[
    {
        "title": "First Missing Positive",
        "question_content": "Given an unsorted integer array nums, return the smallest missing positive integer.\nYou must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space.\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,0]\nOutput: 3\nExplanation: The numbers in the range [1,2] are all in the array.\n\nExample 2:\n\nInput: nums = [3,4,-1,1]\nOutput: 2\nExplanation: 1 is in the array but 2 is missing.\n\nExample 3:\n\nInput: nums = [7,8,9,11,12]\nOutput: 1\nExplanation: The smallest positive integer 1 is missing.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t-231 <= nums[i] <= 231 - 1",
        "solutions": [
            {
                "id": 17071,
                "title": "my-short-c-solution-o-1-space-and-o-n-time",
                "content": "\\nPut each number in its right place.\\n\\nFor example:\\n\\nWhen we find 5, then swap it with A[4].\\n\\nAt last, the first place where its number is not right, return the place + 1.\\n\\n    class Solution\\n    {\\n    public:\\n        int firstMissingPositive(int A[], int n)\\n        {\\n            for(int i = 0; i < n; ++ i)\\n                while(A[i] > 0 && A[i] <= n && A[A[i] - 1] != A[i])\\n                    swap(A[i], A[A[i] - 1]);\\n            \\n            for(int i = 0; i < n; ++ i)\\n                if(A[i] != i + 1)\\n                    return i + 1;\\n            \\n            return n + 1;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n    public:\\n        int firstMissingPositive(int A[], int n)\\n        {\\n            for(int i = 0; i < n; ++ i)\\n                while(A[i] > 0 && A[i] <= n && A[A[i] - 1] != A[i])\\n                    swap(A[i], A[A[i] - 1]);\\n            \\n            for(int i = 0; i < n; ++ i)\\n                if(A[i] != i + 1)\\n                    return i + 1;\\n            \\n            return n + 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 17080,
                "title": "python-o-1-space-o-n-time-solution-with-explanation",
                "content": "     def firstMissingPositive(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n         Basic idea:\\n        1. for any array whose length is l, the first missing positive must be in range [1,...,l+1], \\n            so we only have to care about those elements in this range and remove the rest.\\n        2. we can use the array index as the hash to restore the frequency of each number within \\n             the range [1,...,l+1] \\n        \"\"\"\\n        nums.append(0)\\n        n = len(nums)\\n        for i in range(len(nums)): #delete those useless elements\\n            if nums[i]<0 or nums[i]>=n:\\n                nums[i]=0\\n        for i in range(len(nums)): #use the index as the hash to record the frequency of each number\\n            nums[nums[i]%n]+=n\\n        for i in range(1,len(nums)):\\n            if nums[i]/n==0:\\n                return i\\n        return n",
                "solutionTags": [],
                "code": "     def firstMissingPositive(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n         Basic idea:\\n        1. for any array whose length is l, the first missing positive must be in range [1,...,l+1], \\n            so we only have to care about those elements in this range and remove the rest.\\n        2. we can use the array index as the hash to restore the frequency of each number within \\n             the range [1,...,l+1] \\n        \"\"\"\\n        nums.append(0)\\n        n = len(nums)\\n        for i in range(len(nums)): #delete those useless elements\\n            if nums[i]<0 or nums[i]>=n:\\n                nums[i]=0\\n        for i in range(len(nums)): #use the index as the hash to record the frequency of each number\\n            nums[nums[i]%n]+=n\\n        for i in range(1,len(nums)):\\n            if nums[i]/n==0:\\n                return i\\n        return n",
                "codeTag": "Python3"
            },
            {
                "id": 17214,
                "title": "java-simple-solution-with-documentation",
                "content": "This code takes advantage of two insights: \\n\\n 1. Numbers greater then n can be ignored because the missing integer must be in the range 1..n+1\\n 2. If each cell in the array were to contain positive integers only, we can use the negative of the stored number as a flag to mark something (in this case the flag indicates this index was found in some cell of the array)\\n\\n        public class Solution {\\n        public int firstMissingPositive(int[] nums) {\\n            int n = nums.length;\\n            \\n            // 1. mark numbers (num < 0) and (num > n) with a special marker number (n+1) \\n            // (we can ignore those because if all number are > n then we'll simply return 1)\\n            for (int i = 0; i < n; i++) {\\n                if (nums[i] <= 0 || nums[i] > n) {\\n                    nums[i] = n + 1;\\n                }\\n            }\\n            // note: all number in the array are now positive, and on the range 1..n+1\\n            \\n            // 2. mark each cell appearing in the array, by converting the index for that number to negative\\n            for (int i = 0; i < n; i++) {\\n                int num = Math.abs(nums[i]);\\n                if (num > n) {\\n                    continue;\\n                }\\n                num--; // -1 for zero index based array (so the number 1 will be at pos 0)\\n                if (nums[num] > 0) { // prevents double negative operations\\n                    nums[num] = -1 * nums[num];\\n                }\\n            }\\n            \\n            // 3. find the first cell which isn't negative (doesn't appear in the array)\\n            for (int i = 0; i < n; i++) {\\n                if (nums[i] >= 0) {\\n                    return i + 1;\\n                }\\n            }\\n            \\n            // 4. no positive numbers were found, which means the array contains all numbers 1..n\\n            return n + 1;\\n        }\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int firstMissingPositive(int[] nums) {\\n            int n = nums.length;\\n            \\n            // 1. mark numbers (num < 0) and (num > n) with a special marker number (n+1) \\n            // (we can ignore those because if all number are > n then we'll simply return 1)\\n            for (int i = 0; i < n; i++) {\\n                if (nums[i] <= 0 || nums[i] > n) {\\n                    nums[i] = n + 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 17083,
                "title": "o-1-space-java-solution",
                "content": "The key here is to use swapping to keep constant space and also make use of the length of the array, which means there can be at most n positive integers. So each time we encounter an valid integer, find its correct position and swap. Otherwise we continue.\\n\\n    public class Solution {\\n        public int firstMissingPositive(int[] A) {\\n            int i = 0;\\n            while(i < A.length){\\n                if(A[i] == i+1 || A[i] <= 0 || A[i] > A.length) i++;\\n                else if(A[A[i]-1] != A[i]) swap(A, i, A[i]-1);\\n                else i++;\\n            }\\n            i = 0;\\n            while(i < A.length && A[i] == i+1) i++;\\n            return i+1;\\n        }\\n        \\n        private void swap(int[] A, int i, int j){\\n            int temp = A[i];\\n            A[i] = A[j];\\n            A[j] = temp;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int firstMissingPositive(int[] A) {\\n            int i = 0;\\n            while(i < A.length){\\n                if(A[i] == i+1 || A[i] <= 0 || A[i] > A.length) i++;\\n                else if(A[A[i]-1] != A[i]) swap(A, i, A[i]-1);\\n                else i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 17073,
                "title": "share-my-o-n-time-o-1-space-solution",
                "content": "## Share my O(n)/O(1) solution ##\\n\\n----------\\nThe basic idea is ***for any k positive numbers (duplicates allowed), the first missing positive number must be within [1,k+1]***. The reason is like you put k balls into k+1 bins, there must be a bin empty, the empty bin can be viewed as the missing number. \\n\\n----------\\n\\n 1. Unfortunately, there are 0 and negative numbers in the array, so firstly I think of using partition technique (used in quick sort) to put all positive numbers together in one side. This can be finished in O(n) time, O(1) space. \\n 2. After partition step, you get all the positive numbers lying within A[0,k-1]. Now, According to the basic idea, I infer the first missing number must be within [1,k+1]. I decide to use A[i] (0<=i<=k-1) to indicate whether the number (i+1) exists. But here I still have to main the original information A[i] holds. Fortunately, A[i] are all positive numbers, so I can set them to negative to indicate the existence of (i+1) and I can still use abs(A[i]) to get the original information A[i] holds.\\n 3. After step 2, I can again scan all elements between A[0,k-1] to find the first positive element A[i], that means (i+1) doesn't exist, which is what I want.\\n\\n----------\\n\\n     public int firstMissingPositive(int[] A) {\\n        int n=A.length;\\n        if(n==0)\\n            return 1;\\n        int k=partition(A)+1;\\n        int temp=0;\\n        int first_missing_Index=k;\\n        for(int i=0;i<k;i++){\\n            temp=Math.abs(A[i]);\\n            if(temp<=k)\\n                A[temp-1]=(A[temp-1]<0)?A[temp-1]:-A[temp-1];\\n        }\\n        for(int i=0;i<k;i++){\\n            if(A[i]>0){\\n                first_missing_Index=i;\\n                break;\\n            }\\n        }\\n        return first_missing_Index+1;\\n    }\\n    \\n    public int partition(int[] A){\\n        int n=A.length;\\n        int q=-1;\\n        for(int i=0;i<n;i++){\\n            if(A[i]>0){\\n                q++;\\n                swap(A,q,i);\\n            }\\n        }\\n        return q;\\n    }\\n    \\n    public void swap(int[] A, int i, int j){\\n        if(i!=j){\\n            A[i]^=A[j];\\n            A[j]^=A[i];\\n            A[i]^=A[j];\\n        }\\n    }",
                "solutionTags": [],
                "code": "## Share my O(n)/O(1) solution ##\\n\\n----------\\nThe basic idea is ***for any k positive numbers (duplicates allowed), the first missing positive number must be within [1,k+1]***. The reason is like you put k balls into k+1 bins, there must be a bin empty, the empty bin can be viewed as the missing number. \\n\\n----------\\n\\n 1. Unfortunately, there are 0 and negative numbers in the array, so firstly I think of using partition technique (used in quick sort) to put all positive numbers together in one side. This can be finished in O(n) time, O(1) space. \\n 2. After partition step, you get all the positive numbers lying within A[0,k-1]. Now, According to the basic idea, I infer the first missing number must be within [1,k+1]. I decide to use A[i] (0<=i<=k-1) to indicate whether the number (i+1) exists. But here I still have to main the original information A[i] holds. Fortunately, A[i] are all positive numbers, so I can set them to negative to indicate the existence of (i+1) and I can still use abs(A[i]) to get the original information A[i] holds.\\n 3. After step 2, I can again scan all elements between A[0,k-1] to find the first positive element A[i], that means (i+1) doesn't exist, which is what I want.\\n\\n----------\\n\\n     public int firstMissingPositive(int[] A) {\\n        int n=A.length;\\n        if(n==0)\\n            return 1;\\n        int k=partition(A)+1;\\n        int temp=0;\\n        int first_missing_Index=k;\\n        for(int i=0;i<k;i++){\\n            temp=Math.abs(A[i]);\\n            if(temp<=k)\\n                A[temp-1]=(A[temp-1]<0)?A[temp-1]:-A[temp-1];\\n        }\\n        for(int i=0;i<k;i++){\\n            if(A[i]>0){\\n                first_missing_Index=i;\\n                break;\\n            }\\n        }\\n        return first_missing_Index+1;\\n    }\\n    \\n    public int partition(int[] A){\\n        int n=A.length;\\n        int q=-1;\\n        for(int i=0;i<n;i++){\\n            if(A[i]>0){\\n                q++;\\n                swap(A,q,i);\\n            }\\n        }\\n        return q;\\n    }\\n    \\n    public void swap(int[] A, int i, int j){\\n        if(i!=j){\\n            A[i]^=A[j];\\n            A[j]^=A[i];\\n            A[i]^=A[j];\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 781724,
                "title": "c-simple-5-line-solution-o-n-time-and-o-1-space",
                "content": "We only need to keep track of which ones of the first n positive integers occur in the array. To do this with no extra space, we can treat the array like a boolean array, where sign(arr[i]) indicates whether the i-th positive integer is present or not. First, we replace all non-positive values with n + 1, since we\\'ll only use these indices as storage space. Then, for every one of the first n positive numbers in the array, we turn the value at their corresponding index negative. Finally, all we need to do is check for the first positive value, which will give us the first missing positive. If we find no such index, then all natural numbers up to n are present, so we return n + 1.\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++) if (nums[i] <= 0) nums[i] = n + 1;\\n        for (int i = 0; i < n; i++) if (abs(nums[i]) <= n && nums[abs(nums[i]) - 1] > 0) nums[abs(nums[i]) - 1] *= -1;\\n        for (int i = 0; i < n; i++) if (nums[i] > 0) return i + 1;\\n        return n + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++) if (nums[i] <= 0) nums[i] = n + 1;\\n        for (int i = 0; i < n; i++) if (abs(nums[i]) <= n && nums[abs(nums[i]) - 1] > 0) nums[abs(nums[i]) - 1] *= -1;\\n        for (int i = 0; i < n; i++) if (nums[i] > 0) return i + 1;\\n        return n + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 767105,
                "title": "short-c-o-n-time-o-1-space-steps-explained",
                "content": "**Approach :** \\nIt is evident that the answer lies between ```[1,n+1]```. So bring all the elements to their respective position\\ni.e if the element is 3 bring it to 3rd position or 2nd index.\\nfor example if the array is ```[3,1,-4,7]``` let\\'s say it is nums.\\niterate through the array and **neglect the element if it is greater than n or leass than equal to 0**.\\notherwise bring it to its position by swapping using condition ```while(nums[i]!=nums[nums[i]-1])```.\\n1. at index 0 ```3 != nums[3-1]``` hence swap and the array becomes ```[-4,1,3,7]```\\n2. now at index 0 value is negative hence neglect and move forward.\\n3. at index 1 ```1!=nums[1-1]``` hence swap now the array becomes ```[1,-4,3,7]```\\n4. now at index 1 value is negative hence neglect and move forward.\\n5. at index 2 ```3==nums[3-1]``` the condition is true and 3 is at right position hence neglect and move forward.\\n6. at index 3 value is 7 which is greater than n hence neglect\\n\\nSo the final array is ```[1,-4,3,7]```\\nnow iterate through this array and find the first index for which ```nums[i]!=i+1``` or the element which is not at correct position.\\nthis is the answer so in ```[1,-4,3,7]``` ans is 2.\\n\\n**so you have to swap if** ```nums[i]!=nums[nums[i]-1]``` along with the condition  ```0<nums[i]<=n``` **for all the index.**\\n\\npls Upvote if you like it...\\n\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            while(nums[i]>0 and nums[i]<=n and nums[i]!=nums[nums[i]-1])\\n                swap(nums[i],nums[nums[i]-1]);\\n        }\\n        for(int i=0 ; i<n ; i++) if(nums[i] != i+1) return i+1;\\n        return n+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```[1,n+1]```\n```[3,1,-4,7]```\n```while(nums[i]!=nums[nums[i]-1])```\n```3 != nums[3-1]```\n```[-4,1,3,7]```\n```1!=nums[1-1]```\n```[1,-4,3,7]```\n```3==nums[3-1]```\n```[1,-4,3,7]```\n```nums[i]!=i+1```\n```[1,-4,3,7]```\n```nums[i]!=nums[nums[i]-1]```\n```0<nums[i]<=n```\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            while(nums[i]>0 and nums[i]<=n and nums[i]!=nums[nums[i]-1])\\n                swap(nums[i],nums[nums[i]-1]);\\n        }\\n        for(int i=0 ; i<n ; i++) if(nums[i] != i+1) return i+1;\\n        return n+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872448,
                "title": "python-o-n-solution-with-constant-space-explained-with-clear-train-of-thoughts",
                "content": "\\u2014\\u2014Jump to the final code if you\\'re easly bored, down below!\\n\\nOk, you\\'re still here eh. Here are the train of thoughts to arrive to the final solution:\\n\\n* The answer is always between `1` to `length of nums + 1`. Why? Because the biggest positive integer we can put as answer for the input of length n, is when the input is `[1, 2, 3, ..., n]`, in that case the answer is `n+1`. Otherwise, if the input is not exactly as mentioned (in any order), then the answer must be a positive integer that is less than `n+1`. \\n\\n* Given that the answer is limited to said range, then we can simply solve this with linear time and linear space. We can create a `flag` booleans that indicate whether an `index` is appearing in the `nums` or not. See simple code below!\\n```Python\\nflags = [False] * len(nums)\\n\\nfor num in nums:\\n\\tif num > 0:\\n\\t\\tflags[num-1] = True // notice that we -1, so that the answer set 1..n becomes 0-indexed 0..n-1\\n\\t\\t\\nfor index in range(len(flags)):\\n\\tif flags[index] == False:\\n\\t\\treturn index + 1\\n\\t\\t\\nreturn len(nums) + 1 // happens when all flags are true\\n```\\n\\n* Now, how do we improve this to be a better solution with constant additional space? In other words, how to get rid of the additional booleans? You can probably guess it already. Yes by using the original `nums` array as flags. \\n\\n* Let say we flag it by changing the value in `index` to `None` if it\\'s appearing in `nums`. Problem? Yes, we still need to retain the original values in `nums`, because as we loop over the `nums` to flag the `index`, we will definitely get in trouble if the `index` we\\'re flagging hasn\\'t been evaluated yet. Take an example of `[3,1,2]` (which supposed to have the answer `4`), here is how the `nums` array is being evaluated, in each loop-step:\\n** Before loop: `[3,1,2]`\\n** Loop at index 0: `[3, 1, None]`. The `index` that `3` points to is index `2`, therefore the value becomes `None`.  This is the part where we change index `2`, while index `2` itself hasn\\'t been evaluated yet.\\n** Loop at index 1: `[None, 1, None]`. The `index` that `1` points to is index `0`, therefore the value becomes `None`.\\n** Loop at index 2: `[None, 1, None]`. At this step, it\\'s doing nothing because the original value of `2` has already been changed to `None`, and we have no way to flag index `1` as `None`.\\n\\n*  So how do we flag elements in `nums` while also retaining original `value` **that matters**? Notice I mentioned \\'that matters\\', because we only care about positive integers. We can simply discard anything that is not positive integers. And because of that, we can use positive and negative value as flag\\u2014multiply the value with `-1` to flag it so it becomes negative. So positive means hasn\\'t been flagged, negative means has been flagged. Whether it\\'s positive or negative, we can get the original value with `abs`. So for above example, the correct steps would be:\\n** Before loop: `[3, 1, 2]`\\n** Loop at index 0: `[3, 1, -2]`\\n** Loop at index 1: `[-3, 1, -2]`\\n** Loop at index 2: `[-3, -1, -2]`\\nAnd finally when we\\'re looking for the answer, we find that all the values are negative (flagged), therefore the answer is `4`.\\n\\n* Final thoughts: what about those zeros and negative nums??? Simply change them to 0 before entering the main algorithm explained above. We just need to be careful not to multiply those zeros to `-1` when flagging, instead change it to something like `-inf` (as long as it\\'s a negative value, then it\\'s flagged) \\n\\nHere is the final full code:\\n```python\\ndef firstMissingPositive(self, nums: List[int]) -> int:\\n\\tfor i,num in enumerate(nums):\\n\\t\\tif num <= 0:\\n\\t\\t\\tnums[i] = 0\\n\\n\\tfor i,num in enumerate(nums):\\n\\t\\tindex = abs(num)-1\\n\\t\\tif index >= 0 and index < len(nums):\\n\\t\\t\\tif nums[index] == 0:\\n\\t\\t\\t\\tnums[index] = -inf\\n\\t\\t\\telif nums[index] > 0: // we dont want to make negative to be positive again, when its duplicated num\\n\\t\\t\\t\\tnums[index] *= -1\\n\\n\\tfor index,num in enumerate(nums):\\n\\t\\tif num >= 0:\\n\\t\\t\\treturn index + 1\\n\\n\\treturn len(nums) + 1\\n```\\n\\nTime Complexity: O(N)\\nSpace Complexity: O(1)\\n\\nPlease upvote if you find this useful, comment if you find any improvement points!\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```Python\\nflags = [False] * len(nums)\\n\\nfor num in nums:\\n\\tif num > 0:\\n\\t\\tflags[num-1] = True // notice that we -1, so that the answer set 1..n becomes 0-indexed 0..n-1\\n\\t\\t\\nfor index in range(len(flags)):\\n\\tif flags[index] == False:\\n\\t\\treturn index + 1\\n\\t\\t\\nreturn len(nums) + 1 // happens when all flags are true\\n```\n```python\\ndef firstMissingPositive(self, nums: List[int]) -> int:\\n\\tfor i,num in enumerate(nums):\\n\\t\\tif num <= 0:\\n\\t\\t\\tnums[i] = 0\\n\\n\\tfor i,num in enumerate(nums):\\n\\t\\tindex = abs(num)-1\\n\\t\\tif index >= 0 and index < len(nums):\\n\\t\\t\\tif nums[index] == 0:\\n\\t\\t\\t\\tnums[index] = -inf\\n\\t\\t\\telif nums[index] > 0: // we dont want to make negative to be positive again, when its duplicated num\\n\\t\\t\\t\\tnums[index] *= -1\\n\\n\\tfor index,num in enumerate(nums):\\n\\t\\tif num >= 0:\\n\\t\\t\\treturn index + 1\\n\\n\\treturn len(nums) + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 17161,
                "title": "python-o-n-and-o-nlgn-solutions",
                "content": "        \\n    # O(n) time\\n    def firstMissingPositive(self, nums):\\n        for i in xrange(len(nums)):\\n            while 0 <= nums[i]-1 < len(nums) and nums[nums[i]-1] != nums[i]:\\n                tmp = nums[i]-1\\n                nums[i], nums[tmp] = nums[tmp], nums[i]\\n        for i in xrange(len(nums)):\\n            if nums[i] != i+1:\\n                return i+1\\n        return len(nums)+1\\n        \\n    # O(nlgn) time\\n    def firstMissingPositive(self, nums):\\n        nums.sort()\\n        res = 1\\n        for num in nums:\\n            if num == res:\\n                res += 1\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    # O(n) time\\n    def firstMissingPositive(self, nums):\\n        for i in xrange(len(nums)):\\n            while 0 <= nums[i]-1 < len(nums) and nums[nums[i]-1] != nums[i]:\\n                tmp = nums[i]-1\\n                nums[i], nums[tmp] = nums[tmp], nums[i]\\n        for i in xrange(len(nums)):\\n            if nums[i] != i+1:\\n                return i+1\\n        return len(nums)+1\\n        \\n    # O(nlgn) time\\n    def firstMissingPositive(self, nums):\\n        nums.sort()\\n        res = 1\\n        for num in nums:\\n            if num == res:\\n                res += 1\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 858526,
                "title": "cyclic-sort-explained",
                "content": "All the questions where we need to find the repeating numbers, or missing numbers can easily be solved with the help of a pattern that is cyclic sort. In this pattern we simply place the elements of the array on their positions( or at least try to ), like 1 should be at 1st position and 2 at the second position, and then we iterate again and check if for any index we have an element whose value is not equal to index + 1, then that is the missing number.\\n\\nYou can follow this link to learn [more](https://emre.me/coding-patterns/cyclic-sort/)\\n\\nIn this question we can simply ignore the -ve elements as we only need to find the smallest positive element, so we ignore elements that are less than 0 and greater than arrays length and swap only if the element is not at its correct posiition. Then we iterate again and find the missing number and return it.\\n\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int i = 0;\\n        while( i < nums.length){\\n            if(nums[i] > 0 && nums[i] <= nums.length && nums[i] != nums[nums[i] - 1]){\\n                swap(nums,i,nums[i] - 1);\\n            }else{\\n                i++;\\n            }\\n        }\\n        for(i = 0;i<nums.length;i++){\\n            if(nums[i] != i + 1){\\n                return i + 1;\\n            }\\n        }\\n        return nums.length + 1;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int i = 0;\\n        while( i < nums.length){\\n            if(nums[i] > 0 && nums[i] <= nums.length && nums[i] != nums[nums[i] - 1]){\\n                swap(nums,i,nums[i] - 1);\\n            }else{\\n                i++;\\n            }\\n        }\\n        for(i = 0;i<nums.length;i++){\\n            if(nums[i] != i + 1){\\n                return i + 1;\\n            }\\n        }\\n        return nums.length + 1;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17126,
                "title": "beat-100-fast-elegant-java-index-based-solution-with-explanation",
                "content": "The basic idea is to traversal and try to move the current value to position whose index is exactly the value (swap them). Then travelsal again to find the first unusal value, which can not be corresponding to its index.\\n\\n    public int firstMissingPositive(int[] nums) {\\n\\n\\t\\tint i = 0, n = nums.length;\\n\\t\\twhile (i < n) {\\n            // If the current value is in the range of (0,length) and it's not at its correct position, \\n            // swap it to its correct position.\\n            // Else just continue;\\n\\t\\t\\tif (nums[i] >= 0 && nums[i] < n && nums[nums[i]] != nums[i])\\n\\t\\t\\t\\tswap(nums, i, nums[i]);\\n\\t\\t\\telse\\n\\t\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\tint k = 1;\\n\\n        // Check from k=1 to see whether each index and value can be corresponding.\\n\\t\\twhile (k < n && nums[k] == k)\\n\\t\\t\\tk++;\\n\\n        // If it breaks because of empty array or reaching the end. K must be the first missing number.\\n\\t\\tif (n == 0 || k < n)\\n\\t\\t\\treturn k;\\n\\t\\telse   // If k is hiding at position 0, K+1 is the number. \\n\\t\\t\\treturn nums[0] == k ? k + 1 : k;\\n\\n\\t}\\n\\n\\tprivate void swap(int[] nums, int i, int j) {\\n\\t\\tint temp = nums[i];\\n\\t\\tnums[i] = nums[j];\\n\\t\\tnums[j] = temp;\\n\\t}",
                "solutionTags": [],
                "code": "The basic idea is to traversal and try to move the current value to position whose index is exactly the value (swap them). Then travelsal again to find the first unusal value, which can not be corresponding to its index.\\n\\n    public int firstMissingPositive(int[] nums) {\\n\\n\\t\\tint i = 0, n = nums.length;\\n\\t\\twhile (i < n) {\\n            // If the current value is in the range of (0,length) and it's not at its correct position, \\n            // swap it to its correct position.\\n            // Else just continue;\\n\\t\\t\\tif (nums[i] >= 0 && nums[i] < n && nums[nums[i]] != nums[i])\\n\\t\\t\\t\\tswap(nums, i, nums[i]);\\n\\t\\t\\telse\\n\\t\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\tint k = 1;\\n\\n        // Check from k=1 to see whether each index and value can be corresponding.\\n\\t\\twhile (k < n && nums[k] == k)\\n\\t\\t\\tk++;\\n\\n        // If it breaks because of empty array or reaching the end. K must be the first missing number.\\n\\t\\tif (n == 0 || k < n)\\n\\t\\t\\treturn k;\\n\\t\\telse   // If k is hiding at position 0, K+1 is the number. \\n\\t\\t\\treturn nums[0] == k ? k + 1 : k;\\n\\n\\t}\\n\\n\\tprivate void swap(int[] nums, int i, int j) {\\n\\t\\tint temp = nums[i];\\n\\t\\tnums[i] = nums[j];\\n\\t\\tnums[j] = temp;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 17168,
                "title": "a-very-nice-solution-from-ants-aasma-stackoverflow",
                "content": "time complexity is O(N) and space complexity is O(1). <br>\\nLink: http://stackoverflow.com/questions/1586858/find-the-smallest-integer-not-in-a-list <br>\\nPosted by Ants Aasma on Oct 20 '09.\\n\\nThe code is pasted here: <br>\\n\\n    #Pass 1, move every value to the position of its value\\n    for cursor in range(N): \\n        target = array[cursor]\\n        while target < N and target != array[target]:\\n            new_target = array[target]\\n            array[target] = target\\n            target = new_target\\n    \\n    #Pass 2, find first location where the index doesn't match the value\\n    for cursor in range(N):\\n        if array[cursor] != cursor:\\n            return cursor\\n    return N",
                "solutionTags": [],
                "code": "time complexity is O(N) and space complexity is O(1). <br>\\nLink: http://stackoverflow.com/questions/1586858/find-the-smallest-integer-not-in-a-list <br>\\nPosted by Ants Aasma on Oct 20 '09.\\n\\nThe code is pasted here: <br>\\n\\n    #Pass 1, move every value to the position of its value\\n    for cursor in range(N): \\n        target = array[cursor]\\n        while target < N and target != array[target]:\\n            new_target = array[target]\\n            array[target] = target\\n            target = new_target\\n    \\n    #Pass 2, find first location where the index doesn't match the value\\n    for cursor in range(N):\\n        if array[cursor] != cursor:\\n            return cursor\\n    return N",
                "codeTag": "Unknown"
            },
            {
                "id": 3765193,
                "title": "cycle-sort-o-n-o-1-easy-java-solution-detailed-explanation-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a hard question, because it is hidden in the question, that cycle sort will be used in solving this. Once, you can see why cycle sort will be used and how it will be used, this becomes easy. :)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo, basically we are gonna apply cycle sort, but we will ignore negative elements, because positive element is asked in the question. Also, we will ignore all those elements who values are greater than the size of the array. In this way, the first element in the array which is not present in its correct position (index), will be the answer.\\nWhat I mean by correct position is that, in cycle sort, in this question, if we follow the above approach, then index 0 will have element whose value is 1, index 1 will have 2, index 2 will have 3 and so on, and the first element to break this rule, that index, plus 1 will be our answer, because at that index the correct element which was to exist there was an element whose value is index + 1, but if there is some incorrect element present, then index + 1 element is the first missing positive and hence it is the answer.\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n    \\n        //the first two conditions in the if statement take care \\n        //that negatives and elements greater than the size of \\n        //the array are ignored, while applying cycle sort, and \\n        //rest is the similar code of cycle sort\\n\\n        int i = 0;\\n        while(i < nums.length) {\\n            int correct = nums[i] - 1;\\n            if(nums[i] <= nums.length && nums[i] > 0 && nums[i] != nums[correct]) {\\n\\n                int temp = nums[i];\\n                nums[i] = nums[correct];\\n                nums[correct] = temp;\\n            }\\n            else {\\n                i++;\\n            }\\n        }\\n\\n        int count = 0;\\n\\n    //after cycle sort has been applied, we will find the first element\\n    //which is not at the correct index, and return that index + 1\\n\\n        for(int j = 0; j < nums.length; j++) {\\n\\n            if(nums[j] != j + 1) {\\n                return j + 1;\\n            }\\n        }\\n\\n    //if every element is at its correct index, then obviously the first\\n    //missing positive integer is nums.length + 1\\n\\n        return nums.length + 1;\\n    }\\n}\\n```\\n\\n![cat.jpeg](https://assets.leetcode.com/users/images/534c581c-ce0e-4b09-8c2e-40e316fe3417_1689353156.4622288.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n    \\n        //the first two conditions in the if statement take care \\n        //that negatives and elements greater than the size of \\n        //the array are ignored, while applying cycle sort, and \\n        //rest is the similar code of cycle sort\\n\\n        int i = 0;\\n        while(i < nums.length) {\\n            int correct = nums[i] - 1;\\n            if(nums[i] <= nums.length && nums[i] > 0 && nums[i] != nums[correct]) {\\n\\n                int temp = nums[i];\\n                nums[i] = nums[correct];\\n                nums[correct] = temp;\\n            }\\n            else {\\n                i++;\\n            }\\n        }\\n\\n        int count = 0;\\n\\n    //after cycle sort has been applied, we will find the first element\\n    //which is not at the correct index, and return that index + 1\\n\\n        for(int j = 0; j < nums.length; j++) {\\n\\n            if(nums[j] != j + 1) {\\n                return j + 1;\\n            }\\n        }\\n\\n    //if every element is at its correct index, then obviously the first\\n    //missing positive integer is nums.length + 1\\n\\n        return nums.length + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17135,
                "title": "java-solution-with-integers-encode-trick-explained",
                "content": "This is not the most concise solution but it has one trick that may be useful for many beginners that allows to encode two integers into one with possibility to decode it to both integers back. Once you know it you will always use it as it allows to avoid tuples of integers (as java lacks such structure in its libraries) and use just one integer to represent two.\\n\\nSo, if we have two integers `k` and `m` and `m` is always less than some `n` - we can encode both into one integer using formula:\\n\\n    r = k * n + m\\n    (m < n)\\n\\nand now to retrieve them use the following:\\n\\n    k = r / n\\n    m = r % n\\n\\nAnd just to repeat: this trick is possible only if `m` is strictly less than `n`\\n\\nUsing this trick we can solve many interview tasks that require constant space and have some array which contains integers less than size or array `n`. If this array requires some extra information for every item, but we cannot loose the initial item value - this can be solved either creating new array (simple) or just encoding initial value and new value directly in the array.\\n\\n**Turning back to the task:** \\n\\nWe want to \"seriallize\" all values to their indices. So \"1\" will come to `nums[0]`, \"2\" - `nums[1]` etc. After this we can easily find the \"gap\". This is an easy task if we could use extra memory for another array. But we cannot. So we can use the \"encoding\" scheme offered above:\\n\\n1.clean every non-relevant item from the array to match the restriction `m < n`:\\n \\n\\n    int n = nums.length;\\n    for (int i = 0; i < n; i++) {\\n         if (nums[i] <= 0 || nums[i] > n) nums[i] = 0;\\n    }\\n2.Encode all items to their matching positions:\\n\\n    int m = n + 1;\\n    for (int i = 0; i < n; i++) {\\n        // retrieve the value that initially was at index i (it could be overwritten by encoding)\\n        int prev = nums[i] % m;\\n        if (prev > 0) \\n            // encode it using formula k * n + m, where for 'm' we also use decoding schema\\n            nums[prev - 1] = (prev * m) + nums[prev - 1] % m;\\n    }\\n\\n3.Find the gap:\\n\\n    for (int i = 0; i < n; i++) {\\n        if (nums[i] / m != i + 1) return i + 1;\\n    }\\n\\nAll in one:\\n\\n    public int firstMissingPositive(int[] nums) {\\n        int n = nums.length;\\n        int m = n + 1;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] <= 0 || nums[i] > n) nums[i] = 0;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            int prev = nums[i] % m;\\n            if (prev > 0) \\n                nums[prev - 1] = (prev * m) + nums[prev - 1] % m;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] / m != i + 1) return i + 1;\\n        }\\n        return m;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "This is not the most concise solution but it has one trick that may be useful for many beginners that allows to encode two integers into one with possibility to decode it to both integers back. Once you know it you will always use it as it allows to avoid tuples of integers (as java lacks such structure in its libraries) and use just one integer to represent two.\\n\\nSo, if we have two integers `k` and `m` and `m` is always less than some `n` - we can encode both into one integer using formula:\\n\\n    r = k * n + m\\n    (m < n)\\n\\nand now to retrieve them use the following:\\n\\n    k = r / n\\n    m = r % n\\n\\nAnd just to repeat: this trick is possible only if `m` is strictly less than `n`\\n\\nUsing this trick we can solve many interview tasks that require constant space and have some array which contains integers less than size or array `n`. If this array requires some extra information for every item, but we cannot loose the initial item value - this can be solved either creating new array (simple) or just encoding initial value and new value directly in the array.\\n\\n**Turning back to the task:** \\n\\nWe want to \"seriallize\" all values to their indices. So \"1\" will come to `nums[0]`, \"2\" - `nums[1]` etc. After this we can easily find the \"gap\". This is an easy task if we could use extra memory for another array. But we cannot. So we can use the \"encoding\" scheme offered above:\\n\\n1.clean every non-relevant item from the array to match the restriction `m < n`:\\n \\n\\n    int n = nums.length;\\n    for (int i = 0; i < n; i++) {\\n         if (nums[i] <= 0 || nums[i] > n) nums[i] = 0;\\n    }\\n2.Encode all items to their matching positions:\\n\\n    int m = n + 1;\\n    for (int i = 0; i < n; i++) {\\n        // retrieve the value that initially was at index i (it could be overwritten by encoding)\\n        int prev = nums[i] % m;\\n        if (prev > 0) \\n            // encode it using formula k * n + m, where for 'm' we also use decoding schema\\n            nums[prev - 1] = (prev * m) + nums[prev - 1] % m;\\n    }\\n\\n3.Find the gap:\\n\\n    for (int i = 0; i < n; i++) {\\n        if (nums[i] / m != i + 1) return i + 1;\\n    }\\n\\nAll in one:\\n\\n    public int firstMissingPositive(int[] nums) {\\n        int n = nums.length;\\n        int m = n + 1;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] <= 0 || nums[i] > n) nums[i] = 0;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            int prev = nums[i] % m;\\n            if (prev > 0) \\n                nums[prev - 1] = (prev * m) + nums[prev - 1] % m;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] / m != i + 1) return i + 1;\\n        }\\n        return m;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 17286,
                "title": "my-c-solution-4-ms",
                "content": "    class Solution {\\n    public:\\n        int firstMissingPositive(vector<int>& nums) {\\n            for(int i=0; i<nums.size(); i++){\\n                if(i+1==nums[i]) continue;\\n                int x = nums[i];\\n                while(x>=1 && x<=nums.size() && x!=nums[x-1]){\\n                    swap(x, nums[x-1]);\\n                }\\n            }\\n            for(int i=0; i<nums.size(); i++){\\n                if(i+1!=nums[i])    return i+1;\\n            }\\n            return nums.size()+1;\\n        }\\n    };\\n\\nSince we can not use extra space, so thinking about using the nums vector itself to record a positive number occurred.",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int firstMissingPositive(vector<int>& nums) {\\n            for(int i=0; i<nums.size(); i++){\\n                if(i+1==nums[i]) continue;\\n                int x = nums[i];\\n                while(x>=1 && x<=nums.size() && x!=nums[x-1]){\\n                    swap(x, nums[x-1]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 17204,
                "title": "o-n-time-o-1-space-c",
                "content": "Idea is to swap each positive integer you encounter to its \"rightful\" place at index (x-1) where x is the integer. It's O(n) because you visit each integer in at most 2 unique loop iterations. \\n\\n    class Solution {\\n    public:\\n        int firstMissingPositive(int A[], int n) {\\n            int i,j;\\n            for(i=0;i<n;i++){\\n                int cur=A[i];\\n                // if in place or non-pos or out of bounds, skip.\\n                if(cur==i+1||cur<=0||cur>n)continue;\\n                swap(A[i],A[cur-1]);\\n                // if not the same, then reprocess it.\\n                if(A[i]!=A[cur-1])\\n                    i--;\\n            }\\n            \\n            for(i=0;i<n;i++)\\n                if(A[i]!=i+1) \\n                    return i+1;\\n            return n+1;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int firstMissingPositive(int A[], int n) {\\n            int i,j;\\n            for(i=0;i<n;i++){\\n                int cur=A[i];\\n                // if in place or non-pos or out of bounds, skip.\\n                if(cur==i+1||cur<=0||cur>n)continue;\\n                swap(A[i],A[cur-1]);\\n                // if not the same, then reprocess it.\\n                if(A[i]!=A[cur-1])\\n                    i--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 871665,
                "title": "python-o-n-solution-without-additional-memory-explained",
                "content": "Notice, that first missinig positive will always be in range `1,2,...n,n+1`, where `n` is length of `nums`. Let us rearrange numbers, putting each number on its place: number `i` on place `i-1` (because indexes start with `0`): let us iterate over our numbers and change two numbers if one of them not on its place: we break if number not in range `1,...,n` or if we are trying to put number on the place, which is already occupied with this place (because we have infinite loop in this case)\\n\\nWhen we iterate all numbers we find for number which is not on its place, using `i == nums[i] - 1`. It can happen that all numbers between `1` and `n` are here, so I add `[0]` to the end. Finally, I found index of `False` in this array: it will be our number.\\n\\n**Complexity**: even though we have `while` loop inside `for` loop, complexity will be `O(n)`: on each step we put at least one number to its proper place. Additional space complexity is `O(1)`, however we modify our `nums`.\\n\\nThis solution is very similar to problem **442. Find All Duplicates in an Array**, see my detailed solution here https://leetcode.com/problems/find-all-duplicates-in-an-array/discuss/775738/Python-2-solutions-with-O(n)-timeO(1)-space-explained\\n\\n```\\nclass Solution:\\n    def firstMissingPositive(self, nums):\\n        n = len(nums)\\n        for i in range(n):\\n            while nums[i]-1 in range(n) and nums[i] != nums[nums[i]-1]:\\n                nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]\\n                \\n        return next((i + 1 for i, num in enumerate(nums) if num != i + 1), n + 1)   \\n```\\n\\nThanks to **QwerMike** for pointing out that my last line were using `O(n)` memory and he kindly suggested to use iterators instead, code is corrected now.\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums):\\n        n = len(nums)\\n        for i in range(n):\\n            while nums[i]-1 in range(n) and nums[i] != nums[nums[i]-1]:\\n                nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]\\n                \\n        return next((i + 1 for i, num in enumerate(nums) if num != i + 1), n + 1)   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340607,
                "title": "look-at-this-solution-you-will-not-say-this-was-hard-one-uses-extra-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/6575114b-a664-4c5b-8acb-b74de3f0ff4e_1679763882.7132435.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        int ans[] = new int[nums.length + 1];\\n\\n        // mark the presence of each positive integer in the input array\\n        for(int i = 0; i < nums.length; i++){\\n            int val = nums[i];\\n            if(val > 0 && val <= nums.length) { // check to avoid index out of bounds\\n                ans[val] = 1;\\n            }\\n        }\\n\\n        // find the smallest missing positive integer by checking the array of marked integers\\n        for(int i = 1; i < ans.length; i++){\\n            if(ans[i] == 0){\\n                return i;\\n            }\\n        }\\n\\n        // if no missing positive integer is found, return the length of the array\\n    return ans.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        int ans[] = new int[nums.length + 1];\\n\\n        // mark the presence of each positive integer in the input array\\n        for(int i = 0; i < nums.length; i++){\\n            int val = nums[i];\\n            if(val > 0 && val <= nums.length) { // check to avoid index out of bounds\\n                ans[val] = 1;\\n            }\\n        }\\n\\n        // find the smallest missing positive integer by checking the array of marked integers\\n        for(int i = 1; i < ans.length; i++){\\n            if(ans[i] == 0){\\n                return i;\\n            }\\n        }\\n\\n        // if no missing positive integer is found, return the length of the array\\n    return ans.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 927112,
                "title": "three-js-solutions",
                "content": "```\\nvar firstMissingPositive = function(nums) {\\n    nums = Array.from(new Set(nums));\\n    nums.sort((a,b) => a-b).filter(num => num > 0);\\n    let j = 1;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (j == nums[i]) j++;\\n        else return j;\\n    }\\n    return j;\\n    // Time Complexity: O(nlog(n))\\n    // Space Complexity: O(n)\\n};\\n```\\n\\n```\\nvar firstMissingPositive = function(nums) {    \\n    let m = new Map();\\n    for (let i = 0; i < nums.length; i++) {\\n        m.set(nums[i], 1);\\n    }\\n    for (let i = 1; i <= nums.length; i++) {\\n        if (!m.has(i)) return i;\\n    }\\n    return nums.length + 1; // the array is [1,2,...,n]\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(n)\\n    /*\\n    The worst case (the first missing positive being the greatest) is\\n    when the array is [1,2..,n]. Therefore, in all other cases except this case, \\n    the first missing positive number is less than or equal to n (nums.length).\\n    */\\n}\\n```\\n\\n```\\nvar firstMissingPositive = function(nums) {\\n    // First, we need to understand that the first missing positive number is less than or equal to n (length of array) except for one case. The explanation is in the above.\\n    // We will position every positive integer in the array at its corresponding index\\n    // ex) 1 at index 0, 2 at index 1, 3 at index 2\\n    // In this way, the array can position all integers that are less than or equal to n at their corresponding indices without changing the size of given array.\\n    // Therefore, we can find the first missing positive integer by scanning through the array.\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        let idx = nums[i]-1;\\n        if (i == idx || nums[i] == nums[idx]) continue; // already positioned or nums[i] is a duplicate\\n        if (idx >= 0 && idx <= nums.length - 1) {\\n            [nums[i], nums[idx]] = [nums[idx], nums[i]];\\n            i--; // check the swapped number\\n        }\\n    }\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        if (i+1 == nums[i]) continue;\\n        else return i+1; // the next positive number which is i+1 doesn\\'t exist in the array\\n    }\\n    \\n    return nums.length + 1; // the array is [1,2,...,n]\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(1)\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar firstMissingPositive = function(nums) {\\n    nums = Array.from(new Set(nums));\\n    nums.sort((a,b) => a-b).filter(num => num > 0);\\n    let j = 1;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (j == nums[i]) j++;\\n        else return j;\\n    }\\n    return j;\\n    // Time Complexity: O(nlog(n))\\n    // Space Complexity: O(n)\\n};\\n```\n```\\nvar firstMissingPositive = function(nums) {    \\n    let m = new Map();\\n    for (let i = 0; i < nums.length; i++) {\\n        m.set(nums[i], 1);\\n    }\\n    for (let i = 1; i <= nums.length; i++) {\\n        if (!m.has(i)) return i;\\n    }\\n    return nums.length + 1; // the array is [1,2,...,n]\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(n)\\n    /*\\n    The worst case (the first missing positive being the greatest) is\\n    when the array is [1,2..,n]. Therefore, in all other cases except this case, \\n    the first missing positive number is less than or equal to n (nums.length).\\n    */\\n}\\n```\n```\\nvar firstMissingPositive = function(nums) {\\n    // First, we need to understand that the first missing positive number is less than or equal to n (length of array) except for one case. The explanation is in the above.\\n    // We will position every positive integer in the array at its corresponding index\\n    // ex) 1 at index 0, 2 at index 1, 3 at index 2\\n    // In this way, the array can position all integers that are less than or equal to n at their corresponding indices without changing the size of given array.\\n    // Therefore, we can find the first missing positive integer by scanning through the array.\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        let idx = nums[i]-1;\\n        if (i == idx || nums[i] == nums[idx]) continue; // already positioned or nums[i] is a duplicate\\n        if (idx >= 0 && idx <= nums.length - 1) {\\n            [nums[i], nums[idx]] = [nums[idx], nums[i]];\\n            i--; // check the swapped number\\n        }\\n    }\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        if (i+1 == nums[i]) continue;\\n        else return i+1; // the next positive number which is i+1 doesn\\'t exist in the array\\n    }\\n    \\n    return nums.length + 1; // the array is [1,2,...,n]\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(1)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1351917,
                "title": "accepted-solution-for-swift",
                "content": "```swift\\nclass Solution {\\n    func firstMissingPositive(_ n: [Int]) -> Int {\\n        let set = Set(n)\\n        for i in 0..<n.count where !set.contains(i + 1) { return i + 1 }\\n        return n.count + 1\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 3 tests, with 0 failures (0 unexpected) in 0.006 (0.008) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.firstMissingPositive([1,2,0])\\n        XCTAssertEqual(value, 3)\\n    }\\n    \\n    func test1() {\\n        let value = solution.firstMissingPositive([3,4,-1,1])\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    func test2() {\\n        let value = solution.firstMissingPositive([7,8,9,11,12])\\n        XCTAssertEqual(value, 1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func firstMissingPositive(_ n: [Int]) -> Int {\\n        let set = Set(n)\\n        for i in 0..<n.count where !set.contains(i + 1) { return i + 1 }\\n        return n.count + 1\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.firstMissingPositive([1,2,0])\\n        XCTAssertEqual(value, 3)\\n    }\\n    \\n    func test1() {\\n        let value = solution.firstMissingPositive([3,4,-1,1])\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    func test2() {\\n        let value = solution.firstMissingPositive([7,8,9,11,12])\\n        XCTAssertEqual(value, 1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872224,
                "title": "java-python-supper-clean-concise-time-o-n-space-o-1",
                "content": "**Idea:**\\n1. Marks `zero or negative numbers` as `positive numbers`.\\n2. Mark number `x` as visited by marking `nums[x]` as negative, by using `(x-1)` we can use index 0 of `nums` array.\\n3. Interate from `0..n-1`, if `nums[i] > 0` then it means the number `i+1` is the smallest positive number which is missing.\\n\\n**Java**\\n```java\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int n = nums.length, INF = n + 1;\\n        \\n        for (int i = 0; i < n; i++)\\n            if (nums[i] <= 0)\\n                nums[i] = INF; // marks zero or negative numbers as infinitive positive numbers\\n                \\n        for (int i = 0; i < n; i++) {\\n            int x = Math.abs(nums[i]) - 1; // use index start with zero\\n            if (x < n)\\n                nums[x] = -Math.abs(nums[x]); // mark `x` as visited by marking `nums[x]` as negative\\n        }\\n               \\n        for (int i = 0; i < n; i++)\\n            if (nums[i] > 0) // if nums[i] is positive -> number (i+1) is not visited.\\n                return i + 1;\\n        return n + 1;\\n    }\\n}\\n```\\n\\n**Python**\\n```python\\nclass Solution(object):\\n    def firstMissingPositive(self, nums):\\n        n = len(nums)\\n        INF = n + 1\\n    \\n        for i in range(n):\\n            if nums[i] <= 0:\\n                nums[i] = INF # marks zero or negative numbers as infinitive positive numbers\\n                \\n        for i in range(n):\\n            x = abs(nums[i]) - 1 # use index start with zero\\n            if x < n:\\n                nums[x] = -abs(nums[x]) # mark `x` as visited by marking `nums[x]` as negative\\n                    \\n        for i in range(n):\\n            if nums[i] > 0: # if nums[i] is positive -> number (i+1) is not visited.\\n                return i + 1\\n        return n + 1\\n```\\n\\nPlease give a vote if this post is useful to you.\\nHappy Coding!",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int n = nums.length, INF = n + 1;\\n        \\n        for (int i = 0; i < n; i++)\\n            if (nums[i] <= 0)\\n                nums[i] = INF; // marks zero or negative numbers as infinitive positive numbers\\n                \\n        for (int i = 0; i < n; i++) {\\n            int x = Math.abs(nums[i]) - 1; // use index start with zero\\n            if (x < n)\\n                nums[x] = -Math.abs(nums[x]); // mark `x` as visited by marking `nums[x]` as negative\\n        }\\n               \\n        for (int i = 0; i < n; i++)\\n            if (nums[i] > 0) // if nums[i] is positive -> number (i+1) is not visited.\\n                return i + 1;\\n        return n + 1;\\n    }\\n}\\n```\n```python\\nclass Solution(object):\\n    def firstMissingPositive(self, nums):\\n        n = len(nums)\\n        INF = n + 1\\n    \\n        for i in range(n):\\n            if nums[i] <= 0:\\n                nums[i] = INF # marks zero or negative numbers as infinitive positive numbers\\n                \\n        for i in range(n):\\n            x = abs(nums[i]) - 1 # use index start with zero\\n            if x < n:\\n                nums[x] = -abs(nums[x]) # mark `x` as visited by marking `nums[x]` as negative\\n                    \\n        for i in range(n):\\n            if nums[i] > 0: # if nums[i] is positive -> number (i+1) is not visited.\\n                return i + 1\\n        return n + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 871646,
                "title": "first-missing-positive-c-two-solutions-o-n-time-100",
                "content": "<b>The problem</b>\\nHonestly, it was surpising to me to find out that this problem is marked as hard.\\nWhen I saw the problem, I thought it was probably easy or medium difficulty.\\nI had done some similar problems previously, that required me to use the original array and negate numbers at indices according to some other values.\\nI guess it can appear hard to solve it in linear time, if you miss the clue.\\n\\n<b>Approach</b>\\nThe main thing here is to really understand the question. They are looking for the first positive integer, of <b>ALL</b> positive integers, that does not exist in the given array.\\nThis implies that the first missing number can be in range from ```1``` to ```N``` (size of the input).\\nNow we only have to figure out which one is the first in the sequence that is not present in the array.\\n\\n<b>Solution 1</b>\\nCreate a new array of input size, with all values set to ```-1```.\\nFor each value in the original array, set ```newArray[value - 1]``` to ```1```, if the value is within the ```1``` - ```N``` range.\\nNow we go through the new array and look for the first ```-1``` value. The missing number is ```index + 1```, since we are looking only for positive numbers and we start count from 1, while index is zero based.\\n```\\nclass Solution { // Time and Space: O(N)\\npublic:\\n\\tint firstMissingPositive(vector<int>& nums) {\\n\\t\\tint size = nums.size();\\n\\t\\tvector<int> sequence(size, -1); // Init array with same size to all -1s\\n\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\tif (nums[i] > 0 && nums[i] <= size)\\n\\t\\t\\t\\tsequence[nums[i] - 1] = 1; // Set numbers at indices to positive\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < size; i++) { // First that has value -1 is the missing one\\n\\t\\t\\tif (sequence[i] == -1)\\n\\t\\t\\t\\treturn i + 1;\\n\\t\\t}\\n\\n\\t\\treturn size + 1;\\n\\t}\\n};\\n```\\n\\n<b>Solution 2</b>\\nVery similar to first solution, but we use the original array instead of creating a new one. So the space complexity is constant.\\nSince we don\\'t need to look at the negative values in the array, we set them to ```0```. Then we use the original array to negate all the numbers at indices for which the value exists in the array.\\nIt is a little tricky, and my solution might require some polishing, but overall, it isn\\'t difficult.\\n```\\nclass Solution { // Time: O(N), Space: O(1)\\npublic:\\n\\tint firstMissingPositive(vector<int>& nums) {\\n\\t\\tint size = nums.size();\\n\\t\\tbool hasOne = false;\\n\\n\\t\\tfor (int& n : nums) { // Set all negatives to 0\\n\\t\\t\\tif (n < 0)\\n\\t\\t\\t\\tn = 0;\\n\\t\\t\\telse if (n == 1)\\n\\t\\t\\t\\thasOne = true;\\n\\t\\t}\\n\\n\\t\\tif (!hasOne) // One is the first missing\\n\\t\\t\\treturn 1;\\n\\n\\t\\tfor (int i = 0; i < size; i++) { // Negate all numbers at indices by found values\\n            int currNum = abs(nums[i]);\\n\\t\\t\\tif (currNum > 0 && currNum <= size)\\n\\t\\t\\t\\tif (nums[currNum - 1] == 0)\\n\\t\\t\\t\\t\\tnums[currNum - 1] = -1;\\n\\t\\t\\t\\telse if (nums[currNum - 1] > 0)\\n\\t\\t\\t\\t\\tnums[currNum - 1] *= -1; // Negate it\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < size; i++) // Find first non negative number\\n\\t\\t\\tif (nums[i] > -1)\\n\\t\\t\\t\\treturn i + 1;\\n\\n\\t\\treturn size + 1;\\n\\t}\\n};\\n```\\n\\nAny suggestions or advice on how to improve the solutions are always welcome. Thank you!\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```1```\n```N```\n```-1```\n```newArray[value - 1]```\n```1```\n```1```\n```N```\n```-1```\n```index + 1```\n```\\nclass Solution { // Time and Space: O(N)\\npublic:\\n\\tint firstMissingPositive(vector<int>& nums) {\\n\\t\\tint size = nums.size();\\n\\t\\tvector<int> sequence(size, -1); // Init array with same size to all -1s\\n\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\tif (nums[i] > 0 && nums[i] <= size)\\n\\t\\t\\t\\tsequence[nums[i] - 1] = 1; // Set numbers at indices to positive\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < size; i++) { // First that has value -1 is the missing one\\n\\t\\t\\tif (sequence[i] == -1)\\n\\t\\t\\t\\treturn i + 1;\\n\\t\\t}\\n\\n\\t\\treturn size + 1;\\n\\t}\\n};\\n```\n```0```\n```\\nclass Solution { // Time: O(N), Space: O(1)\\npublic:\\n\\tint firstMissingPositive(vector<int>& nums) {\\n\\t\\tint size = nums.size();\\n\\t\\tbool hasOne = false;\\n\\n\\t\\tfor (int& n : nums) { // Set all negatives to 0\\n\\t\\t\\tif (n < 0)\\n\\t\\t\\t\\tn = 0;\\n\\t\\t\\telse if (n == 1)\\n\\t\\t\\t\\thasOne = true;\\n\\t\\t}\\n\\n\\t\\tif (!hasOne) // One is the first missing\\n\\t\\t\\treturn 1;\\n\\n\\t\\tfor (int i = 0; i < size; i++) { // Negate all numbers at indices by found values\\n            int currNum = abs(nums[i]);\\n\\t\\t\\tif (currNum > 0 && currNum <= size)\\n\\t\\t\\t\\tif (nums[currNum - 1] == 0)\\n\\t\\t\\t\\t\\tnums[currNum - 1] = -1;\\n\\t\\t\\t\\telse if (nums[currNum - 1] > 0)\\n\\t\\t\\t\\t\\tnums[currNum - 1] *= -1; // Negate it\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < size; i++) // Find first non negative number\\n\\t\\t\\tif (nums[i] > -1)\\n\\t\\t\\t\\treturn i + 1;\\n\\n\\t\\treturn size + 1;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17298,
                "title": "sharing-my-2ms-c-solution",
                "content": "In the worst case, this will take 2N iterations.  Satisfies O(N) runtime and O(1) space requirements. \\n\\nI got the idea from doing this in JavaScript, first, by popping off any out-of-bounds or duplicate values after moving them to the end of the array.  In the end I got rid of the pop operation and used a partition index, instead.  The neat thing is that it doesn't require a second loop to find the answer. \\n\\n\\n    void swap(int* nums, int j, int k) {\\n        int tmp = nums[k];\\n        nums[k] = nums[j];\\n        nums[j] = tmp;\\n    }\\n    \\n    int firstMissingPositive(int* nums, int numsSize) {\\n        int i = 0;\\n        int p = numsSize;\\n\\n        while (i < p) {\\n            if (nums[i] == i+1)  ++i; // already in the right place,\\n            else if (nums[i] <= 0 || nums[i] > p || nums[i] == nums[nums[i]-1]) {\\n                swap(nums, i, --p); // out of range or duplicate, put it at the end\\n            } else {\\n                swap(nums, i, nums[i]-1); // within range; put it in the right place.\\n            }\\n        }\\n\\n        return p + 1;\\n    }",
                "solutionTags": [],
                "code": "In the worst case, this will take 2N iterations.  Satisfies O(N) runtime and O(1) space requirements. \\n\\nI got the idea from doing this in JavaScript, first, by popping off any out-of-bounds or duplicate values after moving them to the end of the array.  In the end I got rid of the pop operation and used a partition index, instead.  The neat thing is that it doesn't require a second loop to find the answer. \\n\\n\\n    void swap(int* nums, int j, int k) {\\n        int tmp = nums[k];\\n        nums[k] = nums[j];\\n        nums[j] = tmp;\\n    }\\n    \\n    int firstMissingPositive(int* nums, int numsSize) {\\n        int i = 0;\\n        int p = numsSize;\\n\\n        while (i < p) {\\n            if (nums[i] == i+1)  ++i; // already in the right place,\\n            else if (nums[i] <= 0 || nums[i] > p || nums[i] == nums[nums[i]-1]) {\\n                swap(nums, i, --p); // out of range or duplicate, put it at the end\\n            } else {\\n                swap(nums, i, nums[i]-1); // within range; put it in the right place.\\n            }\\n        }\\n\\n        return p + 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1206111,
                "title": "python-o-n-time-and-constant-space-solution",
                "content": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n\\t\\t\\n        for i in range(n):\\n            if nums[i] <= 0 or nums[i] > n:\\n                nums[i] = n + 1\\n        for i in range(n):\\n            if abs(nums[i]) > n:\\n                continue\\n            nums[abs(nums[i]) - 1] = -abs(nums[abs(nums[i]) - 1])\\n        for i in range(n):\\n            if nums[i] > 0:\\n                return i + 1\\n        return n + 1\\n```\\n**PS: Please upvote if you liked the solution.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n\\t\\t\\n        for i in range(n):\\n            if nums[i] <= 0 or nums[i] > n:\\n                nums[i] = n + 1\\n        for i in range(n):\\n            if abs(nums[i]) > n:\\n                continue\\n            nums[abs(nums[i]) - 1] = -abs(nums[abs(nums[i]) - 1])\\n        for i in range(n):\\n            if nums[i] > 0:\\n                return i + 1\\n        return n + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17133,
                "title": "simple-javascript-o-n-time-and-o-1-space",
                "content": "```\\nvar firstMissingPositive = function(nums) {\\n    let i = 0;\\n    while (i < nums.length) {\\n        if (nums[i] > 0 && nums[i] <= nums.length && nums[nums[i] - 1] !== nums[i]) {\\n            [nums[nums[i] - 1], nums[i]] = [nums[i], nums[nums[i] - 1]];\\n        } else {\\n            i++;\\n        }\\n    }\\n    for (i = 0; i < nums.length; i++) {\\n        if (nums[i] !== i + 1) return i + 1;\\n    }\\n    return i + 1;\\n};\\n```\\n1. Go through and place each number at the index of its value (minus one since `0` isn't positive). All the negative and out-of-bounds elements should now be in the missing gap or on the right side of the array.\\n2. Walk through and take the first index (plus one) which does not match its associated value.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar firstMissingPositive = function(nums) {\\n    let i = 0;\\n    while (i < nums.length) {\\n        if (nums[i] > 0 && nums[i] <= nums.length && nums[nums[i] - 1] !== nums[i]) {\\n            [nums[nums[i] - 1], nums[i]] = [nums[i], nums[nums[i] - 1]];\\n        } else {\\n            i++;\\n        }\\n    }\\n    for (i = 0; i < nums.length; i++) {\\n        if (nums[i] !== i + 1) return i + 1;\\n    }\\n    return i + 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17157,
                "title": "golang-concise-solution-with-some-explanation",
                "content": "Let's say the array is `[3, 4, -1, 1, 3]`.\\nIf the array doesn't have missing positive integer within its range, the array should be `[1, 2, 3, 4, 5]`.\\n\\nSo, the idea is, we iterate through the array and if we find an integer within `1` to `5`, then put it to the ideal position.  \\nFor example, if we find `1`, then swap it with a value on index `0`. If we find `3`, then swap it with a value on index `2`.\\n\\nAfter we swap the value, we need to examine the swapped new value again, so we should not move to the next position. But we need to be careful about the case when the value is set at the ideal index by default, or we put it already. In this case we need to skip that index, otherwise we'll see the infinite loop :-\\\\\\n\\nwalkthrough:\\n```\\n[3, 4, -1, 1, 3]\\n \\u2191 3, swap with array[2]\\n[-1, 4, 3, 1, 3]\\n \\u2191 -1, this is out of range, so proceed to the next index\\n[-1, 4, 3, 1, 3]\\n     \\u2191 4, swap with array[3]\\n[-1, 1, 3, 4, 3]\\n     \\u2191 1, swap with array[0]\\n[1, -1, 3, 4, 3]\\n     \\u2191 -1, out of range, so proceed to the next index\\n[1, -1, 3, 4, 3]\\n        \\u2191 3, but already on array[2], so proceed to the next index\\n[1, -1, 3, 4, 3]\\n           \\u2191 4, but already on array[3], so proceed to the next index\\n[1, -1, 3, 4, 3]\\n              \\u2191 3, but array[2] already occupied with 3, so proceed to the next index\\nend\\n```\\n\\nAfter this iteration, you will notice that the value who is in  range `1 \\u301c n` will sit on the right index. So what you need to do is iterate this modified array again and find the first integer that doesn't have a value of `i+1`. This case, that is `2` because there is `-1` at index `1`. If there is no such integer, then the first missing integer should be `n+1`.\\n\\n```\\nfunc firstMissingPositive(nums []int) int {\\n\\tnlen := len(nums)\\n\\tfor i := 0; i < nlen; i++ {\\n\\t\\tif nums[i] >= 1 && nums[i] <= nlen && nums[i] != nums[nums[i]-1] {\\n\\t\\t\\tnums[i], nums[nums[i]-1] = nums[nums[i]-1], nums[i]\\n\\t\\t\\ti-- // keep the same index\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < nlen; i++ {\\n\\t\\tif nums[i] != i+1 {\\n\\t\\t\\treturn i + 1\\n\\t\\t}\\n\\t}\\n\\treturn nlen + 1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n[3, 4, -1, 1, 3]\\n \\u2191 3, swap with array[2]\\n[-1, 4, 3, 1, 3]\\n \\u2191 -1, this is out of range, so proceed to the next index\\n[-1, 4, 3, 1, 3]\\n     \\u2191 4, swap with array[3]\\n[-1, 1, 3, 4, 3]\\n     \\u2191 1, swap with array[0]\\n[1, -1, 3, 4, 3]\\n     \\u2191 -1, out of range, so proceed to the next index\\n[1, -1, 3, 4, 3]\\n        \\u2191 3, but already on array[2], so proceed to the next index\\n[1, -1, 3, 4, 3]\\n           \\u2191 4, but already on array[3], so proceed to the next index\\n[1, -1, 3, 4, 3]\\n              \\u2191 3, but array[2] already occupied with 3, so proceed to the next index\\nend\\n```\n```\\nfunc firstMissingPositive(nums []int) int {\\n\\tnlen := len(nums)\\n\\tfor i := 0; i < nlen; i++ {\\n\\t\\tif nums[i] >= 1 && nums[i] <= nlen && nums[i] != nums[nums[i]-1] {\\n\\t\\t\\tnums[i], nums[nums[i]-1] = nums[nums[i]-1], nums[i]\\n\\t\\t\\ti-- // keep the same index\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < nlen; i++ {\\n\\t\\tif nums[i] != i+1 {\\n\\t\\t\\treturn i + 1\\n\\t\\t}\\n\\t}\\n\\treturn nlen + 1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17260,
                "title": "clear-java-solution",
                "content": "    public int firstMissingPositive(int[] nums) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n        while (start <= end) {\\n            int index = nums[start] - 1;\\n            if (index == start)\\n                start++;\\n            else if (index < 0 || index > end || nums[start] == nums[index])\\n                nums[start] = nums[end--];\\n            else {\\n                nums[start] = nums[index];\\n                nums[index] = index + 1;\\n            }\\n        }\\n        return start + 1;\\n    }",
                "solutionTags": [],
                "code": "    public int firstMissingPositive(int[] nums) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n        while (start <= end) {\\n            int index = nums[start] - 1;\\n            if (index == start)\\n                start++;\\n            else if (index < 0 || index > end || nums[start] == nums[index])\\n                nums[start] = nums[end--];\\n            else {\\n                nums[start] = nums[index];\\n                nums[index] = index + 1;\\n            }\\n        }\\n        return start + 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2083286,
                "title": "python-o-n-time-o-1-space-step-by-step-explanation",
                "content": "Plzz **UPVOTE** if you like it.\\n```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        \\'\\'\\'Step 1 -> The main idea behind it is that the minimum number to be found will always be in the range [1....n]\\n\\t\\t             where \\'n\\' is the length of list. So keep numbers in this range and mark others\\n\\t\\t\\t\\t\\t (here we are marking them with (n+1) value) in the list provided.\\'\\'\\'\\n        \\n        n = len(nums)\\n        for i in range(n):\\n            if nums[i] < 1 or nums[i] > n:\\n                nums[i] = n + 1\\n        \\n        \\'\\'\\'Step 2 -> Ignoring the values greater than \\'n\\', mark the indexes of the numbers in the range [1...n]\\n\\t\\t\\t\\t\\t so as to ensure that this values are present. To mark the indexes, \\n\\t\\t\\t\\t\\t I am negating the value present at that index.\\'\\'\\'\\n        \\n        for i in range(n):\\n            val = abs(nums[i])\\n            if val > n:\\n                continue\\n            val -= 1  #since the list is zero indexed,so every value will be at position val - 1\\n            \\n            if nums[val] > 0: \\n                # For similar numbers, it will keep on fluctuating between negative and positive \\n\\t\\t\\t\\t# which is not our motive here.\\n                \\n                nums[val] = -1 * nums[val]\\n        \\n        \\'\\'\\'Step 3 -> Return the first occurence of the non-negative numbers from the list\\'\\'\\'\\n        \\n        for i in range(n):\\n            if nums[i] >=0:\\n                return (i + 1) # bcoz list is zero indexed\\n        \\n        \\'\\'\\'Step 4 -> We will encounter this if no positives were found. This means that all the \\n\\t\\t\\t         numbers are in the range [1....n]. So the missing positive number will be n+1\\'\\'\\'\\n        \\n        return (n + 1)\\n```\\n\\nFor detailed explaination,  do visit \\uD83D\\uDC47\\uD83D\\uDC47\\nhttps://leetcode.com/problems/first-missing-positive/discuss/319270/Explanation-of-crucial-observation-needed-to-deduce-algorithm",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        \\'\\'\\'Step 1 -> The main idea behind it is that the minimum number to be found will always be in the range [1....n]\\n\\t\\t             where \\'n\\' is the length of list. So keep numbers in this range and mark others\\n\\t\\t\\t\\t\\t (here we are marking them with (n+1) value) in the list provided.\\'\\'\\'\\n        \\n        n = len(nums)\\n        for i in range(n):\\n            if nums[i] < 1 or nums[i] > n:\\n                nums[i] = n + 1\\n        \\n        \\'\\'\\'Step 2 -> Ignoring the values greater than \\'n\\', mark the indexes of the numbers in the range [1...n]\\n\\t\\t\\t\\t\\t so as to ensure that this values are present. To mark the indexes, \\n\\t\\t\\t\\t\\t I am negating the value present at that index.\\'\\'\\'\\n        \\n        for i in range(n):\\n            val = abs(nums[i])\\n            if val > n:\\n                continue\\n            val -= 1  #since the list is zero indexed,so every value will be at position val - 1\\n            \\n            if nums[val] > 0: \\n                # For similar numbers, it will keep on fluctuating between negative and positive \\n\\t\\t\\t\\t# which is not our motive here.\\n                \\n                nums[val] = -1 * nums[val]\\n        \\n        \\'\\'\\'Step 3 -> Return the first occurence of the non-negative numbers from the list\\'\\'\\'\\n        \\n        for i in range(n):\\n            if nums[i] >=0:\\n                return (i + 1) # bcoz list is zero indexed\\n        \\n        \\'\\'\\'Step 4 -> We will encounter this if no positives were found. This means that all the \\n\\t\\t\\t         numbers are in the range [1....n]. So the missing positive number will be n+1\\'\\'\\'\\n        \\n        return (n + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1778385,
                "title": "o-n-time-o-1-space-using-number-as-index-of-hash",
                "content": "Let us understand the whole problem in three steps of progression, with an example nums array, say : 3, -1, 4, 2, 1, 7\\n\\nOne observation that we can make is: *we can always ignore the negative values and 0\\'s present in the array* as they contribute to nothing. We have to find the first missing positive number.\\n\\n**Naive approach:  (extra space)**\\n\\n1. In one pass, we find the largest positive number present in array. (If no positive no., return 1).\\n2. We create an array till the size of the largest positive number present + 1 (+ 1 if following 1 based indexing). We put 0 in every index initially.\\n3. In second pass, we take each positive no. from the array and mark that corresponding index in our array with 1. (we ignore negative numbers and 0)\\n4. We iterate our array and the first index which has not been visited / marked true, is our first missing positive number.\\n\\nDry run:\\nnums array -----> 3               -1               4                  2                1                7\\n\\nfor 3, we mark index 3 of array as true/1. We ignore -1. And continue like this:\\n```\\nnums array -------------> 3 -1  4  2  1  7\\ncount array indices ----> 0  1  2  3  4  5  6  7\\n\\t\\t\\t\\t\\t      0  1  1  1  1  0  0  1\\n```\\n\\nNow when we iterate on this array from index 1 to 7 (following 1 based indexing), we see 5 is the first empty index. So we return 5.\\n\\n**Reducing auxiliary array size:**\\n\\nOne problem with this approach is if there are huge gaps between numbers, say 1, 2, 3, 22471. We will unnecessarily create a huge array. We can avoid that by making the following observation:\\n`first missing positive number has to lie within {1,n+1} , where n-> nums.size()`\\nSo we can create array only of size n + 1.\\n\\nDry run:\\nnums array -----> 3               -1               4                  2                1                7\\n\\nfor 3, we mark index 3 of array as true/1. We ignore -1. We mark indices 4,2,1 for numbers 4, 2, 1 in array respectively, and ignore 7 ( as 7 > nums.size() )\\n\\n```\\nnums array -------------> 3 -1  4  2  1  7\\ncount array indices ----> 0  1  2  3  4  5\\n\\t\\t\\t\\t\\t      0  1  1  1  1  0\\n```\\nWe return 1st index empty index or n + 1 if no empty index.\\n\\n\\n\\nCode for above idea (extra O(n) space ) :\\n\\n```\\nint firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> count(n + 1,0);\\n        for(int _n : nums)\\n\\t\\t\\tif(_n <= 0 || _n > n)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\telse\\n\\t\\t\\t\\tcount[_n] += 1;\\n        \\n\\t\\tfor(int i = 1; i < n + 1; ++i)\\n\\t\\t\\tif(count[i] == 0)\\n\\t\\t\\t\\treturn i;\\n\\t\\treturn n + 1;\\n}\\n```\\n\\n**Final approach by modifying above idea for constant space:**\\n\\nTo drop the extra array we are using to maintain index count, we can modify the given array itself to do the hashing.\\nIf we put each nums[i] that lie in range {1, n-1} in that index itself, i.e if nums[i] =3, we put nums[i] in index 3 (or 2 if 0 based indexing), then the first index not containing the number as the index itself will be the first missing positive number. If all indices have nums[i] == i, then we return n + 1.\\n\\nDry run: (using 0 based indexing)\\nnums array -----> 3               -1               4                  2                1                7\\n\\nfor 3, we put 3 in index 2. We ignore -1. We put 4 in index 3. We put 2 in index 1. We put 1 in index 0. We ignore 7.\\n```\\nInitially:\\n\\nindices    -------------> 0  1  2  3  4  5\\nnums array -------------> 3 -1  4  2  1  7\\n\\nAfter modification:\\n\\nindices    -------------> 0  1  2  3  4  5\\nnums array -------------> 1  2  3  4 -1  7\\n```\\n\\nBelow is the code implementing this idea with a zero-based indexing approach:\\n\\n```\\n\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        for(int i = 0; i < n; ++i)\\n        {\\n            if(nums[i] <= 0 || nums[i] > n) //ignore numbers not in range of {1, n-1}\\n                continue;\\n            else\\n            {\\n                if(nums[nums[i]-1]==nums[i])  //already in correct place, then skip (else infinite loop of swapping)\\n                    continue;\\n                swap(nums[i], nums[nums[i] - 1]);\\n                --i;                          //can\\'t go forward without putting swapped number in correct place.\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; ++i)\\n            if(i + 1 != nums[i])\\n                return i + 1;\\n        return n + 1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nnums array -------------> 3 -1  4  2  1  7\\ncount array indices ----> 0  1  2  3  4  5  6  7\\n\\t\\t\\t\\t\\t      0  1  1  1  1  0  0  1\\n```\n```\\nnums array -------------> 3 -1  4  2  1  7\\ncount array indices ----> 0  1  2  3  4  5\\n\\t\\t\\t\\t\\t      0  1  1  1  1  0\\n```\n```\\nint firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> count(n + 1,0);\\n        for(int _n : nums)\\n\\t\\t\\tif(_n <= 0 || _n > n)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\telse\\n\\t\\t\\t\\tcount[_n] += 1;\\n        \\n\\t\\tfor(int i = 1; i < n + 1; ++i)\\n\\t\\t\\tif(count[i] == 0)\\n\\t\\t\\t\\treturn i;\\n\\t\\treturn n + 1;\\n}\\n```\n```\\nInitially:\\n\\nindices    -------------> 0  1  2  3  4  5\\nnums array -------------> 3 -1  4  2  1  7\\n\\nAfter modification:\\n\\nindices    -------------> 0  1  2  3  4  5\\nnums array -------------> 1  2  3  4 -1  7\\n```\n```\\n\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        for(int i = 0; i < n; ++i)\\n        {\\n            if(nums[i] <= 0 || nums[i] > n) //ignore numbers not in range of {1, n-1}\\n                continue;\\n            else\\n            {\\n                if(nums[nums[i]-1]==nums[i])  //already in correct place, then skip (else infinite loop of swapping)\\n                    continue;\\n                swap(nums[i], nums[nums[i] - 1]);\\n                --i;                          //can\\'t go forward without putting swapped number in correct place.\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; ++i)\\n            if(i + 1 != nums[i])\\n                return i + 1;\\n        return n + 1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1119550,
                "title": "two-ways-of-solving-this-floyd-cycle-o-n-time-o-1-space-in-2nd-approach",
                "content": "\\n**Key Insight: If n = nums.length, that is size of nums is n, then the max possible answer can be n + 1 only. Think about it if you are not sure. Think of an input where the answer can be more than n + 1. You won\\'t be able to find it.**\\n\\nFirst way is to create an extra boolean array called `exists`. After filling this array, `exists[i]` should be able to indicate if a number `i+1` is the required answer or not. That is `if exists[i] is false` then this means that `i+1` is the answer.\\n\\n# <ins>First Approach - Extra Space:\\n\\n```java\\n    // TC: O(n), SC: O(n)\\n    public int firstMissingPositive_ExtraArray(int[] nums) {\\n        int n = nums.length;\\n        boolean[] exists = new boolean[n];\\n        for (int num : nums) {\\n            if (num > 0 && num <= n) exists[num - 1] = true;\\n        }\\n        for (int i = 0; i < exists.length; i++) {\\n            if (!exists[i]) return i + 1;\\n        }\\n        return n + 1;\\n    }\\n```\\n\\n<br>\\n<hr>\\n<br>\\n\\n# <ins>Second Approach - No Space:\\nSame as first approach, but instead of having an extra boolean array, think of using the giving input array itself. \\n\\n**Key Insight in second approach: Remember that we don\\'t care about negative values in the array. Let\\'s throw them into dustbin \\uD83D\\uDE02**\\n\\nSo we override the negatives, and then we manually flip the sign of the numbers to indicate if a value exists or not. Read the comments in the solution below.\\n\\n```java\\n    public int firstMissingPositive_NoSpace(int[] nums) {\\n        int n = nums.length;\\n        // pre-process array so that non-positive ints are overwritten with n + 1;\\n        // why n + 1? coz this is the safest value to choose during\\n        // floyd cycle way which we are about to do in second for loop below\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] <= 0) nums[i] = n + 1;\\n        }\\n\\n        // Take abs of A[i] and then make sure its within bounds and use that as index.\\n        // This is also called as Floyd Cycle algorithm or something. Another fancy name I think is tortoise-hare.\\n        for (int i = 0; i < n; i++) {\\n            int num = Math.abs(nums[i]);\\n            if (num > 0 && num <= n) {\\n                // Now indicate that the +ve value num was found.\\n                // We indicate this by setting nums[num - 1] as a negative value;\\n                // Why does this work? We are using the negative sign in the array to indicate that\\n                // a positive value has been found. On the other hand, value itself is encoded in Math.abs(nums[i])\\n                nums[num - 1] = -Math.abs(nums[num - 1]);\\n            }\\n        }\\n\\n        // Now check for the first value where nums[i] is not negative and we have found our answer\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] > 0) return i + 1;\\n        }\\n        return n + 1;\\n    }\\n```\\n\\n**Essentially in the first approach, we used an extra boolean array, while in the second approach we used existing array itself to do this. We simulated the \"boolean-ness\" using the negative sign. However since the initial input could have negatives already, we just overwrote the negatives to avoid problems for us down the line.**\\n\\nP.S. Correct me if I am wrong about the name of the algorithm(floyd cycle).\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n    // TC: O(n), SC: O(n)\\n    public int firstMissingPositive_ExtraArray(int[] nums) {\\n        int n = nums.length;\\n        boolean[] exists = new boolean[n];\\n        for (int num : nums) {\\n            if (num > 0 && num <= n) exists[num - 1] = true;\\n        }\\n        for (int i = 0; i < exists.length; i++) {\\n            if (!exists[i]) return i + 1;\\n        }\\n        return n + 1;\\n    }\\n```\n```java\\n    public int firstMissingPositive_NoSpace(int[] nums) {\\n        int n = nums.length;\\n        // pre-process array so that non-positive ints are overwritten with n + 1;\\n        // why n + 1? coz this is the safest value to choose during\\n        // floyd cycle way which we are about to do in second for loop below\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] <= 0) nums[i] = n + 1;\\n        }\\n\\n        // Take abs of A[i] and then make sure its within bounds and use that as index.\\n        // This is also called as Floyd Cycle algorithm or something. Another fancy name I think is tortoise-hare.\\n        for (int i = 0; i < n; i++) {\\n            int num = Math.abs(nums[i]);\\n            if (num > 0 && num <= n) {\\n                // Now indicate that the +ve value num was found.\\n                // We indicate this by setting nums[num - 1] as a negative value;\\n                // Why does this work? We are using the negative sign in the array to indicate that\\n                // a positive value has been found. On the other hand, value itself is encoded in Math.abs(nums[i])\\n                nums[num - 1] = -Math.abs(nums[num - 1]);\\n            }\\n        }\\n\\n        // Now check for the first value where nums[i] is not negative and we have found our answer\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] > 0) return i + 1;\\n        }\\n        return n + 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17164,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution with discussion** https://discuss.leetcode.com/topic/76042/python-solution-with-detailed-explanation\\n\\n**First Missing Positive** https://leetcode.com/problems/first-missing-positive/\\n\\n**Solution using extra space: O(N) time and space**\\n* If the length of the nums array is N, then the first missing positive will be between 1 to N+1. Think Why N+1? We can have in the array 1 to N.\\n\\t* Take an temp array of size N and for any number x in nums such that 1<=x<=N, mark temp[x-1]. Then simply walk the temp array and report the first unmarked index.\\n\\n```\\nclass Solution(object):\\n    def firstMissingPositive(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        temp, N = [None]*len(nums), len(nums)\\n        for x in nums:\\n            if 1<=x<=N:\\n                temp[x-1] = x\\n        for i in range(N):\\n            if temp[i] == None:\\n                return i+1\\n        return N+1\\n```\\n\\n**Optimized solution with O(1) Space**\\n* Simply traverse the nums array and put any number within [1, N] in their right place. For example if 2 is in that input, then put 2 at index 1.\\n* Now traverse this \"shuffled\" array again. You expect 1 at 0th index. Otherwise it is missing. Then you expect 2 at 1st index and so on.\\n* Above idea can be a little tricky. What about cases like [1] and [1,1] - i.e. 1 is in its place or there are duplicates - we need to advance pointer regardless.\\n\\n```\\nclass Solution(object):\\n    def firstMissingPositive(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        N, i = len(nums), 0\\n        while i < N:\\n            while 1<=nums[i]<=N:\\n                idx_expected = nums[i]-1\\n                if nums[i] == nums[idx_expected]:\\n                    break\\n                nums[i], nums[idx_expected] = nums[idx_expected], nums[i]\\n            i = i + 1\\n        for i in range(N):\\n            if nums[i] != i+1:\\n                return i+1\\n        return N+1\\n```.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def firstMissingPositive(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        temp, N = [None]*len(nums), len(nums)\\n        for x in nums:\\n            if 1<=x<=N:\\n                temp[x-1] = x\\n        for i in range(N):\\n            if temp[i] == None:\\n                return i+1\\n        return N+1\\n```\n```\\nclass Solution(object):\\n    def firstMissingPositive(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        N, i = len(nums), 0\\n        while i < N:\\n            while 1<=nums[i]<=N:\\n                idx_expected = nums[i]-1\\n                if nums[i] == nums[idx_expected]:\\n                    break\\n                nums[i], nums[idx_expected] = nums[idx_expected], nums[i]\\n            i = i + 1\\n        for i in range(N):\\n            if nums[i] != i+1:\\n                return i+1\\n        return N+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1895048,
                "title": "simple-python-search-beats-98",
                "content": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        unique = set(nums)\\n        i = 1\\n        while i in unique:\\n            i += 1\\n        return i\\n```\\nIt is quite a simple solution. We first run it through set() to stop duplicate numbers (will cause a runtime error if not there when you submit it). You don\\'t need to sorted() it or anything else because the counter (which is \"i\") will scan through the list for it. \\n\\n\"i\" is the variable that i used as a counter to see if it is in the set(nums) or not. If it not in the set(nums), the `while` function will stop and and move on to the next code which is `return i`.\\n\\n`i += 1` is the same as `i = i + 1` which is what allow the \"while\" loop to continue. \\nYou substitute \"unique\" for \"j\" or something to decrease memory usage.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        unique = set(nums)\\n        i = 1\\n        while i in unique:\\n            i += 1\\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 616956,
                "title": "c-solution-with-clear-explanation-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        //the missing number will always be less than or equal to the size of the vector\\n        //place all positive elements less than or equal to the size of the vector to their respective index in the vector, e.g., 1 at index 0\\n        \\n        int n = nums.size();\\n        for(int i = 0; i < n; i++)\\n            while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i])\\n                swap(nums[i], nums[nums[i] - 1]); //place element x at index num[x - 1]\\n        \\n        //if the number at index i is not i + 1, the missing number is i + 1\\n        for(int i = 0; i < n; i++)\\n            if(nums[i] != i + 1)\\n                return i + 1;\\n        \\n        //else, the missing number is one more than the size of the vector\\n        return n + 1;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        //the missing number will always be less than or equal to the size of the vector\\n        //place all positive elements less than or equal to the size of the vector to their respective index in the vector, e.g., 1 at index 0\\n        \\n        int n = nums.size();\\n        for(int i = 0; i < n; i++)\\n            while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i])\\n                swap(nums[i], nums[nums[i] - 1]); //place element x at index num[x - 1]\\n        \\n        //if the number at index i is not i + 1, the missing number is i + 1\\n        for(int i = 0; i < n; i++)\\n            if(nums[i] != i + 1)\\n                return i + 1;\\n        \\n        //else, the missing number is one more than the size of the vector\\n        return n + 1;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617430,
                "title": "python-swap-sort-o-1-space-and-o-n-time",
                "content": "Swap Sort Playlist by Aditya Verma - https://www.youtube.com/playlist?list=PL_z_8CaSLPWdJfdZHiNYYM46tYQUjbBJx\\n\\nThis problem is a variation of 1 to n missing number problems.\\n\\nHere, Range of numbers is from -2^31 to 2^31 - 1\\n\\nBut as the problem statement says, we need to return the first Missing \"Positive\" number which means we care about only the positive numbers.\\n\\nThe smallest missing positive number = the first missing number.\\n\\nSo, what we can do is we manually pick the range 1 to n where n is the length of given array and then place each element at its correct place.\\n\\n\\t\\tnums = [3,4,-1,1]\\n\\nSo here, n = 4 which means ideally, all numbers from 1 to 4 should be in this array. Lets apply swap sort on this array. We only care about numbers from range 1 to n because that\\'s how swap sort works.\\n\\nDo note that ideally, at index i, element should be i + 1. That\\'s what we are going to check.\\n\\n    at index = 0, we have 3. is 3 > 0 and <= n? YES. SO it can be considered. \\n\\n    It 3 at its correct place? NO. Its correct place is index 2. \\n\\n    So to place 3 at its correct place, swap element at index 2 with 3. \\n\\n    [-1,4,3,1]\\n\\n    Now at index = 0, we have a negative number so we ignore it and move ahead.\\n\\n    At index = 1, we have 4. It should be at index = 3. SO swap\\n\\n    [-1,1,3,4]\\n\\n    Again at index = 1, we have 1. But 1 should be at index = 0. So Swap.\\n\\n    [1,-1,3,4]\\n\\n    And since now we have a negative number at index = 1, ignore it.\\n\\n    At index = 2, we already have correct number i.e, 3\\n\\n    AT index = 3 we already have correct number i.e., 4\\n\\n\\nSo finally, our array becomes [1,-1,3,4]\\n\\nAnd now, we do the second part of Swap Sort algorithm, which is to find the missing number. If at index = i, we do not have i + 1, that means i + 1 is the missing number. And because we are asked to find the first positive missing number, as soon as we find a missing number, that will be the first/smallest so we can return.\\n\\nSo, in [1,-1,3,4] we will see that at index = 1, we should have 2 but instead there is -1. This means 2 is missing. So return 2.\\n\\n# **SPECIAL CASES**\\n\\nThere will be cases where we have arrays like - \\n\\n    [1]\\n\\nAnd in this case, smallest positive missing number is 2. That\\'s because as we know, positive range is from 1 to 2^31 - 1. So if 1 is there, then the next smallest number is 2 which is missing.\\n\\nBut our swap sort algorithm won\\'t be able to find it because we run the loop only till length of the array which in this case is 1.\\n\\nSo, if we did not get a missing number in the given array, that simply means the missing number is (length + 1)\\n\\n\\n```\\ndef firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n        # First put each number in range 1 to n at its correct place\\n        i = 0\\n        \\n        while i < n:\\n            # Swap\\n            # Only for the range 1 to n check if a number at any index is not at its correct place\\n            if nums[i] > 0 and nums[i] <= n and nums[i] != nums[nums[i] - 1]:\\n                nums[nums[i] - 1], nums[i]= nums[i], nums[nums[i] - 1]\\n            else:\\n                i += 1\\n        \\n        # And now just find the first missing number. That would be the smallest\\n        for i,num in enumerate(nums):\\n            if num != i + 1: return i + 1\\n        \\n        # Otherwise the missing positive number is n + 1 (e,g, for testcases such as [1])\\n        return n + 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n        # First put each number in range 1 to n at its correct place\\n        i = 0\\n        \\n        while i < n:\\n            # Swap\\n            # Only for the range 1 to n check if a number at any index is not at its correct place\\n            if nums[i] > 0 and nums[i] <= n and nums[i] != nums[nums[i] - 1]:\\n                nums[nums[i] - 1], nums[i]= nums[i], nums[nums[i] - 1]\\n            else:\\n                i += 1\\n        \\n        # And now just find the first missing number. That would be the smallest\\n        for i,num in enumerate(nums):\\n            if num != i + 1: return i + 1\\n        \\n        # Otherwise the missing positive number is n + 1 (e,g, for testcases such as [1])\\n        return n + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1227747,
                "title": "java-solution-with-comments-o-n",
                "content": "For this problem, the numbers given are not bound by any range so we can have any number in the input array. We can iterate through the array and try to place the positive numbers between 1 and n in their correct indices. As we do so, we will ignore all the numbers that are out of range (i.e negative numbers and all numbers greater than the length of the array). Once we are done with the sorting, we will iterate through the array and find the first index that does not have the correct number.\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\n```\\n    public int firstMissingPositive(int[] nums) {\\n        int i = 0;\\n        int j;\\n        int n = nums.length;\\n        \\n        // handle case of a single-element array\\n        if (n == 1) {\\n            if (nums[i] == 1) return 2;\\n            else return 1;\\n        }\\n        \\n        // try to place numbers in their correct indices\\n        while (i < n) {  \\n            // ignore numbers out of range (negative numbers and numbers greater than length of the array)\\n            if (nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1]) {\\n                swap(nums, i, nums[i] - 1);\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        // loop through the array again\\n        // find the first number that is not at its correct index\\n        for (i = 0; i < n; i++) {\\n            if (nums[i] != i + 1) {\\n                return i + 1;\\n            }\\n        }\\n        \\n        return nums.length + 1;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "For this problem, the numbers given are not bound by any range so we can have any number in the input array. We can iterate through the array and try to place the positive numbers between 1 and n in their correct indices. As we do so, we will ignore all the numbers that are out of range (i.e negative numbers and all numbers greater than the length of the array). Once we are done with the sorting, we will iterate through the array and find the first index that does not have the correct number.\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\n```\\n    public int firstMissingPositive(int[] nums) {\\n        int i = 0;\\n        int j;\\n        int n = nums.length;\\n        \\n        // handle case of a single-element array\\n        if (n == 1) {\\n            if (nums[i] == 1) return 2;\\n            else return 1;\\n        }\\n        \\n        // try to place numbers in their correct indices\\n        while (i < n) {  \\n            // ignore numbers out of range (negative numbers and numbers greater than length of the array)\\n            if (nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1]) {\\n                swap(nums, i, nums[i] - 1);\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        // loop through the array again\\n        // find the first number that is not at its correct index\\n        for (i = 0; i < n; i++) {\\n            if (nums[i] != i + 1) {\\n                return i + 1;\\n            }\\n        }\\n        \\n        return nums.length + 1;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 382641,
                "title": "c-solution-moving-all-negative-numbers-to-right-side-of-the-array",
                "content": "```\\n\\npublic class Solution {\\n  public int FirstMissingPositive(int[] nums) {\\n    if (nums.Length == 0) return 1;\\n      if (nums.Length == 1) {\\n      if (nums[0] != 1) return 1;\\n      if (nums[0] == 1) return 2;\\n    }\\n      Array.Sort(nums);\\n    int maxNumber = nums.Max();\\n    if (maxNumber < 1) return 1;\\n      int indexPos = 0;\\n    for(int i = 0 ; i < nums.Length; i++)\\n    {\\n        if(nums[i] > 0 && nums[i] != 0)\\n        {\\n          nums[indexPos++] = nums[i];\\n        }\\n    }\\n      int negativeIndex = indexPos;\\n      for(int j = indexPos; j < nums.Length; j++)\\n          nums[indexPos] = -1;\\n      if(nums[0] != 1) return 1;\\n      for(int i = 0 ; i < negativeIndex - 1; i++)\\n      {\\n          if(nums[i + 1] != nums[i] + 1 && nums[i+1] != nums[i])\\n              return nums[i] + 1;\\n      }\\n    return maxNumber + 1;\\n  }\\n}\\n\\n````",
                "solutionTags": [],
                "code": "```\\n\\npublic class Solution {\\n  public int FirstMissingPositive(int[] nums) {\\n    if (nums.Length == 0) return 1;\\n      if (nums.Length == 1) {\\n      if (nums[0] != 1) return 1;\\n      if (nums[0] == 1) return 2;\\n    }\\n      Array.Sort(nums);\\n    int maxNumber = nums.Max();\\n    if (maxNumber < 1) return 1;\\n      int indexPos = 0;\\n    for(int i = 0 ; i < nums.Length; i++)\\n    {\\n        if(nums[i] > 0 && nums[i] != 0)\\n        {\\n          nums[indexPos++] = nums[i];\\n        }\\n    }\\n      int negativeIndex = indexPos;\\n      for(int j = indexPos; j < nums.Length; j++)\\n          nums[indexPos] = -1;\\n      if(nums[0] != 1) return 1;\\n      for(int i = 0 ; i < negativeIndex - 1; i++)\\n      {\\n          if(nums[i + 1] != nums[i] + 1 && nums[i+1] != nums[i])\\n              return nums[i] + 1;\\n      }\\n    return maxNumber + 1;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207882,
                "title": "python-beats-99-concise-4-line-solution-runtime",
                "content": "## **Please upvote/favourite/comment if you like this solution!**\\n\\n# Without space complexity restraint\\n```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        nums_set, i = set(nums), 1\\n        while i in nums_set:\\n            i += 1\\n        return i\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Optimized\\n\\n```\\nclass Solution:\\n    def swap(self, arr, a, b):\\n        tmp = arr[a]\\n        arr[a] = arr[b]\\n        arr[b] = tmp\\n        return arr\\n\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(n):\\n            while 1 <= nums[i] <= n and nums[i] != nums[nums[i]-1]:\\n                nums = self.swap(nums,i,nums[i]-1)\\n        for j in range(n):\\n            if nums[j] != j+1:\\n                return j+1\\n        return n+1\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        nums_set, i = set(nums), 1\\n        while i in nums_set:\\n            i += 1\\n        return i\\n```\n```\\nclass Solution:\\n    def swap(self, arr, a, b):\\n        tmp = arr[a]\\n        arr[a] = arr[b]\\n        arr[b] = tmp\\n        return arr\\n\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(n):\\n            while 1 <= nums[i] <= n and nums[i] != nums[nums[i]-1]:\\n                nums = self.swap(nums,i,nums[i]-1)\\n        for j in range(n):\\n            if nums[j] != j+1:\\n                return j+1\\n        return n+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974305,
                "title": "using-cyclic-sort-technique-solve-any-range-based-questions",
                "content": "# Intuition\\nPrerequistes for solving the question is to know the **cyclic sort algorithm.**\\n\\n**Cyclic sort algorithm -** is used when the elements in the array are in the range 1 to n. \\n(n = size of the array)\\n\\n    Arr :  [4, 5, 2, 1, 3]\\n    index :[0, 1, 2, 3, 4]\\n\\nWe can see in the  above example that the elements in the array are in range 1 to n. \\n***So, how does cyclic sort work upon it to sort the array in O(n) complexity?***\\n\\n    arr: [4,5,2,1,3]\\n    arr[0]: 4 \\n\\n*To sort the array we Check - is the 0th element of the array at the correct index?* \\n-- No, so put it at its correct index by **swapping it with the element at its correct index.** \\n-- If Yes, then simply move to the next element and check.\\n-- Dry Run :- \\n\\n    Arr :  [4, 5, 2, 1, 3]\\n    index :[0, 1, 2, 3, 4]\\n\\n    Arr[0]: 4 [Not at the correct index, swap it]\\n    swap(Arr[0], Arr[4 - 1]) // 4 - 1, since 0 based indexing\\n    Arr: [1, 5, 2, 4, 3] // After placing arr[0] at correct index\\n\\n    Again check after swapping, is the swapperd element at correct index?   \\n    Arr[0]: 1 [At the correct index, move to the next element]\\n\\n    Arr[1]: 5 [Not at the correct index, swap it]\\n    swap(Arr[1], Arr[5 - 1]) \\n    Arr: [1, 3, 2, 4, 5] // After placing arr[1] at correct index\\n\\n    Again check after swapping, is the swapperd element at correct index? \\n    Arr[1]: 3 [Not at the correct index, swap it]\\n    swap(Arr[1], Arr[3 - 1]) \\n    Arr: [1, 2, 3, 4, 5] // After placing arr[1] at correct index\\n\\n     Again check after swapping, is the swapperd element at correct index? \\n    Arr[1]: 2 [At the correct index, move to the next element]\\n\\n    Again check after swapping, is the swapperd element at correct index? \\n    Arr[2]: 3 [At the correct index, move to the next element]\\n    .\\n    .\\n    .\\n    .\\n    Likewise, all the elements fall at right indices and we get a sorted array in O(n) complexity.\\n    P.S. - Works only when numbers in array range from 1 to n.\\n\\n\\n    \\n\\n\\n\\n\\n**We use cyclic sort when the given numbers in the array range from 1 to n.** But in this problem we have *negative numbers & numbers > arr.size()* as well in the array.\\n\\n**So, we need to have some clear observations first ->**\\n-- *The 1st missing number always lies between 1 to n.*\\n(Take few examples, and it will be clear)\\n-- We need not care about the negative numbers & numbers > n.\\n\\n# Complexity\\n- Time complexity:\\n0(n)\\n- Space complexity:\\nO(1)\\n\\n# Problems on cylcic sort:-\\n    --> Missing Number\\n    --> Find all numbers disappeared in array\\n    --> Find the Duplicate Numbers\\n    --> Set Mismatch\\n    --> First Missing Positive\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        // Using Cyclic Sort Technique\\n        for (int i = 0; i < n; ) {\\n\\n            // ignoring the negative & >n numbers, \\n            // as the 1st missing number would always lie between 1 to n \\n            if (nums[i] > 0 && nums[i] < nums.size() && nums[nums[i] - 1] != nums[i]) \\n                swap(nums[nums[i] - 1], nums[i]);\\n            else \\n                i++;\\n\\n        }\\n        // run a loop to check which is the 1st element, not at the correct index after sorting\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] != i + 1) {\\n                return i + 1;\\n            }\\n        }\\n        return n + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        // Using Cyclic Sort Technique\\n        for (int i = 0; i < n; ) {\\n\\n            // ignoring the negative & >n numbers, \\n            // as the 1st missing number would always lie between 1 to n \\n            if (nums[i] > 0 && nums[i] < nums.size() && nums[nums[i] - 1] != nums[i]) \\n                swap(nums[nums[i] - 1], nums[i]);\\n            else \\n                i++;\\n\\n        }\\n        // run a loop to check which is the 1st element, not at the correct index after sorting\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] != i + 1) {\\n                return i + 1;\\n            }\\n        }\\n        return n + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362460,
                "title": "c-simple-c-code-o-n-time-o-1-space",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        // Mark all out of range values as n+1\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] <= 0 || nums[i] > n){\\n                nums[i] = n+1;\\n                continue;\\n            }\\n        }\\n        // mark all ranged valued index as negative;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(abs(nums[i]) >= n+1) continue;\\n            int val = abs(nums[i]);\\n            nums[val-1] = -1*abs(nums[val-1]);\\n        }\\n        // if any ranged valued index is positive return one plus its idex since it is (1th indexing)\\n        for(int i = 0; i < n; i++)\\n            if(nums[i] > 0) return i+1;\\n        return n+1;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        // Mark all out of range values as n+1\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] <= 0 || nums[i] > n){\\n                nums[i] = n+1;\\n                continue;\\n            }\\n        }\\n        // mark all ranged valued index as negative;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(abs(nums[i]) >= n+1) continue;\\n            int val = abs(nums[i]);\\n            nums[val-1] = -1*abs(nums[val-1]);\\n        }\\n        // if any ranged valued index is positive return one plus its idex since it is (1th indexing)\\n        for(int i = 0; i < n; i++)\\n            if(nums[i] > 0) return i+1;\\n        return n+1;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905808,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the nums.\\n    //   - space: O(1), only constant space is used, if we have parameter nums as inout.\\n\\n    func firstMissingPositive(_ nums: [Int]) -> Int {\\n        var nums = nums\\n        var ans = 1\\n\\n        for (i, num) in nums.enumerated() {\\n            if num == ans { ans += 1 }\\n            if num <= 0 || num > nums.count { nums[i] = 1 }\\n        }\\n\\n        guard ans != 1, ans != nums.count + 1 else { return ans }\\n\\n        for i in 0..<nums.count {\\n            let num = abs(nums[i])\\n            if num == nums.count {\\n                nums[0] = -abs(nums[0])\\n            } else {\\n                nums[num] = -abs(nums[num])\\n            }\\n        }\\n\\n        for i in 1..<nums.count {\\n            guard nums[i] > 0 else { continue }\\n            return i\\n        }\\n        return nums.count + (nums[0] > 0 ? 0 : 1)\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the nums.\\n    //   - space: O(1), only constant space is used, if we have parameter nums as inout.\\n\\n    func firstMissingPositive(_ nums: [Int]) -> Int {\\n        var nums = nums\\n        var ans = 1\\n\\n        for (i, num) in nums.enumerated() {\\n            if num == ans { ans += 1 }\\n            if num <= 0 || num > nums.count { nums[i] = 1 }\\n        }\\n\\n        guard ans != 1, ans != nums.count + 1 else { return ans }\\n\\n        for i in 0..<nums.count {\\n            let num = abs(nums[i])\\n            if num == nums.count {\\n                nums[0] = -abs(nums[0])\\n            } else {\\n                nums[num] = -abs(nums[num])\\n            }\\n        }\\n\\n        for i in 1..<nums.count {\\n            guard nums[i] > 0 else { continue }\\n            return i\\n        }\\n        return nums.count + (nums[0] > 0 ? 0 : 1)\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1334664,
                "title": "c-solution-with-o-n-time-and-o-1-space-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n// we can also use method where we first move all non-positive elements to left\\n// But, this method makes things more easy as we will have our answer in range [1, nums.size()+1]\\n    int firstMissingPositive(vector<int>& nums) {\\n\\t// first of all, make all -ve numbers and zeroes as some +ve value but that should be greater than nums.size()\\n\\t// because we are going to use these (elements-1) as index to mark the presence of corresponding element\\n        for(int i=0;i<nums.size();i++){\\n\\t\\t\\tif(nums[i]<=0)nums[i]=nums.size()+1;\\n\\t\\t}\\n        \\n\\t\\t// mark the presence of each element if it is between 1 to nums.size()\\n        for(int i=0;i<nums.size();i++){\\n\\t\\t\\t//since we are marking presence of an element by making element of its corresponding index as -ve\\n\\t\\t\\t// therefore, we need to take +ve value or actual value of that element (as it may have been made -ve during process)\\n\\t\\t\\tint element=abs(nums[i]);\\n\\t\\t\\t// now, presence of each element is marked at an index less by 1 than that element\\n\\t\\t\\t// eg. presence of 1 is marked at index 0\\n\\t\\t\\t// i.e. if 1 is present, we will make element at index 0 as -ve\\n            int index=element-1;;\\n            if(index<nums.size() && nums[index]>0)nums[index]*=(-1);\\n        }\\n        \\n\\t\\t// finally, index that is still having +ve value means that no element marked it\\n\\t\\t// i.e. that index+1 element is not present in the array\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0)return i+1;\\n        }\\n\\t\\t// & if all elements from 1 to nums.size() are present, then first missing positive integer is  nums.size()+1\\n        return nums.size()+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// we can also use method where we first move all non-positive elements to left\\n// But, this method makes things more easy as we will have our answer in range [1, nums.size()+1]\\n    int firstMissingPositive(vector<int>& nums) {\\n\\t// first of all, make all -ve numbers and zeroes as some +ve value but that should be greater than nums.size()\\n\\t// because we are going to use these (elements-1) as index to mark the presence of corresponding element\\n        for(int i=0;i<nums.size();i++){\\n\\t\\t\\tif(nums[i]<=0)nums[i]=nums.size()+1;\\n\\t\\t}\\n        \\n\\t\\t// mark the presence of each element if it is between 1 to nums.size()\\n        for(int i=0;i<nums.size();i++){\\n\\t\\t\\t//since we are marking presence of an element by making element of its corresponding index as -ve\\n\\t\\t\\t// therefore, we need to take +ve value or actual value of that element (as it may have been made -ve during process)\\n\\t\\t\\tint element=abs(nums[i]);\\n\\t\\t\\t// now, presence of each element is marked at an index less by 1 than that element\\n\\t\\t\\t// eg. presence of 1 is marked at index 0\\n\\t\\t\\t// i.e. if 1 is present, we will make element at index 0 as -ve\\n            int index=element-1;;\\n            if(index<nums.size() && nums[index]>0)nums[index]*=(-1);\\n        }\\n        \\n\\t\\t// finally, index that is still having +ve value means that no element marked it\\n\\t\\t// i.e. that index+1 element is not present in the array\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0)return i+1;\\n        }\\n\\t\\t// & if all elements from 1 to nums.size() are present, then first missing positive integer is  nums.size()+1\\n        return nums.size()+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 997296,
                "title": "java-o-n-time-o-1-space-with-comments",
                "content": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n\\t\\t//set any 0 or negative number as the size of the array + 1\\n\\t\\t//[1,2,*-3*,4] => [1,2,*5*,4]\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] <= 0) {\\n                nums[i] = nums.length + 1;\\n            }\\n        }\\n        \\n\\t\\t//if the absolute value is a valid position of this array, then \\n\\t\\t//negate the value of the respective index\\n\\t\\t// [1,2,5,4] =>  [-1,-2,5,-4]\\n        for(int i = 0; i < nums.length; i++) {\\n            int valueIdx = Math.abs(nums[i]) - 1;\\n            if(valueIdx + 1 > 0 && valueIdx + 1 <= nums.length) {\\n                nums[valueIdx] = -Math.abs(nums[valueIdx]);\\n            }\\n        }\\n        \\n\\t\\t//traverse the array from left to right\\n\\t\\t//if there\\'s any positive number then\\n\\t\\t//we found the missing positive number\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] >= 1) {\\n                return i + 1;\\n            }\\n        }\\n        \\n\\t\\t//if all elements of the array are correct\\n\\t\\t//return the lenght of the array + 1\\n        return nums.length + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n\\t\\t//set any 0 or negative number as the size of the array + 1\\n\\t\\t//[1,2,*-3*,4] => [1,2,*5*,4]\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] <= 0) {\\n                nums[i] = nums.length + 1;\\n            }\\n        }\\n        \\n\\t\\t//if the absolute value is a valid position of this array, then \\n\\t\\t//negate the value of the respective index\\n\\t\\t// [1,2,5,4] =>  [-1,-2,5,-4]\\n        for(int i = 0; i < nums.length; i++) {\\n            int valueIdx = Math.abs(nums[i]) - 1;\\n            if(valueIdx + 1 > 0 && valueIdx + 1 <= nums.length) {\\n                nums[valueIdx] = -Math.abs(nums[valueIdx]);\\n            }\\n        }\\n        \\n\\t\\t//traverse the array from left to right\\n\\t\\t//if there\\'s any positive number then\\n\\t\\t//we found the missing positive number\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] >= 1) {\\n                return i + 1;\\n            }\\n        }\\n        \\n\\t\\t//if all elements of the array are correct\\n\\t\\t//return the lenght of the array + 1\\n        return nums.length + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17302,
                "title": "concise-o-n-solution",
                "content": "    // ignore all the negative, > n\\n    // put the other value back to its order position A[A[i]-1]\\n    int firstMissingPositive(int A[], int n) {\\n        if (n == 0) return 1;\\n        for (int i = 0; i != n; ) {\\n            if (A[i] != i + 1 && A[i] > 0 && A[i] <= n && A[A[i]-1] != A[i])\\n                swap(A[i], A[A[i] - 1]);\\n            else ++i;\\n        }\\n        \\n        for (int i = 0; i != n; ++i)\\n            if (A[i] != i + 1) return i + 1;\\n        return n+1;\\n    }",
                "solutionTags": [],
                "code": "    // ignore all the negative, > n\\n    // put the other value back to its order position A[A[i]-1]\\n    int firstMissingPositive(int A[], int n) {\\n        if (n == 0) return 1;\\n        for (int i = 0; i != n; ) {\\n            if (A[i] != i + 1 && A[i] > 0 && A[i] <= n && A[A[i]-1] != A[i])\\n                swap(A[i], A[A[i] - 1]);\\n            else ++i;\\n        }\\n        \\n        for (int i = 0; i != n; ++i)\\n            if (A[i] != i + 1) return i + 1;\\n        return n+1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3259471,
                "title": "very-easy-solution-in-java-using-hashset-with-comment-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUpvote if you like it\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We will simply add add the values of nums[] in the hashset, then we will declare an  integer variable and initialize it with 1.\\n\\n- So it is clear that if an array conatins of counting numbers from 1 the max it can have is the length of the array.\\n\\n- So we\\'ll check for all the integers from 1 to nums.length if anyone is missing simply return it otherwise return nums.length +1.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158509,
                "title": "beats-83-14-first-missing-positive-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe algorithm works as follows:\\n\\nIterate through the array nums.\\nFor each element x in the array, if x is positive and less than or equal to n, and x is not in its correct position, swap it with the element at index x - 1.\\nAfter the above step, all positive integers in the range [1, n] should be in their correct positions.\\nIterate through the array nums again.\\nReturn the first index i where nums[i] != i + 1. The result is i + 1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def firstMissingPositive(self, nums: List[int]) -> int:\\n    n = len(nums)\\n    \\n    for i in range(n):\\n        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\\n    \\n    for i in range(n):\\n        if nums[i] != i + 1:\\n            return i + 1\\n    \\n    return n + 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def firstMissingPositive(self, nums: List[int]) -> int:\\n    n = len(nums)\\n    \\n    for i in range(n):\\n        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\\n    \\n    for i in range(n):\\n        if nums[i] != i + 1:\\n            return i + 1\\n    \\n    return n + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 871770,
                "title": "java-easy-both-bruteforce-and-optimize-solution-0ms-100",
                "content": "**if helpful .. please do Upvote**\\n```\\nclass Solution {\\n    // public int firstMissingPositive(int[] nums) {\\n    //     //1st approach O(n) time and O(n) space\\n    //     Set<Integer> set=new HashSet<>();\\n    //     for(int i:nums){\\n    //         set.add(i);\\n    //     }\\n    //     for(int i=1;i<=nums.length;i++){\\n    //         if(!set.contains(i)){\\n    //             return i;\\n    //         }\\n    //     }\\n    //     return nums.length+1;\\n    // }\\n    \\n    \\n    public int firstMissingPositive(int[] nums) {\\n        //2nd approach O(n) time and O(1) space\\n       boolean oneExist=false;\\n        for(int i:nums){\\n            if(i==1){\\n                oneExist=true;\\n            }\\n        }\\n        if(!oneExist){\\n            return 1;\\n        }\\n        \\n        //making sure we will never see a number in the array apart from 1...n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<=0 || nums[i]>nums.length){\\n                nums[i]=1; //make those numbers 1\\n            }\\n        }\\n        \\n        //Numbers which we are found in the array mark its corresponding indices visited by making them -ve \\n        for(int i=0;i<nums.length;i++){\\n            int n=Math.abs(nums[i]);\\n            if(n==nums.length){\\n                nums[0]=-1*Math.abs(nums[0]);\\n            }\\n            else{\\n                nums[n]=-1*Math.abs(nums[n]);\\n            }\\n        }\\n        \\n        //now 1st +ve number we get in array that corresponding index is our required answer \\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>0){\\n                return i;\\n            }\\n        }\\n        if(nums[0]>0) return nums.length;\\n        \\n        return nums.length+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // public int firstMissingPositive(int[] nums) {\\n    //     //1st approach O(n) time and O(n) space\\n    //     Set<Integer> set=new HashSet<>();\\n    //     for(int i:nums){\\n    //         set.add(i);\\n    //     }\\n    //     for(int i=1;i<=nums.length;i++){\\n    //         if(!set.contains(i)){\\n    //             return i;\\n    //         }\\n    //     }\\n    //     return nums.length+1;\\n    // }\\n    \\n    \\n    public int firstMissingPositive(int[] nums) {\\n        //2nd approach O(n) time and O(1) space\\n       boolean oneExist=false;\\n        for(int i:nums){\\n            if(i==1){\\n                oneExist=true;\\n            }\\n        }\\n        if(!oneExist){\\n            return 1;\\n        }\\n        \\n        //making sure we will never see a number in the array apart from 1...n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<=0 || nums[i]>nums.length){\\n                nums[i]=1; //make those numbers 1\\n            }\\n        }\\n        \\n        //Numbers which we are found in the array mark its corresponding indices visited by making them -ve \\n        for(int i=0;i<nums.length;i++){\\n            int n=Math.abs(nums[i]);\\n            if(n==nums.length){\\n                nums[0]=-1*Math.abs(nums[0]);\\n            }\\n            else{\\n                nums[n]=-1*Math.abs(nums[n]);\\n            }\\n        }\\n        \\n        //now 1st +ve number we get in array that corresponding index is our required answer \\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>0){\\n                return i;\\n            }\\n        }\\n        if(nums[0]>0) return nums.length;\\n        \\n        return nums.length+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549123,
                "title": "python-straight-forward-with-explanation-must-read-beats-99",
                "content": "#3-pass solution\\n       #nums => [3, 4, 1, 0, -1]\\n#Pass 1: Replace all the non-positive numbers by (length of array)+1\\n       #nums => [3, 4, 1, 6, 6]\\n#Pass 2: Treat input array as array of index and make numbers present at the given index negative. \\n       #nums => [-3, 4, -1, -6, 6]\\n#Pass 3: Return the first index with positive number \\n       #Return 2 (As second number is positive)\\n\\n\\ndef firstMissingPositive(self, nums: List[int]) -> int:\\n \\n\\t#Pass 1\\n        for i,n in enumerate(nums):\\n            if n<=0:\\n                nums[i]=len(nums)+1\\n        \\n\\t#Pass 2\\n        for n in nums:\\n            n = abs(n)\\n            if n<=len(nums):\\n                nums[n-1] = -1 * abs(nums[n-1])    \\n     \\n\\t #Pass 3\\n        for i in range(len(nums)):\\n            if nums[i]>0:\\n                return i+1\\n            \\n        return len(nums)+1",
                "solutionTags": [],
                "code": "#3-pass solution\\n       #nums => [3, 4, 1, 0, -1]\\n#Pass 1: Replace all the non-positive numbers by (length of array)+1\\n       #nums => [3, 4, 1, 6, 6]\\n#Pass 2: Treat input array as array of index and make numbers present at the given index negative. \\n       #nums => [-3, 4, -1, -6, 6]\\n#Pass 3: Return the first index with positive number \\n       #Return 2 (As second number is positive)\\n\\n\\ndef firstMissingPositive(self, nums: List[int]) -> int:\\n \\n\\t#Pass 1\\n        for i,n in enumerate(nums):\\n            if n<=0:\\n                nums[i]=len(nums)+1\\n        \\n\\t#Pass 2\\n        for n in nums:\\n            n = abs(n)\\n            if n<=len(nums):\\n                nums[n-1] = -1 * abs(nums[n-1])    \\n     \\n\\t #Pass 3\\n        for i in range(len(nums)):\\n            if nums[i]>0:\\n                return i+1\\n            \\n        return len(nums)+1",
                "codeTag": "Python3"
            },
            {
                "id": 489072,
                "title": "c-simple-o-n-time-beats-100-solution-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/first-missing-positive/solution/\\n    \\n    The idea is to move each number to its correct 0-indexed position. Then traverse\\n    the array for the second time and the first index where the number doesn\\'t match is\\n    the answer. If the array has everything in place, then N + 1 is the answer.\\n    The fact that the array size is N, so even if there are numbers greater than N,\\n    they need not be considered as the array that should be at that place can always be the\\n    answer even if all other numbers are present, so need to consider > N.\\n    \\n    TC: O(N)\\n    SC: O(1)\\n*/\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        for(int i = 0; i < nums.size();) {\\n            // swap the current number to its correct position\\n            if(nums[i] >= 0 && nums[i] - 1 >= 0 && nums[i] - 1 < nums.size()) {\\n                swap(nums[nums[i]-1], nums[i]);\\n            }\\n            // if the current number is -ve, 0 or greater than array length or\\n            // the number is already at its correct position or the correct position\\n            // of the current number already has a duplicate of this, skip current number\\n            if(nums[i] <= 0 || nums[i] == i+1 || nums[i] > nums.size() ||\\n               nums[nums[i]-1] == nums[i])\\n                ++i;\\n        }\\n        \\n        // answer is the first position (1 based) that doesn\\'t match the number there\\n        for(int i = 0; i < nums.size(); i++)\\n            if(nums[i] != i + 1)\\n                return i + 1;\\n        return nums.size() + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/first-missing-positive/solution/\\n    \\n    The idea is to move each number to its correct 0-indexed position. Then traverse\\n    the array for the second time and the first index where the number doesn\\'t match is\\n    the answer. If the array has everything in place, then N + 1 is the answer.\\n    The fact that the array size is N, so even if there are numbers greater than N,\\n    they need not be considered as the array that should be at that place can always be the\\n    answer even if all other numbers are present, so need to consider > N.\\n    \\n    TC: O(N)\\n    SC: O(1)\\n*/\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        for(int i = 0; i < nums.size();) {\\n            // swap the current number to its correct position\\n            if(nums[i] >= 0 && nums[i] - 1 >= 0 && nums[i] - 1 < nums.size()) {\\n                swap(nums[nums[i]-1], nums[i]);\\n            }\\n            // if the current number is -ve, 0 or greater than array length or\\n            // the number is already at its correct position or the correct position\\n            // of the current number already has a duplicate of this, skip current number\\n            if(nums[i] <= 0 || nums[i] == i+1 || nums[i] > nums.size() ||\\n               nums[nums[i]-1] == nums[i])\\n                ++i;\\n        }\\n        \\n        // answer is the first position (1 based) that doesn\\'t match the number there\\n        for(int i = 0; i < nums.size(); i++)\\n            if(nums[i] != i + 1)\\n                return i + 1;\\n        return nums.size() + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 311888,
                "title": "clearing-problem-description-with-detailed-solution-explaination",
                "content": "**Clearing problem description:**\\n- Problem is asking you to find the number \"starting from 1\" which is missing. For example:\\n- - [1,2,0], we are ignoring numbers<=0 so if we write this in order we get \"1 2\" here 3 is first missing positive\\n- - [3,4,-1,1] , writing this in order we get \"1 3 4\" and thus 2 is first missing positive\\n- - [7,8,9,10], starting from 1, here 1 is first missing positive\\n\\n**Solution:**\\nI am going to give you an O(3n) solution but using this similarly you can get the O(2n) solution. Note that both are O(n) solution\\n\\nTake N = length of array\\nFirst of all in array, set all \"zero and numbers greater than N\" to -1 since they are no use to us. I will tell you later why I chose -1.\\n\\nNow for all positive numbers \"p\" left in the array, we will set array[p-1] = 0, but before doing so we should also take care of the number present in (p-1)th position.\\nHere 0 implies that number p is present in the array. So later when we see 0 at index i in array we can say that i+1 is definitely present in the array. \\nAfter settings zeros, the first missing number will be:  index(\"non zero number\") +1\\nIf all are zeros then first missing number will be len(array)+1\\n\\nFor example: [3,4,-1,1] ,\\nApplying above procedure:\\n- when i=0 --> [3 4 0 1]\\n- when i =1 -->[3 4 0 0] --> [0 4 0 0]\\n- when i=2 since idx<0 pass\\n- when i=3 since idx<0 pass\\nwe get [0 4 0 0] so first missing is 2\\n\\n**Algorithm(pseudocode):**\\n\\nFor i in ( 0 to length(array)-1 )\\n**{**\\n\\n p = array[i];  \\n Index idx = p-1;\\n\\nwhile(idx>=0 and idx<length(array)) {\\n* store the value at idx to a variable temp. i.e. temp = array[idx]\\n* Set array[idx] = 0.  \\n* Jump to temp-1 location by doing idx=temp-1 \\n}\\n\\n**}**\\n\\nSo what will happen is that for all the positive numbers the inner loop will jump and set array[idx]=0 for numbers in the array. When temp<=0 then idx=temp-1<0, so inner loop will break. This is why I set useless items to -1.\\nOuter loop will ensure that no numbers are left out.\\n\\nTime complexity is O(3n) because setting all \"zero and numbers greater than N\" to -1 takes O(n),\\nouter loop takes O(n)\\nInner jumps will be at max O(n) because after setting all positive number\\'s corresponding indexes to 0 there will be no jump.\\n\\n**Python code:**\\n```\\ndef firstMissingPositive(self, nums):\\n\\tif not nums:\\n\\t    return 1\\n\\n\\tN = len(nums)\\n\\tfor i in xrange(len(nums)):\\n\\t    if nums[i] ==0 or nums[i] > N:\\n\\t        nums[i] = -1\\n\\tfor i in xrange(len(nums)):\\n\\t    idx = nums[i]-1\\n\\t    while(idx>=0 and idx<N):\\n\\t        tmp = nums[idx]\\n\\t        nums[idx] = 0\\n\\t        idx = tmp-1\\n\\tfor i in xrange(len(nums)):\\n\\t    if nums[i] != 0:\\n\\t        return i+1\\n\\treturn len(nums)+1\\n```\\n\\nThe O(2n) method involves setting array[idx] = idx+1 and breaking the inner while loop when array[idx] = idx+1 is already set",
                "solutionTags": [],
                "code": "```\\ndef firstMissingPositive(self, nums):\\n\\tif not nums:\\n\\t    return 1\\n\\n\\tN = len(nums)\\n\\tfor i in xrange(len(nums)):\\n\\t    if nums[i] ==0 or nums[i] > N:\\n\\t        nums[i] = -1\\n\\tfor i in xrange(len(nums)):\\n\\t    idx = nums[i]-1\\n\\t    while(idx>=0 and idx<N):\\n\\t        tmp = nums[idx]\\n\\t        nums[idx] = 0\\n\\t        idx = tmp-1\\n\\tfor i in xrange(len(nums)):\\n\\t    if nums[i] != 0:\\n\\t        return i+1\\n\\treturn len(nums)+1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3243954,
                "title": "java-easy-approach-constant-space",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nput the element that are in range 1 to n to their correct pos like \\nnums[i]-1 pos. then the first element which does match with their pos is the ans.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int n=nums.length;\\n       int i=0;\\n       while(i<n){\\n           int a=nums[i];\\n           if(a>=1 && a<=n){\\n               if(nums[a-1]!=a){\\n                   nums[i]=nums[a-1];\\n                   nums[a-1]=a;\\n               }\\n               else i++;\\n           }\\n           else{\\n               i++;\\n           }\\n       }\\n      for(int j=0;j<n;j++){\\n          if(nums[j]!=j+1)return j+1;\\n      }\\n      return n+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int n=nums.length;\\n       int i=0;\\n       while(i<n){\\n           int a=nums[i];\\n           if(a>=1 && a<=n){\\n               if(nums[a-1]!=a){\\n                   nums[i]=nums[a-1];\\n                   nums[a-1]=a;\\n               }\\n               else i++;\\n           }\\n           else{\\n               i++;\\n           }\\n       }\\n      for(int j=0;j<n;j++){\\n          if(nums[j]!=j+1)return j+1;\\n      }\\n      return n+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764215,
                "title": "python-o-n-with-explanation-inverse-pigeonhole-principle",
                "content": "Since we have to use constant space (ie. can\\'t allocate something of `nums` size), we can modify the original input array `nums` to help us instead. \\n\\n**Idea:** Modify `nums` in-place as an array that represents each positive integer\\'s (\\u2208 [1, n]) presence. Then scan from left to right to find smallest index without presence.\\n\\n`eg. nums = [3, 4, -1, 1]`\\n\\nFirst, since `nums` is of size n, we know the first missing positive will be in the range [1, n + 1]. Thus, we will transform all values outside of the range [1, n] to n + 1. You will see why I used n + 1 in the next step, but ultimately, it has to be a value > n or = 0.\\n\\n```\\nn = 4\\n[3, 4, 5, 1]\\n```\\n\\nNext, for each x \\u2208 `nums`, if x is in range [1, n], we mark `nums[x - 1]` as a negative value. We use the +/- representation here as a pseudo boolean value (seen in the code below) as we don\\'t want to modify the (absolute) value itself as the value may be accessed later on.\\n\\n`[-3, 4, -5, -1]`\\n\\nFinally, from left to right, if `nums[i] > 0`, then the `i + 1` value must be the first missing positive. If we go through this loop without finding a positive value, then `n + 1` must be the first missing positive.\\n\\n`[-3, 4, -5, -1] -> return 2 ( i = 1)`\\n\\n**Code:**\\n```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(n):\\n            if not (0 < nums[i] <= n):\\n                nums[i] = n + 1\\n        for i in range(n):\\n            x = abs(nums[i])\\n            if 0 < x <= n:\\n                nums[x - 1] = abs(nums[x - 1]) * -1\\n        for i in range(n):\\n            if nums[i] > 0:\\n                return i + 1\\n        return n + 1\\n```\\nPS. This relies on something I\\'ll call inverse pigeonhole principle. If there are n values from [1, m], and each x \\u2208 [1, m] is put into index x - 1 of m containers with n <= m, then at least one container will not have anything, or m + 1 will be the smallest container we have to add that will not have anything.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nn = 4\\n[3, 4, 5, 1]\\n```\n```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(n):\\n            if not (0 < nums[i] <= n):\\n                nums[i] = n + 1\\n        for i in range(n):\\n            x = abs(nums[i])\\n            if 0 < x <= n:\\n                nums[x - 1] = abs(nums[x - 1]) * -1\\n        for i in range(n):\\n            if nums[i] > 0:\\n                return i + 1\\n        return n + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1024371,
                "title": "c-0ms-runtime-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int firstMissingPositive(vector<int>nums)\\n    {\\n        int n=nums.size();\\n        for(int i = 0; i < nums.size(); ++ i)\\n            while(nums[i] > 0 && nums[i] <= nums.size() && nums[nums[i] - 1] != nums[i])\\n                swap(nums[i], nums[nums[i] - 1]);\\n        \\n        for(int i = 0; i < nums.size(); ++ i)\\n            if(nums[i] != i + 1)\\n                return i + 1;\\n        \\n        return n + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int firstMissingPositive(vector<int>nums)\\n    {\\n        int n=nums.size();\\n        for(int i = 0; i < nums.size(); ++ i)\\n            while(nums[i] > 0 && nums[i] <= nums.size() && nums[nums[i] - 1] != nums[i])\\n                swap(nums[i], nums[nums[i] - 1]);\\n        \\n        for(int i = 0; i < nums.size(); ++ i)\\n            if(nums[i] != i + 1)\\n                return i + 1;\\n        \\n        return n + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 722399,
                "title": "no-code-just-explanation-o-n-time-o-1-space-complexity",
                "content": "If we have an array of length n we know \"smallest missing positive integer\" must be in between 1 and n+1(inclusive).\\n\\nFor example:\\n[3,1,2,8,9] in this case we have an array of length n=5, so our smallest missing positive integer must lie between 1 and 5+1 = 6(inclusive).\\n\\nClearly, those values that are greater than n(5) should not be in here. Because if we have any value greater than n those values are occupying some samller values place. For example, 8 is occupying index 3 where we should have either 4 or 5 and also 9 is occupying index 4 where we should have either 5 or 4.\\n\\nThe same goes for any value less than or equal to 0.\\n\\nFor example:\\n[-1,-2,3,1,2]\\n-1 is at index 0 where we should either 4 or 5, the same is true for -2 as well.\\n\\nSo, values that are >n and <=0 are all garbage. We don\\'t need those.\\n\\nLet\\'s modify the array:\\n[3,1,2,8,9] will become [3,1,2,1,1]\\n[-1,-2,3,1,2] will become [1,1,3,1,2]\\n\\nWhy are we putting 1 in place of those values?\\n\\nWe know that, 1 is the smallest positive integer from 1 to infinity.\\n\\nSo if our array does not contain 1 then we know for sure that 1 is going to be the answer. There is no point checking further.\\n\\nBut, if we do have 1 as an item inside the array then some other value[ >1 && <=n ] inside the array which is missing will be the answer. If none are missing then n+1 will be the answer.\\n\\nWith that in mind when we see any garbage value that should not be in this array we replace that value with 1, which we already knew is present in the array. Between garbage value and 1, only 1 is allowed to be present in our modified array.\\n\\nOnce we are done processing our array, we know all the values inside the array should lie between 1 & n(inclusive).\\n\\nOne more processing needs to happen before we look for the answer.\\nAs an easier example, let\\'s say after processing up till this point we got an array like this:\\n[1,2,3,3]\\nIn an ideal case we should have had [1,2,3,4], if all the values were present. Now in this case which one is not present? How can you tell? \\nIf we take each value of each index and update the corresponding value to it\\'s negative then we will have an array like this [-1,-2,-3,3].\\nHow? Take i=2, update whatever is present to negative:\\n```\\n                int index = Math.abs(nums[i])-1;\\n                nums[index] = -Math.abs(nums[index]);\\n```\\n[1,2,2,3] , similarly:\\n[-1,-2,-2,3]\\n\\nAfter that, we will check for the first index where the value is still positive. Our answer will be that index+1.\\n\\nIf this is not the case then our answer will be n+1 since all the values between 1 and n are present in the array.\\n\\nHope this will help anyone who is not looking for code but explanation.\\n\\n**Still need the solution? \\nhttps://nextswe.com/leetcode-41-first-missing-positive/ \\nCode is at the bottom of the explanation.**",
                "solutionTags": [],
                "code": "```\\n                int index = Math.abs(nums[i])-1;\\n                nums[index] = -Math.abs(nums[index]);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17230,
                "title": "java-accepted-no-swap-just-use-push",
                "content": "number i should be in index i-1 of nums.\\nkeep pushing number A into its right place, and push out the existing number B from this place and continue push number B into its right place again.\\n\\ni.e. start from the first number 3\\n \\nIndex:0, 1, 2, 3,  4\\n\\nArray: 3, 4, 5, 1, -1  curr number 3\\n\\nArray: 3, 4, 3, 1, -1 push 3 to index 2, the number being pushed out is 5\\n\\nArray: 3, 4, 3, 1, 5  push 5 to index 4, the number being pushed out is -1, so we stop.\\n\\nArray: 3, 4, 3, 4, 5  next number is 4, push 4 to index 3, the number being pushed out is 1\\n\\nArray: 1, 4, 3, 4, 5  push 1 to index 0, the number being pushed out is 3\\n\\nArray: 1, 4, 3, 4, 5  since 3 is already at index 2 (right place), we stop\\n\\ncheck next number is 3 (already right place), then 4 (right place), then 5 (right place), stop.\\n\\nNow we compare each number with its index, should be number == index+1, otherwise the number is the first missing positive.\\n\\n    public class Solution {\\n        public int firstMissingPositive(int[] nums) {\\n            // nums[i] -> i+1\\n            int next;\\n            for (int i = 0 ; i < nums.length; i++) {\\n                int curr = nums[i];\\n                if (curr > 0 && curr != i+1 && curr <= nums.length) {\\n                    do {\\n                        next = nums[curr-1];\\n                        nums[curr-1] = curr;\\n                        curr = next;\\n                    } while (curr > 0 && curr <= nums.length && nums[curr-1] != curr);\\n                }\\n            }\\n            int j;\\n            for (j = 0; j < nums.length; j++) {\\n                if (nums[j] != j+1)\\n                    break;\\n            }\\n            return j+1;\\n        }\\n    }",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution {\\n        public int firstMissingPositive(int[] nums) {\\n            // nums[i] -> i+1\\n            int next;\\n            for (int i = 0 ; i < nums.length; i++) {\\n                int curr = nums[i];\\n                if (curr > 0 && curr != i+1 && curr <= nums.length) {\\n                    do {\\n                        next = nums[curr-1];\\n                        nums[curr-1] = curr;\\n                        curr = next;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 17256,
                "title": "short-python-solution-using-abs",
                "content": "set the index of the corresponding number to negative if the number does not exceed the length of list.\\n\\n    class Solution(object):\\n        def firstMissingPositive(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: int\\n            \"\"\"\\n            n = len(nums)\\n            for i in xrange(n):\\n                if nums[i] <= 0: nums[i] = len(nums)+1\\n            for i in xrange(n):\\n                if abs(nums[i]) <= n: nums[abs(nums[i])-1] = -abs(nums[abs(nums[i])-1])\\n            for i in xrange(n):\\n                if nums[i] > 0: return i+1\\n            return n+1",
                "solutionTags": [
                    "Python"
                ],
                "code": "set the index of the corresponding number to negative if the number does not exceed the length of list.\\n\\n    class Solution(object):\\n        def firstMissingPositive(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: int\\n            \"\"\"\\n            n = len(nums)\\n            for i in xrange(n):\\n                if nums[i] <= 0: nums[i] = len(nums)+1\\n            for i in xrange(n):\\n                if abs(nums[i]) <= n: nums[abs(nums[i])-1] = -abs(nums[abs(nums[i])-1])\\n            for i in xrange(n):\\n                if nums[i] > 0: return i+1\\n            return n+1",
                "codeTag": "Java"
            },
            {
                "id": 2644922,
                "title": "both-apporch-you-can-understand-easily",
                "content": "```\\nint firstMissingPositive(vector<int>& nums) {\\n\\n        unordered_map<int,int>m;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n           m[nums[i]]++;\\n        }\\n        for(int i=1;i<=n+1;i++)\\n        {\\n            if(m.find(i)==m.end())\\n                return i;\\n        }\\n        return -1;\\n    }\\n\\t// t(c)=o(n)\\n\\ts(c)=o(n)\\n\\t\\n\\t\\n\\t// swap sort\\n\\t int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0,j=0;\\n        while(i<n)\\n        {\\n            if(nums[i]>0&&nums[i]<=n&&nums[i]!=nums[nums[i]-1])\\n                swap(nums[i],nums[nums[i]-1]);\\n            else\\n                i++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]!=i+1)\\n            {\\n               return i+1;\\n            }\\n        }\\n        return n+1;\\n    }\\n\\t\\tt(c)=o(n);\\n\\t\\ts(c)=o(1);\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint firstMissingPositive(vector<int>& nums) {\\n\\n        unordered_map<int,int>m;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n           m[nums[i]]++;\\n        }\\n        for(int i=1;i<=n+1;i++)\\n        {\\n            if(m.find(i)==m.end())\\n                return i;\\n        }\\n        return -1;\\n    }\\n\\t// t(c)=o(n)\\n\\ts(c)=o(n)\\n\\t\\n\\t\\n\\t// swap sort\\n\\t int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0,j=0;\\n        while(i<n)\\n        {\\n            if(nums[i]>0&&nums[i]<=n&&nums[i]!=nums[nums[i]-1])\\n                swap(nums[i],nums[nums[i]-1]);\\n            else\\n                i++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]!=i+1)\\n            {\\n               return i+1;\\n            }\\n        }\\n        return n+1;\\n    }\\n\\t\\tt(c)=o(n);\\n\\t\\ts(c)=o(1);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2148440,
                "title": "cpp-solution-with-added-comments-o-1-memory-o-n-time",
                "content": "#  Runtime 54.15% and Memory 77.83%\\n\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        \\n//         we have no use with -ve elements iin list so, make them useless by making them out of range\\n       \\n        for(int i=0;i<nums.size();i++){\\n            if (nums[i]<=0){\\n                nums[i] = nums.size()+1;\\n            }\\n        }\\n       //         we convert our existing array to a map, without using extra space\\n//  so, all we need to check if you have the elements in range[1,nums.size()+1]\\n//         so basically if that element is present just go to tht index and make it negative\\n        for(int i =0;i<nums.size();i++){\\n            int ind = abs(nums[i])-1;\\n            if (ind>=0 and ind<nums.size() and nums[ind]>0) \\n                nums[ind]=-nums[ind];\\n        }\\n//         finally the missing element basically wont be flagged negative so return that position\\n        for(int i=0;i<nums.size();i++){\\n            if (nums[i]>=0)\\n                return i+1;\\n        }\\n// in case the array was flagged completely negative basically the missing element is 1 more than size of array\\n        return nums.size()+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        \\n//         we have no use with -ve elements iin list so, make them useless by making them out of range\\n       \\n        for(int i=0;i<nums.size();i++){\\n            if (nums[i]<=0){\\n                nums[i] = nums.size()+1;\\n            }\\n        }\\n       //         we convert our existing array to a map, without using extra space\\n//  so, all we need to check if you have the elements in range[1,nums.size()+1]\\n//         so basically if that element is present just go to tht index and make it negative\\n        for(int i =0;i<nums.size();i++){\\n            int ind = abs(nums[i])-1;\\n            if (ind>=0 and ind<nums.size() and nums[ind]>0) \\n                nums[ind]=-nums[ind];\\n        }\\n//         finally the missing element basically wont be flagged negative so return that position\\n        for(int i=0;i<nums.size();i++){\\n            if (nums[i]>=0)\\n                return i+1;\\n        }\\n// in case the array was flagged completely negative basically the missing element is 1 more than size of array\\n        return nums.size()+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704248,
                "title": "easy-c-solution-with-full-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- First, we store the minimum value in ***mn*** & in between make all values 1 which are less than 1 or greater than n.\\n- **The logic behind it:** if the array is size n, then max possible n positive character. if any value is greater than n, then there is already an element from 1 to n that is not present.\\n- After the loop ends, if we find ***mn is greater than 1***, that means 1 is not present & simply ***return 1***.\\n- Else we\\u2019ll iterate again & go to the index from elements and if it\\u2019s not negative then make it negative.\\n- Again iterate all elements & the first index where ***the element is positive***, which means that element is not present. So ***return i+1***.\\n- Still, we iterate all elements and didn\\u2019t find the ans that means elements are from 1 to n, in the array, so return ***n+1***.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int mn=INT_MAX;\\n        int n=nums.size();\\n        \\n        for(int i=0; i<n; i++){\\n            if(nums[i]>0 && mn>nums[i])\\n                mn = nums[i];\\n            if(nums[i]<1 || nums[i]>n) \\n                nums[i]=1;\\n        }\\n        if(mn > 1)\\n            return 1;\\n        \\n        for(int i=0; i<n; i++){\\n            if(nums[abs(nums[i])-1]>0) \\n                nums[abs(nums[i])-1] *= -1;            \\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            if(nums[i]>0) return i+1;\\n        }\\n        \\n        return n+1;\\n    }\\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int mn=INT_MAX;\\n        int n=nums.size();\\n        \\n        for(int i=0; i<n; i++){\\n            if(nums[i]>0 && mn>nums[i])\\n                mn = nums[i];\\n            if(nums[i]<1 || nums[i]>n) \\n                nums[i]=1;\\n        }\\n        if(mn > 1)\\n            return 1;\\n        \\n        for(int i=0; i<n; i++){\\n            if(nums[abs(nums[i])-1]>0) \\n                nums[abs(nums[i])-1] *= -1;            \\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            if(nums[i]>0) return i+1;\\n        }\\n        \\n        return n+1;\\n    }\\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318705,
                "title": "java-1-ms-time-beats-96-3-progressive-methods-with-idea",
                "content": "**Method 1:**\\n**T/S:** O(n lg n)/O(1)\\n```\\npublic int firstMissingPositive(int[] nums) {\\n\\tArrays.sort(nums);\\n\\tvar lastPositiveSeen = 1;\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tif (nums[i] <= 0 || (i > 0 && nums[i] == nums[i - 1])) // ignore non-positives and duplicates\\n\\t\\t\\tcontinue;\\n\\t\\tif (nums[i] == lastPositiveSeen)\\n\\t\\t\\tlastPositiveSeen++;\\n\\t\\telse\\n\\t\\t\\tbreak;\\n\\t}\\n\\treturn lastPositiveSeen;\\n}\\n```\\n\\n**Method 2:**\\n**T/S:** O(n)/O(n)\\n```\\npublic int firstMissingPositive(int[] nums) {\\n\\tvar max = Integer.MIN_VALUE;\\n\\tvar set = new HashSet<Integer>();\\n\\tfor (var num : nums) {\\n\\t\\tset.add(num);\\n\\t\\tmax = Math.max(max, num);\\n\\t}\\n\\tif (max < 1)\\n\\t\\treturn 1;\\n\\tfor (var i = 1; i <= max; i++)\\n\\t\\tif (!set.contains(i))\\n\\t\\t\\treturn i;\\n\\treturn max + 1;\\n}\\n```\\n\\n**Method 3:**\\n**Idea:**\\n* Progress from Method 2 to Method 3, thinking on the line of O(1) time access. Index of array can be paired up with values of array to give a hint on the solution.\\n* Ignore non-positives.\\n* The technique is a bit similar to wiggle sort. \\n* It needs some practice, experience and hitting the questions from multiple directions to arrive to this solution.\\n* Constant run-time in arrays is usually achieved with two-pointers, swapping, multi-scan (this question required traversing the array twice) etc.\\n* Arrays provide O(1) time access and are often used as look-up tables if the keys (array index) can be kept within bounds.\\n* Here we put positives in their \"right place\" which is defined as value of the number - 1\\n\\n**T/S:** O(n)/O(1) (This constraint makes it LC Hard)\\n```\\npublic int firstMissingPositive(int[] nums) {\\n\\tvar n = nums.length;\\n\\tfor (var i = 0; i < nums.length; i++)\\n\\t\\t//  put positives in their right place as long as possible\\n\\t\\twhile (0 <= nums[i] - 1 && nums[i] - 1 < n && nums[i] != nums[nums[i] - 1]) \\n\\t\\t\\tswap(nums, nums[i] - 1, i);\\n\\n\\t// scan for first missing positive\\n\\tfor (var i = 0; i < n; i++)\\n\\t\\tif (nums[i] != i + 1)\\n\\t\\t\\treturn i + 1;\\n\\treturn n + 1;\\n}\\n\\nprivate void swap(int[] nums, int i, int j) {\\n\\tvar temp = nums[i];\\n\\tnums[i] = nums[j];\\n\\tnums[j] = temp;\\n}\\n```\\n\\n```\\nWhat swap would look like for this array: [2, 3, 7, 6, 8, -1, -10, 15]\\n\\n[2, 3, 7, 6, 8, -1, -10, 15]\\n[3, 2, 7, 6, 8, -1, -10, 15]\\n[7, 2, 3, 6, 8, -1, -10, 15]\\n[-10, 2, 3, 6, 8, -1, 7, 15]\\n[-10, 2, 3, -1, 8, 6, 7, 15]\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int firstMissingPositive(int[] nums) {\\n\\tArrays.sort(nums);\\n\\tvar lastPositiveSeen = 1;\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tif (nums[i] <= 0 || (i > 0 && nums[i] == nums[i - 1])) // ignore non-positives and duplicates\\n\\t\\t\\tcontinue;\\n\\t\\tif (nums[i] == lastPositiveSeen)\\n\\t\\t\\tlastPositiveSeen++;\\n\\t\\telse\\n\\t\\t\\tbreak;\\n\\t}\\n\\treturn lastPositiveSeen;\\n}\\n```\n```\\npublic int firstMissingPositive(int[] nums) {\\n\\tvar max = Integer.MIN_VALUE;\\n\\tvar set = new HashSet<Integer>();\\n\\tfor (var num : nums) {\\n\\t\\tset.add(num);\\n\\t\\tmax = Math.max(max, num);\\n\\t}\\n\\tif (max < 1)\\n\\t\\treturn 1;\\n\\tfor (var i = 1; i <= max; i++)\\n\\t\\tif (!set.contains(i))\\n\\t\\t\\treturn i;\\n\\treturn max + 1;\\n}\\n```\n```\\npublic int firstMissingPositive(int[] nums) {\\n\\tvar n = nums.length;\\n\\tfor (var i = 0; i < nums.length; i++)\\n\\t\\t//  put positives in their right place as long as possible\\n\\t\\twhile (0 <= nums[i] - 1 && nums[i] - 1 < n && nums[i] != nums[nums[i] - 1]) \\n\\t\\t\\tswap(nums, nums[i] - 1, i);\\n\\n\\t// scan for first missing positive\\n\\tfor (var i = 0; i < n; i++)\\n\\t\\tif (nums[i] != i + 1)\\n\\t\\t\\treturn i + 1;\\n\\treturn n + 1;\\n}\\n\\nprivate void swap(int[] nums, int i, int j) {\\n\\tvar temp = nums[i];\\n\\tnums[i] = nums[j];\\n\\tnums[j] = temp;\\n}\\n```\n```\\nWhat swap would look like for this array: [2, 3, 7, 6, 8, -1, -10, 15]\\n\\n[2, 3, 7, 6, 8, -1, -10, 15]\\n[3, 2, 7, 6, 8, -1, -10, 15]\\n[7, 2, 3, 6, 8, -1, -10, 15]\\n[-10, 2, 3, 6, 8, -1, 7, 15]\\n[-10, 2, 3, -1, 8, 6, 7, 15]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 478668,
                "title": "java-clean-100-o-1-space-o-n-time-comments",
                "content": "```    \\n    /**\\n     * The insight here is that each number in the array must fall within the size of the array.\\n     * For example, if the size of the array is 20, then the first missing positive integer has\\n     * to be [1..21] (note 21 is the case where all the given numbers fall within the size of\\n     * the array).\\n     *\\n     * So, to figure out which number is missing, we place each number into the index that cooresponds\\n     * to the numbers\\'s value+1 (similar to a modified count sort).  If the number falls outside the\\n     * range of the array then it can\\'t be a missing value.\\n     *\\n     * Finally, we run through the array to find which index didn\\'t have a corresponding value.\\n     * In the case all values are present then the first one \"missing\" is the length of the array+1.\\n     */\\n    public static int firstMissingPositive(int[] nums) {\\n        \\n        for (int i=0; i < nums.length; i++) {\\n            int insertIdx = nums[i]-1;\\n            if (insertIdx >= 0 && insertIdx < nums.length && nums[insertIdx] != nums[i]) {\\n                int temp = nums[insertIdx];\\n                nums[insertIdx] = nums[i];\\n                nums[i] = temp;\\n                i--;\\n            }\\n        }\\n\\n        for (int i=0; i < nums.length; i++) {\\n            if (nums[i]-1 != i) return i+1;\\n        }\\n\\n        return nums.length+1;\\n    }",
                "solutionTags": [],
                "code": "```    \\n    /**\\n     * The insight here is that each number in the array must fall within the size of the array.\\n     * For example, if the size of the array is 20, then the first missing positive integer has\\n     * to be [1..21] (note 21 is the case where all the given numbers fall within the size of\\n     * the array).\\n     *\\n     * So, to figure out which number is missing, we place each number into the index that cooresponds\\n     * to the numbers\\'s value+1 (similar to a modified count sort).  If the number falls outside the\\n     * range of the array then it can\\'t be a missing value.\\n     *\\n     * Finally, we run through the array to find which index didn\\'t have a corresponding value.\\n     * In the case all values are present then the first one \"missing\" is the length of the array+1.\\n     */\\n    public static int firstMissingPositive(int[] nums) {\\n        \\n        for (int i=0; i < nums.length; i++) {\\n            int insertIdx = nums[i]-1;\\n            if (insertIdx >= 0 && insertIdx < nums.length && nums[insertIdx] != nums[i]) {\\n                int temp = nums[insertIdx];\\n                nums[insertIdx] = nums[i];\\n                nums[i] = temp;\\n                i--;\\n            }\\n        }\\n\\n        for (int i=0; i < nums.length; i++) {\\n            if (nums[i]-1 != i) return i+1;\\n        }\\n\\n        return nums.length+1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 231337,
                "title": "python-solution",
                "content": "Idea: change `nums[n-1]` to `float(\\'inf\\')` for all `n` in `nums` if `1 <= n <= len(nums)`, meaning that we have seen `n` in `nums`. Then we traverse `nums` once more, and find the first `idx` such that `nums[idx] != float(\\'inf\\')`, then `idx+1` will be the first missing positive in `nums`. If no such `idx` exists, it means that we have seen `1, 2, ..., len(nums)` in `nums`, hence the first missing positive is `len(nums)+1`.\\n\\nTime complexity: `O(n)`, space complexity: `O(1)`.\\n\\n```\\nclass Solution:\\n    def firstMissingPositive(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        for i, n in enumerate(nums):\\n            if n < 0:\\n                continue\\n            else:\\n                while n <= len(nums) and n > 0:\\n                    tmp = nums[n-1]\\n                    nums[n-1] = float(\\'inf\\')\\n                    n = tmp\\n        for i in range(len(nums)):\\n            if nums[i] != float(\\'inf\\'):\\n                return i+1\\n            \\n        return len(nums)+1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        for i, n in enumerate(nums):\\n            if n < 0:\\n                continue\\n            else:\\n                while n <= len(nums) and n > 0:\\n                    tmp = nums[n-1]\\n                    nums[n-1] = float(\\'inf\\')\\n                    n = tmp\\n        for i in range(len(nums)):\\n            if nums[i] != float(\\'inf\\'):\\n                return i+1\\n            \\n        return len(nums)+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 181362,
                "title": "o-n-time-o-1-space-solution-x-2",
                "content": "### Solution 1\\nMark all non-positve `nums` as `MAX`, and mark `nums[abs(nums[i]) - 1]` as negative when we first met `abs(nums[i])`. In this way, the first missing positive is the `index` of the first positive element in nums `+ 1`\\n****\\n```\\n    public int firstMissingPositive(int[] nums) {\\n        if (nums.length == 0) return 1;\\n        \\n        int numLen = nums.length;\\n\\t\\t\\n        // Mark non-positive as MAX.\\n        for (int i = 0; i < numLen; i++) {\\n            if (nums[i] <= 0) nums[i] = Integer.MAX_VALUE;\\n        }\\n        \\n        // Mark on original array.\\n        for (int i = 0; i < numLen; i++) {\\n            int absNum = Math.abs(nums[i]);\\n            if (absNum != Integer.MAX_VALUE && absNum - 1 < numLen && nums[absNum - 1] > 0) {\\n                nums[absNum - 1] = -nums[absNum - 1];\\n            }\\n        }\\n        \\n        // Get first missing positive.\\n        for (int i = 0; i < numLen; i++) {\\n            if (nums[i] > 0) return i + 1;  \\n        }\\n\\n        return numLen + 1;\\n    }\\n```\\n### Solution 2\\nIf nums are consecutive, then `each nums[i] == i + 1`. If we put valid nums[i] into their right position by swapping, then the first `i + 1 such that nums[i] != i + 1` must be the first missing number.\\n```\\n    public int firstMissingPositive(int[] nums) {\\n        for (int i = 0; i < nums.length; i++) {\\n            while (nums[i] != i + 1 \\n                && nums[i] >= 1\\n                && nums[i] <= nums.length\\n                && nums[nums[i] - 1] != nums[i]) {\\n                swap(i, nums[i] - 1, nums);\\n            }\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != i + 1)\\n                return i + 1;\\n        }\\n        \\n        return nums.length + 1;\\n    }\\n    \\n    \\n    private void swap(int i, int j, int[] nums) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int firstMissingPositive(int[] nums) {\\n        if (nums.length == 0) return 1;\\n        \\n        int numLen = nums.length;\\n\\t\\t\\n        // Mark non-positive as MAX.\\n        for (int i = 0; i < numLen; i++) {\\n            if (nums[i] <= 0) nums[i] = Integer.MAX_VALUE;\\n        }\\n        \\n        // Mark on original array.\\n        for (int i = 0; i < numLen; i++) {\\n            int absNum = Math.abs(nums[i]);\\n            if (absNum != Integer.MAX_VALUE && absNum - 1 < numLen && nums[absNum - 1] > 0) {\\n                nums[absNum - 1] = -nums[absNum - 1];\\n            }\\n        }\\n        \\n        // Get first missing positive.\\n        for (int i = 0; i < numLen; i++) {\\n            if (nums[i] > 0) return i + 1;  \\n        }\\n\\n        return numLen + 1;\\n    }\\n```\n```\\n    public int firstMissingPositive(int[] nums) {\\n        for (int i = 0; i < nums.length; i++) {\\n            while (nums[i] != i + 1 \\n                && nums[i] >= 1\\n                && nums[i] <= nums.length\\n                && nums[nums[i] - 1] != nums[i]) {\\n                swap(i, nums[i] - 1, nums);\\n            }\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != i + 1)\\n                return i + 1;\\n        }\\n        \\n        return nums.length + 1;\\n    }\\n    \\n    \\n    private void swap(int i, int j, int[] nums) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2599047,
                "title": "1-ms-java-solution-o-n-time-and-o-1-space",
                "content": "if you like it please upvote it\\n\\nclass Solution \\n{\\npublic int firstMissingPositive(int[] nums)\\n{\\n      int n=nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<=0 || nums[i]>n)\\n            { \\n              nums[i]=n+1;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int val=Math.abs(nums[i]);\\n            if(val>n)continue;\\n            \\n            if(nums[val-1]>0)\\n             nums[val-1]=-nums[val-1];\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]>0)return i+1;\\n        }\\n        \\n        return n+1;\\n        \\n    }\\n}\\n-------------------------------------------------------------------\\n![image](https://assets.leetcode.com/users/images/d0c2c8ad-0b3c-46eb-94f0-75caf904b4c4_1663623875.2498913.png)\\n-------------------------------------------------------------------\\nApproach Explaination :- \\n-----------------\\n1. Assign all the values which is less than 1 and greater than n as n+1\\n2. Now iterate value one by one and mark the value as negative . Negative means value exist in array.\\n3. After completion of previous step iterate array again .\\n4. Now check for positive value  ! if you find any return index+1 . else return n+1\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution \\n{\\npublic int firstMissingPositive(int[] nums)\\n{\\n      int n=nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<=0 || nums[i]>n)\\n            { \\n              nums[i]=n+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1641066,
                "title": "c-logical-solution-without-maps",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n        \\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[nums[i]-1])\\n            {\\n                swap(nums[i],nums[nums[i]-1]);\\n            }\\n            \\n        }\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]!=i+1)\\n            {\\n                return i+1;\\n            }\\n        }\\n        \\n        return n+1;\\n        \\n    }\\n};\\n\\n\\n// please upvote if found helpful",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n        \\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[nums[i]-1])\\n            {\\n                swap(nums[i],nums[nums[i]-1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1326347,
                "title": "6-lines-solution-c-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int i;\\n        for (i = 0; i < nums.size(); i++)\\n            if (nums[i] <= 0) nums[i] = 1000000;\\n\\t\\t\\t\\n        for (i = 0; i < nums.size(); i++)\\n            if (abs(nums[i]) - 1 < nums.size())\\n                nums[abs(nums[i]) - 1] = -abs(nums[abs(nums[i]) - 1]);\\n\\t\\t\\t\\t\\n        for (i = 0; i < nums.size(); i++) if (nums[i] > 0) break;\\n        return i + 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int i;\\n        for (i = 0; i < nums.size(); i++)\\n            if (nums[i] <= 0) nums[i] = 1000000;\\n\\t\\t\\t\\n        for (i = 0; i < nums.size(); i++)\\n            if (abs(nums[i]) - 1 < nums.size())\\n                nums[abs(nums[i]) - 1] = -abs(nums[abs(nums[i]) - 1]);\\n\\t\\t\\t\\t\\n        for (i = 0; i < nums.size(); i++) if (nums[i] > 0) break;\\n        return i + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 764421,
                "title": "c-o-1-space-o-n-time-with-explanation",
                "content": "For an array size of ```N```, we have that the first missing positive is between ```0``` and ```N+1```. This may take some time to think about but the best case is you have all the positive integers from ```0``` to ```N```, in which case the answer is ```N+1```. If you change any one of those values to something greater than ```N``` or less than ```0```, then the answer will be between ```0``` and ```N+1```. So this property holds.\\n\\nWe can abuse this property. Any number less than ```0``` and greater than ```N+1``` will not be inside this range. So we can iterate through and change these values to ```N+1``` (to keep it simple, but they need to be set to something that is at least ```N+1``` or bigger) since they are useless to us.\\n\\nThe next step is to iterate through the array again and use a simple hack: treat the numbers as indicies. We index the array using this value and we make the indexed value negative to \"tick\" it off. We need to remember to take the absoloute value every time we calculate the index because we are using the array for two purposes: to keep track which ones we tick off, and which ones we need to tick off still. This may be a little unintitive so here is how I thought about it (using an extrra array for visual purposes only):\\n\\nStarting array: ```[-5, 2, 3, 5, 1, 8]```\\nTicked off (```#``` is none, ```-``` is ticked): ```[#,#,#,#,#,#]```\\n\\nAfter setting to ```N+1```: ```[7, 2, 3, 5, 1, 7]```\\nTicked off: ```[#,#,#,#,#,#]```\\n\\nWe index ```nums[abs(7-1)]``` which is invalid. So we have\\nArray: ```[7, 2, 3, 5, 1, 7]```\\nTicked off: ```[#,#,#,#,#,#]```\\n\\n\\nWe index ```nums[abs(2)-1]``` which is ```2```. So we have\\nArray: ```[7, -2, 3, 5, 1, 7]```\\nTicked off: ```[#,-,#,#,#,#]```\\n\\nWe index ```nums[abs(3)-1]``` which is ```3```. So we have\\nArray: ```[7, -2, -3, 5, 1, 7]```\\nTicked off: ```[#,-,-,#,#,#]```\\n\\nWe index ```nums[abs(5)-1]``` which is ```1```. So we have\\nArray: ```[7, -2, -3, 5, -1, 7]```\\nTicked off: ```[#,-,-,#,-,#]```\\n\\nWe index ```nums[abs(-1)-1]``` which is ```7```. So we have\\nArray: ```[-7, -2, -3, 5, -1, 7]```\\nTicked off: ```[-,-,-,#,-,#]```\\n\\nWe index ```nums[abs(7)-1]``` which is not valid. So we have\\nArray: ```[-7, -2, -3, 5, 1, 7]```\\nTicked off: ```[-,-,-,#,-,#]```\\n\\nWe can see from the example that the ticked array matches the signs in the original array.\\n\\nWe finally iterate through the array (the index of the array starts at ```1``` for this problem) and return the first index that has a positive number. This will be the first number that has not been ticked off yet. So in the example, we would return ```4``` as ```nums[4]=5``` is not ticked off.\\n\\nHere is the code for reference:\\n\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int negatives = nums.size()-1;\\n        \\n        // change all negative numbers and numbers bigger than N \\n\\t\\t// (the amount of elements in the list)\\n        for (int i = nums.size()-1; i >= 0; i--){\\n            if (nums[i] <= 0 || nums[i] > nums.size()){\\n                nums[i] = nums.size()+1;\\n            }\\n        }\\n        \\n        int min = 1;\\n        \\n        // use nums[i] as the index and mark them off\\n        for (int i =0; i < nums.size(); i++){\\n            int index = abs(nums[i])-1;\\n            \\n            // check to see if it\\'s within the bounds and indexable\\n\\t\\t\\t// and check to not tick off the same value twice\\n            if ((index < nums.size() && index >= 0) && nums[index] > 0){\\n                nums[index] = -nums[index];\\n            }\\n        }\\n        \\n        // first positive value not ticked off \\n        for (min = 0; min < nums.size(); min++){\\n            if (nums[min] > 0){\\n                break;\\n            }\\n        }\\n        return min+1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```N```\n```0```\n```N+1```\n```0```\n```N```\n```N+1```\n```N```\n```0```\n```0```\n```N+1```\n```0```\n```N+1```\n```N+1```\n```N+1```\n```[-5, 2, 3, 5, 1, 8]```\n```#```\n```-```\n```[#,#,#,#,#,#]```\n```N+1```\n```[7, 2, 3, 5, 1, 7]```\n```[#,#,#,#,#,#]```\n```nums[abs(7-1)]```\n```[7, 2, 3, 5, 1, 7]```\n```[#,#,#,#,#,#]```\n```nums[abs(2)-1]```\n```2```\n```[7, -2, 3, 5, 1, 7]```\n```[#,-,#,#,#,#]```\n```nums[abs(3)-1]```\n```3```\n```[7, -2, -3, 5, 1, 7]```\n```[#,-,-,#,#,#]```\n```nums[abs(5)-1]```\n```1```\n```[7, -2, -3, 5, -1, 7]```\n```[#,-,-,#,-,#]```\n```nums[abs(-1)-1]```\n```7```\n```[-7, -2, -3, 5, -1, 7]```\n```[-,-,-,#,-,#]```\n```nums[abs(7)-1]```\n```[-7, -2, -3, 5, 1, 7]```\n```[-,-,-,#,-,#]```\n```1```\n```4```\n```nums[4]=5```\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int negatives = nums.size()-1;\\n        \\n        // change all negative numbers and numbers bigger than N \\n\\t\\t// (the amount of elements in the list)\\n        for (int i = nums.size()-1; i >= 0; i--){\\n            if (nums[i] <= 0 || nums[i] > nums.size()){\\n                nums[i] = nums.size()+1;\\n            }\\n        }\\n        \\n        int min = 1;\\n        \\n        // use nums[i] as the index and mark them off\\n        for (int i =0; i < nums.size(); i++){\\n            int index = abs(nums[i])-1;\\n            \\n            // check to see if it\\'s within the bounds and indexable\\n\\t\\t\\t// and check to not tick off the same value twice\\n            if ((index < nums.size() && index >= 0) && nums[index] > 0){\\n                nums[index] = -nums[index];\\n            }\\n        }\\n        \\n        // first positive value not ticked off \\n        for (min = 0; min < nums.size(); min++){\\n            if (nums[min] > 0){\\n                break;\\n            }\\n        }\\n        return min+1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746638,
                "title": "o-n-time-o-1-space-0ms-solution-beats-100",
                "content": "```\\n    int firstMissingPositive(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0 && nums[i]<=nums.size() && nums[i]!=nums[nums[i]-1])\\n            {\\n                swap(nums[i],nums[nums[i]-1]);\\n                i--;\\n            }\\n        }\\n        int ans=-1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]!=i+1)\\n            {\\n                ans=i+1;\\n                break;\\n            }\\n        }\\n        if(ans==-1)\\n        {\\n            ans=nums.size()+1;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    int firstMissingPositive(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0 && nums[i]<=nums.size() && nums[i]!=nums[nums[i]-1])\\n            {\\n                swap(nums[i],nums[nums[i]-1]);\\n                i--;\\n            }\\n        }\\n        int ans=-1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]!=i+1)\\n            {\\n                ans=i+1;\\n                break;\\n            }\\n        }\\n        if(ans==-1)\\n        {\\n            ans=nums.size()+1;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 566511,
                "title": "simple-python-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        #Sorting positive numbers according to their space E.g [1,2,3,4]\\n        index = 0\\n        while index < len(nums):\\n            # Already in the place\\n            if index + 1 == nums[index]:    \\n                index += 1\\n            # No-use\\n            elif nums[index] <= 0:       \\n                  index += 1\\n            # No-use\\n            elif nums[index] > len(nums):  \\n                   index += 1\\n            # Already swapped\\n            elif nums[index] == nums[nums[index]-1]:\\n                index += 1\\n            else:\\n                A,B = index,nums[index]-1\\n                nums[A], nums[B] = nums[B], nums[A]\\n                \\n        #Smallest no which does not follow the true space\\n        for index in range(len(nums)):\\n            if index + 1 != nums[index]:   \\n                return index + 1\\n        # Otherwise, return the next positive number\\n        return len(nums) + 1\\n```\\n\\nNOTE : Improvements and comments are welcomed.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        #Sorting positive numbers according to their space E.g [1,2,3,4]\\n        index = 0\\n        while index < len(nums):\\n            # Already in the place\\n            if index + 1 == nums[index]:    \\n                index += 1\\n            # No-use\\n            elif nums[index] <= 0:       \\n                  index += 1\\n            # No-use\\n            elif nums[index] > len(nums):  \\n                   index += 1\\n            # Already swapped\\n            elif nums[index] == nums[nums[index]-1]:\\n                index += 1\\n            else:\\n                A,B = index,nums[index]-1\\n                nums[A], nums[B] = nums[B], nums[A]\\n                \\n        #Smallest no which does not follow the true space\\n        for index in range(len(nums)):\\n            if index + 1 != nums[index]:   \\n                return index + 1\\n        # Otherwise, return the next positive number\\n        return len(nums) + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 271306,
                "title": "java-0ms-solution",
                "content": "The idea is simple: put the positive integer ```n``` (```n > 0``` and ```n <= array.length```) at index ```n - 1```.  Then traverse the array, if ```nums[index] != index + 1```, then we find the first miss positive number. \\n```\\npublic int firstMissingPositive(int[] nums) {\\n\\tfor(int i = 0; i < nums.length; i++) {\\n\\t\\twhile( nums[i] > 0 && nums[i] <= nums.length ) {\\n\\t\\t\\tint temp = nums[nums[i] - 1];\\n\\t\\t\\tif( temp == nums[i] ) // If nums[nums[i] - 1] equals nums[i], then we don\\'t need to exchange them\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tnums[nums[i] - 1] = nums[i];\\n\\t\\t\\tnums[i] = temp;\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 0; i < nums.length; i++) \\n\\t\\tif( nums[i] != i + 1 )\\n\\t\\t\\treturn i + 1;\\n\\treturn nums.length + 1;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```n```\n```n > 0```\n```n <= array.length```\n```n - 1```\n```nums[index] != index + 1```\n```\\npublic int firstMissingPositive(int[] nums) {\\n\\tfor(int i = 0; i < nums.length; i++) {\\n\\t\\twhile( nums[i] > 0 && nums[i] <= nums.length ) {\\n\\t\\t\\tint temp = nums[nums[i] - 1];\\n\\t\\t\\tif( temp == nums[i] ) // If nums[nums[i] - 1] equals nums[i], then we don\\'t need to exchange them\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tnums[nums[i] - 1] = nums[i];\\n\\t\\t\\tnums[i] = temp;\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 0; i < nums.length; i++) \\n\\t\\tif( nums[i] != i + 1 )\\n\\t\\t\\treturn i + 1;\\n\\treturn nums.length + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17208,
                "title": "c-solution-no-extra-memory-using-pseudo-sort",
                "content": " The answer is between 1 and n, where n is the size of the vector and the trick is that you have to \"pseudo sort\", what I mean with that? Well, if the number nums[i] is between 1 and n you have to put it in the correct position swapping it with the number nums[nums[i]] if they are different.\\n  For example: [1,2,0] ->[1,2,0];\\n                        [3,4,-1,1] ->[1,-1,3,4];\\n                        [0,10,1,3,6,4]->[1,10,3,4,0,6].\\n You can do this in O(n), than it's easy to find the solution\\n\\n    int firstMissingPositive(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tint p = 0;\\n\\tint expected = 1;\\n\\n\\t//pseudo sort\\n\\twhile (p < n) {\\n\\t\\tint pPos;\\n\\t\\tint aux;\\n\\t\\t\\n\\t\\tif (nums[p] > 0 && nums[p] <= n) {\\n\\t\\t\\tpPos = nums[p] - 1;\\n\\t\\t\\tif (nums[pPos] != nums[p]) {\\n\\t\\t\\t\\taux = nums[p];\\n\\t\\t\\t\\tnums[p] = nums[pPos];\\n\\t\\t\\t\\tnums[pPos] = aux;\\n\\t\\t\\t\\tp--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tp++;\\n\\t}\\n\\n\\t//Finding the answer\\n\\tfor (size_t i = 0; i < n && nums[i] == expected; i++, expected++);\\n\\n\\treturn expected;\\n}",
                "solutionTags": [],
                "code": " The answer is between 1 and n, where n is the size of the vector and the trick is that you have to \"pseudo sort\", what I mean with that? Well, if the number nums[i] is between 1 and n you have to put it in the correct position swapping it with the number nums[nums[i]] if they are different.\\n  For example: [1,2,0] ->[1,2,0];\\n                        [3,4,-1,1] ->[1,-1,3,4];\\n                        [0,10,1,3,6,4]->[1,10,3,4,0,6].\\n You can do this in O(n), than it's easy to find the solution\\n\\n    int firstMissingPositive(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tint p = 0;\\n\\tint expected = 1;\\n\\n\\t//pseudo sort\\n\\twhile (p < n) {\\n\\t\\tint pPos;\\n\\t\\tint aux;\\n\\t\\t\\n\\t\\tif (nums[p] > 0 && nums[p] <= n) {\\n\\t\\t\\tpPos = nums[p] - 1;\\n\\t\\t\\tif (nums[pPos] != nums[p]) {\\n\\t\\t\\t\\taux = nums[p];\\n\\t\\t\\t\\tnums[p] = nums[pPos];\\n\\t\\t\\t\\tnums[pPos] = aux;\\n\\t\\t\\t\\tp--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tp++;\\n\\t}\\n\\n\\t//Finding the answer\\n\\tfor (size_t i = 0; i < n && nums[i] == expected; i++, expected++);\\n\\n\\treturn expected;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 17313,
                "title": "a-hashmap-based-solution-but-in-place",
                "content": "A[] is an array, but we can also treat it as an hashmap,\\nIf A[i] > 0, it mean i+1 exist,\\nIf A[i] < 0,  it mean i + 1 does not.\\nHere is the code\\n\\n    class Solution {\\n    public:\\n        int firstMissingPositive(int A[], int n) {\\n            /* first iteration: change all the value out of bound to (n + 1) */\\n        \\tconst int out_of_bound = n + 1;\\n        \\tfor (int i = 0; i < n; ++i)\\n        \\t\\tif (A[i] <= 0)\\n        \\t\\t\\tA[i] = out_of_bound;\\n    \\n    \\t\\t/* second iteration: construct a hash map. map<int, int>, first argument is index\\n    \\t\\t * second argument: if positive, it exist, else, it doesn't. e.g. A[0] = 4,\\n    \\t\\t * A[0] (i.e. 1) exist */\\n    \\t \\tfor (int i = 0; i < n; ++i) {\\n    \\t \\t\\tint abs_i = abs(A[i]);\\n    \\t \\t\\tif (abs_i <= n)\\n    \\t \\t\\t\\tA[abs_i-1] = -abs(A[abs_i-1]);\\n    \\t \\t}\\n    \\n    \\t \\t/* third iteration: check the first positive value in A[] */\\n    \\t \\tfor (int i = 0; i < n; ++i) {\\n    \\t \\t\\tif (A[i] > 0)\\n    \\t \\t\\t\\treturn i + 1; \\n    \\t \\t}\\n    \\t \\treturn n + 1;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int firstMissingPositive(int A[], int n) {\\n            /* first iteration: change all the value out of bound to (n + 1) */\\n        \\tconst int out_of_bound = n + 1;\\n        \\tfor (int i = 0; i < n; ++i)\\n        \\t\\tif (A[i] <= 0)\\n        \\t\\t\\tA[i] = out_of_bound;\\n    \\n    \\t\\t/* second iteration: construct a hash map. map<int, int>, first argument is index\\n    \\t\\t * second argument: if positive, it exist, else, it doesn't. e.g. A[0] = 4,\\n    \\t\\t * A[0] (i.e. 1) exist */\\n    \\t \\tfor (int i = 0; i < n; ++i) {\\n    \\t \\t\\tint abs_i = abs(A[i]);\\n    \\t \\t\\tif (abs_i <= n)\\n    \\t \\t\\t\\tA[abs_i-1] = -abs(A[abs_i-1]);\\n    \\t \\t}",
                "codeTag": "Java"
            },
            {
                "id": 17319,
                "title": "python-solution-with-bit-manipulation",
                "content": "One pass of the list, but still O(2n)\\n\\n    def firstMissingPositive(self, A):\\n        num = 0\\n        for i in A:\\n            if i > 0:\\n                num = num | (1 << i)\\n        x = 1\\n        while True:\\n            if (1 << x) & num == 0:\\n                return x\\n            x += 1\\n\\nUpdate: not sure why the down votes, Python int converts to long(which has no precision limits) automatically, which means no overflow for `num`.",
                "solutionTags": [
                    "Python"
                ],
                "code": "One pass of the list, but still O(2n)\\n\\n    def firstMissingPositive(self, A):\\n        num = 0\\n        for i in A:\\n            if i > 0:\\n                num = num | (1 << i)\\n        x = 1\\n        while True:\\n            if (1 << x) & num == 0:\\n                return x\\n            x += 1\\n\\nUpdate: not sure why the down votes, Python int converts to long(which has no precision limits) automatically, which means no overflow for `num`.",
                "codeTag": "Python3"
            },
            {
                "id": 17140,
                "title": "c-and-python-modify-the-array-to-do-it-in-o-n-time-and-o-1-space",
                "content": "If there are queries after each insert operation, [disjoint-set][1] is able to answer each query in `O(log(alpha(n)))` time and `O(max(element in the array))` space,  but for this problem, only one query after all the insertion finished,  the time complexity should be `O(n)` and `O(1)` space, some simple method is in need.\\n\\nEven though it is not a good idea to modify the value of the origin array, this is the only space that is available, which means it must be made used of.  Then if it is possible to sort the element which is between `1...n`, then just loop over the sorted array, the job is done.\\n\\nComparison  sort is `O(n logn)`, it is too slow. So the `bucket sort` is the only way. As only the elements between 1...n are useful, each element `w` should be put into the `w th` position of the array. As it is possible there is some other element `v` in the `w th` position, take the `v` out before overwriting and then iteratively use the same logic on `v` and go on.\\n\\n    def firstMissingPositive(self, A):\\n      n = len(A)\\n      for index in xrange(n):\\n        element = A[index]\\n        while True:\\n          if element <= 0 or element > n or element == A[element - 1]:\\n            break\\n          A[element - 1], element = element, A[element - 1]\\n      for index in xrange(n):\\n        if A[index] != index + 1:\\n          return index + 1\\n      return n + 1\\n\\nTime complexity:  each element is looped 2 times and swapped 1 time, so the whole time compexity is `O(n)`\\n\\nSpace: `O(1)` apparently\\n\\n---\\n\\nA pure recursive `C` solution, which has the same time and space complexity.\\n\\n    void rotate(int A[], int n, int start){\\n      if(start <= 0 || start > n){\\n        return;\\n      }\\n      if(A[start - 1] == start){\\n        return;\\n      }\\n      int nxt = A[start - 1];\\n      A[start - 1] = start;\\n      rotate(A, n, nxt);\\n    }\\n    \\n    int firstMissingPositive(int A[], int n) {\\n      int i;\\n      for(i = 0; i < n; ++i){\\n        rotate(A, n, A[i]);\\n      }\\n      for(i = 0; i < n; ++i){\\n        if(A[i] != i + 1){\\n          return i + 1;\\n        }\\n      }\\n      return n + 1;\\n    }\\n\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Disjoint-set_data_structure",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "If there are queries after each insert operation, [disjoint-set][1] is able to answer each query in `O(log(alpha(n)))` time and `O(max(element in the array))` space,  but for this problem, only one query after all the insertion finished,  the time complexity should be `O(n)` and `O(1)` space, some simple method is in need.\\n\\nEven though it is not a good idea to modify the value of the origin array, this is the only space that is available, which means it must be made used of.  Then if it is possible to sort the element which is between `1...n`, then just loop over the sorted array, the job is done.\\n\\nComparison  sort is `O(n logn)`, it is too slow. So the `bucket sort` is the only way. As only the elements between 1...n are useful, each element `w` should be put into the `w th` position of the array. As it is possible there is some other element `v` in the `w th` position, take the `v` out before overwriting and then iteratively use the same logic on `v` and go on.\\n\\n    def firstMissingPositive(self, A):\\n      n = len(A)\\n      for index in xrange(n):\\n        element = A[index]\\n        while True:\\n          if element <= 0 or element > n or element == A[element - 1]:\\n            break\\n          A[element - 1], element = element, A[element - 1]\\n      for index in xrange(n):\\n        if A[index] != index + 1:\\n          return index + 1\\n      return n + 1\\n\\nTime complexity:  each element is looped 2 times and swapped 1 time, so the whole time compexity is `O(n)`\\n\\nSpace: `O(1)` apparently\\n\\n---\\n\\nA pure recursive `C` solution, which has the same time and space complexity.\\n\\n    void rotate(int A[], int n, int start){\\n      if(start <= 0 || start > n){\\n        return;\\n      }\\n      if(A[start - 1] == start){\\n        return;\\n      }\\n      int nxt = A[start - 1];\\n      A[start - 1] = start;\\n      rotate(A, n, nxt);\\n    }\\n    \\n    int firstMissingPositive(int A[], int n) {\\n      int i;\\n      for(i = 0; i < n; ++i){\\n        rotate(A, n, A[i]);\\n      }\\n      for(i = 0; i < n; ++i){\\n        if(A[i] != i + 1){\\n          return i + 1;\\n        }\\n      }\\n      return n + 1;\\n    }\\n\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Disjoint-set_data_structure",
                "codeTag": "Python3"
            },
            {
                "id": 2931346,
                "title": "simple-optimized-solution-in-o-1-space",
                "content": "# Approach\\nSteps:\\n1.remove all the elements having zero or negative value.\\n2.sort the new array and remove all the duplicates.\\n3.now, array has all the element are unique +ve & in increasing order.\\n4.run the loop & check the condition v[i]==i+1,if this fails,answer is i+1,return it.otherwise answer will be v.size()+1.\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& v) {\\n        //erase all the elements having negative and zero value.\\n       for(int i=0;i<v.size();i++){\\n           if(v[i]<=0){\\n               v.erase(v.begin()+i);\\n               i--;\\n           }\\n       }\\n       sort(v.begin(),v.end()); //sort the array.\\n       //Now,remove all duplicates.This approach works in O(n) time\\n       for(int i=0;i<v.size();i++){\\n            int com=v[i];\\n            int freq=0;\\n            while(i<v.size() && v[i]==com){\\n                freq++;\\n                if(freq>1){\\n                 v.erase(v.begin()+i);\\n                 i--;\\n                }\\n                i++;\\n            }\\n            i--;\\n        }\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]!=i+1){\\n                return i+1;\\n            }\\n        }\\n        int ans=v.size()+1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Interactive"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& v) {\\n        //erase all the elements having negative and zero value.\\n       for(int i=0;i<v.size();i++){\\n           if(v[i]<=0){\\n               v.erase(v.begin()+i);\\n               i--;\\n           }\\n       }\\n       sort(v.begin(),v.end()); //sort the array.\\n       //Now,remove all duplicates.This approach works in O(n) time\\n       for(int i=0;i<v.size();i++){\\n            int com=v[i];\\n            int freq=0;\\n            while(i<v.size() && v[i]==com){\\n                freq++;\\n                if(freq>1){\\n                 v.erase(v.begin()+i);\\n                 i--;\\n                }\\n                i++;\\n            }\\n            i--;\\n        }\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]!=i+1){\\n                return i+1;\\n            }\\n        }\\n        int ans=v.size()+1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924456,
                "title": "easy-c-solution",
                "content": "# Intuition\\nBrute Force Approach\\n\\n# Approach\\nStep 1: Sort the vector.\\nStep 2: Take the last element as max. Check if its negative, if it is negative, then return 1 as answer.\\nStep 3: Start a loop from 1 to max.\\nStep 4: Find the element in the vector using binary search and if not found return it.\\nStep 5: Repeat the process till we reach the end of vector.\\nStep 6: If we reach the end that means anything isn\\'t returned so now return max+1 (according to problem statement & examples).\\n\\n# Complexity\\n- Time complexity:\\nO(n logn)\\n\\n- Space complexity:\\nO(log n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int m = nums[nums.size()-1];\\n        if(m <= 0){\\n            return 1;\\n        }\\n        int s, e, mid;\\n        bool found;\\n        for(int key = 1; key < m; key++){\\n            s = 0, e = nums.size()-1;\\n            found = 0;\\n            while(s <= e){\\n                mid = s + (e - s)/2;\\n                if(nums[mid] == key){\\n                    found = 1;\\n                    break;\\n                }\\n                else if(nums[mid] > key){\\n                    e = mid-1;\\n                }\\n                else{\\n                    s = mid+1;\\n                }\\n            }\\n            if(!found){\\n                return key;\\n            }\\n        }\\n        return m+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Divide and Conquer",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int m = nums[nums.size()-1];\\n        if(m <= 0){\\n            return 1;\\n        }\\n        int s, e, mid;\\n        bool found;\\n        for(int key = 1; key < m; key++){\\n            s = 0, e = nums.size()-1;\\n            found = 0;\\n            while(s <= e){\\n                mid = s + (e - s)/2;\\n                if(nums[mid] == key){\\n                    found = 1;\\n                    break;\\n                }\\n                else if(nums[mid] > key){\\n                    e = mid-1;\\n                }\\n                else{\\n                    s = mid+1;\\n                }\\n            }\\n            if(!found){\\n                return key;\\n            }\\n        }\\n        return m+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2670716,
                "title": "easiest-way-to-solve",
                "content": "class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        arr = set(nums)\\n        data=(i for i in range(1,len(arr)+2) if i not in arr)\\n        return min(data)\\n\\t**upvote if u found it useful**",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        arr = set(nums)\\n        data=(i for i in range(1,len(arr)+2) if i not in arr)\\n        return min(data)\\n\\t**upvote if u found it useful**",
                "codeTag": "Java"
            },
            {
                "id": 2576238,
                "title": "python-easy-solution",
                "content": "```\\ndef firstMissingPositive(self, nums: List[int]) -> int:\\n        nums = sorted(list(set(nums)))\\n        i = 1\\n        for num in nums:\\n            if num == i:\\n                i += 1\\n            elif num > 0:\\n                return i\\n        return i\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef firstMissingPositive(self, nums: List[int]) -> int:\\n        nums = sorted(list(set(nums)))\\n        i = 1\\n        for num in nums:\\n            if num == i:\\n                i += 1\\n            elif num > 0:\\n                return i\\n        return i\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2083669,
                "title": "simple-hashmap-solution-o-n",
                "content": "Simple Solution using HashMap.\\n\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            map.put(nums[i], nums[i]);\\n        }\\n        int i;\\n        for (i = 1; i <= nums.length; i++) {\\n            if (!map.containsKey(i)) {\\n                return i;\\n            }\\n        }\\n        return i;\\n    }\\n}```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            map.put(nums[i], nums[i]);\\n        }\\n        int i;\\n        for (i = 1; i <= nums.length; i++) {\\n            if (!map.containsKey(i)) {\\n                return i;\\n            }\\n        }\\n        return i;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1866566,
                "title": "c-easy-and-understandable-approach-with-linear-time-and-constant-space",
                "content": "```\\nint firstMissingPositive(vector<int>& nums) {\\n        //case 1 : manage 1 and those who are out of bound;\\n        bool One = false;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == 1) One = true;\\n            if(nums[i]>nums.size() or nums[i]<1){\\n                nums[i] = 1;\\n            }\\n        }\\n        if(One == false) return 1;\\n        \\n        //case 2 : map element with index\\n        for(int i=0;i<nums.size();i++){\\n            int idx = abs(nums[i]);\\n            nums[idx - 1] = -abs(nums[idx - 1]);\\n        }\\n        \\n        //case 3 : find positive number\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] > 0) return i+1;\\n        }\\n        return nums.size()+1;\\n    }\\n```\\n**Guys if you got the concept then please give one upvote for me.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint firstMissingPositive(vector<int>& nums) {\\n        //case 1 : manage 1 and those who are out of bound;\\n        bool One = false;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == 1) One = true;\\n            if(nums[i]>nums.size() or nums[i]<1){\\n                nums[i] = 1;\\n            }\\n        }\\n        if(One == false) return 1;\\n        \\n        //case 2 : map element with index\\n        for(int i=0;i<nums.size();i++){\\n            int idx = abs(nums[i]);\\n            nums[idx - 1] = -abs(nums[idx - 1]);\\n        }\\n        \\n        //case 3 : find positive number\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] > 0) return i+1;\\n        }\\n        return nums.size()+1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1008481,
                "title": "java-100-fast-simple-and-easy",
                "content": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        for(int i = 0; i < nums.length;) {\\n            int curr = nums[i];\\n            //in place sorting 1 based index ignoring out of range numbers including 0\\n\\t\\t\\tif(curr > 0 && curr < nums.length && curr != nums[curr-1]) \\n                swap(nums, i, curr-1);\\n            else\\n                i++;\\n        }\\n        //check if the number on index i is equal to i + 1 (1 based idxs) if not we have our number\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] != i + 1) {\\n                return i + 1;\\n            }\\n        }\\n\\t\\t//if the whole array have the correct numbers the next number is the last pos (nums.length) + 1\\n        return nums.length + 1;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        for(int i = 0; i < nums.length;) {\\n            int curr = nums[i];\\n            //in place sorting 1 based index ignoring out of range numbers including 0\\n\\t\\t\\tif(curr > 0 && curr < nums.length && curr != nums[curr-1]) \\n                swap(nums, i, curr-1);\\n            else\\n                i++;\\n        }\\n        //check if the number on index i is equal to i + 1 (1 based idxs) if not we have our number\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] != i + 1) {\\n                return i + 1;\\n            }\\n        }\\n\\t\\t//if the whole array have the correct numbers the next number is the last pos (nums.length) + 1\\n        return nums.length + 1;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 360518,
                "title": "my-cpp-solution-o-n-time-o-1-space-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int len = nums.size();\\n        int i = 0;\\n        int j = len-1;\\n        while(i<=j){\\n            if(nums[i]==i+1){\\n                ++i;\\n                continue;\\n            }\\n            // nums[i] looks for pos nums[i]-1\\n            else if(nums[i]>0 && nums[i]-1<=j && nums[nums[i]-1]!=nums[i]){\\n                swap(nums[nums[i]-1],nums[i]);\\n            }\\n\\t\\t\\t// put it at end of array as a \"junk\"\\n            else{\\n                swap(nums[j--],nums[i]);\\n            }\\n        }\\n        if(i==0){\\n            return 1;\\n        }\\n        else{\\n            return nums[i-1]+1;\\n        }\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/jellyzhang/image_1566046353.png)\\nFirst of all ,we know that , if nums looks like [1,2,3,4...] ,then num[i] should be at **pos** nums[i]-1.\\nnow we have 6 at pos i , which should be at pos 5.\\nHere is what we gonna do:\\n\\twe check if his **pos-to-put** is avavilable.\\n\\tsince pos 5 is an available pos , we swap them.\\n![image](https://assets.leetcode.com/users/jellyzhang/image_1566046685.png)\\nnow we have -1 at pos i ,which should be at pos -2.\\nof course pos -2 is not available.\\nso we put it at **junk area** by swapping with pos j. (then j--);\\n![image](https://assets.leetcode.com/users/jellyzhang/image_1566046869.png)\\nthen we facing 20 now...\\nif we cant find a 5 for pos i ,then it will keep looping ,until j hits i.So TIme complexity is O(n).\\n(also ,if **pos-to-put** is already has his number, then nums[i] is regard as junk too,cause we dont need a number twice.)\\nand we dont have to go over the nums again to find the first missing spot. cause where i hit j is what we need.\\n\\nsorry for my bad painting.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int len = nums.size();\\n        int i = 0;\\n        int j = len-1;\\n        while(i<=j){\\n            if(nums[i]==i+1){\\n                ++i;\\n                continue;\\n            }\\n            // nums[i] looks for pos nums[i]-1\\n            else if(nums[i]>0 && nums[i]-1<=j && nums[nums[i]-1]!=nums[i]){\\n                swap(nums[nums[i]-1],nums[i]);\\n            }\\n\\t\\t\\t// put it at end of array as a \"junk\"\\n            else{\\n                swap(nums[j--],nums[i]);\\n            }\\n        }\\n        if(i==0){\\n            return 1;\\n        }\\n        else{\\n            return nums[i-1]+1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 202584,
                "title": "javascript-52ms-beats-100-supposedly",
                "content": "Solving this in O(n) time was tricky, but solving it in O(1) space was arguably more difficult.\\n\\n**Constraints:**\\n1. Can\\'t use an object to store values because that would no longer be constant extra space (as the size of the object would be dependent on the number of values in the array).\\n2.   For the same reason, we can\\'t iniitalize another array.\\n\\n**Possible Scenarios:**\\n1: Array has negative and/or positive values but does not contain the integer 1.  In that case, result would be 1.\\n2: Array contains the integer 1 and has one or more missing integers within the array.  In that case, we need to be able to tell where that gap is.\\n3: Array contains only positive integers and contains 1 through the length of the array.  In that case, result would be array length + 1.\\n\\n**Observations:**\\n1. If there are no gaps, the largest value for an integer in the array is the length of the array.\\n2. That means that we don\\'t care about any values that are greater than the length of the array (because they wouldn\\'t affect the calculation of what the smallest integer missing would be as their inclusion would ensure a gap elsewhere)\\n3. If the lowest value we care about is 1 and the largest value we care about is the length of the array, we can iterate through the array and swap the value at the current index to the index of the value - 1 in order to track whether or not a given value exists in the array.  That is, given an array [3, 2, 1], swapping 3 with 1, not incrementing the iterator so that you are still looking at the array at index 0, seeing that 1 is in place, incrementing the index, seeing that 2 is in place, incrementing the index, and seeing that 3 is in place.  We would then loop through the array a second time in order to find the lowest value that isn\\'t at the index of its value - 1.\\n\\n**Big O Analysis:**\\nThis function goes through the array, swapping the value at the current index with the value at the index of one less than the value.  If the value is less than 0 or greater than the length of the array, the value at that index gets set to 0 to make it easier on the eyes during debugging of edge cases.\\n\\nWhile it\\'s employing a for loop and a while loop in the first pass, it\\'s not nested in the sense that two counters are going as it\\'s utilizing the same counter for both, so I believe that portion is still O(n), and tacking on the for loop at the end to determine whether or not an integer is present in the array wouldn\\'t be significant enough to affect the time complexity.\\n\\nAs we\\'re utilizing the original array and just changing pointer values and not actually moving the array in any way, this should still be O(1) space complexity.\\n\\n```\\nvar firstMissingPositive = function (nums) {\\n  let current;\\n  let indexForCurrent;\\n   for (let i = 0; i < nums.length;) {\\n    if (nums[i] < 0) {\\n      nums[i] = 0;\\n      i++;\\n    } else if (nums[i] > nums.length){\\n      i++;\\n    }\\n      current = nums[i];     \\n      indexForCurrent = current - 1\\n      while (nums[i] != nums[indexForCurrent]) {\\n        if (current > 0 && current <= nums.length) {\\n          let next = nums[indexForCurrent];\\n          nums[indexForCurrent] = current;\\n          nums[i] = next;\\n          current = nums[i];\\n          indexForCurrent = current - 1;\\n        } else {\\n          nums[i] = 0;\\n          i++;\\n          current = nums[i];\\n          indexForCurrent = current - 1;           \\n      }\\n    }\\n    i++;\\n  }\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] !== i + 1) {\\n      return i + 1;\\n    }\\n  }\\n  return nums.length + 1\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar firstMissingPositive = function (nums) {\\n  let current;\\n  let indexForCurrent;\\n   for (let i = 0; i < nums.length;) {\\n    if (nums[i] < 0) {\\n      nums[i] = 0;\\n      i++;\\n    } else if (nums[i] > nums.length){\\n      i++;\\n    }\\n      current = nums[i];     \\n      indexForCurrent = current - 1\\n      while (nums[i] != nums[indexForCurrent]) {\\n        if (current > 0 && current <= nums.length) {\\n          let next = nums[indexForCurrent];\\n          nums[indexForCurrent] = current;\\n          nums[i] = next;\\n          current = nums[i];\\n          indexForCurrent = current - 1;\\n        } else {\\n          nums[i] = 0;\\n          i++;\\n          current = nums[i];\\n          indexForCurrent = current - 1;           \\n      }\\n    }\\n    i++;\\n  }\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] !== i + 1) {\\n      return i + 1;\\n    }\\n  }\\n  return nums.length + 1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17250,
                "title": "share-my-thoughts-4ms-soln",
                "content": "At beginning, I was thinking: \\n\\n 1. it requires O(n), means no sorting/binary searching. You should only go through the numbers then get the result.\\n 2. no extra memory, means you can not use bit vector to indicate if any number exists.\\n\\nSo, the first idea came into my mind is bit manipulation. But, after tried and thought it again, bit manipulation doesn't help here. Because the numbers can be duplicated. Re-visited the problem, I found one critical point: it's asking the smallest missing positive number. It means I can reorder the numbers to let the nums[0]=1, nums[1]=2... etc. Actually, I spent more than 30 minutes on bit manipulation direction. Once I found the solution, it only took about 10 minutes to code.\\n\\n    class Solution {\\n    public:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int size=nums.size();\\n        for(int i=0; i<size;){\\n            if(nums[i]>0 && nums[i]<=size && nums[i]!=nums[nums[i]-1]){\\n                swap(nums[i], nums[nums[i]-1]);\\n            }\\n            else{\\n                ++i;\\n            }\\n        }\\n        int i=0;\\n        for(; i<size && nums[i]==i+1; ++i);\\n        return i+1;\\n    }};",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int size=nums.size();\\n        for(int i=0; i<size;){\\n            if(nums[i]>0 && nums[i]<=size && nums[i]!=nums[nums[i]-1]){\\n                swap(nums[i], nums[nums[i]-1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 17339,
                "title": "as-o-n-solution-and-o-1-space-is-must-only-way-is-to-sort-array-in-o-n-time-with-optimal-space-and-time-overheads",
                "content": "It is certain that to get **O(n) time complexity** and to do in **constant space**  O(n) time complexity sorting technique need to be used, any of the following sorts counting sort, radix sort, bucket sort can be used. \\n\\nAs the input array can contain **negative integers**  counting sort may not be applied here as  we use keys as index in counting sort and it has memory overhead too, but when the input array has many **duplicates** then counting sort performs better it's good to discuss such trade offs with interviewer.\\n\\nRadix sort is a specific type of bucket sort, It starts with the top n-bit or n-digits and may sort those buckets using a radix sort until every entry is sorted. So if the elements in the input array are single digit integers in the **range [-9,9]** then essentially  radix sort and bucket sort are similar.\\n\\nBucket sort is the best sorting technique that might be used here because when the **input is uniformly** **distributed over a range**(here the elements of the input array are in range [-9,9]) bucket sort performs in O(n) time complexity and O(1) space complexity.\\n\\n**Counting sort** -- simple buckets, simple processing, memory overhead, performs well when input has many duplicates.\\n\\n**Radix sort** -- simple buckets, sophisticated processing, speed overhead (and still need additional static memory)\\n\\n**Bucket sort** -- sophisticated buckets, simple processing, requires dynamic memory, good in average compared to counting and radix sorts.\\n\\n\\n     class Solution {\\n        public:\\n            int firstMissingPositive(int A[], int n) {\\n                for (int i = 0; i < n; ++i)\\n                {\\n                    int digit = A[i];\\n                    while (digit <= n && digit > 0 && A[digit - 1] != digit)\\n                    {\\n                        swap(A[digit - 1], A[i]);\\n                        digit = A[i];\\n                    }\\n                }\\n                for (int i = 0; i < n; ++i)\\n                {\\n                    if (A[i] != i + 1)\\n                    {\\n                        return i + 1;\\n                    }\\n                }\\n                return n + 1;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            int firstMissingPositive(int A[], int n) {\\n                for (int i = 0; i < n; ++i)\\n                {\\n                    int digit = A[i];\\n                    while (digit <= n && digit > 0 && A[digit - 1] != digit)\\n                    {\\n                        swap(A[digit - 1], A[i]);\\n                        digit = A[i];\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3669832,
                "title": "easiest-c-code-highly-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& a) {\\n        unordered_map<int,int>map;\\n        int i,j,k,c=0;\\n\\n        for(auto x:a){\\n            if(x>0)\\n            map[x]++;\\n        }\\n\\n        for(i=1;i<a.size()+1;i++){\\n            if(map.find(i)==map.end())\\n            return i;\\n\\n        }\\n        return a.size()+1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& a) {\\n        unordered_map<int,int>map;\\n        int i,j,k,c=0;\\n\\n        for(auto x:a){\\n            if(x>0)\\n            map[x]++;\\n        }\\n\\n        for(i=1;i<a.size()+1;i++){\\n            if(map.find(i)==map.end())\\n            return i;\\n\\n        }\\n        return a.size()+1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379018,
                "title": "time-o-n-space-o-1-using-cycle-sort-beats-99-96",
                "content": "# Intuition\\ncorrect position for each positive element should be its index+1\\n\\n# Approach\\nRun a simple cycle sort by putting elements in there correct position(i.e. index+1).\\nthen return the first element which is not in correct postion, if all are then length+1;\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int i=0;\\n        while(i<nums.length){\\n            int correct=nums[i]-1;\\n          //check if its positive,in range and not in correct position\\n            if(nums[i]>0 && nums[i]<=nums.length && nums[i]!=nums[correct]){\\n                int temp=nums[i];\\n                nums[i]=nums[correct];\\n                nums[correct]=temp;\\n            }else{\\n                i++;\\n            }\\n        }\\n\\n        for(int index=0;index<nums.length;index++){\\n            if(nums[index]!=index+1){\\n                return index+1;\\n            }\\n        }\\n        return nums.length+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int i=0;\\n        while(i<nums.length){\\n            int correct=nums[i]-1;\\n          //check if its positive,in range and not in correct position\\n            if(nums[i]>0 && nums[i]<=nums.length && nums[i]!=nums[correct]){\\n                int temp=nums[i];\\n                nums[i]=nums[correct];\\n                nums[correct]=temp;\\n            }else{\\n                i++;\\n            }\\n        }\\n\\n        for(int index=0;index<nums.length;index++){\\n            if(nums[index]!=index+1){\\n                return index+1;\\n            }\\n        }\\n        return nums.length+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243937,
                "title": "java-1ms-easy-solution-with-explaination",
                "content": "\\n\\n# Approach\\nThe solution first moves all positive integers to the front of the array by swapping them with non-positive integers. It then marks indices that correspond to positive integers by negating the value at that index. Finally, it checks for the first positive integer that is not marked and returns its index + 1. If all positive integers are marked, it returns the length of the array + 1.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is O(n), where n is the length of the input array. \\n\\n- Space complexity:\\n The space complexity is O(1) because it modifies the input array in place. This solution is very efficient and should be able to handle very large input arrays.\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int n = nums.length;\\n        \\n        // Move all positive integers to the front of the array\\n        int j = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] > 0) {\\n                int temp = nums[i];\\n                nums[i] = nums[j];\\n                nums[j] = temp;\\n                j++;\\n            }\\n        }\\n        \\n        // Mark indices that correspond to positive integers\\n        for (int i = 0; i < j; i++) {\\n            int idx = Math.abs(nums[i]) - 1;\\n            if (idx < j && nums[idx] > 0) {\\n                nums[idx] = -nums[idx];\\n            }\\n        }\\n        \\n        // Find the first missing positive integer\\n        for (int i = 0; i < j; i++) {\\n            if (nums[i] > 0) {\\n                return i + 1;\\n            }\\n        }\\n        \\n        return j + 1;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int n = nums.length;\\n        \\n        // Move all positive integers to the front of the array\\n        int j = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] > 0) {\\n                int temp = nums[i];\\n                nums[i] = nums[j];\\n                nums[j] = temp;\\n                j++;\\n            }\\n        }\\n        \\n        // Mark indices that correspond to positive integers\\n        for (int i = 0; i < j; i++) {\\n            int idx = Math.abs(nums[i]) - 1;\\n            if (idx < j && nums[idx] > 0) {\\n                nums[idx] = -nums[idx];\\n            }\\n        }\\n        \\n        // Find the first missing positive integer\\n        for (int i = 0; i < j; i++) {\\n            if (nums[i] > 0) {\\n                return i + 1;\\n            }\\n        }\\n        \\n        return j + 1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928138,
                "title": "javascript-solution-using-map-100-ms-array-map-includes",
                "content": "**Feel free to ask Q\\'s...**\\n*#happytohelpu*\\n\\n***Do upvote if you find this solution useful. Happy Coding!***\\n\\n```\\n/**\\n * \\n * @param {*} nums \\n * @param {*} map \\n * @returns \\n */\\nconst firstMissingPositive = (nums, map = new Map()) => {\\n    for (let i = 1; i <= nums.length + 1; i++) {\\n        map.set(i, 1);\\n    }\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] > 0) map.delete(nums[i])\\n    }\\n    const [firstValue] = map.keys();\\n    return firstValue;\\n};\\n\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * \\n * @param {*} nums \\n * @param {*} map \\n * @returns \\n */\\nconst firstMissingPositive = (nums, map = new Map()) => {\\n    for (let i = 1; i <= nums.length + 1; i++) {\\n        map.set(i, 1);\\n    }\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] > 0) map.delete(nums[i])\\n    }\\n    const [firstValue] = map.keys();\\n    return firstValue;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2774190,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] <= 0 or nums[i] > n) {\\n                nums[i] = n+1;\\n            }\\n        }\\n        for(int i = 0; i < n; i++) {\\n            if(abs(nums[i]) > n) continue;\\n            int id = abs(nums[i]);\\n            nums[id-1] = -1 * abs(nums[id-1]);\\n        }\\n        int ans = n + 1;\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] > 0) {\\n                ans = i+1;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }  \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] <= 0 or nums[i] > n) {\\n                nums[i] = n+1;\\n            }\\n        }\\n        for(int i = 0; i < n; i++) {\\n            if(abs(nums[i]) > n) continue;\\n            int id = abs(nums[i]);\\n            nums[id-1] = -1 * abs(nums[id-1]);\\n        }\\n        int ans = n + 1;\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] > 0) {\\n                ans = i+1;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773300,
                "title": "0ms-java-solution",
                "content": "```\\nclass Solution {\\npublic int firstMissingPositive(int[] nums) {\\n    int n = nums.length;\\n   \\n    for (int i = 0; i < n; i++) {\\n        if (nums[i] <= 0 || nums[i] > n) {\\n            nums[i] = n + 1;\\n        }\\n    }\\n    \\n    for (int i = 0; i < n; i++) {\\n        int num = Math.abs(nums[i]);\\n        if (num > n) {\\n            continue;\\n        }\\n        num--; \\n        if (nums[num] > 0) { \\n            nums[num] = -1 * nums[num];\\n        }\\n    }\\n    for (int i = 0; i < n; i++) {\\n        if (nums[i] >= 0) {\\n            return i + 1;\\n        }\\n    }\\n    \\n    return n + 1;\\n}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic int firstMissingPositive(int[] nums) {\\n    int n = nums.length;\\n   \\n    for (int i = 0; i < n; i++) {\\n        if (nums[i] <= 0 || nums[i] > n) {\\n            nums[i] = n + 1;\\n        }\\n    }\\n    \\n    for (int i = 0; i < n; i++) {\\n        int num = Math.abs(nums[i]);\\n        if (num > n) {\\n            continue;\\n        }\\n        num--; \\n        if (nums[num] > 0) { \\n            nums[num] = -1 * nums[num];\\n        }\\n    }\\n    for (int i = 0; i < n; i++) {\\n        if (nums[i] >= 0) {\\n            return i + 1;\\n        }\\n    }\\n    \\n    return n + 1;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2316294,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans = 1;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]<1)\\n                continue;\\n            else{\\n                if(nums[i]==ans)\\n                    ans++;\\n                else if(nums[i]>ans)\\n                    return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans = 1;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]<1)\\n                continue;\\n            else{\\n                if(nums[i]==ans)\\n                    ans++;\\n                else if(nums[i]>ans)\\n                    return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1302936,
                "title": "cpp-two-different-approaches-with-o-1-space-fully-explained",
                "content": "Hello World ! \\nFirst Approach I used is pretty simple and it\\'s time complexity is O(n)\\n\\n**Steps**\\n1. Traverse the input array and replace all zeroes and negative number by INT_MAX\\n2. Traverse the input array again, and during this traversal we will find the correct position of each element by making value at that index negative.\\n3. During final traversal, return the  (index+1) where \"index\" is the first index at which element found is positive.\\n\\n```\\n\\tint n=v.size();\\n    int ans=0;\\n\\t\\n\\t// step 1 - Replacing zeroes and negative numbers with INT_MAX\\n    for(int i=0;i<n;i++)\\n    if(v[i]<1) v[i]=INT_MAX;\\n\\t\\n\\t// step 2 - Finding correct position of each element.\\n    for(int i=0;i<n;i++)\\n        if(abs(v[i])<=n)\\n        v[abs(v[i])-1] = min(v[abs(v[i])-1],-v[abs(v[i])-1]);\\n    \\n    // step 3 - Returning (index+1) , where \"index\" is the first index at which element found is positive\\n\\tfor(;ans<n;ans++)\\n        if(v[ans]>0) return ans+1;\\n    return ans+1;\\n```\\n\\n**Second Approach**\\n\\nAlthough the above approach was working very good in terms of space and time. But i still went on to look for some other way of solving it, the way through which no one has ever done this yet.\\nThen, the idea of **heap**  crossed my mind.\\n Overall Time complexity i guess would be approx - O(n*logn)\\n\\n1. By using heapify, i convert the same array into min heap.\\n2. Initialised ```ans=1```   \\n3. Now compare with the root of min heap (root of min heap is arr[0])\\n\\t* If the root of min heap (i.e arr[0]) is equal to ans, then ans is incremented.\\n\\t* If the root of min heap is greater than ans, the ans is returned.\\n\\nSee the code and its comments for better understanding.\\n\\n**Iterative Min Heapify Function**\\n```\\nvoid minheapify(vector<int>&a,int i,int n){\\n    while(i<=n){\\n    int l= 2*i+1;\\n    int r=2*i+2;\\n    int largest =i;\\n    if(l<n  && a[l]<a[largest])\\n    largest=l;\\n    if(r<n && a[r]<a[largest])\\n    largest=r;\\n     if(largest!=i){\\n        swap(a[i],a[largest]);\\n        i=largest;\\n    }\\n    else break;\\n    }\\n}\\n```\\n\\n**Driver Code**\\n```\\nint n=v.size();\\n       \\n        int ans=1;\\n\\t\\t\\n\\t\\t//Heapify the input array\\n        for(int i = (n/2)-1;i>-1;i--)\\n            minheapify(v,i,n); \\n  \\n    while(n>0){\\n\\t// Comparing root with the ans\\n        if(ans==v[0]) ans++;\\n        else if(ans<v[0]) break;\\n        v[0]=v[n-1];\\n        n--;\\n        minheapify(v,0,n);\\n    }\\n\\t\\n\\treturn ans;   // Final answer returned\\n```\\n\\nI know the first approach was way better. But you know, one should try to solve the question with other approaches too. \\n\\nOpen for suggestions, edits and improvements.\\nPlease **Upvote** if you like.\\nThanks,\\n**Aadi**\\n",
                "solutionTags": [],
                "code": "```\\n\\tint n=v.size();\\n    int ans=0;\\n\\t\\n\\t// step 1 - Replacing zeroes and negative numbers with INT_MAX\\n    for(int i=0;i<n;i++)\\n    if(v[i]<1) v[i]=INT_MAX;\\n\\t\\n\\t// step 2 - Finding correct position of each element.\\n    for(int i=0;i<n;i++)\\n        if(abs(v[i])<=n)\\n        v[abs(v[i])-1] = min(v[abs(v[i])-1],-v[abs(v[i])-1]);\\n    \\n    // step 3 - Returning (index+1) , where \"index\" is the first index at which element found is positive\\n\\tfor(;ans<n;ans++)\\n        if(v[ans]>0) return ans+1;\\n    return ans+1;\\n```\n```ans=1```\n```\\nvoid minheapify(vector<int>&a,int i,int n){\\n    while(i<=n){\\n    int l= 2*i+1;\\n    int r=2*i+2;\\n    int largest =i;\\n    if(l<n  && a[l]<a[largest])\\n    largest=l;\\n    if(r<n && a[r]<a[largest])\\n    largest=r;\\n     if(largest!=i){\\n        swap(a[i],a[largest]);\\n        i=largest;\\n    }\\n    else break;\\n    }\\n}\\n```\n```\\nint n=v.size();\\n       \\n        int ans=1;\\n\\t\\t\\n\\t\\t//Heapify the input array\\n        for(int i = (n/2)-1;i>-1;i--)\\n            minheapify(v,i,n); \\n  \\n    while(n>0){\\n\\t// Comparing root with the ans\\n        if(ans==v[0]) ans++;\\n        else if(ans<v[0]) break;\\n        v[0]=v[n-1];\\n        n--;\\n        minheapify(v,0,n);\\n    }\\n\\t\\n\\treturn ans;   // Final answer returned\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1234110,
                "title": "c-o-n-time-and-o-1-space",
                "content": "The logic used is put each number in its right place. Example when we find 4, it is swapped with A[3]. At last, the first place where the number is not right, return (place + 1) as that would be the missing value.\\n\\n```\\n int firstMissingPositive(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        int i = 0;\\n        \\n        while (i < n)\\n        {\\n            if (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i])\\n                swap(nums[i], nums[nums[i] - 1]);\\n            else\\n                i++;\\n        }\\n        \\n        for (i = 0; i < n; i++)\\n            if (nums[i] != (i + 1))\\n                return i + 1;\\n        \\n        return n + 1;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n int firstMissingPositive(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        int i = 0;\\n        \\n        while (i < n)\\n        {\\n            if (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i])\\n                swap(nums[i], nums[nums[i] - 1]);\\n            else\\n                i++;\\n        }\\n        \\n        for (i = 0; i < n; i++)\\n            if (nums[i] != (i + 1))\\n                return i + 1;\\n        \\n        return n + 1;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1059738,
                "title": "100-faster-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& arr) {\\n        int n=arr.size();\\n        unordered_set<long long int>s;\\n        for(int i=0;i<n;i++){\\n            if(arr[i]>0){\\n            s.insert(arr[i]);\\n                }\\n        }\\n  \\n        int i=1;\\n         while(1){\\n             if(s.find(i)==s.end()){\\n                 return i;\\n             }\\n             i++;\\n         }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& arr) {\\n        int n=arr.size();\\n        unordered_set<long long int>s;\\n        for(int i=0;i<n;i++){\\n            if(arr[i]>0){\\n            s.insert(arr[i]);\\n                }\\n        }\\n  \\n        int i=1;\\n         while(1){\\n             if(s.find(i)==s.end()){\\n                 return i;\\n             }\\n             i++;\\n         }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 980736,
                "title": "c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for (int i =0; i<n; i++)\\n        {\\n            while (nums[i]>= 1 && nums[i]<=n && nums[i] != nums[nums[i] - 1])\\n                swap(nums[i] , nums[nums[i] - 1]);          \\n        }\\n        for (int i =0; i<n; i++)\\n        {\\n            if (nums[i] != i +1)\\n                return i+1;\\n        }\\n        return n +1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for (int i =0; i<n; i++)\\n        {\\n            while (nums[i]>= 1 && nums[i]<=n && nums[i] != nums[nums[i] - 1])\\n                swap(nums[i] , nums[nums[i] - 1]);          \\n        }\\n        for (int i =0; i<n; i++)\\n        {\\n            if (nums[i] != i +1)\\n                return i+1;\\n        }\\n        return n +1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872320,
                "title": "c-c-super-simple-short-solution-o-n-o-1-0-ms-faster-than-100",
                "content": "**C:**\\n```\\nint firstMissingPositive(int* nums, int numsSize){\\n    int i=0;\\n    while (i < numsSize) {\\n        if ((nums[i] <= 0) || (nums[i] > numsSize) || (nums[i]-1 == i) || (nums[i] == nums[nums[i]-1]))\\n            i++;\\n        else {\\n            \\n            int temp = nums[i];\\n            nums[i] = nums[nums[i] - 1];\\n            nums[temp - 1] = temp;\\n        }\\n    }\\n    for (int i=0; i<numsSize; i++)\\n        if (nums[i]-1 != i)\\n            return i+1;\\n    return numsSize+1;\\n}\\n```\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int numsSize = nums.size();\\n        int i=0;\\n        while (i < numsSize) {\\n            if ((nums[i] <= 0) || (nums[i] > numsSize) || (nums[i]-1 == i) || (nums[i] == nums[nums[i]-1]))\\n                i++;\\n            else {\\n                int temp = nums[i];\\n                nums[i] = nums[nums[i] - 1];\\n                nums[temp - 1] = temp;\\n            }\\n        }\\n        for (int i=0; i<numsSize; i++)\\n            if (nums[i]-1 != i)\\n                return i+1;\\n        return numsSize+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint firstMissingPositive(int* nums, int numsSize){\\n    int i=0;\\n    while (i < numsSize) {\\n        if ((nums[i] <= 0) || (nums[i] > numsSize) || (nums[i]-1 == i) || (nums[i] == nums[nums[i]-1]))\\n            i++;\\n        else {\\n            \\n            int temp = nums[i];\\n            nums[i] = nums[nums[i] - 1];\\n            nums[temp - 1] = temp;\\n        }\\n    }\\n    for (int i=0; i<numsSize; i++)\\n        if (nums[i]-1 != i)\\n            return i+1;\\n    return numsSize+1;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int numsSize = nums.size();\\n        int i=0;\\n        while (i < numsSize) {\\n            if ((nums[i] <= 0) || (nums[i] > numsSize) || (nums[i]-1 == i) || (nums[i] == nums[nums[i]-1]))\\n                i++;\\n            else {\\n                int temp = nums[i];\\n                nums[i] = nums[nums[i] - 1];\\n                nums[temp - 1] = temp;\\n            }\\n        }\\n        for (int i=0; i<numsSize; i++)\\n            if (nums[i]-1 != i)\\n                return i+1;\\n        return numsSize+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 871621,
                "title": "first-missing-positive-solution-java-beat-100",
                "content": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        if (nums == null || nums.length == 0) return 1;\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (nums[i] < 1 || nums[i] > nums.length || nums[i] == nums[nums[i] -1]) continue;\\n            // swap the element\\n            int temp = nums[nums[i] -1];\\n            nums[nums[i] -1] = nums[i]; \\n            nums[i] = temp;\\n            i--;\\n        }\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (nums[i] != i+1) return i+1;\\n        }\\n        return nums.length + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        if (nums == null || nums.length == 0) return 1;\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (nums[i] < 1 || nums[i] > nums.length || nums[i] == nums[nums[i] -1]) continue;\\n            // swap the element\\n            int temp = nums[nums[i] -1];\\n            nums[nums[i] -1] = nums[i]; \\n            nums[i] = temp;\\n            i--;\\n        }\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (nums[i] != i+1) return i+1;\\n        }\\n        return nums.length + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735695,
                "title": "java-time-o-n-constant-space-swap-approach",
                "content": "```\\n/* The goal is to bring the positive element to its place(index=value-1) by swapping...\\neg. [-1,3,1,4,5]....\\nafter swapping the array will look like [1,-1,3,4,5]  \\nAfter swapping we have to find the value which is not in its expected position which is 2 in this case.\\n*/\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        if(nums.length==0) return 1;\\n        for(int i=0;i<nums.length;){\\n            if(nums[i]>nums.length || nums[i]<=0){           //only positive values\\n                i++;\\n              continue;    \\n            }else if(nums[nums[i]-1]==nums[i]){    //checking whether the element is at its position or not\\n                i++;\\n            } \\n\\t\\t// swapping the element to its desired position\\t\\n            else{\\n                \\n            int temp=nums[nums[i]-1];\\n            nums[nums[i]-1]=nums[i];\\n            nums[i]=temp;\\n            }\\n                         }\\n        // finding the smallest positive element out of its position\\n        int i=0;\\n        for(i=0;i<nums.length;i++){\\n            if(nums[i]!=i+1) return i+1;\\n        }\\n        \\n        return nums[i-1]+1;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/* The goal is to bring the positive element to its place(index=value-1) by swapping...\\neg. [-1,3,1,4,5]....\\nafter swapping the array will look like [1,-1,3,4,5]  \\nAfter swapping we have to find the value which is not in its expected position which is 2 in this case.\\n*/\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        if(nums.length==0) return 1;\\n        for(int i=0;i<nums.length;){\\n            if(nums[i]>nums.length || nums[i]<=0){           //only positive values\\n                i++;\\n              continue;    \\n            }else if(nums[nums[i]-1]==nums[i]){    //checking whether the element is at its position or not\\n                i++;\\n            } \\n\\t\\t// swapping the element to its desired position\\t\\n            else{\\n                \\n            int temp=nums[nums[i]-1];\\n            nums[nums[i]-1]=nums[i];\\n            nums[i]=temp;\\n            }\\n                         }\\n        // finding the smallest positive element out of its position\\n        int i=0;\\n        for(i=0;i<nums.length;i++){\\n            if(nums[i]!=i+1) return i+1;\\n        }\\n        \\n        return nums[i-1]+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 524319,
                "title": "brute-force-solution",
                "content": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int num: nums) {\\n            set.add(num);\\n        }\\n        int first = 1;\\n        while(set.contains(first)){\\n            first++;\\n        }\\n        return first;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int num: nums) {\\n            set.add(num);\\n        }\\n        int first = 1;\\n        while(set.contains(first)){\\n            first++;\\n        }\\n        return first;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17296,
                "title": "simple-method-with-a-little-trick",
                "content": "Firstly,the answer must be among [1..n+1]. so all numbers less than 0 or greater than n could be discared.(change them to 0).\\nThen, if \"i\" appeared, we modify a[i-1] to -a[i-1]-1. In this way, we could do it with constant extra space.\\n\\n    class Solution {\\n    public:\\n        int firstMissingPositive(vector<int>& nums) {\\n            vector<int> &a=nums;\\n            int n=a.size();\\n            if(n==0) return 1;\\n            for(int i=0;i<n;i++) if(a[i]<0||a[i]>n) a[i]=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(a[i]==0 || a[i]==-1) continue;\\n                int t=(a[i]>0)?(a[i]-1):(-a[i]-2);\\n                if(a[t]>=0) a[t]=-a[t]-1;\\n            }\\n            for(int i=0;i<n;i++) if(a[i]>=0) return i+1;\\n            return n+1;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int firstMissingPositive(vector<int>& nums) {\\n            vector<int> &a=nums;\\n            int n=a.size();\\n            if(n==0) return 1;\\n            for(int i=0;i<n;i++) if(a[i]<0||a[i]>n) a[i]=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(a[i]==0 || a[i]==-1) continue;\\n                int t=(a[i]>0)?(a[i]-1):(-a[i]-2);\\n                if(a[t]>=0) a[t]=-a[t]-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4067658,
                "title": "easy-3-for-loop-c-o-1-space-based-on-pigeonhole-principle-using-cyclic-sort-with-explanation",
                "content": "1. **Clean the array:** We want to ignore numbers that are not useful for us. So, we go through our list (nums) one by one.If a number is zero or negative, or if it\\'s greater than m (our total number of elements), we consider it not useful and replace it with zero. This simplifies our task because we only care about positive integers up to m.\\n\\n* 2. **Put numbers to their place using cyclic sort i.e swap until you find the number :** (This works because of **[Pigeonhole Principle](https://en.wikipedia.org/wiki/Pigeonhole_principle)**) : The Pigeonhole Principle states that if you have more \"pigeons\" than \"pigeonholes,\" at least one pigeonhole must contain more than one pigeon. In this context:\\n* \\n* The \"pigeons\" are the positive integers from 1 to m (where m is the size of the input array nums).\\n* The \"pigeonholes\" are the indices of the array nums.\\n* The goal in this problem is to find the first missing positive integer. If there are no missing positive integers in the range from 1 to m, then all the pigeons are already in their correct pigeonholes, and no pigeonhole contains more than one pigeon.\\n* * So Now, we want to arrange the remaining positive integers in the correct order from 1 to m. We do this using a technique called cyclic sort. \\n* * We go through our list again, and for each number: If it\\'s not zero (useful) and not already in the right place (not equal to i + 1), we swap it with the number in its rightful position, which is nums[i] - 1. We repeat this until we can\\'t swap anymore.\\n\\n3. **Finding the First Missing Positive:** \\n* * Once we\\'ve sorted our list, we go through it one more time to find the first number that\\'s not in its expected position.\\n* * The first missing positive integer is equal to i + 1 (because we\\'re looking for the number that should be in the i-th position of our sorted list).\\n* * If we don\\'t find any missing positive integers in the range from 1 to m, we return m + 1, indicating that all positive integers up to m are present in the list.\\n\\n**If you liked the solution. Please Vote Up. Thank you! Happy Coding! Keep Finding the pigeons\\uD83D\\uDE02**\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) \\n    {\\n        int m = size(nums);\\n        \\n        for(int i=0;i<m;i++)if(nums[i]<=0 || nums[i]>m) nums[i]=0; //replace non needed numbers with zero\\n        \\n        \\n        for(int i=0;i<m;i++)                                     //arrange the position with cyclic sort\\n        {\\n           while(nums[i]!=0 && nums[i]!=i+1)                    //while loop runs till correct number on its place or the necessary condition fails\\n           {\\n               if (nums[i] == nums[ (nums[i] - 1) ])break;      //if both are same then no need to run loop\\n               swap(nums[i],nums[nums[i]-1]);                   //swap till they are at their required place\\n           }\\n        }\\n        \\n        \\n        for(int i=0;i<m;i++)if(nums[i]!=i+1)                    //find the missing numbers as all the needed numbers are on its place\\n            return i+1;\\n        \\n        return m+1;\\n    }\\n};\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/48d3adef-77ff-41b1-92c6-b3b9c501d46c_1695198038.9110086.png)\\n\\n",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) \\n    {\\n        int m = size(nums);\\n        \\n        for(int i=0;i<m;i++)if(nums[i]<=0 || nums[i]>m) nums[i]=0; //replace non needed numbers with zero\\n        \\n        \\n        for(int i=0;i<m;i++)                                     //arrange the position with cyclic sort\\n        {\\n           while(nums[i]!=0 && nums[i]!=i+1)                    //while loop runs till correct number on its place or the necessary condition fails\\n           {\\n               if (nums[i] == nums[ (nums[i] - 1) ])break;      //if both are same then no need to run loop\\n               swap(nums[i],nums[nums[i]-1]);                   //swap till they are at their required place\\n           }\\n        }\\n        \\n        \\n        for(int i=0;i<m;i++)if(nums[i]!=i+1)                    //find the missing numbers as all the needed numbers are on its place\\n            return i+1;\\n        \\n        return m+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668423,
                "title": "basic-approach-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        vector<int> sol(nums.size()+2,0);\\n        int ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0 && nums[i]<=nums.size())\\n                sol[nums[i]]=1;\\n        }\\n        for(int i=1;i<sol.size();i++)\\n        {\\n            if(sol[i]==0)\\n            {\\n                ans=i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        vector<int> sol(nums.size()+2,0);\\n        int ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0 && nums[i]<=nums.size())\\n                sol[nums[i]]=1;\\n        }\\n        for(int i=1;i<sol.size();i++)\\n        {\\n            if(sol[i]==0)\\n            {\\n                ans=i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591829,
                "title": "very-very-easy-java-soln-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        int b=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==b)\\n            {\\n               b++;\\n            }\\n            \\n        }\\n        return b;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        int b=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==b)\\n            {\\n               b++;\\n            }\\n            \\n        }\\n        return b;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587781,
                "title": "c-very-simple-easy-to-understand-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for(auto &i: nums){\\n            if(i>n) i = n+1;\\n            if(i<=0)i = n+1;\\n        }\\n        for(auto &i: nums){\\n            if(abs(i)-1<n && nums[abs(i)-1]>0)nums[abs(i)-1] *= -1;\\n        }\\n        int i;\\n        for(i = 0; i < n; i++){\\n            if(nums[i]>0)return i+1;\\n        }\\n        return n+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for(auto &i: nums){\\n            if(i>n) i = n+1;\\n            if(i<=0)i = n+1;\\n        }\\n        for(auto &i: nums){\\n            if(abs(i)-1<n && nums[abs(i)-1]>0)nums[abs(i)-1] *= -1;\\n        }\\n        int i;\\n        for(i = 0; i < n; i++){\\n            if(nums[i]>0)return i+1;\\n        }\\n        return n+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3388562,
                "title": "all-possible-solutions-include-hash-set-normal-sorting-and-cyclic-sort",
                "content": "The idea is that we `don\\'t care elements which less than 1 and and greater nums.count`. We try to `partly` sort the elements to build a final array like: `[1, 2, 3, ... out_of_bound_element ... ]`, which is calle `Cyclic Sorting`. Then just iterate from starting and return the fist missing number.\\n\\nOne thing to note that `nums[i] >= -2^31`, so have to compare `nums[i] with i + 1` but not `nums[i] - 1 with i` \\uD83D\\uDE02,\\n\\n# Code\\n```\\nclass Solution {\\n\\n    func firstMissingPositive(_ nums: [Int]) -> Int {\\n        return firstMissingPositiveUsingCylicSort(nums)\\n        // return firstMissingPositiveUsingNormalSort(nums)\\n        // return firstMissingPositiveUsingSet(nums)\\n    }\\n\\n    // Cylic sort\\n    // Time: O(n)\\n    // Space: O(1)\\n    func firstMissingPositiveUsingCylicSort(_ nums: [Int]) -> Int {\\n        var nums = nums\\n        var i = 0\\n        while i < nums.count {\\n            if nums[i] > 0, nums[i] <= nums.count, nums[i] != nums[nums[i] - 1] {\\n                nums.swapAt(i, nums[i] - 1)\\n            } else {\\n                i += 1\\n            }\\n        }\\n        for (i, num) in nums.enumerated() {\\n            if num != i + 1 {\\n                return i + 1\\n            }\\n        }\\n        return nums.count + 1\\n    }\\n\\n\\n    // Normal sort\\n    // Time: O(nlogn)\\n    // Space: O(1)\\n    func firstMissingPositiveUsingNormalSort(_ nums: [Int]) -> Int {\\n        var nums = nums.sorted()\\n\\n        if var minPositiveIndex = nums.firstIndex(where: { $0 > 0 }), nums[minPositiveIndex] == 1 {\\n            while minPositiveIndex + 1 < nums.count, nums[minPositiveIndex + 1] - nums[minPositiveIndex] <= 1 {\\n                minPositiveIndex += 1\\n            }\\n            return nums[minPositiveIndex] + 1\\n        } else {\\n            return 1\\n        }\\n    }\\n\\n    // Hash/Set\\n    // Time: O(n)\\n    // Space: O(n)\\n    func firstMissingPositiveUsingSet(_ nums: [Int]) -> Int {\\n        var set = Set<Int>()\\n        for num in nums {\\n            if num > 0, num <= nums.count {\\n                set.insert(num)\\n            }\\n        }\\n\\n        for i in 1...nums.count {\\n            if !set.contains(i) {\\n                return i\\n            }\\n        }\\n        return nums.count + 1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Hash Table",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n\\n    func firstMissingPositive(_ nums: [Int]) -> Int {\\n        return firstMissingPositiveUsingCylicSort(nums)\\n        // return firstMissingPositiveUsingNormalSort(nums)\\n        // return firstMissingPositiveUsingSet(nums)\\n    }\\n\\n    // Cylic sort\\n    // Time: O(n)\\n    // Space: O(1)\\n    func firstMissingPositiveUsingCylicSort(_ nums: [Int]) -> Int {\\n        var nums = nums\\n        var i = 0\\n        while i < nums.count {\\n            if nums[i] > 0, nums[i] <= nums.count, nums[i] != nums[nums[i] - 1] {\\n                nums.swapAt(i, nums[i] - 1)\\n            } else {\\n                i += 1\\n            }\\n        }\\n        for (i, num) in nums.enumerated() {\\n            if num != i + 1 {\\n                return i + 1\\n            }\\n        }\\n        return nums.count + 1\\n    }\\n\\n\\n    // Normal sort\\n    // Time: O(nlogn)\\n    // Space: O(1)\\n    func firstMissingPositiveUsingNormalSort(_ nums: [Int]) -> Int {\\n        var nums = nums.sorted()\\n\\n        if var minPositiveIndex = nums.firstIndex(where: { $0 > 0 }), nums[minPositiveIndex] == 1 {\\n            while minPositiveIndex + 1 < nums.count, nums[minPositiveIndex + 1] - nums[minPositiveIndex] <= 1 {\\n                minPositiveIndex += 1\\n            }\\n            return nums[minPositiveIndex] + 1\\n        } else {\\n            return 1\\n        }\\n    }\\n\\n    // Hash/Set\\n    // Time: O(n)\\n    // Space: O(n)\\n    func firstMissingPositiveUsingSet(_ nums: [Int]) -> Int {\\n        var set = Set<Int>()\\n        for num in nums {\\n            if num > 0, num <= nums.count {\\n                set.insert(num)\\n            }\\n        }\\n\\n        for i in 1...nums.count {\\n            if !set.contains(i) {\\n                return i\\n            }\\n        }\\n        return nums.count + 1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263341,
                "title": "short-sweet-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size(),i;\\n        for(auto &i: nums){\\n            if(i<=0||i>n){\\n                i = n+1;\\n            }\\n        }\\n        for(auto &i: nums){\\n            if(abs(i)==n+1||nums[abs(i)-1]<0)continue;\\n            nums[abs(i)-1] *= -1;\\n        }\\n        for(i = 1; i <= n; i++){\\n            if(nums[i-1]>0)return i;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size(),i;\\n        for(auto &i: nums){\\n            if(i<=0||i>n){\\n                i = n+1;\\n            }\\n        }\\n        for(auto &i: nums){\\n            if(abs(i)==n+1||nums[abs(i)-1]<0)continue;\\n            nums[abs(i)-1] *= -1;\\n        }\\n        for(i = 1; i <= n; i++){\\n            if(nums[i-1]>0)return i;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160264,
                "title": "92-accepted-easy-solution-with-explanation",
                "content": "# Intuition\\n@first you think about to put ith value at its original position in sorted array (that is at i)\\n# Approach\\n@first you think about to put ith value at its original position in sorted array (that is at i)\\n@if the position is out of bound leave it as it is and move on this is done also in case of duplicate\\n@then re-iterate whole array find first time which is not at its original position return it \\n@ if all array is perfect after swap return size of array\\n# Complexity\\n- Time complexity:\\nTime complexity is O(n)  because for each element we find it original position or leave it on their position\\n\\n- Space complexity:\\nspace complexity is O(1)\\nbecause there is only 2 to 4 approx variable is taken\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        // if(nums.)\\n        int i=0;\\n        while(i<nums.size()){\\n            if(nums[i]!=i){\\n                if(nums[i]>nums.size()-1||nums[i]<0){\\n                    i++;\\n                }else{\\n                     int j=nums[i];\\n                     int temp=nums[j];\\n                     nums[i]=temp;\\n                     nums[j]=j;\\n                     if(temp==j){\\n                         i++;\\n                     }\\n                }\\n            }else{\\n            i++;\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=i&&i){\\n                return i;\\n            }\\n        }\\n        if(nums[0]==nums.size()){\\nreturn nums.size()+1;\\n        }else{\\n\\n        return nums.size();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        // if(nums.)\\n        int i=0;\\n        while(i<nums.size()){\\n            if(nums[i]!=i){\\n                if(nums[i]>nums.size()-1||nums[i]<0){\\n                    i++;\\n                }else{\\n                     int j=nums[i];\\n                     int temp=nums[j];\\n                     nums[i]=temp;\\n                     nums[j]=j;\\n                     if(temp==j){\\n                         i++;\\n                     }\\n                }\\n            }else{\\n            i++;\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=i&&i){\\n                return i;\\n            }\\n        }\\n        if(nums[0]==nums.size()){\\nreturn nums.size()+1;\\n        }else{\\n\\n        return nums.size();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148746,
                "title": "4-line-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int traversal =1;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==traversal)\\n            {\\n                traversal++;\\n            }\\n           \\n        }\\n        return traversal;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int traversal =1;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==traversal)\\n            {\\n                traversal++;\\n            }\\n           \\n        }\\n        return traversal;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3127620,
                "title": "easy-peasy-soln-to-hard-problem",
                "content": "# Intuition \\n    Simple Math Operation and Logic\\n\\n# Approach\\n\\n- Since they\\'ve asked us to find out the smallest positive integer, then there\\'s no point of having the negative numbers in array.\\n\\n- All the negative numbers in the array is replaced by 0.\\n\\n- Check if the number one(1) is present in array or not. If not then you\\'ve got the answer :-))),  just return 1.\\n\\n- Otherwise sort the array and find out for that first element whose difference is greater than 1. If found, then store the result in a variable and break the loop. \\n\\n- If the value of the variable is same even before and after the iteration, then return (last element + 1).\\n\\n\\n# Complexity\\n- Time complexity: O(n*logn)\\n<!--  -->\\n\\n- Space complexity: O(1)\\n<!--  -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] < 0)\\n              nums[i] = 0;\\n        }\\n\\n        int ones = 0;\\n        for(auto x: nums)\\n        {\\n            if(x == 1)\\n               ones++;  \\n        }\\n\\n        if(ones == 0)\\n            return 1;\\n\\n        sort(nums.begin(), nums.end());\\n        int ele = -1;\\n\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(nums[i] - nums[i-1] > 1)\\n            {\\n                ele = nums[i-1] + 1;\\n                break;\\n            }\\n        } \\n\\n        return ele == -1 ? ++nums[n-1] : ele;     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] < 0)\\n              nums[i] = 0;\\n        }\\n\\n        int ones = 0;\\n        for(auto x: nums)\\n        {\\n            if(x == 1)\\n               ones++;  \\n        }\\n\\n        if(ones == 0)\\n            return 1;\\n\\n        sort(nums.begin(), nums.end());\\n        int ele = -1;\\n\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(nums[i] - nums[i-1] > 1)\\n            {\\n                ele = nums[i-1] + 1;\\n                break;\\n            }\\n        } \\n\\n        return ele == -1 ? ++nums[n-1] : ele;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719139,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        \\n        int first = 1;\\n        \\n        for (int num : nums) {\\n            if (num > 0) {\\n                set.add(num);\\n            }\\n            \\n            if (num == first) {\\n                first++;\\n                \\n                while (set.contains(first)) {\\n                    first++;\\n                }\\n            }\\n        }\\n        \\n        return first;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        \\n        int first = 1;\\n        \\n        for (int num : nums) {\\n            if (num > 0) {\\n                set.add(num);\\n            }\\n            \\n            if (num == first) {\\n                first++;\\n                \\n                while (set.contains(first)) {\\n                    first++;\\n                }\\n            }\\n        }\\n        \\n        return first;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2623142,
                "title": "easy-beginners-solution-explained",
                "content": "nums.sort() # sort the given array of numbers \\n        ans=1  # set 1 as ans because 1 is the smallest positive integer#\\n        for i in range(len(nums)):\\n            if nums[i] == ans: # if during the iteration current index value and ans matches then increment ans, at any point it does not match return ans #\\n                ans += 1\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "nums.sort() # sort the given array of numbers \\n        ans=1  # set 1 as ans because 1 is the smallest positive integer#\\n        for i in range(len(nums)):\\n            if nums[i] == ans: # if during the iteration current index value and ans matches then increment ans, at any point it does not match return ans #\\n                ans += 1\\n        return ans",
                "codeTag": "Unknown"
            },
            {
                "id": 2463829,
                "title": "python-4-approaches-summarized-with-o-n-o-1-solution",
                "content": "# Introduction\\nThis particular problem is much easier than it would usually be, as the problem\\u2019s description specifies the required time and space complexity, limiting the possible approaches.</br>\\nHowever, in the actual interview, you would likely be given a problem without specified constraints and solution time-space complexity. \\n* You should ask about input value constraints before proceeding to solve the problem. \\n* Optimal time-space complexity should be achieved in the solving process, starting with a brute-force solution and further seeking ways to optimize the process.</br>\\n\\n# Brute-Force solution\\nThe solution that comes to mind first consists of checking the presence in `nums` of every positive integer in ascending order, starting with *1*. The number of checks is limited by *N + 1*, because the lowest positive missing integer lies within the range *[1, \\u2026, N + 1]* for an array of length *N*, as the missing value would be *N + 1* if all values in *[1, \\u2026, n]* are present in `nums` once, and missing value would be in *[1, \\u2026, n]* otherwise.\\n## Code\\n```python\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n\\n\\t\\t# check presence of each value in [1, ..., N]\\n\\t\\t# missing value is N + 1 if every previous value is present\\n        for v in range(1, len(nums)):\\n\\n            if v not in nums:\\n                return v\\n\\n        return v + 1\\n```\\n## Complexity analysis\\nLet *N* be the length of the `nums` array, and *O(M)* be the time complexity of finding whether a certain number is present in the array.</br>\\nNote that linear search in an array takes *O(N)* time because it is conducted by iterating through the whole array until the number is found, meaning *O(M) = O(N)*\\n* Time Complexity: *O(N<sup>2</sup>)*\\nFor each number in *[1, \\u2026 N]*, we spend *O(M)* time to check whether it is present in `nums`</br>\\nIn total, we have *O(N \\\\* M) = O(N<sup>2</sup>))*</br>\\n\\n* Space Complexity: *O(1)*\\nWe use constant extra space to store a fixed number of variables to account for the currently processed number.\\n\\n# Sorting solution\\nAnother simple solution lies in sorting the array and iterating through it until we reach the last non-positive number and further checking that every positive number is present in the sorted array.\\n## Code:\\n```python\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n\\n        # sort nums\\n        nums.sort()\\n        cur = 0\\n        \\n        for idx, val in enumerate(nums):\\n            # skip the negatives\\n            if val <= 0:\\n                continue\\n\\n            # check that next value in sorted nums contains\\n            # number that immeadiately follows it or is equal to it\\n            # set current lowest positive to one that we checked\\n            elif val == cur or val == cur + 1:\\n                cur = val\\n           \\n           # break cycle if there is a gap of more than 1 between two\\n           # neighbouring values in sorted nums\\n           else:\\n                break\\n\\n        return cur + 1\\n```\\n## Complexity analysis\\nLet *N* be the length of the `nums` array.\\n* Time Complexity: *O(N \\\\* logN)*\\nQuicksort is generally considered the fastest among the usual sorting algorithms since its time complexity is *O(N \\\\* logN)* on average for a randomly sampled array. However, most programming languages use some sort of hybrid, heavily optimized algorithm as their native sort. Usually, the native sorting algorithms are the fastest, but their average time complexity is *O(N \\\\* logN)*.\\nFor each in `nums[i]`, we check whether the value is positive and equal to the previous or bigger by one.</br>\\nIn total we have *O(N \\\\* logN + N \\\\* M) = O(N \\\\* logN + N) = O(N \\\\* logN)*</br>\\n\\n* Space Complexity: *O(1)*\\nWe use constant extra space to store a fixed number of variables to account for the current number we search for. Quicksort is an in-place sorting algorithm, meaning that it uses no extra space.</br>\\nHowever, if you use native to your preferred language sorting algorithm, it may use a linear extra space in a worst-case scenario.\\n# Hash-Table solution\\nThe pros of using a hash table are that hash tables are implemented in such a way that adding, searching for, and deleting a value is done within average and amortized *O(1)* time. The solution lies in iterating through `nums` and adding every positive integer to the hash table, and then checking for the presence in the hash table of every positive integer in ascending order.\\n## Code:\\n```python\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n\\n        # create hash table\\n        present_values = set()\\n\\n        # add every value from nums to hash table\\n        for v in nums:\\n            if v > 0:\\n                present_values.add(v)\\n        \\n        # searching for lowest missing value, starting with 1\\n        cur = 1\\n        \\n        while cur in present_values:\\n            cur += 1\\n\\n        return cur\\n```\\n## Complexity analysis\\nLet *N* be the length of the `nums` array, and *O(M)* be the time complexity of finding whether a certain positive number is present in the hash table.\\n* Time Complexity: *O(N)*\\nFor each `nums[i]`, we add its value to the hash table in *O(1)* time. For values in the range *[1, \\u2026, N]*, we check whether they are present in the hash table in *O(M)* time.</br>\\nIn total we have *O(N \\\\* 1 + N \\\\* M) = O(N + N \\\\* 1) = O(N)*</br>\\n* Space Complexity: *O(N)*\\nWe use linear extra space to store the hash table (some of the values in `nums` are stored in the hash table). Not knowing the exact number of positive integers in `nums`, in the worst-case scenario, all values in `nums` will be positive), and thus hash table stores a certain percentage *P* of values in `nums`.</br>\\nNote that *O(P / 100 * N) = O(N)*\\n# Final solution\\nThere are a couple of constraints to the problem, which will help us find the right solution:\\n* We need to store somehow information about the existence of a certain positive number\\n* According to the problem\\u2019s formulation, we can not use additional space to store this information.\\n* We can not sort the `nums` array to store information in an intuitive ascending way because of the time complexity constraints which do not allow for sorting.\\n\\nThe only way to store all necessary information is in the `nums` array itself, and here is how we will do it. \\n1. We could use the cell at the index that corresponds to a specific value *v* to store information about the value *v* so that `nums[v]`, which contains some value *k*, will represent the existence of *v*, yet still containing information about the *k* value.\\n2. Since we only care about the positive numbers, upon reaching value *v*, we could make the value in `nums[v]` a negative value of the same power, `nums[v] = -nums[v]`. But you can already see some flaws in this approach:\\n\\n\\t* In case `nums[v] = 0`, then `-nums[v] = 0` as well, not reflecting the existence of *v*.\\n\\t* Negative integers could already be present in `nums`, confusing the algorithm, such as in the following case, say there is no value *v* in `nums`, but `nums[i] = -2`, then the algorithm would think that *v* was present in `nums`.\\n\\t* Large values greater than the highest index in `nums` can also be present in `nums`, calling for runtime errors.\\n3. Let us try to fix these issues:\\n\\t* In case `nums[v] = 0`: Since zero is not a positive integer, we do not care about its existence. We can replace it with any number that we know exists in `nums`, as adding a number already present in `nums` will not reflect on the lowest missing integer. The number that surely is the number *v* that we are processing at the moment `nums[v] = 0 => nums[v] = -v`.\\n\\t* Since the presence of negative values is irrelevant to us (we are looking for the lowest positive integer), we can replace all negatives with zeroes, especially since we have already solved the \\u2018zero\\u2019 problem.\\n\\t* As explained in the brute-force approach, missing values is in the range *[1, \\u2026, N + 1]* thus, we can ignore all values greater than *N* (if all values in *[1, \\u2026, N]* are present in `nums`, then *N + 1* is the lowest missing, thus no need to store information about *N + 1*), or perhaps more conveniently replace them with zeroes\\n4. And lastly, for convenience, to avoid messing with indices, we will add another zero value at the end of the array to represent the existence of value *N*; consequently, `nums[N]` will not present us with a runtime error.\\n![image](https://assets.leetcode.com/users/images/aefd3524-2345-4bbf-a834-5c4af0807abb_1661287627.2233372.gif)\\n## Code:\\n```python\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        # add zero value to the end to avoid messing with indices\\n        nums.append(0)\\n\\n        # nums preprocessing\\n        for idx, num in enumerate(nums):\\n            if nums[idx] <= 0 or nums[idx] >= len(nums):\\n                nums[idx] = 0\\n\\n        # getting nums to store information about the existence of processed positive integer\\n        for idx, num in enumerate(nums):\\n            i = abs(num)\\n\\n            if nums[i] == 0:\\n                nums[i] = -i\\n            else:\\n                nums[i] = -abs(nums[i])\\n\\n        idx = 1\\n\\n        # finding lowest positive integer that is missing from nums\\n        while idx < len(nums) and nums[idx] < 0:\\n            idx += 1\\n\\n        return idx\\n```\\n## Complexity analysis\\nLet *N* be the length of the `nums` array.\\n* Time Complexity: *O(N \\\\* logN)*\\nFor each `nums[i]`, we check whether it is negative or larger than *N* and replace it with zero if the condition is true in *O(N)* time. For each `nums[i] = v` we set `nums[|v|] = -|v|` in *O(N)* time. For each `nums[i] = v`, we check whether *v* is larger than zero, meaning that *v* was not present in `nums`, consequently *v* being the first missing positive in *O(N)* time</br>\\nIn total we have *O(N + N + N) = O(N)*\\n\\n* Space Complexity: *O(1)*\\nWe use constant extra space to store a fixed number of variables to account for the current number/index.\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n\\n\\t\\t# check presence of each value in [1, ..., N]\\n\\t\\t# missing value is N + 1 if every previous value is present\\n        for v in range(1, len(nums)):\\n\\n            if v not in nums:\\n                return v\\n\\n        return v + 1\\n```\n```python\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n\\n        # sort nums\\n        nums.sort()\\n        cur = 0\\n        \\n        for idx, val in enumerate(nums):\\n            # skip the negatives\\n            if val <= 0:\\n                continue\\n\\n            # check that next value in sorted nums contains\\n            # number that immeadiately follows it or is equal to it\\n            # set current lowest positive to one that we checked\\n            elif val == cur or val == cur + 1:\\n                cur = val\\n           \\n           # break cycle if there is a gap of more than 1 between two\\n           # neighbouring values in sorted nums\\n           else:\\n                break\\n\\n        return cur + 1\\n```\n```python\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n\\n        # create hash table\\n        present_values = set()\\n\\n        # add every value from nums to hash table\\n        for v in nums:\\n            if v > 0:\\n                present_values.add(v)\\n        \\n        # searching for lowest missing value, starting with 1\\n        cur = 1\\n        \\n        while cur in present_values:\\n            cur += 1\\n\\n        return cur\\n```\n```python\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        # add zero value to the end to avoid messing with indices\\n        nums.append(0)\\n\\n        # nums preprocessing\\n        for idx, num in enumerate(nums):\\n            if nums[idx] <= 0 or nums[idx] >= len(nums):\\n                nums[idx] = 0\\n\\n        # getting nums to store information about the existence of processed positive integer\\n        for idx, num in enumerate(nums):\\n            i = abs(num)\\n\\n            if nums[i] == 0:\\n                nums[i] = -i\\n            else:\\n                nums[i] = -abs(nums[i])\\n\\n        idx = 1\\n\\n        # finding lowest positive integer that is missing from nums\\n        while idx < len(nums) and nums[idx] < 0:\\n            idx += 1\\n\\n        return idx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718735,
                "title": "c-o-1-space-and-o-n-time-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n    Algorithm- \\n    We will rearrange the array such that each `valid` element get its correct place and then search for the answer in rearranged array.\\n    \\n    Question-0: Why the thought of array rearrangement should click OR Why this method?\\n        We can easily solve this question using unordered_set but that will cost us O(n) space and we are expected to solve it in O(1) extra space hence\\n\\t\\twe have to somehow make use of existing space to get the answer and hence the thought of array rearrangment should click.\\n     \\n    Question-1: What is correct the place for an element in the rearranged array? \\n        For an element i its correct place is i-1 th index in the array.\\n        E.g. [5,3,4,1,2] -> [1,2,3,4,5] or [4,-2,5,3,0] -> [0,-2,3,4,5].\\n        \\n    Question-2: Which elements will not get its correct place OR which are `invalid` elements? \\n        1. Elements which are non-positive -> We do not have any index in the array to store them(Hence condition-1: nums[i] <= 0 then continue).\\n        2. If element is larger than array size -> We again do not have correct index to store such elements(Hence condition-2: nums[i] > sz then continue). \\n        3. Repeated elements -> As one index can hold only one correct element other repeated elements will have to be ignored (Hence condition-3: \\n\\t\\t   nums[nums[i]-1] == nums[i] means element with which we are swapping current element is already in its correct position so ignore).\\n        \\n    Question-3: How we will get the final answer?\\n        We will go through the modified array and find the first position(in or outside the array) which does not hold the correct element.\\n    */\\n    int firstMissingPositive(vector<int>& nums) {\\n        int sz = nums.size();\\n        for(int i=0;i<sz;i++) {\\n            while(nums[i] != i+1) {\\n                if(nums[i] <= 0 || nums[i] > sz || nums[nums[i]-1] == nums[i]) break;\\n                swap(nums[nums[i]-1], nums[i]);\\n            }\\n        }\\n        for(int i=0;i<sz;i++) if(nums[i] != i+1) return i+1;\\n        return sz+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n    Algorithm- \\n    We will rearrange the array such that each `valid` element get its correct place and then search for the answer in rearranged array.\\n    \\n    Question-0: Why the thought of array rearrangement should click OR Why this method?\\n        We can easily solve this question using unordered_set but that will cost us O(n) space and we are expected to solve it in O(1) extra space hence\\n\\t\\twe have to somehow make use of existing space to get the answer and hence the thought of array rearrangment should click.\\n     \\n    Question-1: What is correct the place for an element in the rearranged array? \\n        For an element i its correct place is i-1 th index in the array.\\n        E.g. [5,3,4,1,2] -> [1,2,3,4,5] or [4,-2,5,3,0] -> [0,-2,3,4,5].\\n        \\n    Question-2: Which elements will not get its correct place OR which are `invalid` elements? \\n        1. Elements which are non-positive -> We do not have any index in the array to store them(Hence condition-1: nums[i] <= 0 then continue).\\n        2. If element is larger than array size -> We again do not have correct index to store such elements(Hence condition-2: nums[i] > sz then continue). \\n        3. Repeated elements -> As one index can hold only one correct element other repeated elements will have to be ignored (Hence condition-3: \\n\\t\\t   nums[nums[i]-1] == nums[i] means element with which we are swapping current element is already in its correct position so ignore).\\n        \\n    Question-3: How we will get the final answer?\\n        We will go through the modified array and find the first position(in or outside the array) which does not hold the correct element.\\n    */\\n    int firstMissingPositive(vector<int>& nums) {\\n        int sz = nums.size();\\n        for(int i=0;i<sz;i++) {\\n            while(nums[i] != i+1) {\\n                if(nums[i] <= 0 || nums[i] > sz || nums[nums[i]-1] == nums[i]) break;\\n                swap(nums[nums[i]-1], nums[i]);\\n            }\\n        }\\n        for(int i=0;i<sz;i++) if(nums[i] != i+1) return i+1;\\n        return sz+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371896,
                "title": "python-o-n-time-and-o-1-space-accepted-solution-with-explanation",
                "content": "**TECHNIQUE :**\\n\\nWhat we are going to use a simple trick that if we modify a element A as **A\\' =  A + (B * N)** (here A is smaller than N) then now we can obtain both the value A and B from this new A as : \\nA = A\\' % N and B = A\\' / N\\n\\nWe can use this technique here to use the current array as a hash array.\\n\\n**Approach :**\\n\\nIf we have an array of size say x then we can definitely say that our missing number will lie in range 1 to (x+1). So, we can modify the array so that ith number will get stored at ith cell. Then we can traverse through the array and the index at which arr[i] != i, will be our answer. In case, all are present, then we can check if n is present in original array or not, if yes then our answer will be (n+1) else our answer is n. \\n\\n**CODE :**\\n\\n```\\ndef missingNumber(self,arr,n):\\n\\t\\t/* variable to check if n is present in our array or not */\\n        hasN = False\\n        for i in range(0,n):\\n\\t\\t\\t# if n is present we update our boolean variable to True\\n            if arr[i] == n:\\n                hasN = True\\n\\t\\t\\t\\t\\n\\t\\t\\t# marking the useless elements as zero\\n            if arr[i]<=0 or arr[i]>=n:\\n                arr[i] = 0\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n        #using the above technique, we are updating the current array \\n\\t\\t\\t# so that arr[i] contains its original value as well as the desired value        \\n        for i in range(0,n):\\n            val = arr[i]%n\\n\\t\\t\\t\\n\\t\\t\\t# leaving the useless elements as well as\\n\\t\\t\\t# already updated elements\\n            if val==0 or arr[val]//n == val:\\n                continue\\n            arr[val] += val * n\\n        \\n        #simple check that updated arr[i] contains i or not\\n        for i in range(1,n):\\n            if arr[i]//n != i:\\n                return i\\n                \\n\\t\\t#in case 1 to n-1 are all present , we will check for n and n+1 using prev calculated hasN\\n        if hasN == True:\\n            return n+1\\n        else :\\n            return n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef missingNumber(self,arr,n):\\n\\t\\t/* variable to check if n is present in our array or not */\\n        hasN = False\\n        for i in range(0,n):\\n\\t\\t\\t# if n is present we update our boolean variable to True\\n            if arr[i] == n:\\n                hasN = True\\n\\t\\t\\t\\t\\n\\t\\t\\t# marking the useless elements as zero\\n            if arr[i]<=0 or arr[i]>=n:\\n                arr[i] = 0\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n        #using the above technique, we are updating the current array \\n\\t\\t\\t# so that arr[i] contains its original value as well as the desired value        \\n        for i in range(0,n):\\n            val = arr[i]%n\\n\\t\\t\\t\\n\\t\\t\\t# leaving the useless elements as well as\\n\\t\\t\\t# already updated elements\\n            if val==0 or arr[val]//n == val:\\n                continue\\n            arr[val] += val * n\\n        \\n        #simple check that updated arr[i] contains i or not\\n        for i in range(1,n):\\n            if arr[i]//n != i:\\n                return i\\n                \\n\\t\\t#in case 1 to n-1 are all present , we will check for n and n+1 using prev calculated hasN\\n        if hasN == True:\\n            return n+1\\n        else :\\n            return n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1291029,
                "title": "c-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        /*\\n        \\n        Lets say the size of the array is n\\n        We need to find the first missing positive number\\n        The range of values for this required number should be ? \\n        If the array is strictly increasing and starts with 1 then the missing number would be n+1;\\n        but if thats not the case then the first positive number should be in the range[1,n];\\n        \\n        algo should be:\\n        we can discard the negative and numbers greater than n.\\n        For the remaining numbers we can use them as index and\\n        mark the number in index position. \\n         One way to mark would be first replace negative number and number greater than n with n+1\\n         Then using marking technique mentioned convert the value to negative.\\n         \\n        After that iterate the array and return the first unmarked poition +1 value as the result.\\n        */\\n        \\n        if(nums.size()==1 && nums[0]<=0)\\n            return 1;\\n            \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<=0 || nums[i] > nums.size()+1)\\n                nums[i]=nums.size()+1;            \\n        }\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(abs(nums[i]) > nums.size())continue;\\n            int idx = abs(nums[i])-1;\\n            \\n            if( nums[idx] > 0)\\n                nums[idx]=-nums[idx];\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0)\\n                return i+1;\\n        }\\n        return nums.size()+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        /*\\n        \\n        Lets say the size of the array is n\\n        We need to find the first missing positive number\\n        The range of values for this required number should be ? \\n        If the array is strictly increasing and starts with 1 then the missing number would be n+1;\\n        but if thats not the case then the first positive number should be in the range[1,n];\\n        \\n        algo should be:\\n        we can discard the negative and numbers greater than n.\\n        For the remaining numbers we can use them as index and\\n        mark the number in index position. \\n         One way to mark would be first replace negative number and number greater than n with n+1\\n         Then using marking technique mentioned convert the value to negative.\\n         \\n        After that iterate the array and return the first unmarked poition +1 value as the result.\\n        */\\n        \\n        if(nums.size()==1 && nums[0]<=0)\\n            return 1;\\n            \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<=0 || nums[i] > nums.size()+1)\\n                nums[i]=nums.size()+1;            \\n        }\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(abs(nums[i]) > nums.size())continue;\\n            int idx = abs(nums[i])-1;\\n            \\n            if( nums[idx] > 0)\\n                nums[idx]=-nums[idx];\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0)\\n                return i+1;\\n        }\\n        return nums.size()+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1060638,
                "title": "python-really-cool-solution-faster-than-99-32-o-n-time-o-1-memory",
                "content": "\\tclass Solution:\\n\\t\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\t\\tdef swap(nums: List[int], i: int, j: int):\\n\\t\\t\\t\\ttmp = nums[i]\\n\\t\\t\\t\\tnums[i] = nums[j]\\n\\t\\t\\t\\tnums[j] = tmp\\n\\t\\t\\t\\n\\t\\t\\tlength = len(nums)\\n\\t\\t\\tfor index in range(len(nums)):\\n\\t\\t\\t\\twhile( nums[index] > 0 and nums[index] <= length and nums[nums[index] - 1] != nums[index]):\\n\\t\\t\\t\\t\\tswap(nums, index, nums[index] - 1)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\tfor index in range(len(nums)):\\n\\t\\t\\t\\tif nums[index] != index + 1: return index + 1\\n\\t\\t\\treturn length + 1",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\t\\tdef swap(nums: List[int], i: int, j: int):\\n\\t\\t\\t\\ttmp = nums[i]\\n\\t\\t\\t\\tnums[i] = nums[j]\\n\\t\\t\\t\\tnums[j] = tmp\\n\\t\\t\\t\\n\\t\\t\\tlength = len(nums)\\n\\t\\t\\tfor index in range(len(nums)):\\n\\t\\t\\t\\twhile( nums[index] > 0 and nums[index] <= length and nums[nums[index] - 1] != nums[index]):\\n\\t\\t\\t\\t\\tswap(nums, index, nums[index] - 1)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\tfor index in range(len(nums)):\\n\\t\\t\\t\\tif nums[index] != index + 1: return index + 1\\n\\t\\t\\treturn length + 1",
                "codeTag": "Java"
            },
            {
                "id": 914496,
                "title": "c-o-n-time-o-1-space",
                "content": "Answer may be in [1, n] or it may be n + 1\\nElement bound [1, n]\\nIf there a element whose value is out of bound the the answer is between [1, n], else the answer is n + 1\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n\\t\\t// Checking if the answer is 1\\n        bool f = false;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 1)\\n            {\\n                f = true;\\n                break;\\n            }\\n        }\\n        \\n        if(!f)\\n        {\\n            return 1;\\n        }\\n        // 1 is present so it doesn\\'t matter how many times it is present\\n        \\n\\t\\t// Making all the out of bound elements 1\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] < 1 || nums[i] > n)\\n            {\\n                nums[i] = 1;\\n            }\\n        }\\n        \\n\\t\\t// Hashing\\n        for(int i = 0; i < n; i++)\\n        {\\n            int c = abs(nums[i]);\\n            nums[c - 1] = -1 * abs(nums[c - 1]);\\n        }\\n        \\n\\t\\t// Checking\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] > 0)\\n            {\\n                return i + 1;\\n            }\\n        }\\n        \\n        \\n        return n + 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n\\t\\t// Checking if the answer is 1\\n        bool f = false;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 1)\\n            {\\n                f = true;\\n                break;\\n            }\\n        }\\n        \\n        if(!f)\\n        {\\n            return 1;\\n        }\\n        // 1 is present so it doesn\\'t matter how many times it is present\\n        \\n\\t\\t// Making all the out of bound elements 1\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] < 1 || nums[i] > n)\\n            {\\n                nums[i] = 1;\\n            }\\n        }\\n        \\n\\t\\t// Hashing\\n        for(int i = 0; i < n; i++)\\n        {\\n            int c = abs(nums[i]);\\n            nums[c - 1] = -1 * abs(nums[c - 1]);\\n        }\\n        \\n\\t\\t// Checking\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] > 0)\\n            {\\n                return i + 1;\\n            }\\n        }\\n        \\n        \\n        return n + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 871583,
                "title": "c-two-pointers-o-n-with-swap",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) \\n    {\\n        int l = 0, r = nums.size() - 1;\\n        while(l < r)\\n        {\\n            if(l + 1 == nums[l])\\n                l++;\\n            else if(r + 1 == nums[r] || nums[r] <= 0 || nums[r] >= nums.size() || nums[nums[r] - 1] == nums[r])\\n                r--;\\n            else \\n                swap(nums[r], nums[nums[r] - 1]);\\n        }\\n        while(l < nums.size() && l + 1 == nums[l])\\n            l++;\\n        return l + 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) \\n    {\\n        int l = 0, r = nums.size() - 1;\\n        while(l < r)\\n        {\\n            if(l + 1 == nums[l])\\n                l++;\\n            else if(r + 1 == nums[r] || nums[r] <= 0 || nums[r] >= nums.size() || nums[nums[r] - 1] == nums[r])\\n                r--;\\n            else \\n                swap(nums[r], nums[nums[r] - 1]);\\n        }\\n        while(l < nums.size() && l + 1 == nums[l])\\n            l++;\\n        return l + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 725846,
                "title": "python-easy-solution-with-comments",
                "content": "```py\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n        # mark those elements who aren\\'t in the range of [1, n]\\n        for i in range(n):\\n            if nums[i] <= 0 or nums[i] > n:\\n                nums[i] = n + 1\\n        \\n        # mark visited elements as negative\\n        for i in range(n): \\n            if (abs(nums[i]) - 1 < n and nums[abs(nums[i]) - 1] > 0): \\n                nums[abs(nums[i]) - 1] = -nums[abs(nums[i]) - 1] \\n\\n        # find first positive/unmarked element and return its index\\n        for i in range(n): \\n            if (nums[i] > 0): \\n                return i + 1\\n        \\n        # if all elements are negative/marked means all elements are in the range of [1, n]\\n        return n + 1\\n```\\n\\nFor another approach, check out https://leetcode.com/problems/first-missing-positive/discuss/754516/O(1)-space-O(n)-time-Python-solution-by-placing-elements-to-their-right-position",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```py\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n        # mark those elements who aren\\'t in the range of [1, n]\\n        for i in range(n):\\n            if nums[i] <= 0 or nums[i] > n:\\n                nums[i] = n + 1\\n        \\n        # mark visited elements as negative\\n        for i in range(n): \\n            if (abs(nums[i]) - 1 < n and nums[abs(nums[i]) - 1] > 0): \\n                nums[abs(nums[i]) - 1] = -nums[abs(nums[i]) - 1] \\n\\n        # find first positive/unmarked element and return its index\\n        for i in range(n): \\n            if (nums[i] > 0): \\n                return i + 1\\n        \\n        # if all elements are negative/marked means all elements are in the range of [1, n]\\n        return n + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 364428,
                "title": "python-o-n-time-o-1-space-with-explanation",
                "content": "The key observation is that the smallest missing positive integer is NO MORE THAN n+1. Therefore, we can safely remove all the integers that are greater than n or less than 1, then all numbers in the list are less than or equal to n. By arranging each number in the new list to correspoding position(e.g. nums[0] = 1, nums[1] = 2 ...), we can spot the missing integer within O(n) time and O(1) space.\\n\\n```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n\\n        i = 0\\n        while i < n:\\n            while 0 < nums[i] <= n and nums[i] != i + 1 and nums[nums[i] - 1] != nums[i]:\\n                # termination conditions:\\n                # 1. current number is less than zero or greater than n, leave it and check the next position\\n                # 2. current number is the right number\\n                # 3. the position corresponds to current number has already contain the right number\\n                # Otherwise, exchange between current position and the position corresponds to current number\\n\\t\\t\\t\\t\\n                tmp = nums[i]\\n                nums[i], nums[tmp - 1] = nums[tmp - 1], nums[i]\\n            i += 1\\n\\n        for i in range(n):\\n            if nums[i] != i + 1:\\n                return i + 1\\n        return n + 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n\\n        i = 0\\n        while i < n:\\n            while 0 < nums[i] <= n and nums[i] != i + 1 and nums[nums[i] - 1] != nums[i]:\\n                # termination conditions:\\n                # 1. current number is less than zero or greater than n, leave it and check the next position\\n                # 2. current number is the right number\\n                # 3. the position corresponds to current number has already contain the right number\\n                # Otherwise, exchange between current position and the position corresponds to current number\\n\\t\\t\\t\\t\\n                tmp = nums[i]\\n                nums[i], nums[tmp - 1] = nums[tmp - 1], nums[i]\\n            i += 1\\n\\n        for i in range(n):\\n            if nums[i] != i + 1:\\n                return i + 1\\n        return n + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 304741,
                "title": "cyclic-sort-o-n-runtime-0-ms-memory-usage-34-1-mb-java-with-comments",
                "content": "```\\nclass Solution {\\n    \\n\\tpublic int firstMissingPositive(int[] nums) {\\n       int i=0;\\n       // Convert the array to \"1 to n\" (example below) form using Cyclic Sort \\n       // and map +ve numbers to respective indices around negative numbers\\n       while(i < nums.length) {\\n         if(nums[i] > 0 // Skip negative numbers\\n         && nums[i] <= nums.length //Critical, so we do not want to go out of bound\\n         && nums[i] != nums[nums[i] - 1]) { // Cyclic Sort criteria\\n               swap (nums, i, nums[i] - 1);\\n         } else {\\n               ++i;\\n         }\\n       }\\n        \\n       // Example: For an input array [-3, 1, 5, 4, 2 ], the cyclic sorted \\n       // array after the above jumps will look like [1, 2, -3, 4, 5].\\n       // Looking at this we know the element after 2, i.e 3 is missing.\\n       for(i=0; i<nums.length; i++) {\\n           if(i+1 != nums[i]) {\\n               return i + 1;\\n           }\\n       }\\n        \\n       return i+1; // This will tc of all negative testcases like empty array etc\\n    }\\n\\t\\n\\tprivate static void swap (int [] nums, int a, int b) {\\n        int temp = nums[a];\\n        nums[a] = nums[b];\\n        nums[b] = temp;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n\\tpublic int firstMissingPositive(int[] nums) {\\n       int i=0;\\n       // Convert the array to \"1 to n\" (example below) form using Cyclic Sort \\n       // and map +ve numbers to respective indices around negative numbers\\n       while(i < nums.length) {\\n         if(nums[i] > 0 // Skip negative numbers\\n         && nums[i] <= nums.length //Critical, so we do not want to go out of bound\\n         && nums[i] != nums[nums[i] - 1]) { // Cyclic Sort criteria\\n               swap (nums, i, nums[i] - 1);\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 243173,
                "title": "java-solution-faster-than-100-o-1-space-and-o-n-time",
                "content": "We can assert the answer must be in [1, len + 1], the len is the length of input array. Because if the answer is greater than len + 1, then [1, 2, ...., len + 1] must be in the array, but the array of len length only can store [1, 2, ..., len]. \\nSo, first we can replace the zero or negative with len + 1, and that not change answer. then this problem similar with [find-all-numbers-disappeared-in-an-array](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/), [find-all-duplicates-in-an-array](https://leetcode.com/problems/find-all-duplicates-in-an-array/) :)\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int len = nums.length;\\n        for (int i = 0; i < len; i++) {\\n            if (nums[i] <= 0) {\\n                nums[i] = len + 1;\\n            }\\n        }\\n        \\n        for (int i = 0; i < len; i++) {\\n            int n = Math.abs(nums[i]);\\n            if (n <= len && nums[n - 1] > 0) {\\n                nums[n - 1] *= -1;\\n            }\\n        }\\n        \\n        int first = len + 1;\\n        for (int i = 0; i < len; i++) {\\n            if (nums[i] >= 0) {\\n                first = i + 1;\\n                break;\\n            }\\n        }\\n        \\n        return first;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int len = nums.length;\\n        for (int i = 0; i < len; i++) {\\n            if (nums[i] <= 0) {\\n                nums[i] = len + 1;\\n            }\\n        }\\n        \\n        for (int i = 0; i < len; i++) {\\n            int n = Math.abs(nums[i]);\\n            if (n <= len && nums[n - 1] > 0) {\\n                nums[n - 1] *= -1;\\n            }\\n        }\\n        \\n        int first = len + 1;\\n        for (int i = 0; i < len; i++) {\\n            if (nums[i] >= 0) {\\n                first = i + 1;\\n                break;\\n            }\\n        }\\n        \\n        return first;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 174383,
                "title": "o-n-time-o-1-space-without-swapping-with-explanation",
                "content": "## Idea:\\n1. Any element less than `0` or greater than `n` is useless, so change those to `0`\\n2. Track whether an element is present by making the element at the index negative\\n\\n## Steps:\\n1. Assign `0` to useless terms (`nums[i] < 0 || nums[i] > n`)\\n    - `[3,4,-1,1] -> [3,4,0,1]`\\n2. Treat each element as a pointer by making the element at that index negative (taking the absolute value to ignore whether we marked it as present). The one edge case is if the element is `0`: we point to itself since we assigned `0` to the useless elements.\\n\\t1. `nums[0] = 3: [3,4,0,1] -> [3,4,-3,1]` (the third element is 0 so we point to itself)\\n\\t2. `nums[1] = 4: [3,4,-3,1] -> [3,4,-3,-1]` (we negate the fourth element)\\n\\t3. `nums[2] = -3` (no change since the third element is already negative)\\n\\t4. `nums[3] = -1: [3,4,-3,-1] -> [-3,4,-3,-1]` (we negate the first element)\\n3. Return the correct index for the first element that is `>= 0`\\n\\n## Full solution:\\n```\\npublic int firstMissingPositive(int[] nums) {\\n    int n = nums.length;\\n    for (int i = 0; i < n; i++) {\\n        if (nums[i] < 0 || nums[i] > n) {\\n            nums[i] = 0;\\n        }\\n    }\\n\\n    for (int num : nums) {\\n        if (num != 0) {\\n            int index = Math.abs(num) - 1;\\n            if (nums[index] == 0) {\\n                nums[index] = -(index + 1);\\n            } else {\\n                nums[index] = -Math.abs(nums[index]);\\n            }\\n        }\\n    }\\n\\n    for (int i = 0; i < n; i++) {\\n        if (nums[i] >= 0) {\\n            return i + 1;\\n        }\\n    }\\n    return n + 1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int firstMissingPositive(int[] nums) {\\n    int n = nums.length;\\n    for (int i = 0; i < n; i++) {\\n        if (nums[i] < 0 || nums[i] > n) {\\n            nums[i] = 0;\\n        }\\n    }\\n\\n    for (int num : nums) {\\n        if (num != 0) {\\n            int index = Math.abs(num) - 1;\\n            if (nums[index] == 0) {\\n                nums[index] = -(index + 1);\\n            } else {\\n                nums[index] = -Math.abs(nums[index]);\\n            }\\n        }\\n    }\\n\\n    for (int i = 0; i < n; i++) {\\n        if (nums[i] >= 0) {\\n            return i + 1;\\n        }\\n    }\\n    return n + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 170370,
                "title": "python-o-n-time-o-1-space-beats-100-changes-the-original-list",
                "content": "```\\nclass Solution(object):\\n    def firstMissingPositive(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        length = len(nums)\\n        k = 0\\n        \\n        # remove 0, negatives, and too large numbers\\n        for i, num in enumerate(nums):\\n            if num > 0 and num <= length:\\n                # move the positive integers up front\\n                nums[k] = num \\n                k += 1 \\n        \\n        # We manipulate the list up to the k-th index\\n        # We don\\'t care about the elements from indices (k+1)-th to length.\\n        # Now the nums[:k+1] only contains integers in the range 1 to k+1.\\n        # We treat the elements as the next indices. \\n        # When an element is reached, it is changed to be negative.\\n        # If the element is never reached, it\\'s gonna stay positive.\\n        # That is the first missing positive integer.\\n        for i in range(k):\\n            num = abs(nums[i])\\n            \\n            if nums[num-1] > 0:\\n                nums[num-1] *= -1\\n        \\n        for i in range(k):\\n            if nums[i] >= 0:\\n                return i+1\\n        \\n        return k+1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def firstMissingPositive(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        length = len(nums)\\n        k = 0\\n        \\n        # remove 0, negatives, and too large numbers\\n        for i, num in enumerate(nums):\\n            if num > 0 and num <= length:\\n                # move the positive integers up front\\n                nums[k] = num \\n                k += 1 \\n        \\n        # We manipulate the list up to the k-th index\\n        # We don\\'t care about the elements from indices (k+1)-th to length.\\n        # Now the nums[:k+1] only contains integers in the range 1 to k+1.\\n        # We treat the elements as the next indices. \\n        # When an element is reached, it is changed to be negative.\\n        # If the element is never reached, it\\'s gonna stay positive.\\n        # That is the first missing positive integer.\\n        for i in range(k):\\n            num = abs(nums[i])\\n            \\n            if nums[num-1] > 0:\\n                nums[num-1] *= -1\\n        \\n        for i in range(k):\\n            if nums[i] >= 0:\\n                return i+1\\n        \\n        return k+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996341,
                "title": "solution-explained-with-example-o-n-time-o-1-space",
                "content": "# Bruteforce\\nMark all the integers of array in separate array of n elements by updating corresponding value to 1 and then from start find index at which value is not 1 to identify the smallest missing positive integer.\\n\\n# Optimal Approach\\nHere we can\\'t mark all the integers as we only have O(1) auxiliary space. So, we will use the same array to mark the numbers. But you\\'ll think that how can we mark? There will be some number at each index. So, we will do this in loop until we reach the free space or come at begining, this way no data will be lost.\\n\\n# Example\\nArray : [5, 6, 2, 1, 2] => N = 5\\nPre Processing : We will remove all negatives integers and numbers greater than N by replacing them with 0.\\n0 = Represents position free to be marked, no loss of data.\\n-1 = Position already marked, integer present in input array.\\n\\nArray (current state) : [6, 0, 2, 1, 2] \\n\\nStart with Index: 0\\nRead number 5 and free up position(index: 0) by marking it with 0. Mark number 5 by replacing arr[5 - 1] with -1. In order to avoid loss of data at index 4, we will keep it in temp variable. After marking, we will do the same process for temp variable which is 1.\\n\\nArray (current state) : [-1, 0, 2, -1, 2] \\nInsights - Integer 1 and 5 was present in input array because they are marked in above array.\\n\\nIndex : 1\\nAlready 0. It\\'s free space and we can ignore it.\\n\\nIndex : 2\\n2 will be marked at arr[2 - 1] which is already free so no further processing.\\nArray (current state) : [-1, -1, 0, -1, 2]\\n\\nIndex : 3\\nNo data present to mark because it\\'s -1.\\n\\nIndex : 4\\n2 will be marked at arr[2 - 1], it\\'s already marked so we can either ignore or remark it.\\n\\nFinal array : [-1, -1, 0, -1, 0]\\n\\nTraverse the array and stop at first non -1 number. Here it will be index 2, So Integer 3 is missing.\\n\\nIf we don\\'t find any non -1 number then N + 1 will be the answer.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N) - Since we will come at every index only once.\\n\\n- Space complexity:\\nO(1) - No space is used other than few temporary variables.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        // Remove negative and numbers greater than N, those are unwanted.\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] < 0 || nums[i] > n) nums[i] = 0;\\n        }\\n\\n        // Starting from index 0, we will start marking.\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 0 || nums[i] == -1) continue;\\n\\n            int index = nums[i] - 1; // index is the position of number which needs to be updated\\n            nums[i] = 0; \\n            int temp;\\n            while (nums[index] > 0) {\\n                temp = nums[index];\\n                nums[index] = -1;\\n                index = temp - 1;\\n            }\\n            nums[index] = -1;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] != -1) return i + 1;\\n        }\\n        return n + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        // Remove negative and numbers greater than N, those are unwanted.\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] < 0 || nums[i] > n) nums[i] = 0;\\n        }\\n\\n        // Starting from index 0, we will start marking.\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 0 || nums[i] == -1) continue;\\n\\n            int index = nums[i] - 1; // index is the position of number which needs to be updated\\n            nums[i] = 0; \\n            int temp;\\n            while (nums[index] > 0) {\\n                temp = nums[index];\\n                nums[index] = -1;\\n                index = temp - 1;\\n            }\\n            nums[index] = -1;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] != -1) return i + 1;\\n        }\\n        return n + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738172,
                "title": "java-solution-using-min-heap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n    PriorityQueue <Integer> minHeap = new PriorityQueue<>();\\n    // Add all the positive numbers in the PriorityQueue\\n    for(int i = 0; i < nums.length; i ++) {\\n        if(nums[i] > 0) minHeap.add(nums[i]);\\n    }\\n    int minMissing = 1;\\n    // Check for all minimum missing positive number\\n    while(! minHeap.isEmpty()) {\\n        int element = minHeap.poll();\\n        if(element == minMissing) minMissing ++;\\n        else if(element > minMissing) break;\\n    }\\n    return minMissing;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n    PriorityQueue <Integer> minHeap = new PriorityQueue<>();\\n    // Add all the positive numbers in the PriorityQueue\\n    for(int i = 0; i < nums.length; i ++) {\\n        if(nums[i] > 0) minHeap.add(nums[i]);\\n    }\\n    int minMissing = 1;\\n    // Check for all minimum missing positive number\\n    while(! minHeap.isEmpty()) {\\n        int element = minHeap.poll();\\n        if(element == minMissing) minMissing ++;\\n        else if(element > minMissing) break;\\n    }\\n    return minMissing;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718092,
                "title": "easy-detailed-c-o-n-time-complexity-o-1-space-complexity-solution-beats-100",
                "content": "# Intuition\\nHashmap\\n\\n# Approach\\n1. shift all the negative numbers to the rightmost side using two pointers\\n\\n2. Use index as hashmap to check which positive number is missing\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        //Complexities - \\n        //time complexity O(n)\\n        //space complexity O(1)\\n        \\n        //Code improvement suggestion -\\n        //revert back the changes done to the array after getting the min missing positive number\\n\\n        //steps used - \\n        // 1. shift all the negative numbers to the rightmost side using two pointers\\n\\n\\n        //2. Use index as hashmap to check which positive number is missing\\n\\n        int maxElement = 0;\\n        int l = nums.size()-1;\\n        int r = nums.size() -1;\\n\\n        while(r>=0) {\\n            if(nums[r]<=0) {\\n                swap(nums[l], nums[r]);\\n                l--;\\n            }\\n            if(nums[r] > maxElement) {\\n                maxElement = nums[r];\\n            }\\n            r--;\\n        }\\n\\n          // l contains the location of last positive integer\\n          for(int i =0; i <=l; i++) {\\n              if( (abs(nums[i]) - 1) <=l && nums[abs(nums[i]) - 1] > 0) {\\n                  nums[abs(nums[i]) - 1] = 0 - nums[abs(nums[i]) - 1];\\n              }\\n          }\\n\\n          //any the number till l position if found postive the index value + 1 will be the first missing positive integer  \\n          for(int i =0; i <=l; i++) {\\n              if(nums[i] >0) {\\n                  return i+1;\\n              }\\n          }\\n\\n          // if we did not find out any missing number in seq that means whatever is the max positive integer till now + 1 will be the first missing posyive number  \\n          return maxElement+1;  \\n     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        //Complexities - \\n        //time complexity O(n)\\n        //space complexity O(1)\\n        \\n        //Code improvement suggestion -\\n        //revert back the changes done to the array after getting the min missing positive number\\n\\n        //steps used - \\n        // 1. shift all the negative numbers to the rightmost side using two pointers\\n\\n\\n        //2. Use index as hashmap to check which positive number is missing\\n\\n        int maxElement = 0;\\n        int l = nums.size()-1;\\n        int r = nums.size() -1;\\n\\n        while(r>=0) {\\n            if(nums[r]<=0) {\\n                swap(nums[l], nums[r]);\\n                l--;\\n            }\\n            if(nums[r] > maxElement) {\\n                maxElement = nums[r];\\n            }\\n            r--;\\n        }\\n\\n          // l contains the location of last positive integer\\n          for(int i =0; i <=l; i++) {\\n              if( (abs(nums[i]) - 1) <=l && nums[abs(nums[i]) - 1] > 0) {\\n                  nums[abs(nums[i]) - 1] = 0 - nums[abs(nums[i]) - 1];\\n              }\\n          }\\n\\n          //any the number till l position if found postive the index value + 1 will be the first missing positive integer  \\n          for(int i =0; i <=l; i++) {\\n              if(nums[i] >0) {\\n                  return i+1;\\n              }\\n          }\\n\\n          // if we did not find out any missing number in seq that means whatever is the max positive integer till now + 1 will be the first missing posyive number  \\n          return maxElement+1;  \\n     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693801,
                "title": "first-missing-positive-using-c-with-time-o-n-memory-o-1",
                "content": "# Intuition\\nCan we solve this problem in-place or without using extra space? \\n# Approach\\nThe approach described is known as the \"Cyclic Sort\" algorithm, which is used to solve the problem of finding the first missing positive number in an array without using extra space. It involves rearranging the elements in the array by swapping them into their correct positions.\\n\\nThe algorithm works as follows:\\n1. Iterate through the array from the start.\\n2. Check if the current number, X[i], is within the range of 1 to n and if it is not already present at index X[i] - 1.\\n3. If the conditions are met, swap X[i] with the number present at the index X[i] - 1.\\n4. Continue the process until the array is fully traversed.\\n\\nAfter the sorting is done, the next step is to scan the modified array again to find the first index where X[i] is not equal to i + 1. This indicates the presence of a missing positive number. If such an index is found, return i + 1 as the first missing positive. If no such index is found, it means all numbers from 1 to n are present in the array, so return the value n + 1 as the first missing positive.\\n\\nThis algorithm solves the problem in-place, meaning it rearranges the elements within the original array without requiring additional space.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int i = 0;\\n        while(i<nums.size()){\\n            if(nums[i] > 0 && nums[i] <= nums.size() && nums[nums[i]-1] != nums[i]){\\n                swap(nums[i], nums[nums[i]-1]);\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        for (int i = 0; i < nums.size(); i++) {\\n            if(nums[i] != i+1){\\n                return i+1;\\n            }\\n        }\\n\\n        return nums.size() + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int i = 0;\\n        while(i<nums.size()){\\n            if(nums[i] > 0 && nums[i] <= nums.size() && nums[nums[i]-1] != nums[i]){\\n                swap(nums[i], nums[nums[i]-1]);\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        for (int i = 0; i < nums.size(); i++) {\\n            if(nums[i] != i+1){\\n                return i+1;\\n            }\\n        }\\n\\n        return nums.size() + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618414,
                "title": "easy-peasy-c-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        unordered_set<int> st;\\n        for(auto x: nums) st.insert(x);\\n        for(int i=1; ;i++){\\n            if(st.find(i)==st.end()) return i;\\n        }\\n        return 0;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        unordered_set<int> st;\\n        for(auto x: nums) st.insert(x);\\n        for(int i=1; ;i++){\\n            if(st.find(i)==st.end()) return i;\\n        }\\n        return 0;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505754,
                "title": "beginner-friendly-approach-usinf-hashsets-basic-trick",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nintuition was to solve the problem with the help of sets in one loops\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ni stored the value in sets ,because sets automatically arrange it in increasing order making it very easy to solve.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        set<int> data;\\n        int n=nums.size();\\n        for(int x=0;x<n;x++)\\n        {\\n            data.insert(nums[x]);\\n        }\\n        int i=1;\\n        while(i<=n)\\n        {\\n            if(data.find(i)!=data.end()) i++;\\n            else return i;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        set<int> data;\\n        int n=nums.size();\\n        for(int x=0;x<n;x++)\\n        {\\n            data.insert(nums[x]);\\n        }\\n        int i=1;\\n        while(i<=n)\\n        {\\n            if(data.find(i)!=data.end()) i++;\\n            else return i;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447629,
                "title": "c-sorting-easy-10-lines-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply sort the array and keep a current positive count , If you able to get it increment current positive else return it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.) Set curPos i.e. count for current positive to 1.\\n2.) Now  sort the array \\n3.)Then simply iterate the array , If you find it increment curPos and search in remaining array\\n4.) If you don\\'t find it i.e. i reaches to n-1(size-1) simply return curPos because it is missing in the array.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*logN) -> sorting the array\\nO(N)->for searching \\n\\nTotal = O(NlogN + N) = O(N(logN+1))= O(N*logN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) -> no extra space used \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end()); // to sort the array \\n\\n        int curPos=1; // sets current Positive to 1 \\n        \\n        for(int i=0;i<n;i++){\\n            if(nums[i]==curPos) curPos++;\\n        }\\n\\n        return curPos;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end()); // to sort the array \\n\\n        int curPos=1; // sets current Positive to 1 \\n        \\n        for(int i=0;i<n;i++){\\n            if(nums[i]==curPos) curPos++;\\n        }\\n\\n        return curPos;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297321,
                "title": "first-missing-positive-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        for(int i=0 ; i<nums.length; ) {\\n\\t\\t\\tif(nums[i]<=0 || nums[i]>=nums.length || nums[i]-1== i || nums[i]==nums[nums[i]-1] )i++;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tint index= nums[i]-1; \\n\\t\\t\\t    int temp = nums[index]; \\n\\t\\t\\t\\tnums[index]= nums[i];\\n\\t\\t\\t\\tnums[i]= temp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor(int i=0 ; i<nums.length ; i++) {\\n\\t\\t\\tif(nums[i]-1!=i) {\\n\\t\\t\\t\\treturn i+1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn nums.length+1;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        for(int i=0 ; i<nums.length; ) {\\n\\t\\t\\tif(nums[i]<=0 || nums[i]>=nums.length || nums[i]-1== i || nums[i]==nums[nums[i]-1] )i++;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tint index= nums[i]-1; \\n\\t\\t\\t    int temp = nums[index]; \\n\\t\\t\\t\\tnums[index]= nums[i];\\n\\t\\t\\t\\tnums[i]= temp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor(int i=0 ; i<nums.length ; i++) {\\n\\t\\t\\tif(nums[i]-1!=i) {\\n\\t\\t\\t\\treturn i+1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn nums.length+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290473,
                "title": "fast-and-simple-python3-no-modification",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        visited = {n for n in nums if n > 0 and n < 100_001}\\n        smallest = 1\\n        while smallest in visited:\\n            smallest += 1\\n        return smallest\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        visited = {n for n in nums if n > 0 and n < 100_001}\\n        smallest = 1\\n        while smallest in visited:\\n            smallest += 1\\n        return smallest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3138111,
                "title": "c-beginner-friendly-small-and-readable-code-hard-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe used simple hash table to find it \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n    int p=nums.size()+1;\\n    vector<int> a(p,0);\\n    int i,j;\\n// to fill hashtable with 1\\n    for(i=0;i<nums.size();i++)\\n    {\\n        if(nums[i]>0 && nums[i]<nums.size()+1)\\n        a[nums[i]]++;\\n    }\\n    //to find the no.\\n    for(i=1;i<nums.size()+1;i++)\\n    {\\n        if(a[i]==0) return i;\\n    }\\n\\n    return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n    int p=nums.size()+1;\\n    vector<int> a(p,0);\\n    int i,j;\\n// to fill hashtable with 1\\n    for(i=0;i<nums.size();i++)\\n    {\\n        if(nums[i]>0 && nums[i]<nums.size()+1)\\n        a[nums[i]]++;\\n    }\\n    //to find the no.\\n    for(i=1;i<nums.size()+1;i++)\\n    {\\n        if(a[i]==0) return i;\\n    }\\n\\n    return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126783,
                "title": "c-solved-explained-with-o-n-time-and-uses-constant-extra-space",
                "content": "# Explanation\\nThe idea is to use the index of the array to store the value of the number in the array. For example, if the input array is [3, 4, -1, 1], we can use the index 0 to store 1, index 1 to store 2, index 2 to store 3 and so on.\\n\\nTo do this, we need to first separate the positive numbers from the negative numbers. Then, for each positive number, we use its value as the index to store its corresponding value in the array.\\n\\nAfter separating the positive numbers and rearranging the array, the first missing positive number will be the first position in the array that does not contain its corresponding value.\\n\\n# Use of Loops\\nIn the first loop, we separate the positive numbers from the negative numbers. We use while loop to swap the value of the current number with its corresponding value in the array until the current number is not in its correct position.\\n\\nIn the second loop, we find the first missing positive number. The first position in the array that does not contain its corresponding value is the first missing positive number. If all the positions contain their corresponding values, then the missing positive number is n+1.\\n\\nHere is the code in C++:\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        // separate the positive numbers from the negative numbers\\n        for (int i=0;i<n;i++) \\n            while (nums[i]>0 && nums[i]<=n && nums[nums[i]-1]!=nums[i])\\n                swap(nums[i],nums[nums[i]-1]);\\n        // find the first missing positive number\\n        for (int i=0;i<n;i++)\\n            if (nums[i]!=i+1)\\n                return i+1;\\n        return n+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        // separate the positive numbers from the negative numbers\\n        for (int i=0;i<n;i++) \\n            while (nums[i]>0 && nums[i]<=n && nums[nums[i]-1]!=nums[i])\\n                swap(nums[i],nums[nums[i]-1]);\\n        // find the first missing positive number\\n        for (int i=0;i<n;i++)\\n            if (nums[i]!=i+1)\\n                return i+1;\\n        return n+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971735,
                "title": "java-1ms-o-n-100-50mb-o-1-85-10-code-with-full-explanation-using-bits",
                "content": "Please Upvote if it helps! \\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        // O(n) time, O(1) space;\\n        int n = nums.length, size = 0;\\n        // -> Since: max(min integer not in nums ) <= n+1\\n        // -> we find the number of bits i.e. (size) of n\\n        // -> we know that no number <= n will have (size)th bit to 1\\n        // therefore we set the (size)th bit of the i to 1 if there exists\\n        // nums[j] such that nums[j] = i.\\n        // -> this set bit will be used in the final iteration as the judging criteria\\n        // -> for all values <=0 && values > n, we first partition them \\n\\t\\t//and then we set them to zero so that there does not arrive any conflict of  (size)th bit = 1 beforehand.\\n        // -> I have used zero indexing so if we have nums[j] = 1,\\n        // (size)th bit of nums[0] will be set to 1 and not of nums[1]\\n\\n        \\n        // CODE:        \\n        \\n        //calculating the variable size:\\n        while(n > 0){\\n            n = n>>1;\\n            size++;\\n        }\\n        n = nums.length;\\n        int pivot = 0;\\n        \\n        // using partitioning to partition values not to be included in the array (negatives, zeros, and values > n):\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] <= 0 || nums[i] > n){\\n                int temp = nums[i];\\n                nums[i] = nums[pivot];\\n                nums[pivot] = temp;\\n                pivot++;\\n            }\\n        }\\n        // setting all bits to zero for values not in range 1 - n:\\n        for(int i= 0; i < pivot; i++)\\n            nums[i] = 0;\\n        //setting the (size)th bit to 1 for all values in range\\n        for(int i= pivot; i < n; i++){\\n            nums[(nums[i] - 1)&((1<<size) - 1)] |= (1<<size);\\n        }\\n        //final checking condition iteration\\n        for(int i= 0; i < n; i++)\\n            if((nums[i] & (1<<size)) == 0)\\n                return i+1;\\n        //if all 1-n are present, then we return n+1\\n        return n+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        // O(n) time, O(1) space;\\n        int n = nums.length, size = 0;\\n        // -> Since: max(min integer not in nums ) <= n+1\\n        // -> we find the number of bits i.e. (size) of n\\n        // -> we know that no number <= n will have (size)th bit to 1\\n        // therefore we set the (size)th bit of the i to 1 if there exists\\n        // nums[j] such that nums[j] = i.\\n        // -> this set bit will be used in the final iteration as the judging criteria\\n        // -> for all values <=0 && values > n, we first partition them \\n\\t\\t//and then we set them to zero so that there does not arrive any conflict of  (size)th bit = 1 beforehand.\\n        // -> I have used zero indexing so if we have nums[j] = 1,\\n        // (size)th bit of nums[0] will be set to 1 and not of nums[1]\\n\\n        \\n        // CODE:        \\n        \\n        //calculating the variable size:\\n        while(n > 0){\\n            n = n>>1;\\n            size++;\\n        }\\n        n = nums.length;\\n        int pivot = 0;\\n        \\n        // using partitioning to partition values not to be included in the array (negatives, zeros, and values > n):\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] <= 0 || nums[i] > n){\\n                int temp = nums[i];\\n                nums[i] = nums[pivot];\\n                nums[pivot] = temp;\\n                pivot++;\\n            }\\n        }\\n        // setting all bits to zero for values not in range 1 - n:\\n        for(int i= 0; i < pivot; i++)\\n            nums[i] = 0;\\n        //setting the (size)th bit to 1 for all values in range\\n        for(int i= pivot; i < n; i++){\\n            nums[(nums[i] - 1)&((1<<size) - 1)] |= (1<<size);\\n        }\\n        //final checking condition iteration\\n        for(int i= 0; i < n; i++)\\n            if((nums[i] & (1<<size)) == 0)\\n                return i+1;\\n        //if all 1-n are present, then we return n+1\\n        return n+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805417,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] <= 0 or nums[i] > n) {\\n                nums[i] = n+1;\\n            }\\n        }\\n        for(int i = 0; i < n; i++) {\\n            if(abs(nums[i]) > n) continue;\\n            int id = abs(nums[i]);\\n            nums[id-1] = -1 * abs(nums[id-1]);\\n        }\\n        int ans = n + 1;\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] > 0) {\\n                ans = i+1;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }  \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] <= 0 or nums[i] > n) {\\n                nums[i] = n+1;\\n            }\\n        }\\n        for(int i = 0; i < n; i++) {\\n            if(abs(nums[i]) > n) continue;\\n            int id = abs(nums[i]);\\n            nums[id-1] = -1 * abs(nums[id-1]);\\n        }\\n        int ans = n + 1;\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] > 0) {\\n                ans = i+1;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792059,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n,,,\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint firstMissingPositive(vector<int>& nums) {\\n\\t\\t\\tint k=1;\\n\\t\\t\\tsort(nums.begin(), nums.end());\\n\\t\\t\\tfor(int i=0; i<nums.size(); i++){\\n\\t\\t\\t\\tif(k==nums[i]){\\n\\t\\t\\t\\t\\tk++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn k;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint firstMissingPositive(vector<int>& nums) {\\n\\t\\t\\tint k=1;\\n\\t\\t\\tsort(nums.begin(), nums.end());\\n\\t\\t\\tfor(int i=0; i<nums.size(); i++){\\n\\t\\t\\t\\tif(k==nums[i]){\\n\\t\\t\\t\\t\\tk++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2649319,
                "title": "javascript-fully-explained-solution-with-o-1-space-and-o-n-time-and-faster-than-99-submissions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar firstMissingPositive = function(nums) {\\n    // In this approach we will loop through array and if we find element is in\\n    // range (1 to n) then swap the elemnt with index equal to its value-1.\\n    // example--> if 2 is element then swap 2 with index 2-1 or(1)\\'s value . Notice that if \\n    //another duplicate 2 is already present at index then no need to swap.\\n    let n=nums.length;\\n    let index;\\n    let element;\\n    let temp;\\n    // run a loop through the given array\\n    for(let i=0;i<n;i++){\\n        // if element is from 1 to n.\\n        if(nums[i]>=1 && nums[i]<=n){\\n            element=nums[i];\\n            index=element-1;\\n            // if element is not at correct index swap it.\\n            if(nums[index]!=element){\\n                   temp=nums[index];\\n                   nums[index]=element;\\n                   nums[i]=temp;\\n                   i--;\\n            }\\n        }\\n    }\\n\\n    // run a loop and find if index i has value=i+1. if not return i+1(because it will\\n    // be the first missing positive number)\\n    for(let i=0;i<n;i++){\\n        if(nums[i]!=i+1){\\n            return i+1;\\n        }\\n    }\\n\\n    // if all elements are found till length of array then return length+1.\\n    return n+1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar firstMissingPositive = function(nums) {\\n    // In this approach we will loop through array and if we find element is in\\n    // range (1 to n) then swap the elemnt with index equal to its value-1.\\n    // example--> if 2 is element then swap 2 with index 2-1 or(1)\\'s value . Notice that if \\n    //another duplicate 2 is already present at index then no need to swap.\\n    let n=nums.length;\\n    let index;\\n    let element;\\n    let temp;\\n    // run a loop through the given array\\n    for(let i=0;i<n;i++){\\n        // if element is from 1 to n.\\n        if(nums[i]>=1 && nums[i]<=n){\\n            element=nums[i];\\n            index=element-1;\\n            // if element is not at correct index swap it.\\n            if(nums[index]!=element){\\n                   temp=nums[index];\\n                   nums[index]=element;\\n                   nums[i]=temp;\\n                   i--;\\n            }\\n        }\\n    }\\n\\n    // run a loop and find if index i has value=i+1. if not return i+1(because it will\\n    // be the first missing positive number)\\n    for(let i=0;i<n;i++){\\n        if(nums[i]!=i+1){\\n            return i+1;\\n        }\\n    }\\n\\n    // if all elements are found till length of array then return length+1.\\n    return n+1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2391396,
                "title": "c-o-n-and-o-1-with-detail-explanation",
                "content": "\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        /*\\n            1. reorder nums to keep 1 in index 1, 2 in index 2 ... \\n                 3,4,-1,1 -> 1,-1,3,4\\n                 1,2,0 -> 1,2,0\\n                 7,8,9,11,12 -> 7,8,9,11,12\\n                algorithm: keep swapping if num in [1, N], if the two nums doesn\\'t equal\\n            2. the one missing in expected place is the missing one\\n        */\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            while (nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1] ) {\\n                swap(nums[nums[i] - 1], nums[i]);\\n            } \\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] != i + 1)\\n                return i + 1;\\n        }\\n        // if it is already ordered, e.g. [1,2], [1], [1,2,3]\\n        return n + 1;\\n        \\n    }\\n};\\n```\\n\\nTime: O(n)\\n\\nSpace: O(1)",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        /*\\n            1. reorder nums to keep 1 in index 1, 2 in index 2 ... \\n                 3,4,-1,1 -> 1,-1,3,4\\n                 1,2,0 -> 1,2,0\\n                 7,8,9,11,12 -> 7,8,9,11,12\\n                algorithm: keep swapping if num in [1, N], if the two nums doesn\\'t equal\\n            2. the one missing in expected place is the missing one\\n        */\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            while (nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1] ) {\\n                swap(nums[nums[i] - 1], nums[i]);\\n            } \\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] != i + 1)\\n                return i + 1;\\n        }\\n        // if it is already ordered, e.g. [1,2], [1], [1,2,3]\\n        return n + 1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2289046,
                "title": "explanation-for-o-n-time-and-o-1-space-complexity-solution-c",
                "content": "Firstly, we need to understand that **answer is going to lie among the first n + 1 positive integers**: \\nReason: \\nThe array can have at most n unique positive integers. Now if any of the positive numbers in the range [1, n] are missing in the array then our answer will be the smallest of those. In case all the integers in the range [1, n] are present, then the array has all its indices filled with the integers in the range[1, n] and so the answer will be n + 1.\\n\\nNow I think the easiest approach to come up with is to use a HashMap or HashSet to store the elements of the array and then check for the first n + 1 integers if they are present or not. Even though this approach is O(n) in time, it is pretty slow, because of the time it takes for the hashing operation. Also, the space complexity of the solution is O(n). As clearly mentioned in the problem statement, we can do better. \\n\\nThe main idea of the above approach was to somehow distinguish between the numbers that are present in the array vs the numbers that are not present in the array.\\n\\nWe can still use the same idea but implement it in a better way. \\n\\nFor every element in the array, if it is in not in the range[1, n] we can replace it with n + 2, since these numbers don\\'t really matter. \\nNow the array consists of elements that are either in the range [1, n] or n + 2.\\nFor every element in the array that is in the range [1, n], we can make the element in the array at (position = element - 1) negative\\ni.e. make sure that arr[arr[i] - 1] is negative for every i such that arr[i] belongs to [1, n].\\nthis way we would be able to distinguish between elements that are present in the array ( as for x, in range [1, n] if it is present in the array then arr[x - 1] would be negative, otherwise it will be positive), vs the numbers that are not present in the array. We can then loop from 1 to n, and then check if the corresponding index is negative or positive to check if the element exists in the array.\\n\\nMy Code:\\n```cpp\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i = 0; i < n; ++i)\\n            if(nums[i] <= 0 || nums[i] > n)\\n                nums[i] = n + 2;\\n        for(int i = 0; i < n; ++i){\\n            if(abs(nums[i]) == n + 2)\\n                continue;\\n            if(nums[abs(nums[i]) - 1] > 0)\\n                nums[abs(nums[i]) - 1] *= -1;\\n        }\\n        for(int i = 0; i < n; ++i){\\n            if(nums[i] > 0)\\n                return i + 1;\\n        }\\n        return n + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i = 0; i < n; ++i)\\n            if(nums[i] <= 0 || nums[i] > n)\\n                nums[i] = n + 2;\\n        for(int i = 0; i < n; ++i){\\n            if(abs(nums[i]) == n + 2)\\n                continue;\\n            if(nums[abs(nums[i]) - 1] > 0)\\n                nums[abs(nums[i]) - 1] *= -1;\\n        }\\n        for(int i = 0; i < n; ++i){\\n            if(nums[i] > 0)\\n                return i + 1;\\n        }\\n        return n + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2232826,
                "title": "c-2-easiest-approaches-tc-o-n-space-o-1-easy-problem",
                "content": "**Approach 1**\\nTime complexity : **`O(N)`**\\nSpace Complexity : **`O(1)`**\\n\\n----\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // Cyclic sort \\n    // Arr :      [1,2,3,4,5,6] \\n    // indices :  [0,1,2,3,4,5]   arr[i] == i+1               \\n    int firstMissingPositive(vector<int>&nums) \\n    {\\n        int i = 0;\\n        int n = nums.size();\\n        while(i < n)\\n        {\\n            if(nums[i] > 0 and nums[i] <= n && nums[i] != nums[nums[i] - 1]){\\n                swap(nums,i,nums[i] - 1);\\n            }\\n            else\\n                i++;\\n        }\\n        \\n        for(i=0;i<n;i++){\\n            if(nums[i] != i + 1){\\n                return (i + 1); // missing positive number \\n            }\\n        }\\n        return n + 1; // [1,2,3] , ans  = 4 (missing positive integers)\\n    }\\n    \\n    void swap(vector<int>&nums, int i, int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n};\\n```\\n\\n\\n**Approach 2** \\nTime complexity : **`O(N)`**\\nSpace Complexity : **`O(N)`**\\n\\n----\\n```\\nclass Solution {\\npublic:\\n    \\n    int firstMissingPositive(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        vector<bool>res(n+1, 0);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i] > 0 and nums[i] <= n) // positive number inside the range 0 to n\\n            {\\n                res[nums[i]] = true;\\n            }   \\n        }\\n        \\n        // Indices start from 0 to n-1\\n        //  Number start from 1 to n\\n        for(int i=1;i<res.size();i++)\\n        {\\n            if(!res[i])  // first positive number that is false\\n                return i;\\n        }\\n        return (n+1);\\n    }\\n};\\n```\\n*Thanks for upvoting !*\\n\\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // Cyclic sort \\n    // Arr :      [1,2,3,4,5,6] \\n    // indices :  [0,1,2,3,4,5]   arr[i] == i+1               \\n    int firstMissingPositive(vector<int>&nums) \\n    {\\n        int i = 0;\\n        int n = nums.size();\\n        while(i < n)\\n        {\\n            if(nums[i] > 0 and nums[i] <= n && nums[i] != nums[nums[i] - 1]){\\n                swap(nums,i,nums[i] - 1);\\n            }\\n            else\\n                i++;\\n        }\\n        \\n        for(i=0;i<n;i++){\\n            if(nums[i] != i + 1){\\n                return (i + 1); // missing positive number \\n            }\\n        }\\n        return n + 1; // [1,2,3] , ans  = 4 (missing positive integers)\\n    }\\n    \\n    void swap(vector<int>&nums, int i, int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int firstMissingPositive(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        vector<bool>res(n+1, 0);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i] > 0 and nums[i] <= n) // positive number inside the range 0 to n\\n            {\\n                res[nums[i]] = true;\\n            }   \\n        }\\n        \\n        // Indices start from 0 to n-1\\n        //  Number start from 1 to n\\n        for(int i=1;i<res.size();i++)\\n        {\\n            if(!res[i])  // first positive number that is false\\n                return i;\\n        }\\n        return (n+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2075835,
                "title": "cpp-fully-explained-o-1-space-o-n-time-70-faster-solution",
                "content": "```\\nEXPLANATION :\\n    \\n1) I just tried to put every number num: from 1-N, in the (num-1)th position.\\n2) So I just stored the arr[i] in the variable \\'in\\' and swapped arr[in-1] with arr[i].\\n3) Swapped it until I got repetations or arr[i]<=0 or arr[i]>n.\\n4) Did this for every number in the array.\\n5) After that just checked for the number which is not in the (num-1)th position\\n6) If no such number found that simply mean that Every number from 1-N are present in it\\'s position, so return N+1\\n\\nCOMPLEXITY ANALYSIS:\\nTIME: O(N) ,  SPACE: O(1)\\n    \\n    \\nKINDLY DO UPVOTE IF YOU UNDERSTAND MY SOLUTION\\nCOMMENT DOWN IF YOU HAVE ANY DOUBT\\n\\n\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int firstMissingPositive(vector<int>& arr) {\\n        ll n=arr.size();\\n        for(ll i=0;i<n;i++){\\n            ll in=-1;\\n            while(1){\\n                if((ll)arr[i]-1==in || arr[i]>n || arr[i]<=0) break;\\n                in=arr[i]-1;\\n                swap(arr[i],arr[in]);\\n            }\\n        }\\n        for(ll i=0;i<n;i++){\\n            if((ll)arr[i]-1!=i) return (int)i+1;\\n        }\\n        return (int)n+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nEXPLANATION :\\n    \\n1) I just tried to put every number num: from 1-N, in the (num-1)th position.\\n2) So I just stored the arr[i] in the variable \\'in\\' and swapped arr[in-1] with arr[i].\\n3) Swapped it until I got repetations or arr[i]<=0 or arr[i]>n.\\n4) Did this for every number in the array.\\n5) After that just checked for the number which is not in the (num-1)th position\\n6) If no such number found that simply mean that Every number from 1-N are present in it\\'s position, so return N+1\\n\\nCOMPLEXITY ANALYSIS:\\nTIME: O(N) ,  SPACE: O(1)\\n    \\n    \\nKINDLY DO UPVOTE IF YOU UNDERSTAND MY SOLUTION\\nCOMMENT DOWN IF YOU HAVE ANY DOUBT\\n\\n\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int firstMissingPositive(vector<int>& arr) {\\n        ll n=arr.size();\\n        for(ll i=0;i<n;i++){\\n            ll in=-1;\\n            while(1){\\n                if((ll)arr[i]-1==in || arr[i]>n || arr[i]<=0) break;\\n                in=arr[i]-1;\\n                swap(arr[i],arr[in]);\\n            }\\n        }\\n        for(ll i=0;i<n;i++){\\n            if((ll)arr[i]-1!=i) return (int)i+1;\\n        }\\n        return (int)n+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2014426,
                "title": "very-clearly-explained-solution-in-python-easy-to-understand",
                "content": "A problem requiring O(n) time and constant extra space, **really hard**!\\n\\nUse the original **input list to work as a hashmap**!\\nWe will let:\\n**mark the value of that index as negative** <=> **mark that index as visited**\\n\\nI will **explain step by step** using an example:\\n[3 4 -1 1]\\n\\n**1. First**, we should know that the first missing positive should be **at most len(list) + 1**,\\n(for example, input list:[1 2 3 4], first missing positive is 5).\\n\\n**2. In the first loop** of the array list, we let number that are not in the range 1:n be n + 1.\\nIn the example:\\n[3 4 -1 1] -> [3 4 5 1]\\n\\n**3. In the second loop**, for every number, if its original value is not equal to n + 1, make it opposite.\\nIn the example:\\n[3 4 5 1]\\n-> [3 4 -5 1] (integer 3 exists, value of index 2 negative)\\n-> [3 4 -5 -1] (integer 4 exists, value of index 3 negative)\\n-> [3 4 -5 -1] (integer 5 equals n + 1, continue)\\n-> [-3 4 -5 -1] (integer 1 exists, value of index 0 negative)\\n\\n**4. In the last loop**, find the first index whose value is positive.\\n\\n**TIme:** O(n)\\n**Space:** O(1)\\n\\n```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)\\n        \\n        for i in range(n):\\n            if nums[i] <= 0 or nums[i] > n:\\n                nums[i] = n + 1\\n        \\n        for i in range(n): \\n            a = abs(nums[i])\\n\\n            if a == n + 1:\\n                continue\\n            \\n            nums[a - 1] = - abs(nums[a - 1])\\n            \\n        for i in range(n):\\n            if nums[i] > 0:\\n                return i + 1\\n            \\n        return n + 1\\n```",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)\\n        \\n        for i in range(n):\\n            if nums[i] <= 0 or nums[i] > n:\\n                nums[i] = n + 1\\n        \\n        for i in range(n): \\n            a = abs(nums[i])\\n\\n            if a == n + 1:\\n                continue\\n            \\n            nums[a - 1] = - abs(nums[a - 1])\\n            \\n        for i in range(n):\\n            if nums[i] > 0:\\n                return i + 1\\n            \\n        return n + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1903797,
                "title": "java-solution-with-comment",
                "content": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int i =0 ;\\n       int i =0 ;\\n        while(i<nums.length)\\n        //nums[i] <nums.length with this we ignore arrayIndexBound error\\n            //nums[i] != nums[nums[i]-1] with this duplicacy is removed\\n        {\\n            if (nums[i] > 0 && nums[i] <nums.length && nums[i] != nums[nums[i]-1] )\\n                swap(nums, i , nums[i]-1);\\n            else\\n                i++;\\n        }\\n        for( i =0; i<nums.length; i++)\\n        {\\n            if (nums[i] != i+1 )\\n               return i+1;\\n        }\\n        return nums.length+1;\\n    }\\n    public  void swap (int nums[], int i , int j){\\n      int  temp =  nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int i =0 ;\\n       int i =0 ;\\n        while(i<nums.length)\\n        //nums[i] <nums.length with this we ignore arrayIndexBound error\\n            //nums[i] != nums[nums[i]-1] with this duplicacy is removed\\n        {\\n            if (nums[i] > 0 && nums[i] <nums.length && nums[i] != nums[nums[i]-1] )\\n                swap(nums, i , nums[i]-1);\\n            else\\n                i++;\\n        }\\n        for( i =0; i<nums.length; i++)\\n        {\\n            if (nums[i] != i+1 )\\n               return i+1;\\n        }\\n        return nums.length+1;\\n    }\\n    public  void swap (int nums[], int i , int j){\\n      int  temp =  nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1789620,
                "title": "java-cyclic-sorting-easy-understanding",
                "content": "## **Please upvote if you understood it (\\u301C\\uFFE3\\u25BD\\uFFE3)\\u301C**\\n----\\n-----\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        for(int i=0;i<nums.length;){\\n            if(nums[i]>0 && nums[i]<nums.length && nums[i]!=nums[nums[i]-1]){\\n                swap(nums,i,nums[i]-1);\\n            }\\n            else i++;\\n        }\\n        \\n        if(nums[0]>1) return 1;\\n        \\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]!=i+1){\\n                return i+1;\\n            }\\n        }\\n        \\n        return nums.length+1;\\n    }\\n    \\n    \\n    public void swap(int[] nums, int first, int second){\\n        int temp = nums[first];\\n        nums[first] = nums[second];\\n        nums[second] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        for(int i=0;i<nums.length;){\\n            if(nums[i]>0 && nums[i]<nums.length && nums[i]!=nums[nums[i]-1]){\\n                swap(nums,i,nums[i]-1);\\n            }\\n            else i++;\\n        }\\n        \\n        if(nums[0]>1) return 1;\\n        \\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]!=i+1){\\n                return i+1;\\n            }\\n        }\\n        \\n        return nums.length+1;\\n    }\\n    \\n    \\n    public void swap(int[] nums, int first, int second){\\n        int temp = nums[first];\\n        nums[first] = nums[second];\\n        nums[second] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1692023,
                "title": "c-o-n-time-o-1-space-solution-with-explanation",
                "content": "Not correct solution but for understanding the concept\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        // intution\\n        // create a visited array of size n = nums.size()\\n        // mark whatever has been seen\\n        // once whole array is marked iterate and check\\n        // what is absent\\n        // return that\\n        // if nothing is absent return n+1\\n        // this will take O(n) space in extra\\n        // we will obtimise it later\\n        int n = nums.size();\\n        vector<bool> visited(n);\\n        \\n        //marking the exisitng numbers\\n        for (int i = 0; i < n; i++){\\n            if (nums[i] > 0 && nums[i] <= n) {\\n                // numbers are from 1 to ..\\n                // indexes to mark are from 0\\n                // so mark number i at i-1 \\n                // e.g mark 5 at index 4\\n                visited[i-1] = true;\\n            }\\n        }\\n        \\n        // cheking what was not present\\n        for(int i = 0; i < n; i++) {\\n            if(!visited[i]) \\n                return i+1;\\n        }\\n        \\n        // everything was present\\n        return n+1;\\n    }\\n};\\n```\\n\\nCorrect solution\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        // now we cant use viisited array\\n        // so we need to mark that we have seen a number between 1 to n in nums itself\\n        // we have to do this without distroying any needed info in nums\\n        \\n        // idea\\n        // we dont need any negative number or 0\\n        // convert them to any number which we are sure will not be out answer\\n        // say intmax\\n        \\n        // now wenever we get any number betwen 1 to n\\n        // we can change the number at that index to its negative\\n        // this will help us store both info\\n        // the value will give us the value in the array\\n        // while the -ve sign will say that the idx+1 was present in the array\\n        int n = nums.size();\\n        \\n        \\n        \\n        //chnage all non positive to intmax or anything greater than n\\n        for (int i = 0; i < n; i++){\\n            if (nums[i] <= 0 ) {\\n               nums[i] = INT_MAX;\\n            }\\n        }\\n        \\n        //mark\\n        for (int i = 0; i < n; i++){\\n            // retrive the number\\n            // convert is to positive if it was negative\\n            // as negative was only used for marking\\n            int val = nums[i] > 0 ? nums[i] : -nums[i];\\n            if(val > 0 && val <= n){\\n                // got a number between 1 to n\\n                \\n                // check if it is already marked at index val-1\\n                // if its negative its marked\\n                // if its postive mark by changing it to negative\\n                if(nums[val-1] > 0) nums[val-1] *= -1;\\n                \\n            }\\n        }\\n        \\n        // check what was absent\\n        for (int i = 0; i < n; i++){\\n            if(nums[i] > 0) return i+1;\\n        }\\n        \\n        // everything was marked\\n        return n+1;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        // intution\\n        // create a visited array of size n = nums.size()\\n        // mark whatever has been seen\\n        // once whole array is marked iterate and check\\n        // what is absent\\n        // return that\\n        // if nothing is absent return n+1\\n        // this will take O(n) space in extra\\n        // we will obtimise it later\\n        int n = nums.size();\\n        vector<bool> visited(n);\\n        \\n        //marking the exisitng numbers\\n        for (int i = 0; i < n; i++){\\n            if (nums[i] > 0 && nums[i] <= n) {\\n                // numbers are from 1 to ..\\n                // indexes to mark are from 0\\n                // so mark number i at i-1 \\n                // e.g mark 5 at index 4\\n                visited[i-1] = true;\\n            }\\n        }\\n        \\n        // cheking what was not present\\n        for(int i = 0; i < n; i++) {\\n            if(!visited[i]) \\n                return i+1;\\n        }\\n        \\n        // everything was present\\n        return n+1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        // now we cant use viisited array\\n        // so we need to mark that we have seen a number between 1 to n in nums itself\\n        // we have to do this without distroying any needed info in nums\\n        \\n        // idea\\n        // we dont need any negative number or 0\\n        // convert them to any number which we are sure will not be out answer\\n        // say intmax\\n        \\n        // now wenever we get any number betwen 1 to n\\n        // we can change the number at that index to its negative\\n        // this will help us store both info\\n        // the value will give us the value in the array\\n        // while the -ve sign will say that the idx+1 was present in the array\\n        int n = nums.size();\\n        \\n        \\n        \\n        //chnage all non positive to intmax or anything greater than n\\n        for (int i = 0; i < n; i++){\\n            if (nums[i] <= 0 ) {\\n               nums[i] = INT_MAX;\\n            }\\n        }\\n        \\n        //mark\\n        for (int i = 0; i < n; i++){\\n            // retrive the number\\n            // convert is to positive if it was negative\\n            // as negative was only used for marking\\n            int val = nums[i] > 0 ? nums[i] : -nums[i];\\n            if(val > 0 && val <= n){\\n                // got a number between 1 to n\\n                \\n                // check if it is already marked at index val-1\\n                // if its negative its marked\\n                // if its postive mark by changing it to negative\\n                if(nums[val-1] > 0) nums[val-1] *= -1;\\n                \\n            }\\n        }\\n        \\n        // check what was absent\\n        for (int i = 0; i < n; i++){\\n            if(nums[i] > 0) return i+1;\\n        }\\n        \\n        // everything was marked\\n        return n+1;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1669736,
                "title": "solution-with-explaination",
                "content": "Solution Approach- Try placing the number at position where index and value can be equal. such that i= nums[i]-1 (zero based index)\\n```\\n// Time-O(N), Space-O(1)\\n\\tpublic static int firstMissingPositive(int[] nums) {\\n\\t\\tif (nums == null || nums.length == 0) {\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\n\\t\\tint n = nums.length;\\n\\t\\tint i = 0;\\n\\t\\twhile (i < n) {\\n\\t\\t\\t// if number is either less than 1 or already at the right position skip it\\n\\t\\t\\tif (nums[i] < 1 || nums[i] == i + 1) {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// don\\'t increment i here, we can compare again after its value is updated\\n\\t\\t\\t\\t// if number is beyond array size then change to out of range (-1)\\n\\t\\t\\t\\tif (nums[i] > n) {\\n\\t\\t\\t\\t\\tnums[i] = -1;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// number being swapped already matches, don\\'t swap to avoid infinite loops [1,1]\\n\\t\\t\\t\\t\\tif (nums[i] == nums[nums[i] - 1]) {\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t// swap to make sure value of nums[i] can be placed to its desired position (if value is 4, place it at the 4th index- i=3)\\n\\t\\t\\t\\t\\t\\tint temp = nums[nums[i] - 1];\\n\\t\\t\\t\\t\\t\\tnums[nums[i] - 1] = nums[i];\\n\\t\\t\\t\\t\\t\\tnums[i] = temp;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// scan to see if number is not at its desired position, that position is the result\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tif (nums[j] != j + 1) {\\n\\t\\t\\t\\treturn j + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// if every number is at its desired position then size+1 is the answer\\n\\t\\treturn n + 1;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n// Time-O(N), Space-O(1)\\n\\tpublic static int firstMissingPositive(int[] nums) {\\n\\t\\tif (nums == null || nums.length == 0) {\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\n\\t\\tint n = nums.length;\\n\\t\\tint i = 0;\\n\\t\\twhile (i < n) {\\n\\t\\t\\t// if number is either less than 1 or already at the right position skip it\\n\\t\\t\\tif (nums[i] < 1 || nums[i] == i + 1) {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// don\\'t increment i here, we can compare again after its value is updated\\n\\t\\t\\t\\t// if number is beyond array size then change to out of range (-1)\\n\\t\\t\\t\\tif (nums[i] > n) {\\n\\t\\t\\t\\t\\tnums[i] = -1;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// number being swapped already matches, don\\'t swap to avoid infinite loops [1,1]\\n\\t\\t\\t\\t\\tif (nums[i] == nums[nums[i] - 1]) {\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t// swap to make sure value of nums[i] can be placed to its desired position (if value is 4, place it at the 4th index- i=3)\\n\\t\\t\\t\\t\\t\\tint temp = nums[nums[i] - 1];\\n\\t\\t\\t\\t\\t\\tnums[nums[i] - 1] = nums[i];\\n\\t\\t\\t\\t\\t\\tnums[i] = temp;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// scan to see if number is not at its desired position, that position is the result\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tif (nums[j] != j + 1) {\\n\\t\\t\\t\\treturn j + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// if every number is at its desired position then size+1 is the answer\\n\\t\\treturn n + 1;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1631318,
                "title": "optimal-and-intuitive-solution-with-explanation-tc-o-n-sc-o-1",
                "content": "Ignore all the elements not in the range 1 to size (include only 1<= element <= size )\\nPlace the element at it\\'s index value ( arr[arr[i] - 1] = arr[i]) ( in zero based index)\\nfor instance  index for 1 is 0, 2 is 1, 3 is 2 and so on.\\n\\n``` arr = [3, 4, -1, 1, 7] ```\\n```\\n\\tplace 3 at index (3 - 1) = 2 i.e at index 2\\n    place 4 at index (4 - 1) = 3\\n    place 1 at index (1 - 1) = 0 \\n\\t\\n\\tsince -1 and 7 are not in the range 1 to size \\n\\tso ignore these elements\\n```\\nIf duplicate elements exist, then no need to place the duplicate element at its correct index as the  elements is already placed at its correct index.\\n\\n\\n\\n```\\n\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int size = nums.length;\\n        for(int i = 0; i < size; i++){\\n            while((nums[i] >= 1 && nums[i] <= size) && (nums[nums[i] - 1] != nums[i])){\\n                int temp = nums[nums[i] - 1];\\n                nums[nums[i] - 1] = nums[i];\\n                nums[i] = temp;\\n            }\\n        }\\n        \\n        for(int i = 0; i < size; i++){\\n            if(nums[i] != i + 1)\\n                return i + 1;\\n        }\\n     return size + 1;   \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "``` arr = [3, 4, -1, 1, 7] ```\n```\\n\\tplace 3 at index (3 - 1) = 2 i.e at index 2\\n    place 4 at index (4 - 1) = 3\\n    place 1 at index (1 - 1) = 0 \\n\\t\\n\\tsince -1 and 7 are not in the range 1 to size \\n\\tso ignore these elements\\n```\n```\\n\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int size = nums.length;\\n        for(int i = 0; i < size; i++){\\n            while((nums[i] >= 1 && nums[i] <= size) && (nums[nums[i] - 1] != nums[i])){\\n                int temp = nums[nums[i] - 1];\\n                nums[nums[i] - 1] = nums[i];\\n                nums[i] = temp;\\n            }\\n        }\\n        \\n        for(int i = 0; i < size; i++){\\n            if(nums[i] != i + 1)\\n                return i + 1;\\n        }\\n     return size + 1;   \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1606058,
                "title": "c-index-marking-fast-easy-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        // we convert all the numbers except 1to n into n+1 as they won\\'t give potential answer.\\n        int n = nums.size();\\n        for(int i =0;i<n;i++){\\n            if(nums[i]<=0){\\n                nums[i] = n+1;\\n            }\\n        }\\n        for(int i=0; i<n;i++){\\n            int temp = abs(nums[i]);\\n            //if there is any number in ranger 1to n , its index in 0 based array will get marked negative. \\n            if(temp<n+1){\\n                nums[temp-1] = -abs(nums[temp-1]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            // the first positive index+1 will give us result(if there was any element in array was not present\\n            //in the range of 1ton, otherwise we return n+1)\\n            if(nums[i]>0){\\n                return i+1;\\n            }\\n        }\\n        return n+1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        // we convert all the numbers except 1to n into n+1 as they won\\'t give potential answer.\\n        int n = nums.size();\\n        for(int i =0;i<n;i++){\\n            if(nums[i]<=0){\\n                nums[i] = n+1;\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564577,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1568115,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1565259,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1565425,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1567177,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1570529,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1565938,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1568865,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1571103,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1778745,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1564577,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1568115,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1565259,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1565425,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1567177,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1570529,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1565938,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1568865,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1571103,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1778745,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1572795,
                "content": [
                    {
                        "username": "isgulkov",
                        "content": "So I\\'ve just wasted a good couple of hours trying to find a solution that would, and I quote, \"*run in O(n) time and use constant extra space*\".\\n\\nThe *no negatives* case of this is itself not too obvious: you just use the signs (basically, unused bits) to store what you need, then clean up after yourself \\u2014 pretty neat. How do you do this with negative numbers, though? I don\\'t know! Maybe there *is* some clever way to do this, but it doesn\\'t seem likely.\\n\\nOne way ot the other, none of the solutions I\\'ve found to this \\u2014 neither on this forum nor through Google \\u2014 actually solve the problem as stated. They just leave the array modified in one way or another!\\n\\nSee, unless you\\'re using some quite peculiar definition of space complexity, if the input array is left modified modified, you\\'re actually **using** it as extra space for your algorithm, which makes its space complexity O(n). You might as well allocate a second array of booleans like any sane person would in this case.\\n\\nOr is there an actual O(1) space solution for this? If so, I\\'d really like to see it!"
                    },
                    {
                        "username": "0ca6ra",
                        "content": "nowhere in the description of the problem it is mentioned that the positive integers in the integer array should be >= 1 and <= n. it seems that all solutions provided made that assumption. if this is the case, the description should be updated."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My second hard which I solved on my own without looking at hints or solution ! <33"
                    },
                    {
                        "username": "piyushmorey626",
                        "content": "The first missing number always lies between the range of [1, n+1], where \\'n\\' represents the length of the array. This observation simplifies the problem-solving process. "
                    },
                    {
                        "username": "tunstals",
                        "content": "Some of the solutions I\\'ve seen posted here are using sets or lists to sort the unsorted array parameter, then iterating through the sorted result.\\n\\nSurely this can\\'t be O(N) as the sort algorithm implementation will use a loop itself, then the solution code will use a loop to find the smallest value?  So this would be O(N*2)\\n\\nAm I missing something here?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "That sorting can also get completed in O(n log n)\\n"
                    },
                    {
                        "username": "m13d",
                        "content": "So pretty quickliy I came up with a solution similiar to many of the others here, using a set, or hashmap, to keep track of the numebrs seen. But that\\'s not using constant space. After a bit, I gave in, and looked at the solution. With out giving to much away, it suggests doing something you should never do in real code: modifing the input array!"
                    },
                    {
                        "username": "XuWang77",
                        "content": "\\'\\'\\'\\nreturn(sorted(list(set(range(1,max(nums)+2)) - set(nums)))[0] if nums else 1)\\n\\'\\'\\'"
                    },
                    {
                        "username": "garyfu",
                        "content": "Sorting the array makes the runtime at least O(n*log(n)).\nAlso, creating a extra sets violates the constant extra memory constraint."
                    },
                    {
                        "username": "pilch",
                        "content": "I find the wording confusing, since usually constant space does mean that your algorithm is not allowed to use space quantity that depends on the size of the input. When modifying the input, we allow the algorithm to use up to O(n) space.\\nI suggest the wording should precise that we are allowed to modify the input array."
                    },
                    {
                        "username": "makeittrue",
                        "content": "like putting interger into the i-th element of the array"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "This is a hard question because of the space constraint. Otherwise, it is an easy."
                    },
                    {
                        "username": "Husoski",
                        "content": "The hard part for me was ignoring (what used to be?) good software engineering practice and treating a reference argument as working storage."
                    }
                ]
            },
            {
                "id": 1571099,
                "content": [
                    {
                        "username": "isgulkov",
                        "content": "So I\\'ve just wasted a good couple of hours trying to find a solution that would, and I quote, \"*run in O(n) time and use constant extra space*\".\\n\\nThe *no negatives* case of this is itself not too obvious: you just use the signs (basically, unused bits) to store what you need, then clean up after yourself \\u2014 pretty neat. How do you do this with negative numbers, though? I don\\'t know! Maybe there *is* some clever way to do this, but it doesn\\'t seem likely.\\n\\nOne way ot the other, none of the solutions I\\'ve found to this \\u2014 neither on this forum nor through Google \\u2014 actually solve the problem as stated. They just leave the array modified in one way or another!\\n\\nSee, unless you\\'re using some quite peculiar definition of space complexity, if the input array is left modified modified, you\\'re actually **using** it as extra space for your algorithm, which makes its space complexity O(n). You might as well allocate a second array of booleans like any sane person would in this case.\\n\\nOr is there an actual O(1) space solution for this? If so, I\\'d really like to see it!"
                    },
                    {
                        "username": "0ca6ra",
                        "content": "nowhere in the description of the problem it is mentioned that the positive integers in the integer array should be >= 1 and <= n. it seems that all solutions provided made that assumption. if this is the case, the description should be updated."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My second hard which I solved on my own without looking at hints or solution ! <33"
                    },
                    {
                        "username": "piyushmorey626",
                        "content": "The first missing number always lies between the range of [1, n+1], where \\'n\\' represents the length of the array. This observation simplifies the problem-solving process. "
                    },
                    {
                        "username": "tunstals",
                        "content": "Some of the solutions I\\'ve seen posted here are using sets or lists to sort the unsorted array parameter, then iterating through the sorted result.\\n\\nSurely this can\\'t be O(N) as the sort algorithm implementation will use a loop itself, then the solution code will use a loop to find the smallest value?  So this would be O(N*2)\\n\\nAm I missing something here?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "That sorting can also get completed in O(n log n)\\n"
                    },
                    {
                        "username": "m13d",
                        "content": "So pretty quickliy I came up with a solution similiar to many of the others here, using a set, or hashmap, to keep track of the numebrs seen. But that\\'s not using constant space. After a bit, I gave in, and looked at the solution. With out giving to much away, it suggests doing something you should never do in real code: modifing the input array!"
                    },
                    {
                        "username": "XuWang77",
                        "content": "\\'\\'\\'\\nreturn(sorted(list(set(range(1,max(nums)+2)) - set(nums)))[0] if nums else 1)\\n\\'\\'\\'"
                    },
                    {
                        "username": "garyfu",
                        "content": "Sorting the array makes the runtime at least O(n*log(n)).\nAlso, creating a extra sets violates the constant extra memory constraint."
                    },
                    {
                        "username": "pilch",
                        "content": "I find the wording confusing, since usually constant space does mean that your algorithm is not allowed to use space quantity that depends on the size of the input. When modifying the input, we allow the algorithm to use up to O(n) space.\\nI suggest the wording should precise that we are allowed to modify the input array."
                    },
                    {
                        "username": "makeittrue",
                        "content": "like putting interger into the i-th element of the array"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "This is a hard question because of the space constraint. Otherwise, it is an easy."
                    },
                    {
                        "username": "Husoski",
                        "content": "The hard part for me was ignoring (what used to be?) good software engineering practice and treating a reference argument as working storage."
                    }
                ]
            },
            {
                "id": 2041972,
                "content": [
                    {
                        "username": "isgulkov",
                        "content": "So I\\'ve just wasted a good couple of hours trying to find a solution that would, and I quote, \"*run in O(n) time and use constant extra space*\".\\n\\nThe *no negatives* case of this is itself not too obvious: you just use the signs (basically, unused bits) to store what you need, then clean up after yourself \\u2014 pretty neat. How do you do this with negative numbers, though? I don\\'t know! Maybe there *is* some clever way to do this, but it doesn\\'t seem likely.\\n\\nOne way ot the other, none of the solutions I\\'ve found to this \\u2014 neither on this forum nor through Google \\u2014 actually solve the problem as stated. They just leave the array modified in one way or another!\\n\\nSee, unless you\\'re using some quite peculiar definition of space complexity, if the input array is left modified modified, you\\'re actually **using** it as extra space for your algorithm, which makes its space complexity O(n). You might as well allocate a second array of booleans like any sane person would in this case.\\n\\nOr is there an actual O(1) space solution for this? If so, I\\'d really like to see it!"
                    },
                    {
                        "username": "0ca6ra",
                        "content": "nowhere in the description of the problem it is mentioned that the positive integers in the integer array should be >= 1 and <= n. it seems that all solutions provided made that assumption. if this is the case, the description should be updated."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My second hard which I solved on my own without looking at hints or solution ! <33"
                    },
                    {
                        "username": "piyushmorey626",
                        "content": "The first missing number always lies between the range of [1, n+1], where \\'n\\' represents the length of the array. This observation simplifies the problem-solving process. "
                    },
                    {
                        "username": "tunstals",
                        "content": "Some of the solutions I\\'ve seen posted here are using sets or lists to sort the unsorted array parameter, then iterating through the sorted result.\\n\\nSurely this can\\'t be O(N) as the sort algorithm implementation will use a loop itself, then the solution code will use a loop to find the smallest value?  So this would be O(N*2)\\n\\nAm I missing something here?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "That sorting can also get completed in O(n log n)\\n"
                    },
                    {
                        "username": "m13d",
                        "content": "So pretty quickliy I came up with a solution similiar to many of the others here, using a set, or hashmap, to keep track of the numebrs seen. But that\\'s not using constant space. After a bit, I gave in, and looked at the solution. With out giving to much away, it suggests doing something you should never do in real code: modifing the input array!"
                    },
                    {
                        "username": "XuWang77",
                        "content": "\\'\\'\\'\\nreturn(sorted(list(set(range(1,max(nums)+2)) - set(nums)))[0] if nums else 1)\\n\\'\\'\\'"
                    },
                    {
                        "username": "garyfu",
                        "content": "Sorting the array makes the runtime at least O(n*log(n)).\nAlso, creating a extra sets violates the constant extra memory constraint."
                    },
                    {
                        "username": "pilch",
                        "content": "I find the wording confusing, since usually constant space does mean that your algorithm is not allowed to use space quantity that depends on the size of the input. When modifying the input, we allow the algorithm to use up to O(n) space.\\nI suggest the wording should precise that we are allowed to modify the input array."
                    },
                    {
                        "username": "makeittrue",
                        "content": "like putting interger into the i-th element of the array"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "This is a hard question because of the space constraint. Otherwise, it is an easy."
                    },
                    {
                        "username": "Husoski",
                        "content": "The hard part for me was ignoring (what used to be?) good software engineering practice and treating a reference argument as working storage."
                    }
                ]
            },
            {
                "id": 1899816,
                "content": [
                    {
                        "username": "isgulkov",
                        "content": "So I\\'ve just wasted a good couple of hours trying to find a solution that would, and I quote, \"*run in O(n) time and use constant extra space*\".\\n\\nThe *no negatives* case of this is itself not too obvious: you just use the signs (basically, unused bits) to store what you need, then clean up after yourself \\u2014 pretty neat. How do you do this with negative numbers, though? I don\\'t know! Maybe there *is* some clever way to do this, but it doesn\\'t seem likely.\\n\\nOne way ot the other, none of the solutions I\\'ve found to this \\u2014 neither on this forum nor through Google \\u2014 actually solve the problem as stated. They just leave the array modified in one way or another!\\n\\nSee, unless you\\'re using some quite peculiar definition of space complexity, if the input array is left modified modified, you\\'re actually **using** it as extra space for your algorithm, which makes its space complexity O(n). You might as well allocate a second array of booleans like any sane person would in this case.\\n\\nOr is there an actual O(1) space solution for this? If so, I\\'d really like to see it!"
                    },
                    {
                        "username": "0ca6ra",
                        "content": "nowhere in the description of the problem it is mentioned that the positive integers in the integer array should be >= 1 and <= n. it seems that all solutions provided made that assumption. if this is the case, the description should be updated."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My second hard which I solved on my own without looking at hints or solution ! <33"
                    },
                    {
                        "username": "piyushmorey626",
                        "content": "The first missing number always lies between the range of [1, n+1], where \\'n\\' represents the length of the array. This observation simplifies the problem-solving process. "
                    },
                    {
                        "username": "tunstals",
                        "content": "Some of the solutions I\\'ve seen posted here are using sets or lists to sort the unsorted array parameter, then iterating through the sorted result.\\n\\nSurely this can\\'t be O(N) as the sort algorithm implementation will use a loop itself, then the solution code will use a loop to find the smallest value?  So this would be O(N*2)\\n\\nAm I missing something here?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "That sorting can also get completed in O(n log n)\\n"
                    },
                    {
                        "username": "m13d",
                        "content": "So pretty quickliy I came up with a solution similiar to many of the others here, using a set, or hashmap, to keep track of the numebrs seen. But that\\'s not using constant space. After a bit, I gave in, and looked at the solution. With out giving to much away, it suggests doing something you should never do in real code: modifing the input array!"
                    },
                    {
                        "username": "XuWang77",
                        "content": "\\'\\'\\'\\nreturn(sorted(list(set(range(1,max(nums)+2)) - set(nums)))[0] if nums else 1)\\n\\'\\'\\'"
                    },
                    {
                        "username": "garyfu",
                        "content": "Sorting the array makes the runtime at least O(n*log(n)).\nAlso, creating a extra sets violates the constant extra memory constraint."
                    },
                    {
                        "username": "pilch",
                        "content": "I find the wording confusing, since usually constant space does mean that your algorithm is not allowed to use space quantity that depends on the size of the input. When modifying the input, we allow the algorithm to use up to O(n) space.\\nI suggest the wording should precise that we are allowed to modify the input array."
                    },
                    {
                        "username": "makeittrue",
                        "content": "like putting interger into the i-th element of the array"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "This is a hard question because of the space constraint. Otherwise, it is an easy."
                    },
                    {
                        "username": "Husoski",
                        "content": "The hard part for me was ignoring (what used to be?) good software engineering practice and treating a reference argument as working storage."
                    }
                ]
            },
            {
                "id": 1576134,
                "content": [
                    {
                        "username": "isgulkov",
                        "content": "So I\\'ve just wasted a good couple of hours trying to find a solution that would, and I quote, \"*run in O(n) time and use constant extra space*\".\\n\\nThe *no negatives* case of this is itself not too obvious: you just use the signs (basically, unused bits) to store what you need, then clean up after yourself \\u2014 pretty neat. How do you do this with negative numbers, though? I don\\'t know! Maybe there *is* some clever way to do this, but it doesn\\'t seem likely.\\n\\nOne way ot the other, none of the solutions I\\'ve found to this \\u2014 neither on this forum nor through Google \\u2014 actually solve the problem as stated. They just leave the array modified in one way or another!\\n\\nSee, unless you\\'re using some quite peculiar definition of space complexity, if the input array is left modified modified, you\\'re actually **using** it as extra space for your algorithm, which makes its space complexity O(n). You might as well allocate a second array of booleans like any sane person would in this case.\\n\\nOr is there an actual O(1) space solution for this? If so, I\\'d really like to see it!"
                    },
                    {
                        "username": "0ca6ra",
                        "content": "nowhere in the description of the problem it is mentioned that the positive integers in the integer array should be >= 1 and <= n. it seems that all solutions provided made that assumption. if this is the case, the description should be updated."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My second hard which I solved on my own without looking at hints or solution ! <33"
                    },
                    {
                        "username": "piyushmorey626",
                        "content": "The first missing number always lies between the range of [1, n+1], where \\'n\\' represents the length of the array. This observation simplifies the problem-solving process. "
                    },
                    {
                        "username": "tunstals",
                        "content": "Some of the solutions I\\'ve seen posted here are using sets or lists to sort the unsorted array parameter, then iterating through the sorted result.\\n\\nSurely this can\\'t be O(N) as the sort algorithm implementation will use a loop itself, then the solution code will use a loop to find the smallest value?  So this would be O(N*2)\\n\\nAm I missing something here?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "That sorting can also get completed in O(n log n)\\n"
                    },
                    {
                        "username": "m13d",
                        "content": "So pretty quickliy I came up with a solution similiar to many of the others here, using a set, or hashmap, to keep track of the numebrs seen. But that\\'s not using constant space. After a bit, I gave in, and looked at the solution. With out giving to much away, it suggests doing something you should never do in real code: modifing the input array!"
                    },
                    {
                        "username": "XuWang77",
                        "content": "\\'\\'\\'\\nreturn(sorted(list(set(range(1,max(nums)+2)) - set(nums)))[0] if nums else 1)\\n\\'\\'\\'"
                    },
                    {
                        "username": "garyfu",
                        "content": "Sorting the array makes the runtime at least O(n*log(n)).\nAlso, creating a extra sets violates the constant extra memory constraint."
                    },
                    {
                        "username": "pilch",
                        "content": "I find the wording confusing, since usually constant space does mean that your algorithm is not allowed to use space quantity that depends on the size of the input. When modifying the input, we allow the algorithm to use up to O(n) space.\\nI suggest the wording should precise that we are allowed to modify the input array."
                    },
                    {
                        "username": "makeittrue",
                        "content": "like putting interger into the i-th element of the array"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "This is a hard question because of the space constraint. Otherwise, it is an easy."
                    },
                    {
                        "username": "Husoski",
                        "content": "The hard part for me was ignoring (what used to be?) good software engineering practice and treating a reference argument as working storage."
                    }
                ]
            },
            {
                "id": 1574477,
                "content": [
                    {
                        "username": "isgulkov",
                        "content": "So I\\'ve just wasted a good couple of hours trying to find a solution that would, and I quote, \"*run in O(n) time and use constant extra space*\".\\n\\nThe *no negatives* case of this is itself not too obvious: you just use the signs (basically, unused bits) to store what you need, then clean up after yourself \\u2014 pretty neat. How do you do this with negative numbers, though? I don\\'t know! Maybe there *is* some clever way to do this, but it doesn\\'t seem likely.\\n\\nOne way ot the other, none of the solutions I\\'ve found to this \\u2014 neither on this forum nor through Google \\u2014 actually solve the problem as stated. They just leave the array modified in one way or another!\\n\\nSee, unless you\\'re using some quite peculiar definition of space complexity, if the input array is left modified modified, you\\'re actually **using** it as extra space for your algorithm, which makes its space complexity O(n). You might as well allocate a second array of booleans like any sane person would in this case.\\n\\nOr is there an actual O(1) space solution for this? If so, I\\'d really like to see it!"
                    },
                    {
                        "username": "0ca6ra",
                        "content": "nowhere in the description of the problem it is mentioned that the positive integers in the integer array should be >= 1 and <= n. it seems that all solutions provided made that assumption. if this is the case, the description should be updated."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My second hard which I solved on my own without looking at hints or solution ! <33"
                    },
                    {
                        "username": "piyushmorey626",
                        "content": "The first missing number always lies between the range of [1, n+1], where \\'n\\' represents the length of the array. This observation simplifies the problem-solving process. "
                    },
                    {
                        "username": "tunstals",
                        "content": "Some of the solutions I\\'ve seen posted here are using sets or lists to sort the unsorted array parameter, then iterating through the sorted result.\\n\\nSurely this can\\'t be O(N) as the sort algorithm implementation will use a loop itself, then the solution code will use a loop to find the smallest value?  So this would be O(N*2)\\n\\nAm I missing something here?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "That sorting can also get completed in O(n log n)\\n"
                    },
                    {
                        "username": "m13d",
                        "content": "So pretty quickliy I came up with a solution similiar to many of the others here, using a set, or hashmap, to keep track of the numebrs seen. But that\\'s not using constant space. After a bit, I gave in, and looked at the solution. With out giving to much away, it suggests doing something you should never do in real code: modifing the input array!"
                    },
                    {
                        "username": "XuWang77",
                        "content": "\\'\\'\\'\\nreturn(sorted(list(set(range(1,max(nums)+2)) - set(nums)))[0] if nums else 1)\\n\\'\\'\\'"
                    },
                    {
                        "username": "garyfu",
                        "content": "Sorting the array makes the runtime at least O(n*log(n)).\nAlso, creating a extra sets violates the constant extra memory constraint."
                    },
                    {
                        "username": "pilch",
                        "content": "I find the wording confusing, since usually constant space does mean that your algorithm is not allowed to use space quantity that depends on the size of the input. When modifying the input, we allow the algorithm to use up to O(n) space.\\nI suggest the wording should precise that we are allowed to modify the input array."
                    },
                    {
                        "username": "makeittrue",
                        "content": "like putting interger into the i-th element of the array"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "This is a hard question because of the space constraint. Otherwise, it is an easy."
                    },
                    {
                        "username": "Husoski",
                        "content": "The hard part for me was ignoring (what used to be?) good software engineering practice and treating a reference argument as working storage."
                    }
                ]
            },
            {
                "id": 1569200,
                "content": [
                    {
                        "username": "isgulkov",
                        "content": "So I\\'ve just wasted a good couple of hours trying to find a solution that would, and I quote, \"*run in O(n) time and use constant extra space*\".\\n\\nThe *no negatives* case of this is itself not too obvious: you just use the signs (basically, unused bits) to store what you need, then clean up after yourself \\u2014 pretty neat. How do you do this with negative numbers, though? I don\\'t know! Maybe there *is* some clever way to do this, but it doesn\\'t seem likely.\\n\\nOne way ot the other, none of the solutions I\\'ve found to this \\u2014 neither on this forum nor through Google \\u2014 actually solve the problem as stated. They just leave the array modified in one way or another!\\n\\nSee, unless you\\'re using some quite peculiar definition of space complexity, if the input array is left modified modified, you\\'re actually **using** it as extra space for your algorithm, which makes its space complexity O(n). You might as well allocate a second array of booleans like any sane person would in this case.\\n\\nOr is there an actual O(1) space solution for this? If so, I\\'d really like to see it!"
                    },
                    {
                        "username": "0ca6ra",
                        "content": "nowhere in the description of the problem it is mentioned that the positive integers in the integer array should be >= 1 and <= n. it seems that all solutions provided made that assumption. if this is the case, the description should be updated."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My second hard which I solved on my own without looking at hints or solution ! <33"
                    },
                    {
                        "username": "piyushmorey626",
                        "content": "The first missing number always lies between the range of [1, n+1], where \\'n\\' represents the length of the array. This observation simplifies the problem-solving process. "
                    },
                    {
                        "username": "tunstals",
                        "content": "Some of the solutions I\\'ve seen posted here are using sets or lists to sort the unsorted array parameter, then iterating through the sorted result.\\n\\nSurely this can\\'t be O(N) as the sort algorithm implementation will use a loop itself, then the solution code will use a loop to find the smallest value?  So this would be O(N*2)\\n\\nAm I missing something here?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "That sorting can also get completed in O(n log n)\\n"
                    },
                    {
                        "username": "m13d",
                        "content": "So pretty quickliy I came up with a solution similiar to many of the others here, using a set, or hashmap, to keep track of the numebrs seen. But that\\'s not using constant space. After a bit, I gave in, and looked at the solution. With out giving to much away, it suggests doing something you should never do in real code: modifing the input array!"
                    },
                    {
                        "username": "XuWang77",
                        "content": "\\'\\'\\'\\nreturn(sorted(list(set(range(1,max(nums)+2)) - set(nums)))[0] if nums else 1)\\n\\'\\'\\'"
                    },
                    {
                        "username": "garyfu",
                        "content": "Sorting the array makes the runtime at least O(n*log(n)).\nAlso, creating a extra sets violates the constant extra memory constraint."
                    },
                    {
                        "username": "pilch",
                        "content": "I find the wording confusing, since usually constant space does mean that your algorithm is not allowed to use space quantity that depends on the size of the input. When modifying the input, we allow the algorithm to use up to O(n) space.\\nI suggest the wording should precise that we are allowed to modify the input array."
                    },
                    {
                        "username": "makeittrue",
                        "content": "like putting interger into the i-th element of the array"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "This is a hard question because of the space constraint. Otherwise, it is an easy."
                    },
                    {
                        "username": "Husoski",
                        "content": "The hard part for me was ignoring (what used to be?) good software engineering practice and treating a reference argument as working storage."
                    }
                ]
            },
            {
                "id": 1571100,
                "content": [
                    {
                        "username": "isgulkov",
                        "content": "So I\\'ve just wasted a good couple of hours trying to find a solution that would, and I quote, \"*run in O(n) time and use constant extra space*\".\\n\\nThe *no negatives* case of this is itself not too obvious: you just use the signs (basically, unused bits) to store what you need, then clean up after yourself \\u2014 pretty neat. How do you do this with negative numbers, though? I don\\'t know! Maybe there *is* some clever way to do this, but it doesn\\'t seem likely.\\n\\nOne way ot the other, none of the solutions I\\'ve found to this \\u2014 neither on this forum nor through Google \\u2014 actually solve the problem as stated. They just leave the array modified in one way or another!\\n\\nSee, unless you\\'re using some quite peculiar definition of space complexity, if the input array is left modified modified, you\\'re actually **using** it as extra space for your algorithm, which makes its space complexity O(n). You might as well allocate a second array of booleans like any sane person would in this case.\\n\\nOr is there an actual O(1) space solution for this? If so, I\\'d really like to see it!"
                    },
                    {
                        "username": "0ca6ra",
                        "content": "nowhere in the description of the problem it is mentioned that the positive integers in the integer array should be >= 1 and <= n. it seems that all solutions provided made that assumption. if this is the case, the description should be updated."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My second hard which I solved on my own without looking at hints or solution ! <33"
                    },
                    {
                        "username": "piyushmorey626",
                        "content": "The first missing number always lies between the range of [1, n+1], where \\'n\\' represents the length of the array. This observation simplifies the problem-solving process. "
                    },
                    {
                        "username": "tunstals",
                        "content": "Some of the solutions I\\'ve seen posted here are using sets or lists to sort the unsorted array parameter, then iterating through the sorted result.\\n\\nSurely this can\\'t be O(N) as the sort algorithm implementation will use a loop itself, then the solution code will use a loop to find the smallest value?  So this would be O(N*2)\\n\\nAm I missing something here?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "That sorting can also get completed in O(n log n)\\n"
                    },
                    {
                        "username": "m13d",
                        "content": "So pretty quickliy I came up with a solution similiar to many of the others here, using a set, or hashmap, to keep track of the numebrs seen. But that\\'s not using constant space. After a bit, I gave in, and looked at the solution. With out giving to much away, it suggests doing something you should never do in real code: modifing the input array!"
                    },
                    {
                        "username": "XuWang77",
                        "content": "\\'\\'\\'\\nreturn(sorted(list(set(range(1,max(nums)+2)) - set(nums)))[0] if nums else 1)\\n\\'\\'\\'"
                    },
                    {
                        "username": "garyfu",
                        "content": "Sorting the array makes the runtime at least O(n*log(n)).\nAlso, creating a extra sets violates the constant extra memory constraint."
                    },
                    {
                        "username": "pilch",
                        "content": "I find the wording confusing, since usually constant space does mean that your algorithm is not allowed to use space quantity that depends on the size of the input. When modifying the input, we allow the algorithm to use up to O(n) space.\\nI suggest the wording should precise that we are allowed to modify the input array."
                    },
                    {
                        "username": "makeittrue",
                        "content": "like putting interger into the i-th element of the array"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "This is a hard question because of the space constraint. Otherwise, it is an easy."
                    },
                    {
                        "username": "Husoski",
                        "content": "The hard part for me was ignoring (what used to be?) good software engineering practice and treating a reference argument as working storage."
                    }
                ]
            },
            {
                "id": 1568866,
                "content": [
                    {
                        "username": "isgulkov",
                        "content": "So I\\'ve just wasted a good couple of hours trying to find a solution that would, and I quote, \"*run in O(n) time and use constant extra space*\".\\n\\nThe *no negatives* case of this is itself not too obvious: you just use the signs (basically, unused bits) to store what you need, then clean up after yourself \\u2014 pretty neat. How do you do this with negative numbers, though? I don\\'t know! Maybe there *is* some clever way to do this, but it doesn\\'t seem likely.\\n\\nOne way ot the other, none of the solutions I\\'ve found to this \\u2014 neither on this forum nor through Google \\u2014 actually solve the problem as stated. They just leave the array modified in one way or another!\\n\\nSee, unless you\\'re using some quite peculiar definition of space complexity, if the input array is left modified modified, you\\'re actually **using** it as extra space for your algorithm, which makes its space complexity O(n). You might as well allocate a second array of booleans like any sane person would in this case.\\n\\nOr is there an actual O(1) space solution for this? If so, I\\'d really like to see it!"
                    },
                    {
                        "username": "0ca6ra",
                        "content": "nowhere in the description of the problem it is mentioned that the positive integers in the integer array should be >= 1 and <= n. it seems that all solutions provided made that assumption. if this is the case, the description should be updated."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My second hard which I solved on my own without looking at hints or solution ! <33"
                    },
                    {
                        "username": "piyushmorey626",
                        "content": "The first missing number always lies between the range of [1, n+1], where \\'n\\' represents the length of the array. This observation simplifies the problem-solving process. "
                    },
                    {
                        "username": "tunstals",
                        "content": "Some of the solutions I\\'ve seen posted here are using sets or lists to sort the unsorted array parameter, then iterating through the sorted result.\\n\\nSurely this can\\'t be O(N) as the sort algorithm implementation will use a loop itself, then the solution code will use a loop to find the smallest value?  So this would be O(N*2)\\n\\nAm I missing something here?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "That sorting can also get completed in O(n log n)\\n"
                    },
                    {
                        "username": "m13d",
                        "content": "So pretty quickliy I came up with a solution similiar to many of the others here, using a set, or hashmap, to keep track of the numebrs seen. But that\\'s not using constant space. After a bit, I gave in, and looked at the solution. With out giving to much away, it suggests doing something you should never do in real code: modifing the input array!"
                    },
                    {
                        "username": "XuWang77",
                        "content": "\\'\\'\\'\\nreturn(sorted(list(set(range(1,max(nums)+2)) - set(nums)))[0] if nums else 1)\\n\\'\\'\\'"
                    },
                    {
                        "username": "garyfu",
                        "content": "Sorting the array makes the runtime at least O(n*log(n)).\nAlso, creating a extra sets violates the constant extra memory constraint."
                    },
                    {
                        "username": "pilch",
                        "content": "I find the wording confusing, since usually constant space does mean that your algorithm is not allowed to use space quantity that depends on the size of the input. When modifying the input, we allow the algorithm to use up to O(n) space.\\nI suggest the wording should precise that we are allowed to modify the input array."
                    },
                    {
                        "username": "makeittrue",
                        "content": "like putting interger into the i-th element of the array"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "This is a hard question because of the space constraint. Otherwise, it is an easy."
                    },
                    {
                        "username": "Husoski",
                        "content": "The hard part for me was ignoring (what used to be?) good software engineering practice and treating a reference argument as working storage."
                    }
                ]
            },
            {
                "id": 2047614,
                "content": [
                    {
                        "username": "isgulkov",
                        "content": "So I\\'ve just wasted a good couple of hours trying to find a solution that would, and I quote, \"*run in O(n) time and use constant extra space*\".\\n\\nThe *no negatives* case of this is itself not too obvious: you just use the signs (basically, unused bits) to store what you need, then clean up after yourself \\u2014 pretty neat. How do you do this with negative numbers, though? I don\\'t know! Maybe there *is* some clever way to do this, but it doesn\\'t seem likely.\\n\\nOne way ot the other, none of the solutions I\\'ve found to this \\u2014 neither on this forum nor through Google \\u2014 actually solve the problem as stated. They just leave the array modified in one way or another!\\n\\nSee, unless you\\'re using some quite peculiar definition of space complexity, if the input array is left modified modified, you\\'re actually **using** it as extra space for your algorithm, which makes its space complexity O(n). You might as well allocate a second array of booleans like any sane person would in this case.\\n\\nOr is there an actual O(1) space solution for this? If so, I\\'d really like to see it!"
                    },
                    {
                        "username": "0ca6ra",
                        "content": "nowhere in the description of the problem it is mentioned that the positive integers in the integer array should be >= 1 and <= n. it seems that all solutions provided made that assumption. if this is the case, the description should be updated."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My second hard which I solved on my own without looking at hints or solution ! <33"
                    },
                    {
                        "username": "piyushmorey626",
                        "content": "The first missing number always lies between the range of [1, n+1], where \\'n\\' represents the length of the array. This observation simplifies the problem-solving process. "
                    },
                    {
                        "username": "tunstals",
                        "content": "Some of the solutions I\\'ve seen posted here are using sets or lists to sort the unsorted array parameter, then iterating through the sorted result.\\n\\nSurely this can\\'t be O(N) as the sort algorithm implementation will use a loop itself, then the solution code will use a loop to find the smallest value?  So this would be O(N*2)\\n\\nAm I missing something here?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "That sorting can also get completed in O(n log n)\\n"
                    },
                    {
                        "username": "m13d",
                        "content": "So pretty quickliy I came up with a solution similiar to many of the others here, using a set, or hashmap, to keep track of the numebrs seen. But that\\'s not using constant space. After a bit, I gave in, and looked at the solution. With out giving to much away, it suggests doing something you should never do in real code: modifing the input array!"
                    },
                    {
                        "username": "XuWang77",
                        "content": "\\'\\'\\'\\nreturn(sorted(list(set(range(1,max(nums)+2)) - set(nums)))[0] if nums else 1)\\n\\'\\'\\'"
                    },
                    {
                        "username": "garyfu",
                        "content": "Sorting the array makes the runtime at least O(n*log(n)).\nAlso, creating a extra sets violates the constant extra memory constraint."
                    },
                    {
                        "username": "pilch",
                        "content": "I find the wording confusing, since usually constant space does mean that your algorithm is not allowed to use space quantity that depends on the size of the input. When modifying the input, we allow the algorithm to use up to O(n) space.\\nI suggest the wording should precise that we are allowed to modify the input array."
                    },
                    {
                        "username": "makeittrue",
                        "content": "like putting interger into the i-th element of the array"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "This is a hard question because of the space constraint. Otherwise, it is an easy."
                    },
                    {
                        "username": "Husoski",
                        "content": "The hard part for me was ignoring (what used to be?) good software engineering practice and treating a reference argument as working storage."
                    }
                ]
            },
            {
                "id": 1997280,
                "content": [
                    {
                        "username": "ShashankChaturvedi",
                        "content": "I will give a simple hint, think of indexes, because indexes can be used to compare as they are increasing integers , either your answer will be from the indexes or length + 1."
                    },
                    {
                        "username": "sadmanrizwan",
                        "content": "Easiest solution is to use an extra marking array and mark index **(i - 1)** of that array if **i** is in the given array.\\nThis takes **O(N)** extra memory.\\n\\nTo do it without extra space, we have to use the given array itself as the marking array.\\n\\nHow do we do that?\\n\\nAt first we can get rid of all the numbers less than **0** and greater than **n** (length of the array). We can make them zero, since we don\\'t need them to find the answer.\\n\\nNow, for each positive number **i** in the array, we can mark the index **(i - 1)** just by making **nums[i - 1]** negative.\\nIf **nums[i - 1]** is zero, we can just put **-i** there.\\n\\nThis way value of **nums[i - 1]** will remain intact. Our marking will only make it negative and won\\'t change it\\'s absolute value.\\n\\nAt the end, we can find the lowest missing positive number by finding the lowest index that doesn\\'t have a negative number."
                    },
                    {
                        "username": "user6208QR",
                        "content": "If you are really stuck, please just read one hint at a time, then think about it before reading the next one:\\n\\n1)  Look at the boundary values -2\\u02C632 <= num[i] <= 2\\u02C632-1  and 0 <= n <= 5*10\\u02C65...\\n2) What if we had a huge number in the list?\\n3) Does that huge number really matters in a small list?\\n4) If we only care about values in a small range, can we do something clever?\\n5) Maybe sort the vector faster than O(n log n)?\\n6) Sorting it in place... O(1) space"
                    },
                    {
                        "username": "vaccum",
                        "content": "**Indices are sorted in non-decreasing order and are continuous starting from 1.**"
                    },
                    {
                        "username": "dana-n",
                        "content": "It is bad practice to modify an input parameter as a side effect. In this case, we are being asked to find the first missing positive and in order to do it in \"constant space\" you have to modify the input array. I understand there is a bit of a challenge here, \"can you solve this without allocating extra memory\", however in practice this is generally a bad idea.\\n\\n* https://softwareengineering.stackexchange.com/q/245767/17270\\n* https://softwareengineering.stackexchange.com/q/208828/17270\\n\\nThe exception here would be if the purpose of your function is to modify an input parameter. For example, sort the input array in-place.\\n\\n"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "\\t0. This solution modifies the source array. But since there is no constraint for us not to do that, that\\'s ok.\\n\\t1. The idea is to mark array indexes that correspond to positive numbers in the array.\\n\\t2. We\\'ll mark the index by storing a negative value there.\\n\\t3. But what if there\\'s already negative value there?\\n\\t4. To remedy this we\\'ll first find whatever positive number there exists in array\\n\\t        and substitute all negatives and zeroes with that value.\\n\\t        This way we will not introduce a NEW positive number.\\n\\t        Obviously, if there is no positive number found at this step, the result will be 1.\\n\\t5. After getting rid of negatives and zeroes we\\'ll run thru array and for every number in the array\\n\\t        we will make the number at the corresponding index (number-1) a negative one.\\n\\t        Should check that this index is valid for the array.\\n\\t6. If we hit a position where the number is already negative, that would mean there was a number before\\n\\t       that corresponds to that position. But we know that me made all numbers in the array to be positive.\\n\\t       So we just ignore the minus sign and execute step 5 on this position as though the number was positive.\\n\\t7. In the end we\\'ll have one of two cases:\\n\\t7a. All numbers in the array are negative.\\n\\t        That means that we have numbers in the array corresponding to all indexes.\\n\\t        Obviously that means that we have ALL the numbers from 1 to nums.length (both inclusive).\\n\\t        Obviously we can have more numbers in this case, so the result is nums.length+1\\n\\t7b. Some numbers are negative, some are positive in the array.\\n\\t        The first index with the positive number is our result - because there no such number that would\\n\\t        correspond to this index.\\n\\t8. Mind the fact that array indexes are zero based\\n\\t9. If there were a explicitly stated constraint that nums.length<Integer.MAX_VALUE\\n\\t        (or whatever equivalent is there for this in your preferred language)\\n\\t        we could have simply changed all negatives and zeroes to nums.length+1.\\n\\t        This way they couldn\\'t have meddle at step 5.\\n"
                    },
                    {
                        "username": "zhenxu92",
                        "content": "It indeed has no non-trivial difference between missing number. And it was marked as hard. LeetCode need to fix it."
                    },
                    {
                        "username": "liaoht",
                        "content": "I read a lot of the answers they all get O(n) solution that base on a pre condition , then the bucket sort can be applied, So anyone can tell me where can get this from the question statement ? I can't fingure out where I missed."
                    },
                    {
                        "username": "JUNYUANGO",
                        "content": "![image](https://assets.leetcode.com/users/images/1768d89c-4b76-48d2-9ada-5400a2ca2597_1644363950.9340327.png)\\n"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "first off, solutions shouldn\\'t be posted here, next, that is O(n) space which is outside the requirements"
                    },
                    {
                        "username": "updownuper",
                        "content": "nums = [1,1]\nExpected = 2\n\nThis task is full of nonsense.\nFor the author of this task to draw up a loan agreement at the bank on the same conditions.\n\nSo that he ran around the bank and asked.\n- Why did I take \\$100 from you, but I owe \\$5000?!"
                    }
                ]
            },
            {
                "id": 1576234,
                "content": [
                    {
                        "username": "ShashankChaturvedi",
                        "content": "I will give a simple hint, think of indexes, because indexes can be used to compare as they are increasing integers , either your answer will be from the indexes or length + 1."
                    },
                    {
                        "username": "sadmanrizwan",
                        "content": "Easiest solution is to use an extra marking array and mark index **(i - 1)** of that array if **i** is in the given array.\\nThis takes **O(N)** extra memory.\\n\\nTo do it without extra space, we have to use the given array itself as the marking array.\\n\\nHow do we do that?\\n\\nAt first we can get rid of all the numbers less than **0** and greater than **n** (length of the array). We can make them zero, since we don\\'t need them to find the answer.\\n\\nNow, for each positive number **i** in the array, we can mark the index **(i - 1)** just by making **nums[i - 1]** negative.\\nIf **nums[i - 1]** is zero, we can just put **-i** there.\\n\\nThis way value of **nums[i - 1]** will remain intact. Our marking will only make it negative and won\\'t change it\\'s absolute value.\\n\\nAt the end, we can find the lowest missing positive number by finding the lowest index that doesn\\'t have a negative number."
                    },
                    {
                        "username": "user6208QR",
                        "content": "If you are really stuck, please just read one hint at a time, then think about it before reading the next one:\\n\\n1)  Look at the boundary values -2\\u02C632 <= num[i] <= 2\\u02C632-1  and 0 <= n <= 5*10\\u02C65...\\n2) What if we had a huge number in the list?\\n3) Does that huge number really matters in a small list?\\n4) If we only care about values in a small range, can we do something clever?\\n5) Maybe sort the vector faster than O(n log n)?\\n6) Sorting it in place... O(1) space"
                    },
                    {
                        "username": "vaccum",
                        "content": "**Indices are sorted in non-decreasing order and are continuous starting from 1.**"
                    },
                    {
                        "username": "dana-n",
                        "content": "It is bad practice to modify an input parameter as a side effect. In this case, we are being asked to find the first missing positive and in order to do it in \"constant space\" you have to modify the input array. I understand there is a bit of a challenge here, \"can you solve this without allocating extra memory\", however in practice this is generally a bad idea.\\n\\n* https://softwareengineering.stackexchange.com/q/245767/17270\\n* https://softwareengineering.stackexchange.com/q/208828/17270\\n\\nThe exception here would be if the purpose of your function is to modify an input parameter. For example, sort the input array in-place.\\n\\n"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "\\t0. This solution modifies the source array. But since there is no constraint for us not to do that, that\\'s ok.\\n\\t1. The idea is to mark array indexes that correspond to positive numbers in the array.\\n\\t2. We\\'ll mark the index by storing a negative value there.\\n\\t3. But what if there\\'s already negative value there?\\n\\t4. To remedy this we\\'ll first find whatever positive number there exists in array\\n\\t        and substitute all negatives and zeroes with that value.\\n\\t        This way we will not introduce a NEW positive number.\\n\\t        Obviously, if there is no positive number found at this step, the result will be 1.\\n\\t5. After getting rid of negatives and zeroes we\\'ll run thru array and for every number in the array\\n\\t        we will make the number at the corresponding index (number-1) a negative one.\\n\\t        Should check that this index is valid for the array.\\n\\t6. If we hit a position where the number is already negative, that would mean there was a number before\\n\\t       that corresponds to that position. But we know that me made all numbers in the array to be positive.\\n\\t       So we just ignore the minus sign and execute step 5 on this position as though the number was positive.\\n\\t7. In the end we\\'ll have one of two cases:\\n\\t7a. All numbers in the array are negative.\\n\\t        That means that we have numbers in the array corresponding to all indexes.\\n\\t        Obviously that means that we have ALL the numbers from 1 to nums.length (both inclusive).\\n\\t        Obviously we can have more numbers in this case, so the result is nums.length+1\\n\\t7b. Some numbers are negative, some are positive in the array.\\n\\t        The first index with the positive number is our result - because there no such number that would\\n\\t        correspond to this index.\\n\\t8. Mind the fact that array indexes are zero based\\n\\t9. If there were a explicitly stated constraint that nums.length<Integer.MAX_VALUE\\n\\t        (or whatever equivalent is there for this in your preferred language)\\n\\t        we could have simply changed all negatives and zeroes to nums.length+1.\\n\\t        This way they couldn\\'t have meddle at step 5.\\n"
                    },
                    {
                        "username": "zhenxu92",
                        "content": "It indeed has no non-trivial difference between missing number. And it was marked as hard. LeetCode need to fix it."
                    },
                    {
                        "username": "liaoht",
                        "content": "I read a lot of the answers they all get O(n) solution that base on a pre condition , then the bucket sort can be applied, So anyone can tell me where can get this from the question statement ? I can't fingure out where I missed."
                    },
                    {
                        "username": "JUNYUANGO",
                        "content": "![image](https://assets.leetcode.com/users/images/1768d89c-4b76-48d2-9ada-5400a2ca2597_1644363950.9340327.png)\\n"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "first off, solutions shouldn\\'t be posted here, next, that is O(n) space which is outside the requirements"
                    },
                    {
                        "username": "updownuper",
                        "content": "nums = [1,1]\nExpected = 2\n\nThis task is full of nonsense.\nFor the author of this task to draw up a loan agreement at the bank on the same conditions.\n\nSo that he ran around the bank and asked.\n- Why did I take \\$100 from you, but I owe \\$5000?!"
                    }
                ]
            },
            {
                "id": 1576131,
                "content": [
                    {
                        "username": "ShashankChaturvedi",
                        "content": "I will give a simple hint, think of indexes, because indexes can be used to compare as they are increasing integers , either your answer will be from the indexes or length + 1."
                    },
                    {
                        "username": "sadmanrizwan",
                        "content": "Easiest solution is to use an extra marking array and mark index **(i - 1)** of that array if **i** is in the given array.\\nThis takes **O(N)** extra memory.\\n\\nTo do it without extra space, we have to use the given array itself as the marking array.\\n\\nHow do we do that?\\n\\nAt first we can get rid of all the numbers less than **0** and greater than **n** (length of the array). We can make them zero, since we don\\'t need them to find the answer.\\n\\nNow, for each positive number **i** in the array, we can mark the index **(i - 1)** just by making **nums[i - 1]** negative.\\nIf **nums[i - 1]** is zero, we can just put **-i** there.\\n\\nThis way value of **nums[i - 1]** will remain intact. Our marking will only make it negative and won\\'t change it\\'s absolute value.\\n\\nAt the end, we can find the lowest missing positive number by finding the lowest index that doesn\\'t have a negative number."
                    },
                    {
                        "username": "user6208QR",
                        "content": "If you are really stuck, please just read one hint at a time, then think about it before reading the next one:\\n\\n1)  Look at the boundary values -2\\u02C632 <= num[i] <= 2\\u02C632-1  and 0 <= n <= 5*10\\u02C65...\\n2) What if we had a huge number in the list?\\n3) Does that huge number really matters in a small list?\\n4) If we only care about values in a small range, can we do something clever?\\n5) Maybe sort the vector faster than O(n log n)?\\n6) Sorting it in place... O(1) space"
                    },
                    {
                        "username": "vaccum",
                        "content": "**Indices are sorted in non-decreasing order and are continuous starting from 1.**"
                    },
                    {
                        "username": "dana-n",
                        "content": "It is bad practice to modify an input parameter as a side effect. In this case, we are being asked to find the first missing positive and in order to do it in \"constant space\" you have to modify the input array. I understand there is a bit of a challenge here, \"can you solve this without allocating extra memory\", however in practice this is generally a bad idea.\\n\\n* https://softwareengineering.stackexchange.com/q/245767/17270\\n* https://softwareengineering.stackexchange.com/q/208828/17270\\n\\nThe exception here would be if the purpose of your function is to modify an input parameter. For example, sort the input array in-place.\\n\\n"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "\\t0. This solution modifies the source array. But since there is no constraint for us not to do that, that\\'s ok.\\n\\t1. The idea is to mark array indexes that correspond to positive numbers in the array.\\n\\t2. We\\'ll mark the index by storing a negative value there.\\n\\t3. But what if there\\'s already negative value there?\\n\\t4. To remedy this we\\'ll first find whatever positive number there exists in array\\n\\t        and substitute all negatives and zeroes with that value.\\n\\t        This way we will not introduce a NEW positive number.\\n\\t        Obviously, if there is no positive number found at this step, the result will be 1.\\n\\t5. After getting rid of negatives and zeroes we\\'ll run thru array and for every number in the array\\n\\t        we will make the number at the corresponding index (number-1) a negative one.\\n\\t        Should check that this index is valid for the array.\\n\\t6. If we hit a position where the number is already negative, that would mean there was a number before\\n\\t       that corresponds to that position. But we know that me made all numbers in the array to be positive.\\n\\t       So we just ignore the minus sign and execute step 5 on this position as though the number was positive.\\n\\t7. In the end we\\'ll have one of two cases:\\n\\t7a. All numbers in the array are negative.\\n\\t        That means that we have numbers in the array corresponding to all indexes.\\n\\t        Obviously that means that we have ALL the numbers from 1 to nums.length (both inclusive).\\n\\t        Obviously we can have more numbers in this case, so the result is nums.length+1\\n\\t7b. Some numbers are negative, some are positive in the array.\\n\\t        The first index with the positive number is our result - because there no such number that would\\n\\t        correspond to this index.\\n\\t8. Mind the fact that array indexes are zero based\\n\\t9. If there were a explicitly stated constraint that nums.length<Integer.MAX_VALUE\\n\\t        (or whatever equivalent is there for this in your preferred language)\\n\\t        we could have simply changed all negatives and zeroes to nums.length+1.\\n\\t        This way they couldn\\'t have meddle at step 5.\\n"
                    },
                    {
                        "username": "zhenxu92",
                        "content": "It indeed has no non-trivial difference between missing number. And it was marked as hard. LeetCode need to fix it."
                    },
                    {
                        "username": "liaoht",
                        "content": "I read a lot of the answers they all get O(n) solution that base on a pre condition , then the bucket sort can be applied, So anyone can tell me where can get this from the question statement ? I can't fingure out where I missed."
                    },
                    {
                        "username": "JUNYUANGO",
                        "content": "![image](https://assets.leetcode.com/users/images/1768d89c-4b76-48d2-9ada-5400a2ca2597_1644363950.9340327.png)\\n"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "first off, solutions shouldn\\'t be posted here, next, that is O(n) space which is outside the requirements"
                    },
                    {
                        "username": "updownuper",
                        "content": "nums = [1,1]\nExpected = 2\n\nThis task is full of nonsense.\nFor the author of this task to draw up a loan agreement at the bank on the same conditions.\n\nSo that he ran around the bank and asked.\n- Why did I take \\$100 from you, but I owe \\$5000?!"
                    }
                ]
            },
            {
                "id": 1575308,
                "content": [
                    {
                        "username": "ShashankChaturvedi",
                        "content": "I will give a simple hint, think of indexes, because indexes can be used to compare as they are increasing integers , either your answer will be from the indexes or length + 1."
                    },
                    {
                        "username": "sadmanrizwan",
                        "content": "Easiest solution is to use an extra marking array and mark index **(i - 1)** of that array if **i** is in the given array.\\nThis takes **O(N)** extra memory.\\n\\nTo do it without extra space, we have to use the given array itself as the marking array.\\n\\nHow do we do that?\\n\\nAt first we can get rid of all the numbers less than **0** and greater than **n** (length of the array). We can make them zero, since we don\\'t need them to find the answer.\\n\\nNow, for each positive number **i** in the array, we can mark the index **(i - 1)** just by making **nums[i - 1]** negative.\\nIf **nums[i - 1]** is zero, we can just put **-i** there.\\n\\nThis way value of **nums[i - 1]** will remain intact. Our marking will only make it negative and won\\'t change it\\'s absolute value.\\n\\nAt the end, we can find the lowest missing positive number by finding the lowest index that doesn\\'t have a negative number."
                    },
                    {
                        "username": "user6208QR",
                        "content": "If you are really stuck, please just read one hint at a time, then think about it before reading the next one:\\n\\n1)  Look at the boundary values -2\\u02C632 <= num[i] <= 2\\u02C632-1  and 0 <= n <= 5*10\\u02C65...\\n2) What if we had a huge number in the list?\\n3) Does that huge number really matters in a small list?\\n4) If we only care about values in a small range, can we do something clever?\\n5) Maybe sort the vector faster than O(n log n)?\\n6) Sorting it in place... O(1) space"
                    },
                    {
                        "username": "vaccum",
                        "content": "**Indices are sorted in non-decreasing order and are continuous starting from 1.**"
                    },
                    {
                        "username": "dana-n",
                        "content": "It is bad practice to modify an input parameter as a side effect. In this case, we are being asked to find the first missing positive and in order to do it in \"constant space\" you have to modify the input array. I understand there is a bit of a challenge here, \"can you solve this without allocating extra memory\", however in practice this is generally a bad idea.\\n\\n* https://softwareengineering.stackexchange.com/q/245767/17270\\n* https://softwareengineering.stackexchange.com/q/208828/17270\\n\\nThe exception here would be if the purpose of your function is to modify an input parameter. For example, sort the input array in-place.\\n\\n"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "\\t0. This solution modifies the source array. But since there is no constraint for us not to do that, that\\'s ok.\\n\\t1. The idea is to mark array indexes that correspond to positive numbers in the array.\\n\\t2. We\\'ll mark the index by storing a negative value there.\\n\\t3. But what if there\\'s already negative value there?\\n\\t4. To remedy this we\\'ll first find whatever positive number there exists in array\\n\\t        and substitute all negatives and zeroes with that value.\\n\\t        This way we will not introduce a NEW positive number.\\n\\t        Obviously, if there is no positive number found at this step, the result will be 1.\\n\\t5. After getting rid of negatives and zeroes we\\'ll run thru array and for every number in the array\\n\\t        we will make the number at the corresponding index (number-1) a negative one.\\n\\t        Should check that this index is valid for the array.\\n\\t6. If we hit a position where the number is already negative, that would mean there was a number before\\n\\t       that corresponds to that position. But we know that me made all numbers in the array to be positive.\\n\\t       So we just ignore the minus sign and execute step 5 on this position as though the number was positive.\\n\\t7. In the end we\\'ll have one of two cases:\\n\\t7a. All numbers in the array are negative.\\n\\t        That means that we have numbers in the array corresponding to all indexes.\\n\\t        Obviously that means that we have ALL the numbers from 1 to nums.length (both inclusive).\\n\\t        Obviously we can have more numbers in this case, so the result is nums.length+1\\n\\t7b. Some numbers are negative, some are positive in the array.\\n\\t        The first index with the positive number is our result - because there no such number that would\\n\\t        correspond to this index.\\n\\t8. Mind the fact that array indexes are zero based\\n\\t9. If there were a explicitly stated constraint that nums.length<Integer.MAX_VALUE\\n\\t        (or whatever equivalent is there for this in your preferred language)\\n\\t        we could have simply changed all negatives and zeroes to nums.length+1.\\n\\t        This way they couldn\\'t have meddle at step 5.\\n"
                    },
                    {
                        "username": "zhenxu92",
                        "content": "It indeed has no non-trivial difference between missing number. And it was marked as hard. LeetCode need to fix it."
                    },
                    {
                        "username": "liaoht",
                        "content": "I read a lot of the answers they all get O(n) solution that base on a pre condition , then the bucket sort can be applied, So anyone can tell me where can get this from the question statement ? I can't fingure out where I missed."
                    },
                    {
                        "username": "JUNYUANGO",
                        "content": "![image](https://assets.leetcode.com/users/images/1768d89c-4b76-48d2-9ada-5400a2ca2597_1644363950.9340327.png)\\n"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "first off, solutions shouldn\\'t be posted here, next, that is O(n) space which is outside the requirements"
                    },
                    {
                        "username": "updownuper",
                        "content": "nums = [1,1]\nExpected = 2\n\nThis task is full of nonsense.\nFor the author of this task to draw up a loan agreement at the bank on the same conditions.\n\nSo that he ran around the bank and asked.\n- Why did I take \\$100 from you, but I owe \\$5000?!"
                    }
                ]
            },
            {
                "id": 1574430,
                "content": [
                    {
                        "username": "ShashankChaturvedi",
                        "content": "I will give a simple hint, think of indexes, because indexes can be used to compare as they are increasing integers , either your answer will be from the indexes or length + 1."
                    },
                    {
                        "username": "sadmanrizwan",
                        "content": "Easiest solution is to use an extra marking array and mark index **(i - 1)** of that array if **i** is in the given array.\\nThis takes **O(N)** extra memory.\\n\\nTo do it without extra space, we have to use the given array itself as the marking array.\\n\\nHow do we do that?\\n\\nAt first we can get rid of all the numbers less than **0** and greater than **n** (length of the array). We can make them zero, since we don\\'t need them to find the answer.\\n\\nNow, for each positive number **i** in the array, we can mark the index **(i - 1)** just by making **nums[i - 1]** negative.\\nIf **nums[i - 1]** is zero, we can just put **-i** there.\\n\\nThis way value of **nums[i - 1]** will remain intact. Our marking will only make it negative and won\\'t change it\\'s absolute value.\\n\\nAt the end, we can find the lowest missing positive number by finding the lowest index that doesn\\'t have a negative number."
                    },
                    {
                        "username": "user6208QR",
                        "content": "If you are really stuck, please just read one hint at a time, then think about it before reading the next one:\\n\\n1)  Look at the boundary values -2\\u02C632 <= num[i] <= 2\\u02C632-1  and 0 <= n <= 5*10\\u02C65...\\n2) What if we had a huge number in the list?\\n3) Does that huge number really matters in a small list?\\n4) If we only care about values in a small range, can we do something clever?\\n5) Maybe sort the vector faster than O(n log n)?\\n6) Sorting it in place... O(1) space"
                    },
                    {
                        "username": "vaccum",
                        "content": "**Indices are sorted in non-decreasing order and are continuous starting from 1.**"
                    },
                    {
                        "username": "dana-n",
                        "content": "It is bad practice to modify an input parameter as a side effect. In this case, we are being asked to find the first missing positive and in order to do it in \"constant space\" you have to modify the input array. I understand there is a bit of a challenge here, \"can you solve this without allocating extra memory\", however in practice this is generally a bad idea.\\n\\n* https://softwareengineering.stackexchange.com/q/245767/17270\\n* https://softwareengineering.stackexchange.com/q/208828/17270\\n\\nThe exception here would be if the purpose of your function is to modify an input parameter. For example, sort the input array in-place.\\n\\n"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "\\t0. This solution modifies the source array. But since there is no constraint for us not to do that, that\\'s ok.\\n\\t1. The idea is to mark array indexes that correspond to positive numbers in the array.\\n\\t2. We\\'ll mark the index by storing a negative value there.\\n\\t3. But what if there\\'s already negative value there?\\n\\t4. To remedy this we\\'ll first find whatever positive number there exists in array\\n\\t        and substitute all negatives and zeroes with that value.\\n\\t        This way we will not introduce a NEW positive number.\\n\\t        Obviously, if there is no positive number found at this step, the result will be 1.\\n\\t5. After getting rid of negatives and zeroes we\\'ll run thru array and for every number in the array\\n\\t        we will make the number at the corresponding index (number-1) a negative one.\\n\\t        Should check that this index is valid for the array.\\n\\t6. If we hit a position where the number is already negative, that would mean there was a number before\\n\\t       that corresponds to that position. But we know that me made all numbers in the array to be positive.\\n\\t       So we just ignore the minus sign and execute step 5 on this position as though the number was positive.\\n\\t7. In the end we\\'ll have one of two cases:\\n\\t7a. All numbers in the array are negative.\\n\\t        That means that we have numbers in the array corresponding to all indexes.\\n\\t        Obviously that means that we have ALL the numbers from 1 to nums.length (both inclusive).\\n\\t        Obviously we can have more numbers in this case, so the result is nums.length+1\\n\\t7b. Some numbers are negative, some are positive in the array.\\n\\t        The first index with the positive number is our result - because there no such number that would\\n\\t        correspond to this index.\\n\\t8. Mind the fact that array indexes are zero based\\n\\t9. If there were a explicitly stated constraint that nums.length<Integer.MAX_VALUE\\n\\t        (or whatever equivalent is there for this in your preferred language)\\n\\t        we could have simply changed all negatives and zeroes to nums.length+1.\\n\\t        This way they couldn\\'t have meddle at step 5.\\n"
                    },
                    {
                        "username": "zhenxu92",
                        "content": "It indeed has no non-trivial difference between missing number. And it was marked as hard. LeetCode need to fix it."
                    },
                    {
                        "username": "liaoht",
                        "content": "I read a lot of the answers they all get O(n) solution that base on a pre condition , then the bucket sort can be applied, So anyone can tell me where can get this from the question statement ? I can't fingure out where I missed."
                    },
                    {
                        "username": "JUNYUANGO",
                        "content": "![image](https://assets.leetcode.com/users/images/1768d89c-4b76-48d2-9ada-5400a2ca2597_1644363950.9340327.png)\\n"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "first off, solutions shouldn\\'t be posted here, next, that is O(n) space which is outside the requirements"
                    },
                    {
                        "username": "updownuper",
                        "content": "nums = [1,1]\nExpected = 2\n\nThis task is full of nonsense.\nFor the author of this task to draw up a loan agreement at the bank on the same conditions.\n\nSo that he ran around the bank and asked.\n- Why did I take \\$100 from you, but I owe \\$5000?!"
                    }
                ]
            },
            {
                "id": 1573760,
                "content": [
                    {
                        "username": "ShashankChaturvedi",
                        "content": "I will give a simple hint, think of indexes, because indexes can be used to compare as they are increasing integers , either your answer will be from the indexes or length + 1."
                    },
                    {
                        "username": "sadmanrizwan",
                        "content": "Easiest solution is to use an extra marking array and mark index **(i - 1)** of that array if **i** is in the given array.\\nThis takes **O(N)** extra memory.\\n\\nTo do it without extra space, we have to use the given array itself as the marking array.\\n\\nHow do we do that?\\n\\nAt first we can get rid of all the numbers less than **0** and greater than **n** (length of the array). We can make them zero, since we don\\'t need them to find the answer.\\n\\nNow, for each positive number **i** in the array, we can mark the index **(i - 1)** just by making **nums[i - 1]** negative.\\nIf **nums[i - 1]** is zero, we can just put **-i** there.\\n\\nThis way value of **nums[i - 1]** will remain intact. Our marking will only make it negative and won\\'t change it\\'s absolute value.\\n\\nAt the end, we can find the lowest missing positive number by finding the lowest index that doesn\\'t have a negative number."
                    },
                    {
                        "username": "user6208QR",
                        "content": "If you are really stuck, please just read one hint at a time, then think about it before reading the next one:\\n\\n1)  Look at the boundary values -2\\u02C632 <= num[i] <= 2\\u02C632-1  and 0 <= n <= 5*10\\u02C65...\\n2) What if we had a huge number in the list?\\n3) Does that huge number really matters in a small list?\\n4) If we only care about values in a small range, can we do something clever?\\n5) Maybe sort the vector faster than O(n log n)?\\n6) Sorting it in place... O(1) space"
                    },
                    {
                        "username": "vaccum",
                        "content": "**Indices are sorted in non-decreasing order and are continuous starting from 1.**"
                    },
                    {
                        "username": "dana-n",
                        "content": "It is bad practice to modify an input parameter as a side effect. In this case, we are being asked to find the first missing positive and in order to do it in \"constant space\" you have to modify the input array. I understand there is a bit of a challenge here, \"can you solve this without allocating extra memory\", however in practice this is generally a bad idea.\\n\\n* https://softwareengineering.stackexchange.com/q/245767/17270\\n* https://softwareengineering.stackexchange.com/q/208828/17270\\n\\nThe exception here would be if the purpose of your function is to modify an input parameter. For example, sort the input array in-place.\\n\\n"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "\\t0. This solution modifies the source array. But since there is no constraint for us not to do that, that\\'s ok.\\n\\t1. The idea is to mark array indexes that correspond to positive numbers in the array.\\n\\t2. We\\'ll mark the index by storing a negative value there.\\n\\t3. But what if there\\'s already negative value there?\\n\\t4. To remedy this we\\'ll first find whatever positive number there exists in array\\n\\t        and substitute all negatives and zeroes with that value.\\n\\t        This way we will not introduce a NEW positive number.\\n\\t        Obviously, if there is no positive number found at this step, the result will be 1.\\n\\t5. After getting rid of negatives and zeroes we\\'ll run thru array and for every number in the array\\n\\t        we will make the number at the corresponding index (number-1) a negative one.\\n\\t        Should check that this index is valid for the array.\\n\\t6. If we hit a position where the number is already negative, that would mean there was a number before\\n\\t       that corresponds to that position. But we know that me made all numbers in the array to be positive.\\n\\t       So we just ignore the minus sign and execute step 5 on this position as though the number was positive.\\n\\t7. In the end we\\'ll have one of two cases:\\n\\t7a. All numbers in the array are negative.\\n\\t        That means that we have numbers in the array corresponding to all indexes.\\n\\t        Obviously that means that we have ALL the numbers from 1 to nums.length (both inclusive).\\n\\t        Obviously we can have more numbers in this case, so the result is nums.length+1\\n\\t7b. Some numbers are negative, some are positive in the array.\\n\\t        The first index with the positive number is our result - because there no such number that would\\n\\t        correspond to this index.\\n\\t8. Mind the fact that array indexes are zero based\\n\\t9. If there were a explicitly stated constraint that nums.length<Integer.MAX_VALUE\\n\\t        (or whatever equivalent is there for this in your preferred language)\\n\\t        we could have simply changed all negatives and zeroes to nums.length+1.\\n\\t        This way they couldn\\'t have meddle at step 5.\\n"
                    },
                    {
                        "username": "zhenxu92",
                        "content": "It indeed has no non-trivial difference between missing number. And it was marked as hard. LeetCode need to fix it."
                    },
                    {
                        "username": "liaoht",
                        "content": "I read a lot of the answers they all get O(n) solution that base on a pre condition , then the bucket sort can be applied, So anyone can tell me where can get this from the question statement ? I can't fingure out where I missed."
                    },
                    {
                        "username": "JUNYUANGO",
                        "content": "![image](https://assets.leetcode.com/users/images/1768d89c-4b76-48d2-9ada-5400a2ca2597_1644363950.9340327.png)\\n"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "first off, solutions shouldn\\'t be posted here, next, that is O(n) space which is outside the requirements"
                    },
                    {
                        "username": "updownuper",
                        "content": "nums = [1,1]\nExpected = 2\n\nThis task is full of nonsense.\nFor the author of this task to draw up a loan agreement at the bank on the same conditions.\n\nSo that he ran around the bank and asked.\n- Why did I take \\$100 from you, but I owe \\$5000?!"
                    }
                ]
            },
            {
                "id": 1571956,
                "content": [
                    {
                        "username": "ShashankChaturvedi",
                        "content": "I will give a simple hint, think of indexes, because indexes can be used to compare as they are increasing integers , either your answer will be from the indexes or length + 1."
                    },
                    {
                        "username": "sadmanrizwan",
                        "content": "Easiest solution is to use an extra marking array and mark index **(i - 1)** of that array if **i** is in the given array.\\nThis takes **O(N)** extra memory.\\n\\nTo do it without extra space, we have to use the given array itself as the marking array.\\n\\nHow do we do that?\\n\\nAt first we can get rid of all the numbers less than **0** and greater than **n** (length of the array). We can make them zero, since we don\\'t need them to find the answer.\\n\\nNow, for each positive number **i** in the array, we can mark the index **(i - 1)** just by making **nums[i - 1]** negative.\\nIf **nums[i - 1]** is zero, we can just put **-i** there.\\n\\nThis way value of **nums[i - 1]** will remain intact. Our marking will only make it negative and won\\'t change it\\'s absolute value.\\n\\nAt the end, we can find the lowest missing positive number by finding the lowest index that doesn\\'t have a negative number."
                    },
                    {
                        "username": "user6208QR",
                        "content": "If you are really stuck, please just read one hint at a time, then think about it before reading the next one:\\n\\n1)  Look at the boundary values -2\\u02C632 <= num[i] <= 2\\u02C632-1  and 0 <= n <= 5*10\\u02C65...\\n2) What if we had a huge number in the list?\\n3) Does that huge number really matters in a small list?\\n4) If we only care about values in a small range, can we do something clever?\\n5) Maybe sort the vector faster than O(n log n)?\\n6) Sorting it in place... O(1) space"
                    },
                    {
                        "username": "vaccum",
                        "content": "**Indices are sorted in non-decreasing order and are continuous starting from 1.**"
                    },
                    {
                        "username": "dana-n",
                        "content": "It is bad practice to modify an input parameter as a side effect. In this case, we are being asked to find the first missing positive and in order to do it in \"constant space\" you have to modify the input array. I understand there is a bit of a challenge here, \"can you solve this without allocating extra memory\", however in practice this is generally a bad idea.\\n\\n* https://softwareengineering.stackexchange.com/q/245767/17270\\n* https://softwareengineering.stackexchange.com/q/208828/17270\\n\\nThe exception here would be if the purpose of your function is to modify an input parameter. For example, sort the input array in-place.\\n\\n"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "\\t0. This solution modifies the source array. But since there is no constraint for us not to do that, that\\'s ok.\\n\\t1. The idea is to mark array indexes that correspond to positive numbers in the array.\\n\\t2. We\\'ll mark the index by storing a negative value there.\\n\\t3. But what if there\\'s already negative value there?\\n\\t4. To remedy this we\\'ll first find whatever positive number there exists in array\\n\\t        and substitute all negatives and zeroes with that value.\\n\\t        This way we will not introduce a NEW positive number.\\n\\t        Obviously, if there is no positive number found at this step, the result will be 1.\\n\\t5. After getting rid of negatives and zeroes we\\'ll run thru array and for every number in the array\\n\\t        we will make the number at the corresponding index (number-1) a negative one.\\n\\t        Should check that this index is valid for the array.\\n\\t6. If we hit a position where the number is already negative, that would mean there was a number before\\n\\t       that corresponds to that position. But we know that me made all numbers in the array to be positive.\\n\\t       So we just ignore the minus sign and execute step 5 on this position as though the number was positive.\\n\\t7. In the end we\\'ll have one of two cases:\\n\\t7a. All numbers in the array are negative.\\n\\t        That means that we have numbers in the array corresponding to all indexes.\\n\\t        Obviously that means that we have ALL the numbers from 1 to nums.length (both inclusive).\\n\\t        Obviously we can have more numbers in this case, so the result is nums.length+1\\n\\t7b. Some numbers are negative, some are positive in the array.\\n\\t        The first index with the positive number is our result - because there no such number that would\\n\\t        correspond to this index.\\n\\t8. Mind the fact that array indexes are zero based\\n\\t9. If there were a explicitly stated constraint that nums.length<Integer.MAX_VALUE\\n\\t        (or whatever equivalent is there for this in your preferred language)\\n\\t        we could have simply changed all negatives and zeroes to nums.length+1.\\n\\t        This way they couldn\\'t have meddle at step 5.\\n"
                    },
                    {
                        "username": "zhenxu92",
                        "content": "It indeed has no non-trivial difference between missing number. And it was marked as hard. LeetCode need to fix it."
                    },
                    {
                        "username": "liaoht",
                        "content": "I read a lot of the answers they all get O(n) solution that base on a pre condition , then the bucket sort can be applied, So anyone can tell me where can get this from the question statement ? I can't fingure out where I missed."
                    },
                    {
                        "username": "JUNYUANGO",
                        "content": "![image](https://assets.leetcode.com/users/images/1768d89c-4b76-48d2-9ada-5400a2ca2597_1644363950.9340327.png)\\n"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "first off, solutions shouldn\\'t be posted here, next, that is O(n) space which is outside the requirements"
                    },
                    {
                        "username": "updownuper",
                        "content": "nums = [1,1]\nExpected = 2\n\nThis task is full of nonsense.\nFor the author of this task to draw up a loan agreement at the bank on the same conditions.\n\nSo that he ran around the bank and asked.\n- Why did I take \\$100 from you, but I owe \\$5000?!"
                    }
                ]
            },
            {
                "id": 1571102,
                "content": [
                    {
                        "username": "ShashankChaturvedi",
                        "content": "I will give a simple hint, think of indexes, because indexes can be used to compare as they are increasing integers , either your answer will be from the indexes or length + 1."
                    },
                    {
                        "username": "sadmanrizwan",
                        "content": "Easiest solution is to use an extra marking array and mark index **(i - 1)** of that array if **i** is in the given array.\\nThis takes **O(N)** extra memory.\\n\\nTo do it without extra space, we have to use the given array itself as the marking array.\\n\\nHow do we do that?\\n\\nAt first we can get rid of all the numbers less than **0** and greater than **n** (length of the array). We can make them zero, since we don\\'t need them to find the answer.\\n\\nNow, for each positive number **i** in the array, we can mark the index **(i - 1)** just by making **nums[i - 1]** negative.\\nIf **nums[i - 1]** is zero, we can just put **-i** there.\\n\\nThis way value of **nums[i - 1]** will remain intact. Our marking will only make it negative and won\\'t change it\\'s absolute value.\\n\\nAt the end, we can find the lowest missing positive number by finding the lowest index that doesn\\'t have a negative number."
                    },
                    {
                        "username": "user6208QR",
                        "content": "If you are really stuck, please just read one hint at a time, then think about it before reading the next one:\\n\\n1)  Look at the boundary values -2\\u02C632 <= num[i] <= 2\\u02C632-1  and 0 <= n <= 5*10\\u02C65...\\n2) What if we had a huge number in the list?\\n3) Does that huge number really matters in a small list?\\n4) If we only care about values in a small range, can we do something clever?\\n5) Maybe sort the vector faster than O(n log n)?\\n6) Sorting it in place... O(1) space"
                    },
                    {
                        "username": "vaccum",
                        "content": "**Indices are sorted in non-decreasing order and are continuous starting from 1.**"
                    },
                    {
                        "username": "dana-n",
                        "content": "It is bad practice to modify an input parameter as a side effect. In this case, we are being asked to find the first missing positive and in order to do it in \"constant space\" you have to modify the input array. I understand there is a bit of a challenge here, \"can you solve this without allocating extra memory\", however in practice this is generally a bad idea.\\n\\n* https://softwareengineering.stackexchange.com/q/245767/17270\\n* https://softwareengineering.stackexchange.com/q/208828/17270\\n\\nThe exception here would be if the purpose of your function is to modify an input parameter. For example, sort the input array in-place.\\n\\n"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "\\t0. This solution modifies the source array. But since there is no constraint for us not to do that, that\\'s ok.\\n\\t1. The idea is to mark array indexes that correspond to positive numbers in the array.\\n\\t2. We\\'ll mark the index by storing a negative value there.\\n\\t3. But what if there\\'s already negative value there?\\n\\t4. To remedy this we\\'ll first find whatever positive number there exists in array\\n\\t        and substitute all negatives and zeroes with that value.\\n\\t        This way we will not introduce a NEW positive number.\\n\\t        Obviously, if there is no positive number found at this step, the result will be 1.\\n\\t5. After getting rid of negatives and zeroes we\\'ll run thru array and for every number in the array\\n\\t        we will make the number at the corresponding index (number-1) a negative one.\\n\\t        Should check that this index is valid for the array.\\n\\t6. If we hit a position where the number is already negative, that would mean there was a number before\\n\\t       that corresponds to that position. But we know that me made all numbers in the array to be positive.\\n\\t       So we just ignore the minus sign and execute step 5 on this position as though the number was positive.\\n\\t7. In the end we\\'ll have one of two cases:\\n\\t7a. All numbers in the array are negative.\\n\\t        That means that we have numbers in the array corresponding to all indexes.\\n\\t        Obviously that means that we have ALL the numbers from 1 to nums.length (both inclusive).\\n\\t        Obviously we can have more numbers in this case, so the result is nums.length+1\\n\\t7b. Some numbers are negative, some are positive in the array.\\n\\t        The first index with the positive number is our result - because there no such number that would\\n\\t        correspond to this index.\\n\\t8. Mind the fact that array indexes are zero based\\n\\t9. If there were a explicitly stated constraint that nums.length<Integer.MAX_VALUE\\n\\t        (or whatever equivalent is there for this in your preferred language)\\n\\t        we could have simply changed all negatives and zeroes to nums.length+1.\\n\\t        This way they couldn\\'t have meddle at step 5.\\n"
                    },
                    {
                        "username": "zhenxu92",
                        "content": "It indeed has no non-trivial difference between missing number. And it was marked as hard. LeetCode need to fix it."
                    },
                    {
                        "username": "liaoht",
                        "content": "I read a lot of the answers they all get O(n) solution that base on a pre condition , then the bucket sort can be applied, So anyone can tell me where can get this from the question statement ? I can't fingure out where I missed."
                    },
                    {
                        "username": "JUNYUANGO",
                        "content": "![image](https://assets.leetcode.com/users/images/1768d89c-4b76-48d2-9ada-5400a2ca2597_1644363950.9340327.png)\\n"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "first off, solutions shouldn\\'t be posted here, next, that is O(n) space which is outside the requirements"
                    },
                    {
                        "username": "updownuper",
                        "content": "nums = [1,1]\nExpected = 2\n\nThis task is full of nonsense.\nFor the author of this task to draw up a loan agreement at the bank on the same conditions.\n\nSo that he ran around the bank and asked.\n- Why did I take \\$100 from you, but I owe \\$5000?!"
                    }
                ]
            },
            {
                "id": 1570792,
                "content": [
                    {
                        "username": "ShashankChaturvedi",
                        "content": "I will give a simple hint, think of indexes, because indexes can be used to compare as they are increasing integers , either your answer will be from the indexes or length + 1."
                    },
                    {
                        "username": "sadmanrizwan",
                        "content": "Easiest solution is to use an extra marking array and mark index **(i - 1)** of that array if **i** is in the given array.\\nThis takes **O(N)** extra memory.\\n\\nTo do it without extra space, we have to use the given array itself as the marking array.\\n\\nHow do we do that?\\n\\nAt first we can get rid of all the numbers less than **0** and greater than **n** (length of the array). We can make them zero, since we don\\'t need them to find the answer.\\n\\nNow, for each positive number **i** in the array, we can mark the index **(i - 1)** just by making **nums[i - 1]** negative.\\nIf **nums[i - 1]** is zero, we can just put **-i** there.\\n\\nThis way value of **nums[i - 1]** will remain intact. Our marking will only make it negative and won\\'t change it\\'s absolute value.\\n\\nAt the end, we can find the lowest missing positive number by finding the lowest index that doesn\\'t have a negative number."
                    },
                    {
                        "username": "user6208QR",
                        "content": "If you are really stuck, please just read one hint at a time, then think about it before reading the next one:\\n\\n1)  Look at the boundary values -2\\u02C632 <= num[i] <= 2\\u02C632-1  and 0 <= n <= 5*10\\u02C65...\\n2) What if we had a huge number in the list?\\n3) Does that huge number really matters in a small list?\\n4) If we only care about values in a small range, can we do something clever?\\n5) Maybe sort the vector faster than O(n log n)?\\n6) Sorting it in place... O(1) space"
                    },
                    {
                        "username": "vaccum",
                        "content": "**Indices are sorted in non-decreasing order and are continuous starting from 1.**"
                    },
                    {
                        "username": "dana-n",
                        "content": "It is bad practice to modify an input parameter as a side effect. In this case, we are being asked to find the first missing positive and in order to do it in \"constant space\" you have to modify the input array. I understand there is a bit of a challenge here, \"can you solve this without allocating extra memory\", however in practice this is generally a bad idea.\\n\\n* https://softwareengineering.stackexchange.com/q/245767/17270\\n* https://softwareengineering.stackexchange.com/q/208828/17270\\n\\nThe exception here would be if the purpose of your function is to modify an input parameter. For example, sort the input array in-place.\\n\\n"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "\\t0. This solution modifies the source array. But since there is no constraint for us not to do that, that\\'s ok.\\n\\t1. The idea is to mark array indexes that correspond to positive numbers in the array.\\n\\t2. We\\'ll mark the index by storing a negative value there.\\n\\t3. But what if there\\'s already negative value there?\\n\\t4. To remedy this we\\'ll first find whatever positive number there exists in array\\n\\t        and substitute all negatives and zeroes with that value.\\n\\t        This way we will not introduce a NEW positive number.\\n\\t        Obviously, if there is no positive number found at this step, the result will be 1.\\n\\t5. After getting rid of negatives and zeroes we\\'ll run thru array and for every number in the array\\n\\t        we will make the number at the corresponding index (number-1) a negative one.\\n\\t        Should check that this index is valid for the array.\\n\\t6. If we hit a position where the number is already negative, that would mean there was a number before\\n\\t       that corresponds to that position. But we know that me made all numbers in the array to be positive.\\n\\t       So we just ignore the minus sign and execute step 5 on this position as though the number was positive.\\n\\t7. In the end we\\'ll have one of two cases:\\n\\t7a. All numbers in the array are negative.\\n\\t        That means that we have numbers in the array corresponding to all indexes.\\n\\t        Obviously that means that we have ALL the numbers from 1 to nums.length (both inclusive).\\n\\t        Obviously we can have more numbers in this case, so the result is nums.length+1\\n\\t7b. Some numbers are negative, some are positive in the array.\\n\\t        The first index with the positive number is our result - because there no such number that would\\n\\t        correspond to this index.\\n\\t8. Mind the fact that array indexes are zero based\\n\\t9. If there were a explicitly stated constraint that nums.length<Integer.MAX_VALUE\\n\\t        (or whatever equivalent is there for this in your preferred language)\\n\\t        we could have simply changed all negatives and zeroes to nums.length+1.\\n\\t        This way they couldn\\'t have meddle at step 5.\\n"
                    },
                    {
                        "username": "zhenxu92",
                        "content": "It indeed has no non-trivial difference between missing number. And it was marked as hard. LeetCode need to fix it."
                    },
                    {
                        "username": "liaoht",
                        "content": "I read a lot of the answers they all get O(n) solution that base on a pre condition , then the bucket sort can be applied, So anyone can tell me where can get this from the question statement ? I can't fingure out where I missed."
                    },
                    {
                        "username": "JUNYUANGO",
                        "content": "![image](https://assets.leetcode.com/users/images/1768d89c-4b76-48d2-9ada-5400a2ca2597_1644363950.9340327.png)\\n"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "first off, solutions shouldn\\'t be posted here, next, that is O(n) space which is outside the requirements"
                    },
                    {
                        "username": "updownuper",
                        "content": "nums = [1,1]\nExpected = 2\n\nThis task is full of nonsense.\nFor the author of this task to draw up a loan agreement at the bank on the same conditions.\n\nSo that he ran around the bank and asked.\n- Why did I take \\$100 from you, but I owe \\$5000?!"
                    }
                ]
            },
            {
                "id": 1826191,
                "content": [
                    {
                        "username": "ShashankChaturvedi",
                        "content": "I will give a simple hint, think of indexes, because indexes can be used to compare as they are increasing integers , either your answer will be from the indexes or length + 1."
                    },
                    {
                        "username": "sadmanrizwan",
                        "content": "Easiest solution is to use an extra marking array and mark index **(i - 1)** of that array if **i** is in the given array.\\nThis takes **O(N)** extra memory.\\n\\nTo do it without extra space, we have to use the given array itself as the marking array.\\n\\nHow do we do that?\\n\\nAt first we can get rid of all the numbers less than **0** and greater than **n** (length of the array). We can make them zero, since we don\\'t need them to find the answer.\\n\\nNow, for each positive number **i** in the array, we can mark the index **(i - 1)** just by making **nums[i - 1]** negative.\\nIf **nums[i - 1]** is zero, we can just put **-i** there.\\n\\nThis way value of **nums[i - 1]** will remain intact. Our marking will only make it negative and won\\'t change it\\'s absolute value.\\n\\nAt the end, we can find the lowest missing positive number by finding the lowest index that doesn\\'t have a negative number."
                    },
                    {
                        "username": "user6208QR",
                        "content": "If you are really stuck, please just read one hint at a time, then think about it before reading the next one:\\n\\n1)  Look at the boundary values -2\\u02C632 <= num[i] <= 2\\u02C632-1  and 0 <= n <= 5*10\\u02C65...\\n2) What if we had a huge number in the list?\\n3) Does that huge number really matters in a small list?\\n4) If we only care about values in a small range, can we do something clever?\\n5) Maybe sort the vector faster than O(n log n)?\\n6) Sorting it in place... O(1) space"
                    },
                    {
                        "username": "vaccum",
                        "content": "**Indices are sorted in non-decreasing order and are continuous starting from 1.**"
                    },
                    {
                        "username": "dana-n",
                        "content": "It is bad practice to modify an input parameter as a side effect. In this case, we are being asked to find the first missing positive and in order to do it in \"constant space\" you have to modify the input array. I understand there is a bit of a challenge here, \"can you solve this without allocating extra memory\", however in practice this is generally a bad idea.\\n\\n* https://softwareengineering.stackexchange.com/q/245767/17270\\n* https://softwareengineering.stackexchange.com/q/208828/17270\\n\\nThe exception here would be if the purpose of your function is to modify an input parameter. For example, sort the input array in-place.\\n\\n"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "\\t0. This solution modifies the source array. But since there is no constraint for us not to do that, that\\'s ok.\\n\\t1. The idea is to mark array indexes that correspond to positive numbers in the array.\\n\\t2. We\\'ll mark the index by storing a negative value there.\\n\\t3. But what if there\\'s already negative value there?\\n\\t4. To remedy this we\\'ll first find whatever positive number there exists in array\\n\\t        and substitute all negatives and zeroes with that value.\\n\\t        This way we will not introduce a NEW positive number.\\n\\t        Obviously, if there is no positive number found at this step, the result will be 1.\\n\\t5. After getting rid of negatives and zeroes we\\'ll run thru array and for every number in the array\\n\\t        we will make the number at the corresponding index (number-1) a negative one.\\n\\t        Should check that this index is valid for the array.\\n\\t6. If we hit a position where the number is already negative, that would mean there was a number before\\n\\t       that corresponds to that position. But we know that me made all numbers in the array to be positive.\\n\\t       So we just ignore the minus sign and execute step 5 on this position as though the number was positive.\\n\\t7. In the end we\\'ll have one of two cases:\\n\\t7a. All numbers in the array are negative.\\n\\t        That means that we have numbers in the array corresponding to all indexes.\\n\\t        Obviously that means that we have ALL the numbers from 1 to nums.length (both inclusive).\\n\\t        Obviously we can have more numbers in this case, so the result is nums.length+1\\n\\t7b. Some numbers are negative, some are positive in the array.\\n\\t        The first index with the positive number is our result - because there no such number that would\\n\\t        correspond to this index.\\n\\t8. Mind the fact that array indexes are zero based\\n\\t9. If there were a explicitly stated constraint that nums.length<Integer.MAX_VALUE\\n\\t        (or whatever equivalent is there for this in your preferred language)\\n\\t        we could have simply changed all negatives and zeroes to nums.length+1.\\n\\t        This way they couldn\\'t have meddle at step 5.\\n"
                    },
                    {
                        "username": "zhenxu92",
                        "content": "It indeed has no non-trivial difference between missing number. And it was marked as hard. LeetCode need to fix it."
                    },
                    {
                        "username": "liaoht",
                        "content": "I read a lot of the answers they all get O(n) solution that base on a pre condition , then the bucket sort can be applied, So anyone can tell me where can get this from the question statement ? I can't fingure out where I missed."
                    },
                    {
                        "username": "JUNYUANGO",
                        "content": "![image](https://assets.leetcode.com/users/images/1768d89c-4b76-48d2-9ada-5400a2ca2597_1644363950.9340327.png)\\n"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "first off, solutions shouldn\\'t be posted here, next, that is O(n) space which is outside the requirements"
                    },
                    {
                        "username": "updownuper",
                        "content": "nums = [1,1]\nExpected = 2\n\nThis task is full of nonsense.\nFor the author of this task to draw up a loan agreement at the bank on the same conditions.\n\nSo that he ran around the bank and asked.\n- Why did I take \\$100 from you, but I owe \\$5000?!"
                    }
                ]
            },
            {
                "id": 1575849,
                "content": [
                    {
                        "username": "topensite",
                        "content": "![image](https://assets.leetcode.com/users/images/00b86e58-5852-42de-9a89-cf5582c9f750_1634063008.47816.png)\\n"
                    },
                    {
                        "username": "allanruin",
                        "content": "when considering the problem, I write several cases to test before submit. After some trying, finally I gave up, and decided to see other peoples' idea. Then I see some claimed AC program, yes, they did got AC on leetcode, and I understand the algorithm behind them. But could you guys tell why the following cases won't pass.\\n\\n    {120,121,119,117,116,115}, // expect 118\\n    {8,7,5,4,9,12,11,10}       // expect 6\\n\\n\\nthe problem itself just stated `unsorted integer array`, and I think the two cases I list above is valid?\\n\\nThe program I tested including these:\\n\\n[\"my c solution 4ms\"][1]\\n\\n[\"my short c solution o(1) space and o(n) time\"][2]\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/42098/my-c-solution-4-ms\\n  [2]: https://leetcode.com/discuss/24013/my-short-c-solution-o-1-space-and-o-n-time"
                    },
                    {
                        "username": "Husoski",
                        "content": "In both of those cases, the first missing positive integer is 1."
                    },
                    {
                        "username": "vamsam61",
                        "content": "Is it real hard?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "uses O(1) auxiliary space How much is this space precisely? 1 int ? and thus we have to use Binary for Status  "
                    },
                    {
                        "username": "Husoski",
                        "content": "O(1) is a shorthand for \"constant\".  That means that the memory required is the same (or very nearly so) for all input sizes.  Technically, any program that achieves this has \"O(1) space complexity\", provided of course that the program runs at all.\\n\\nSo, \"big O\" notation is not really a good description of how well a program performs.  It\\'s really a description of how that performance will scale with larger inputs.  \\n  "
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int firstMissingPositive(int[] nums) {\\n        nums=mergesort(nums);\\n        int ans=1;\\n        int i=0;\\n        while(i<nums.length && nums[i]!=1){\\n            i++;\\n        }\\n        if(i==nums.length){\\n            return ans;\\n        }\\n        while(i<nums.length-1 && nums[i]>=nums[i+1]-1){\\n            i++;\\n        }\\n        return nums[i]+1;\\n    }\\n}"
                    },
                    {
                        "username": "snehal_elkiwar",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        if(nums.length==1){\\n            if(nums[0]==1){\\n                return 2;\\n            }\\n            else{\\n                return 1;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> ans=new ArrayList<>();    \\n        HashSet<Integer>uni=new HashSet<>();\\n\\n        for(int i:nums){\\n            uni.add(i);\\n        }\\n\\n        for(int i=1;i<=nums.length+1;i++){\\n            if(uni.contains(i)){\\n                continue;\\n            }\\n            else{\\n                return i;\\n            }\\n        }\\n\\n\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "shift2023",
                        "content": "[2147483647]\\n\\nSeriously??? Why is this even a valid TC? Those of you who are wondering i.e. equivalent to [ INT_MAX ]"
                    },
                    {
                        "username": "agraavi786",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> m= new HashMap<>();\\n        Arrays.sort(nums);\\n\\n        for(int n: nums){\\n            if(n>0){\\n                 m.put(n,m.getOrDefault(m, 0)+1);\\n            }\\n        }\\n        for(int i=1;i<=m.size();i++){\\n            if(!m.containsKey(i)){\\n                return i;\\n\\n            }\\n        }\\n        return m.size()+1;\\n        \\n    }\\n}\\n\\n\\n\\n\\nwhat is the wrong with my code? can anyone tell me?"
                    },
                    {
                        "username": "cnml",
                        "content": "This one was weird, I expected it to be hard. Sometimes for hard puzzles I struggle a lot, but this one I immediately got right and my solution beats 98.8% in runtime and average in memory (O(1)). That was unexpected, but good, i guess. Time to struggle for hours on the next hard problem."
                    },
                    {
                        "username": "yush_2001",
                        "content": "It should be a medium not hard. "
                    }
                ]
            },
            {
                "id": 1571101,
                "content": [
                    {
                        "username": "topensite",
                        "content": "![image](https://assets.leetcode.com/users/images/00b86e58-5852-42de-9a89-cf5582c9f750_1634063008.47816.png)\\n"
                    },
                    {
                        "username": "allanruin",
                        "content": "when considering the problem, I write several cases to test before submit. After some trying, finally I gave up, and decided to see other peoples' idea. Then I see some claimed AC program, yes, they did got AC on leetcode, and I understand the algorithm behind them. But could you guys tell why the following cases won't pass.\\n\\n    {120,121,119,117,116,115}, // expect 118\\n    {8,7,5,4,9,12,11,10}       // expect 6\\n\\n\\nthe problem itself just stated `unsorted integer array`, and I think the two cases I list above is valid?\\n\\nThe program I tested including these:\\n\\n[\"my c solution 4ms\"][1]\\n\\n[\"my short c solution o(1) space and o(n) time\"][2]\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/42098/my-c-solution-4-ms\\n  [2]: https://leetcode.com/discuss/24013/my-short-c-solution-o-1-space-and-o-n-time"
                    },
                    {
                        "username": "Husoski",
                        "content": "In both of those cases, the first missing positive integer is 1."
                    },
                    {
                        "username": "vamsam61",
                        "content": "Is it real hard?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "uses O(1) auxiliary space How much is this space precisely? 1 int ? and thus we have to use Binary for Status  "
                    },
                    {
                        "username": "Husoski",
                        "content": "O(1) is a shorthand for \"constant\".  That means that the memory required is the same (or very nearly so) for all input sizes.  Technically, any program that achieves this has \"O(1) space complexity\", provided of course that the program runs at all.\\n\\nSo, \"big O\" notation is not really a good description of how well a program performs.  It\\'s really a description of how that performance will scale with larger inputs.  \\n  "
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int firstMissingPositive(int[] nums) {\\n        nums=mergesort(nums);\\n        int ans=1;\\n        int i=0;\\n        while(i<nums.length && nums[i]!=1){\\n            i++;\\n        }\\n        if(i==nums.length){\\n            return ans;\\n        }\\n        while(i<nums.length-1 && nums[i]>=nums[i+1]-1){\\n            i++;\\n        }\\n        return nums[i]+1;\\n    }\\n}"
                    },
                    {
                        "username": "snehal_elkiwar",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        if(nums.length==1){\\n            if(nums[0]==1){\\n                return 2;\\n            }\\n            else{\\n                return 1;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> ans=new ArrayList<>();    \\n        HashSet<Integer>uni=new HashSet<>();\\n\\n        for(int i:nums){\\n            uni.add(i);\\n        }\\n\\n        for(int i=1;i<=nums.length+1;i++){\\n            if(uni.contains(i)){\\n                continue;\\n            }\\n            else{\\n                return i;\\n            }\\n        }\\n\\n\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "shift2023",
                        "content": "[2147483647]\\n\\nSeriously??? Why is this even a valid TC? Those of you who are wondering i.e. equivalent to [ INT_MAX ]"
                    },
                    {
                        "username": "agraavi786",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> m= new HashMap<>();\\n        Arrays.sort(nums);\\n\\n        for(int n: nums){\\n            if(n>0){\\n                 m.put(n,m.getOrDefault(m, 0)+1);\\n            }\\n        }\\n        for(int i=1;i<=m.size();i++){\\n            if(!m.containsKey(i)){\\n                return i;\\n\\n            }\\n        }\\n        return m.size()+1;\\n        \\n    }\\n}\\n\\n\\n\\n\\nwhat is the wrong with my code? can anyone tell me?"
                    },
                    {
                        "username": "cnml",
                        "content": "This one was weird, I expected it to be hard. Sometimes for hard puzzles I struggle a lot, but this one I immediately got right and my solution beats 98.8% in runtime and average in memory (O(1)). That was unexpected, but good, i guess. Time to struggle for hours on the next hard problem."
                    },
                    {
                        "username": "yush_2001",
                        "content": "It should be a medium not hard. "
                    }
                ]
            },
            {
                "id": 2073255,
                "content": [
                    {
                        "username": "topensite",
                        "content": "![image](https://assets.leetcode.com/users/images/00b86e58-5852-42de-9a89-cf5582c9f750_1634063008.47816.png)\\n"
                    },
                    {
                        "username": "allanruin",
                        "content": "when considering the problem, I write several cases to test before submit. After some trying, finally I gave up, and decided to see other peoples' idea. Then I see some claimed AC program, yes, they did got AC on leetcode, and I understand the algorithm behind them. But could you guys tell why the following cases won't pass.\\n\\n    {120,121,119,117,116,115}, // expect 118\\n    {8,7,5,4,9,12,11,10}       // expect 6\\n\\n\\nthe problem itself just stated `unsorted integer array`, and I think the two cases I list above is valid?\\n\\nThe program I tested including these:\\n\\n[\"my c solution 4ms\"][1]\\n\\n[\"my short c solution o(1) space and o(n) time\"][2]\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/42098/my-c-solution-4-ms\\n  [2]: https://leetcode.com/discuss/24013/my-short-c-solution-o-1-space-and-o-n-time"
                    },
                    {
                        "username": "Husoski",
                        "content": "In both of those cases, the first missing positive integer is 1."
                    },
                    {
                        "username": "vamsam61",
                        "content": "Is it real hard?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "uses O(1) auxiliary space How much is this space precisely? 1 int ? and thus we have to use Binary for Status  "
                    },
                    {
                        "username": "Husoski",
                        "content": "O(1) is a shorthand for \"constant\".  That means that the memory required is the same (or very nearly so) for all input sizes.  Technically, any program that achieves this has \"O(1) space complexity\", provided of course that the program runs at all.\\n\\nSo, \"big O\" notation is not really a good description of how well a program performs.  It\\'s really a description of how that performance will scale with larger inputs.  \\n  "
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int firstMissingPositive(int[] nums) {\\n        nums=mergesort(nums);\\n        int ans=1;\\n        int i=0;\\n        while(i<nums.length && nums[i]!=1){\\n            i++;\\n        }\\n        if(i==nums.length){\\n            return ans;\\n        }\\n        while(i<nums.length-1 && nums[i]>=nums[i+1]-1){\\n            i++;\\n        }\\n        return nums[i]+1;\\n    }\\n}"
                    },
                    {
                        "username": "snehal_elkiwar",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        if(nums.length==1){\\n            if(nums[0]==1){\\n                return 2;\\n            }\\n            else{\\n                return 1;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> ans=new ArrayList<>();    \\n        HashSet<Integer>uni=new HashSet<>();\\n\\n        for(int i:nums){\\n            uni.add(i);\\n        }\\n\\n        for(int i=1;i<=nums.length+1;i++){\\n            if(uni.contains(i)){\\n                continue;\\n            }\\n            else{\\n                return i;\\n            }\\n        }\\n\\n\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "shift2023",
                        "content": "[2147483647]\\n\\nSeriously??? Why is this even a valid TC? Those of you who are wondering i.e. equivalent to [ INT_MAX ]"
                    },
                    {
                        "username": "agraavi786",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> m= new HashMap<>();\\n        Arrays.sort(nums);\\n\\n        for(int n: nums){\\n            if(n>0){\\n                 m.put(n,m.getOrDefault(m, 0)+1);\\n            }\\n        }\\n        for(int i=1;i<=m.size();i++){\\n            if(!m.containsKey(i)){\\n                return i;\\n\\n            }\\n        }\\n        return m.size()+1;\\n        \\n    }\\n}\\n\\n\\n\\n\\nwhat is the wrong with my code? can anyone tell me?"
                    },
                    {
                        "username": "cnml",
                        "content": "This one was weird, I expected it to be hard. Sometimes for hard puzzles I struggle a lot, but this one I immediately got right and my solution beats 98.8% in runtime and average in memory (O(1)). That was unexpected, but good, i guess. Time to struggle for hours on the next hard problem."
                    },
                    {
                        "username": "yush_2001",
                        "content": "It should be a medium not hard. "
                    }
                ]
            },
            {
                "id": 2064610,
                "content": [
                    {
                        "username": "topensite",
                        "content": "![image](https://assets.leetcode.com/users/images/00b86e58-5852-42de-9a89-cf5582c9f750_1634063008.47816.png)\\n"
                    },
                    {
                        "username": "allanruin",
                        "content": "when considering the problem, I write several cases to test before submit. After some trying, finally I gave up, and decided to see other peoples' idea. Then I see some claimed AC program, yes, they did got AC on leetcode, and I understand the algorithm behind them. But could you guys tell why the following cases won't pass.\\n\\n    {120,121,119,117,116,115}, // expect 118\\n    {8,7,5,4,9,12,11,10}       // expect 6\\n\\n\\nthe problem itself just stated `unsorted integer array`, and I think the two cases I list above is valid?\\n\\nThe program I tested including these:\\n\\n[\"my c solution 4ms\"][1]\\n\\n[\"my short c solution o(1) space and o(n) time\"][2]\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/42098/my-c-solution-4-ms\\n  [2]: https://leetcode.com/discuss/24013/my-short-c-solution-o-1-space-and-o-n-time"
                    },
                    {
                        "username": "Husoski",
                        "content": "In both of those cases, the first missing positive integer is 1."
                    },
                    {
                        "username": "vamsam61",
                        "content": "Is it real hard?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "uses O(1) auxiliary space How much is this space precisely? 1 int ? and thus we have to use Binary for Status  "
                    },
                    {
                        "username": "Husoski",
                        "content": "O(1) is a shorthand for \"constant\".  That means that the memory required is the same (or very nearly so) for all input sizes.  Technically, any program that achieves this has \"O(1) space complexity\", provided of course that the program runs at all.\\n\\nSo, \"big O\" notation is not really a good description of how well a program performs.  It\\'s really a description of how that performance will scale with larger inputs.  \\n  "
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int firstMissingPositive(int[] nums) {\\n        nums=mergesort(nums);\\n        int ans=1;\\n        int i=0;\\n        while(i<nums.length && nums[i]!=1){\\n            i++;\\n        }\\n        if(i==nums.length){\\n            return ans;\\n        }\\n        while(i<nums.length-1 && nums[i]>=nums[i+1]-1){\\n            i++;\\n        }\\n        return nums[i]+1;\\n    }\\n}"
                    },
                    {
                        "username": "snehal_elkiwar",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        if(nums.length==1){\\n            if(nums[0]==1){\\n                return 2;\\n            }\\n            else{\\n                return 1;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> ans=new ArrayList<>();    \\n        HashSet<Integer>uni=new HashSet<>();\\n\\n        for(int i:nums){\\n            uni.add(i);\\n        }\\n\\n        for(int i=1;i<=nums.length+1;i++){\\n            if(uni.contains(i)){\\n                continue;\\n            }\\n            else{\\n                return i;\\n            }\\n        }\\n\\n\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "shift2023",
                        "content": "[2147483647]\\n\\nSeriously??? Why is this even a valid TC? Those of you who are wondering i.e. equivalent to [ INT_MAX ]"
                    },
                    {
                        "username": "agraavi786",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> m= new HashMap<>();\\n        Arrays.sort(nums);\\n\\n        for(int n: nums){\\n            if(n>0){\\n                 m.put(n,m.getOrDefault(m, 0)+1);\\n            }\\n        }\\n        for(int i=1;i<=m.size();i++){\\n            if(!m.containsKey(i)){\\n                return i;\\n\\n            }\\n        }\\n        return m.size()+1;\\n        \\n    }\\n}\\n\\n\\n\\n\\nwhat is the wrong with my code? can anyone tell me?"
                    },
                    {
                        "username": "cnml",
                        "content": "This one was weird, I expected it to be hard. Sometimes for hard puzzles I struggle a lot, but this one I immediately got right and my solution beats 98.8% in runtime and average in memory (O(1)). That was unexpected, but good, i guess. Time to struggle for hours on the next hard problem."
                    },
                    {
                        "username": "yush_2001",
                        "content": "It should be a medium not hard. "
                    }
                ]
            },
            {
                "id": 2064595,
                "content": [
                    {
                        "username": "topensite",
                        "content": "![image](https://assets.leetcode.com/users/images/00b86e58-5852-42de-9a89-cf5582c9f750_1634063008.47816.png)\\n"
                    },
                    {
                        "username": "allanruin",
                        "content": "when considering the problem, I write several cases to test before submit. After some trying, finally I gave up, and decided to see other peoples' idea. Then I see some claimed AC program, yes, they did got AC on leetcode, and I understand the algorithm behind them. But could you guys tell why the following cases won't pass.\\n\\n    {120,121,119,117,116,115}, // expect 118\\n    {8,7,5,4,9,12,11,10}       // expect 6\\n\\n\\nthe problem itself just stated `unsorted integer array`, and I think the two cases I list above is valid?\\n\\nThe program I tested including these:\\n\\n[\"my c solution 4ms\"][1]\\n\\n[\"my short c solution o(1) space and o(n) time\"][2]\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/42098/my-c-solution-4-ms\\n  [2]: https://leetcode.com/discuss/24013/my-short-c-solution-o-1-space-and-o-n-time"
                    },
                    {
                        "username": "Husoski",
                        "content": "In both of those cases, the first missing positive integer is 1."
                    },
                    {
                        "username": "vamsam61",
                        "content": "Is it real hard?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "uses O(1) auxiliary space How much is this space precisely? 1 int ? and thus we have to use Binary for Status  "
                    },
                    {
                        "username": "Husoski",
                        "content": "O(1) is a shorthand for \"constant\".  That means that the memory required is the same (or very nearly so) for all input sizes.  Technically, any program that achieves this has \"O(1) space complexity\", provided of course that the program runs at all.\\n\\nSo, \"big O\" notation is not really a good description of how well a program performs.  It\\'s really a description of how that performance will scale with larger inputs.  \\n  "
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int firstMissingPositive(int[] nums) {\\n        nums=mergesort(nums);\\n        int ans=1;\\n        int i=0;\\n        while(i<nums.length && nums[i]!=1){\\n            i++;\\n        }\\n        if(i==nums.length){\\n            return ans;\\n        }\\n        while(i<nums.length-1 && nums[i]>=nums[i+1]-1){\\n            i++;\\n        }\\n        return nums[i]+1;\\n    }\\n}"
                    },
                    {
                        "username": "snehal_elkiwar",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        if(nums.length==1){\\n            if(nums[0]==1){\\n                return 2;\\n            }\\n            else{\\n                return 1;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> ans=new ArrayList<>();    \\n        HashSet<Integer>uni=new HashSet<>();\\n\\n        for(int i:nums){\\n            uni.add(i);\\n        }\\n\\n        for(int i=1;i<=nums.length+1;i++){\\n            if(uni.contains(i)){\\n                continue;\\n            }\\n            else{\\n                return i;\\n            }\\n        }\\n\\n\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "shift2023",
                        "content": "[2147483647]\\n\\nSeriously??? Why is this even a valid TC? Those of you who are wondering i.e. equivalent to [ INT_MAX ]"
                    },
                    {
                        "username": "agraavi786",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> m= new HashMap<>();\\n        Arrays.sort(nums);\\n\\n        for(int n: nums){\\n            if(n>0){\\n                 m.put(n,m.getOrDefault(m, 0)+1);\\n            }\\n        }\\n        for(int i=1;i<=m.size();i++){\\n            if(!m.containsKey(i)){\\n                return i;\\n\\n            }\\n        }\\n        return m.size()+1;\\n        \\n    }\\n}\\n\\n\\n\\n\\nwhat is the wrong with my code? can anyone tell me?"
                    },
                    {
                        "username": "cnml",
                        "content": "This one was weird, I expected it to be hard. Sometimes for hard puzzles I struggle a lot, but this one I immediately got right and my solution beats 98.8% in runtime and average in memory (O(1)). That was unexpected, but good, i guess. Time to struggle for hours on the next hard problem."
                    },
                    {
                        "username": "yush_2001",
                        "content": "It should be a medium not hard. "
                    }
                ]
            },
            {
                "id": 2061616,
                "content": [
                    {
                        "username": "topensite",
                        "content": "![image](https://assets.leetcode.com/users/images/00b86e58-5852-42de-9a89-cf5582c9f750_1634063008.47816.png)\\n"
                    },
                    {
                        "username": "allanruin",
                        "content": "when considering the problem, I write several cases to test before submit. After some trying, finally I gave up, and decided to see other peoples' idea. Then I see some claimed AC program, yes, they did got AC on leetcode, and I understand the algorithm behind them. But could you guys tell why the following cases won't pass.\\n\\n    {120,121,119,117,116,115}, // expect 118\\n    {8,7,5,4,9,12,11,10}       // expect 6\\n\\n\\nthe problem itself just stated `unsorted integer array`, and I think the two cases I list above is valid?\\n\\nThe program I tested including these:\\n\\n[\"my c solution 4ms\"][1]\\n\\n[\"my short c solution o(1) space and o(n) time\"][2]\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/42098/my-c-solution-4-ms\\n  [2]: https://leetcode.com/discuss/24013/my-short-c-solution-o-1-space-and-o-n-time"
                    },
                    {
                        "username": "Husoski",
                        "content": "In both of those cases, the first missing positive integer is 1."
                    },
                    {
                        "username": "vamsam61",
                        "content": "Is it real hard?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "uses O(1) auxiliary space How much is this space precisely? 1 int ? and thus we have to use Binary for Status  "
                    },
                    {
                        "username": "Husoski",
                        "content": "O(1) is a shorthand for \"constant\".  That means that the memory required is the same (or very nearly so) for all input sizes.  Technically, any program that achieves this has \"O(1) space complexity\", provided of course that the program runs at all.\\n\\nSo, \"big O\" notation is not really a good description of how well a program performs.  It\\'s really a description of how that performance will scale with larger inputs.  \\n  "
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int firstMissingPositive(int[] nums) {\\n        nums=mergesort(nums);\\n        int ans=1;\\n        int i=0;\\n        while(i<nums.length && nums[i]!=1){\\n            i++;\\n        }\\n        if(i==nums.length){\\n            return ans;\\n        }\\n        while(i<nums.length-1 && nums[i]>=nums[i+1]-1){\\n            i++;\\n        }\\n        return nums[i]+1;\\n    }\\n}"
                    },
                    {
                        "username": "snehal_elkiwar",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        if(nums.length==1){\\n            if(nums[0]==1){\\n                return 2;\\n            }\\n            else{\\n                return 1;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> ans=new ArrayList<>();    \\n        HashSet<Integer>uni=new HashSet<>();\\n\\n        for(int i:nums){\\n            uni.add(i);\\n        }\\n\\n        for(int i=1;i<=nums.length+1;i++){\\n            if(uni.contains(i)){\\n                continue;\\n            }\\n            else{\\n                return i;\\n            }\\n        }\\n\\n\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "shift2023",
                        "content": "[2147483647]\\n\\nSeriously??? Why is this even a valid TC? Those of you who are wondering i.e. equivalent to [ INT_MAX ]"
                    },
                    {
                        "username": "agraavi786",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> m= new HashMap<>();\\n        Arrays.sort(nums);\\n\\n        for(int n: nums){\\n            if(n>0){\\n                 m.put(n,m.getOrDefault(m, 0)+1);\\n            }\\n        }\\n        for(int i=1;i<=m.size();i++){\\n            if(!m.containsKey(i)){\\n                return i;\\n\\n            }\\n        }\\n        return m.size()+1;\\n        \\n    }\\n}\\n\\n\\n\\n\\nwhat is the wrong with my code? can anyone tell me?"
                    },
                    {
                        "username": "cnml",
                        "content": "This one was weird, I expected it to be hard. Sometimes for hard puzzles I struggle a lot, but this one I immediately got right and my solution beats 98.8% in runtime and average in memory (O(1)). That was unexpected, but good, i guess. Time to struggle for hours on the next hard problem."
                    },
                    {
                        "username": "yush_2001",
                        "content": "It should be a medium not hard. "
                    }
                ]
            },
            {
                "id": 2060767,
                "content": [
                    {
                        "username": "topensite",
                        "content": "![image](https://assets.leetcode.com/users/images/00b86e58-5852-42de-9a89-cf5582c9f750_1634063008.47816.png)\\n"
                    },
                    {
                        "username": "allanruin",
                        "content": "when considering the problem, I write several cases to test before submit. After some trying, finally I gave up, and decided to see other peoples' idea. Then I see some claimed AC program, yes, they did got AC on leetcode, and I understand the algorithm behind them. But could you guys tell why the following cases won't pass.\\n\\n    {120,121,119,117,116,115}, // expect 118\\n    {8,7,5,4,9,12,11,10}       // expect 6\\n\\n\\nthe problem itself just stated `unsorted integer array`, and I think the two cases I list above is valid?\\n\\nThe program I tested including these:\\n\\n[\"my c solution 4ms\"][1]\\n\\n[\"my short c solution o(1) space and o(n) time\"][2]\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/42098/my-c-solution-4-ms\\n  [2]: https://leetcode.com/discuss/24013/my-short-c-solution-o-1-space-and-o-n-time"
                    },
                    {
                        "username": "Husoski",
                        "content": "In both of those cases, the first missing positive integer is 1."
                    },
                    {
                        "username": "vamsam61",
                        "content": "Is it real hard?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "uses O(1) auxiliary space How much is this space precisely? 1 int ? and thus we have to use Binary for Status  "
                    },
                    {
                        "username": "Husoski",
                        "content": "O(1) is a shorthand for \"constant\".  That means that the memory required is the same (or very nearly so) for all input sizes.  Technically, any program that achieves this has \"O(1) space complexity\", provided of course that the program runs at all.\\n\\nSo, \"big O\" notation is not really a good description of how well a program performs.  It\\'s really a description of how that performance will scale with larger inputs.  \\n  "
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int firstMissingPositive(int[] nums) {\\n        nums=mergesort(nums);\\n        int ans=1;\\n        int i=0;\\n        while(i<nums.length && nums[i]!=1){\\n            i++;\\n        }\\n        if(i==nums.length){\\n            return ans;\\n        }\\n        while(i<nums.length-1 && nums[i]>=nums[i+1]-1){\\n            i++;\\n        }\\n        return nums[i]+1;\\n    }\\n}"
                    },
                    {
                        "username": "snehal_elkiwar",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        if(nums.length==1){\\n            if(nums[0]==1){\\n                return 2;\\n            }\\n            else{\\n                return 1;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> ans=new ArrayList<>();    \\n        HashSet<Integer>uni=new HashSet<>();\\n\\n        for(int i:nums){\\n            uni.add(i);\\n        }\\n\\n        for(int i=1;i<=nums.length+1;i++){\\n            if(uni.contains(i)){\\n                continue;\\n            }\\n            else{\\n                return i;\\n            }\\n        }\\n\\n\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "shift2023",
                        "content": "[2147483647]\\n\\nSeriously??? Why is this even a valid TC? Those of you who are wondering i.e. equivalent to [ INT_MAX ]"
                    },
                    {
                        "username": "agraavi786",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> m= new HashMap<>();\\n        Arrays.sort(nums);\\n\\n        for(int n: nums){\\n            if(n>0){\\n                 m.put(n,m.getOrDefault(m, 0)+1);\\n            }\\n        }\\n        for(int i=1;i<=m.size();i++){\\n            if(!m.containsKey(i)){\\n                return i;\\n\\n            }\\n        }\\n        return m.size()+1;\\n        \\n    }\\n}\\n\\n\\n\\n\\nwhat is the wrong with my code? can anyone tell me?"
                    },
                    {
                        "username": "cnml",
                        "content": "This one was weird, I expected it to be hard. Sometimes for hard puzzles I struggle a lot, but this one I immediately got right and my solution beats 98.8% in runtime and average in memory (O(1)). That was unexpected, but good, i guess. Time to struggle for hours on the next hard problem."
                    },
                    {
                        "username": "yush_2001",
                        "content": "It should be a medium not hard. "
                    }
                ]
            },
            {
                "id": 2057780,
                "content": [
                    {
                        "username": "topensite",
                        "content": "![image](https://assets.leetcode.com/users/images/00b86e58-5852-42de-9a89-cf5582c9f750_1634063008.47816.png)\\n"
                    },
                    {
                        "username": "allanruin",
                        "content": "when considering the problem, I write several cases to test before submit. After some trying, finally I gave up, and decided to see other peoples' idea. Then I see some claimed AC program, yes, they did got AC on leetcode, and I understand the algorithm behind them. But could you guys tell why the following cases won't pass.\\n\\n    {120,121,119,117,116,115}, // expect 118\\n    {8,7,5,4,9,12,11,10}       // expect 6\\n\\n\\nthe problem itself just stated `unsorted integer array`, and I think the two cases I list above is valid?\\n\\nThe program I tested including these:\\n\\n[\"my c solution 4ms\"][1]\\n\\n[\"my short c solution o(1) space and o(n) time\"][2]\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/42098/my-c-solution-4-ms\\n  [2]: https://leetcode.com/discuss/24013/my-short-c-solution-o-1-space-and-o-n-time"
                    },
                    {
                        "username": "Husoski",
                        "content": "In both of those cases, the first missing positive integer is 1."
                    },
                    {
                        "username": "vamsam61",
                        "content": "Is it real hard?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "uses O(1) auxiliary space How much is this space precisely? 1 int ? and thus we have to use Binary for Status  "
                    },
                    {
                        "username": "Husoski",
                        "content": "O(1) is a shorthand for \"constant\".  That means that the memory required is the same (or very nearly so) for all input sizes.  Technically, any program that achieves this has \"O(1) space complexity\", provided of course that the program runs at all.\\n\\nSo, \"big O\" notation is not really a good description of how well a program performs.  It\\'s really a description of how that performance will scale with larger inputs.  \\n  "
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int firstMissingPositive(int[] nums) {\\n        nums=mergesort(nums);\\n        int ans=1;\\n        int i=0;\\n        while(i<nums.length && nums[i]!=1){\\n            i++;\\n        }\\n        if(i==nums.length){\\n            return ans;\\n        }\\n        while(i<nums.length-1 && nums[i]>=nums[i+1]-1){\\n            i++;\\n        }\\n        return nums[i]+1;\\n    }\\n}"
                    },
                    {
                        "username": "snehal_elkiwar",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        if(nums.length==1){\\n            if(nums[0]==1){\\n                return 2;\\n            }\\n            else{\\n                return 1;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> ans=new ArrayList<>();    \\n        HashSet<Integer>uni=new HashSet<>();\\n\\n        for(int i:nums){\\n            uni.add(i);\\n        }\\n\\n        for(int i=1;i<=nums.length+1;i++){\\n            if(uni.contains(i)){\\n                continue;\\n            }\\n            else{\\n                return i;\\n            }\\n        }\\n\\n\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "shift2023",
                        "content": "[2147483647]\\n\\nSeriously??? Why is this even a valid TC? Those of you who are wondering i.e. equivalent to [ INT_MAX ]"
                    },
                    {
                        "username": "agraavi786",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> m= new HashMap<>();\\n        Arrays.sort(nums);\\n\\n        for(int n: nums){\\n            if(n>0){\\n                 m.put(n,m.getOrDefault(m, 0)+1);\\n            }\\n        }\\n        for(int i=1;i<=m.size();i++){\\n            if(!m.containsKey(i)){\\n                return i;\\n\\n            }\\n        }\\n        return m.size()+1;\\n        \\n    }\\n}\\n\\n\\n\\n\\nwhat is the wrong with my code? can anyone tell me?"
                    },
                    {
                        "username": "cnml",
                        "content": "This one was weird, I expected it to be hard. Sometimes for hard puzzles I struggle a lot, but this one I immediately got right and my solution beats 98.8% in runtime and average in memory (O(1)). That was unexpected, but good, i guess. Time to struggle for hours on the next hard problem."
                    },
                    {
                        "username": "yush_2001",
                        "content": "It should be a medium not hard. "
                    }
                ]
            },
            {
                "id": 2055998,
                "content": [
                    {
                        "username": "topensite",
                        "content": "![image](https://assets.leetcode.com/users/images/00b86e58-5852-42de-9a89-cf5582c9f750_1634063008.47816.png)\\n"
                    },
                    {
                        "username": "allanruin",
                        "content": "when considering the problem, I write several cases to test before submit. After some trying, finally I gave up, and decided to see other peoples' idea. Then I see some claimed AC program, yes, they did got AC on leetcode, and I understand the algorithm behind them. But could you guys tell why the following cases won't pass.\\n\\n    {120,121,119,117,116,115}, // expect 118\\n    {8,7,5,4,9,12,11,10}       // expect 6\\n\\n\\nthe problem itself just stated `unsorted integer array`, and I think the two cases I list above is valid?\\n\\nThe program I tested including these:\\n\\n[\"my c solution 4ms\"][1]\\n\\n[\"my short c solution o(1) space and o(n) time\"][2]\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/42098/my-c-solution-4-ms\\n  [2]: https://leetcode.com/discuss/24013/my-short-c-solution-o-1-space-and-o-n-time"
                    },
                    {
                        "username": "Husoski",
                        "content": "In both of those cases, the first missing positive integer is 1."
                    },
                    {
                        "username": "vamsam61",
                        "content": "Is it real hard?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "uses O(1) auxiliary space How much is this space precisely? 1 int ? and thus we have to use Binary for Status  "
                    },
                    {
                        "username": "Husoski",
                        "content": "O(1) is a shorthand for \"constant\".  That means that the memory required is the same (or very nearly so) for all input sizes.  Technically, any program that achieves this has \"O(1) space complexity\", provided of course that the program runs at all.\\n\\nSo, \"big O\" notation is not really a good description of how well a program performs.  It\\'s really a description of how that performance will scale with larger inputs.  \\n  "
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int firstMissingPositive(int[] nums) {\\n        nums=mergesort(nums);\\n        int ans=1;\\n        int i=0;\\n        while(i<nums.length && nums[i]!=1){\\n            i++;\\n        }\\n        if(i==nums.length){\\n            return ans;\\n        }\\n        while(i<nums.length-1 && nums[i]>=nums[i+1]-1){\\n            i++;\\n        }\\n        return nums[i]+1;\\n    }\\n}"
                    },
                    {
                        "username": "snehal_elkiwar",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        if(nums.length==1){\\n            if(nums[0]==1){\\n                return 2;\\n            }\\n            else{\\n                return 1;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> ans=new ArrayList<>();    \\n        HashSet<Integer>uni=new HashSet<>();\\n\\n        for(int i:nums){\\n            uni.add(i);\\n        }\\n\\n        for(int i=1;i<=nums.length+1;i++){\\n            if(uni.contains(i)){\\n                continue;\\n            }\\n            else{\\n                return i;\\n            }\\n        }\\n\\n\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "shift2023",
                        "content": "[2147483647]\\n\\nSeriously??? Why is this even a valid TC? Those of you who are wondering i.e. equivalent to [ INT_MAX ]"
                    },
                    {
                        "username": "agraavi786",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> m= new HashMap<>();\\n        Arrays.sort(nums);\\n\\n        for(int n: nums){\\n            if(n>0){\\n                 m.put(n,m.getOrDefault(m, 0)+1);\\n            }\\n        }\\n        for(int i=1;i<=m.size();i++){\\n            if(!m.containsKey(i)){\\n                return i;\\n\\n            }\\n        }\\n        return m.size()+1;\\n        \\n    }\\n}\\n\\n\\n\\n\\nwhat is the wrong with my code? can anyone tell me?"
                    },
                    {
                        "username": "cnml",
                        "content": "This one was weird, I expected it to be hard. Sometimes for hard puzzles I struggle a lot, but this one I immediately got right and my solution beats 98.8% in runtime and average in memory (O(1)). That was unexpected, but good, i guess. Time to struggle for hours on the next hard problem."
                    },
                    {
                        "username": "yush_2001",
                        "content": "It should be a medium not hard. "
                    }
                ]
            },
            {
                "id": 2053416,
                "content": [
                    {
                        "username": "topensite",
                        "content": "![image](https://assets.leetcode.com/users/images/00b86e58-5852-42de-9a89-cf5582c9f750_1634063008.47816.png)\\n"
                    },
                    {
                        "username": "allanruin",
                        "content": "when considering the problem, I write several cases to test before submit. After some trying, finally I gave up, and decided to see other peoples' idea. Then I see some claimed AC program, yes, they did got AC on leetcode, and I understand the algorithm behind them. But could you guys tell why the following cases won't pass.\\n\\n    {120,121,119,117,116,115}, // expect 118\\n    {8,7,5,4,9,12,11,10}       // expect 6\\n\\n\\nthe problem itself just stated `unsorted integer array`, and I think the two cases I list above is valid?\\n\\nThe program I tested including these:\\n\\n[\"my c solution 4ms\"][1]\\n\\n[\"my short c solution o(1) space and o(n) time\"][2]\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/42098/my-c-solution-4-ms\\n  [2]: https://leetcode.com/discuss/24013/my-short-c-solution-o-1-space-and-o-n-time"
                    },
                    {
                        "username": "Husoski",
                        "content": "In both of those cases, the first missing positive integer is 1."
                    },
                    {
                        "username": "vamsam61",
                        "content": "Is it real hard?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "uses O(1) auxiliary space How much is this space precisely? 1 int ? and thus we have to use Binary for Status  "
                    },
                    {
                        "username": "Husoski",
                        "content": "O(1) is a shorthand for \"constant\".  That means that the memory required is the same (or very nearly so) for all input sizes.  Technically, any program that achieves this has \"O(1) space complexity\", provided of course that the program runs at all.\\n\\nSo, \"big O\" notation is not really a good description of how well a program performs.  It\\'s really a description of how that performance will scale with larger inputs.  \\n  "
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int firstMissingPositive(int[] nums) {\\n        nums=mergesort(nums);\\n        int ans=1;\\n        int i=0;\\n        while(i<nums.length && nums[i]!=1){\\n            i++;\\n        }\\n        if(i==nums.length){\\n            return ans;\\n        }\\n        while(i<nums.length-1 && nums[i]>=nums[i+1]-1){\\n            i++;\\n        }\\n        return nums[i]+1;\\n    }\\n}"
                    },
                    {
                        "username": "snehal_elkiwar",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        if(nums.length==1){\\n            if(nums[0]==1){\\n                return 2;\\n            }\\n            else{\\n                return 1;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> ans=new ArrayList<>();    \\n        HashSet<Integer>uni=new HashSet<>();\\n\\n        for(int i:nums){\\n            uni.add(i);\\n        }\\n\\n        for(int i=1;i<=nums.length+1;i++){\\n            if(uni.contains(i)){\\n                continue;\\n            }\\n            else{\\n                return i;\\n            }\\n        }\\n\\n\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "shift2023",
                        "content": "[2147483647]\\n\\nSeriously??? Why is this even a valid TC? Those of you who are wondering i.e. equivalent to [ INT_MAX ]"
                    },
                    {
                        "username": "agraavi786",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> m= new HashMap<>();\\n        Arrays.sort(nums);\\n\\n        for(int n: nums){\\n            if(n>0){\\n                 m.put(n,m.getOrDefault(m, 0)+1);\\n            }\\n        }\\n        for(int i=1;i<=m.size();i++){\\n            if(!m.containsKey(i)){\\n                return i;\\n\\n            }\\n        }\\n        return m.size()+1;\\n        \\n    }\\n}\\n\\n\\n\\n\\nwhat is the wrong with my code? can anyone tell me?"
                    },
                    {
                        "username": "cnml",
                        "content": "This one was weird, I expected it to be hard. Sometimes for hard puzzles I struggle a lot, but this one I immediately got right and my solution beats 98.8% in runtime and average in memory (O(1)). That was unexpected, but good, i guess. Time to struggle for hours on the next hard problem."
                    },
                    {
                        "username": "yush_2001",
                        "content": "It should be a medium not hard. "
                    }
                ]
            },
            {
                "id": 2049691,
                "content": [
                    {
                        "username": "bashyal",
                        "content": "using O(n) space makes this problem easy or at best medium "
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t seen a submission in Python or C that *doesn\\'t* use O(n) auxiliary space.  Most \"cheat\" and overwrite the input array/list for that purpose."
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "I am not getting the question itself\\uD83D\\uDE12"
                    },
                    {
                        "username": "amit_9899",
                        "content": " Try solving this question first \\uD83D\\uDC47 \\n\\nhttps://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\\n\\nThis problem is similar to above mentioned with only difference that above problem do not contain non - positive numbers and numbers > n.\\n                                             So the Logic will be similar if we somehow succeed to ignore the numbers not in the range [1, n]."
                    },
                    {
                        "username": "erumster",
                        "content": "I don\\'t get why i\\'m getting Runtime Error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\n`\\ni\\'m returning an integer..."
                    },
                    {
                        "username": "erumster",
                        "content": "i\\'m getting `\\n\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");`\\n\\nbut i\\'m literally returning an integer...."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "people using hashmaps and sorting array knowing that question is asking O(N) time and O(1) space. if you use these things then question will lose its purpose"
                    },
                    {
                        "username": "sangameshMath",
                        "content": "What happens if there are duplicate elements in the array?\\nCan we still produce a O(n) t.c and const space solution?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "yes. a duplicate has no effect on the n in o(n) but then it also depends on what your code does."
                    },
                    {
                        "username": "user2325D",
                        "content": "I\\'m confused with 3rd test case y it is 1 not 10.\\nSo came to check discussions\\nIf it is only have to find minimum positive integer irrespective of numbers in a array\\nI will start comparing my array.\\nIll compare 1 if it is absent its the output\\nIf not will compare  2,3 so on\\nIf 4 is missing, 4 is the output. \\nIs that\\'s it? "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Are we allowed to change given array nums?\\nIn this case we actually have additional space to store results. \\n\\nDo anyone know solution with \"const vector<int>& nums\" and 0(1) extra space?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) No. Hashset does not allow O(1) extra space condition."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "U can use hashset to do this"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hello,\\n\\nI have a doubt, what does it mean by \"uses constant extra space\"? \\nCan someone please explain me this with respect to the code that I have written.\\n\\n class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        all_positive_nums = set()\\n        for i in nums:\\n            if i > 0 and i not in all_positive_nums:\\n                all_positive_nums.add(i)\\n\\n        current = 1\\n\\n        while current <= len(all_positive_nums):\\n            if current in all_positive_nums:\\n                current += 1\\n                continue\\n            else:\\n                return current\\n        \\n        return current"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "[@Anik0071](/Anik0071) ok got it, thank you so much for your valuable response. :) "
                    },
                    {
                        "username": "Anik0071",
                        "content": "constant extra space means you shouldn't use variable with n elements. suppose question has [1,2,3,4,5,6] (assuming they gave without duplicate element)  in a list and you are creating a set with the same elements here all_positive_nums {1,2,3,4,5,6} which has element  6 element. So you are creating another variable with same elements which has space complexity of O(n). what you have to do, solve this problem without this extra variable where space complexity will be O(1). [@Akshay Gole](/AKSHAY_GOLE)"
                    }
                ]
            },
            {
                "id": 2020252,
                "content": [
                    {
                        "username": "bashyal",
                        "content": "using O(n) space makes this problem easy or at best medium "
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t seen a submission in Python or C that *doesn\\'t* use O(n) auxiliary space.  Most \"cheat\" and overwrite the input array/list for that purpose."
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "I am not getting the question itself\\uD83D\\uDE12"
                    },
                    {
                        "username": "amit_9899",
                        "content": " Try solving this question first \\uD83D\\uDC47 \\n\\nhttps://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\\n\\nThis problem is similar to above mentioned with only difference that above problem do not contain non - positive numbers and numbers > n.\\n                                             So the Logic will be similar if we somehow succeed to ignore the numbers not in the range [1, n]."
                    },
                    {
                        "username": "erumster",
                        "content": "I don\\'t get why i\\'m getting Runtime Error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\n`\\ni\\'m returning an integer..."
                    },
                    {
                        "username": "erumster",
                        "content": "i\\'m getting `\\n\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");`\\n\\nbut i\\'m literally returning an integer...."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "people using hashmaps and sorting array knowing that question is asking O(N) time and O(1) space. if you use these things then question will lose its purpose"
                    },
                    {
                        "username": "sangameshMath",
                        "content": "What happens if there are duplicate elements in the array?\\nCan we still produce a O(n) t.c and const space solution?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "yes. a duplicate has no effect on the n in o(n) but then it also depends on what your code does."
                    },
                    {
                        "username": "user2325D",
                        "content": "I\\'m confused with 3rd test case y it is 1 not 10.\\nSo came to check discussions\\nIf it is only have to find minimum positive integer irrespective of numbers in a array\\nI will start comparing my array.\\nIll compare 1 if it is absent its the output\\nIf not will compare  2,3 so on\\nIf 4 is missing, 4 is the output. \\nIs that\\'s it? "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Are we allowed to change given array nums?\\nIn this case we actually have additional space to store results. \\n\\nDo anyone know solution with \"const vector<int>& nums\" and 0(1) extra space?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) No. Hashset does not allow O(1) extra space condition."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "U can use hashset to do this"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hello,\\n\\nI have a doubt, what does it mean by \"uses constant extra space\"? \\nCan someone please explain me this with respect to the code that I have written.\\n\\n class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        all_positive_nums = set()\\n        for i in nums:\\n            if i > 0 and i not in all_positive_nums:\\n                all_positive_nums.add(i)\\n\\n        current = 1\\n\\n        while current <= len(all_positive_nums):\\n            if current in all_positive_nums:\\n                current += 1\\n                continue\\n            else:\\n                return current\\n        \\n        return current"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "[@Anik0071](/Anik0071) ok got it, thank you so much for your valuable response. :) "
                    },
                    {
                        "username": "Anik0071",
                        "content": "constant extra space means you shouldn't use variable with n elements. suppose question has [1,2,3,4,5,6] (assuming they gave without duplicate element)  in a list and you are creating a set with the same elements here all_positive_nums {1,2,3,4,5,6} which has element  6 element. So you are creating another variable with same elements which has space complexity of O(n). what you have to do, solve this problem without this extra variable where space complexity will be O(1). [@Akshay Gole](/AKSHAY_GOLE)"
                    }
                ]
            },
            {
                "id": 1988682,
                "content": [
                    {
                        "username": "bashyal",
                        "content": "using O(n) space makes this problem easy or at best medium "
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t seen a submission in Python or C that *doesn\\'t* use O(n) auxiliary space.  Most \"cheat\" and overwrite the input array/list for that purpose."
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "I am not getting the question itself\\uD83D\\uDE12"
                    },
                    {
                        "username": "amit_9899",
                        "content": " Try solving this question first \\uD83D\\uDC47 \\n\\nhttps://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\\n\\nThis problem is similar to above mentioned with only difference that above problem do not contain non - positive numbers and numbers > n.\\n                                             So the Logic will be similar if we somehow succeed to ignore the numbers not in the range [1, n]."
                    },
                    {
                        "username": "erumster",
                        "content": "I don\\'t get why i\\'m getting Runtime Error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\n`\\ni\\'m returning an integer..."
                    },
                    {
                        "username": "erumster",
                        "content": "i\\'m getting `\\n\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");`\\n\\nbut i\\'m literally returning an integer...."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "people using hashmaps and sorting array knowing that question is asking O(N) time and O(1) space. if you use these things then question will lose its purpose"
                    },
                    {
                        "username": "sangameshMath",
                        "content": "What happens if there are duplicate elements in the array?\\nCan we still produce a O(n) t.c and const space solution?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "yes. a duplicate has no effect on the n in o(n) but then it also depends on what your code does."
                    },
                    {
                        "username": "user2325D",
                        "content": "I\\'m confused with 3rd test case y it is 1 not 10.\\nSo came to check discussions\\nIf it is only have to find minimum positive integer irrespective of numbers in a array\\nI will start comparing my array.\\nIll compare 1 if it is absent its the output\\nIf not will compare  2,3 so on\\nIf 4 is missing, 4 is the output. \\nIs that\\'s it? "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Are we allowed to change given array nums?\\nIn this case we actually have additional space to store results. \\n\\nDo anyone know solution with \"const vector<int>& nums\" and 0(1) extra space?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) No. Hashset does not allow O(1) extra space condition."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "U can use hashset to do this"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hello,\\n\\nI have a doubt, what does it mean by \"uses constant extra space\"? \\nCan someone please explain me this with respect to the code that I have written.\\n\\n class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        all_positive_nums = set()\\n        for i in nums:\\n            if i > 0 and i not in all_positive_nums:\\n                all_positive_nums.add(i)\\n\\n        current = 1\\n\\n        while current <= len(all_positive_nums):\\n            if current in all_positive_nums:\\n                current += 1\\n                continue\\n            else:\\n                return current\\n        \\n        return current"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "[@Anik0071](/Anik0071) ok got it, thank you so much for your valuable response. :) "
                    },
                    {
                        "username": "Anik0071",
                        "content": "constant extra space means you shouldn't use variable with n elements. suppose question has [1,2,3,4,5,6] (assuming they gave without duplicate element)  in a list and you are creating a set with the same elements here all_positive_nums {1,2,3,4,5,6} which has element  6 element. So you are creating another variable with same elements which has space complexity of O(n). what you have to do, solve this problem without this extra variable where space complexity will be O(1). [@Akshay Gole](/AKSHAY_GOLE)"
                    }
                ]
            },
            {
                "id": 1979497,
                "content": [
                    {
                        "username": "bashyal",
                        "content": "using O(n) space makes this problem easy or at best medium "
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t seen a submission in Python or C that *doesn\\'t* use O(n) auxiliary space.  Most \"cheat\" and overwrite the input array/list for that purpose."
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "I am not getting the question itself\\uD83D\\uDE12"
                    },
                    {
                        "username": "amit_9899",
                        "content": " Try solving this question first \\uD83D\\uDC47 \\n\\nhttps://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\\n\\nThis problem is similar to above mentioned with only difference that above problem do not contain non - positive numbers and numbers > n.\\n                                             So the Logic will be similar if we somehow succeed to ignore the numbers not in the range [1, n]."
                    },
                    {
                        "username": "erumster",
                        "content": "I don\\'t get why i\\'m getting Runtime Error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\n`\\ni\\'m returning an integer..."
                    },
                    {
                        "username": "erumster",
                        "content": "i\\'m getting `\\n\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");`\\n\\nbut i\\'m literally returning an integer...."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "people using hashmaps and sorting array knowing that question is asking O(N) time and O(1) space. if you use these things then question will lose its purpose"
                    },
                    {
                        "username": "sangameshMath",
                        "content": "What happens if there are duplicate elements in the array?\\nCan we still produce a O(n) t.c and const space solution?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "yes. a duplicate has no effect on the n in o(n) but then it also depends on what your code does."
                    },
                    {
                        "username": "user2325D",
                        "content": "I\\'m confused with 3rd test case y it is 1 not 10.\\nSo came to check discussions\\nIf it is only have to find minimum positive integer irrespective of numbers in a array\\nI will start comparing my array.\\nIll compare 1 if it is absent its the output\\nIf not will compare  2,3 so on\\nIf 4 is missing, 4 is the output. \\nIs that\\'s it? "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Are we allowed to change given array nums?\\nIn this case we actually have additional space to store results. \\n\\nDo anyone know solution with \"const vector<int>& nums\" and 0(1) extra space?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) No. Hashset does not allow O(1) extra space condition."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "U can use hashset to do this"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hello,\\n\\nI have a doubt, what does it mean by \"uses constant extra space\"? \\nCan someone please explain me this with respect to the code that I have written.\\n\\n class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        all_positive_nums = set()\\n        for i in nums:\\n            if i > 0 and i not in all_positive_nums:\\n                all_positive_nums.add(i)\\n\\n        current = 1\\n\\n        while current <= len(all_positive_nums):\\n            if current in all_positive_nums:\\n                current += 1\\n                continue\\n            else:\\n                return current\\n        \\n        return current"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "[@Anik0071](/Anik0071) ok got it, thank you so much for your valuable response. :) "
                    },
                    {
                        "username": "Anik0071",
                        "content": "constant extra space means you shouldn't use variable with n elements. suppose question has [1,2,3,4,5,6] (assuming they gave without duplicate element)  in a list and you are creating a set with the same elements here all_positive_nums {1,2,3,4,5,6} which has element  6 element. So you are creating another variable with same elements which has space complexity of O(n). what you have to do, solve this problem without this extra variable where space complexity will be O(1). [@Akshay Gole](/AKSHAY_GOLE)"
                    }
                ]
            },
            {
                "id": 1979486,
                "content": [
                    {
                        "username": "bashyal",
                        "content": "using O(n) space makes this problem easy or at best medium "
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t seen a submission in Python or C that *doesn\\'t* use O(n) auxiliary space.  Most \"cheat\" and overwrite the input array/list for that purpose."
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "I am not getting the question itself\\uD83D\\uDE12"
                    },
                    {
                        "username": "amit_9899",
                        "content": " Try solving this question first \\uD83D\\uDC47 \\n\\nhttps://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\\n\\nThis problem is similar to above mentioned with only difference that above problem do not contain non - positive numbers and numbers > n.\\n                                             So the Logic will be similar if we somehow succeed to ignore the numbers not in the range [1, n]."
                    },
                    {
                        "username": "erumster",
                        "content": "I don\\'t get why i\\'m getting Runtime Error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\n`\\ni\\'m returning an integer..."
                    },
                    {
                        "username": "erumster",
                        "content": "i\\'m getting `\\n\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");`\\n\\nbut i\\'m literally returning an integer...."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "people using hashmaps and sorting array knowing that question is asking O(N) time and O(1) space. if you use these things then question will lose its purpose"
                    },
                    {
                        "username": "sangameshMath",
                        "content": "What happens if there are duplicate elements in the array?\\nCan we still produce a O(n) t.c and const space solution?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "yes. a duplicate has no effect on the n in o(n) but then it also depends on what your code does."
                    },
                    {
                        "username": "user2325D",
                        "content": "I\\'m confused with 3rd test case y it is 1 not 10.\\nSo came to check discussions\\nIf it is only have to find minimum positive integer irrespective of numbers in a array\\nI will start comparing my array.\\nIll compare 1 if it is absent its the output\\nIf not will compare  2,3 so on\\nIf 4 is missing, 4 is the output. \\nIs that\\'s it? "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Are we allowed to change given array nums?\\nIn this case we actually have additional space to store results. \\n\\nDo anyone know solution with \"const vector<int>& nums\" and 0(1) extra space?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) No. Hashset does not allow O(1) extra space condition."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "U can use hashset to do this"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hello,\\n\\nI have a doubt, what does it mean by \"uses constant extra space\"? \\nCan someone please explain me this with respect to the code that I have written.\\n\\n class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        all_positive_nums = set()\\n        for i in nums:\\n            if i > 0 and i not in all_positive_nums:\\n                all_positive_nums.add(i)\\n\\n        current = 1\\n\\n        while current <= len(all_positive_nums):\\n            if current in all_positive_nums:\\n                current += 1\\n                continue\\n            else:\\n                return current\\n        \\n        return current"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "[@Anik0071](/Anik0071) ok got it, thank you so much for your valuable response. :) "
                    },
                    {
                        "username": "Anik0071",
                        "content": "constant extra space means you shouldn't use variable with n elements. suppose question has [1,2,3,4,5,6] (assuming they gave without duplicate element)  in a list and you are creating a set with the same elements here all_positive_nums {1,2,3,4,5,6} which has element  6 element. So you are creating another variable with same elements which has space complexity of O(n). what you have to do, solve this problem without this extra variable where space complexity will be O(1). [@Akshay Gole](/AKSHAY_GOLE)"
                    }
                ]
            },
            {
                "id": 1978604,
                "content": [
                    {
                        "username": "bashyal",
                        "content": "using O(n) space makes this problem easy or at best medium "
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t seen a submission in Python or C that *doesn\\'t* use O(n) auxiliary space.  Most \"cheat\" and overwrite the input array/list for that purpose."
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "I am not getting the question itself\\uD83D\\uDE12"
                    },
                    {
                        "username": "amit_9899",
                        "content": " Try solving this question first \\uD83D\\uDC47 \\n\\nhttps://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\\n\\nThis problem is similar to above mentioned with only difference that above problem do not contain non - positive numbers and numbers > n.\\n                                             So the Logic will be similar if we somehow succeed to ignore the numbers not in the range [1, n]."
                    },
                    {
                        "username": "erumster",
                        "content": "I don\\'t get why i\\'m getting Runtime Error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\n`\\ni\\'m returning an integer..."
                    },
                    {
                        "username": "erumster",
                        "content": "i\\'m getting `\\n\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");`\\n\\nbut i\\'m literally returning an integer...."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "people using hashmaps and sorting array knowing that question is asking O(N) time and O(1) space. if you use these things then question will lose its purpose"
                    },
                    {
                        "username": "sangameshMath",
                        "content": "What happens if there are duplicate elements in the array?\\nCan we still produce a O(n) t.c and const space solution?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "yes. a duplicate has no effect on the n in o(n) but then it also depends on what your code does."
                    },
                    {
                        "username": "user2325D",
                        "content": "I\\'m confused with 3rd test case y it is 1 not 10.\\nSo came to check discussions\\nIf it is only have to find minimum positive integer irrespective of numbers in a array\\nI will start comparing my array.\\nIll compare 1 if it is absent its the output\\nIf not will compare  2,3 so on\\nIf 4 is missing, 4 is the output. \\nIs that\\'s it? "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Are we allowed to change given array nums?\\nIn this case we actually have additional space to store results. \\n\\nDo anyone know solution with \"const vector<int>& nums\" and 0(1) extra space?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) No. Hashset does not allow O(1) extra space condition."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "U can use hashset to do this"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hello,\\n\\nI have a doubt, what does it mean by \"uses constant extra space\"? \\nCan someone please explain me this with respect to the code that I have written.\\n\\n class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        all_positive_nums = set()\\n        for i in nums:\\n            if i > 0 and i not in all_positive_nums:\\n                all_positive_nums.add(i)\\n\\n        current = 1\\n\\n        while current <= len(all_positive_nums):\\n            if current in all_positive_nums:\\n                current += 1\\n                continue\\n            else:\\n                return current\\n        \\n        return current"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "[@Anik0071](/Anik0071) ok got it, thank you so much for your valuable response. :) "
                    },
                    {
                        "username": "Anik0071",
                        "content": "constant extra space means you shouldn't use variable with n elements. suppose question has [1,2,3,4,5,6] (assuming they gave without duplicate element)  in a list and you are creating a set with the same elements here all_positive_nums {1,2,3,4,5,6} which has element  6 element. So you are creating another variable with same elements which has space complexity of O(n). what you have to do, solve this problem without this extra variable where space complexity will be O(1). [@Akshay Gole](/AKSHAY_GOLE)"
                    }
                ]
            },
            {
                "id": 1967926,
                "content": [
                    {
                        "username": "bashyal",
                        "content": "using O(n) space makes this problem easy or at best medium "
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t seen a submission in Python or C that *doesn\\'t* use O(n) auxiliary space.  Most \"cheat\" and overwrite the input array/list for that purpose."
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "I am not getting the question itself\\uD83D\\uDE12"
                    },
                    {
                        "username": "amit_9899",
                        "content": " Try solving this question first \\uD83D\\uDC47 \\n\\nhttps://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\\n\\nThis problem is similar to above mentioned with only difference that above problem do not contain non - positive numbers and numbers > n.\\n                                             So the Logic will be similar if we somehow succeed to ignore the numbers not in the range [1, n]."
                    },
                    {
                        "username": "erumster",
                        "content": "I don\\'t get why i\\'m getting Runtime Error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\n`\\ni\\'m returning an integer..."
                    },
                    {
                        "username": "erumster",
                        "content": "i\\'m getting `\\n\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");`\\n\\nbut i\\'m literally returning an integer...."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "people using hashmaps and sorting array knowing that question is asking O(N) time and O(1) space. if you use these things then question will lose its purpose"
                    },
                    {
                        "username": "sangameshMath",
                        "content": "What happens if there are duplicate elements in the array?\\nCan we still produce a O(n) t.c and const space solution?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "yes. a duplicate has no effect on the n in o(n) but then it also depends on what your code does."
                    },
                    {
                        "username": "user2325D",
                        "content": "I\\'m confused with 3rd test case y it is 1 not 10.\\nSo came to check discussions\\nIf it is only have to find minimum positive integer irrespective of numbers in a array\\nI will start comparing my array.\\nIll compare 1 if it is absent its the output\\nIf not will compare  2,3 so on\\nIf 4 is missing, 4 is the output. \\nIs that\\'s it? "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Are we allowed to change given array nums?\\nIn this case we actually have additional space to store results. \\n\\nDo anyone know solution with \"const vector<int>& nums\" and 0(1) extra space?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) No. Hashset does not allow O(1) extra space condition."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "U can use hashset to do this"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hello,\\n\\nI have a doubt, what does it mean by \"uses constant extra space\"? \\nCan someone please explain me this with respect to the code that I have written.\\n\\n class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        all_positive_nums = set()\\n        for i in nums:\\n            if i > 0 and i not in all_positive_nums:\\n                all_positive_nums.add(i)\\n\\n        current = 1\\n\\n        while current <= len(all_positive_nums):\\n            if current in all_positive_nums:\\n                current += 1\\n                continue\\n            else:\\n                return current\\n        \\n        return current"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "[@Anik0071](/Anik0071) ok got it, thank you so much for your valuable response. :) "
                    },
                    {
                        "username": "Anik0071",
                        "content": "constant extra space means you shouldn't use variable with n elements. suppose question has [1,2,3,4,5,6] (assuming they gave without duplicate element)  in a list and you are creating a set with the same elements here all_positive_nums {1,2,3,4,5,6} which has element  6 element. So you are creating another variable with same elements which has space complexity of O(n). what you have to do, solve this problem without this extra variable where space complexity will be O(1). [@Akshay Gole](/AKSHAY_GOLE)"
                    }
                ]
            },
            {
                "id": 1940061,
                "content": [
                    {
                        "username": "bashyal",
                        "content": "using O(n) space makes this problem easy or at best medium "
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t seen a submission in Python or C that *doesn\\'t* use O(n) auxiliary space.  Most \"cheat\" and overwrite the input array/list for that purpose."
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "I am not getting the question itself\\uD83D\\uDE12"
                    },
                    {
                        "username": "amit_9899",
                        "content": " Try solving this question first \\uD83D\\uDC47 \\n\\nhttps://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\\n\\nThis problem is similar to above mentioned with only difference that above problem do not contain non - positive numbers and numbers > n.\\n                                             So the Logic will be similar if we somehow succeed to ignore the numbers not in the range [1, n]."
                    },
                    {
                        "username": "erumster",
                        "content": "I don\\'t get why i\\'m getting Runtime Error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\n`\\ni\\'m returning an integer..."
                    },
                    {
                        "username": "erumster",
                        "content": "i\\'m getting `\\n\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");`\\n\\nbut i\\'m literally returning an integer...."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "people using hashmaps and sorting array knowing that question is asking O(N) time and O(1) space. if you use these things then question will lose its purpose"
                    },
                    {
                        "username": "sangameshMath",
                        "content": "What happens if there are duplicate elements in the array?\\nCan we still produce a O(n) t.c and const space solution?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "yes. a duplicate has no effect on the n in o(n) but then it also depends on what your code does."
                    },
                    {
                        "username": "user2325D",
                        "content": "I\\'m confused with 3rd test case y it is 1 not 10.\\nSo came to check discussions\\nIf it is only have to find minimum positive integer irrespective of numbers in a array\\nI will start comparing my array.\\nIll compare 1 if it is absent its the output\\nIf not will compare  2,3 so on\\nIf 4 is missing, 4 is the output. \\nIs that\\'s it? "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Are we allowed to change given array nums?\\nIn this case we actually have additional space to store results. \\n\\nDo anyone know solution with \"const vector<int>& nums\" and 0(1) extra space?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) No. Hashset does not allow O(1) extra space condition."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "U can use hashset to do this"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hello,\\n\\nI have a doubt, what does it mean by \"uses constant extra space\"? \\nCan someone please explain me this with respect to the code that I have written.\\n\\n class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        all_positive_nums = set()\\n        for i in nums:\\n            if i > 0 and i not in all_positive_nums:\\n                all_positive_nums.add(i)\\n\\n        current = 1\\n\\n        while current <= len(all_positive_nums):\\n            if current in all_positive_nums:\\n                current += 1\\n                continue\\n            else:\\n                return current\\n        \\n        return current"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "[@Anik0071](/Anik0071) ok got it, thank you so much for your valuable response. :) "
                    },
                    {
                        "username": "Anik0071",
                        "content": "constant extra space means you shouldn't use variable with n elements. suppose question has [1,2,3,4,5,6] (assuming they gave without duplicate element)  in a list and you are creating a set with the same elements here all_positive_nums {1,2,3,4,5,6} which has element  6 element. So you are creating another variable with same elements which has space complexity of O(n). what you have to do, solve this problem without this extra variable where space complexity will be O(1). [@Akshay Gole](/AKSHAY_GOLE)"
                    }
                ]
            },
            {
                "id": 1939535,
                "content": [
                    {
                        "username": "bashyal",
                        "content": "using O(n) space makes this problem easy or at best medium "
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t seen a submission in Python or C that *doesn\\'t* use O(n) auxiliary space.  Most \"cheat\" and overwrite the input array/list for that purpose."
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "I am not getting the question itself\\uD83D\\uDE12"
                    },
                    {
                        "username": "amit_9899",
                        "content": " Try solving this question first \\uD83D\\uDC47 \\n\\nhttps://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\\n\\nThis problem is similar to above mentioned with only difference that above problem do not contain non - positive numbers and numbers > n.\\n                                             So the Logic will be similar if we somehow succeed to ignore the numbers not in the range [1, n]."
                    },
                    {
                        "username": "erumster",
                        "content": "I don\\'t get why i\\'m getting Runtime Error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\n`\\ni\\'m returning an integer..."
                    },
                    {
                        "username": "erumster",
                        "content": "i\\'m getting `\\n\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");`\\n\\nbut i\\'m literally returning an integer...."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "people using hashmaps and sorting array knowing that question is asking O(N) time and O(1) space. if you use these things then question will lose its purpose"
                    },
                    {
                        "username": "sangameshMath",
                        "content": "What happens if there are duplicate elements in the array?\\nCan we still produce a O(n) t.c and const space solution?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "yes. a duplicate has no effect on the n in o(n) but then it also depends on what your code does."
                    },
                    {
                        "username": "user2325D",
                        "content": "I\\'m confused with 3rd test case y it is 1 not 10.\\nSo came to check discussions\\nIf it is only have to find minimum positive integer irrespective of numbers in a array\\nI will start comparing my array.\\nIll compare 1 if it is absent its the output\\nIf not will compare  2,3 so on\\nIf 4 is missing, 4 is the output. \\nIs that\\'s it? "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Are we allowed to change given array nums?\\nIn this case we actually have additional space to store results. \\n\\nDo anyone know solution with \"const vector<int>& nums\" and 0(1) extra space?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) No. Hashset does not allow O(1) extra space condition."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "U can use hashset to do this"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hello,\\n\\nI have a doubt, what does it mean by \"uses constant extra space\"? \\nCan someone please explain me this with respect to the code that I have written.\\n\\n class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        all_positive_nums = set()\\n        for i in nums:\\n            if i > 0 and i not in all_positive_nums:\\n                all_positive_nums.add(i)\\n\\n        current = 1\\n\\n        while current <= len(all_positive_nums):\\n            if current in all_positive_nums:\\n                current += 1\\n                continue\\n            else:\\n                return current\\n        \\n        return current"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "[@Anik0071](/Anik0071) ok got it, thank you so much for your valuable response. :) "
                    },
                    {
                        "username": "Anik0071",
                        "content": "constant extra space means you shouldn't use variable with n elements. suppose question has [1,2,3,4,5,6] (assuming they gave without duplicate element)  in a list and you are creating a set with the same elements here all_positive_nums {1,2,3,4,5,6} which has element  6 element. So you are creating another variable with same elements which has space complexity of O(n). what you have to do, solve this problem without this extra variable where space complexity will be O(1). [@Akshay Gole](/AKSHAY_GOLE)"
                    }
                ]
            },
            {
                "id": 1935217,
                "content": [
                    {
                        "username": "bashyal",
                        "content": "using O(n) space makes this problem easy or at best medium "
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t seen a submission in Python or C that *doesn\\'t* use O(n) auxiliary space.  Most \"cheat\" and overwrite the input array/list for that purpose."
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "I am not getting the question itself\\uD83D\\uDE12"
                    },
                    {
                        "username": "amit_9899",
                        "content": " Try solving this question first \\uD83D\\uDC47 \\n\\nhttps://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\\n\\nThis problem is similar to above mentioned with only difference that above problem do not contain non - positive numbers and numbers > n.\\n                                             So the Logic will be similar if we somehow succeed to ignore the numbers not in the range [1, n]."
                    },
                    {
                        "username": "erumster",
                        "content": "I don\\'t get why i\\'m getting Runtime Error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\n`\\ni\\'m returning an integer..."
                    },
                    {
                        "username": "erumster",
                        "content": "i\\'m getting `\\n\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");`\\n\\nbut i\\'m literally returning an integer...."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "people using hashmaps and sorting array knowing that question is asking O(N) time and O(1) space. if you use these things then question will lose its purpose"
                    },
                    {
                        "username": "sangameshMath",
                        "content": "What happens if there are duplicate elements in the array?\\nCan we still produce a O(n) t.c and const space solution?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "yes. a duplicate has no effect on the n in o(n) but then it also depends on what your code does."
                    },
                    {
                        "username": "user2325D",
                        "content": "I\\'m confused with 3rd test case y it is 1 not 10.\\nSo came to check discussions\\nIf it is only have to find minimum positive integer irrespective of numbers in a array\\nI will start comparing my array.\\nIll compare 1 if it is absent its the output\\nIf not will compare  2,3 so on\\nIf 4 is missing, 4 is the output. \\nIs that\\'s it? "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Are we allowed to change given array nums?\\nIn this case we actually have additional space to store results. \\n\\nDo anyone know solution with \"const vector<int>& nums\" and 0(1) extra space?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) No. Hashset does not allow O(1) extra space condition."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "U can use hashset to do this"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hello,\\n\\nI have a doubt, what does it mean by \"uses constant extra space\"? \\nCan someone please explain me this with respect to the code that I have written.\\n\\n class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        all_positive_nums = set()\\n        for i in nums:\\n            if i > 0 and i not in all_positive_nums:\\n                all_positive_nums.add(i)\\n\\n        current = 1\\n\\n        while current <= len(all_positive_nums):\\n            if current in all_positive_nums:\\n                current += 1\\n                continue\\n            else:\\n                return current\\n        \\n        return current"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "[@Anik0071](/Anik0071) ok got it, thank you so much for your valuable response. :) "
                    },
                    {
                        "username": "Anik0071",
                        "content": "constant extra space means you shouldn't use variable with n elements. suppose question has [1,2,3,4,5,6] (assuming they gave without duplicate element)  in a list and you are creating a set with the same elements here all_positive_nums {1,2,3,4,5,6} which has element  6 element. So you are creating another variable with same elements which has space complexity of O(n). what you have to do, solve this problem without this extra variable where space complexity will be O(1). [@Akshay Gole](/AKSHAY_GOLE)"
                    }
                ]
            },
            {
                "id": 1931668,
                "content": [
                    {
                        "username": "johnnychang",
                        "content": "This is a very interesting problem that can be solved with cyclic sort. I found this article very helpful for understanding the pattern: https://leetcode.com/discuss/study-guide/2958275/cyclic-sort-important-pattern"
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "counting sort\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is interesting comparing algorithms. I also hit on the idea of moving each element in the array into its correct position then finding the first position where the element is out of place.\\n\\nThe problem is that some elements need more than 1 jump to get into the correct position and that created all sorts of edge cases that I had to come up with logic for it.\\n\\nIt didn\\'t occur to me that I could mark each position as negative to indicate a found index. It would have simplified the logic if it did."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why say constant space, but related topics is hash table? "
                    },
                    {
                        "username": "Lakshman_11",
                        "content": "can the elements be repeating"
                    },
                    {
                        "username": "dheeraj3859",
                        "content": "For a linear algorithm we need to sort it using bucket sort and then do a linear search for the missing positive number"
                    },
                    {
                        "username": "charanarc3",
                        "content": "can anyone provide me the proof of time complexity of searching in dictionaries in python"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the time complexity of this code?\\n`    for i in range(index, len(nums)):\\n            # print(nums,data,nums[i])\\n            if data not in nums:\\n                return data\\n            data = data +1\\n        return data`\\n\\nfirst for loop is looping through n number and on the 1st if used \"in\" operator this operation also has O(n) complexity. but the chatgpt and bard says this code time complexity is O(n), but my understanding is it may be O(n^2).\\n\\nPasting the chatgpt response \\n<<<-------------------->>>\\nThe time complexity of the provided code is O(n), where n is the number of elements in the nums list.\\n\\nThe for loop iterates over the elements in nums starting from the index variable until the end of the list. In the worst-case scenario, where index is 0, the loop will iterate through all n elements of the nums list.\\n\\nInside the loop, the code checks if data is not in the nums list using the in operator. This operation has a time complexity of O(n) since it potentially needs to compare data with each element of nums.\\n\\nIf the data is not in nums, the code returns data immediately, terminating the loop. Otherwise, if the loop completes without returning, data is incremented by 1 and the loop continues.\\n\\nSince the loop iterates through all n elements of the nums list, the time complexity of the code is O(n).\\n\\nIt\\'s worth noting that the actual time complexity may be lower if the loop is terminated early when data is not found in nums. However, in the worst-case scenario where data is larger than all elements in nums, the code will iterate through all n elements. Therefore, the overall time complexity is O(n).\\n<<<-------------------------->>>\\n\\n "
                    },
                    {
                        "username": "atul1503",
                        "content": "What kind of witchcraft is going on in python with the swap algorithm?"
                    },
                    {
                        "username": "Konada_sunita",
                        "content": "Hi,\\n\\ni have doubt that why my program is exceeding the time limit but the some what similar program is not exceeding the time limit . Could anyone please help me with this ?Please let me know what is wrong with my program as my program is passing for all test case except the below one for which is giving as time limit exceeding \\n\\nBelow Test case is getting failed for my program:\\n__________________________________________________\\n[100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,99988,99987,99986,99985,99984,99983,99982,99981,99980,99979,99978,99977,99976,99975,99974,99973,99972,99971,99970,99969,99968,99967,99966,99965,99964,99963,99962,99961,99960,99959,99958,99957,99956,99955,99954,99953,99952,99951,99950,99949,99948,99947,99946,99945,99944,99943,99942,99941,99940,99939,99938,99937,99936,99935,99934,99933,99932,99931,99930,99929,99928,99927,99926,99925,99924,99923,99922--------,4,3,2,1]\\n\\n\\n______________________________________________________________________\\nBelow is my program which is exceeding time limit :\\n_____________________________________________________\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        List<Integer> list=new ArrayList<Integer>();\\n        for(int x:nums){\\n            list.add(x);\\n        }\\n        for(int i=1;i<=nums.length;i++){\\n           if(list.contains(i)){\\n               continue;\\n           }else{\\n                return i;\\n               \\n           }\\n        }\\n        return nums.length+1;\\n    } \\n    \\n}\\n_________________________________________________________________________\\n\\n. Below is similar program but with different interface :\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\nHashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n_______________________________________________________________________________"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "you are performing O(n^n) contains is iterating through the array internally"
                    }
                ]
            },
            {
                "id": 1928904,
                "content": [
                    {
                        "username": "johnnychang",
                        "content": "This is a very interesting problem that can be solved with cyclic sort. I found this article very helpful for understanding the pattern: https://leetcode.com/discuss/study-guide/2958275/cyclic-sort-important-pattern"
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "counting sort\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is interesting comparing algorithms. I also hit on the idea of moving each element in the array into its correct position then finding the first position where the element is out of place.\\n\\nThe problem is that some elements need more than 1 jump to get into the correct position and that created all sorts of edge cases that I had to come up with logic for it.\\n\\nIt didn\\'t occur to me that I could mark each position as negative to indicate a found index. It would have simplified the logic if it did."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why say constant space, but related topics is hash table? "
                    },
                    {
                        "username": "Lakshman_11",
                        "content": "can the elements be repeating"
                    },
                    {
                        "username": "dheeraj3859",
                        "content": "For a linear algorithm we need to sort it using bucket sort and then do a linear search for the missing positive number"
                    },
                    {
                        "username": "charanarc3",
                        "content": "can anyone provide me the proof of time complexity of searching in dictionaries in python"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the time complexity of this code?\\n`    for i in range(index, len(nums)):\\n            # print(nums,data,nums[i])\\n            if data not in nums:\\n                return data\\n            data = data +1\\n        return data`\\n\\nfirst for loop is looping through n number and on the 1st if used \"in\" operator this operation also has O(n) complexity. but the chatgpt and bard says this code time complexity is O(n), but my understanding is it may be O(n^2).\\n\\nPasting the chatgpt response \\n<<<-------------------->>>\\nThe time complexity of the provided code is O(n), where n is the number of elements in the nums list.\\n\\nThe for loop iterates over the elements in nums starting from the index variable until the end of the list. In the worst-case scenario, where index is 0, the loop will iterate through all n elements of the nums list.\\n\\nInside the loop, the code checks if data is not in the nums list using the in operator. This operation has a time complexity of O(n) since it potentially needs to compare data with each element of nums.\\n\\nIf the data is not in nums, the code returns data immediately, terminating the loop. Otherwise, if the loop completes without returning, data is incremented by 1 and the loop continues.\\n\\nSince the loop iterates through all n elements of the nums list, the time complexity of the code is O(n).\\n\\nIt\\'s worth noting that the actual time complexity may be lower if the loop is terminated early when data is not found in nums. However, in the worst-case scenario where data is larger than all elements in nums, the code will iterate through all n elements. Therefore, the overall time complexity is O(n).\\n<<<-------------------------->>>\\n\\n "
                    },
                    {
                        "username": "atul1503",
                        "content": "What kind of witchcraft is going on in python with the swap algorithm?"
                    },
                    {
                        "username": "Konada_sunita",
                        "content": "Hi,\\n\\ni have doubt that why my program is exceeding the time limit but the some what similar program is not exceeding the time limit . Could anyone please help me with this ?Please let me know what is wrong with my program as my program is passing for all test case except the below one for which is giving as time limit exceeding \\n\\nBelow Test case is getting failed for my program:\\n__________________________________________________\\n[100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,99988,99987,99986,99985,99984,99983,99982,99981,99980,99979,99978,99977,99976,99975,99974,99973,99972,99971,99970,99969,99968,99967,99966,99965,99964,99963,99962,99961,99960,99959,99958,99957,99956,99955,99954,99953,99952,99951,99950,99949,99948,99947,99946,99945,99944,99943,99942,99941,99940,99939,99938,99937,99936,99935,99934,99933,99932,99931,99930,99929,99928,99927,99926,99925,99924,99923,99922--------,4,3,2,1]\\n\\n\\n______________________________________________________________________\\nBelow is my program which is exceeding time limit :\\n_____________________________________________________\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        List<Integer> list=new ArrayList<Integer>();\\n        for(int x:nums){\\n            list.add(x);\\n        }\\n        for(int i=1;i<=nums.length;i++){\\n           if(list.contains(i)){\\n               continue;\\n           }else{\\n                return i;\\n               \\n           }\\n        }\\n        return nums.length+1;\\n    } \\n    \\n}\\n_________________________________________________________________________\\n\\n. Below is similar program but with different interface :\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\nHashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n_______________________________________________________________________________"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "you are performing O(n^n) contains is iterating through the array internally"
                    }
                ]
            },
            {
                "id": 1922112,
                "content": [
                    {
                        "username": "johnnychang",
                        "content": "This is a very interesting problem that can be solved with cyclic sort. I found this article very helpful for understanding the pattern: https://leetcode.com/discuss/study-guide/2958275/cyclic-sort-important-pattern"
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "counting sort\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is interesting comparing algorithms. I also hit on the idea of moving each element in the array into its correct position then finding the first position where the element is out of place.\\n\\nThe problem is that some elements need more than 1 jump to get into the correct position and that created all sorts of edge cases that I had to come up with logic for it.\\n\\nIt didn\\'t occur to me that I could mark each position as negative to indicate a found index. It would have simplified the logic if it did."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why say constant space, but related topics is hash table? "
                    },
                    {
                        "username": "Lakshman_11",
                        "content": "can the elements be repeating"
                    },
                    {
                        "username": "dheeraj3859",
                        "content": "For a linear algorithm we need to sort it using bucket sort and then do a linear search for the missing positive number"
                    },
                    {
                        "username": "charanarc3",
                        "content": "can anyone provide me the proof of time complexity of searching in dictionaries in python"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the time complexity of this code?\\n`    for i in range(index, len(nums)):\\n            # print(nums,data,nums[i])\\n            if data not in nums:\\n                return data\\n            data = data +1\\n        return data`\\n\\nfirst for loop is looping through n number and on the 1st if used \"in\" operator this operation also has O(n) complexity. but the chatgpt and bard says this code time complexity is O(n), but my understanding is it may be O(n^2).\\n\\nPasting the chatgpt response \\n<<<-------------------->>>\\nThe time complexity of the provided code is O(n), where n is the number of elements in the nums list.\\n\\nThe for loop iterates over the elements in nums starting from the index variable until the end of the list. In the worst-case scenario, where index is 0, the loop will iterate through all n elements of the nums list.\\n\\nInside the loop, the code checks if data is not in the nums list using the in operator. This operation has a time complexity of O(n) since it potentially needs to compare data with each element of nums.\\n\\nIf the data is not in nums, the code returns data immediately, terminating the loop. Otherwise, if the loop completes without returning, data is incremented by 1 and the loop continues.\\n\\nSince the loop iterates through all n elements of the nums list, the time complexity of the code is O(n).\\n\\nIt\\'s worth noting that the actual time complexity may be lower if the loop is terminated early when data is not found in nums. However, in the worst-case scenario where data is larger than all elements in nums, the code will iterate through all n elements. Therefore, the overall time complexity is O(n).\\n<<<-------------------------->>>\\n\\n "
                    },
                    {
                        "username": "atul1503",
                        "content": "What kind of witchcraft is going on in python with the swap algorithm?"
                    },
                    {
                        "username": "Konada_sunita",
                        "content": "Hi,\\n\\ni have doubt that why my program is exceeding the time limit but the some what similar program is not exceeding the time limit . Could anyone please help me with this ?Please let me know what is wrong with my program as my program is passing for all test case except the below one for which is giving as time limit exceeding \\n\\nBelow Test case is getting failed for my program:\\n__________________________________________________\\n[100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,99988,99987,99986,99985,99984,99983,99982,99981,99980,99979,99978,99977,99976,99975,99974,99973,99972,99971,99970,99969,99968,99967,99966,99965,99964,99963,99962,99961,99960,99959,99958,99957,99956,99955,99954,99953,99952,99951,99950,99949,99948,99947,99946,99945,99944,99943,99942,99941,99940,99939,99938,99937,99936,99935,99934,99933,99932,99931,99930,99929,99928,99927,99926,99925,99924,99923,99922--------,4,3,2,1]\\n\\n\\n______________________________________________________________________\\nBelow is my program which is exceeding time limit :\\n_____________________________________________________\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        List<Integer> list=new ArrayList<Integer>();\\n        for(int x:nums){\\n            list.add(x);\\n        }\\n        for(int i=1;i<=nums.length;i++){\\n           if(list.contains(i)){\\n               continue;\\n           }else{\\n                return i;\\n               \\n           }\\n        }\\n        return nums.length+1;\\n    } \\n    \\n}\\n_________________________________________________________________________\\n\\n. Below is similar program but with different interface :\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\nHashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n_______________________________________________________________________________"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "you are performing O(n^n) contains is iterating through the array internally"
                    }
                ]
            },
            {
                "id": 1920360,
                "content": [
                    {
                        "username": "johnnychang",
                        "content": "This is a very interesting problem that can be solved with cyclic sort. I found this article very helpful for understanding the pattern: https://leetcode.com/discuss/study-guide/2958275/cyclic-sort-important-pattern"
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "counting sort\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is interesting comparing algorithms. I also hit on the idea of moving each element in the array into its correct position then finding the first position where the element is out of place.\\n\\nThe problem is that some elements need more than 1 jump to get into the correct position and that created all sorts of edge cases that I had to come up with logic for it.\\n\\nIt didn\\'t occur to me that I could mark each position as negative to indicate a found index. It would have simplified the logic if it did."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why say constant space, but related topics is hash table? "
                    },
                    {
                        "username": "Lakshman_11",
                        "content": "can the elements be repeating"
                    },
                    {
                        "username": "dheeraj3859",
                        "content": "For a linear algorithm we need to sort it using bucket sort and then do a linear search for the missing positive number"
                    },
                    {
                        "username": "charanarc3",
                        "content": "can anyone provide me the proof of time complexity of searching in dictionaries in python"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the time complexity of this code?\\n`    for i in range(index, len(nums)):\\n            # print(nums,data,nums[i])\\n            if data not in nums:\\n                return data\\n            data = data +1\\n        return data`\\n\\nfirst for loop is looping through n number and on the 1st if used \"in\" operator this operation also has O(n) complexity. but the chatgpt and bard says this code time complexity is O(n), but my understanding is it may be O(n^2).\\n\\nPasting the chatgpt response \\n<<<-------------------->>>\\nThe time complexity of the provided code is O(n), where n is the number of elements in the nums list.\\n\\nThe for loop iterates over the elements in nums starting from the index variable until the end of the list. In the worst-case scenario, where index is 0, the loop will iterate through all n elements of the nums list.\\n\\nInside the loop, the code checks if data is not in the nums list using the in operator. This operation has a time complexity of O(n) since it potentially needs to compare data with each element of nums.\\n\\nIf the data is not in nums, the code returns data immediately, terminating the loop. Otherwise, if the loop completes without returning, data is incremented by 1 and the loop continues.\\n\\nSince the loop iterates through all n elements of the nums list, the time complexity of the code is O(n).\\n\\nIt\\'s worth noting that the actual time complexity may be lower if the loop is terminated early when data is not found in nums. However, in the worst-case scenario where data is larger than all elements in nums, the code will iterate through all n elements. Therefore, the overall time complexity is O(n).\\n<<<-------------------------->>>\\n\\n "
                    },
                    {
                        "username": "atul1503",
                        "content": "What kind of witchcraft is going on in python with the swap algorithm?"
                    },
                    {
                        "username": "Konada_sunita",
                        "content": "Hi,\\n\\ni have doubt that why my program is exceeding the time limit but the some what similar program is not exceeding the time limit . Could anyone please help me with this ?Please let me know what is wrong with my program as my program is passing for all test case except the below one for which is giving as time limit exceeding \\n\\nBelow Test case is getting failed for my program:\\n__________________________________________________\\n[100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,99988,99987,99986,99985,99984,99983,99982,99981,99980,99979,99978,99977,99976,99975,99974,99973,99972,99971,99970,99969,99968,99967,99966,99965,99964,99963,99962,99961,99960,99959,99958,99957,99956,99955,99954,99953,99952,99951,99950,99949,99948,99947,99946,99945,99944,99943,99942,99941,99940,99939,99938,99937,99936,99935,99934,99933,99932,99931,99930,99929,99928,99927,99926,99925,99924,99923,99922--------,4,3,2,1]\\n\\n\\n______________________________________________________________________\\nBelow is my program which is exceeding time limit :\\n_____________________________________________________\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        List<Integer> list=new ArrayList<Integer>();\\n        for(int x:nums){\\n            list.add(x);\\n        }\\n        for(int i=1;i<=nums.length;i++){\\n           if(list.contains(i)){\\n               continue;\\n           }else{\\n                return i;\\n               \\n           }\\n        }\\n        return nums.length+1;\\n    } \\n    \\n}\\n_________________________________________________________________________\\n\\n. Below is similar program but with different interface :\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\nHashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n_______________________________________________________________________________"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "you are performing O(n^n) contains is iterating through the array internally"
                    }
                ]
            },
            {
                "id": 1915754,
                "content": [
                    {
                        "username": "johnnychang",
                        "content": "This is a very interesting problem that can be solved with cyclic sort. I found this article very helpful for understanding the pattern: https://leetcode.com/discuss/study-guide/2958275/cyclic-sort-important-pattern"
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "counting sort\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is interesting comparing algorithms. I also hit on the idea of moving each element in the array into its correct position then finding the first position where the element is out of place.\\n\\nThe problem is that some elements need more than 1 jump to get into the correct position and that created all sorts of edge cases that I had to come up with logic for it.\\n\\nIt didn\\'t occur to me that I could mark each position as negative to indicate a found index. It would have simplified the logic if it did."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why say constant space, but related topics is hash table? "
                    },
                    {
                        "username": "Lakshman_11",
                        "content": "can the elements be repeating"
                    },
                    {
                        "username": "dheeraj3859",
                        "content": "For a linear algorithm we need to sort it using bucket sort and then do a linear search for the missing positive number"
                    },
                    {
                        "username": "charanarc3",
                        "content": "can anyone provide me the proof of time complexity of searching in dictionaries in python"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the time complexity of this code?\\n`    for i in range(index, len(nums)):\\n            # print(nums,data,nums[i])\\n            if data not in nums:\\n                return data\\n            data = data +1\\n        return data`\\n\\nfirst for loop is looping through n number and on the 1st if used \"in\" operator this operation also has O(n) complexity. but the chatgpt and bard says this code time complexity is O(n), but my understanding is it may be O(n^2).\\n\\nPasting the chatgpt response \\n<<<-------------------->>>\\nThe time complexity of the provided code is O(n), where n is the number of elements in the nums list.\\n\\nThe for loop iterates over the elements in nums starting from the index variable until the end of the list. In the worst-case scenario, where index is 0, the loop will iterate through all n elements of the nums list.\\n\\nInside the loop, the code checks if data is not in the nums list using the in operator. This operation has a time complexity of O(n) since it potentially needs to compare data with each element of nums.\\n\\nIf the data is not in nums, the code returns data immediately, terminating the loop. Otherwise, if the loop completes without returning, data is incremented by 1 and the loop continues.\\n\\nSince the loop iterates through all n elements of the nums list, the time complexity of the code is O(n).\\n\\nIt\\'s worth noting that the actual time complexity may be lower if the loop is terminated early when data is not found in nums. However, in the worst-case scenario where data is larger than all elements in nums, the code will iterate through all n elements. Therefore, the overall time complexity is O(n).\\n<<<-------------------------->>>\\n\\n "
                    },
                    {
                        "username": "atul1503",
                        "content": "What kind of witchcraft is going on in python with the swap algorithm?"
                    },
                    {
                        "username": "Konada_sunita",
                        "content": "Hi,\\n\\ni have doubt that why my program is exceeding the time limit but the some what similar program is not exceeding the time limit . Could anyone please help me with this ?Please let me know what is wrong with my program as my program is passing for all test case except the below one for which is giving as time limit exceeding \\n\\nBelow Test case is getting failed for my program:\\n__________________________________________________\\n[100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,99988,99987,99986,99985,99984,99983,99982,99981,99980,99979,99978,99977,99976,99975,99974,99973,99972,99971,99970,99969,99968,99967,99966,99965,99964,99963,99962,99961,99960,99959,99958,99957,99956,99955,99954,99953,99952,99951,99950,99949,99948,99947,99946,99945,99944,99943,99942,99941,99940,99939,99938,99937,99936,99935,99934,99933,99932,99931,99930,99929,99928,99927,99926,99925,99924,99923,99922--------,4,3,2,1]\\n\\n\\n______________________________________________________________________\\nBelow is my program which is exceeding time limit :\\n_____________________________________________________\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        List<Integer> list=new ArrayList<Integer>();\\n        for(int x:nums){\\n            list.add(x);\\n        }\\n        for(int i=1;i<=nums.length;i++){\\n           if(list.contains(i)){\\n               continue;\\n           }else{\\n                return i;\\n               \\n           }\\n        }\\n        return nums.length+1;\\n    } \\n    \\n}\\n_________________________________________________________________________\\n\\n. Below is similar program but with different interface :\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\nHashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n_______________________________________________________________________________"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "you are performing O(n^n) contains is iterating through the array internally"
                    }
                ]
            },
            {
                "id": 1914993,
                "content": [
                    {
                        "username": "johnnychang",
                        "content": "This is a very interesting problem that can be solved with cyclic sort. I found this article very helpful for understanding the pattern: https://leetcode.com/discuss/study-guide/2958275/cyclic-sort-important-pattern"
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "counting sort\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is interesting comparing algorithms. I also hit on the idea of moving each element in the array into its correct position then finding the first position where the element is out of place.\\n\\nThe problem is that some elements need more than 1 jump to get into the correct position and that created all sorts of edge cases that I had to come up with logic for it.\\n\\nIt didn\\'t occur to me that I could mark each position as negative to indicate a found index. It would have simplified the logic if it did."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why say constant space, but related topics is hash table? "
                    },
                    {
                        "username": "Lakshman_11",
                        "content": "can the elements be repeating"
                    },
                    {
                        "username": "dheeraj3859",
                        "content": "For a linear algorithm we need to sort it using bucket sort and then do a linear search for the missing positive number"
                    },
                    {
                        "username": "charanarc3",
                        "content": "can anyone provide me the proof of time complexity of searching in dictionaries in python"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the time complexity of this code?\\n`    for i in range(index, len(nums)):\\n            # print(nums,data,nums[i])\\n            if data not in nums:\\n                return data\\n            data = data +1\\n        return data`\\n\\nfirst for loop is looping through n number and on the 1st if used \"in\" operator this operation also has O(n) complexity. but the chatgpt and bard says this code time complexity is O(n), but my understanding is it may be O(n^2).\\n\\nPasting the chatgpt response \\n<<<-------------------->>>\\nThe time complexity of the provided code is O(n), where n is the number of elements in the nums list.\\n\\nThe for loop iterates over the elements in nums starting from the index variable until the end of the list. In the worst-case scenario, where index is 0, the loop will iterate through all n elements of the nums list.\\n\\nInside the loop, the code checks if data is not in the nums list using the in operator. This operation has a time complexity of O(n) since it potentially needs to compare data with each element of nums.\\n\\nIf the data is not in nums, the code returns data immediately, terminating the loop. Otherwise, if the loop completes without returning, data is incremented by 1 and the loop continues.\\n\\nSince the loop iterates through all n elements of the nums list, the time complexity of the code is O(n).\\n\\nIt\\'s worth noting that the actual time complexity may be lower if the loop is terminated early when data is not found in nums. However, in the worst-case scenario where data is larger than all elements in nums, the code will iterate through all n elements. Therefore, the overall time complexity is O(n).\\n<<<-------------------------->>>\\n\\n "
                    },
                    {
                        "username": "atul1503",
                        "content": "What kind of witchcraft is going on in python with the swap algorithm?"
                    },
                    {
                        "username": "Konada_sunita",
                        "content": "Hi,\\n\\ni have doubt that why my program is exceeding the time limit but the some what similar program is not exceeding the time limit . Could anyone please help me with this ?Please let me know what is wrong with my program as my program is passing for all test case except the below one for which is giving as time limit exceeding \\n\\nBelow Test case is getting failed for my program:\\n__________________________________________________\\n[100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,99988,99987,99986,99985,99984,99983,99982,99981,99980,99979,99978,99977,99976,99975,99974,99973,99972,99971,99970,99969,99968,99967,99966,99965,99964,99963,99962,99961,99960,99959,99958,99957,99956,99955,99954,99953,99952,99951,99950,99949,99948,99947,99946,99945,99944,99943,99942,99941,99940,99939,99938,99937,99936,99935,99934,99933,99932,99931,99930,99929,99928,99927,99926,99925,99924,99923,99922--------,4,3,2,1]\\n\\n\\n______________________________________________________________________\\nBelow is my program which is exceeding time limit :\\n_____________________________________________________\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        List<Integer> list=new ArrayList<Integer>();\\n        for(int x:nums){\\n            list.add(x);\\n        }\\n        for(int i=1;i<=nums.length;i++){\\n           if(list.contains(i)){\\n               continue;\\n           }else{\\n                return i;\\n               \\n           }\\n        }\\n        return nums.length+1;\\n    } \\n    \\n}\\n_________________________________________________________________________\\n\\n. Below is similar program but with different interface :\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\nHashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n_______________________________________________________________________________"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "you are performing O(n^n) contains is iterating through the array internally"
                    }
                ]
            },
            {
                "id": 1904716,
                "content": [
                    {
                        "username": "johnnychang",
                        "content": "This is a very interesting problem that can be solved with cyclic sort. I found this article very helpful for understanding the pattern: https://leetcode.com/discuss/study-guide/2958275/cyclic-sort-important-pattern"
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "counting sort\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is interesting comparing algorithms. I also hit on the idea of moving each element in the array into its correct position then finding the first position where the element is out of place.\\n\\nThe problem is that some elements need more than 1 jump to get into the correct position and that created all sorts of edge cases that I had to come up with logic for it.\\n\\nIt didn\\'t occur to me that I could mark each position as negative to indicate a found index. It would have simplified the logic if it did."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why say constant space, but related topics is hash table? "
                    },
                    {
                        "username": "Lakshman_11",
                        "content": "can the elements be repeating"
                    },
                    {
                        "username": "dheeraj3859",
                        "content": "For a linear algorithm we need to sort it using bucket sort and then do a linear search for the missing positive number"
                    },
                    {
                        "username": "charanarc3",
                        "content": "can anyone provide me the proof of time complexity of searching in dictionaries in python"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the time complexity of this code?\\n`    for i in range(index, len(nums)):\\n            # print(nums,data,nums[i])\\n            if data not in nums:\\n                return data\\n            data = data +1\\n        return data`\\n\\nfirst for loop is looping through n number and on the 1st if used \"in\" operator this operation also has O(n) complexity. but the chatgpt and bard says this code time complexity is O(n), but my understanding is it may be O(n^2).\\n\\nPasting the chatgpt response \\n<<<-------------------->>>\\nThe time complexity of the provided code is O(n), where n is the number of elements in the nums list.\\n\\nThe for loop iterates over the elements in nums starting from the index variable until the end of the list. In the worst-case scenario, where index is 0, the loop will iterate through all n elements of the nums list.\\n\\nInside the loop, the code checks if data is not in the nums list using the in operator. This operation has a time complexity of O(n) since it potentially needs to compare data with each element of nums.\\n\\nIf the data is not in nums, the code returns data immediately, terminating the loop. Otherwise, if the loop completes without returning, data is incremented by 1 and the loop continues.\\n\\nSince the loop iterates through all n elements of the nums list, the time complexity of the code is O(n).\\n\\nIt\\'s worth noting that the actual time complexity may be lower if the loop is terminated early when data is not found in nums. However, in the worst-case scenario where data is larger than all elements in nums, the code will iterate through all n elements. Therefore, the overall time complexity is O(n).\\n<<<-------------------------->>>\\n\\n "
                    },
                    {
                        "username": "atul1503",
                        "content": "What kind of witchcraft is going on in python with the swap algorithm?"
                    },
                    {
                        "username": "Konada_sunita",
                        "content": "Hi,\\n\\ni have doubt that why my program is exceeding the time limit but the some what similar program is not exceeding the time limit . Could anyone please help me with this ?Please let me know what is wrong with my program as my program is passing for all test case except the below one for which is giving as time limit exceeding \\n\\nBelow Test case is getting failed for my program:\\n__________________________________________________\\n[100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,99988,99987,99986,99985,99984,99983,99982,99981,99980,99979,99978,99977,99976,99975,99974,99973,99972,99971,99970,99969,99968,99967,99966,99965,99964,99963,99962,99961,99960,99959,99958,99957,99956,99955,99954,99953,99952,99951,99950,99949,99948,99947,99946,99945,99944,99943,99942,99941,99940,99939,99938,99937,99936,99935,99934,99933,99932,99931,99930,99929,99928,99927,99926,99925,99924,99923,99922--------,4,3,2,1]\\n\\n\\n______________________________________________________________________\\nBelow is my program which is exceeding time limit :\\n_____________________________________________________\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        List<Integer> list=new ArrayList<Integer>();\\n        for(int x:nums){\\n            list.add(x);\\n        }\\n        for(int i=1;i<=nums.length;i++){\\n           if(list.contains(i)){\\n               continue;\\n           }else{\\n                return i;\\n               \\n           }\\n        }\\n        return nums.length+1;\\n    } \\n    \\n}\\n_________________________________________________________________________\\n\\n. Below is similar program but with different interface :\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\nHashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n_______________________________________________________________________________"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "you are performing O(n^n) contains is iterating through the array internally"
                    }
                ]
            },
            {
                "id": 1890475,
                "content": [
                    {
                        "username": "johnnychang",
                        "content": "This is a very interesting problem that can be solved with cyclic sort. I found this article very helpful for understanding the pattern: https://leetcode.com/discuss/study-guide/2958275/cyclic-sort-important-pattern"
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "counting sort\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is interesting comparing algorithms. I also hit on the idea of moving each element in the array into its correct position then finding the first position where the element is out of place.\\n\\nThe problem is that some elements need more than 1 jump to get into the correct position and that created all sorts of edge cases that I had to come up with logic for it.\\n\\nIt didn\\'t occur to me that I could mark each position as negative to indicate a found index. It would have simplified the logic if it did."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why say constant space, but related topics is hash table? "
                    },
                    {
                        "username": "Lakshman_11",
                        "content": "can the elements be repeating"
                    },
                    {
                        "username": "dheeraj3859",
                        "content": "For a linear algorithm we need to sort it using bucket sort and then do a linear search for the missing positive number"
                    },
                    {
                        "username": "charanarc3",
                        "content": "can anyone provide me the proof of time complexity of searching in dictionaries in python"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the time complexity of this code?\\n`    for i in range(index, len(nums)):\\n            # print(nums,data,nums[i])\\n            if data not in nums:\\n                return data\\n            data = data +1\\n        return data`\\n\\nfirst for loop is looping through n number and on the 1st if used \"in\" operator this operation also has O(n) complexity. but the chatgpt and bard says this code time complexity is O(n), but my understanding is it may be O(n^2).\\n\\nPasting the chatgpt response \\n<<<-------------------->>>\\nThe time complexity of the provided code is O(n), where n is the number of elements in the nums list.\\n\\nThe for loop iterates over the elements in nums starting from the index variable until the end of the list. In the worst-case scenario, where index is 0, the loop will iterate through all n elements of the nums list.\\n\\nInside the loop, the code checks if data is not in the nums list using the in operator. This operation has a time complexity of O(n) since it potentially needs to compare data with each element of nums.\\n\\nIf the data is not in nums, the code returns data immediately, terminating the loop. Otherwise, if the loop completes without returning, data is incremented by 1 and the loop continues.\\n\\nSince the loop iterates through all n elements of the nums list, the time complexity of the code is O(n).\\n\\nIt\\'s worth noting that the actual time complexity may be lower if the loop is terminated early when data is not found in nums. However, in the worst-case scenario where data is larger than all elements in nums, the code will iterate through all n elements. Therefore, the overall time complexity is O(n).\\n<<<-------------------------->>>\\n\\n "
                    },
                    {
                        "username": "atul1503",
                        "content": "What kind of witchcraft is going on in python with the swap algorithm?"
                    },
                    {
                        "username": "Konada_sunita",
                        "content": "Hi,\\n\\ni have doubt that why my program is exceeding the time limit but the some what similar program is not exceeding the time limit . Could anyone please help me with this ?Please let me know what is wrong with my program as my program is passing for all test case except the below one for which is giving as time limit exceeding \\n\\nBelow Test case is getting failed for my program:\\n__________________________________________________\\n[100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,99988,99987,99986,99985,99984,99983,99982,99981,99980,99979,99978,99977,99976,99975,99974,99973,99972,99971,99970,99969,99968,99967,99966,99965,99964,99963,99962,99961,99960,99959,99958,99957,99956,99955,99954,99953,99952,99951,99950,99949,99948,99947,99946,99945,99944,99943,99942,99941,99940,99939,99938,99937,99936,99935,99934,99933,99932,99931,99930,99929,99928,99927,99926,99925,99924,99923,99922--------,4,3,2,1]\\n\\n\\n______________________________________________________________________\\nBelow is my program which is exceeding time limit :\\n_____________________________________________________\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        List<Integer> list=new ArrayList<Integer>();\\n        for(int x:nums){\\n            list.add(x);\\n        }\\n        for(int i=1;i<=nums.length;i++){\\n           if(list.contains(i)){\\n               continue;\\n           }else{\\n                return i;\\n               \\n           }\\n        }\\n        return nums.length+1;\\n    } \\n    \\n}\\n_________________________________________________________________________\\n\\n. Below is similar program but with different interface :\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\nHashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n_______________________________________________________________________________"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "you are performing O(n^n) contains is iterating through the array internally"
                    }
                ]
            },
            {
                "id": 1887475,
                "content": [
                    {
                        "username": "johnnychang",
                        "content": "This is a very interesting problem that can be solved with cyclic sort. I found this article very helpful for understanding the pattern: https://leetcode.com/discuss/study-guide/2958275/cyclic-sort-important-pattern"
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "counting sort\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is interesting comparing algorithms. I also hit on the idea of moving each element in the array into its correct position then finding the first position where the element is out of place.\\n\\nThe problem is that some elements need more than 1 jump to get into the correct position and that created all sorts of edge cases that I had to come up with logic for it.\\n\\nIt didn\\'t occur to me that I could mark each position as negative to indicate a found index. It would have simplified the logic if it did."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why say constant space, but related topics is hash table? "
                    },
                    {
                        "username": "Lakshman_11",
                        "content": "can the elements be repeating"
                    },
                    {
                        "username": "dheeraj3859",
                        "content": "For a linear algorithm we need to sort it using bucket sort and then do a linear search for the missing positive number"
                    },
                    {
                        "username": "charanarc3",
                        "content": "can anyone provide me the proof of time complexity of searching in dictionaries in python"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the time complexity of this code?\\n`    for i in range(index, len(nums)):\\n            # print(nums,data,nums[i])\\n            if data not in nums:\\n                return data\\n            data = data +1\\n        return data`\\n\\nfirst for loop is looping through n number and on the 1st if used \"in\" operator this operation also has O(n) complexity. but the chatgpt and bard says this code time complexity is O(n), but my understanding is it may be O(n^2).\\n\\nPasting the chatgpt response \\n<<<-------------------->>>\\nThe time complexity of the provided code is O(n), where n is the number of elements in the nums list.\\n\\nThe for loop iterates over the elements in nums starting from the index variable until the end of the list. In the worst-case scenario, where index is 0, the loop will iterate through all n elements of the nums list.\\n\\nInside the loop, the code checks if data is not in the nums list using the in operator. This operation has a time complexity of O(n) since it potentially needs to compare data with each element of nums.\\n\\nIf the data is not in nums, the code returns data immediately, terminating the loop. Otherwise, if the loop completes without returning, data is incremented by 1 and the loop continues.\\n\\nSince the loop iterates through all n elements of the nums list, the time complexity of the code is O(n).\\n\\nIt\\'s worth noting that the actual time complexity may be lower if the loop is terminated early when data is not found in nums. However, in the worst-case scenario where data is larger than all elements in nums, the code will iterate through all n elements. Therefore, the overall time complexity is O(n).\\n<<<-------------------------->>>\\n\\n "
                    },
                    {
                        "username": "atul1503",
                        "content": "What kind of witchcraft is going on in python with the swap algorithm?"
                    },
                    {
                        "username": "Konada_sunita",
                        "content": "Hi,\\n\\ni have doubt that why my program is exceeding the time limit but the some what similar program is not exceeding the time limit . Could anyone please help me with this ?Please let me know what is wrong with my program as my program is passing for all test case except the below one for which is giving as time limit exceeding \\n\\nBelow Test case is getting failed for my program:\\n__________________________________________________\\n[100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,99988,99987,99986,99985,99984,99983,99982,99981,99980,99979,99978,99977,99976,99975,99974,99973,99972,99971,99970,99969,99968,99967,99966,99965,99964,99963,99962,99961,99960,99959,99958,99957,99956,99955,99954,99953,99952,99951,99950,99949,99948,99947,99946,99945,99944,99943,99942,99941,99940,99939,99938,99937,99936,99935,99934,99933,99932,99931,99930,99929,99928,99927,99926,99925,99924,99923,99922--------,4,3,2,1]\\n\\n\\n______________________________________________________________________\\nBelow is my program which is exceeding time limit :\\n_____________________________________________________\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        List<Integer> list=new ArrayList<Integer>();\\n        for(int x:nums){\\n            list.add(x);\\n        }\\n        for(int i=1;i<=nums.length;i++){\\n           if(list.contains(i)){\\n               continue;\\n           }else{\\n                return i;\\n               \\n           }\\n        }\\n        return nums.length+1;\\n    } \\n    \\n}\\n_________________________________________________________________________\\n\\n. Below is similar program but with different interface :\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\nHashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n_______________________________________________________________________________"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "you are performing O(n^n) contains is iterating through the array internally"
                    }
                ]
            },
            {
                "id": 1863876,
                "content": [
                    {
                        "username": "johnnychang",
                        "content": "This is a very interesting problem that can be solved with cyclic sort. I found this article very helpful for understanding the pattern: https://leetcode.com/discuss/study-guide/2958275/cyclic-sort-important-pattern"
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "counting sort\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is interesting comparing algorithms. I also hit on the idea of moving each element in the array into its correct position then finding the first position where the element is out of place.\\n\\nThe problem is that some elements need more than 1 jump to get into the correct position and that created all sorts of edge cases that I had to come up with logic for it.\\n\\nIt didn\\'t occur to me that I could mark each position as negative to indicate a found index. It would have simplified the logic if it did."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why say constant space, but related topics is hash table? "
                    },
                    {
                        "username": "Lakshman_11",
                        "content": "can the elements be repeating"
                    },
                    {
                        "username": "dheeraj3859",
                        "content": "For a linear algorithm we need to sort it using bucket sort and then do a linear search for the missing positive number"
                    },
                    {
                        "username": "charanarc3",
                        "content": "can anyone provide me the proof of time complexity of searching in dictionaries in python"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the time complexity of this code?\\n`    for i in range(index, len(nums)):\\n            # print(nums,data,nums[i])\\n            if data not in nums:\\n                return data\\n            data = data +1\\n        return data`\\n\\nfirst for loop is looping through n number and on the 1st if used \"in\" operator this operation also has O(n) complexity. but the chatgpt and bard says this code time complexity is O(n), but my understanding is it may be O(n^2).\\n\\nPasting the chatgpt response \\n<<<-------------------->>>\\nThe time complexity of the provided code is O(n), where n is the number of elements in the nums list.\\n\\nThe for loop iterates over the elements in nums starting from the index variable until the end of the list. In the worst-case scenario, where index is 0, the loop will iterate through all n elements of the nums list.\\n\\nInside the loop, the code checks if data is not in the nums list using the in operator. This operation has a time complexity of O(n) since it potentially needs to compare data with each element of nums.\\n\\nIf the data is not in nums, the code returns data immediately, terminating the loop. Otherwise, if the loop completes without returning, data is incremented by 1 and the loop continues.\\n\\nSince the loop iterates through all n elements of the nums list, the time complexity of the code is O(n).\\n\\nIt\\'s worth noting that the actual time complexity may be lower if the loop is terminated early when data is not found in nums. However, in the worst-case scenario where data is larger than all elements in nums, the code will iterate through all n elements. Therefore, the overall time complexity is O(n).\\n<<<-------------------------->>>\\n\\n "
                    },
                    {
                        "username": "atul1503",
                        "content": "What kind of witchcraft is going on in python with the swap algorithm?"
                    },
                    {
                        "username": "Konada_sunita",
                        "content": "Hi,\\n\\ni have doubt that why my program is exceeding the time limit but the some what similar program is not exceeding the time limit . Could anyone please help me with this ?Please let me know what is wrong with my program as my program is passing for all test case except the below one for which is giving as time limit exceeding \\n\\nBelow Test case is getting failed for my program:\\n__________________________________________________\\n[100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,99988,99987,99986,99985,99984,99983,99982,99981,99980,99979,99978,99977,99976,99975,99974,99973,99972,99971,99970,99969,99968,99967,99966,99965,99964,99963,99962,99961,99960,99959,99958,99957,99956,99955,99954,99953,99952,99951,99950,99949,99948,99947,99946,99945,99944,99943,99942,99941,99940,99939,99938,99937,99936,99935,99934,99933,99932,99931,99930,99929,99928,99927,99926,99925,99924,99923,99922--------,4,3,2,1]\\n\\n\\n______________________________________________________________________\\nBelow is my program which is exceeding time limit :\\n_____________________________________________________\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        List<Integer> list=new ArrayList<Integer>();\\n        for(int x:nums){\\n            list.add(x);\\n        }\\n        for(int i=1;i<=nums.length;i++){\\n           if(list.contains(i)){\\n               continue;\\n           }else{\\n                return i;\\n               \\n           }\\n        }\\n        return nums.length+1;\\n    } \\n    \\n}\\n_________________________________________________________________________\\n\\n. Below is similar program but with different interface :\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\nHashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n_______________________________________________________________________________"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "you are performing O(n^n) contains is iterating through the array internally"
                    }
                ]
            },
            {
                "id": 1861489,
                "content": [
                    {
                        "username": "RajYuvaraj",
                        "content": "for this testcase [3,4,-1,1], both 0 and 2 is missing. Am I correct ?"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "0 is not positive"
                    },
                    {
                        "username": "Ultron03",
                        "content": "CAN SOMEONE PLEASE HELP ME FINDING THE ERROR IN CODE ..\nIT IS GIVING TLE FOR  [1,2,2147483647] INPUT..\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n \n        int n=nums.size();\n       long long   int min=nums[0];\n         int max=nums[0];\n        for(int i=0;i<n;i++){\n         if(nums[i]>max){\n             max=nums[i];\n             \n         }\n         if(nums[i]<min){\n             min=nums[i];\n         }\n        }\n\n        if(min>1||max<=0){\n            return 1;\n        }\n      \n      map<long long int, int>m;\n  \n      for(int i=min;i<=max;i++){\n          m[i]=0;\n      }\n      for(int i=0;i<n;i++){\n          m[nums[i]]++;\n      }\n\n      for(int i=min;i<=max;i++){\n          if(m[i]==0 && i>0){\n              return i;\n          }\n      }\n\n      return max+1;\n\n    }\n};\n"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "What I don\\'t get is, the condition doesn\\'t specify that the `nums` is from 1 to n. Hence, I don\\'t understand why it doesn\\'t return 10 in the sample `7, 8, 9, 11, 12`. I have to think more on this."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Because positive integer starts at 1."
                    },
                    {
                        "username": "shoyebmd424",
                        "content": "i have used hashtable but showing TLE just i have used O(n) space and O(n) time complexity"
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Should not be in Hard Category "
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "your solution is more than O(1) space complexity, so technically you don\\'t meet the requirements"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "isn't a while loop(less or equal to len(nums)) without any nested loops O(n)? Then why am I getting a TLE error on case 171, which i think is no.s from 1-100k"
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem may not be the number of times through your loop, but it might be the amount of computation in each iteration.  My solution goes the the array 3 times with no TLE error."
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem states \"You must implement an algorithm that runs in O(n) time and uses constant extra space.\"  Yet, when I look at accepted solutions that supposedly ran faster than mine, I see that they sort the array using O(n log n) time, and/or they copy the array to a set using O(n) memory.  Why state a restriction if you don\\'t test to be sure the restriction is met?"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "Guys, could you tell me why the output of [1] should be 2 instead  of None?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "because 2 is the next position number. likewise ignoring duplicates if the array was [1,1] the answer would be 2 as well. "
                    },
                    {
                        "username": "bugsbunny99",
                        "content": "Anyone else who is puzzled about why this is a LeetCode \\'Hard\\' problem?"
                    },
                    {
                        "username": "akuthiala",
                        "content": "Why is this C++ code not working?\\nGives runtime error.\\n\\n\\n\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v(n,-1);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                v[nums[i]-1]=nums[i];\\n            }\\n        }\\n\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==-1){\\n                return i+1;\\n            }\\n        }\\n        return v.size();\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1845980,
                "content": [
                    {
                        "username": "RajYuvaraj",
                        "content": "for this testcase [3,4,-1,1], both 0 and 2 is missing. Am I correct ?"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "0 is not positive"
                    },
                    {
                        "username": "Ultron03",
                        "content": "CAN SOMEONE PLEASE HELP ME FINDING THE ERROR IN CODE ..\nIT IS GIVING TLE FOR  [1,2,2147483647] INPUT..\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n \n        int n=nums.size();\n       long long   int min=nums[0];\n         int max=nums[0];\n        for(int i=0;i<n;i++){\n         if(nums[i]>max){\n             max=nums[i];\n             \n         }\n         if(nums[i]<min){\n             min=nums[i];\n         }\n        }\n\n        if(min>1||max<=0){\n            return 1;\n        }\n      \n      map<long long int, int>m;\n  \n      for(int i=min;i<=max;i++){\n          m[i]=0;\n      }\n      for(int i=0;i<n;i++){\n          m[nums[i]]++;\n      }\n\n      for(int i=min;i<=max;i++){\n          if(m[i]==0 && i>0){\n              return i;\n          }\n      }\n\n      return max+1;\n\n    }\n};\n"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "What I don\\'t get is, the condition doesn\\'t specify that the `nums` is from 1 to n. Hence, I don\\'t understand why it doesn\\'t return 10 in the sample `7, 8, 9, 11, 12`. I have to think more on this."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Because positive integer starts at 1."
                    },
                    {
                        "username": "shoyebmd424",
                        "content": "i have used hashtable but showing TLE just i have used O(n) space and O(n) time complexity"
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Should not be in Hard Category "
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "your solution is more than O(1) space complexity, so technically you don\\'t meet the requirements"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "isn't a while loop(less or equal to len(nums)) without any nested loops O(n)? Then why am I getting a TLE error on case 171, which i think is no.s from 1-100k"
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem may not be the number of times through your loop, but it might be the amount of computation in each iteration.  My solution goes the the array 3 times with no TLE error."
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem states \"You must implement an algorithm that runs in O(n) time and uses constant extra space.\"  Yet, when I look at accepted solutions that supposedly ran faster than mine, I see that they sort the array using O(n log n) time, and/or they copy the array to a set using O(n) memory.  Why state a restriction if you don\\'t test to be sure the restriction is met?"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "Guys, could you tell me why the output of [1] should be 2 instead  of None?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "because 2 is the next position number. likewise ignoring duplicates if the array was [1,1] the answer would be 2 as well. "
                    },
                    {
                        "username": "bugsbunny99",
                        "content": "Anyone else who is puzzled about why this is a LeetCode \\'Hard\\' problem?"
                    },
                    {
                        "username": "akuthiala",
                        "content": "Why is this C++ code not working?\\nGives runtime error.\\n\\n\\n\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v(n,-1);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                v[nums[i]-1]=nums[i];\\n            }\\n        }\\n\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==-1){\\n                return i+1;\\n            }\\n        }\\n        return v.size();\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1845880,
                "content": [
                    {
                        "username": "RajYuvaraj",
                        "content": "for this testcase [3,4,-1,1], both 0 and 2 is missing. Am I correct ?"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "0 is not positive"
                    },
                    {
                        "username": "Ultron03",
                        "content": "CAN SOMEONE PLEASE HELP ME FINDING THE ERROR IN CODE ..\nIT IS GIVING TLE FOR  [1,2,2147483647] INPUT..\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n \n        int n=nums.size();\n       long long   int min=nums[0];\n         int max=nums[0];\n        for(int i=0;i<n;i++){\n         if(nums[i]>max){\n             max=nums[i];\n             \n         }\n         if(nums[i]<min){\n             min=nums[i];\n         }\n        }\n\n        if(min>1||max<=0){\n            return 1;\n        }\n      \n      map<long long int, int>m;\n  \n      for(int i=min;i<=max;i++){\n          m[i]=0;\n      }\n      for(int i=0;i<n;i++){\n          m[nums[i]]++;\n      }\n\n      for(int i=min;i<=max;i++){\n          if(m[i]==0 && i>0){\n              return i;\n          }\n      }\n\n      return max+1;\n\n    }\n};\n"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "What I don\\'t get is, the condition doesn\\'t specify that the `nums` is from 1 to n. Hence, I don\\'t understand why it doesn\\'t return 10 in the sample `7, 8, 9, 11, 12`. I have to think more on this."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Because positive integer starts at 1."
                    },
                    {
                        "username": "shoyebmd424",
                        "content": "i have used hashtable but showing TLE just i have used O(n) space and O(n) time complexity"
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Should not be in Hard Category "
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "your solution is more than O(1) space complexity, so technically you don\\'t meet the requirements"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "isn't a while loop(less or equal to len(nums)) without any nested loops O(n)? Then why am I getting a TLE error on case 171, which i think is no.s from 1-100k"
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem may not be the number of times through your loop, but it might be the amount of computation in each iteration.  My solution goes the the array 3 times with no TLE error."
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem states \"You must implement an algorithm that runs in O(n) time and uses constant extra space.\"  Yet, when I look at accepted solutions that supposedly ran faster than mine, I see that they sort the array using O(n log n) time, and/or they copy the array to a set using O(n) memory.  Why state a restriction if you don\\'t test to be sure the restriction is met?"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "Guys, could you tell me why the output of [1] should be 2 instead  of None?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "because 2 is the next position number. likewise ignoring duplicates if the array was [1,1] the answer would be 2 as well. "
                    },
                    {
                        "username": "bugsbunny99",
                        "content": "Anyone else who is puzzled about why this is a LeetCode \\'Hard\\' problem?"
                    },
                    {
                        "username": "akuthiala",
                        "content": "Why is this C++ code not working?\\nGives runtime error.\\n\\n\\n\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v(n,-1);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                v[nums[i]-1]=nums[i];\\n            }\\n        }\\n\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==-1){\\n                return i+1;\\n            }\\n        }\\n        return v.size();\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1837770,
                "content": [
                    {
                        "username": "RajYuvaraj",
                        "content": "for this testcase [3,4,-1,1], both 0 and 2 is missing. Am I correct ?"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "0 is not positive"
                    },
                    {
                        "username": "Ultron03",
                        "content": "CAN SOMEONE PLEASE HELP ME FINDING THE ERROR IN CODE ..\nIT IS GIVING TLE FOR  [1,2,2147483647] INPUT..\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n \n        int n=nums.size();\n       long long   int min=nums[0];\n         int max=nums[0];\n        for(int i=0;i<n;i++){\n         if(nums[i]>max){\n             max=nums[i];\n             \n         }\n         if(nums[i]<min){\n             min=nums[i];\n         }\n        }\n\n        if(min>1||max<=0){\n            return 1;\n        }\n      \n      map<long long int, int>m;\n  \n      for(int i=min;i<=max;i++){\n          m[i]=0;\n      }\n      for(int i=0;i<n;i++){\n          m[nums[i]]++;\n      }\n\n      for(int i=min;i<=max;i++){\n          if(m[i]==0 && i>0){\n              return i;\n          }\n      }\n\n      return max+1;\n\n    }\n};\n"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "What I don\\'t get is, the condition doesn\\'t specify that the `nums` is from 1 to n. Hence, I don\\'t understand why it doesn\\'t return 10 in the sample `7, 8, 9, 11, 12`. I have to think more on this."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Because positive integer starts at 1."
                    },
                    {
                        "username": "shoyebmd424",
                        "content": "i have used hashtable but showing TLE just i have used O(n) space and O(n) time complexity"
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Should not be in Hard Category "
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "your solution is more than O(1) space complexity, so technically you don\\'t meet the requirements"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "isn't a while loop(less or equal to len(nums)) without any nested loops O(n)? Then why am I getting a TLE error on case 171, which i think is no.s from 1-100k"
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem may not be the number of times through your loop, but it might be the amount of computation in each iteration.  My solution goes the the array 3 times with no TLE error."
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem states \"You must implement an algorithm that runs in O(n) time and uses constant extra space.\"  Yet, when I look at accepted solutions that supposedly ran faster than mine, I see that they sort the array using O(n log n) time, and/or they copy the array to a set using O(n) memory.  Why state a restriction if you don\\'t test to be sure the restriction is met?"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "Guys, could you tell me why the output of [1] should be 2 instead  of None?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "because 2 is the next position number. likewise ignoring duplicates if the array was [1,1] the answer would be 2 as well. "
                    },
                    {
                        "username": "bugsbunny99",
                        "content": "Anyone else who is puzzled about why this is a LeetCode \\'Hard\\' problem?"
                    },
                    {
                        "username": "akuthiala",
                        "content": "Why is this C++ code not working?\\nGives runtime error.\\n\\n\\n\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v(n,-1);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                v[nums[i]-1]=nums[i];\\n            }\\n        }\\n\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==-1){\\n                return i+1;\\n            }\\n        }\\n        return v.size();\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1826178,
                "content": [
                    {
                        "username": "RajYuvaraj",
                        "content": "for this testcase [3,4,-1,1], both 0 and 2 is missing. Am I correct ?"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "0 is not positive"
                    },
                    {
                        "username": "Ultron03",
                        "content": "CAN SOMEONE PLEASE HELP ME FINDING THE ERROR IN CODE ..\nIT IS GIVING TLE FOR  [1,2,2147483647] INPUT..\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n \n        int n=nums.size();\n       long long   int min=nums[0];\n         int max=nums[0];\n        for(int i=0;i<n;i++){\n         if(nums[i]>max){\n             max=nums[i];\n             \n         }\n         if(nums[i]<min){\n             min=nums[i];\n         }\n        }\n\n        if(min>1||max<=0){\n            return 1;\n        }\n      \n      map<long long int, int>m;\n  \n      for(int i=min;i<=max;i++){\n          m[i]=0;\n      }\n      for(int i=0;i<n;i++){\n          m[nums[i]]++;\n      }\n\n      for(int i=min;i<=max;i++){\n          if(m[i]==0 && i>0){\n              return i;\n          }\n      }\n\n      return max+1;\n\n    }\n};\n"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "What I don\\'t get is, the condition doesn\\'t specify that the `nums` is from 1 to n. Hence, I don\\'t understand why it doesn\\'t return 10 in the sample `7, 8, 9, 11, 12`. I have to think more on this."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Because positive integer starts at 1."
                    },
                    {
                        "username": "shoyebmd424",
                        "content": "i have used hashtable but showing TLE just i have used O(n) space and O(n) time complexity"
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Should not be in Hard Category "
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "your solution is more than O(1) space complexity, so technically you don\\'t meet the requirements"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "isn't a while loop(less or equal to len(nums)) without any nested loops O(n)? Then why am I getting a TLE error on case 171, which i think is no.s from 1-100k"
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem may not be the number of times through your loop, but it might be the amount of computation in each iteration.  My solution goes the the array 3 times with no TLE error."
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem states \"You must implement an algorithm that runs in O(n) time and uses constant extra space.\"  Yet, when I look at accepted solutions that supposedly ran faster than mine, I see that they sort the array using O(n log n) time, and/or they copy the array to a set using O(n) memory.  Why state a restriction if you don\\'t test to be sure the restriction is met?"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "Guys, could you tell me why the output of [1] should be 2 instead  of None?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "because 2 is the next position number. likewise ignoring duplicates if the array was [1,1] the answer would be 2 as well. "
                    },
                    {
                        "username": "bugsbunny99",
                        "content": "Anyone else who is puzzled about why this is a LeetCode \\'Hard\\' problem?"
                    },
                    {
                        "username": "akuthiala",
                        "content": "Why is this C++ code not working?\\nGives runtime error.\\n\\n\\n\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v(n,-1);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                v[nums[i]-1]=nums[i];\\n            }\\n        }\\n\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==-1){\\n                return i+1;\\n            }\\n        }\\n        return v.size();\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1817599,
                "content": [
                    {
                        "username": "RajYuvaraj",
                        "content": "for this testcase [3,4,-1,1], both 0 and 2 is missing. Am I correct ?"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "0 is not positive"
                    },
                    {
                        "username": "Ultron03",
                        "content": "CAN SOMEONE PLEASE HELP ME FINDING THE ERROR IN CODE ..\nIT IS GIVING TLE FOR  [1,2,2147483647] INPUT..\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n \n        int n=nums.size();\n       long long   int min=nums[0];\n         int max=nums[0];\n        for(int i=0;i<n;i++){\n         if(nums[i]>max){\n             max=nums[i];\n             \n         }\n         if(nums[i]<min){\n             min=nums[i];\n         }\n        }\n\n        if(min>1||max<=0){\n            return 1;\n        }\n      \n      map<long long int, int>m;\n  \n      for(int i=min;i<=max;i++){\n          m[i]=0;\n      }\n      for(int i=0;i<n;i++){\n          m[nums[i]]++;\n      }\n\n      for(int i=min;i<=max;i++){\n          if(m[i]==0 && i>0){\n              return i;\n          }\n      }\n\n      return max+1;\n\n    }\n};\n"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "What I don\\'t get is, the condition doesn\\'t specify that the `nums` is from 1 to n. Hence, I don\\'t understand why it doesn\\'t return 10 in the sample `7, 8, 9, 11, 12`. I have to think more on this."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Because positive integer starts at 1."
                    },
                    {
                        "username": "shoyebmd424",
                        "content": "i have used hashtable but showing TLE just i have used O(n) space and O(n) time complexity"
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Should not be in Hard Category "
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "your solution is more than O(1) space complexity, so technically you don\\'t meet the requirements"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "isn't a while loop(less or equal to len(nums)) without any nested loops O(n)? Then why am I getting a TLE error on case 171, which i think is no.s from 1-100k"
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem may not be the number of times through your loop, but it might be the amount of computation in each iteration.  My solution goes the the array 3 times with no TLE error."
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem states \"You must implement an algorithm that runs in O(n) time and uses constant extra space.\"  Yet, when I look at accepted solutions that supposedly ran faster than mine, I see that they sort the array using O(n log n) time, and/or they copy the array to a set using O(n) memory.  Why state a restriction if you don\\'t test to be sure the restriction is met?"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "Guys, could you tell me why the output of [1] should be 2 instead  of None?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "because 2 is the next position number. likewise ignoring duplicates if the array was [1,1] the answer would be 2 as well. "
                    },
                    {
                        "username": "bugsbunny99",
                        "content": "Anyone else who is puzzled about why this is a LeetCode \\'Hard\\' problem?"
                    },
                    {
                        "username": "akuthiala",
                        "content": "Why is this C++ code not working?\\nGives runtime error.\\n\\n\\n\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v(n,-1);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                v[nums[i]-1]=nums[i];\\n            }\\n        }\\n\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==-1){\\n                return i+1;\\n            }\\n        }\\n        return v.size();\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1815654,
                "content": [
                    {
                        "username": "RajYuvaraj",
                        "content": "for this testcase [3,4,-1,1], both 0 and 2 is missing. Am I correct ?"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "0 is not positive"
                    },
                    {
                        "username": "Ultron03",
                        "content": "CAN SOMEONE PLEASE HELP ME FINDING THE ERROR IN CODE ..\nIT IS GIVING TLE FOR  [1,2,2147483647] INPUT..\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n \n        int n=nums.size();\n       long long   int min=nums[0];\n         int max=nums[0];\n        for(int i=0;i<n;i++){\n         if(nums[i]>max){\n             max=nums[i];\n             \n         }\n         if(nums[i]<min){\n             min=nums[i];\n         }\n        }\n\n        if(min>1||max<=0){\n            return 1;\n        }\n      \n      map<long long int, int>m;\n  \n      for(int i=min;i<=max;i++){\n          m[i]=0;\n      }\n      for(int i=0;i<n;i++){\n          m[nums[i]]++;\n      }\n\n      for(int i=min;i<=max;i++){\n          if(m[i]==0 && i>0){\n              return i;\n          }\n      }\n\n      return max+1;\n\n    }\n};\n"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "What I don\\'t get is, the condition doesn\\'t specify that the `nums` is from 1 to n. Hence, I don\\'t understand why it doesn\\'t return 10 in the sample `7, 8, 9, 11, 12`. I have to think more on this."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Because positive integer starts at 1."
                    },
                    {
                        "username": "shoyebmd424",
                        "content": "i have used hashtable but showing TLE just i have used O(n) space and O(n) time complexity"
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Should not be in Hard Category "
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "your solution is more than O(1) space complexity, so technically you don\\'t meet the requirements"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "isn't a while loop(less or equal to len(nums)) without any nested loops O(n)? Then why am I getting a TLE error on case 171, which i think is no.s from 1-100k"
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem may not be the number of times through your loop, but it might be the amount of computation in each iteration.  My solution goes the the array 3 times with no TLE error."
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem states \"You must implement an algorithm that runs in O(n) time and uses constant extra space.\"  Yet, when I look at accepted solutions that supposedly ran faster than mine, I see that they sort the array using O(n log n) time, and/or they copy the array to a set using O(n) memory.  Why state a restriction if you don\\'t test to be sure the restriction is met?"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "Guys, could you tell me why the output of [1] should be 2 instead  of None?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "because 2 is the next position number. likewise ignoring duplicates if the array was [1,1] the answer would be 2 as well. "
                    },
                    {
                        "username": "bugsbunny99",
                        "content": "Anyone else who is puzzled about why this is a LeetCode \\'Hard\\' problem?"
                    },
                    {
                        "username": "akuthiala",
                        "content": "Why is this C++ code not working?\\nGives runtime error.\\n\\n\\n\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v(n,-1);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                v[nums[i]-1]=nums[i];\\n            }\\n        }\\n\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==-1){\\n                return i+1;\\n            }\\n        }\\n        return v.size();\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1811624,
                "content": [
                    {
                        "username": "RajYuvaraj",
                        "content": "for this testcase [3,4,-1,1], both 0 and 2 is missing. Am I correct ?"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "0 is not positive"
                    },
                    {
                        "username": "Ultron03",
                        "content": "CAN SOMEONE PLEASE HELP ME FINDING THE ERROR IN CODE ..\nIT IS GIVING TLE FOR  [1,2,2147483647] INPUT..\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n \n        int n=nums.size();\n       long long   int min=nums[0];\n         int max=nums[0];\n        for(int i=0;i<n;i++){\n         if(nums[i]>max){\n             max=nums[i];\n             \n         }\n         if(nums[i]<min){\n             min=nums[i];\n         }\n        }\n\n        if(min>1||max<=0){\n            return 1;\n        }\n      \n      map<long long int, int>m;\n  \n      for(int i=min;i<=max;i++){\n          m[i]=0;\n      }\n      for(int i=0;i<n;i++){\n          m[nums[i]]++;\n      }\n\n      for(int i=min;i<=max;i++){\n          if(m[i]==0 && i>0){\n              return i;\n          }\n      }\n\n      return max+1;\n\n    }\n};\n"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "What I don\\'t get is, the condition doesn\\'t specify that the `nums` is from 1 to n. Hence, I don\\'t understand why it doesn\\'t return 10 in the sample `7, 8, 9, 11, 12`. I have to think more on this."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Because positive integer starts at 1."
                    },
                    {
                        "username": "shoyebmd424",
                        "content": "i have used hashtable but showing TLE just i have used O(n) space and O(n) time complexity"
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Should not be in Hard Category "
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "your solution is more than O(1) space complexity, so technically you don\\'t meet the requirements"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "isn't a while loop(less or equal to len(nums)) without any nested loops O(n)? Then why am I getting a TLE error on case 171, which i think is no.s from 1-100k"
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem may not be the number of times through your loop, but it might be the amount of computation in each iteration.  My solution goes the the array 3 times with no TLE error."
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem states \"You must implement an algorithm that runs in O(n) time and uses constant extra space.\"  Yet, when I look at accepted solutions that supposedly ran faster than mine, I see that they sort the array using O(n log n) time, and/or they copy the array to a set using O(n) memory.  Why state a restriction if you don\\'t test to be sure the restriction is met?"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "Guys, could you tell me why the output of [1] should be 2 instead  of None?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "because 2 is the next position number. likewise ignoring duplicates if the array was [1,1] the answer would be 2 as well. "
                    },
                    {
                        "username": "bugsbunny99",
                        "content": "Anyone else who is puzzled about why this is a LeetCode \\'Hard\\' problem?"
                    },
                    {
                        "username": "akuthiala",
                        "content": "Why is this C++ code not working?\\nGives runtime error.\\n\\n\\n\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v(n,-1);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                v[nums[i]-1]=nums[i];\\n            }\\n        }\\n\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==-1){\\n                return i+1;\\n            }\\n        }\\n        return v.size();\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1810839,
                "content": [
                    {
                        "username": "RajYuvaraj",
                        "content": "for this testcase [3,4,-1,1], both 0 and 2 is missing. Am I correct ?"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "0 is not positive"
                    },
                    {
                        "username": "Ultron03",
                        "content": "CAN SOMEONE PLEASE HELP ME FINDING THE ERROR IN CODE ..\nIT IS GIVING TLE FOR  [1,2,2147483647] INPUT..\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n \n        int n=nums.size();\n       long long   int min=nums[0];\n         int max=nums[0];\n        for(int i=0;i<n;i++){\n         if(nums[i]>max){\n             max=nums[i];\n             \n         }\n         if(nums[i]<min){\n             min=nums[i];\n         }\n        }\n\n        if(min>1||max<=0){\n            return 1;\n        }\n      \n      map<long long int, int>m;\n  \n      for(int i=min;i<=max;i++){\n          m[i]=0;\n      }\n      for(int i=0;i<n;i++){\n          m[nums[i]]++;\n      }\n\n      for(int i=min;i<=max;i++){\n          if(m[i]==0 && i>0){\n              return i;\n          }\n      }\n\n      return max+1;\n\n    }\n};\n"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "What I don\\'t get is, the condition doesn\\'t specify that the `nums` is from 1 to n. Hence, I don\\'t understand why it doesn\\'t return 10 in the sample `7, 8, 9, 11, 12`. I have to think more on this."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Because positive integer starts at 1."
                    },
                    {
                        "username": "shoyebmd424",
                        "content": "i have used hashtable but showing TLE just i have used O(n) space and O(n) time complexity"
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Should not be in Hard Category "
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "your solution is more than O(1) space complexity, so technically you don\\'t meet the requirements"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "isn't a while loop(less or equal to len(nums)) without any nested loops O(n)? Then why am I getting a TLE error on case 171, which i think is no.s from 1-100k"
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem may not be the number of times through your loop, but it might be the amount of computation in each iteration.  My solution goes the the array 3 times with no TLE error."
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem states \"You must implement an algorithm that runs in O(n) time and uses constant extra space.\"  Yet, when I look at accepted solutions that supposedly ran faster than mine, I see that they sort the array using O(n log n) time, and/or they copy the array to a set using O(n) memory.  Why state a restriction if you don\\'t test to be sure the restriction is met?"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "Guys, could you tell me why the output of [1] should be 2 instead  of None?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "because 2 is the next position number. likewise ignoring duplicates if the array was [1,1] the answer would be 2 as well. "
                    },
                    {
                        "username": "bugsbunny99",
                        "content": "Anyone else who is puzzled about why this is a LeetCode \\'Hard\\' problem?"
                    },
                    {
                        "username": "akuthiala",
                        "content": "Why is this C++ code not working?\\nGives runtime error.\\n\\n\\n\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v(n,-1);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                v[nums[i]-1]=nums[i];\\n            }\\n        }\\n\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==-1){\\n                return i+1;\\n            }\\n        }\\n        return v.size();\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1810250,
                "content": [
                    {
                        "username": "RajYuvaraj",
                        "content": "for this testcase [3,4,-1,1], both 0 and 2 is missing. Am I correct ?"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "0 is not positive"
                    },
                    {
                        "username": "Ultron03",
                        "content": "CAN SOMEONE PLEASE HELP ME FINDING THE ERROR IN CODE ..\nIT IS GIVING TLE FOR  [1,2,2147483647] INPUT..\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n \n        int n=nums.size();\n       long long   int min=nums[0];\n         int max=nums[0];\n        for(int i=0;i<n;i++){\n         if(nums[i]>max){\n             max=nums[i];\n             \n         }\n         if(nums[i]<min){\n             min=nums[i];\n         }\n        }\n\n        if(min>1||max<=0){\n            return 1;\n        }\n      \n      map<long long int, int>m;\n  \n      for(int i=min;i<=max;i++){\n          m[i]=0;\n      }\n      for(int i=0;i<n;i++){\n          m[nums[i]]++;\n      }\n\n      for(int i=min;i<=max;i++){\n          if(m[i]==0 && i>0){\n              return i;\n          }\n      }\n\n      return max+1;\n\n    }\n};\n"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "What I don\\'t get is, the condition doesn\\'t specify that the `nums` is from 1 to n. Hence, I don\\'t understand why it doesn\\'t return 10 in the sample `7, 8, 9, 11, 12`. I have to think more on this."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Because positive integer starts at 1."
                    },
                    {
                        "username": "shoyebmd424",
                        "content": "i have used hashtable but showing TLE just i have used O(n) space and O(n) time complexity"
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Should not be in Hard Category "
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "your solution is more than O(1) space complexity, so technically you don\\'t meet the requirements"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "isn't a while loop(less or equal to len(nums)) without any nested loops O(n)? Then why am I getting a TLE error on case 171, which i think is no.s from 1-100k"
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem may not be the number of times through your loop, but it might be the amount of computation in each iteration.  My solution goes the the array 3 times with no TLE error."
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem states \"You must implement an algorithm that runs in O(n) time and uses constant extra space.\"  Yet, when I look at accepted solutions that supposedly ran faster than mine, I see that they sort the array using O(n log n) time, and/or they copy the array to a set using O(n) memory.  Why state a restriction if you don\\'t test to be sure the restriction is met?"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "Guys, could you tell me why the output of [1] should be 2 instead  of None?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "because 2 is the next position number. likewise ignoring duplicates if the array was [1,1] the answer would be 2 as well. "
                    },
                    {
                        "username": "bugsbunny99",
                        "content": "Anyone else who is puzzled about why this is a LeetCode \\'Hard\\' problem?"
                    },
                    {
                        "username": "akuthiala",
                        "content": "Why is this C++ code not working?\\nGives runtime error.\\n\\n\\n\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v(n,-1);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                v[nums[i]-1]=nums[i];\\n            }\\n        }\\n\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==-1){\\n                return i+1;\\n            }\\n        }\\n        return v.size();\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1809806,
                "content": [
                    {
                        "username": "jatinchoubey_19",
                        "content": "Can we not sort the Vector before solving ?"
                    },
                    {
                        "username": "shinedark",
                        "content": "Time Limit Exceeded ??? what does that mean  `var firstMissingPositive = function(nums) {\\n    let low = 1;\\n    while(nums.includes(low)){\\n        low++\\n    }\\n    return low\\n};`\\n\\nit works but I get the Time Limit Exceeded "
                    },
                    {
                        "username": "aqf00221",
                        "content": " `\ndef firstMissingPositive(self, nums: List[int]) -> int:\n        n = len(nums)\n        hash_set = set(nums)\n        \n        for i in range(1, n+1):\n            if i not in hash_set:\n                return i \n        return n+1\n`\n\nidea behind this: \nThe first missing positive cannot be greater than len(nums) + 1."
                    },
                    {
                        "username": "cheesebread",
                        "content": "Why is a hard? Are we assuming we can\\'t modify the input array...?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "im confused why are people asking why it\\'s hard?"
                    },
                    {
                        "username": "im_rish97",
                        "content": "WHY TLE in my code? \\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int curr_ind;\\n        for(int i=0;i<n;++i)\\n        {\\n            curr_ind=nums[i]-1;\\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[curr_ind])\\n                swap(nums[i],nums[curr_ind]);\\n\\n        }\\n         for(int i=0;i<n;++i)\\n         {\\n             if(nums[i]!=i+1)\\n                return i+1;\\n         }\\n    return n+1;\\n    }\\n};"
                    },
                    {
                        "username": "zloig",
                        "content": "These \"problem\" is bullsh*t.\\n1. Absolutely no problem-solving skill is exposed. You either know this trick or not. And again, it\\'s just a trick.\\n2. Nobody mentioned that we can change the given array. It was said we can use only O(1) memory, but as soon as we are able to touch the original array it\\'s not O(1) anymore but O(n). Because we are using an array.\\n\\n"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The First Missing Positive problem is a hard level question that asks you to find the smallest missing positive integer in an unsorted integer array. The solution must have a time complexity of O(n) and use constant extra space.\\n\\nOne way to solve this problem is to use the index of the array to store the positive integers in their correct position. For example, if we have a number x, we should put it in the position nums[x-1]. We need to iterate the array and for each number, swap it to its correct position until the array has all positive integers in their correct position. After that, we can iterate the array again to find the first missing positive integer by checking if the number in position i is not equal to i+1.\\n\\nFor example, in the case of [3, 4, -1, 1], after swapping, the array becomes [1, -1, 3, 4], and the first missing positive integer is 2, which is the first missing number in the sequence [1, 2, 3, ...].\\n\\nIn summary, the solution involves two steps:\\n\\nSwapping the numbers in the array to their correct position.\\nFinding the first missing positive integer by checking the sequence."
                    },
                    {
                        "username": "jkig",
                        "content": "bit of spoilers!!\\n\\nTrying to do this question in given bounds, and am pretty sure many of the solutions are wrong.\\nFirst question, does folowing python code:\\n\\nnums = set(nums)\\n\\nnot use O(n) space, because if not, then the answer is ez, but i would think while building the nums we need more than constant extra space. Would love to find out I\\'m wrong on this.\\nif this is allowed, then converting to a set and looping through, with iterator starting at 1 and returning for the first not to be found will def work in expected O(n), and the conversion to a set is also O(n), so that solution is fine."
                    },
                    {
                        "username": "adwi11",
                        "content": "Is this an O(n) solution, will appreciate the feedback !!\\n\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n      sn=1\\n      trav=set()\\n      for i in range(len(nums)):\\n        trav.add(nums[i])\\n        if sn==nums[i]:\\n            sn+=1\\n      while sn in trav:\\n           sn+=1\\n      return sn"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1808741,
                "content": [
                    {
                        "username": "jatinchoubey_19",
                        "content": "Can we not sort the Vector before solving ?"
                    },
                    {
                        "username": "shinedark",
                        "content": "Time Limit Exceeded ??? what does that mean  `var firstMissingPositive = function(nums) {\\n    let low = 1;\\n    while(nums.includes(low)){\\n        low++\\n    }\\n    return low\\n};`\\n\\nit works but I get the Time Limit Exceeded "
                    },
                    {
                        "username": "aqf00221",
                        "content": " `\ndef firstMissingPositive(self, nums: List[int]) -> int:\n        n = len(nums)\n        hash_set = set(nums)\n        \n        for i in range(1, n+1):\n            if i not in hash_set:\n                return i \n        return n+1\n`\n\nidea behind this: \nThe first missing positive cannot be greater than len(nums) + 1."
                    },
                    {
                        "username": "cheesebread",
                        "content": "Why is a hard? Are we assuming we can\\'t modify the input array...?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "im confused why are people asking why it\\'s hard?"
                    },
                    {
                        "username": "im_rish97",
                        "content": "WHY TLE in my code? \\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int curr_ind;\\n        for(int i=0;i<n;++i)\\n        {\\n            curr_ind=nums[i]-1;\\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[curr_ind])\\n                swap(nums[i],nums[curr_ind]);\\n\\n        }\\n         for(int i=0;i<n;++i)\\n         {\\n             if(nums[i]!=i+1)\\n                return i+1;\\n         }\\n    return n+1;\\n    }\\n};"
                    },
                    {
                        "username": "zloig",
                        "content": "These \"problem\" is bullsh*t.\\n1. Absolutely no problem-solving skill is exposed. You either know this trick or not. And again, it\\'s just a trick.\\n2. Nobody mentioned that we can change the given array. It was said we can use only O(1) memory, but as soon as we are able to touch the original array it\\'s not O(1) anymore but O(n). Because we are using an array.\\n\\n"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The First Missing Positive problem is a hard level question that asks you to find the smallest missing positive integer in an unsorted integer array. The solution must have a time complexity of O(n) and use constant extra space.\\n\\nOne way to solve this problem is to use the index of the array to store the positive integers in their correct position. For example, if we have a number x, we should put it in the position nums[x-1]. We need to iterate the array and for each number, swap it to its correct position until the array has all positive integers in their correct position. After that, we can iterate the array again to find the first missing positive integer by checking if the number in position i is not equal to i+1.\\n\\nFor example, in the case of [3, 4, -1, 1], after swapping, the array becomes [1, -1, 3, 4], and the first missing positive integer is 2, which is the first missing number in the sequence [1, 2, 3, ...].\\n\\nIn summary, the solution involves two steps:\\n\\nSwapping the numbers in the array to their correct position.\\nFinding the first missing positive integer by checking the sequence."
                    },
                    {
                        "username": "jkig",
                        "content": "bit of spoilers!!\\n\\nTrying to do this question in given bounds, and am pretty sure many of the solutions are wrong.\\nFirst question, does folowing python code:\\n\\nnums = set(nums)\\n\\nnot use O(n) space, because if not, then the answer is ez, but i would think while building the nums we need more than constant extra space. Would love to find out I\\'m wrong on this.\\nif this is allowed, then converting to a set and looping through, with iterator starting at 1 and returning for the first not to be found will def work in expected O(n), and the conversion to a set is also O(n), so that solution is fine."
                    },
                    {
                        "username": "adwi11",
                        "content": "Is this an O(n) solution, will appreciate the feedback !!\\n\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n      sn=1\\n      trav=set()\\n      for i in range(len(nums)):\\n        trav.add(nums[i])\\n        if sn==nums[i]:\\n            sn+=1\\n      while sn in trav:\\n           sn+=1\\n      return sn"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1807844,
                "content": [
                    {
                        "username": "jatinchoubey_19",
                        "content": "Can we not sort the Vector before solving ?"
                    },
                    {
                        "username": "shinedark",
                        "content": "Time Limit Exceeded ??? what does that mean  `var firstMissingPositive = function(nums) {\\n    let low = 1;\\n    while(nums.includes(low)){\\n        low++\\n    }\\n    return low\\n};`\\n\\nit works but I get the Time Limit Exceeded "
                    },
                    {
                        "username": "aqf00221",
                        "content": " `\ndef firstMissingPositive(self, nums: List[int]) -> int:\n        n = len(nums)\n        hash_set = set(nums)\n        \n        for i in range(1, n+1):\n            if i not in hash_set:\n                return i \n        return n+1\n`\n\nidea behind this: \nThe first missing positive cannot be greater than len(nums) + 1."
                    },
                    {
                        "username": "cheesebread",
                        "content": "Why is a hard? Are we assuming we can\\'t modify the input array...?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "im confused why are people asking why it\\'s hard?"
                    },
                    {
                        "username": "im_rish97",
                        "content": "WHY TLE in my code? \\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int curr_ind;\\n        for(int i=0;i<n;++i)\\n        {\\n            curr_ind=nums[i]-1;\\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[curr_ind])\\n                swap(nums[i],nums[curr_ind]);\\n\\n        }\\n         for(int i=0;i<n;++i)\\n         {\\n             if(nums[i]!=i+1)\\n                return i+1;\\n         }\\n    return n+1;\\n    }\\n};"
                    },
                    {
                        "username": "zloig",
                        "content": "These \"problem\" is bullsh*t.\\n1. Absolutely no problem-solving skill is exposed. You either know this trick or not. And again, it\\'s just a trick.\\n2. Nobody mentioned that we can change the given array. It was said we can use only O(1) memory, but as soon as we are able to touch the original array it\\'s not O(1) anymore but O(n). Because we are using an array.\\n\\n"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The First Missing Positive problem is a hard level question that asks you to find the smallest missing positive integer in an unsorted integer array. The solution must have a time complexity of O(n) and use constant extra space.\\n\\nOne way to solve this problem is to use the index of the array to store the positive integers in their correct position. For example, if we have a number x, we should put it in the position nums[x-1]. We need to iterate the array and for each number, swap it to its correct position until the array has all positive integers in their correct position. After that, we can iterate the array again to find the first missing positive integer by checking if the number in position i is not equal to i+1.\\n\\nFor example, in the case of [3, 4, -1, 1], after swapping, the array becomes [1, -1, 3, 4], and the first missing positive integer is 2, which is the first missing number in the sequence [1, 2, 3, ...].\\n\\nIn summary, the solution involves two steps:\\n\\nSwapping the numbers in the array to their correct position.\\nFinding the first missing positive integer by checking the sequence."
                    },
                    {
                        "username": "jkig",
                        "content": "bit of spoilers!!\\n\\nTrying to do this question in given bounds, and am pretty sure many of the solutions are wrong.\\nFirst question, does folowing python code:\\n\\nnums = set(nums)\\n\\nnot use O(n) space, because if not, then the answer is ez, but i would think while building the nums we need more than constant extra space. Would love to find out I\\'m wrong on this.\\nif this is allowed, then converting to a set and looping through, with iterator starting at 1 and returning for the first not to be found will def work in expected O(n), and the conversion to a set is also O(n), so that solution is fine."
                    },
                    {
                        "username": "adwi11",
                        "content": "Is this an O(n) solution, will appreciate the feedback !!\\n\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n      sn=1\\n      trav=set()\\n      for i in range(len(nums)):\\n        trav.add(nums[i])\\n        if sn==nums[i]:\\n            sn+=1\\n      while sn in trav:\\n           sn+=1\\n      return sn"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1807475,
                "content": [
                    {
                        "username": "jatinchoubey_19",
                        "content": "Can we not sort the Vector before solving ?"
                    },
                    {
                        "username": "shinedark",
                        "content": "Time Limit Exceeded ??? what does that mean  `var firstMissingPositive = function(nums) {\\n    let low = 1;\\n    while(nums.includes(low)){\\n        low++\\n    }\\n    return low\\n};`\\n\\nit works but I get the Time Limit Exceeded "
                    },
                    {
                        "username": "aqf00221",
                        "content": " `\ndef firstMissingPositive(self, nums: List[int]) -> int:\n        n = len(nums)\n        hash_set = set(nums)\n        \n        for i in range(1, n+1):\n            if i not in hash_set:\n                return i \n        return n+1\n`\n\nidea behind this: \nThe first missing positive cannot be greater than len(nums) + 1."
                    },
                    {
                        "username": "cheesebread",
                        "content": "Why is a hard? Are we assuming we can\\'t modify the input array...?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "im confused why are people asking why it\\'s hard?"
                    },
                    {
                        "username": "im_rish97",
                        "content": "WHY TLE in my code? \\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int curr_ind;\\n        for(int i=0;i<n;++i)\\n        {\\n            curr_ind=nums[i]-1;\\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[curr_ind])\\n                swap(nums[i],nums[curr_ind]);\\n\\n        }\\n         for(int i=0;i<n;++i)\\n         {\\n             if(nums[i]!=i+1)\\n                return i+1;\\n         }\\n    return n+1;\\n    }\\n};"
                    },
                    {
                        "username": "zloig",
                        "content": "These \"problem\" is bullsh*t.\\n1. Absolutely no problem-solving skill is exposed. You either know this trick or not. And again, it\\'s just a trick.\\n2. Nobody mentioned that we can change the given array. It was said we can use only O(1) memory, but as soon as we are able to touch the original array it\\'s not O(1) anymore but O(n). Because we are using an array.\\n\\n"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The First Missing Positive problem is a hard level question that asks you to find the smallest missing positive integer in an unsorted integer array. The solution must have a time complexity of O(n) and use constant extra space.\\n\\nOne way to solve this problem is to use the index of the array to store the positive integers in their correct position. For example, if we have a number x, we should put it in the position nums[x-1]. We need to iterate the array and for each number, swap it to its correct position until the array has all positive integers in their correct position. After that, we can iterate the array again to find the first missing positive integer by checking if the number in position i is not equal to i+1.\\n\\nFor example, in the case of [3, 4, -1, 1], after swapping, the array becomes [1, -1, 3, 4], and the first missing positive integer is 2, which is the first missing number in the sequence [1, 2, 3, ...].\\n\\nIn summary, the solution involves two steps:\\n\\nSwapping the numbers in the array to their correct position.\\nFinding the first missing positive integer by checking the sequence."
                    },
                    {
                        "username": "jkig",
                        "content": "bit of spoilers!!\\n\\nTrying to do this question in given bounds, and am pretty sure many of the solutions are wrong.\\nFirst question, does folowing python code:\\n\\nnums = set(nums)\\n\\nnot use O(n) space, because if not, then the answer is ez, but i would think while building the nums we need more than constant extra space. Would love to find out I\\'m wrong on this.\\nif this is allowed, then converting to a set and looping through, with iterator starting at 1 and returning for the first not to be found will def work in expected O(n), and the conversion to a set is also O(n), so that solution is fine."
                    },
                    {
                        "username": "adwi11",
                        "content": "Is this an O(n) solution, will appreciate the feedback !!\\n\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n      sn=1\\n      trav=set()\\n      for i in range(len(nums)):\\n        trav.add(nums[i])\\n        if sn==nums[i]:\\n            sn+=1\\n      while sn in trav:\\n           sn+=1\\n      return sn"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1799190,
                "content": [
                    {
                        "username": "jatinchoubey_19",
                        "content": "Can we not sort the Vector before solving ?"
                    },
                    {
                        "username": "shinedark",
                        "content": "Time Limit Exceeded ??? what does that mean  `var firstMissingPositive = function(nums) {\\n    let low = 1;\\n    while(nums.includes(low)){\\n        low++\\n    }\\n    return low\\n};`\\n\\nit works but I get the Time Limit Exceeded "
                    },
                    {
                        "username": "aqf00221",
                        "content": " `\ndef firstMissingPositive(self, nums: List[int]) -> int:\n        n = len(nums)\n        hash_set = set(nums)\n        \n        for i in range(1, n+1):\n            if i not in hash_set:\n                return i \n        return n+1\n`\n\nidea behind this: \nThe first missing positive cannot be greater than len(nums) + 1."
                    },
                    {
                        "username": "cheesebread",
                        "content": "Why is a hard? Are we assuming we can\\'t modify the input array...?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "im confused why are people asking why it\\'s hard?"
                    },
                    {
                        "username": "im_rish97",
                        "content": "WHY TLE in my code? \\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int curr_ind;\\n        for(int i=0;i<n;++i)\\n        {\\n            curr_ind=nums[i]-1;\\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[curr_ind])\\n                swap(nums[i],nums[curr_ind]);\\n\\n        }\\n         for(int i=0;i<n;++i)\\n         {\\n             if(nums[i]!=i+1)\\n                return i+1;\\n         }\\n    return n+1;\\n    }\\n};"
                    },
                    {
                        "username": "zloig",
                        "content": "These \"problem\" is bullsh*t.\\n1. Absolutely no problem-solving skill is exposed. You either know this trick or not. And again, it\\'s just a trick.\\n2. Nobody mentioned that we can change the given array. It was said we can use only O(1) memory, but as soon as we are able to touch the original array it\\'s not O(1) anymore but O(n). Because we are using an array.\\n\\n"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The First Missing Positive problem is a hard level question that asks you to find the smallest missing positive integer in an unsorted integer array. The solution must have a time complexity of O(n) and use constant extra space.\\n\\nOne way to solve this problem is to use the index of the array to store the positive integers in their correct position. For example, if we have a number x, we should put it in the position nums[x-1]. We need to iterate the array and for each number, swap it to its correct position until the array has all positive integers in their correct position. After that, we can iterate the array again to find the first missing positive integer by checking if the number in position i is not equal to i+1.\\n\\nFor example, in the case of [3, 4, -1, 1], after swapping, the array becomes [1, -1, 3, 4], and the first missing positive integer is 2, which is the first missing number in the sequence [1, 2, 3, ...].\\n\\nIn summary, the solution involves two steps:\\n\\nSwapping the numbers in the array to their correct position.\\nFinding the first missing positive integer by checking the sequence."
                    },
                    {
                        "username": "jkig",
                        "content": "bit of spoilers!!\\n\\nTrying to do this question in given bounds, and am pretty sure many of the solutions are wrong.\\nFirst question, does folowing python code:\\n\\nnums = set(nums)\\n\\nnot use O(n) space, because if not, then the answer is ez, but i would think while building the nums we need more than constant extra space. Would love to find out I\\'m wrong on this.\\nif this is allowed, then converting to a set and looping through, with iterator starting at 1 and returning for the first not to be found will def work in expected O(n), and the conversion to a set is also O(n), so that solution is fine."
                    },
                    {
                        "username": "adwi11",
                        "content": "Is this an O(n) solution, will appreciate the feedback !!\\n\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n      sn=1\\n      trav=set()\\n      for i in range(len(nums)):\\n        trav.add(nums[i])\\n        if sn==nums[i]:\\n            sn+=1\\n      while sn in trav:\\n           sn+=1\\n      return sn"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1793774,
                "content": [
                    {
                        "username": "jatinchoubey_19",
                        "content": "Can we not sort the Vector before solving ?"
                    },
                    {
                        "username": "shinedark",
                        "content": "Time Limit Exceeded ??? what does that mean  `var firstMissingPositive = function(nums) {\\n    let low = 1;\\n    while(nums.includes(low)){\\n        low++\\n    }\\n    return low\\n};`\\n\\nit works but I get the Time Limit Exceeded "
                    },
                    {
                        "username": "aqf00221",
                        "content": " `\ndef firstMissingPositive(self, nums: List[int]) -> int:\n        n = len(nums)\n        hash_set = set(nums)\n        \n        for i in range(1, n+1):\n            if i not in hash_set:\n                return i \n        return n+1\n`\n\nidea behind this: \nThe first missing positive cannot be greater than len(nums) + 1."
                    },
                    {
                        "username": "cheesebread",
                        "content": "Why is a hard? Are we assuming we can\\'t modify the input array...?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "im confused why are people asking why it\\'s hard?"
                    },
                    {
                        "username": "im_rish97",
                        "content": "WHY TLE in my code? \\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int curr_ind;\\n        for(int i=0;i<n;++i)\\n        {\\n            curr_ind=nums[i]-1;\\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[curr_ind])\\n                swap(nums[i],nums[curr_ind]);\\n\\n        }\\n         for(int i=0;i<n;++i)\\n         {\\n             if(nums[i]!=i+1)\\n                return i+1;\\n         }\\n    return n+1;\\n    }\\n};"
                    },
                    {
                        "username": "zloig",
                        "content": "These \"problem\" is bullsh*t.\\n1. Absolutely no problem-solving skill is exposed. You either know this trick or not. And again, it\\'s just a trick.\\n2. Nobody mentioned that we can change the given array. It was said we can use only O(1) memory, but as soon as we are able to touch the original array it\\'s not O(1) anymore but O(n). Because we are using an array.\\n\\n"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The First Missing Positive problem is a hard level question that asks you to find the smallest missing positive integer in an unsorted integer array. The solution must have a time complexity of O(n) and use constant extra space.\\n\\nOne way to solve this problem is to use the index of the array to store the positive integers in their correct position. For example, if we have a number x, we should put it in the position nums[x-1]. We need to iterate the array and for each number, swap it to its correct position until the array has all positive integers in their correct position. After that, we can iterate the array again to find the first missing positive integer by checking if the number in position i is not equal to i+1.\\n\\nFor example, in the case of [3, 4, -1, 1], after swapping, the array becomes [1, -1, 3, 4], and the first missing positive integer is 2, which is the first missing number in the sequence [1, 2, 3, ...].\\n\\nIn summary, the solution involves two steps:\\n\\nSwapping the numbers in the array to their correct position.\\nFinding the first missing positive integer by checking the sequence."
                    },
                    {
                        "username": "jkig",
                        "content": "bit of spoilers!!\\n\\nTrying to do this question in given bounds, and am pretty sure many of the solutions are wrong.\\nFirst question, does folowing python code:\\n\\nnums = set(nums)\\n\\nnot use O(n) space, because if not, then the answer is ez, but i would think while building the nums we need more than constant extra space. Would love to find out I\\'m wrong on this.\\nif this is allowed, then converting to a set and looping through, with iterator starting at 1 and returning for the first not to be found will def work in expected O(n), and the conversion to a set is also O(n), so that solution is fine."
                    },
                    {
                        "username": "adwi11",
                        "content": "Is this an O(n) solution, will appreciate the feedback !!\\n\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n      sn=1\\n      trav=set()\\n      for i in range(len(nums)):\\n        trav.add(nums[i])\\n        if sn==nums[i]:\\n            sn+=1\\n      while sn in trav:\\n           sn+=1\\n      return sn"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1792234,
                "content": [
                    {
                        "username": "jatinchoubey_19",
                        "content": "Can we not sort the Vector before solving ?"
                    },
                    {
                        "username": "shinedark",
                        "content": "Time Limit Exceeded ??? what does that mean  `var firstMissingPositive = function(nums) {\\n    let low = 1;\\n    while(nums.includes(low)){\\n        low++\\n    }\\n    return low\\n};`\\n\\nit works but I get the Time Limit Exceeded "
                    },
                    {
                        "username": "aqf00221",
                        "content": " `\ndef firstMissingPositive(self, nums: List[int]) -> int:\n        n = len(nums)\n        hash_set = set(nums)\n        \n        for i in range(1, n+1):\n            if i not in hash_set:\n                return i \n        return n+1\n`\n\nidea behind this: \nThe first missing positive cannot be greater than len(nums) + 1."
                    },
                    {
                        "username": "cheesebread",
                        "content": "Why is a hard? Are we assuming we can\\'t modify the input array...?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "im confused why are people asking why it\\'s hard?"
                    },
                    {
                        "username": "im_rish97",
                        "content": "WHY TLE in my code? \\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int curr_ind;\\n        for(int i=0;i<n;++i)\\n        {\\n            curr_ind=nums[i]-1;\\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[curr_ind])\\n                swap(nums[i],nums[curr_ind]);\\n\\n        }\\n         for(int i=0;i<n;++i)\\n         {\\n             if(nums[i]!=i+1)\\n                return i+1;\\n         }\\n    return n+1;\\n    }\\n};"
                    },
                    {
                        "username": "zloig",
                        "content": "These \"problem\" is bullsh*t.\\n1. Absolutely no problem-solving skill is exposed. You either know this trick or not. And again, it\\'s just a trick.\\n2. Nobody mentioned that we can change the given array. It was said we can use only O(1) memory, but as soon as we are able to touch the original array it\\'s not O(1) anymore but O(n). Because we are using an array.\\n\\n"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The First Missing Positive problem is a hard level question that asks you to find the smallest missing positive integer in an unsorted integer array. The solution must have a time complexity of O(n) and use constant extra space.\\n\\nOne way to solve this problem is to use the index of the array to store the positive integers in their correct position. For example, if we have a number x, we should put it in the position nums[x-1]. We need to iterate the array and for each number, swap it to its correct position until the array has all positive integers in their correct position. After that, we can iterate the array again to find the first missing positive integer by checking if the number in position i is not equal to i+1.\\n\\nFor example, in the case of [3, 4, -1, 1], after swapping, the array becomes [1, -1, 3, 4], and the first missing positive integer is 2, which is the first missing number in the sequence [1, 2, 3, ...].\\n\\nIn summary, the solution involves two steps:\\n\\nSwapping the numbers in the array to their correct position.\\nFinding the first missing positive integer by checking the sequence."
                    },
                    {
                        "username": "jkig",
                        "content": "bit of spoilers!!\\n\\nTrying to do this question in given bounds, and am pretty sure many of the solutions are wrong.\\nFirst question, does folowing python code:\\n\\nnums = set(nums)\\n\\nnot use O(n) space, because if not, then the answer is ez, but i would think while building the nums we need more than constant extra space. Would love to find out I\\'m wrong on this.\\nif this is allowed, then converting to a set and looping through, with iterator starting at 1 and returning for the first not to be found will def work in expected O(n), and the conversion to a set is also O(n), so that solution is fine."
                    },
                    {
                        "username": "adwi11",
                        "content": "Is this an O(n) solution, will appreciate the feedback !!\\n\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n      sn=1\\n      trav=set()\\n      for i in range(len(nums)):\\n        trav.add(nums[i])\\n        if sn==nums[i]:\\n            sn+=1\\n      while sn in trav:\\n           sn+=1\\n      return sn"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1777029,
                "content": [
                    {
                        "username": "jatinchoubey_19",
                        "content": "Can we not sort the Vector before solving ?"
                    },
                    {
                        "username": "shinedark",
                        "content": "Time Limit Exceeded ??? what does that mean  `var firstMissingPositive = function(nums) {\\n    let low = 1;\\n    while(nums.includes(low)){\\n        low++\\n    }\\n    return low\\n};`\\n\\nit works but I get the Time Limit Exceeded "
                    },
                    {
                        "username": "aqf00221",
                        "content": " `\ndef firstMissingPositive(self, nums: List[int]) -> int:\n        n = len(nums)\n        hash_set = set(nums)\n        \n        for i in range(1, n+1):\n            if i not in hash_set:\n                return i \n        return n+1\n`\n\nidea behind this: \nThe first missing positive cannot be greater than len(nums) + 1."
                    },
                    {
                        "username": "cheesebread",
                        "content": "Why is a hard? Are we assuming we can\\'t modify the input array...?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "im confused why are people asking why it\\'s hard?"
                    },
                    {
                        "username": "im_rish97",
                        "content": "WHY TLE in my code? \\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int curr_ind;\\n        for(int i=0;i<n;++i)\\n        {\\n            curr_ind=nums[i]-1;\\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[curr_ind])\\n                swap(nums[i],nums[curr_ind]);\\n\\n        }\\n         for(int i=0;i<n;++i)\\n         {\\n             if(nums[i]!=i+1)\\n                return i+1;\\n         }\\n    return n+1;\\n    }\\n};"
                    },
                    {
                        "username": "zloig",
                        "content": "These \"problem\" is bullsh*t.\\n1. Absolutely no problem-solving skill is exposed. You either know this trick or not. And again, it\\'s just a trick.\\n2. Nobody mentioned that we can change the given array. It was said we can use only O(1) memory, but as soon as we are able to touch the original array it\\'s not O(1) anymore but O(n). Because we are using an array.\\n\\n"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The First Missing Positive problem is a hard level question that asks you to find the smallest missing positive integer in an unsorted integer array. The solution must have a time complexity of O(n) and use constant extra space.\\n\\nOne way to solve this problem is to use the index of the array to store the positive integers in their correct position. For example, if we have a number x, we should put it in the position nums[x-1]. We need to iterate the array and for each number, swap it to its correct position until the array has all positive integers in their correct position. After that, we can iterate the array again to find the first missing positive integer by checking if the number in position i is not equal to i+1.\\n\\nFor example, in the case of [3, 4, -1, 1], after swapping, the array becomes [1, -1, 3, 4], and the first missing positive integer is 2, which is the first missing number in the sequence [1, 2, 3, ...].\\n\\nIn summary, the solution involves two steps:\\n\\nSwapping the numbers in the array to their correct position.\\nFinding the first missing positive integer by checking the sequence."
                    },
                    {
                        "username": "jkig",
                        "content": "bit of spoilers!!\\n\\nTrying to do this question in given bounds, and am pretty sure many of the solutions are wrong.\\nFirst question, does folowing python code:\\n\\nnums = set(nums)\\n\\nnot use O(n) space, because if not, then the answer is ez, but i would think while building the nums we need more than constant extra space. Would love to find out I\\'m wrong on this.\\nif this is allowed, then converting to a set and looping through, with iterator starting at 1 and returning for the first not to be found will def work in expected O(n), and the conversion to a set is also O(n), so that solution is fine."
                    },
                    {
                        "username": "adwi11",
                        "content": "Is this an O(n) solution, will appreciate the feedback !!\\n\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n      sn=1\\n      trav=set()\\n      for i in range(len(nums)):\\n        trav.add(nums[i])\\n        if sn==nums[i]:\\n            sn+=1\\n      while sn in trav:\\n           sn+=1\\n      return sn"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1773895,
                "content": [
                    {
                        "username": "jatinchoubey_19",
                        "content": "Can we not sort the Vector before solving ?"
                    },
                    {
                        "username": "shinedark",
                        "content": "Time Limit Exceeded ??? what does that mean  `var firstMissingPositive = function(nums) {\\n    let low = 1;\\n    while(nums.includes(low)){\\n        low++\\n    }\\n    return low\\n};`\\n\\nit works but I get the Time Limit Exceeded "
                    },
                    {
                        "username": "aqf00221",
                        "content": " `\ndef firstMissingPositive(self, nums: List[int]) -> int:\n        n = len(nums)\n        hash_set = set(nums)\n        \n        for i in range(1, n+1):\n            if i not in hash_set:\n                return i \n        return n+1\n`\n\nidea behind this: \nThe first missing positive cannot be greater than len(nums) + 1."
                    },
                    {
                        "username": "cheesebread",
                        "content": "Why is a hard? Are we assuming we can\\'t modify the input array...?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "im confused why are people asking why it\\'s hard?"
                    },
                    {
                        "username": "im_rish97",
                        "content": "WHY TLE in my code? \\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int curr_ind;\\n        for(int i=0;i<n;++i)\\n        {\\n            curr_ind=nums[i]-1;\\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[curr_ind])\\n                swap(nums[i],nums[curr_ind]);\\n\\n        }\\n         for(int i=0;i<n;++i)\\n         {\\n             if(nums[i]!=i+1)\\n                return i+1;\\n         }\\n    return n+1;\\n    }\\n};"
                    },
                    {
                        "username": "zloig",
                        "content": "These \"problem\" is bullsh*t.\\n1. Absolutely no problem-solving skill is exposed. You either know this trick or not. And again, it\\'s just a trick.\\n2. Nobody mentioned that we can change the given array. It was said we can use only O(1) memory, but as soon as we are able to touch the original array it\\'s not O(1) anymore but O(n). Because we are using an array.\\n\\n"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The First Missing Positive problem is a hard level question that asks you to find the smallest missing positive integer in an unsorted integer array. The solution must have a time complexity of O(n) and use constant extra space.\\n\\nOne way to solve this problem is to use the index of the array to store the positive integers in their correct position. For example, if we have a number x, we should put it in the position nums[x-1]. We need to iterate the array and for each number, swap it to its correct position until the array has all positive integers in their correct position. After that, we can iterate the array again to find the first missing positive integer by checking if the number in position i is not equal to i+1.\\n\\nFor example, in the case of [3, 4, -1, 1], after swapping, the array becomes [1, -1, 3, 4], and the first missing positive integer is 2, which is the first missing number in the sequence [1, 2, 3, ...].\\n\\nIn summary, the solution involves two steps:\\n\\nSwapping the numbers in the array to their correct position.\\nFinding the first missing positive integer by checking the sequence."
                    },
                    {
                        "username": "jkig",
                        "content": "bit of spoilers!!\\n\\nTrying to do this question in given bounds, and am pretty sure many of the solutions are wrong.\\nFirst question, does folowing python code:\\n\\nnums = set(nums)\\n\\nnot use O(n) space, because if not, then the answer is ez, but i would think while building the nums we need more than constant extra space. Would love to find out I\\'m wrong on this.\\nif this is allowed, then converting to a set and looping through, with iterator starting at 1 and returning for the first not to be found will def work in expected O(n), and the conversion to a set is also O(n), so that solution is fine."
                    },
                    {
                        "username": "adwi11",
                        "content": "Is this an O(n) solution, will appreciate the feedback !!\\n\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n      sn=1\\n      trav=set()\\n      for i in range(len(nums)):\\n        trav.add(nums[i])\\n        if sn==nums[i]:\\n            sn+=1\\n      while sn in trav:\\n           sn+=1\\n      return sn"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1768444,
                "content": [
                    {
                        "username": "jatinchoubey_19",
                        "content": "Can we not sort the Vector before solving ?"
                    },
                    {
                        "username": "shinedark",
                        "content": "Time Limit Exceeded ??? what does that mean  `var firstMissingPositive = function(nums) {\\n    let low = 1;\\n    while(nums.includes(low)){\\n        low++\\n    }\\n    return low\\n};`\\n\\nit works but I get the Time Limit Exceeded "
                    },
                    {
                        "username": "aqf00221",
                        "content": " `\ndef firstMissingPositive(self, nums: List[int]) -> int:\n        n = len(nums)\n        hash_set = set(nums)\n        \n        for i in range(1, n+1):\n            if i not in hash_set:\n                return i \n        return n+1\n`\n\nidea behind this: \nThe first missing positive cannot be greater than len(nums) + 1."
                    },
                    {
                        "username": "cheesebread",
                        "content": "Why is a hard? Are we assuming we can\\'t modify the input array...?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "im confused why are people asking why it\\'s hard?"
                    },
                    {
                        "username": "im_rish97",
                        "content": "WHY TLE in my code? \\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int curr_ind;\\n        for(int i=0;i<n;++i)\\n        {\\n            curr_ind=nums[i]-1;\\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[curr_ind])\\n                swap(nums[i],nums[curr_ind]);\\n\\n        }\\n         for(int i=0;i<n;++i)\\n         {\\n             if(nums[i]!=i+1)\\n                return i+1;\\n         }\\n    return n+1;\\n    }\\n};"
                    },
                    {
                        "username": "zloig",
                        "content": "These \"problem\" is bullsh*t.\\n1. Absolutely no problem-solving skill is exposed. You either know this trick or not. And again, it\\'s just a trick.\\n2. Nobody mentioned that we can change the given array. It was said we can use only O(1) memory, but as soon as we are able to touch the original array it\\'s not O(1) anymore but O(n). Because we are using an array.\\n\\n"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The First Missing Positive problem is a hard level question that asks you to find the smallest missing positive integer in an unsorted integer array. The solution must have a time complexity of O(n) and use constant extra space.\\n\\nOne way to solve this problem is to use the index of the array to store the positive integers in their correct position. For example, if we have a number x, we should put it in the position nums[x-1]. We need to iterate the array and for each number, swap it to its correct position until the array has all positive integers in their correct position. After that, we can iterate the array again to find the first missing positive integer by checking if the number in position i is not equal to i+1.\\n\\nFor example, in the case of [3, 4, -1, 1], after swapping, the array becomes [1, -1, 3, 4], and the first missing positive integer is 2, which is the first missing number in the sequence [1, 2, 3, ...].\\n\\nIn summary, the solution involves two steps:\\n\\nSwapping the numbers in the array to their correct position.\\nFinding the first missing positive integer by checking the sequence."
                    },
                    {
                        "username": "jkig",
                        "content": "bit of spoilers!!\\n\\nTrying to do this question in given bounds, and am pretty sure many of the solutions are wrong.\\nFirst question, does folowing python code:\\n\\nnums = set(nums)\\n\\nnot use O(n) space, because if not, then the answer is ez, but i would think while building the nums we need more than constant extra space. Would love to find out I\\'m wrong on this.\\nif this is allowed, then converting to a set and looping through, with iterator starting at 1 and returning for the first not to be found will def work in expected O(n), and the conversion to a set is also O(n), so that solution is fine."
                    },
                    {
                        "username": "adwi11",
                        "content": "Is this an O(n) solution, will appreciate the feedback !!\\n\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n      sn=1\\n      trav=set()\\n      for i in range(len(nums)):\\n        trav.add(nums[i])\\n        if sn==nums[i]:\\n            sn+=1\\n      while sn in trav:\\n           sn+=1\\n      return sn"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1755671,
                "content": [
                    {
                        "username": "kBrostoff",
                        "content": "I have a solution that is using a single for loop, but getting stuck on `#40/173` test case. It has an input of `[1]` and it expects an output of `2`. i\\'m a bit confused.\\n\\n```python\\nfrom typing import List\\n\\nclass Solution:\\n\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\tn: int = 1\\n\\t\\ttotal: int = 0\\n\\n\\t\\tfor num in nums:\\n\\t\\t\\tif num > 0 and num < len(nums):\\n\\t\\t\\t\\tn += 1\\n\\t\\t\\t\\ttotal += num\\n\\t\\texpected: int = int((n * (n + 1)) / 2)\\n\\t\\treturn expected - total\\n```"
                    },
                    {
                        "username": "alph-mephesto",
                        "content": "The description strictly says that the answer has to be in O(n) time. Well I sorted the array and solved the problem, but not only it didn\\'t fail because of the insufficient complexity but also it was faster than the vast majority of the submitted solutions.\\nI am really looking for a solution that doesn\\'t require to modify the input. If any one here has a suggestion please help me, because I wasn\\'t able to find any solution satisfying this criteria among the submitted solutions."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "1ncu804u",
                        "content": "should this be a hard \\uD83E\\uDD74 ?"
                    },
                    {
                        "username": "wey53l",
                        "content": "what is the time limit exceeded problem with my code ?\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        if max(nums) < 0 or min(nums) > 1:\\n            return 1\\n        for i in range(1,max(nums)):\\n            if i not in set(nums):\\n                return i\\n        return max(nums) + 1"
                    },
                    {
                        "username": "karthik87",
                        "content": "Another way to solve the problem\n\ns = startIndex, e = endIndex\npartition the array around(s+e)/2 and keep count on both sides\nrecurse on the half with less than expected count\n\nThis is O(n) not O(nlogn)"
                    },
                    {
                        "username": "nivi77",
                        "content": "Why did Leetcode not throw a TLE in a nlog n solution?"
                    },
                    {
                        "username": "nivi77",
                        "content": "I solved using O(n log n) time still my solution was accepted.\\nShouldn\\'t it deny because of TLE?"
                    },
                    {
                        "username": "RaktimChowdhury",
                        "content": "I solved this problem using O(n) time complexity but LeetCode is actually terrible in implementing the time complexities that are mentioned in the problem description. The number of times I have seen that the descripted time complexity is O(n) but users have submitted their code successfully using O(n log n) is absolutely funny. Its a problem from their side."
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "Going to join the choir to say that the solution expected here (utilizing O(1)) space is a completely impractical solution that you should almost never use in production code, and even if by some rare case you need something like it for something to work under severe resource constraints, you would practically need to put bright flashing lights around the screen every time a future developer goes to use the function to remind them that the function destroys/consumes the input data.\\n\\nSome languages make consuming the input a normal part of operation, forcing you to copy the input if it\\'s something you want to reuse, but if you\\'re going to use the memory to copy the input, then you might as well use an algorithmically simpler solution utilizing O(n) space."
                    },
                    {
                        "username": "generalkernel",
                        "content": "At first I thought the solution utilized some \"trick\" with summing the elements or counting the number of elements that aren\\'t part of the solution.  But instead, try to think of the O(n) space answer, and utilize the space already provided to try and match the data structure of the O(n) answer"
                    }
                ]
            },
            {
                "id": 1754856,
                "content": [
                    {
                        "username": "kBrostoff",
                        "content": "I have a solution that is using a single for loop, but getting stuck on `#40/173` test case. It has an input of `[1]` and it expects an output of `2`. i\\'m a bit confused.\\n\\n```python\\nfrom typing import List\\n\\nclass Solution:\\n\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\tn: int = 1\\n\\t\\ttotal: int = 0\\n\\n\\t\\tfor num in nums:\\n\\t\\t\\tif num > 0 and num < len(nums):\\n\\t\\t\\t\\tn += 1\\n\\t\\t\\t\\ttotal += num\\n\\t\\texpected: int = int((n * (n + 1)) / 2)\\n\\t\\treturn expected - total\\n```"
                    },
                    {
                        "username": "alph-mephesto",
                        "content": "The description strictly says that the answer has to be in O(n) time. Well I sorted the array and solved the problem, but not only it didn\\'t fail because of the insufficient complexity but also it was faster than the vast majority of the submitted solutions.\\nI am really looking for a solution that doesn\\'t require to modify the input. If any one here has a suggestion please help me, because I wasn\\'t able to find any solution satisfying this criteria among the submitted solutions."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "1ncu804u",
                        "content": "should this be a hard \\uD83E\\uDD74 ?"
                    },
                    {
                        "username": "wey53l",
                        "content": "what is the time limit exceeded problem with my code ?\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        if max(nums) < 0 or min(nums) > 1:\\n            return 1\\n        for i in range(1,max(nums)):\\n            if i not in set(nums):\\n                return i\\n        return max(nums) + 1"
                    },
                    {
                        "username": "karthik87",
                        "content": "Another way to solve the problem\n\ns = startIndex, e = endIndex\npartition the array around(s+e)/2 and keep count on both sides\nrecurse on the half with less than expected count\n\nThis is O(n) not O(nlogn)"
                    },
                    {
                        "username": "nivi77",
                        "content": "Why did Leetcode not throw a TLE in a nlog n solution?"
                    },
                    {
                        "username": "nivi77",
                        "content": "I solved using O(n log n) time still my solution was accepted.\\nShouldn\\'t it deny because of TLE?"
                    },
                    {
                        "username": "RaktimChowdhury",
                        "content": "I solved this problem using O(n) time complexity but LeetCode is actually terrible in implementing the time complexities that are mentioned in the problem description. The number of times I have seen that the descripted time complexity is O(n) but users have submitted their code successfully using O(n log n) is absolutely funny. Its a problem from their side."
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "Going to join the choir to say that the solution expected here (utilizing O(1)) space is a completely impractical solution that you should almost never use in production code, and even if by some rare case you need something like it for something to work under severe resource constraints, you would practically need to put bright flashing lights around the screen every time a future developer goes to use the function to remind them that the function destroys/consumes the input data.\\n\\nSome languages make consuming the input a normal part of operation, forcing you to copy the input if it\\'s something you want to reuse, but if you\\'re going to use the memory to copy the input, then you might as well use an algorithmically simpler solution utilizing O(n) space."
                    },
                    {
                        "username": "generalkernel",
                        "content": "At first I thought the solution utilized some \"trick\" with summing the elements or counting the number of elements that aren\\'t part of the solution.  But instead, try to think of the O(n) space answer, and utilize the space already provided to try and match the data structure of the O(n) answer"
                    }
                ]
            },
            {
                "id": 1752617,
                "content": [
                    {
                        "username": "kBrostoff",
                        "content": "I have a solution that is using a single for loop, but getting stuck on `#40/173` test case. It has an input of `[1]` and it expects an output of `2`. i\\'m a bit confused.\\n\\n```python\\nfrom typing import List\\n\\nclass Solution:\\n\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\tn: int = 1\\n\\t\\ttotal: int = 0\\n\\n\\t\\tfor num in nums:\\n\\t\\t\\tif num > 0 and num < len(nums):\\n\\t\\t\\t\\tn += 1\\n\\t\\t\\t\\ttotal += num\\n\\t\\texpected: int = int((n * (n + 1)) / 2)\\n\\t\\treturn expected - total\\n```"
                    },
                    {
                        "username": "alph-mephesto",
                        "content": "The description strictly says that the answer has to be in O(n) time. Well I sorted the array and solved the problem, but not only it didn\\'t fail because of the insufficient complexity but also it was faster than the vast majority of the submitted solutions.\\nI am really looking for a solution that doesn\\'t require to modify the input. If any one here has a suggestion please help me, because I wasn\\'t able to find any solution satisfying this criteria among the submitted solutions."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "1ncu804u",
                        "content": "should this be a hard \\uD83E\\uDD74 ?"
                    },
                    {
                        "username": "wey53l",
                        "content": "what is the time limit exceeded problem with my code ?\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        if max(nums) < 0 or min(nums) > 1:\\n            return 1\\n        for i in range(1,max(nums)):\\n            if i not in set(nums):\\n                return i\\n        return max(nums) + 1"
                    },
                    {
                        "username": "karthik87",
                        "content": "Another way to solve the problem\n\ns = startIndex, e = endIndex\npartition the array around(s+e)/2 and keep count on both sides\nrecurse on the half with less than expected count\n\nThis is O(n) not O(nlogn)"
                    },
                    {
                        "username": "nivi77",
                        "content": "Why did Leetcode not throw a TLE in a nlog n solution?"
                    },
                    {
                        "username": "nivi77",
                        "content": "I solved using O(n log n) time still my solution was accepted.\\nShouldn\\'t it deny because of TLE?"
                    },
                    {
                        "username": "RaktimChowdhury",
                        "content": "I solved this problem using O(n) time complexity but LeetCode is actually terrible in implementing the time complexities that are mentioned in the problem description. The number of times I have seen that the descripted time complexity is O(n) but users have submitted their code successfully using O(n log n) is absolutely funny. Its a problem from their side."
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "Going to join the choir to say that the solution expected here (utilizing O(1)) space is a completely impractical solution that you should almost never use in production code, and even if by some rare case you need something like it for something to work under severe resource constraints, you would practically need to put bright flashing lights around the screen every time a future developer goes to use the function to remind them that the function destroys/consumes the input data.\\n\\nSome languages make consuming the input a normal part of operation, forcing you to copy the input if it\\'s something you want to reuse, but if you\\'re going to use the memory to copy the input, then you might as well use an algorithmically simpler solution utilizing O(n) space."
                    },
                    {
                        "username": "generalkernel",
                        "content": "At first I thought the solution utilized some \"trick\" with summing the elements or counting the number of elements that aren\\'t part of the solution.  But instead, try to think of the O(n) space answer, and utilize the space already provided to try and match the data structure of the O(n) answer"
                    }
                ]
            },
            {
                "id": 1751311,
                "content": [
                    {
                        "username": "kBrostoff",
                        "content": "I have a solution that is using a single for loop, but getting stuck on `#40/173` test case. It has an input of `[1]` and it expects an output of `2`. i\\'m a bit confused.\\n\\n```python\\nfrom typing import List\\n\\nclass Solution:\\n\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\tn: int = 1\\n\\t\\ttotal: int = 0\\n\\n\\t\\tfor num in nums:\\n\\t\\t\\tif num > 0 and num < len(nums):\\n\\t\\t\\t\\tn += 1\\n\\t\\t\\t\\ttotal += num\\n\\t\\texpected: int = int((n * (n + 1)) / 2)\\n\\t\\treturn expected - total\\n```"
                    },
                    {
                        "username": "alph-mephesto",
                        "content": "The description strictly says that the answer has to be in O(n) time. Well I sorted the array and solved the problem, but not only it didn\\'t fail because of the insufficient complexity but also it was faster than the vast majority of the submitted solutions.\\nI am really looking for a solution that doesn\\'t require to modify the input. If any one here has a suggestion please help me, because I wasn\\'t able to find any solution satisfying this criteria among the submitted solutions."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "1ncu804u",
                        "content": "should this be a hard \\uD83E\\uDD74 ?"
                    },
                    {
                        "username": "wey53l",
                        "content": "what is the time limit exceeded problem with my code ?\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        if max(nums) < 0 or min(nums) > 1:\\n            return 1\\n        for i in range(1,max(nums)):\\n            if i not in set(nums):\\n                return i\\n        return max(nums) + 1"
                    },
                    {
                        "username": "karthik87",
                        "content": "Another way to solve the problem\n\ns = startIndex, e = endIndex\npartition the array around(s+e)/2 and keep count on both sides\nrecurse on the half with less than expected count\n\nThis is O(n) not O(nlogn)"
                    },
                    {
                        "username": "nivi77",
                        "content": "Why did Leetcode not throw a TLE in a nlog n solution?"
                    },
                    {
                        "username": "nivi77",
                        "content": "I solved using O(n log n) time still my solution was accepted.\\nShouldn\\'t it deny because of TLE?"
                    },
                    {
                        "username": "RaktimChowdhury",
                        "content": "I solved this problem using O(n) time complexity but LeetCode is actually terrible in implementing the time complexities that are mentioned in the problem description. The number of times I have seen that the descripted time complexity is O(n) but users have submitted their code successfully using O(n log n) is absolutely funny. Its a problem from their side."
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "Going to join the choir to say that the solution expected here (utilizing O(1)) space is a completely impractical solution that you should almost never use in production code, and even if by some rare case you need something like it for something to work under severe resource constraints, you would practically need to put bright flashing lights around the screen every time a future developer goes to use the function to remind them that the function destroys/consumes the input data.\\n\\nSome languages make consuming the input a normal part of operation, forcing you to copy the input if it\\'s something you want to reuse, but if you\\'re going to use the memory to copy the input, then you might as well use an algorithmically simpler solution utilizing O(n) space."
                    },
                    {
                        "username": "generalkernel",
                        "content": "At first I thought the solution utilized some \"trick\" with summing the elements or counting the number of elements that aren\\'t part of the solution.  But instead, try to think of the O(n) space answer, and utilize the space already provided to try and match the data structure of the O(n) answer"
                    }
                ]
            },
            {
                "id": 1743368,
                "content": [
                    {
                        "username": "kBrostoff",
                        "content": "I have a solution that is using a single for loop, but getting stuck on `#40/173` test case. It has an input of `[1]` and it expects an output of `2`. i\\'m a bit confused.\\n\\n```python\\nfrom typing import List\\n\\nclass Solution:\\n\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\tn: int = 1\\n\\t\\ttotal: int = 0\\n\\n\\t\\tfor num in nums:\\n\\t\\t\\tif num > 0 and num < len(nums):\\n\\t\\t\\t\\tn += 1\\n\\t\\t\\t\\ttotal += num\\n\\t\\texpected: int = int((n * (n + 1)) / 2)\\n\\t\\treturn expected - total\\n```"
                    },
                    {
                        "username": "alph-mephesto",
                        "content": "The description strictly says that the answer has to be in O(n) time. Well I sorted the array and solved the problem, but not only it didn\\'t fail because of the insufficient complexity but also it was faster than the vast majority of the submitted solutions.\\nI am really looking for a solution that doesn\\'t require to modify the input. If any one here has a suggestion please help me, because I wasn\\'t able to find any solution satisfying this criteria among the submitted solutions."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "1ncu804u",
                        "content": "should this be a hard \\uD83E\\uDD74 ?"
                    },
                    {
                        "username": "wey53l",
                        "content": "what is the time limit exceeded problem with my code ?\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        if max(nums) < 0 or min(nums) > 1:\\n            return 1\\n        for i in range(1,max(nums)):\\n            if i not in set(nums):\\n                return i\\n        return max(nums) + 1"
                    },
                    {
                        "username": "karthik87",
                        "content": "Another way to solve the problem\n\ns = startIndex, e = endIndex\npartition the array around(s+e)/2 and keep count on both sides\nrecurse on the half with less than expected count\n\nThis is O(n) not O(nlogn)"
                    },
                    {
                        "username": "nivi77",
                        "content": "Why did Leetcode not throw a TLE in a nlog n solution?"
                    },
                    {
                        "username": "nivi77",
                        "content": "I solved using O(n log n) time still my solution was accepted.\\nShouldn\\'t it deny because of TLE?"
                    },
                    {
                        "username": "RaktimChowdhury",
                        "content": "I solved this problem using O(n) time complexity but LeetCode is actually terrible in implementing the time complexities that are mentioned in the problem description. The number of times I have seen that the descripted time complexity is O(n) but users have submitted their code successfully using O(n log n) is absolutely funny. Its a problem from their side."
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "Going to join the choir to say that the solution expected here (utilizing O(1)) space is a completely impractical solution that you should almost never use in production code, and even if by some rare case you need something like it for something to work under severe resource constraints, you would practically need to put bright flashing lights around the screen every time a future developer goes to use the function to remind them that the function destroys/consumes the input data.\\n\\nSome languages make consuming the input a normal part of operation, forcing you to copy the input if it\\'s something you want to reuse, but if you\\'re going to use the memory to copy the input, then you might as well use an algorithmically simpler solution utilizing O(n) space."
                    },
                    {
                        "username": "generalkernel",
                        "content": "At first I thought the solution utilized some \"trick\" with summing the elements or counting the number of elements that aren\\'t part of the solution.  But instead, try to think of the O(n) space answer, and utilize the space already provided to try and match the data structure of the O(n) answer"
                    }
                ]
            },
            {
                "id": 1742391,
                "content": [
                    {
                        "username": "kBrostoff",
                        "content": "I have a solution that is using a single for loop, but getting stuck on `#40/173` test case. It has an input of `[1]` and it expects an output of `2`. i\\'m a bit confused.\\n\\n```python\\nfrom typing import List\\n\\nclass Solution:\\n\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\tn: int = 1\\n\\t\\ttotal: int = 0\\n\\n\\t\\tfor num in nums:\\n\\t\\t\\tif num > 0 and num < len(nums):\\n\\t\\t\\t\\tn += 1\\n\\t\\t\\t\\ttotal += num\\n\\t\\texpected: int = int((n * (n + 1)) / 2)\\n\\t\\treturn expected - total\\n```"
                    },
                    {
                        "username": "alph-mephesto",
                        "content": "The description strictly says that the answer has to be in O(n) time. Well I sorted the array and solved the problem, but not only it didn\\'t fail because of the insufficient complexity but also it was faster than the vast majority of the submitted solutions.\\nI am really looking for a solution that doesn\\'t require to modify the input. If any one here has a suggestion please help me, because I wasn\\'t able to find any solution satisfying this criteria among the submitted solutions."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "1ncu804u",
                        "content": "should this be a hard \\uD83E\\uDD74 ?"
                    },
                    {
                        "username": "wey53l",
                        "content": "what is the time limit exceeded problem with my code ?\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        if max(nums) < 0 or min(nums) > 1:\\n            return 1\\n        for i in range(1,max(nums)):\\n            if i not in set(nums):\\n                return i\\n        return max(nums) + 1"
                    },
                    {
                        "username": "karthik87",
                        "content": "Another way to solve the problem\n\ns = startIndex, e = endIndex\npartition the array around(s+e)/2 and keep count on both sides\nrecurse on the half with less than expected count\n\nThis is O(n) not O(nlogn)"
                    },
                    {
                        "username": "nivi77",
                        "content": "Why did Leetcode not throw a TLE in a nlog n solution?"
                    },
                    {
                        "username": "nivi77",
                        "content": "I solved using O(n log n) time still my solution was accepted.\\nShouldn\\'t it deny because of TLE?"
                    },
                    {
                        "username": "RaktimChowdhury",
                        "content": "I solved this problem using O(n) time complexity but LeetCode is actually terrible in implementing the time complexities that are mentioned in the problem description. The number of times I have seen that the descripted time complexity is O(n) but users have submitted their code successfully using O(n log n) is absolutely funny. Its a problem from their side."
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "Going to join the choir to say that the solution expected here (utilizing O(1)) space is a completely impractical solution that you should almost never use in production code, and even if by some rare case you need something like it for something to work under severe resource constraints, you would practically need to put bright flashing lights around the screen every time a future developer goes to use the function to remind them that the function destroys/consumes the input data.\\n\\nSome languages make consuming the input a normal part of operation, forcing you to copy the input if it\\'s something you want to reuse, but if you\\'re going to use the memory to copy the input, then you might as well use an algorithmically simpler solution utilizing O(n) space."
                    },
                    {
                        "username": "generalkernel",
                        "content": "At first I thought the solution utilized some \"trick\" with summing the elements or counting the number of elements that aren\\'t part of the solution.  But instead, try to think of the O(n) space answer, and utilize the space already provided to try and match the data structure of the O(n) answer"
                    }
                ]
            },
            {
                "id": 1733008,
                "content": [
                    {
                        "username": "kBrostoff",
                        "content": "I have a solution that is using a single for loop, but getting stuck on `#40/173` test case. It has an input of `[1]` and it expects an output of `2`. i\\'m a bit confused.\\n\\n```python\\nfrom typing import List\\n\\nclass Solution:\\n\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\tn: int = 1\\n\\t\\ttotal: int = 0\\n\\n\\t\\tfor num in nums:\\n\\t\\t\\tif num > 0 and num < len(nums):\\n\\t\\t\\t\\tn += 1\\n\\t\\t\\t\\ttotal += num\\n\\t\\texpected: int = int((n * (n + 1)) / 2)\\n\\t\\treturn expected - total\\n```"
                    },
                    {
                        "username": "alph-mephesto",
                        "content": "The description strictly says that the answer has to be in O(n) time. Well I sorted the array and solved the problem, but not only it didn\\'t fail because of the insufficient complexity but also it was faster than the vast majority of the submitted solutions.\\nI am really looking for a solution that doesn\\'t require to modify the input. If any one here has a suggestion please help me, because I wasn\\'t able to find any solution satisfying this criteria among the submitted solutions."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "1ncu804u",
                        "content": "should this be a hard \\uD83E\\uDD74 ?"
                    },
                    {
                        "username": "wey53l",
                        "content": "what is the time limit exceeded problem with my code ?\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        if max(nums) < 0 or min(nums) > 1:\\n            return 1\\n        for i in range(1,max(nums)):\\n            if i not in set(nums):\\n                return i\\n        return max(nums) + 1"
                    },
                    {
                        "username": "karthik87",
                        "content": "Another way to solve the problem\n\ns = startIndex, e = endIndex\npartition the array around(s+e)/2 and keep count on both sides\nrecurse on the half with less than expected count\n\nThis is O(n) not O(nlogn)"
                    },
                    {
                        "username": "nivi77",
                        "content": "Why did Leetcode not throw a TLE in a nlog n solution?"
                    },
                    {
                        "username": "nivi77",
                        "content": "I solved using O(n log n) time still my solution was accepted.\\nShouldn\\'t it deny because of TLE?"
                    },
                    {
                        "username": "RaktimChowdhury",
                        "content": "I solved this problem using O(n) time complexity but LeetCode is actually terrible in implementing the time complexities that are mentioned in the problem description. The number of times I have seen that the descripted time complexity is O(n) but users have submitted their code successfully using O(n log n) is absolutely funny. Its a problem from their side."
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "Going to join the choir to say that the solution expected here (utilizing O(1)) space is a completely impractical solution that you should almost never use in production code, and even if by some rare case you need something like it for something to work under severe resource constraints, you would practically need to put bright flashing lights around the screen every time a future developer goes to use the function to remind them that the function destroys/consumes the input data.\\n\\nSome languages make consuming the input a normal part of operation, forcing you to copy the input if it\\'s something you want to reuse, but if you\\'re going to use the memory to copy the input, then you might as well use an algorithmically simpler solution utilizing O(n) space."
                    },
                    {
                        "username": "generalkernel",
                        "content": "At first I thought the solution utilized some \"trick\" with summing the elements or counting the number of elements that aren\\'t part of the solution.  But instead, try to think of the O(n) space answer, and utilize the space already provided to try and match the data structure of the O(n) answer"
                    }
                ]
            },
            {
                "id": 1732948,
                "content": [
                    {
                        "username": "kBrostoff",
                        "content": "I have a solution that is using a single for loop, but getting stuck on `#40/173` test case. It has an input of `[1]` and it expects an output of `2`. i\\'m a bit confused.\\n\\n```python\\nfrom typing import List\\n\\nclass Solution:\\n\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\tn: int = 1\\n\\t\\ttotal: int = 0\\n\\n\\t\\tfor num in nums:\\n\\t\\t\\tif num > 0 and num < len(nums):\\n\\t\\t\\t\\tn += 1\\n\\t\\t\\t\\ttotal += num\\n\\t\\texpected: int = int((n * (n + 1)) / 2)\\n\\t\\treturn expected - total\\n```"
                    },
                    {
                        "username": "alph-mephesto",
                        "content": "The description strictly says that the answer has to be in O(n) time. Well I sorted the array and solved the problem, but not only it didn\\'t fail because of the insufficient complexity but also it was faster than the vast majority of the submitted solutions.\\nI am really looking for a solution that doesn\\'t require to modify the input. If any one here has a suggestion please help me, because I wasn\\'t able to find any solution satisfying this criteria among the submitted solutions."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "1ncu804u",
                        "content": "should this be a hard \\uD83E\\uDD74 ?"
                    },
                    {
                        "username": "wey53l",
                        "content": "what is the time limit exceeded problem with my code ?\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        if max(nums) < 0 or min(nums) > 1:\\n            return 1\\n        for i in range(1,max(nums)):\\n            if i not in set(nums):\\n                return i\\n        return max(nums) + 1"
                    },
                    {
                        "username": "karthik87",
                        "content": "Another way to solve the problem\n\ns = startIndex, e = endIndex\npartition the array around(s+e)/2 and keep count on both sides\nrecurse on the half with less than expected count\n\nThis is O(n) not O(nlogn)"
                    },
                    {
                        "username": "nivi77",
                        "content": "Why did Leetcode not throw a TLE in a nlog n solution?"
                    },
                    {
                        "username": "nivi77",
                        "content": "I solved using O(n log n) time still my solution was accepted.\\nShouldn\\'t it deny because of TLE?"
                    },
                    {
                        "username": "RaktimChowdhury",
                        "content": "I solved this problem using O(n) time complexity but LeetCode is actually terrible in implementing the time complexities that are mentioned in the problem description. The number of times I have seen that the descripted time complexity is O(n) but users have submitted their code successfully using O(n log n) is absolutely funny. Its a problem from their side."
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "Going to join the choir to say that the solution expected here (utilizing O(1)) space is a completely impractical solution that you should almost never use in production code, and even if by some rare case you need something like it for something to work under severe resource constraints, you would practically need to put bright flashing lights around the screen every time a future developer goes to use the function to remind them that the function destroys/consumes the input data.\\n\\nSome languages make consuming the input a normal part of operation, forcing you to copy the input if it\\'s something you want to reuse, but if you\\'re going to use the memory to copy the input, then you might as well use an algorithmically simpler solution utilizing O(n) space."
                    },
                    {
                        "username": "generalkernel",
                        "content": "At first I thought the solution utilized some \"trick\" with summing the elements or counting the number of elements that aren\\'t part of the solution.  But instead, try to think of the O(n) space answer, and utilize the space already provided to try and match the data structure of the O(n) answer"
                    }
                ]
            },
            {
                "id": 1729717,
                "content": [
                    {
                        "username": "kBrostoff",
                        "content": "I have a solution that is using a single for loop, but getting stuck on `#40/173` test case. It has an input of `[1]` and it expects an output of `2`. i\\'m a bit confused.\\n\\n```python\\nfrom typing import List\\n\\nclass Solution:\\n\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\tn: int = 1\\n\\t\\ttotal: int = 0\\n\\n\\t\\tfor num in nums:\\n\\t\\t\\tif num > 0 and num < len(nums):\\n\\t\\t\\t\\tn += 1\\n\\t\\t\\t\\ttotal += num\\n\\t\\texpected: int = int((n * (n + 1)) / 2)\\n\\t\\treturn expected - total\\n```"
                    },
                    {
                        "username": "alph-mephesto",
                        "content": "The description strictly says that the answer has to be in O(n) time. Well I sorted the array and solved the problem, but not only it didn\\'t fail because of the insufficient complexity but also it was faster than the vast majority of the submitted solutions.\\nI am really looking for a solution that doesn\\'t require to modify the input. If any one here has a suggestion please help me, because I wasn\\'t able to find any solution satisfying this criteria among the submitted solutions."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "1ncu804u",
                        "content": "should this be a hard \\uD83E\\uDD74 ?"
                    },
                    {
                        "username": "wey53l",
                        "content": "what is the time limit exceeded problem with my code ?\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        if max(nums) < 0 or min(nums) > 1:\\n            return 1\\n        for i in range(1,max(nums)):\\n            if i not in set(nums):\\n                return i\\n        return max(nums) + 1"
                    },
                    {
                        "username": "karthik87",
                        "content": "Another way to solve the problem\n\ns = startIndex, e = endIndex\npartition the array around(s+e)/2 and keep count on both sides\nrecurse on the half with less than expected count\n\nThis is O(n) not O(nlogn)"
                    },
                    {
                        "username": "nivi77",
                        "content": "Why did Leetcode not throw a TLE in a nlog n solution?"
                    },
                    {
                        "username": "nivi77",
                        "content": "I solved using O(n log n) time still my solution was accepted.\\nShouldn\\'t it deny because of TLE?"
                    },
                    {
                        "username": "RaktimChowdhury",
                        "content": "I solved this problem using O(n) time complexity but LeetCode is actually terrible in implementing the time complexities that are mentioned in the problem description. The number of times I have seen that the descripted time complexity is O(n) but users have submitted their code successfully using O(n log n) is absolutely funny. Its a problem from their side."
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "Going to join the choir to say that the solution expected here (utilizing O(1)) space is a completely impractical solution that you should almost never use in production code, and even if by some rare case you need something like it for something to work under severe resource constraints, you would practically need to put bright flashing lights around the screen every time a future developer goes to use the function to remind them that the function destroys/consumes the input data.\\n\\nSome languages make consuming the input a normal part of operation, forcing you to copy the input if it\\'s something you want to reuse, but if you\\'re going to use the memory to copy the input, then you might as well use an algorithmically simpler solution utilizing O(n) space."
                    },
                    {
                        "username": "generalkernel",
                        "content": "At first I thought the solution utilized some \"trick\" with summing the elements or counting the number of elements that aren\\'t part of the solution.  But instead, try to think of the O(n) space answer, and utilize the space already provided to try and match the data structure of the O(n) answer"
                    }
                ]
            },
            {
                "id": 1728888,
                "content": [
                    {
                        "username": "kBrostoff",
                        "content": "I have a solution that is using a single for loop, but getting stuck on `#40/173` test case. It has an input of `[1]` and it expects an output of `2`. i\\'m a bit confused.\\n\\n```python\\nfrom typing import List\\n\\nclass Solution:\\n\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\tn: int = 1\\n\\t\\ttotal: int = 0\\n\\n\\t\\tfor num in nums:\\n\\t\\t\\tif num > 0 and num < len(nums):\\n\\t\\t\\t\\tn += 1\\n\\t\\t\\t\\ttotal += num\\n\\t\\texpected: int = int((n * (n + 1)) / 2)\\n\\t\\treturn expected - total\\n```"
                    },
                    {
                        "username": "alph-mephesto",
                        "content": "The description strictly says that the answer has to be in O(n) time. Well I sorted the array and solved the problem, but not only it didn\\'t fail because of the insufficient complexity but also it was faster than the vast majority of the submitted solutions.\\nI am really looking for a solution that doesn\\'t require to modify the input. If any one here has a suggestion please help me, because I wasn\\'t able to find any solution satisfying this criteria among the submitted solutions."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "1ncu804u",
                        "content": "should this be a hard \\uD83E\\uDD74 ?"
                    },
                    {
                        "username": "wey53l",
                        "content": "what is the time limit exceeded problem with my code ?\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        if max(nums) < 0 or min(nums) > 1:\\n            return 1\\n        for i in range(1,max(nums)):\\n            if i not in set(nums):\\n                return i\\n        return max(nums) + 1"
                    },
                    {
                        "username": "karthik87",
                        "content": "Another way to solve the problem\n\ns = startIndex, e = endIndex\npartition the array around(s+e)/2 and keep count on both sides\nrecurse on the half with less than expected count\n\nThis is O(n) not O(nlogn)"
                    },
                    {
                        "username": "nivi77",
                        "content": "Why did Leetcode not throw a TLE in a nlog n solution?"
                    },
                    {
                        "username": "nivi77",
                        "content": "I solved using O(n log n) time still my solution was accepted.\\nShouldn\\'t it deny because of TLE?"
                    },
                    {
                        "username": "RaktimChowdhury",
                        "content": "I solved this problem using O(n) time complexity but LeetCode is actually terrible in implementing the time complexities that are mentioned in the problem description. The number of times I have seen that the descripted time complexity is O(n) but users have submitted their code successfully using O(n log n) is absolutely funny. Its a problem from their side."
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "Going to join the choir to say that the solution expected here (utilizing O(1)) space is a completely impractical solution that you should almost never use in production code, and even if by some rare case you need something like it for something to work under severe resource constraints, you would practically need to put bright flashing lights around the screen every time a future developer goes to use the function to remind them that the function destroys/consumes the input data.\\n\\nSome languages make consuming the input a normal part of operation, forcing you to copy the input if it\\'s something you want to reuse, but if you\\'re going to use the memory to copy the input, then you might as well use an algorithmically simpler solution utilizing O(n) space."
                    },
                    {
                        "username": "generalkernel",
                        "content": "At first I thought the solution utilized some \"trick\" with summing the elements or counting the number of elements that aren\\'t part of the solution.  But instead, try to think of the O(n) space answer, and utilize the space already provided to try and match the data structure of the O(n) answer"
                    }
                ]
            },
            {
                "id": 1725223,
                "content": [
                    {
                        "username": "sakshambhalla11",
                        "content": "Why is this rated hard? It\\'s an easy Set question"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "Do anybody have ideas how can I speed up my code? It executes correctly 171/173 test cases, then dies because of the time limit.\n\n `\n\n      nums = sorted(nums) \n      number = 1  # minimum possible positive number\n      if not len(nums):\n          return 1\n\n      while number <= nums[-1]:\n            if number not in nums and number > 0:\n                   break\n            number += 1\n      return number\n\n`"
                    },
                    {
                        "username": "smartmath",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\n\\nhow to resolve this ?\\n "
                    },
                    {
                        "username": "one_djenty_boi",
                        "content": "Great edge cases!!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "The closest i have gotten so far is the observation that the missing element must be no more than 1 greater than the array size. So I can remove all elements out of range, and the array size also decreases, and so on, until i can't reduce the size anymore then i just write out the remaining array size plus one.\n\nBut this requires deduplicating the array in O(n) time and O(1) space, since the problem does not state that the arrays can't contain duplicate elements. I could do it with a hash table in O(n) but I don't know how to without extra space.\n\nI also don't think this actually shaves off an exponential amount of array size every time which would be required to make it a O(n) time solution. Bad solutions exist (like if 1 is the only missing element, resulting in only 1 element being removed at a time) that make this a O(n^2) worst case. If there's a better way, it still eludes me right now.\n\nEdit: Nvm! I figured this out. \n\nThe trick is to store a \"seen\" array INSIDE the original array by flipping a number to negative to indicate that it has been seen. This results in O(1) space complexity.\nThe \"seen\" array fits in the original array this way because of the observation that the missing element value is bounded by the size of the array."
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "sort the array first \\nthen make a integer variable a=1\\nand use for loop (0,array.length)\\nafter the for loop use if condition \\nif(arr[i]==a) then a++\\nand return a"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[1,2,3,4,5,6,7,8,9,20]\\nIn this case n=10(size of an array) \\nwhy the answer is 21 not 10?\\ni guess 10 is positive number\\n \\n"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[@patelhet050603](/patelhet050603) yeah got the answer\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s 10 only"
                    },
                    {
                        "username": "woppi123",
                        "content": "cannot use only constant space without modifying the array, can you?"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "What is another possible way instead of using a while loop?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1722682,
                "content": [
                    {
                        "username": "sakshambhalla11",
                        "content": "Why is this rated hard? It\\'s an easy Set question"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "Do anybody have ideas how can I speed up my code? It executes correctly 171/173 test cases, then dies because of the time limit.\n\n `\n\n      nums = sorted(nums) \n      number = 1  # minimum possible positive number\n      if not len(nums):\n          return 1\n\n      while number <= nums[-1]:\n            if number not in nums and number > 0:\n                   break\n            number += 1\n      return number\n\n`"
                    },
                    {
                        "username": "smartmath",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\n\\nhow to resolve this ?\\n "
                    },
                    {
                        "username": "one_djenty_boi",
                        "content": "Great edge cases!!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "The closest i have gotten so far is the observation that the missing element must be no more than 1 greater than the array size. So I can remove all elements out of range, and the array size also decreases, and so on, until i can't reduce the size anymore then i just write out the remaining array size plus one.\n\nBut this requires deduplicating the array in O(n) time and O(1) space, since the problem does not state that the arrays can't contain duplicate elements. I could do it with a hash table in O(n) but I don't know how to without extra space.\n\nI also don't think this actually shaves off an exponential amount of array size every time which would be required to make it a O(n) time solution. Bad solutions exist (like if 1 is the only missing element, resulting in only 1 element being removed at a time) that make this a O(n^2) worst case. If there's a better way, it still eludes me right now.\n\nEdit: Nvm! I figured this out. \n\nThe trick is to store a \"seen\" array INSIDE the original array by flipping a number to negative to indicate that it has been seen. This results in O(1) space complexity.\nThe \"seen\" array fits in the original array this way because of the observation that the missing element value is bounded by the size of the array."
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "sort the array first \\nthen make a integer variable a=1\\nand use for loop (0,array.length)\\nafter the for loop use if condition \\nif(arr[i]==a) then a++\\nand return a"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[1,2,3,4,5,6,7,8,9,20]\\nIn this case n=10(size of an array) \\nwhy the answer is 21 not 10?\\ni guess 10 is positive number\\n \\n"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[@patelhet050603](/patelhet050603) yeah got the answer\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s 10 only"
                    },
                    {
                        "username": "woppi123",
                        "content": "cannot use only constant space without modifying the array, can you?"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "What is another possible way instead of using a while loop?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1718319,
                "content": [
                    {
                        "username": "sakshambhalla11",
                        "content": "Why is this rated hard? It\\'s an easy Set question"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "Do anybody have ideas how can I speed up my code? It executes correctly 171/173 test cases, then dies because of the time limit.\n\n `\n\n      nums = sorted(nums) \n      number = 1  # minimum possible positive number\n      if not len(nums):\n          return 1\n\n      while number <= nums[-1]:\n            if number not in nums and number > 0:\n                   break\n            number += 1\n      return number\n\n`"
                    },
                    {
                        "username": "smartmath",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\n\\nhow to resolve this ?\\n "
                    },
                    {
                        "username": "one_djenty_boi",
                        "content": "Great edge cases!!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "The closest i have gotten so far is the observation that the missing element must be no more than 1 greater than the array size. So I can remove all elements out of range, and the array size also decreases, and so on, until i can't reduce the size anymore then i just write out the remaining array size plus one.\n\nBut this requires deduplicating the array in O(n) time and O(1) space, since the problem does not state that the arrays can't contain duplicate elements. I could do it with a hash table in O(n) but I don't know how to without extra space.\n\nI also don't think this actually shaves off an exponential amount of array size every time which would be required to make it a O(n) time solution. Bad solutions exist (like if 1 is the only missing element, resulting in only 1 element being removed at a time) that make this a O(n^2) worst case. If there's a better way, it still eludes me right now.\n\nEdit: Nvm! I figured this out. \n\nThe trick is to store a \"seen\" array INSIDE the original array by flipping a number to negative to indicate that it has been seen. This results in O(1) space complexity.\nThe \"seen\" array fits in the original array this way because of the observation that the missing element value is bounded by the size of the array."
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "sort the array first \\nthen make a integer variable a=1\\nand use for loop (0,array.length)\\nafter the for loop use if condition \\nif(arr[i]==a) then a++\\nand return a"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[1,2,3,4,5,6,7,8,9,20]\\nIn this case n=10(size of an array) \\nwhy the answer is 21 not 10?\\ni guess 10 is positive number\\n \\n"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[@patelhet050603](/patelhet050603) yeah got the answer\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s 10 only"
                    },
                    {
                        "username": "woppi123",
                        "content": "cannot use only constant space without modifying the array, can you?"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "What is another possible way instead of using a while loop?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1710782,
                "content": [
                    {
                        "username": "sakshambhalla11",
                        "content": "Why is this rated hard? It\\'s an easy Set question"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "Do anybody have ideas how can I speed up my code? It executes correctly 171/173 test cases, then dies because of the time limit.\n\n `\n\n      nums = sorted(nums) \n      number = 1  # minimum possible positive number\n      if not len(nums):\n          return 1\n\n      while number <= nums[-1]:\n            if number not in nums and number > 0:\n                   break\n            number += 1\n      return number\n\n`"
                    },
                    {
                        "username": "smartmath",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\n\\nhow to resolve this ?\\n "
                    },
                    {
                        "username": "one_djenty_boi",
                        "content": "Great edge cases!!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "The closest i have gotten so far is the observation that the missing element must be no more than 1 greater than the array size. So I can remove all elements out of range, and the array size also decreases, and so on, until i can't reduce the size anymore then i just write out the remaining array size plus one.\n\nBut this requires deduplicating the array in O(n) time and O(1) space, since the problem does not state that the arrays can't contain duplicate elements. I could do it with a hash table in O(n) but I don't know how to without extra space.\n\nI also don't think this actually shaves off an exponential amount of array size every time which would be required to make it a O(n) time solution. Bad solutions exist (like if 1 is the only missing element, resulting in only 1 element being removed at a time) that make this a O(n^2) worst case. If there's a better way, it still eludes me right now.\n\nEdit: Nvm! I figured this out. \n\nThe trick is to store a \"seen\" array INSIDE the original array by flipping a number to negative to indicate that it has been seen. This results in O(1) space complexity.\nThe \"seen\" array fits in the original array this way because of the observation that the missing element value is bounded by the size of the array."
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "sort the array first \\nthen make a integer variable a=1\\nand use for loop (0,array.length)\\nafter the for loop use if condition \\nif(arr[i]==a) then a++\\nand return a"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[1,2,3,4,5,6,7,8,9,20]\\nIn this case n=10(size of an array) \\nwhy the answer is 21 not 10?\\ni guess 10 is positive number\\n \\n"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[@patelhet050603](/patelhet050603) yeah got the answer\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s 10 only"
                    },
                    {
                        "username": "woppi123",
                        "content": "cannot use only constant space without modifying the array, can you?"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "What is another possible way instead of using a while loop?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1705887,
                "content": [
                    {
                        "username": "sakshambhalla11",
                        "content": "Why is this rated hard? It\\'s an easy Set question"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "Do anybody have ideas how can I speed up my code? It executes correctly 171/173 test cases, then dies because of the time limit.\n\n `\n\n      nums = sorted(nums) \n      number = 1  # minimum possible positive number\n      if not len(nums):\n          return 1\n\n      while number <= nums[-1]:\n            if number not in nums and number > 0:\n                   break\n            number += 1\n      return number\n\n`"
                    },
                    {
                        "username": "smartmath",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\n\\nhow to resolve this ?\\n "
                    },
                    {
                        "username": "one_djenty_boi",
                        "content": "Great edge cases!!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "The closest i have gotten so far is the observation that the missing element must be no more than 1 greater than the array size. So I can remove all elements out of range, and the array size also decreases, and so on, until i can't reduce the size anymore then i just write out the remaining array size plus one.\n\nBut this requires deduplicating the array in O(n) time and O(1) space, since the problem does not state that the arrays can't contain duplicate elements. I could do it with a hash table in O(n) but I don't know how to without extra space.\n\nI also don't think this actually shaves off an exponential amount of array size every time which would be required to make it a O(n) time solution. Bad solutions exist (like if 1 is the only missing element, resulting in only 1 element being removed at a time) that make this a O(n^2) worst case. If there's a better way, it still eludes me right now.\n\nEdit: Nvm! I figured this out. \n\nThe trick is to store a \"seen\" array INSIDE the original array by flipping a number to negative to indicate that it has been seen. This results in O(1) space complexity.\nThe \"seen\" array fits in the original array this way because of the observation that the missing element value is bounded by the size of the array."
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "sort the array first \\nthen make a integer variable a=1\\nand use for loop (0,array.length)\\nafter the for loop use if condition \\nif(arr[i]==a) then a++\\nand return a"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[1,2,3,4,5,6,7,8,9,20]\\nIn this case n=10(size of an array) \\nwhy the answer is 21 not 10?\\ni guess 10 is positive number\\n \\n"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[@patelhet050603](/patelhet050603) yeah got the answer\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s 10 only"
                    },
                    {
                        "username": "woppi123",
                        "content": "cannot use only constant space without modifying the array, can you?"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "What is another possible way instead of using a while loop?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1703683,
                "content": [
                    {
                        "username": "sakshambhalla11",
                        "content": "Why is this rated hard? It\\'s an easy Set question"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "Do anybody have ideas how can I speed up my code? It executes correctly 171/173 test cases, then dies because of the time limit.\n\n `\n\n      nums = sorted(nums) \n      number = 1  # minimum possible positive number\n      if not len(nums):\n          return 1\n\n      while number <= nums[-1]:\n            if number not in nums and number > 0:\n                   break\n            number += 1\n      return number\n\n`"
                    },
                    {
                        "username": "smartmath",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\n\\nhow to resolve this ?\\n "
                    },
                    {
                        "username": "one_djenty_boi",
                        "content": "Great edge cases!!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "The closest i have gotten so far is the observation that the missing element must be no more than 1 greater than the array size. So I can remove all elements out of range, and the array size also decreases, and so on, until i can't reduce the size anymore then i just write out the remaining array size plus one.\n\nBut this requires deduplicating the array in O(n) time and O(1) space, since the problem does not state that the arrays can't contain duplicate elements. I could do it with a hash table in O(n) but I don't know how to without extra space.\n\nI also don't think this actually shaves off an exponential amount of array size every time which would be required to make it a O(n) time solution. Bad solutions exist (like if 1 is the only missing element, resulting in only 1 element being removed at a time) that make this a O(n^2) worst case. If there's a better way, it still eludes me right now.\n\nEdit: Nvm! I figured this out. \n\nThe trick is to store a \"seen\" array INSIDE the original array by flipping a number to negative to indicate that it has been seen. This results in O(1) space complexity.\nThe \"seen\" array fits in the original array this way because of the observation that the missing element value is bounded by the size of the array."
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "sort the array first \\nthen make a integer variable a=1\\nand use for loop (0,array.length)\\nafter the for loop use if condition \\nif(arr[i]==a) then a++\\nand return a"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[1,2,3,4,5,6,7,8,9,20]\\nIn this case n=10(size of an array) \\nwhy the answer is 21 not 10?\\ni guess 10 is positive number\\n \\n"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[@patelhet050603](/patelhet050603) yeah got the answer\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s 10 only"
                    },
                    {
                        "username": "woppi123",
                        "content": "cannot use only constant space without modifying the array, can you?"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "What is another possible way instead of using a while loop?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1698023,
                "content": [
                    {
                        "username": "sakshambhalla11",
                        "content": "Why is this rated hard? It\\'s an easy Set question"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "Do anybody have ideas how can I speed up my code? It executes correctly 171/173 test cases, then dies because of the time limit.\n\n `\n\n      nums = sorted(nums) \n      number = 1  # minimum possible positive number\n      if not len(nums):\n          return 1\n\n      while number <= nums[-1]:\n            if number not in nums and number > 0:\n                   break\n            number += 1\n      return number\n\n`"
                    },
                    {
                        "username": "smartmath",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\n\\nhow to resolve this ?\\n "
                    },
                    {
                        "username": "one_djenty_boi",
                        "content": "Great edge cases!!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "The closest i have gotten so far is the observation that the missing element must be no more than 1 greater than the array size. So I can remove all elements out of range, and the array size also decreases, and so on, until i can't reduce the size anymore then i just write out the remaining array size plus one.\n\nBut this requires deduplicating the array in O(n) time and O(1) space, since the problem does not state that the arrays can't contain duplicate elements. I could do it with a hash table in O(n) but I don't know how to without extra space.\n\nI also don't think this actually shaves off an exponential amount of array size every time which would be required to make it a O(n) time solution. Bad solutions exist (like if 1 is the only missing element, resulting in only 1 element being removed at a time) that make this a O(n^2) worst case. If there's a better way, it still eludes me right now.\n\nEdit: Nvm! I figured this out. \n\nThe trick is to store a \"seen\" array INSIDE the original array by flipping a number to negative to indicate that it has been seen. This results in O(1) space complexity.\nThe \"seen\" array fits in the original array this way because of the observation that the missing element value is bounded by the size of the array."
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "sort the array first \\nthen make a integer variable a=1\\nand use for loop (0,array.length)\\nafter the for loop use if condition \\nif(arr[i]==a) then a++\\nand return a"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[1,2,3,4,5,6,7,8,9,20]\\nIn this case n=10(size of an array) \\nwhy the answer is 21 not 10?\\ni guess 10 is positive number\\n \\n"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[@patelhet050603](/patelhet050603) yeah got the answer\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s 10 only"
                    },
                    {
                        "username": "woppi123",
                        "content": "cannot use only constant space without modifying the array, can you?"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "What is another possible way instead of using a while loop?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1693402,
                "content": [
                    {
                        "username": "sakshambhalla11",
                        "content": "Why is this rated hard? It\\'s an easy Set question"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "Do anybody have ideas how can I speed up my code? It executes correctly 171/173 test cases, then dies because of the time limit.\n\n `\n\n      nums = sorted(nums) \n      number = 1  # minimum possible positive number\n      if not len(nums):\n          return 1\n\n      while number <= nums[-1]:\n            if number not in nums and number > 0:\n                   break\n            number += 1\n      return number\n\n`"
                    },
                    {
                        "username": "smartmath",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\n\\nhow to resolve this ?\\n "
                    },
                    {
                        "username": "one_djenty_boi",
                        "content": "Great edge cases!!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "The closest i have gotten so far is the observation that the missing element must be no more than 1 greater than the array size. So I can remove all elements out of range, and the array size also decreases, and so on, until i can't reduce the size anymore then i just write out the remaining array size plus one.\n\nBut this requires deduplicating the array in O(n) time and O(1) space, since the problem does not state that the arrays can't contain duplicate elements. I could do it with a hash table in O(n) but I don't know how to without extra space.\n\nI also don't think this actually shaves off an exponential amount of array size every time which would be required to make it a O(n) time solution. Bad solutions exist (like if 1 is the only missing element, resulting in only 1 element being removed at a time) that make this a O(n^2) worst case. If there's a better way, it still eludes me right now.\n\nEdit: Nvm! I figured this out. \n\nThe trick is to store a \"seen\" array INSIDE the original array by flipping a number to negative to indicate that it has been seen. This results in O(1) space complexity.\nThe \"seen\" array fits in the original array this way because of the observation that the missing element value is bounded by the size of the array."
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "sort the array first \\nthen make a integer variable a=1\\nand use for loop (0,array.length)\\nafter the for loop use if condition \\nif(arr[i]==a) then a++\\nand return a"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[1,2,3,4,5,6,7,8,9,20]\\nIn this case n=10(size of an array) \\nwhy the answer is 21 not 10?\\ni guess 10 is positive number\\n \\n"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[@patelhet050603](/patelhet050603) yeah got the answer\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s 10 only"
                    },
                    {
                        "username": "woppi123",
                        "content": "cannot use only constant space without modifying the array, can you?"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "What is another possible way instead of using a while loop?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1690886,
                "content": [
                    {
                        "username": "sakshambhalla11",
                        "content": "Why is this rated hard? It\\'s an easy Set question"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "Do anybody have ideas how can I speed up my code? It executes correctly 171/173 test cases, then dies because of the time limit.\n\n `\n\n      nums = sorted(nums) \n      number = 1  # minimum possible positive number\n      if not len(nums):\n          return 1\n\n      while number <= nums[-1]:\n            if number not in nums and number > 0:\n                   break\n            number += 1\n      return number\n\n`"
                    },
                    {
                        "username": "smartmath",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\n\\nhow to resolve this ?\\n "
                    },
                    {
                        "username": "one_djenty_boi",
                        "content": "Great edge cases!!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "The closest i have gotten so far is the observation that the missing element must be no more than 1 greater than the array size. So I can remove all elements out of range, and the array size also decreases, and so on, until i can't reduce the size anymore then i just write out the remaining array size plus one.\n\nBut this requires deduplicating the array in O(n) time and O(1) space, since the problem does not state that the arrays can't contain duplicate elements. I could do it with a hash table in O(n) but I don't know how to without extra space.\n\nI also don't think this actually shaves off an exponential amount of array size every time which would be required to make it a O(n) time solution. Bad solutions exist (like if 1 is the only missing element, resulting in only 1 element being removed at a time) that make this a O(n^2) worst case. If there's a better way, it still eludes me right now.\n\nEdit: Nvm! I figured this out. \n\nThe trick is to store a \"seen\" array INSIDE the original array by flipping a number to negative to indicate that it has been seen. This results in O(1) space complexity.\nThe \"seen\" array fits in the original array this way because of the observation that the missing element value is bounded by the size of the array."
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "sort the array first \\nthen make a integer variable a=1\\nand use for loop (0,array.length)\\nafter the for loop use if condition \\nif(arr[i]==a) then a++\\nand return a"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[1,2,3,4,5,6,7,8,9,20]\\nIn this case n=10(size of an array) \\nwhy the answer is 21 not 10?\\ni guess 10 is positive number\\n \\n"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[@patelhet050603](/patelhet050603) yeah got the answer\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s 10 only"
                    },
                    {
                        "username": "woppi123",
                        "content": "cannot use only constant space without modifying the array, can you?"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "What is another possible way instead of using a while loop?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1672177,
                "content": [
                    {
                        "username": "sakshambhalla11",
                        "content": "Why is this rated hard? It\\'s an easy Set question"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "Do anybody have ideas how can I speed up my code? It executes correctly 171/173 test cases, then dies because of the time limit.\n\n `\n\n      nums = sorted(nums) \n      number = 1  # minimum possible positive number\n      if not len(nums):\n          return 1\n\n      while number <= nums[-1]:\n            if number not in nums and number > 0:\n                   break\n            number += 1\n      return number\n\n`"
                    },
                    {
                        "username": "smartmath",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\n\\nhow to resolve this ?\\n "
                    },
                    {
                        "username": "one_djenty_boi",
                        "content": "Great edge cases!!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "The closest i have gotten so far is the observation that the missing element must be no more than 1 greater than the array size. So I can remove all elements out of range, and the array size also decreases, and so on, until i can't reduce the size anymore then i just write out the remaining array size plus one.\n\nBut this requires deduplicating the array in O(n) time and O(1) space, since the problem does not state that the arrays can't contain duplicate elements. I could do it with a hash table in O(n) but I don't know how to without extra space.\n\nI also don't think this actually shaves off an exponential amount of array size every time which would be required to make it a O(n) time solution. Bad solutions exist (like if 1 is the only missing element, resulting in only 1 element being removed at a time) that make this a O(n^2) worst case. If there's a better way, it still eludes me right now.\n\nEdit: Nvm! I figured this out. \n\nThe trick is to store a \"seen\" array INSIDE the original array by flipping a number to negative to indicate that it has been seen. This results in O(1) space complexity.\nThe \"seen\" array fits in the original array this way because of the observation that the missing element value is bounded by the size of the array."
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "sort the array first \\nthen make a integer variable a=1\\nand use for loop (0,array.length)\\nafter the for loop use if condition \\nif(arr[i]==a) then a++\\nand return a"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[1,2,3,4,5,6,7,8,9,20]\\nIn this case n=10(size of an array) \\nwhy the answer is 21 not 10?\\ni guess 10 is positive number\\n \\n"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[@patelhet050603](/patelhet050603) yeah got the answer\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s 10 only"
                    },
                    {
                        "username": "woppi123",
                        "content": "cannot use only constant space without modifying the array, can you?"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "What is another possible way instead of using a while loop?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Linked List Cycle",
        "question_content": "<p>Given <code>head</code>, the head of a linked list, determine if the linked list has a cycle in it.</p>\n\n<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the&nbsp;<code>next</code>&nbsp;pointer. Internally, <code>pos</code>&nbsp;is used to denote the index of the node that&nbsp;tail&#39;s&nbsp;<code>next</code>&nbsp;pointer is connected to.&nbsp;<strong>Note that&nbsp;<code>pos</code>&nbsp;is not passed as a parameter</strong>.</p>\n\n<p>Return&nbsp;<code>true</code><em> if there is a cycle in the linked list</em>. Otherwise, return <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png\" style=\"width: 300px; height: 97px; margin-top: 8px; margin-bottom: 8px;\" />\n<pre>\n<strong>Input:</strong> head = [3,2,0,-4], pos = 1\n<strong>Output:</strong> true\n<strong>Explanation:</strong> There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png\" style=\"width: 141px; height: 74px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2], pos = 0\n<strong>Output:</strong> true\n<strong>Explanation:</strong> There is a cycle in the linked list, where the tail connects to the 0th node.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png\" style=\"width: 45px; height: 45px;\" />\n<pre>\n<strong>Input:</strong> head = [1], pos = -1\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There is no cycle in the linked list.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of the nodes in the list is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pos</code> is <code>-1</code> or a <strong>valid index</strong> in the linked-list.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Can you solve it using <code>O(1)</code> (i.e. constant) memory?</p>\n",
        "solutions": [
            {
                "id": 1829489,
                "title": "c-easy-to-understand-2-pointer-fast-slow",
                "content": "# 141. Linked List Cycle\\n**KNOCKCAT**\\n\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Linked list problem, 2 pointer , fast slow / turtle hare algorithm.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\\n\\n[LeetCode](https://github.com/knockcat/Leetcode)          **LINK TO LEETCODE REPOSITORY**\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n**EXPLANATION**\\n* **Floyd\\u2019s Cycle-Finding Algorithm** // fast slow approach // 2 pointers // **\"tortoise and the hare algorithm\"**\\n* Approach: This is the **fastest method** and has been described below:  \\n\\n* **Traverse linked list** using **two pointers**.\\n* Move **one pointer(slow_p) by one** and another **pointer(fast_p) by two.**\\n* If t**hese pointers meet at the same node** then **there is a loop**. If **pointers do not meet** then **linked list doesn\\u2019t have a loop.**\\n\\n![image](https://assets.leetcode.com/users/images/55a1e7fb-e28e-4a21-b7c5-43274d77e10a_1646699998.33529.png)\\n\\n*Above linked list has a loop as node 5 is connected to node 2 foming a Cycle.*\\n\\n**The algorithm can be reffered to as a real life scenario ->**\\n\\nSuppose there are **two people running on a track** one with a **speed x** and another with a **speed 2x** (twice of first) now it\\'s clear that **person 2 is faster**.\\nNow **assume the track to  be circular** and now since peson 2 will have faster speed so it is very sure that **person two will meet person 1 or he will overtake him**.\\n\\nNow the **above scenario is similar to our problem statement** where given ***linkedlist is the track*** and if the linked list would have a cycle it would be same as the circular track and the above conditon will definitely meet,  i.e person 2 will overtake or meet person one.\\n\\n**person 1 is slow pointer** here and moving by 1 node at a time and **person 2 is fast pointer** here moving with 2 nodes at a time. So they will meet definitely at some point **if the linkedlist contains a cycle** that is our **fast and slow pointer reference will become equal** or they point at same memory location.\\n\\n**CODE WITH EXPLANATION**\\n\\n* Time Complexity : O(N)\\n* Space Complexity : O(1)\\n```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n\\t\\n\\t\\t// making two pointers fast and slow and assignning them to head\\n        ListNode *fast = head;\\n        ListNode *slow = head;\\n        \\n\\t\\t// till fast and fast-> next not reaches NULL\\n\\t\\t// we will increment fast by 2 step and slow by 1 step\\n        while(fast != NULL && fast ->next != NULL)\\n        {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n            \\n\\t\\t\\t\\n\\t\\t\\t// At the point if fast and slow are at same address\\n\\t\\t\\t// this means linked list has a cycle in it.\\n            if(fast == slow)\\n                return true;\\n        }\\n        \\n\\t\\t// if traversal reaches to NULL this means no cycle.\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Linked list problem, 2 pointer , fast slow / turtle hare algorithm.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\n```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n\\t\\n\\t\\t// making two pointers fast and slow and assignning them to head\\n        ListNode *fast = head;\\n        ListNode *slow = head;\\n        \\n\\t\\t// till fast and fast-> next not reaches NULL\\n\\t\\t// we will increment fast by 2 step and slow by 1 step\\n        while(fast != NULL && fast ->next != NULL)\\n        {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n            \\n\\t\\t\\t\\n\\t\\t\\t// At the point if fast and slow are at same address\\n\\t\\t\\t// this means linked list has a cycle in it.\\n            if(fast == slow)\\n                return true;\\n        }\\n        \\n\\t\\t// if traversal reaches to NULL this means no cycle.\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1829768,
                "title": "javascript-easy-to-understand-slow-fast-pointers-detailed-explanation",
                "content": "## Core Strategy\\n\\nFor this problem, let\\'s see what will happen if there\\'s a circle.\\nIf it\\'s a little abstract, then let\\'s think about we are running on a circular track.\\n\\nIf the track is 100m long, your speed is 10m/s, your friend\\'s speed is 5m/s. Then after 20s, you\\'ve run 200m, your friend has run 100m. But because the track is circular, so you will be at the same place with your friend since the difference between your distances is exactly 100m.\\n\\nHow about we change another track, change the speed of you and your friend? As long as your speeds are not the same, the faster person will always catch up with the slower person again.\\n\\nThat\\'s the key point for this problem.\\n\\n## Solution\\n\\nWe just need to follow the strategy above - make a slower pointer and a faster pointer. Then we loop and loop again:\\n- if the fast pointer catch up with slow pointer, then it\\'s a circular linked list\\n- if the fast pointer get to the end, then it\\'s not a circular linked list\\n\\nHere\\'s a sample code from me:\\n\\n```js\\nconst hasCycle = (head) => {\\n  let fast = head;\\n  while (fast && fast.next) {\\n    head = head.next;\\n    fast = fast.next.next;\\n    if (head === fast) return true;\\n  }\\n  return false;\\n};\\n```\\n\\n---\\n\\nUPDATE at Apr 04 2023\\n\\nSince there\\'s a question in comments said the running case is a continuous process while linked-list is discrete, so let me put more here to explain.\\n\\nLet\\'s suppose we have these:\\n- `v1` is for the speed of pointer 1\\n- `v2` is for the speed of pointer 2\\n- `s` is for the length of the linked list\\n- `t` is for the time spent before meet\\n- `n` is an integer\\n\\nSo, we are looking for `(|v1-v2|) * t = s * n`, and we can get `t = s * n / (|v1-v2|)`. Since they are all integers, so it\\'s very easy to find a `n` to make it happen, at least we could let the `n` equals to `|v1-v2|`.\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst hasCycle = (head) => {\\n  let fast = head;\\n  while (fast && fast.next) {\\n    head = head.next;\\n    fast = fast.next.next;\\n    if (head === fast) return true;\\n  }\\n  return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1829641,
                "title": "c-my-first-c-code-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nIt\\'s a classic algo for detecting cycles in a linked list. We use two pointers to traverse the list: The first one is moving one node at the time and the second two nodes at the time. If there is a cycle, sooner or later pointers will meet and we return `true`. If the fast pointer reached the end of the list, that means there is no cycle and we can return `false`.\\n\\n*For reference: [Floyd\\'s Cycle Detection Algorithm](https://en.wikipedia.org/wiki/Cycle_detection#Floyd\\'s_tortoise_and_hare)*\\n\\nTime: O(n) - for traversing\\nSpace: O(1) - nothing stored\\n\\n```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode *slow = head, *fast = head;\\n        while (fast && fast->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if (slow == fast) return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode *slow = head, *fast = head;\\n        while (fast && fast->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if (slow == fast) return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44489,
                "title": "o-1-space-solution",
                "content": "```\\npublic boolean hasCycle(ListNode head) {\\n    if(head==null) return false;\\n    ListNode walker = head;\\n    ListNode runner = head;\\n    while(runner.next!=null && runner.next.next!=null) {\\n        walker = walker.next;\\n        runner = runner.next.next;\\n        if(walker==runner) return true;\\n    }\\n    return false;\\n}\\n```\\n 1. Use two pointers, **walker** and **runner**.\\n 2. **walker** moves step by step. **runner** moves two steps at time.\\n 3. if the Linked List has a cycle **walker** and **runner** will meet at some\\n    point.",
                "solutionTags": [],
                "code": "```\\npublic boolean hasCycle(ListNode head) {\\n    if(head==null) return false;\\n    ListNode walker = head;\\n    ListNode runner = head;\\n    while(runner.next!=null && runner.next.next!=null) {\\n        walker = walker.next;\\n        runner = runner.next.next;\\n        if(walker==runner) return true;\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 44494,
                "title": "except-ionally-fast-python",
                "content": "Took 88 ms and the \"Accepted Solutions Runtime Distribution\" doesn't show any faster Python submissions. The \"trick\" is to not check all the time whether we have reached the end but to handle it via an exception. [\"Easier to ask for forgiveness than permission.\"](https://docs.python.org/3/glossary.html#term-eafp)\\n\\nThe algorithm is of course [Tortoise and hare](https://en.wikipedia.org/wiki/Cycle_detection#Tortoise_and_hare).\\n\\n    def hasCycle(self, head):\\n        try:\\n            slow = head\\n            fast = head.next\\n            while slow is not fast:\\n                slow = slow.next\\n                fast = fast.next.next\\n            return True\\n        except:\\n            return False",
                "solutionTags": [
                    "Python"
                ],
                "code": "Took 88 ms and the \"Accepted Solutions Runtime Distribution\" doesn't show any faster Python submissions. The \"trick\" is to not check all the time whether we have reached the end but to handle it via an exception. [\"Easier to ask for forgiveness than permission.\"](https://docs.python.org/3/glossary.html#term-eafp)\\n\\nThe algorithm is of course [Tortoise and hare](https://en.wikipedia.org/wiki/Cycle_detection#Tortoise_and_hare).\\n\\n    def hasCycle(self, head):\\n        try:\\n            slow = head\\n            fast = head.next\\n            while slow is not fast:\\n                slow = slow.next\\n                fast = fast.next.next\\n            return True\\n        except:\\n            return False",
                "codeTag": "Python3"
            },
            {
                "id": 44694,
                "title": "accepted-clean-java-solution",
                "content": "    public boolean hasCycle(ListNode head) {\\n      ListNode slow = head, fast = head;\\n      \\n      while (fast != null && fast.next != null) {\\n        slow = slow.next;\\n        fast = fast.next.next;\\n        \\n        if (slow == fast) \\n            return true;\\n      }\\n      \\n      return false;\\n    }",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "    public boolean hasCycle(ListNode head) {\\n      ListNode slow = head, fast = head;\\n      \\n      while (fast != null && fast.next != null) {\\n        slow = slow.next;\\n        fast = fast.next.next;\\n        \\n        if (slow == fast) \\n            return true;\\n      }\\n      \\n      return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1047638,
                "title": "c-super-simple-and-short-two-pointer-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (!head) \\n            return false;\\n        \\n        ListNode *slow = head, *fast = head;\\n        \\n        while (fast->next && fast->next->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if (slow == fast) \\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (!head) \\n            return false;\\n        \\n        ListNode *slow = head, *fast = head;\\n        \\n        while (fast->next && fast->next->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if (slow == fast) \\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823960,
                "title": "two-approaches-in-python-3-dictionary-and-two-pointers",
                "content": "### Dictionary/Hash table\\n```\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        dictionary = {}\\n        while head:\\n            if head in dictionary: \\n                return True\\n            else: \\n                dictionary[head]= True\\n            head = head.next\\n        return False\\n```\\n\\n### Two pointers\\n```\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        if not head:\\n            return False\\n        slow = head\\n        fast = head.next\\n        while slow != fast:\\n            if not fast or not fast.next:\\n                return False\\n            slow = slow.next\\n            fast = fast.next.next\\n        return True\\n```\\n\\nIf you find this post useful, please consider **upvoting** it. Thanks!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        dictionary = {}\\n        while head:\\n            if head in dictionary: \\n                return True\\n            else: \\n                dictionary[head]= True\\n            head = head.next\\n        return False\\n```\n```\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        if not head:\\n            return False\\n        slow = head\\n        fast = head.next\\n        while slow != fast:\\n            if not fast or not fast.next:\\n                return False\\n            slow = slow.next\\n            fast = fast.next.next\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 289913,
                "title": "javascript-solution-98-faster",
                "content": "```\\nvar hasCycle = function(head) {\\n    if(!head) {\\n        return false;\\n    }\\n    let hare = head;\\n    let tortoise = head;\\n    while(hare) {\\n        if(!hare.next) {\\n            return false;\\n        } else {\\n            hare = hare.next.next;\\n            tortoise = tortoise.next;\\n        }\\n        if(tortoise == hare) {\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n```\\n\\nWhen I finally learned about the tortoise and the hare analogy for this problem, I was estatic and I\\'m here to help you understand it for those that don\\'t! \\n\\nAnalogy:\\n\\nFor those that are unfamiliar with the story of the tortoise and the hare, it\\'s basically the story of how the hare, despite being the faster than the tortoise, it still loses the race. \\n\\nHowever, the story (other than the characters) are irrelevant. What is relevant is the speed of the characters.\\n\\nOkay, now that we have that context, let\\'s talk about the approach to this problem.\\n\\nWe understand that the linked list has a cycle, anyone running through this linked list will be running around this circle forever. If it wasn\\'t, they would have stopped at the end.\\n\\nLet\\'s now imagine two types of tracks. \\n\\nOne is a straight line you see in sprint racing. If we imagine a non-circular linked list, then it would be the straight line. The fastest run reaches the end and that\\'s that.\\n\\n![image](https://assets.leetcode.com/users/tryck/image_1557470440.png)\\n\\n\\nHowever, if it was an actual track where runners would have to run laps, then it would be a circular linked list.\\n\\n![image](https://assets.leetcode.com/users/tryck/image_1557470481.png)\\n\\nNow let\\'s bring back the tortoise and the hare.\\nSince we know that the hare is faster, it will likely reach the \"end\" of the linked list faster than the tortoise. So it\\'s reasonable to say that it goes at a faster speed in relation to the tortoise\\'s speed.\\n\\nIf the track (linked list) is circular, the hare will be running around in circles and eventually so will the tortoise. At one point, the hare will have lapped the tortoise, which would mean that they\\'re in a circle since the hare will have revist a position that it\\'s already been in since the tortoise is \"behind\" it.\\n\\nIf we were to look at this mathematically, we can formulize it like this:\\n\\nSuppose that the hare runs at a rate of `ax` , where `a` is a constant and the tortoise runs at a pace of `bx` where `b` is a constant and `a > b`.\\n\\nSince they have different slopes, mathematically, they will intersect at one point. That intersection indicates a circle because the hare will revisit a position it has already been in since it comes into the same position as the tortoise.\\n\\nRuntime: `O(n)`\\nSpace Complexity: `O(1)`",
                "solutionTags": [],
                "code": "```\\nvar hasCycle = function(head) {\\n    if(!head) {\\n        return false;\\n    }\\n    let hare = head;\\n    let tortoise = head;\\n    while(hare) {\\n        if(!hare.next) {\\n            return false;\\n        } else {\\n            hare = hare.next.next;\\n            tortoise = tortoise.next;\\n        }\\n        if(tortoise == hare) {\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 44539,
                "title": "ac-python-76ms-floyd-loop-detection-in-7-lines",
                "content": "    def hasCycle(self, head):\\n        slow = fast = head\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n            if slow == fast:\\n                return True\\n        return False\\n\\n    # 16 / 16 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 76 ms\\n    # 96.56%\\n\\n\\nThis way we do not need to check if head is null.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def hasCycle(self, head):\\n        slow = fast = head\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n            if slow == fast:\\n                return True\\n        return False\\n\\n    # 16 / 16 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 76 ms\\n    # 96.56%\\n\\n\\nThis way we do not need to check if head is null.",
                "codeTag": "Python3"
            },
            {
                "id": 1047852,
                "title": "python-two-pointers-o-1-memory-explained",
                "content": "This is pretty classical and well-know problem about linked list. One way is just to put all linked list to for example hash table and check if we have repeating elements. However it will take `O(n)` space. There is better solution with only `O(1)` complexity. Imagine the following example:\\n`1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 3`, the list with loop. Idea is to use two pointers, one is slow and one is fast, let us do several steps:\\n1. At the beginning, both of them at number `1`.\\n2. Next step, slow pointer at `2` and fast at `3`.\\n3. Next step, slow pointer at `3` and fast at `5`.\\n4. Next step, slow pointer at `4` and fast at `3`.\\n5. Next step, slow pointer at `5` and fast is also `5`, so we have the same element and we return `True`.\\n\\nIf we do not have loop we will never have equal elements, if we have loop, because slow pointer moves with speed `1` and fast with speed `2`, fast pointer will always gain slow one.\\n\\n**Complexity**: time complexity is `O(n)`, space complexity is `O(1)`. \\n\\n```\\nclass Solution:\\n    def hasCycle(self, head):\\n        slow = fast = head\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n            if slow == fast: return True\\n            \\n        return False\\n```\\n\\n**Similar problems**:\\n**142: Linked List Cycle II:** https://leetcode.com/problems/linked-list-cycle-ii/discuss/912276/Python-2-pointers-approach-explained\\n**287. Find the Duplicate Number:** https://leetcode.com/problems/find-the-duplicate-number/discuss/704693/Python-2-solutions%3A-Linked-List-Cycle-O(n)-and-BS-O(n-log-n)-explained\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def hasCycle(self, head):\\n        slow = fast = head\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n            if slow == fast: return True\\n            \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44498,
                "title": "just-reverse-the-list",
                "content": "    ListNode* reverseList(ListNode* head) \\n    {\\n    \\tListNode* prev = NULL;\\n    \\tListNode* follow = NULL;\\n    \\twhile (head)\\n    \\t{\\n    \\t\\tfollow = head->next;\\n    \\t\\thead->next = prev;\\n    \\t\\tprev = head;\\n    \\t\\thead = follow;\\n    \\t}\\n\\t    return prev;\\n    }\\n    bool hasCycle(ListNode *head)\\n    {\\n    \\tListNode* rev = reverseList(head);\\n    \\tif (head && head->next && rev == head)\\n    \\t{\\n    \\t\\treturn true;\\n    \\t}\\n    \\treturn false;\\n    }\\n\\nif the list has got a loop, then its reversed version must have got the same head pointer as its self;",
                "solutionTags": [
                    "C++"
                ],
                "code": "    ListNode* reverseList(ListNode* head) \\n    {\\n    \\tListNode* prev = NULL;\\n    \\tListNode* follow = NULL;\\n    \\twhile (head)\\n    \\t{\\n    \\t\\tfollow = head->next;\\n    \\t\\thead->next = prev;\\n    \\t\\tprev = head;\\n    \\t\\thead = follow;\\n    \\t}\\n\\t    return prev;\\n    }\\n    bool hasCycle(ListNode *head)\\n    {\\n    \\tListNode* rev = reverseList(head);\\n    \\tif (head && head->next && rev == head)\\n    \\t{\\n    \\t\\treturn true;\\n    \\t}\\n    \\treturn false;\\n    }\\n\\nif the list has got a loop, then its reversed version must have got the same head pointer as its self;",
                "codeTag": "Unknown"
            },
            {
                "id": 3999014,
                "title": "99-68-two-pointer-hash-table",
                "content": "# Interview Guide - Detecting Cycles in a Linked List: A Dual-Approach Analysis\\n\\n## Introduction & Problem Understanding\\n\\nDetecting cycles in a linked list is a classic problem that tests a developer\\'s ability to understand and manipulate data structures. In this problem, you are given the head of a singly-linked list. The objective is to determine whether the list contains a cycle. A cycle exists if a node in the list can be visited more than once by following the `next` pointers continuously.\\n\\n### Key Concepts and Constraints\\n\\n1. **Node Anatomy**:  \\n   Each node in the list contains an integer value and a `next` pointer that points to the subsequent node in the list.\\n\\n2. **Cycle Detection**:  \\n   The primary task is to identify whether a cycle exists within the list. If a cycle is detected, the function should return `True`. Otherwise, it should return `False`.\\n\\n3. **Memory Efficiency**:  \\n   The question poses an implicit challenge: Can you solve it using $$ O(1) $$ memory, meaning constant extra space?\\n\\n## Strategies to Tackle the Problem\\n\\n1. **Hash Table Method**:  \\nThis approach involves storing visited nodes in a hash table. During traversal, if a node is encountered that already exists in the hash table, a cycle is confirmed.\\n\\n2. **Two-Pointers Method (Floyd\\'s Cycle-Finding Algorithm)**:  \\nAlso known as the \"hare and tortoise\" algorithm, this method employs two pointers that move at different speeds. If there is a cycle, the fast pointer will eventually catch up to the slow pointer, confirming the cycle\\'s existence.\\n\\n---\\n\\n# Live Coding 2 Solution & More\\nhttps://youtu.be/ew-E3mHOBT0?si=DTvrijJplAk7XV1w\\n\\n## Solution #1: Hash Table Method\\n\\n### Intuition and Logic Behind the Solution\\n\\nThe basic idea here is to traverse the list and keep a record of the nodes we\\'ve visited so far. If at any point we encounter a node that we\\'ve already visited, we can conclude that there is a cycle in the list.\\n\\n### Step-by-step Explanation\\n\\n1. **Initialization**: \\n    - Create an empty set, `visited_nodes`, to keep track of the nodes that have been visited.\\n\\n2. **Traversal and Verification**:  \\n    - Traverse the list starting from the head node.\\n    - At each node, check whether it already exists in `visited_nodes`.\\n    - If it does, return `True` as a cycle is detected.\\n    - Otherwise, add the node to `visited_nodes`.\\n\\n### Complexity Analysis\\n\\n- **Time Complexity**: $$ O(n) $$ \\u2014 Each node is visited once.\\n- **Space Complexity**: $$ O(n) $$ \\u2014 To store visited nodes.\\n\\n---\\n\\n## Solution #2: Two-Pointer Method (Floyd\\'s Cycle-Finding Algorithm)\\n\\n### Intuition and Logic Behind the Solution\\n\\nAlso known as the \"hare and tortoise\" algorithm, this method uses two pointers that traverse the list at different speeds. The slow pointer moves one step at a time, while the fast pointer moves two steps. If there is a cycle, the fast pointer will eventually catch up to the slow pointer.\\n\\n### Step-by-step Explanation\\n\\n1. **Initialization**:  \\n   - Initialize two pointers, `slow_pointer` and `fast_pointer`, both pointing to the head node initially.\\n\\n2. **Cycle Detection**:  \\n   - Traverse the list until the `fast_pointer` or its `next` becomes `None`.\\n   - Update `slow_pointer` and `fast_pointer` as follows:\\n        - `slow_pointer = slow_pointer.next`\\n        - `fast_pointer = fast_pointer.next.next`\\n   - If `slow_pointer` and `fast_pointer` meet at some point, return `True`.\\n\\n### Complexity Analysis\\n\\n- **Time Complexity**: $$ O(n) $$ \\u2014 In the worst-case scenario, each node is visited once.\\n- **Space Complexity**: $$ O(1) $$ \\u2014 Constant space is used.\\n\\n---\\n\\n\\n# Performance\\n\\n### Two-Pointers\\n\\n| Language  | Execution Time (ms) | Memory Usage (MB) |\\n|-----------|---------------------|-------------------|\\n| Java      | 0                   | 44                |\\n| Go        | 8                   | 4.4               |\\n| PHP       | 10                  | 22.7              |\\n| C++       | 11                  | 8.2               |\\n| Python3   | 41                  | 20.6              |\\n| JavaScript| 65                  | 45                |\\n| C#        | 84                  | 43                |\\n\\n![4a.png](https://assets.leetcode.com/users/images/15ccece4-d8c7-4b20-a20e-ec68df3195c9_1693788120.9485033.png)\\n\\n### Hash Table\\n\\n| Language  | Execution Time (ms) | Memory Usage (MB) |\\n|-----------|---------------------|-------------------|\\n| Java      | 4                   | 43.7              |\\n| Go        | 10                  | 6.2               |\\n| C++       | 18                  | 10.5              |\\n| Python3   | 49                  | 20.7              |\\n| C#        | 82                  | 44.9              |\\n| JavaScript| 69                  | 45.9              |\\n| PHP       | 432                 | 22.8              |\\n\\n![4b.png](https://assets.leetcode.com/users/images/f7f852af-c713-4592-9702-274042cac052_1693788438.437233.png)\\n\\n\\n# Code Two-Pointer\\n``` Python []\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        slow_pointer = head\\n        fast_pointer = head\\n        while fast_pointer and fast_pointer.next:\\n            slow_pointer = slow_pointer.next\\n            fast_pointer = fast_pointer.next.next\\n            if slow_pointer == fast_pointer:\\n                return True\\n        return False\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode *slow_pointer = head, *fast_pointer = head;\\n        while (fast_pointer != nullptr && fast_pointer->next != nullptr) {\\n            slow_pointer = slow_pointer->next;\\n            fast_pointer = fast_pointer->next->next;\\n            if (slow_pointer == fast_pointer) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow_pointer = head, fast_pointer = head;\\n        while (fast_pointer != null && fast_pointer.next != null) {\\n            slow_pointer = slow_pointer.next;\\n            fast_pointer = fast_pointer.next.next;\\n            if (slow_pointer == fast_pointer) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public bool HasCycle(ListNode head) {\\n        ListNode slow_pointer = head, fast_pointer = head;\\n        while (fast_pointer != null && fast_pointer.next != null) {\\n            slow_pointer = slow_pointer.next;\\n            fast_pointer = fast_pointer.next.next;\\n            if (slow_pointer == fast_pointer) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n``` Go []\\nfunc hasCycle(head *ListNode) bool {\\n    slow_pointer, fast_pointer := head, head\\n    for fast_pointer != nil && fast_pointer.Next != nil {\\n        slow_pointer = slow_pointer.Next\\n        fast_pointer = fast_pointer.Next.Next\\n        if slow_pointer == fast_pointer {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {ListNode} head\\n * @return {boolean}\\n */\\nvar hasCycle = function(head) {\\n    let slow_pointer = head, fast_pointer = head;\\n    while (fast_pointer !== null && fast_pointer.next !== null) {\\n        slow_pointer = slow_pointer.next;\\n        fast_pointer = fast_pointer.next.next;\\n        if (slow_pointer === fast_pointer) {\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n```\\n``` PHP []\\nclass Solution {\\n    function hasCycle($head) {\\n        $slow_pointer = $head;\\n        $fast_pointer = $head;\\n        while ($fast_pointer !== null && $fast_pointer->next !== null) {\\n            $slow_pointer = $slow_pointer->next;\\n            $fast_pointer = $fast_pointer->next->next;\\n            if ($slow_pointer === $fast_pointer) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n# Code Hash Table\\n``` Python []\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        visited_nodes = set()\\n        current_node = head\\n        while current_node:\\n            if current_node in visited_nodes:\\n                return True\\n            visited_nodes.add(current_node)\\n            current_node = current_node.next\\n        return False                                                                 \\n```\\n``` Go []\\nfunc hasCycle(head *ListNode) bool {\\n    visited_nodes := make(map[*ListNode]bool)\\n    current_node := head\\n    for current_node != nil {\\n        if visited_nodes[current_node] {\\n            return true\\n        }\\n        visited_nodes[current_node] = true\\n        current_node = current_node.Next\\n    }\\n    return false\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        std::unordered_set<ListNode*> visited_nodes;\\n        ListNode *current_node = head;\\n        while (current_node != nullptr) {\\n            if (visited_nodes.find(current_node) != visited_nodes.end()) {\\n                return true;\\n            }\\n            visited_nodes.insert(current_node);\\n            current_node = current_node->next;\\n        }\\n        return false;\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        HashSet<ListNode> visited_nodes = new HashSet<>();\\n        ListNode current_node = head;\\n        while (current_node != null) {\\n            if (visited_nodes.contains(current_node)) {\\n                return true;\\n            }\\n            visited_nodes.add(current_node);\\n            current_node = current_node.next;\\n        }\\n        return false;\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public bool HasCycle(ListNode head) {\\n        HashSet<ListNode> visited_nodes = new HashSet<ListNode>();\\n        ListNode current_node = head;\\n        while (current_node != null) {\\n            if (visited_nodes.Contains(current_node)) {\\n                return true;\\n            }\\n            visited_nodes.Add(current_node);\\n            current_node = current_node.next;\\n        }\\n        return false;\\n    }\\n}\\n```\\n``` PHP []\\nclass Solution {\\n    function hasCycle($head) {\\n        $visited_nodes = [];\\n        $current_node = $head;\\n        while ($current_node !== null) {\\n            if (in_array($current_node, $visited_nodes, true)) {\\n                return true;\\n            }\\n            $visited_nodes[] = $current_node;\\n            $current_node = $current_node->next;\\n        }\\n        return false;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {ListNode} head\\n * @return {boolean}\\n */\\nvar hasCycle = function(head) {\\n    let visited_nodes = new Set();\\n    let current_node = head;\\n    while (current_node !== null) {\\n        if (visited_nodes.has(current_node)) {\\n            return true;\\n        }\\n        visited_nodes.add(current_node);\\n        current_node = current_node.next;\\n    }\\n    return false;\\n};\\n```\\n\\n# Live Coding with Comments\\nhttps://youtu.be/aGbOOAKkhNo?si=IoPNL49uVessMpCv\\n\\n# Reflections on Cycle Detection\\n\\nBoth the Hash Table and Two-Pointers methods offer compelling strategies for detecting cycles in linked lists.\\n\\n1. **Hash Table Method**:  \\n   Intuitive and adaptable, though potentially memory-intensive.\\n   \\n2. **Two-Pointers Method**:  \\n   A marvel of memory efficiency, but perhaps less straightforward to the uninitiated.\\n\\nNavigating this problem is a dive into data structure nuances and algorithmic elegance. Whether you appreciate the directness of the Hash Table or the finesse of Two-Pointers, each method champions a facet of computational acumen. This isn\\'t just a problem; it\\'s a step in honing algorithmic artistry. Embrace the challenge! \\uD83D\\uDE80\\uD83C\\uDF1F",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "PHP",
                    "Hash Table",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        slow_pointer = head\\n        fast_pointer = head\\n        while fast_pointer and fast_pointer.next:\\n            slow_pointer = slow_pointer.next\\n            fast_pointer = fast_pointer.next.next\\n            if slow_pointer == fast_pointer:\\n                return True\\n        return False\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode *slow_pointer = head, *fast_pointer = head;\\n        while (fast_pointer != nullptr && fast_pointer->next != nullptr) {\\n            slow_pointer = slow_pointer->next;\\n            fast_pointer = fast_pointer->next->next;\\n            if (slow_pointer == fast_pointer) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow_pointer = head, fast_pointer = head;\\n        while (fast_pointer != null && fast_pointer.next != null) {\\n            slow_pointer = slow_pointer.next;\\n            fast_pointer = fast_pointer.next.next;\\n            if (slow_pointer == fast_pointer) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public bool HasCycle(ListNode head) {\\n        ListNode slow_pointer = head, fast_pointer = head;\\n        while (fast_pointer != null && fast_pointer.next != null) {\\n            slow_pointer = slow_pointer.next;\\n            fast_pointer = fast_pointer.next.next;\\n            if (slow_pointer == fast_pointer) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n``` Go []\\nfunc hasCycle(head *ListNode) bool {\\n    slow_pointer, fast_pointer := head, head\\n    for fast_pointer != nil && fast_pointer.Next != nil {\\n        slow_pointer = slow_pointer.Next\\n        fast_pointer = fast_pointer.Next.Next\\n        if slow_pointer == fast_pointer {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {ListNode} head\\n * @return {boolean}\\n */\\nvar hasCycle = function(head) {\\n    let slow_pointer = head, fast_pointer = head;\\n    while (fast_pointer !== null && fast_pointer.next !== null) {\\n        slow_pointer = slow_pointer.next;\\n        fast_pointer = fast_pointer.next.next;\\n        if (slow_pointer === fast_pointer) {\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n```\n``` PHP []\\nclass Solution {\\n    function hasCycle($head) {\\n        $slow_pointer = $head;\\n        $fast_pointer = $head;\\n        while ($fast_pointer !== null && $fast_pointer->next !== null) {\\n            $slow_pointer = $slow_pointer->next;\\n            $fast_pointer = $fast_pointer->next->next;\\n            if ($slow_pointer === $fast_pointer) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n``` Python []\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        visited_nodes = set()\\n        current_node = head\\n        while current_node:\\n            if current_node in visited_nodes:\\n                return True\\n            visited_nodes.add(current_node)\\n            current_node = current_node.next\\n        return False                                                                 \\n```\n``` Go []\\nfunc hasCycle(head *ListNode) bool {\\n    visited_nodes := make(map[*ListNode]bool)\\n    current_node := head\\n    for current_node != nil {\\n        if visited_nodes[current_node] {\\n            return true\\n        }\\n        visited_nodes[current_node] = true\\n        current_node = current_node.Next\\n    }\\n    return false\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        std::unordered_set<ListNode*> visited_nodes;\\n        ListNode *current_node = head;\\n        while (current_node != nullptr) {\\n            if (visited_nodes.find(current_node) != visited_nodes.end()) {\\n                return true;\\n            }\\n            visited_nodes.insert(current_node);\\n            current_node = current_node->next;\\n        }\\n        return false;\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        HashSet<ListNode> visited_nodes = new HashSet<>();\\n        ListNode current_node = head;\\n        while (current_node != null) {\\n            if (visited_nodes.contains(current_node)) {\\n                return true;\\n            }\\n            visited_nodes.add(current_node);\\n            current_node = current_node.next;\\n        }\\n        return false;\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public bool HasCycle(ListNode head) {\\n        HashSet<ListNode> visited_nodes = new HashSet<ListNode>();\\n        ListNode current_node = head;\\n        while (current_node != null) {\\n            if (visited_nodes.Contains(current_node)) {\\n                return true;\\n            }\\n            visited_nodes.Add(current_node);\\n            current_node = current_node.next;\\n        }\\n        return false;\\n    }\\n}\\n```\n``` PHP []\\nclass Solution {\\n    function hasCycle($head) {\\n        $visited_nodes = [];\\n        $current_node = $head;\\n        while ($current_node !== null) {\\n            if (in_array($current_node, $visited_nodes, true)) {\\n                return true;\\n            }\\n            $visited_nodes[] = $current_node;\\n            $current_node = $current_node->next;\\n        }\\n        return false;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {ListNode} head\\n * @return {boolean}\\n */\\nvar hasCycle = function(head) {\\n    let visited_nodes = new Set();\\n    let current_node = head;\\n    while (current_node !== null) {\\n        if (visited_nodes.has(current_node)) {\\n            return true;\\n        }\\n        visited_nodes.add(current_node);\\n        current_node = current_node.next;\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44604,
                "title": "my-faster-and-slower-runner-solution",
                "content": "    /**\\n     * Definition for singly-linked list.\\n     * struct ListNode {\\n     *     int val;\\n     *     ListNode *next;\\n     *     ListNode(int x) : val(x), next(NULL) {}\\n     * };\\n     */\\n     /**\\n     use faster and lower runner solution. (2 pointers)\\n     the faster one move 2 steps, and slower one move only one step.\\n     if there's a circle, the faster one will finally \"catch\" the slower one. \\n     (the distance between these 2 pointers will decrease one every time.)\\n     \\n     if there's no circle, the faster runner will reach the end of linked list. (NULL)\\n     */\\n    class Solution {\\n    public:\\n        bool hasCycle(ListNode *head) {\\n            if(head == NULL || head -> next == NULL)    \\n                return false;\\n     \\n            ListNode *fast = head;\\n            ListNode *slow = head;\\n            \\n            while(fast -> next && fast -> next -> next){\\n                fast = fast -> next -> next;\\n                slow = slow -> next;\\n                if(fast == slow)\\n                    return true;\\n            }\\n     \\n            return false;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool hasCycle(ListNode *head) {\\n            if(head == NULL || head -> next == NULL)    \\n                return false;\\n     \\n            ListNode *fast = head;\\n            ListNode *slow = head;\\n            \\n            while(fast -> next && fast -> next -> next){\\n                fast = fast -> next -> next;\\n                slow = slow -> next;\\n                if(fast == slow)\\n                    return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1501787,
                "title": "python-easy-single-pointer-approach-modifying-linked-list",
                "content": "```\\n # Approach 1 using a visited hash_set\\n        # Time -O(n), Space- O(n)\\nnode_set = set()\\nwhile(head):\\n\\tif head in node_set:\\n\\t\\treturn True\\n\\tnode_set.add(head)\\n\\thead = head.next\\nreturn False\\n```\\n\\n```\\n# Approach 2 slow and fast pointers slow moves one step at a time, fast moves 2, if they ever meet, means there was a cycle,\\n        # Time -O(n), Space- O(1)\\n        # Floyd\\'s Tortoise and Hare Algorithm\\n\\nslow = head\\nfast = head\\nwhile(fast and fast.next):\\n\\tslow = slow.next\\n\\tfast = fast.next.next\\n\\tif slow == fast:\\n\\t\\treturn True\\nreturn False\\n```\\n\\n```\\n # Approch 3 single pointer, marking nodes as visited, makes use of fact that node value\\'s are not None\\n  # Time -O(n), Space- O(1)\\nslow = head\\nwhile(slow):\\n\\tif slow.val == None:\\n\\t\\t# This was already visited\\n\\t\\treturn True\\n\\tslow.val = None # a way to mark visited\\n\\tslow = slow.next\\nreturn False\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n # Approach 1 using a visited hash_set\\n        # Time -O(n), Space- O(n)\\nnode_set = set()\\nwhile(head):\\n\\tif head in node_set:\\n\\t\\treturn True\\n\\tnode_set.add(head)\\n\\thead = head.next\\nreturn False\\n```\n```\\n# Approach 2 slow and fast pointers slow moves one step at a time, fast moves 2, if they ever meet, means there was a cycle,\\n        # Time -O(n), Space- O(1)\\n        # Floyd\\'s Tortoise and Hare Algorithm\\n\\nslow = head\\nfast = head\\nwhile(fast and fast.next):\\n\\tslow = slow.next\\n\\tfast = fast.next.next\\n\\tif slow == fast:\\n\\t\\treturn True\\nreturn False\\n```\n```\\n # Approch 3 single pointer, marking nodes as visited, makes use of fact that node value\\'s are not None\\n  # Time -O(n), Space- O(1)\\nslow = head\\nwhile(slow):\\n\\tif slow.val == None:\\n\\t\\t# This was already visited\\n\\t\\treturn True\\n\\tslow.val = None # a way to mark visited\\n\\tslow = slow.next\\nreturn False\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 805345,
                "title": "2-approach-hashmap-fast-and-slow-pointer-c",
                "content": "\\n    //fast and slow pointer approach\\n\\t\\n    bool hasCycle(ListNode *head) {\\n       ListNode* slow=head;\\n       ListNode* fast=head;\\n        while(fast && slow && fast->next){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n            if(fast==slow)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\t\\n\\t//hashmap approach\\n\\t\\n\\tbool hasCycle(ListNode *head) {\\n        if(head==NULL)\\n            return false;\\n        unordered_map<ListNode*,int> map;\\n        while(head!=NULL){\\n            if(map.count(head)>0)\\n                return true;\\n            else\\n                map[head]=1;\\n            head=head->next;\\n        }\\n        return false;\\n    }\\n\\t\\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.\\nHappy Coding :)**\\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "\\n    //fast and slow pointer approach\\n\\t\\n    bool hasCycle(ListNode *head) {\\n       ListNode* slow=head;\\n       ListNode* fast=head;\\n        while(fast && slow && fast->next){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n            if(fast==slow)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\t\\n\\t//hashmap approach\\n\\t\\n\\tbool hasCycle(ListNode *head) {\\n        if(head==NULL)\\n            return false;\\n        unordered_map<ListNode*,int> map;\\n        while(head!=NULL){\\n            if(map.count(head)>0)\\n                return true;\\n            else\\n                map[head]=1;\\n            head=head->next;\\n        }\\n        return false;\\n    }\\n\\t\\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.\\nHappy Coding :)**\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 375999,
                "title": "slow-fast-runner-in-javascript",
                "content": "```\\nconst hasCycle = head => {\\n    let p1 = head\\n    let p2 = head\\n    \\n    while (p2 && p2.next && p2.next.next) {\\n        p1 = p1.next\\n        p2 = p2.next.next\\n        \\n        if (p1 === p2) {\\n            return true\\n        }\\n    }\\n    \\n    return false\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst hasCycle = head => {\\n    let p1 = head\\n    let p2 = head\\n    \\n    while (p2 && p2.next && p2.next.next) {\\n        p1 = p1.next\\n        p2 = p2.next.next\\n        \\n        if (p1 === p2) {\\n            return true\\n        }\\n    }\\n    \\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 44485,
                "title": "simple-and-easy-understanding-java-solution-time-o-n-space-o-1",
                "content": "    public class Solution {\\n        public boolean hasCycle(ListNode head) {\\n        \\tListNode p = head,pre = head;\\n        \\twhile(p != null && p.next != null){\\n        \\t\\tif (p.next == head) return true;\\n        \\t\\tp = p.next;\\n        \\t\\tpre.next = head;\\n        \\t\\tpre = p;\\n        \\t}\\n            return false;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean hasCycle(ListNode head) {\\n        \\tListNode p = head,pre = head;\\n        \\twhile(p != null && p.next != null){\\n        \\t\\tif (p.next == head) return true;\\n        \\t\\tp = p.next;\\n        \\t\\tpre.next = head;\\n        \\t\\tpre = p;\\n        \\t}",
                "codeTag": "Java"
            },
            {
                "id": 44603,
                "title": "shorter-solution-in-java",
                "content": "    class HasCycleInLinkedList{\\n       public boolean hasCycle(ListNode head){\\n           if(head == null || head.next == null) return false;\\n           if(head.next == head) return true;\\n           ListNode nextNode = head.next; \\n           head.next = head;\\n           boolean isCycle = hasCycle(nextNode);\\n           return isCycle;\\n       }\\n    }",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion"
                ],
                "code": "    class HasCycleInLinkedList{\\n       public boolean hasCycle(ListNode head){\\n           if(head == null || head.next == null) return false;\\n           if(head.next == head) return true;\\n           ListNode nextNode = head.next; \\n           head.next = head;\\n           boolean isCycle = hasCycle(nextNode);\\n           return isCycle;\\n       }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 44669,
                "title": "fully-explained-why-fast-and-slow-can-meet-in-the-cycle",
                "content": "I want to explain why we can get the answer when using `fast-slow` method. Share my opinion below.\\n\\nFast-Slow Solution:\\n-------------------\\n\\n    public class Solution { //java version\\n        public boolean hasCycle(ListNode head) {\\n            ListNode fast = head;\\n            ListNode slow = head;\\n            while(fast != null && fast.next != null){            \\n                fast = fast.next.next; //2 times\\n                slow = slow.next;\\n                if(fast == slow) return true;\\n            }\\n            return false;\\n        }\\n    }\\n\\nFirst,\\n------\\n\\nwe assume that they can meet. Set the `linear length` as `a`, the `cycle length` as `c`, the slow's running distance from cycle's start point to meeting point as `b`. `a and c are known, b is unknown.` We want a equation to describe `b` by using `a` and `c`.\\n\\nHere is the diagram:  \\n\\n                   b..3    \\n                   .   \\\\     \\n                   c   2   \\n                   \\\\  /     \\n    1-2-3-4-5-...-a -1  \\n\\nAn important point is that, `the running part of linear length` is not `a`, actually it's `a-1`.** That's because they use head as start point: \\n\\n        ListNode fast = head;\\n        ListNode slow = head;\\nthen begin to run:\\n\\n            fast = fast.next.next;\\n            slow = slow.next;\\nThe `head` point `can't be included` when calculating this relation: \\n\\n    slow total running length * 2 = fast total running length\\n\\nIf fast's speed is `twice` of slow's speed, we can get:\\n\\n    slow total running length = (a-1)+b //not a!!!\\n    \\n    fast total running length = 2*((a-1)+b) //2 can be t times\\n\\nBecause they meet at point `b`, we can get equation:\\n\\n    (fast total running length - running part of linear length) % c = b\\n\\nwhich is:\\n\\n    (2*((a-1)+b) - (a-1))%c = b\\n    2*((a-1)+b) - (a-1) = n*c +b\\n    (a-1)+b = n*c\\n    b = n*c-a+1\\n\\nThen,\\n-----\\n\\nif fast and slow can meet, we can get a integer `b` when `n` is increasing where `n` is an integer starting from `0`. Actually, the `b` is the first integer that is bigger than 0:\\n\\n    b = n*c-a+1 //write it on paper, compare b with code's result\\n\\nGenerally,\\n----------\\n\\nif fast's speed is `t times` of slow's speed, we get:\\n\\n    (fast total running length - running part of linear length) % c = b\\n    (t*((a-1)+b) - (a-1))%c = b\\nMost general equation:\\n\\n    b = n/(t-1) * c - a + 1 //1.fast&slow start from head, 2.t times, 3.a&c are known, 4.n from 0\\n                            //5.if b>c, b=b%c\\n\\n**(If we want to use `a` as the running part of linear length, we need a `dummy head`.)\\n\\nIf there is anything wrong, please figure it out. Welcome to write your ideas below.",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "class Solution { //java version\\n        public boolean hasCycle(ListNode head) {\\n            ListNode fast = head;\\n            ListNode slow = head;\\n            while(fast != null && fast.next != null){            \\n                fast = fast.next.next; //2 times\\n                slow = slow.next;\\n                if(fast == slow) return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2810093,
                "title": "java-o-1-memory-no-two-pointers-value-manipulation-original-solution",
                "content": "# Code\\n```\\n//since constraints for value are -10^5 <= Node.val <= 10^5\\n//then I use 1_000_000 as indicator that this node has been\\n//visited\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        while (head != null) {\\n            if (head.val == 1_000_000) return true;\\n            head.val = 1_000_000;\\n            head = head.next;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//since constraints for value are -10^5 <= Node.val <= 10^5\\n//then I use 1_000_000 as indicator that this node has been\\n//visited\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        while (head != null) {\\n            if (head.val == 1_000_000) return true;\\n            head.val = 1_000_000;\\n            head = head.next;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 773893,
                "title": "javascript-3-solutions-using-hash-map-and-two-pointers",
                "content": "## Solution-1 : Using Hash Map\\n```javascript\\nvar hasCycle = function(head) {\\n    const seen = new Set();\\n    \\n    function traverse(node) {\\n        if(seen.has(node)) return true;\\n        if(!node) return false;\\n        seen.add(node);\\n        return traverse(node.next);\\n    }\\n    return traverse(head);\\n};\\n```\\n\\n## Solution-2: Two Pointers\\n```javascript\\nvar hasCycle = function(head) {\\n    \\n    function run(fast, slow) {\\n        if(!fast || !fast.next) return false;\\n        if(fast.next === slow) return true;\\n        return run(fast.next.next, slow.next);\\n    }\\n    return run(head, head);    \\n};\\n```\\n\\n## Solution-3: Add Property\\n```\\nvar hasCycle = function(head) {\\n    \\n    function run(node) {\\n        if(!node) return false;\\n        if(node.seen) return true;\\n        node.seen = true;\\n        return run(node.next);\\n    }\\n    return run(head);\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar hasCycle = function(head) {\\n    const seen = new Set();\\n    \\n    function traverse(node) {\\n        if(seen.has(node)) return true;\\n        if(!node) return false;\\n        seen.add(node);\\n        return traverse(node.next);\\n    }\\n    return traverse(head);\\n};\\n```\n```javascript\\nvar hasCycle = function(head) {\\n    \\n    function run(fast, slow) {\\n        if(!fast || !fast.next) return false;\\n        if(fast.next === slow) return true;\\n        return run(fast.next.next, slow.next);\\n    }\\n    return run(head, head);    \\n};\\n```\n```\\nvar hasCycle = function(head) {\\n    \\n    function run(node) {\\n        if(!node) return false;\\n        if(node.seen) return true;\\n        node.seen = true;\\n        return run(node.next);\\n    }\\n    return run(head);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 44502,
                "title": "by-saying-using-no-extra-space-does-it-mean-o-0-in-space",
                "content": "I cannot give a solution to make it possible. I can only do it in O(1) space using the two runner solution, which I think is the best one.\\n\\n    \\n\\n    // set two runners\\n    ListNode slow = head;\\n    ListNode fast = head;\\n    \\n    // fast runner move 2 steps at one time while slow runner move 1 step,\\n    // if traverse to a null, there must be no loop\\n    while (fast != null && fast.next != null) {\\n    \\tslow = slow.next;\\n    \\tfast = fast.next.next;\\n    \\tif (slow == fast) {\\n    \\t\\treturn true;\\n    \\t}\\n    }\\n    return false;",
                "solutionTags": [],
                "code": "I cannot give a solution to make it possible. I can only do it in O(1) space using the two runner solution, which I think is the best one.\\n\\n    \\n\\n    // set two runners\\n    ListNode slow = head;\\n    ListNode fast = head;\\n    \\n    // fast runner move 2 steps at one time while slow runner move 1 step,\\n    // if traverse to a null, there must be no loop\\n    while (fast != null && fast.next != null) {\\n    \\tslow = slow.next;\\n    \\tfast = fast.next.next;\\n    \\tif (slow == fast) {\\n    \\t\\treturn true;\\n    \\t}\\n    }\\n    return false;",
                "codeTag": "Unknown"
            },
            {
                "id": 2656867,
                "title": "list-set-and-two-pointer-solutions-simply-explained",
                "content": "The simplest way to solve this problem is to keep a list, ```seen```, which will keep track of all the nodes we have already visited. If we ever encounter a node which we have already seen, that means that we must have a cycle! \\n\\n**Method 1: Using List; Time: O(N^2), Memory: O(N)**\\n```\\ndef hasCycle(self, head: Optional[ListNode]) -> bool:\\n\\tseen = [] #list of nodes we have already seen\\n\\twhile head: \\n\\t\\tif head in seen: #if we already saw this node then there is a cycle\\n\\t\\t\\treturn True\\n\\t\\tseen.append(head) #add node to our list of seen nodes\\n\\t\\thead = head.next \\n\\treturn False #we reached the end of the list -- no cycle!\\n```\\n\\nThis method is accepted by LeetCode but is very slow due to the ```O(N)``` time it takes to check ```if head in seen```. We can make a quick optimization to this method by using ```set``` instead of ```list```, since ```set``` (an unordered data structure in python which doesn\\'t allow for duplicates) uses a hashing function for ```O(1)``` lookups (like a dictionary). This reduces the overall time complexity to ```O(N)```!\\n\\n**Method 2: Using Set; Time: O(N), Memory: O(N)**\\n```\\ndef hasCycle(self, head: Optional[ListNode]) -> bool:\\n\\tseen = set() #set of nodes we have already seen\\n\\twhile head:\\n\\t\\tif head in seen: #if we already saw this node then there is a cycle\\n\\t\\t\\treturn True\\n\\t\\tseen.add(head) #add node to our list of seen nodes\\n\\t\\thead = head.next #visit next node\\n\\treturn False #we reached the end of the list -- no cycle!\\n```\\n\\nEven though this is a good solution, you can often solve linked list problems without extra data structures like ```set``` and ```list```. Often, the way to do this is with recursion or two-pointers. For this problem, recursion doesn\\'t offer much help since we would struggle to break the problem up into smaller sub-problems. However, two pointers can be super helpful! We can use a ```slow``` pointer and a ```fast``` pointer to travel through the linked list at different speeds and if they are ever the same node then we know there must be a cycle! Otherwise, the ```fast``` pointer will simply reach the end of the list.\\n\\n**Method 3: Two-pointers; Time: O(N), Memory: O(1)**\\n```\\ndef hasCycle(self, head: Optional[ListNode]) -> bool:\\n\\tslow = fast = head #slow and fast pointers\\n\\twhile fast and fast.next: #while not at the end of the list\\n\\t\\tslow = slow.next #slow moves forward by 1\\n\\t\\tfast = fast.next.next #fast moves forward by 2\\n\\t\\tif slow == fast: #if they are the same then we must have a cycle!\\n\\t\\t\\treturn True\\n\\treturn False #no cycle found\\n```\\n\\n**Thanks for Reading!**\\nIf this post has been helpful, please consider upvoting! Also, if I made any mistakes or there are other optimizations, methods I didn\\'t consider, etc. please let me know!",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```seen```\n```\\ndef hasCycle(self, head: Optional[ListNode]) -> bool:\\n\\tseen = [] #list of nodes we have already seen\\n\\twhile head: \\n\\t\\tif head in seen: #if we already saw this node then there is a cycle\\n\\t\\t\\treturn True\\n\\t\\tseen.append(head) #add node to our list of seen nodes\\n\\t\\thead = head.next \\n\\treturn False #we reached the end of the list -- no cycle!\\n```\n```O(N)```\n```if head in seen```\n```set```\n```list```\n```set```\n```O(1)```\n```O(N)```\n```\\ndef hasCycle(self, head: Optional[ListNode]) -> bool:\\n\\tseen = set() #set of nodes we have already seen\\n\\twhile head:\\n\\t\\tif head in seen: #if we already saw this node then there is a cycle\\n\\t\\t\\treturn True\\n\\t\\tseen.add(head) #add node to our list of seen nodes\\n\\t\\thead = head.next #visit next node\\n\\treturn False #we reached the end of the list -- no cycle!\\n```\n```set```\n```list```\n```slow```\n```fast```\n```fast```\n```\\ndef hasCycle(self, head: Optional[ListNode]) -> bool:\\n\\tslow = fast = head #slow and fast pointers\\n\\twhile fast and fast.next: #while not at the end of the list\\n\\t\\tslow = slow.next #slow moves forward by 1\\n\\t\\tfast = fast.next.next #fast moves forward by 2\\n\\t\\tif slow == fast: #if they are the same then we must have a cycle!\\n\\t\\t\\treturn True\\n\\treturn False #no cycle found\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1320893,
                "title": "6ms-beats-100-cpp-engineering-hack",
                "content": "PS : Please let me know if this solution will be counted in O(1) space \\n\\n``` \\n if(!head) return false;\\n        int count = 0;\\n        while( head ){\\n            count++;\\n            if(count > 10000) break;\\n            head = head -> next;\\n        }\\n        return count > 10000 ? true : false;\\n\\n```\\n\\n**If you liked the engineering hack please click on UPVOTE icon (^ _ ^)**",
                "solutionTags": [
                    "C"
                ],
                "code": "``` \\n if(!head) return false;\\n        int count = 0;\\n        while( head ){\\n            count++;\\n            if(count > 10000) break;\\n            head = head -> next;\\n        }\\n        return count > 10000 ? true : false;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2439002,
                "title": "very-easy-0-ms-100-fully-explained-java-c-python-js-c-python3",
                "content": "# **Java Solution:**\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Linked List Cycle.\\n```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        // Initialize two node slow and fast point to the hesd node...\\n        ListNode fastptr = head;\\n        ListNode slowptr = head;\\n        while(fastptr != null && fastptr.next != null){\\n            // Move slow pointer by 1 node and fast at 2 at each step.\\n            slowptr = slowptr.next;\\n            fastptr = fastptr.next.next;\\n            // If both the pointers meet at any point, then the cycle is present and return true...\\n            if(slowptr == fastptr)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        // Initialize two node slow and fast point to the hesd node...\\n        ListNode* fastptr = head;\\n        ListNode* slowptr = head;\\n        while(fastptr != NULL && fastptr->next != NULL){\\n            // Move slow pointer by 1 node and fast at 2 at each step.\\n            slowptr = slowptr->next;\\n            fastptr = fastptr->next->next;\\n            // If both the pointers meet at any point, then the cycle is present and return true...\\n            if(slowptr == fastptr)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\n```\\nclass Solution(object):\\n    def hasCycle(self, head):\\n        # Initialize two node slow and fast point to the hesd node...\\n        fastptr = head\\n        slowptr = head\\n        while fastptr is not None and fastptr.next is not None:\\n            # Move slow pointer by 1 node and fast at 2 at each step.\\n            slowptr = slowptr.next\\n            fastptr = fastptr.next.next\\n            # If both the pointers meet at any point, then the cycle is present and return true...\\n            if slowptr == fastptr:\\n                return 1\\n        return 0\\n```\\n                    \\n# **JavaScript Solution:**\\n```\\nvar hasCycle = function(head) {\\n    // Initialize two node slow and fast point to the hesd node...\\n    var fastptr = head;\\n    var slowptr = head;\\n    while(fastptr != null && fastptr.next != null){\\n        // Move slow pointer by 1 node and fast at 2 at each step.\\n        slowptr = slowptr.next;\\n        fastptr = fastptr.next.next;\\n        // If both the pointers meet at any point, then the cycle is present and return true...\\n        if(slowptr == fastptr)\\n            return true;\\n    }\\n    return false;\\n};\\n```\\n\\n# **C Language:**\\n```\\nbool hasCycle(struct ListNode *head) {\\n    // Initialize two node slow and fast point to the hesd node...\\n    struct ListNode* fastptr = head;\\n    struct ListNode* slowptr = head;\\n    while(fastptr != NULL && fastptr->next != NULL){\\n        // Move slow pointer by 1 node and fast at 2 at each step.\\n        slowptr = slowptr->next;\\n        fastptr = fastptr->next->next;\\n        // If both the pointers meet at any point, then the cycle is present and return true...\\n        if(slowptr == fastptr)\\n            return true;\\n    }\\n    return false;\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        # Initialize two node slow and fast point to the hesd node...\\n        fastptr = head\\n        slowptr = head\\n        while fastptr is not None and fastptr.next is not None:\\n            # Move slow pointer by 1 node and fast at 2 at each step.\\n            slowptr = slowptr.next\\n            fastptr = fastptr.next.next\\n            # If both the pointers meet at any point, then the cycle is present and return true...\\n            if slowptr == fastptr:\\n                return 1\\n        return 0\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        // Initialize two node slow and fast point to the hesd node...\\n        ListNode fastptr = head;\\n        ListNode slowptr = head;\\n        while(fastptr != null && fastptr.next != null){\\n            // Move slow pointer by 1 node and fast at 2 at each step.\\n            slowptr = slowptr.next;\\n            fastptr = fastptr.next.next;\\n            // If both the pointers meet at any point, then the cycle is present and return true...\\n            if(slowptr == fastptr)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        // Initialize two node slow and fast point to the hesd node...\\n        ListNode* fastptr = head;\\n        ListNode* slowptr = head;\\n        while(fastptr != NULL && fastptr->next != NULL){\\n            // Move slow pointer by 1 node and fast at 2 at each step.\\n            slowptr = slowptr->next;\\n            fastptr = fastptr->next->next;\\n            // If both the pointers meet at any point, then the cycle is present and return true...\\n            if(slowptr == fastptr)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def hasCycle(self, head):\\n        # Initialize two node slow and fast point to the hesd node...\\n        fastptr = head\\n        slowptr = head\\n        while fastptr is not None and fastptr.next is not None:\\n            # Move slow pointer by 1 node and fast at 2 at each step.\\n            slowptr = slowptr.next\\n            fastptr = fastptr.next.next\\n            # If both the pointers meet at any point, then the cycle is present and return true...\\n            if slowptr == fastptr:\\n                return 1\\n        return 0\\n```\n```\\nvar hasCycle = function(head) {\\n    // Initialize two node slow and fast point to the hesd node...\\n    var fastptr = head;\\n    var slowptr = head;\\n    while(fastptr != null && fastptr.next != null){\\n        // Move slow pointer by 1 node and fast at 2 at each step.\\n        slowptr = slowptr.next;\\n        fastptr = fastptr.next.next;\\n        // If both the pointers meet at any point, then the cycle is present and return true...\\n        if(slowptr == fastptr)\\n            return true;\\n    }\\n    return false;\\n};\\n```\n```\\nbool hasCycle(struct ListNode *head) {\\n    // Initialize two node slow and fast point to the hesd node...\\n    struct ListNode* fastptr = head;\\n    struct ListNode* slowptr = head;\\n    while(fastptr != NULL && fastptr->next != NULL){\\n        // Move slow pointer by 1 node and fast at 2 at each step.\\n        slowptr = slowptr->next;\\n        fastptr = fastptr->next->next;\\n        // If both the pointers meet at any point, then the cycle is present and return true...\\n        if(slowptr == fastptr)\\n            return true;\\n    }\\n    return false;\\n}\\n```\n```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        # Initialize two node slow and fast point to the hesd node...\\n        fastptr = head\\n        slowptr = head\\n        while fastptr is not None and fastptr.next is not None:\\n            # Move slow pointer by 1 node and fast at 2 at each step.\\n            slowptr = slowptr.next\\n            fastptr = fastptr.next.next\\n            # If both the pointers meet at any point, then the cycle is present and return true...\\n            if slowptr == fastptr:\\n                return 1\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549670,
                "title": "2-solutions-easy-to-understand-faster-simple-python-solution",
                "content": "```\\ndef using_two_pointers(self, head):\\n        if not head: return False\\n        slow = head\\n        fast = head.next\\n        while slow and fast and fast != slow and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        return slow == fast\\n    \\n    \\n    def using_dict(self, head):\\n        mem = {}\\n        temp = head\\n        while temp:\\n            if temp in mem: return True\\n            else: mem[temp]= True\\n            temp = temp.next\\n        return False\\n```\\n\\n**I hope that you\\'ve found them useful.**\\n*In that case, please do upvote. It only motivates me to write more such posts\\uD83D\\uDE03*\\n**I am on my quest to document solution to every problem on leetcode\\uD83D\\uDE05**",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\ndef using_two_pointers(self, head):\\n        if not head: return False\\n        slow = head\\n        fast = head.next\\n        while slow and fast and fast != slow and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        return slow == fast\\n    \\n    \\n    def using_dict(self, head):\\n        mem = {}\\n        temp = head\\n        while temp:\\n            if temp in mem: return True\\n            else: mem[temp]= True\\n            temp = temp.next\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3417380,
                "title": "c-java-python-javascript-floyd-s-tortoise-and-hare-algorithm",
                "content": "# Intuition:\\nThe given problem is to detect if there is a cycle in the given linked list. To do so, we use the Floyd\\'s Cycle detection algorithm, which is also known as the \"Tortoise and Hare\" algorithm.\\n\\n# Approach:\\nWe use two pointers, rabbit and tortoise, which start from the head of the linked list. The rabbit moves twice as fast as the tortoise, i.e., it moves two nodes at a time while the tortoise moves one node at a time.\\n\\nIf there is no cycle in the linked list, the rabbit will reach the end of the list, i.e., it will become NULL, and we can return false. However, if there is a cycle, the rabbit will eventually catch up with the tortoise, and both pointers will point to the same node. We return true in this case.\\n\\n## Algorithm Steps:\\n\\n1. Initialize two pointers, rabbit and tortoise, to the head of the linked list.\\n2. While the rabbit pointer is not NULL and its next pointer is not NULL, repeat steps 3-4.\\n3. Move the rabbit pointer two nodes ahead.\\n4. Move the tortoise pointer one node ahead.\\n5. If the rabbit and tortoise pointers point to the same node, return true.\\n6. If the rabbit pointer becomes NULL, return false.\\n# Complexity:\\n- Time complexity: O(n), where n is the number of nodes in the linked list. In the worst case scenario, we will need to traverse the entire list to determine if there is a cycle.\\n- Space complexity: O(1), as we are only using two pointers and not using any additional data structures.\\n\\n# C++\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n       auto rabbit=head, tortoise=head;\\n       while(rabbit && rabbit->next){\\n           rabbit=rabbit->next->next;\\n           tortoise=tortoise->next;\\n           if(rabbit==tortoise){\\n               return true;\\n           }\\n       }\\n       return false;\\n    }\\n};\\n```\\n# JAVA\\n```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode rabbit = head;\\n        ListNode tortoise = head;\\n        while (rabbit != null && rabbit.next != null) {\\n            rabbit = rabbit.next.next;\\n            tortoise = tortoise.next;\\n            if (rabbit == tortoise) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n```\\n# Python\\n```\\nclass Solution(object):\\n    def hasCycle(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: bool\\n        \"\"\"\\n        rabbit = head\\n        tortoise = head\\n        while rabbit and rabbit.next:\\n            rabbit = rabbit.next.next\\n            tortoise = tortoise.next\\n            if rabbit == tortoise:\\n                return True\\n        return False\\n\\n```\\n# Javascript\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {boolean}\\n */\\nvar hasCycle = function(head) {\\n    let rabbit = head, tortoise = head;\\n    while (rabbit && rabbit.next) {\\n        rabbit = rabbit.next.next;\\n        tortoise = tortoise.next;\\n        if (rabbit === tortoise) {\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n       auto rabbit=head, tortoise=head;\\n       while(rabbit && rabbit->next){\\n           rabbit=rabbit->next->next;\\n           tortoise=tortoise->next;\\n           if(rabbit==tortoise){\\n               return true;\\n           }\\n       }\\n       return false;\\n    }\\n};\\n```\n```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode rabbit = head;\\n        ListNode tortoise = head;\\n        while (rabbit != null && rabbit.next != null) {\\n            rabbit = rabbit.next.next;\\n            tortoise = tortoise.next;\\n            if (rabbit == tortoise) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def hasCycle(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: bool\\n        \"\"\"\\n        rabbit = head\\n        tortoise = head\\n        while rabbit and rabbit.next:\\n            rabbit = rabbit.next.next\\n            tortoise = tortoise.next\\n            if rabbit == tortoise:\\n                return True\\n        return False\\n\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {boolean}\\n */\\nvar hasCycle = function(head) {\\n    let rabbit = head, tortoise = head;\\n    while (rabbit && rabbit.next) {\\n        rabbit = rabbit.next.next;\\n        tortoise = tortoise.next;\\n        if (rabbit === tortoise) {\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673790,
                "title": "python3-solution-without-new-pointer-in-8-lines",
                "content": "# Intuition\\nCome up with this solution when seeing the limit of node\\'s value is between -10^5 and 10^5.\\n\\n# Approach\\n1. Loop through the linked list. If the current node is None, it means there is no cycle.\\n2. Modify the value of the node that has checked. The value could be anything out of the range -10^5 and 10^5.\\n\\n# Complexity\\nTime: O(n)\\nSpace: O(1) \\n\\n# Code\\n```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        while head:\\n            if head.val == 10**6:\\n                return True\\n            head.val = 10**6\\n            head = head.next\\n        return False\\n\\n```\\n\\nPlease upvote \\u2B06 if you like my very first solution \\u0295\\u2022\\u1D25\\u2022\\u0294",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        while head:\\n            if head.val == 10**6:\\n                return True\\n            head.val = 10**6\\n            head = head.next\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938506,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init(_ val: Int) {\\n *         self.val = val\\n *         self.next = nil\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func hasCycle(_ head: ListNode?) -> Bool {\\n        var slow = head\\n        var fast = head?.next\\n        \\n        while slow != nil, fast != nil {\\n            guard slow !== fast else { return true }\\n            \\n            slow = slow?.next\\n            fast = fast?.next?.next            \\n        }\\n        \\n        return false\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init(_ val: Int) {\\n *         self.val = val\\n *         self.next = nil\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func hasCycle(_ head: ListNode?) -> Bool {\\n        var slow = head\\n        var fast = head?.next\\n        \\n        while slow != nil, fast != nil {\\n            guard slow !== fast else { return true }\\n            \\n            slow = slow?.next\\n            fast = fast?.next?.next            \\n        }\\n        \\n        return false\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44607,
                "title": "in-place-python-code-beats-90",
                "content": "Multiple pointers having different steps are our friend to solve Linked List problems. We can set two pointers to \"run through\" the linked list. Since they have different pace, if the list is cyclic, they **must** meet after the starting point. \\n\\nIn this case I choose two pointers and steps are `1` and `2` respectively. I think assigning one step as `3` is also doable, but I have no ideas which one is better.\\n<br>\\n\\n    def hasCycle(self, head):\\n        fast = slow = head\\n\\n        while slow and fast and fast.next:\\n            slow = slow.next                # Step of 1\\n            fast = fast.next.next           # Setp of 2\\n\\n            if slow is fast:                # Checking whether two pointers meet\\n                return True\\n\\n        return False",
                "solutionTags": [
                    "Python"
                ],
                "code": "Multiple pointers having different steps are our friend to solve Linked List problems. We can set two pointers to \"run through\" the linked list. Since they have different pace, if the list is cyclic, they **must** meet after the starting point. \\n\\nIn this case I choose two pointers and steps are `1` and `2` respectively. I think assigning one step as `3` is also doable, but I have no ideas which one is better.\\n<br>\\n\\n    def hasCycle(self, head):\\n        fast = slow = head\\n\\n        while slow and fast and fast.next:\\n            slow = slow.next                # Step of 1\\n            fast = fast.next.next           # Setp of 2\\n\\n            if slow is fast:                # Checking whether two pointers meet\\n                return True\\n\\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 44614,
                "title": "java-11ms-solution-with-hashset-and-1ms-solution-without-extra-space",
                "content": "        public boolean hasCycle(ListNode head) {\\n    \\t\\tif (head == null || head.next == null)\\n    \\t\\t\\treturn false;\\n    \\t\\tHashSet<ListNode> nodeSet = new HashSet<>();\\n    \\t\\twhile(head != null) {\\n    \\t\\t\\tif (nodeSet.contains(head))\\n    \\t\\t\\t\\treturn true;\\n    \\t\\t\\tnodeSet.add(head);\\n    \\t\\t\\thead = head.next;\\n    \\t\\t}\\n    \\t\\treturn false;\\n    \\t}\\n    \\t\\n    \\tpublic boolean hasCycleNoExtraSpace(ListNode head) {\\n    \\t\\tif (head == null || head.next == null) \\n    \\t\\t\\treturn false;\\n    \\t\\tListNode p = head;\\n    \\t\\tListNode q = head;\\n    \\t\\twhile(q != null && q.next != null) {\\n    \\t\\t\\tp = p.next;\\n    \\t\\t\\tq = q.next.next;\\n    \\t\\t\\tif (p == q)\\n    \\t\\t\\t\\treturn true;\\n    \\t\\t}\\n    \\t\\treturn false;\\n    \\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "        public boolean hasCycle(ListNode head) {\\n    \\t\\tif (head == null || head.next == null)\\n    \\t\\t\\treturn false;\\n    \\t\\tHashSet<ListNode> nodeSet = new HashSet<>();\\n    \\t\\twhile(head != null) {\\n    \\t\\t\\tif (nodeSet.contains(head))\\n    \\t\\t\\t\\treturn true;\\n    \\t\\t\\tnodeSet.add(head);\\n    \\t\\t\\thead = head.next;\\n    \\t\\t}\\n    \\t\\treturn false;\\n    \\t}\\n    \\t\\n    \\tpublic boolean hasCycleNoExtraSpace(ListNode head) {\\n    \\t\\tif (head == null || head.next == null) \\n    \\t\\t\\treturn false;\\n    \\t\\tListNode p = head;\\n    \\t\\tListNode q = head;\\n    \\t\\twhile(q != null && q.next != null) {\\n    \\t\\t\\tp = p.next;\\n    \\t\\t\\tq = q.next.next;\\n    \\t\\t\\tif (p == q)\\n    \\t\\t\\t\\treturn true;\\n    \\t\\t}\\n    \\t\\treturn false;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3999179,
                "title": "video-solution-with-two-pointers-and-a-bonus-video-python-javascript-java-c",
                "content": "# Intuition\\nThe main idea to solve the question of detecting a cycle in a singly-linked list is to use the concept of two pointers: a \"slow\" pointer that moves one step at a time and a \"fast\" pointer that moves two steps at a time. By having these two pointers traverse the list simultaneously, if there is a cycle, the fast pointer will eventually catch up to the slow pointer. If there is no cycle, the fast pointer will reach the end of the list.\\n\\n---\\n\\n# Solution Video\\n\\n### Please subscribe to my channel from here. I have 254 videos as of September 4th, 2023.\\n\\nhttps://youtu.be/AwlrFqjq0cY\\n\\n### In the video, the steps of approach below are visualized using diagrams and drawings. I\\'m sure you understand the solution easily!\\n\\n### \\u2B50\\uFE0F\\u2B50\\uFE0F Don\\'t forget to subscribe to my channel! \\u2B50\\uFE0F\\u2B50\\uFE0F\\n\\n**\\u25A0 Subscribe URL**\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nThe next subscriber will be exact 2200.\\n\\n---\\n\\n# Approach\\nThis is based on Python. Other might be different a bit.\\n\\n1. Initialize `fast` and `slow` pointers to the head of the linked list.\\n   - `fast` and `slow` are initially pointing to the head of the linked list, which is the starting point.\\n\\n2. Enter a loop while both `fast` and `fast.next` are not null.\\n   - This loop will continue until either `fast` or `fast.next` becomes null, indicating the end of the linked list or if there is no cycle.\\n\\n3. Move the `fast` pointer two steps ahead (`fast = fast.next.next`) and the `slow` pointer one step ahead (`slow = slow.next`).\\n   - This step simulates the two-pointer traversal where `fast` moves twice as fast as `slow`.\\n\\n4. Check if `fast` is equal to `slow`.\\n   - If `fast` and `slow` pointers meet at the same node, it means there is a cycle in the linked list, and we return `True`.\\n\\n5. If the loop exits without finding a cycle, return `False`.\\n   - If the loop completes without finding a cycle, it means that the `fast` pointer has reached the end of the list, and there is no cycle. In this case, we return `False`.\\n\\nThis algorithm uses two pointers, `fast` and `slow`, to traverse the linked list. The `fast` pointer moves twice as fast as the `slow` pointer. If there is a cycle, the `fast` pointer will eventually catch up to the `slow` pointer. If there is no cycle, the `fast` pointer will reach the end of the list, and the function will return `False`. This algorithm is an efficient way to detect cycles in a singly-linked list.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n```python []\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n    \\n        fast = head\\n        slow = head\\n        \\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n            \\n            if fast == slow:\\n                return True\\n    \\n        return False\\n```\\n```javascript []\\nvar hasCycle = function(head) {\\n    let fast = head;\\n    let slow = head;\\n\\n    while (fast && fast.next) {\\n        fast = fast.next.next;\\n        slow = slow.next;\\n\\n        if (fast === slow) {\\n            return true;\\n        }\\n    }\\n\\n    return false;    \\n};\\n```\\n```java []\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n\\n        while (fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n\\n            if (fast == slow) {\\n                return true;\\n            }\\n        }\\n\\n        return false;        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* fast = head;\\n        ListNode* slow = head;\\n\\n        while (fast != nullptr && fast->next != nullptr) {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n\\n            if (fast == slow) {\\n                return true;\\n            }\\n        }\\n\\n        return false;        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n    \\n        fast = head\\n        slow = head\\n        \\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n            \\n            if fast == slow:\\n                return True\\n    \\n        return False\\n```\n```javascript []\\nvar hasCycle = function(head) {\\n    let fast = head;\\n    let slow = head;\\n\\n    while (fast && fast.next) {\\n        fast = fast.next.next;\\n        slow = slow.next;\\n\\n        if (fast === slow) {\\n            return true;\\n        }\\n    }\\n\\n    return false;    \\n};\\n```\n```java []\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n\\n        while (fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n\\n            if (fast == slow) {\\n                return true;\\n            }\\n        }\\n\\n        return false;        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* fast = head;\\n        ListNode* slow = head;\\n\\n        while (fast != nullptr && fast->next != nullptr) {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n\\n            if (fast == slow) {\\n                return true;\\n            }\\n        }\\n\\n        return false;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1048428,
                "title": "python-3-solutions-explained",
                "content": "**Solution 1:** Easiest method\\n```html5\\n<b>Time Complexity: O(n)</b> &becaus; we must traverse every node in the linked list\\n<b>Space Complexity: O(n)</b> &becaus; we need to store every node in the linked list in seen\\n```\\n\\nIterate over the linked list, if head is ever None, then we reached the end, there is no cycle.\\nIf head is ever a node that we have already seen, then return True, there is a cycle.\\n\\n```python\\ndef hasCycle(self, head: ListNode) -> bool:\\n\\tseen = set()\\n\\twhile head:\\n\\t\\tif head in seen:\\n\\t\\t\\treturn True\\n\\t\\tseen.add(head)\\n\\t\\thead = head.next\\n\\treturn False\\n```\\n\\n<br>\\n\\n**Solution 2:** Two turtles and one Hare\\n```html5\\n<b>Time Complexity: O(n)</b> &becaus; we must traverse every node in the linked list\\n<b>Space Complexity: O(1)</b> &becaus; we only need to store 3 pointers regardless of the length of the list\\n```\\n\\nTwo turtles start off at node\\'s 0 and 1, and the rabbit starts off at node 1.  \\nEach turn, the rabbit moves 2 nodes forward and each turtle only moves 1 node forward.\\nIf there is a cycle, eventually the rabbit **must** land on a turtle because it cannot move more\\nthan 2 spaces at a time, and the two turtles (side by side) cover 2 spaces.\\nIf the rabbit lands on the same node as a turtle, then there is a cycle.\\nIf the rabbit runs out of nodes, then there is no cycle.\\n\\n```python\\ndef hasCycle(self, head: ListNode) -> bool:\\n\\tif not head: return False\\n\\thare = turtle1 = head.next\\n\\tturtle2 = head\\n\\twhile True:\\n\\t\\t# move hare pointer up two\\n\\t\\tif not hare or not hare.next: return False\\n\\t\\thare = hare.next.next\\n\\n\\t\\t# move both turtles forward one node\\n\\t\\tif turtle1 == hare or turtle2 == hare: return True\\n\\t\\tturtle1, turtle2 = turtle1.next, turtle2.next\\n```\\n\\n<br>\\n\\n**Solution 3:** One turtle and one hare\\n```html5\\n<b>Time Complexity: O(n)</b> &becaus; we must traverse every node in the linked list\\n<b>Space Complexity: O(1)</b> &becaus; we only need to store 2 pointers regardless of the length of the list\\n```\\n\\n```python\\ndef hasCycle(self, head: ListNode) -> bool:\\n\\tif not head: return False\\n\\thare = turtle = head\\n\\twhile True:\\n\\t\\tturtle = turtle.next\\n\\t\\tif not hare or not hare.next: return False\\n\\t\\thare = hare.next.next\\n\\t\\tif hare == turtle:\\n\\t\\t\\treturn True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```html5\\n<b>Time Complexity: O(n)</b> &becaus; we must traverse every node in the linked list\\n<b>Space Complexity: O(n)</b> &becaus; we need to store every node in the linked list in seen\\n```\n```python\\ndef hasCycle(self, head: ListNode) -> bool:\\n\\tseen = set()\\n\\twhile head:\\n\\t\\tif head in seen:\\n\\t\\t\\treturn True\\n\\t\\tseen.add(head)\\n\\t\\thead = head.next\\n\\treturn False\\n```\n```html5\\n<b>Time Complexity: O(n)</b> &becaus; we must traverse every node in the linked list\\n<b>Space Complexity: O(1)</b> &becaus; we only need to store 3 pointers regardless of the length of the list\\n```\n```python\\ndef hasCycle(self, head: ListNode) -> bool:\\n\\tif not head: return False\\n\\thare = turtle1 = head.next\\n\\tturtle2 = head\\n\\twhile True:\\n\\t\\t# move hare pointer up two\\n\\t\\tif not hare or not hare.next: return False\\n\\t\\thare = hare.next.next\\n\\n\\t\\t# move both turtles forward one node\\n\\t\\tif turtle1 == hare or turtle2 == hare: return True\\n\\t\\tturtle1, turtle2 = turtle1.next, turtle2.next\\n```\n```html5\\n<b>Time Complexity: O(n)</b> &becaus; we must traverse every node in the linked list\\n<b>Space Complexity: O(1)</b> &becaus; we only need to store 2 pointers regardless of the length of the list\\n```\n```python\\ndef hasCycle(self, head: ListNode) -> bool:\\n\\tif not head: return False\\n\\thare = turtle = head\\n\\twhile True:\\n\\t\\tturtle = turtle.next\\n\\t\\tif not hare or not hare.next: return False\\n\\t\\thare = hare.next.next\\n\\t\\tif hare == turtle:\\n\\t\\t\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 44636,
                "title": "accepted-6-line-code-in-c",
                "content": "    bool hasCycle(struct ListNode *head) {\\n        struct ListNode *fast=head, *slow=head;\\n        while( slow && fast && fast->next ){\\n            fast=fast->next->next;\\n            slow=slow->next;\\n            if(fast==slow) return true;\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "    bool hasCycle(struct ListNode *head) {\\n        struct ListNode *fast=head, *slow=head;\\n        while( slow && fast && fast->next ){\\n            fast=fast->next->next;\\n            slow=slow->next;\\n            if(fast==slow) return true;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1535461,
                "title": "c-method-two-pointer",
                "content": "# First I tried using hashset but that requires O(n) space\\n```\\npublic class Solution {\\n    public bool HasCycle(ListNode head) {\\n        \\n        HashSet<ListNode> finder = new HashSet<ListNode>();\\n        \\n        ListNode current = head;\\n        \\n        while(current != null)\\n        {\\n            if(finder.Contains(current))\\n                return true;\\n            \\n            finder.Add(current);\\n            current = current.next;\\n        }\\n        \\n        return false;\\n        \\n    }\\n}\\n```\\n# Then I tried two pointers approach \\n```\\npublic class Solution {\\n    public bool HasCycle(ListNode head) {\\n        if(head == null) return false;\\n        \\n        ListNode slow = head;\\n        ListNode fast = head;\\n        \\n        while(fast != null && fast.next != null)\\n        {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            \\n            if(slow == fast)\\n                return true;\\n        }\\n\\n        return false;\\n        \\n    }\\n}\\n```\\n\\n# Key here is that when you move one pointer slowly and another pointer faster then eventually if there is a cycle they will meetup.",
                "solutionTags": [
                    "C#",
                    "Two Pointers"
                ],
                "code": "```\\npublic class Solution {\\n    public bool HasCycle(ListNode head) {\\n        \\n        HashSet<ListNode> finder = new HashSet<ListNode>();\\n        \\n        ListNode current = head;\\n        \\n        while(current != null)\\n        {\\n            if(finder.Contains(current))\\n                return true;\\n            \\n            finder.Add(current);\\n            current = current.next;\\n        }\\n        \\n        return false;\\n        \\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public bool HasCycle(ListNode head) {\\n        if(head == null) return false;\\n        \\n        ListNode slow = head;\\n        ListNode fast = head;\\n        \\n        while(fast != null && fast.next != null)\\n        {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            \\n            if(slow == fast)\\n                return true;\\n        }\\n\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 167587,
                "title": "java-python-logical-thinking",
                "content": "We set two pointers fast and slow. \\nfast moves 2 steps at a time, while slow moves one step a time as below,\\n\\n1: |sf--------|\\n2: |-s-f------|\\n3: |--s--f----|\\n4: |---s---f--|\\n5: |----s----f|\\n\\nIf there is no cycle in the List, the fast pointer reaches the tail at O(n/2) time.\\n\\nIf the List is circular, the slow pointer moves through the whole List and eventually equals to the fast pointer\\n\\n6: |--f---s---|\\n7: |----f--s--| x\\n8: |------f-s-|\\n9: |--------fs|\\n10: s == f\\n\\nIf the list contains a cycle (but not circular),\\ncase 1:\\n6: |---f--s---|\\n7: |-----f-s--|\\n8: |-------fs-|\\n9: s == f\\n\\ncase 2:\\n6: |----f-s---| same as x\\n...\\n\\ncase n:\\nsame as ...\\n****\\n**Java**\\n```\\n    public boolean hasCycle(ListNode head) {\\n        \\n        ListNode fast = head, slow = head;\\n        while (fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (slow == fast) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```\\n**Python**\\n```\\n    def hasCycle(self, head):        \\n        slow = fast = head\\n            \\n        while fast != None and fast.next != None:\\n            fast = fast.next.next\\n            slow = slow.next\\n            if slow == fast:\\n                return True\\n                    \\n        return False\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n    public boolean hasCycle(ListNode head) {\\n        \\n        ListNode fast = head, slow = head;\\n        while (fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (slow == fast) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```\n```\\n    def hasCycle(self, head):        \\n        slow = fast = head\\n            \\n        while fast != None and fast.next != None:\\n            fast = fast.next.next\\n            slow = slow.next\\n            if slow == fast:\\n                return True\\n                    \\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 44690,
                "title": "my-easy-12ms-c-solution-sharing",
                "content": "    bool hasCycle(ListNode *head) \\n    {\\n        ListNode *fast;\\n        fast = head;\\n        while (head)\\n        {\\n            head = head->next;\\n            if (fast->next && fast->next->next)\\n                fast = fast->next->next;\\n            else\\n                return false;\\n                \\n            if (fast == head)\\n                return true;\\n        }\\n        \\n        return false;\\n    }",
                "solutionTags": [],
                "code": "    bool hasCycle(ListNode *head) \\n    {\\n        ListNode *fast;\\n        fast = head;\\n        while (head)\\n        {\\n            head = head->next;\\n            if (fast->next && fast->next->next)\\n                fast = fast->next->next;\\n            else\\n                return false;\\n                \\n            if (fast == head)\\n                return true;\\n        }\\n        \\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1776569,
                "title": "javascript-time-o-n-space-o-1-simple-approach-with-explanation",
                "content": "1. Visit a Node and replace its value to any non integer, here I took \\'X\\' character.\\n2. Move to next Node and check if it is \\'X\\'\\n3. if true means it is a cycle so return true\\n4. else Move to next... repeat step 2 and 3 till end of the Linked list.\\n5. return false if no cycle found.\\n\\n\\n```\\nvar hasCycle = function(head) {\\n    let start = new ListNode(head);\\n    while(head){\\n        if(head.val === \\'X\\'){\\n            return true;\\n        }\\n        head.val = \\'X\\';\\n        head = head.next;\\n    }\\n    return false;\\n};\\n```\\n\\n**Upvote** if helped.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar hasCycle = function(head) {\\n    let start = new ListNode(head);\\n    while(head){\\n        if(head.val === \\'X\\'){\\n            return true;\\n        }\\n        head.val = \\'X\\';\\n        head = head.next;\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1829907,
                "title": "c-detailed-explanation-w-images-see-visually-how-pointer-changes-commented-code",
                "content": "***Brief note about Question***-\\n* We have to return true if there is a cycle in the linked list. Otherwise, return false.\\n```\\nLet\\'s take an example not given in the question-\\nSuppose our head and position given to us as head = [4,5,6,7,8,9] & pos = 4\\n\\nSo, linked looks like-\\n\\n  4 --> 5 --> 6 --> 7 --> 8 --> 9\\n                          \\u2191     \\u2193\\n\\t\\t\\t\\t\\t\\t  \\u2190 \\u2190 \\u2190 \\u2193\\n\\t\\t\\t\\t\\t\\t  \\n\\t\\t\\t\\t\\t\\t  So, their is a cycle at position 4,\\n\\t\\t\\t\\t\\t\\t  therefore we have to return true as our answer\\n```\\n_____________\\n***Solution - I (Accepted)-***\\n* We maintain two pointers i.e slow and fast.\\n* Our fast pointer takes two step at a time and slow pointer is slow so he takes one step at a time.\\n* So, if their is a cycle present in our linked list, then no matter how fast our fast pointer moves. their is a time come when both i.e slow and fast pointer are standing on a same position.\\n* Why this happen? See, since our fast pointer taking two steps at a time,so by defaullt he will be always ahead of our slow pointer.\\n* But their is a cycle present in the linked list, our fast pointer end up in moving the cycle only.\\n* And their is a time came when both our fast and slow pointer stands up the same position.\\n* So, If fast and slow pointer cames to same position then we will return true by saying that yes their is a cycle in the linked list.\\n* But, Suppose if their is no cycle present in the linked list, then? \\n* If their is no cyle present in the linked list then our fast pointer was the first one who reaches to the end.\\n* So if fast pointer reaches to the end, then we will say their is no cycle present in the linked list and hence return false.\\n* See below Image for better clarification.\\n_________________\\n* ![image](https://assets.leetcode.com/users/images/11e14acb-6005-4c2a-8ed5-59908440490a_1646713764.0097659.jpeg)\\n_________\\n**Code (C++)**\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* slow = head; // making slow pointer\\n        ListNode* fast = head; // making fast pointer\\n\\n        while(fast != NULL && fast -> next != NULL)\\n        {\\n            slow = slow -> next; // move slow one step at a time\\n            fast = fast -> next -> next; // move fast two step at a time\\n            \\n            // if at any point slow and fast pointer reaches to the same pos\\n            // then we can say that yess!, their is a cycle and hence return true\\n\\t\\t\\t\\n            if(slow == fast) // if slow is equal to fast\\n            {\\n                return true; // means cycle, and hence return true\\n            }\\n        }\\n        \\n        // otherwise no cycle is present, hence return false\\n        return false;\\n    }\\n};\\n```\\n***`If u find this useful , please consider to give a upvote!!`***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nLet\\'s take an example not given in the question-\\nSuppose our head and position given to us as head = [4,5,6,7,8,9] & pos = 4\\n\\nSo, linked looks like-\\n\\n  4 --> 5 --> 6 --> 7 --> 8 --> 9\\n                          \\u2191     \\u2193\\n\\t\\t\\t\\t\\t\\t  \\u2190 \\u2190 \\u2190 \\u2193\\n\\t\\t\\t\\t\\t\\t  \\n\\t\\t\\t\\t\\t\\t  So, their is a cycle at position 4,\\n\\t\\t\\t\\t\\t\\t  therefore we have to return true as our answer\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* slow = head; // making slow pointer\\n        ListNode* fast = head; // making fast pointer\\n\\n        while(fast != NULL && fast -> next != NULL)\\n        {\\n            slow = slow -> next; // move slow one step at a time\\n            fast = fast -> next -> next; // move fast two step at a time\\n            \\n            // if at any point slow and fast pointer reaches to the same pos\\n            // then we can say that yess!, their is a cycle and hence return true\\n\\t\\t\\t\\n            if(slow == fast) // if slow is equal to fast\\n            {\\n                return true; // means cycle, and hence return true\\n            }\\n        }\\n        \\n        // otherwise no cycle is present, hence return false\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226855,
                "title": "javascript",
                "content": "**\\u65B9\\u6CD51:** \\u4F7F\\u7528\\u96C6\\u5408\\u5224\\u65AD\\n**\\u89E3\\u9898\\u601D\\u8DEF:**\\n1. \\u4E0D\\u65AD\\u904D\\u5386\\u94FE\\u8868, \\u5C06\\u904D\\u5386\\u8FC7\\u7684\\u8282\\u70B9\\u653E\\u5165\\u96C6\\u5408\\u4E2D.\\n2. \\u5982\\u679C\\u8282\\u70B9\\u51FA\\u73B0\\u5728\\u4E4B\\u524D\\u7684\\u96C6\\u5408\\u4E2D, \\u5219\\u4E3A\\u6709\\u73AF.\\n\\n**\\u4EE3\\u7801:**\\n```\\nvar hasCycle = function(head) {\\n  const nodes = new Set();\\n  while (head) {\\n    if (nodes.has(head)) return true;\\n    nodes.add(head);\\n    head = head.next;\\n  }\\n  return false;\\n};\\n```\\n\\n**\\u65B9\\u6CD52:** \\u5FEB\\u6162\\u6307\\u9488\\u6CD5\\n**\\u89E3\\u9898\\u601D\\u8DEF:**\\n1. \\u5FEB\\u6307\\u9488\\u6BCF\\u6B21\\u8D70\\u4E24\\u6B65, \\u6162\\u6307\\u9488\\u6BCF\\u6B21\\u8D70\\u4E00\\u6B65. \\u90A3\\u5B9E\\u9645\\u4E0A\\u5FEB\\u6307\\u9488\\u4F1A\\u6BD4\\u6162\\u6307\\u9488\\u591A\\u8D70\\u4E00\\u6B65.\\n2. \\u53EA\\u8981\\u5B58\\u5728\\u73AF\\u8DEF, \\u90A3\\u4E48\\u5FEB\\u6307\\u9488\\u4E00\\u5B9A\\u4F1A\\u8FFD\\u4E0A\\u6162\\u6307\\u9488, \\u5E76\\u4E14\\u76F8\\u7B49\\u800C\\u4E0D\\u4F1A\\u8DF3\\u8FC7.\\n\\n**\\u4EE3\\u7801:**\\n```\\nvar hasCycle = function(head) {\\n  let fast = head;\\n  let slow = head;\\n  \\n  while (fast && fast.next) {\\n    fast = fast.next.next;\\n    slow = slow.next;\\n    \\n    if (fast === slow) return true;\\n  }\\n  return false;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar hasCycle = function(head) {\\n  const nodes = new Set();\\n  while (head) {\\n    if (nodes.has(head)) return true;\\n    nodes.add(head);\\n    head = head.next;\\n  }\\n  return false;\\n};\\n```\n```\\nvar hasCycle = function(head) {\\n  let fast = head;\\n  let slow = head;\\n  \\n  while (fast && fast.next) {\\n    fast = fast.next.next;\\n    slow = slow.next;\\n    \\n    if (fast === slow) return true;\\n  }\\n  return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1561115,
                "title": "python-easy-solution-with-explanation-institutive",
                "content": "* **Idea** : we create two runners \\n\\t*  slow : go through the linked list one step a time\\n\\t* fast : go through the linked list two step at a time\\n*  If the the fast or the slow hit the end before they meet\\n\\t* the linked list doesn\\'t have a cycle\\n* If they become equal at some point\\n\\t* \\tthe linked list has a cycle        \\n\\n        \\n```\\ndef hasCycle(self, head):\\n        if not head or not head.next:\\n            return False\\n        \\n        slow = head # slow mover pointer\\n        fast = head.next # fast mover pointer\\n        \\n        while fast != None and fast.next != None: # since the fast pointer is the leader; if there is an end it would be the fast who would hit the end first\\n            if slow == fast: # if they are equal the fast finsh the cycle and has catch the slow --> there is a cycle\\n                return True\\n            else:  # else just move slow one step and fast two step at a time\\n                slow = slow.next\\n                fast = fast.next.next\\n        return False # if the fast hit the end, there is no cycle\\n```\\n\\n##### If you\\'ve found this helpful, comment and upvote  \\n* ##### encourage me to on my quest to document leetcode problem solutions\\uD83D\\uDE03\\n##### Search for Abeni tag in the discussion, \\n* ##### if I have solved it, You will find a detial explanation there \\uD83E\\uDD16",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\ndef hasCycle(self, head):\\n        if not head or not head.next:\\n            return False\\n        \\n        slow = head # slow mover pointer\\n        fast = head.next # fast mover pointer\\n        \\n        while fast != None and fast.next != None: # since the fast pointer is the leader; if there is an end it would be the fast who would hit the end first\\n            if slow == fast: # if they are equal the fast finsh the cycle and has catch the slow --> there is a cycle\\n                return True\\n            else:  # else just move slow one step and fast two step at a time\\n                slow = slow.next\\n                fast = fast.next.next\\n        return False # if the fast hit the end, there is no cycle\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1515121,
                "title": "c-python-simple-two-pointers-solution",
                "content": "**C++ :**\\n\\n```\\nbool hasCycle(ListNode *head) {\\n\\tListNode* slow = head;\\n\\tListNode* fast = head;\\n\\n\\twhile(slow && fast && fast -> next)\\n\\t{\\n\\t\\tslow = slow -> next;\\n\\t\\tfast  = fast -> next -> next;\\n\\n\\t\\tif(slow == fast)\\n\\t\\t\\treturn true;\\n\\t}\\n\\n\\treturn false;\\n}\\n```\\n\\n**Python :**\\n\\n```\\ndef hasCycle(self, head: ListNode) -> bool:\\n\\tslow = head\\n\\tfast = head\\n\\n\\twhile slow and fast and fast.next:\\n\\t\\tslow = slow.next\\n\\t\\tfast  = fast.next.next\\n\\n\\t\\tif slow == fast:\\n\\t\\t\\treturn True\\n\\n\\treturn False\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nbool hasCycle(ListNode *head) {\\n\\tListNode* slow = head;\\n\\tListNode* fast = head;\\n\\n\\twhile(slow && fast && fast -> next)\\n\\t{\\n\\t\\tslow = slow -> next;\\n\\t\\tfast  = fast -> next -> next;\\n\\n\\t\\tif(slow == fast)\\n\\t\\t\\treturn true;\\n\\t}\\n\\n\\treturn false;\\n}\\n```\n```\\ndef hasCycle(self, head: ListNode) -> bool:\\n\\tslow = head\\n\\tfast = head\\n\\n\\twhile slow and fast and fast.next:\\n\\t\\tslow = slow.next\\n\\t\\tfast  = fast.next.next\\n\\n\\t\\tif slow == fast:\\n\\t\\t\\treturn True\\n\\n\\treturn False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1829693,
                "title": "python-go-floyd-s-cycle-detection-solution-and-explanation",
                "content": "**\\uD83D\\uDC46Please UPVOTE it if you find my soulutions are useful \\uD83D\\uDC46 Feel free to ask any question**\\n# [Python/Go] \\uD83C\\uDF1FFloyd\\'s Cycle Detection Solution and Explanation \\uD83D\\uDC95\\n\\n## 1\\uFE0F\\u20E3 Floyd\\'s Cycle Detection Approach:\\nIn this question we set two pointer:\\n> **slow**: move to next pointer each time\\n> **fast**: move to next.next pointer each time\\n\\n> Step 1: Traverse slow and fast pointer all the way until they meet\\n( If there is no cycle in the linked list the fast pointer will point to None eventually)\\n\\n> Step 2: Return if slow == fast, (if there is no cycle fast will be None)\\n\\n## Math Explained\\nLet the whole linked-list\\'s length be *n*, distance between **head** and the **slow index** of the cycle be *m*,\\nThe distance between **slow index** of the cycle and the **index where slow and fast pointer meets** to be *p*\\n\\nWe can know that in the step 1: first pointer traverse the distance m+p and the second traverse 2(m + p) and also equals to  n+p => n = 2m + p\\nUpon this equation if we move second pointer m step it will traverse the linked-list again point at 2m + p which is our target\\n\\n### IF YOU CAN: Better draw a graph and mark these distance so you will know the whole math equation\\n\\n## Complexity Analysis\\n* Time: O(N): Let N be the length of linked list\\n* Space: O(1)\\n* \\n## Floyd\\'s Cycle Detection Code\\n**Python**\\n```python\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        if head is None or head.next is None:\\n            return False\\n        slow = head\\n        fast = head.next\\n        while fast.next and fast.next.next and slow != fast:\\n            slow = slow.next\\n            fast = fast.next.next\\n        return slow == fast\\n```\\n**Go**\\n```go\\nfunc hasCycle(head *ListNode) bool {\\n    if head == nil || head.Next == nil{\\n        return false\\n    }\\n    slow := head\\n    fast := head.Next\\n    \\n    for fast.Next != nil && fast.Next.Next != nil && fast != slow{\\n        slow = slow.Next\\n        fast = fast.Next.Next\\n    }\\n    \\n    return slow == fast\\n}\\n```\\n\\nFOLLOW-UP : [142. Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/)\\nMy Explanation : https://leetcode.com/problems/linked-list-cycle-ii/discuss/1701051/Python-3-Solution-Tow-Pointer-O(N)-Explained\\n\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)",
                "solutionTags": [
                    "Python",
                    "Go"
                ],
                "code": "```python\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        if head is None or head.next is None:\\n            return False\\n        slow = head\\n        fast = head.next\\n        while fast.next and fast.next.next and slow != fast:\\n            slow = slow.next\\n            fast = fast.next.next\\n        return slow == fast\\n```\n```go\\nfunc hasCycle(head *ListNode) bool {\\n    if head == nil || head.Next == nil{\\n        return false\\n    }\\n    slow := head\\n    fast := head.Next\\n    \\n    for fast.Next != nil && fast.Next.Next != nil && fast != slow{\\n        slow = slow.Next\\n        fast = fast.Next.Next\\n    }\\n    \\n    return slow == fast\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1378006,
                "title": "java-easy-to-understand-slow-ptr-fast-ptr-approach",
                "content": "```\\n\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow = head,fast = head;\\n        if(head == null || head.next == null)return false;\\n        while(fast != null && fast.next != null)\\n        {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            if(slow == fast)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow = head,fast = head;\\n        if(head == null || head.next == null)return false;\\n        while(fast != null && fast.next != null)\\n        {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            if(slow == fast)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1047819,
                "title": "easy-in-python-o-1-beats-91",
                "content": "```\\nclass Solution(object):\\n    def hasCycle(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: bool\\n        \"\"\"\\n\\t\\tif head is None or head.next is None return False\\n        slow_ref = head\\n        fast_ref = head\\n        while fast_ref and fast_ref.next:\\n            slow_ref = slow_ref.next\\n            fast_ref = fast_ref.next.next\\n            if slow_ref == fast_ref:\\n                return True\\n        return False\\n\\t\\t\\n\\tIf you get it please Upvote.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution(object):\\n    def hasCycle(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: bool\\n        \"\"\"\\n\\t\\tif head is None or head.next is None return False\\n        slow_ref = head\\n        fast_ref = head\\n        while fast_ref and fast_ref.next:\\n            slow_ref = slow_ref.next\\n            fast_ref = fast_ref.next.next\\n            if slow_ref == fast_ref:\\n                return True\\n        return False\\n\\t\\t\\n\\tIf you get it please Upvote.",
                "codeTag": "Java"
            },
            {
                "id": 3493885,
                "title": "full-explanation-beautiful-easy-approach",
                "content": "# Intuition\\nFast slow pointer approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe will use two pointers with different steps forward. The process is as follows:-\\n\\n1. We will take two pointers, namely fast and slow. Fast pointer takes 2 steps ahead and slow pointer takes 2 points ahead.\\n2. Iterate through the list until the fast pointer is equal to NULL. This is because NULL indicates that there is no cycle present in the given list.\\n3. Cycle can be detected when fast and slow pointers collide.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow= head;\\n        ListNode fast= head;\\n        while(fast!=null&& fast.next!=null){\\n            slow= slow.next;\\n            fast = fast.next.next;\\n            if(slow == fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/e1101f1c-4697-4ad1-8f66-f761c855f316_1683395057.6222804.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow= head;\\n        ListNode fast= head;\\n        while(fast!=null&& fast.next!=null){\\n            slow= slow.next;\\n            fast = fast.next.next;\\n            if(slow == fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1048089,
                "title": "c-floyd-s-cycle-finding-algorithm-o-n-fastest-solution",
                "content": "**Floyd\\u2019s Cycle-Finding Algorithm**\\n\\nTraverse linked list using one **slow** and one **fast** pointer. Move the **slow pointer** by one and the **fast pointer** by two.\\n\\n**CASE 1**\\nIf these pointers meet at the same node then there is a loop.\\n\\n**CASE 2**\\nIf pointers do not meet then the linked list doesn\\u2019t have a loop.\\n\\n**EXAMPLE**\\nConsider the below image.\\n**Initially considering fast pointer = slow pointer +1 , so Distance =1.**\\n\\n![Floyd-Algo-Proof](https://assets.leetcode.com/users/images/8be7aed7-e0d6-43c7-ae61-de4c1d359ede_1612365738.3477886.png)\\n\\n**Finally, if the Distance at any point becomes zero, that is Slow==Fast then cycle found.**\\n\\n\\n**NOTE**\\nIt is absolutely all right to start the **slow** and **fast** pointers from the first and second node respectively **or** both from the first node. ( if they exists ).\\n\\n\\n**CODE**\\n\\n```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        \\n        ListNode *slow=head;\\n        ListNode *fast;\\n        \\n        if(slow)\\n            fast=head->next; // \"fast\" can also start from the same node as \"slow\"\\n        else\\n            return false;\\n        \\n        while(slow||fast){  // while traversing if both of them becomes NULL together, no cycle found\\n\\t\\t\\t\\n            if(slow==fast) // then we got the same node again, hence cycle found\\n                return true; // [ CASE 1 ]\\n            \\n            if(slow)\\n                slow=slow->next; // move 1 step at a time\\n            \\n            if(fast){\\n                if(fast->next)\\n                    fast=fast->next->next; // move 2 step at a time\\n                else\\n                    break; // if 2 step jump not possible at any node then break from loop, hence no cycle\\n            }\\n        }\\n        // [ CASE 2 ]\\n        return false; // no cycle found at this point\\n    }\\n};\\n```\\n\\n\\nConsidering *N* to be the total number of nodes of the link list\\n\\n**TIME COMPLEXITY:** O(N)\\n*[ Atmax the whole link list will be traversed by the slow pointer one time ]*\\n\\n**SPACE COMPLEXITY:** O(1)\\n*[ Since no extra space is used ]*",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        \\n        ListNode *slow=head;\\n        ListNode *fast;\\n        \\n        if(slow)\\n            fast=head->next; // \"fast\" can also start from the same node as \"slow\"\\n        else\\n            return false;\\n        \\n        while(slow||fast){  // while traversing if both of them becomes NULL together, no cycle found\\n\\t\\t\\t\\n            if(slow==fast) // then we got the same node again, hence cycle found\\n                return true; // [ CASE 1 ]\\n            \\n            if(slow)\\n                slow=slow->next; // move 1 step at a time\\n            \\n            if(fast){\\n                if(fast->next)\\n                    fast=fast->next->next; // move 2 step at a time\\n                else\\n                    break; // if 2 step jump not possible at any node then break from loop, hence no cycle\\n            }\\n        }\\n        // [ CASE 2 ]\\n        return false; // no cycle found at this point\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1047648,
                "title": "cheating-solution-o-1-for-fun",
                "content": "as first constraint says \\nThe number of the nodes in the list is in the range **[0, 10^4]**\\nthen we can loop for 10^4 times:\\n* if we find null then we reached the end of the LinkedList => no cycle \\n* if we couldn\\'t find null => cycle found\\n```\\npublic boolean hasCycle(ListNode head) {\\n        int n = 10_001;\\n        for(int i=0; i<n; i++) {\\n            if(head == null) return false;\\n            head = head.next;\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "as first constraint says \\nThe number of the nodes in the list is in the range **[0, 10^4]**\\nthen we can loop for 10^4 times:\\n* if we find null then we reached the end of the LinkedList => no cycle \\n* if we couldn\\'t find null => cycle found\\n```\\npublic boolean hasCycle(ListNode head) {\\n        int n = 10_001;\\n        for(int i=0; i<n; i++) {\\n            if(head == null) return false;\\n            head = head.next;\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 239546,
                "title": "c-cheat-solution-make-use-of-consecutive-memory",
                "content": "Just sharing my solution. This is a special case. \\nConsider all the nodes are stored in consecutive memory. Next node of every node is in higher memory address except the tail node.\\nThe next node of the tail node is in lower memory address or NULL. If it is in lower address, cycle exists.\\n   \\n\\tbool hasCycle(ListNode *head) {\\n        ListNode* cur = head;\\n        if(cur==NULL){\\n            return false;\\n        }\\n        while(true){\\n            if(cur->next == NULL){\\n                return false;\\n            }else if(cur->next <= cur){\\n                return true;\\n            }\\n            cur=cur->next;\\n        }\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "Just sharing my solution. This is a special case. \\nConsider all the nodes are stored in consecutive memory. Next node of every node is in higher memory address except the tail node.\\nThe next node of the tail node is in lower memory address or NULL. If it is in lower address, cycle exists.\\n   \\n\\tbool hasCycle(ListNode *head) {\\n        ListNode* cur = head;\\n        if(cur==NULL){\\n            return false;\\n        }\\n        while(true){\\n            if(cur->next == NULL){\\n                return false;\\n            }else if(cur->next <= cur){\\n                return true;\\n            }\\n            cur=cur->next;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1369573,
                "title": "java-clean-solution-using-boundary-condition-beats-100",
                "content": "**In Question it is mentioned that total 10^4 nodes are possible so if there is a possiblity of a circular loop then head will never point towards null so as the count hits 10^4+1 we know that there is no end to this LinkedList so print True.**\\n\\n```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        int count=0;\\n        while(head!=null){\\n            count++;\\n            head = head.next;\\n            if(count==10001) return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\nPlease do upvote if you liked!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        int count=0;\\n        while(head!=null){\\n            count++;\\n            head = head.next;\\n            if(count==10001) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148048,
                "title": "please-support-swift-solution",
                "content": "Please support a Swift solution to this problem.\\n\\nHere is a solution using pointers.\\n\\n```\\nclass Solution {\\n    \\n    private func bridge<T : AnyObject>(obj : T) -> UnsafeRawPointer {\\n        return UnsafeRawPointer(Unmanaged.passUnretained(obj).toOpaque())\\n    }\\n    \\n    func hasCycle(_ head: ListNode?) -> Bool {\\n        \\n        var slow: ListNode? = head\\n        var fast: ListNode? = head\\n        while fast?.next != nil && fast != nil {\\n            slow = slow?.next\\n            fast = fast?.next?.next\\n            \\n            if let slow = slow, let fast = fast {\\n                let pslow = bridge(obj: slow)\\n                let pfast = bridge(obj: fast)\\n                if pslow == pfast {\\n                    return true\\n                }\\n            }\\n        }\\n        \\n        return false\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private func bridge<T : AnyObject>(obj : T) -> UnsafeRawPointer {\\n        return UnsafeRawPointer(Unmanaged.passUnretained(obj).toOpaque())\\n    }\\n    \\n    func hasCycle(_ head: ListNode?) -> Bool {\\n        \\n        var slow: ListNode? = head\\n        var fast: ListNode? = head\\n        while fast?.next != nil && fast != nil {\\n            slow = slow?.next\\n            fast = fast?.next?.next\\n            \\n            if let slow = slow, let fast = fast {\\n                let pslow = bridge(obj: slow)\\n                let pfast = bridge(obj: fast)\\n                if pslow == pfast {\\n                    return true\\n                }\\n            }\\n        }\\n        \\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 117109,
                "title": "c-floyd-cycle-detection-algorithm",
                "content": "Firstly, I would like to thank @StefanPochmann for his solution. He uses a try catch method which would not work in cpp and will cause an infinite loop. \n\nWe will use the same [Tortoise and Hare](http://https://en.wikipedia.org/wiki/Cycle_detection#Tortoise_and_hare) approach where two pointers are mainted.\n1) Slow pointer //Moves only 1 step at a time\n2) Fast Pointer //Moves 2 steps at a time\n\nAs soon as these pointers meet, we are sure that there is a LOOP(return true). The stop condition for our loop  will be that if either of these pointers reach NULL - that means that the linked list has a definite end. Hence, we will break the loop and say that there is NO LOOP(return false).\n\nTo Understand how it works : https://www.youtube.com/watch?v=LUm2ABqAs1w\n\n```\nbool hasCycle(ListNode *head) {\n        ListNode *slow=head,*fast=head;\n        \n        while(slow!=NULL && fast!=NULL && fast->next!=NULL) {\n            \n            slow = slow->next;               //Slow moves by 1 step\n            fast = fast->next->next;        //Fast moves by two steps\n            \n            if(slow==fast) //If they meet then there is a loop\n                return true;\n        }\n        \n        return false; //No loop\n    }\n```\nFollow Up: [Linked List Cyle 2](https://leetcode.com/problems/linked-list-cycle-ii/description/) asks us to find  the point where the cycle is starting. If you have seen the video then you can easily solve it. If not then  check out my solution for that : https://leetcode.com/problems/linked-list-cycle-ii/discuss/117110/C++-Floyd-Cycle-Detection-Algorithm",
                "solutionTags": [],
                "code": "```\nbool hasCycle(ListNode *head) {\n        ListNode *slow=head,*fast=head;\n        \n        while(slow!=NULL && fast!=NULL && fast->next!=NULL) {\n            \n            slow = slow->next;               //Slow moves by 1 step\n            fast = fast->next->next;        //Fast moves by two steps\n            \n            if(slow==fast) //If they meet then there is a loop\n                return true;\n        }\n        \n        return false; //No loop\n    }\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 44632,
                "title": "my-c-solution",
                "content": "    class Solution {\\n    public:\\n        bool hasCycle(ListNode *head) {\\n            ListNode* slow = head;\\n    \\t\\tListNode* fast = head;\\n    \\t\\twhile (fast && fast->next){\\n    \\t\\t\\tfast = fast->next->next;\\n    \\t\\t\\tslow = slow->next;\\n    \\t\\t\\tif (slow == fast)\\n    \\t\\t\\t\\treturn true;\\n    \\t\\t}\\n    \\t\\treturn false;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool hasCycle(ListNode *head) {\\n            ListNode* slow = head;\\n    \\t\\tListNode* fast = head;\\n    \\t\\twhile (fast && fast->next){\\n    \\t\\t\\tfast = fast->next->next;\\n    \\t\\t\\tslow = slow->next;\\n    \\t\\t\\tif (slow == fast)\\n    \\t\\t\\t\\treturn true;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3999268,
                "title": "2-approaches-slow-fast-pointer-set-method-easy-method",
                "content": "**Pls see the code It is well commented you will be easily understand.**\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# 2 Pointer Approach\\n```C++ []\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n\\t\\n\\t\\t// if head is NULL then return false;\\n        if(head == NULL)\\n            return false;\\n        \\n\\t\\t// making two pointers fast and slow and assignning them to head\\n        ListNode *fast = head;\\n        ListNode *slow = head;\\n        \\n\\t\\t// till fast and fast-> next not reaches NULL\\n\\t\\t// we will increment fast by 2 step and slow by 1 step\\n        while(fast != NULL && fast ->next != NULL)\\n        {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n            \\n\\t\\t\\t\\n\\t\\t\\t// At the point if fast and slow are at same address\\n\\t\\t\\t// this means linked list has a cycle in it.\\n            if(fast == slow)\\n                return true;\\n        }\\n        \\n\\t\\t// if traversal reaches to NULL this means no cycle.\\n        return false;\\n    }\\n};\\n```\\n```Java []\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        // If head is null, return false\\n        if (head == null) {\\n            return false;\\n        }\\n        \\n        // Initialize two pointers, fast and slow, and assign them to head\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        \\n        // Traverse the list until fast and fast.next reach null\\n        // Increment fast by 2 steps and slow by 1 step\\n        while (fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            \\n            // If fast and slow point to the same node, there is a cycle\\n            if (fast == slow) {\\n                return true;\\n            }\\n        }\\n        \\n        // If traversal reaches null, there is no cycle\\n        return false;\\n    }\\n}\\n\\n```\\n```Python3 []\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution:\\n    def hasCycle(self, head):\\n        # If head is None, return False\\n        if head is None:\\n            return False\\n        \\n        # Initialize two pointers, fast and slow, and assign them to head\\n        fast = head\\n        slow = head\\n        \\n        # Traverse the list until fast and fast.next reach None\\n        # Increment fast by 2 steps and slow by 1 step\\n        while fast is not None and fast.next is not None:\\n            fast = fast.next.next\\n            slow = slow.next\\n            \\n            # If fast and slow point to the same node, there is a cycle\\n            if fast == slow:\\n                return True\\n        \\n        # If traversal reaches None, there is no cycle\\n        return False\\n\\n```\\n# Code using Set method\\n```C++ []\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        unordered_set<ListNode*> st;\\n        while(head!=NULL){\\n            if(st.find(head)!=st.end()){\\n                return true;\\n            }\\n            st.insert(head);\\n            head=head->next;\\n        }\\n        return false;\\n    }\\n};\\n```\\n```Java []\\nimport java.util.HashSet;\\n\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        HashSet<ListNode> set = new HashSet<>();\\n        while (head != null) {\\n            if (set.contains(head)) {\\n                return true;\\n            }\\n            set.add(head);\\n            head = head.next;\\n        }\\n        return false;\\n    }\\n}\\n\\n```\\n```Python3 []\\nclass Solution:\\n    def hasCycle(self, head):\\n        visited = set()\\n        while head is not None:\\n            if head in visited:\\n                return True\\n            visited.add(head)\\n            head = head.next\\n        return False\\n\\n```\\n![UPVOTE.png](https://assets.leetcode.com/users/images/5e406e5c-239d-483a-9333-b11d4aa6dd3d_1693794772.6311383.png)\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n\\t\\n\\t\\t// if head is NULL then return false;\\n        if(head == NULL)\\n            return false;\\n        \\n\\t\\t// making two pointers fast and slow and assignning them to head\\n        ListNode *fast = head;\\n        ListNode *slow = head;\\n        \\n\\t\\t// till fast and fast-> next not reaches NULL\\n\\t\\t// we will increment fast by 2 step and slow by 1 step\\n        while(fast != NULL && fast ->next != NULL)\\n        {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n            \\n\\t\\t\\t\\n\\t\\t\\t// At the point if fast and slow are at same address\\n\\t\\t\\t// this means linked list has a cycle in it.\\n            if(fast == slow)\\n                return true;\\n        }\\n        \\n\\t\\t// if traversal reaches to NULL this means no cycle.\\n        return false;\\n    }\\n};\\n```\n```Java []\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        // If head is null, return false\\n        if (head == null) {\\n            return false;\\n        }\\n        \\n        // Initialize two pointers, fast and slow, and assign them to head\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        \\n        // Traverse the list until fast and fast.next reach null\\n        // Increment fast by 2 steps and slow by 1 step\\n        while (fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            \\n            // If fast and slow point to the same node, there is a cycle\\n            if (fast == slow) {\\n                return true;\\n            }\\n        }\\n        \\n        // If traversal reaches null, there is no cycle\\n        return false;\\n    }\\n}\\n\\n```\n```Python3 []\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution:\\n    def hasCycle(self, head):\\n        # If head is None, return False\\n        if head is None:\\n            return False\\n        \\n        # Initialize two pointers, fast and slow, and assign them to head\\n        fast = head\\n        slow = head\\n        \\n        # Traverse the list until fast and fast.next reach None\\n        # Increment fast by 2 steps and slow by 1 step\\n        while fast is not None and fast.next is not None:\\n            fast = fast.next.next\\n            slow = slow.next\\n            \\n            # If fast and slow point to the same node, there is a cycle\\n            if fast == slow:\\n                return True\\n        \\n        # If traversal reaches None, there is no cycle\\n        return False\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        unordered_set<ListNode*> st;\\n        while(head!=NULL){\\n            if(st.find(head)!=st.end()){\\n                return true;\\n            }\\n            st.insert(head);\\n            head=head->next;\\n        }\\n        return false;\\n    }\\n};\\n```\n```Java []\\nimport java.util.HashSet;\\n\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        HashSet<ListNode> set = new HashSet<>();\\n        while (head != null) {\\n            if (set.contains(head)) {\\n                return true;\\n            }\\n            set.add(head);\\n            head = head.next;\\n        }\\n        return false;\\n    }\\n}\\n\\n```\n```Python3 []\\nclass Solution:\\n    def hasCycle(self, head):\\n        visited = set()\\n        while head is not None:\\n            if head in visited:\\n                return True\\n            visited.add(head)\\n            head = head.next\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999041,
                "title": "c-10ms-easy-to-understand-2-pointer",
                "content": "# C++ | 10ms | Easy to Understand | 2 Pointer\\n```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if(head == NULL)\\n            return false;\\n        \\n        ListNode *fast = head;\\n        ListNode *slow = head;\\n    \\n        while(fast != NULL && fast ->next != NULL)\\n        {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n            \\n            if(fast == slow)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if(head == NULL)\\n            return false;\\n        \\n        ListNode *fast = head;\\n        ListNode *slow = head;\\n    \\n        while(fast != NULL && fast ->next != NULL)\\n        {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n            \\n            if(fast == slow)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830758,
                "title": "floyd-s-cycle-detection-algorithm-java-explained-o-n-speed",
                "content": "The Algorithm is used to check if there are any loops in the linked list. It is really simple algorithm in which you take two pointers each pointing to the head node. One is a Fast node which jumps 2 nodes in single loop and the other one is Slow pointer which jumps 1 node at a time. If both of the pointers meet again at a point in the linked list then there is a loop exist and hence return true.\\n\\n***Bonus tip:- If there is no loop in the Linked List then this method can be used to find the middle of the Linked list without knowing the length of the linked list. You just run this same technique until and unless the fast pointer reaches null, and the slow pointer will be pointing to the middle element of the linked list.***\\n\\n```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null){\\n            return false;\\n        }\\n        \\n        ListNode fast = head;\\n        ListNode slow = head;\\n        boolean t = true;\\n        \\n        do{\\n            if(fast == null || fast.next == null){\\n                t = false;\\n                break;\\n            }\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        }while(fast!=slow);\\n        return t;\\n    }\\n}\\n```\\n\\n***Please do upvote if this helped.***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null){\\n            return false;\\n        }\\n        \\n        ListNode fast = head;\\n        ListNode slow = head;\\n        boolean t = true;\\n        \\n        do{\\n            if(fast == null || fast.next == null){\\n                t = false;\\n                break;\\n            }\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        }while(fast!=slow);\\n        return t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1541807,
                "title": "java-easy-solution-hashset-and-two-pointers",
                "content": "### Two pointer approach\\n```java\\npublic boolean hasCycle(ListNode head) {\\n\\tListNode slow = head, fast = head;\\n\\n\\twhile(fast != null && fast.next != null) {\\n\\t\\tfast = fast.next.next;\\n\\t\\tif(slow == fast)\\n\\t\\t\\treturn true;\\n\\t\\tslow = slow.next;\\n\\t}\\n\\treturn false;\\n}\\n```\\n\\n---\\n\\n### HashSet approach\\n```java\\npublic boolean hasCycleBrute(ListNode head) {\\n\\tHashSet<ListNode> set = new HashSet<>();\\n\\n\\tListNode temp = head;\\n\\twhile(temp != null) {\\n\\t\\tif(set.contains(temp)) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tset.add(temp);\\n\\t\\ttemp = temp.next;\\n\\t}\\n\\n\\treturn false;\\n}\\n```\\n\\nIf it helped, do upvote.\\nThanks",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```java\\npublic boolean hasCycle(ListNode head) {\\n\\tListNode slow = head, fast = head;\\n\\n\\twhile(fast != null && fast.next != null) {\\n\\t\\tfast = fast.next.next;\\n\\t\\tif(slow == fast)\\n\\t\\t\\treturn true;\\n\\t\\tslow = slow.next;\\n\\t}\\n\\treturn false;\\n}\\n```\n```java\\npublic boolean hasCycleBrute(ListNode head) {\\n\\tHashSet<ListNode> set = new HashSet<>();\\n\\n\\tListNode temp = head;\\n\\twhile(temp != null) {\\n\\t\\tif(set.contains(temp)) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tset.add(temp);\\n\\t\\ttemp = temp.next;\\n\\t}\\n\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 345472,
                "title": "javascript",
                "content": "```\\n\\n\\nvar hasCycle = function(head) {\\n    \\n    while (head){\\n        if (head.visited) {return true}\\n        head.visited = true\\n        head = head.next\\n    }\\n    \\n    return false \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nvar hasCycle = function(head) {\\n    \\n    while (head){\\n        if (head.visited) {return true}\\n        head.visited = true\\n        head = head.next\\n    }\\n    \\n    return false \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 44525,
                "title": "java-o-1-space-solution-with-fast-and-slow-pointer",
                "content": "    public class Solution {\\n        public boolean hasCycle(ListNode head) {\\n            if(head==null || head.next==null) return false;\\n            ListNode fast=head,slow=head;\\n            while(fast!=null&& fast.next!=null){\\n                fast=fast.next.next;\\n                slow=slow.next;\\n                if(fast==slow) return true;\\n            }\\n            return false;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean hasCycle(ListNode head) {\\n            if(head==null || head.next==null) return false;\\n            ListNode fast=head,slow=head;\\n            while(fast!=null&& fast.next!=null){\\n                fast=fast.next.next;\\n                slow=slow.next;\\n                if(fast==slow) return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1777646,
                "title": "python-simple-o-1-memory-solution",
                "content": "\\n```class Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        count = 0\\n        while head != None and count < 1250:\\n            try:\\n                head = head.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next\\n            except:\\n                return False\\n            count += 1\\n        return count == 1250",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n```class Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        count = 0\\n        while head != None and count < 1250:\\n            try:\\n                head = head.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next\\n            except:\\n                return False\\n            count += 1\\n        return count == 1250",
                "codeTag": "Java"
            },
            {
                "id": 886506,
                "title": "python-intuitive-solution",
                "content": "Runtime: 44 ms, faster than 91.20% of Python3 online submissions for Linked List Cycle.\\nMemory Usage: 16.8 MB, less than 99.00% of Python3 online submissions for Linked List Cycle.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        if head is None:\\n            return False\\n        if head.next is None:\\n            return False\\n        while head.next is not None: \\n            if head.val==None:\\n                return True \\n            head.val=None\\n            head=head.next\\n        return False\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        if head is None:\\n            return False\\n        if head.next is None:\\n            return False\\n        while head.next is not None: \\n            if head.val==None:\\n                return True \\n            head.val=None\\n            head=head.next\\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572350,
                "title": "python-simplest-iterative-solution-with-visual-explanation-beg-to-adv-linked-list",
                "content": "***Found helpful, Do upvote !!***\\n\\n**Approach:**\\nFirstly we are taking two pointers, Fast & Slow.\\n\\n**In each iteraton,**\\nFast pointer runs twice as fast than slow pointer, i.e each time, fast go 2 steps.\\nSlow pointer runs once, i.e slow go 1 steps.\\nThis results in when fast arrives at the end, slow will arrive right in the middle.\\n\\nNow, \\n**Condition - 1**, If the fast reaches the end before they meet, that implies linked list doesn\\'t have a cycle\\n**Condition - 2**, If they become equal at some point, that implies linked list has a cycle\\n![image](https://assets.leetcode.com/users/images/bedeb860-f204-451f-a76d-e42856093f56_1663094002.4657688.png)\\nCondition 1 is reaching to the null = Not a cyclic linked list\\nCondition 2 both pointer meet each other with they will = Is a cyclic linked list\\n**\"In the case of cyclic linked list , they will for sure meet at certain point.\"**\\n\\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        slow = fast = head # firstly we are assigning heads to our pointers slow and fast. \\n        while fast and fast.next:# Checking if head exixt or not as fast is head as we assigned earlier and by \"fast.next\" we are checking if we have some other element in the linked list or not. If we wont have then we are returing slow as it contains the head as well.\\n            slow = slow.next # Slow pointer is getting inceremented one by one & we are assiging immediate next value in it.\\n            fast = fast.next.next  # Fast pointer is getting incremented by 2 & we are assiging second next value to it.\\n            if fast == slow: # as described in the approach above.\\n                return True # If both pointer meet, implies there is a cycle.\\n        return False # If both pointer does meet, implies there is no cycle.\\n```\\n***Found helpful, Do upvote !!***\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        slow = fast = head # firstly we are assigning heads to our pointers slow and fast. \\n        while fast and fast.next:# Checking if head exixt or not as fast is head as we assigned earlier and by \"fast.next\" we are checking if we have some other element in the linked list or not. If we wont have then we are returing slow as it contains the head as well.\\n            slow = slow.next # Slow pointer is getting inceremented one by one & we are assiging immediate next value in it.\\n            fast = fast.next.next  # Fast pointer is getting incremented by 2 & we are assiging second next value to it.\\n            if fast == slow: # as described in the approach above.\\n                return True # If both pointer meet, implies there is a cycle.\\n        return False # If both pointer does meet, implies there is no cycle.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830548,
                "title": "simple-solution",
                "content": "\\n\\n\\n       if(head==NULL)\\n        return false;\\n    struct ListNode *fast=head;\\n    struct ListNode *slow=head;\\n    while(fast!=NULL&&fast->next!=NULL){\\n        fast=fast->next->next;\\n        slow=slow->next;\\n        \\n        if(fast==slow)\\n            return true;\\n        \\n    }\\n    return false;",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "\\n\\n\\n       if(head==NULL)\\n        return false;\\n    struct ListNode *fast=head;\\n    struct ListNode *slow=head;\\n    while(fast!=NULL&&fast->next!=NULL){\\n        fast=fast->next->next;\\n        slow=slow->next;\\n        \\n        if(fast==slow)\\n            return true;\\n        \\n    }\\n    return false;",
                "codeTag": "Unknown"
            },
            {
                "id": 1474599,
                "title": "java-short-100-faster-o-1-space-floyd-s-cycle-detection-algorithm",
                "content": "This is the initial part in Floyd\\'s Cycle Detection Algorithm.\\n\\nWe consider 2 pointers, fast and slow:\\n- slow pointer will move by one node\\n- fast pointer will move by two nodes\\n\\nThink of two cars running in a race track (one fast and second slow). The fast car will get far ahead of slow car at first, but after one/few laps, the fast car will again cross the slow car, as they are running in a circle/loop\\n\\n\\tpublic class Solution {\\n    \\n\\t\\tpublic boolean hasCycle(ListNode head) {\\n\\t\\t\\t\\n\\t\\t\\tListNode slow = head;\\n\\t\\t\\tListNode fast = head;\\n\\t\\t\\t\\n\\t\\t\\t// If fast or slow pointer is null, therefore, linked list has an end\\n\\t\\t\\twhile (fast != null && slow != null) {\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t// If fast.next is null, then we cannot move fast pointer by 2 nodes, hence end\\n\\t\\t\\t\\t// If we check this in while loop\\'s contition, then runtime error when fast == null\\n\\t\\t\\t\\tif (fast.next == null)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tslow = slow.next;\\n\\t\\t\\t\\tfast = fast.next.next;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// If there is a cycle/loop, eventually slow and fast pointers will collide\\n\\t\\t\\t\\tif (slow == fast)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn false;\\n\\t\\t\\t\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n\\t\\tpublic boolean hasCycle(ListNode head) {\\n\\t\\t\\t\\n\\t\\t\\tListNode slow = head;\\n\\t\\t\\tListNode fast = head;\\n\\t\\t\\t\\n\\t\\t\\t// If fast or slow pointer is null, therefore, linked list has an end\\n\\t\\t\\twhile (fast != null && slow != null) {\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t// If fast.next is null, then we cannot move fast pointer by 2 nodes, hence end\\n\\t\\t\\t\\t// If we check this in while loop\\'s contition, then runtime error when fast == null\\n\\t\\t\\t\\tif (fast.next == null)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tslow = slow.next;\\n\\t\\t\\t\\tfast = fast.next.next;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// If there is a cycle/loop, eventually slow and fast pointers will collide\\n\\t\\t\\t\\tif (slow == fast)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1450084,
                "title": "python-3-solutions-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Using HashSet**\\n```\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        seen = set()\\n        while head != None:\\n            if head in seen: return True\\n            seen.add(head)\\n            head = head.next\\n        return False\\n```\\n**Complexity**\\n- Time: `O(N)`, where `N <= 10^4` is number of nodes in the Linked List.\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Modify Linked List to point to visitedNode**\\n```\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        visitedNode = ListNode(0)\\n        \\n        while head != None:\\n            if head.next == visitedNode:\\n                return True\\n            head.next, head = visitedNode, head.next\\n        return False\\n```\\n**Complexity**\\n- Time: `O(N)`, where `N <= 10^4` is number of nodes in the Linked List.\\n- Space: `O(1)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3: Floyd\\'s Cycle Finding Algorithm**\\n```python\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        slow = head\\n        fast = head\\n        while fast != None and fast.next != None:\\n            slow = slow.next\\n            fast = fast.next.next\\n            if slow == fast: return True\\n        return False\\n```\\n**Complexity**\\n- Time: `O(N)`, where `N <= 10^4` is number of nodes in the Linked List.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        seen = set()\\n        while head != None:\\n            if head in seen: return True\\n            seen.add(head)\\n            head = head.next\\n        return False\\n```\n```\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        visitedNode = ListNode(0)\\n        \\n        while head != None:\\n            if head.next == visitedNode:\\n                return True\\n            head.next, head = visitedNode, head.next\\n        return False\\n```\n```python\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        slow = head\\n        fast = head\\n        while fast != None and fast.next != None:\\n            slow = slow.next\\n            fast = fast.next.next\\n            if slow == fast: return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1004795,
                "title": "python-o-n-easy-clear-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef hasCycle(self, head: ListNode) -> bool:\\n\\t\\t\\twhile head and head.next:\\n\\t\\t\\t\\tif str(head.val) == \"T\":\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\thead.val = \"T\"\\n\\t\\t\\t\\thead = head.next\\n\\t\\t\\treturn False",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef hasCycle(self, head: ListNode) -> bool:\\n\\t\\t\\twhile head and head.next:\\n\\t\\t\\t\\tif str(head.val) == \"T\":\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\thead.val = \"T\"\\n\\t\\t\\t\\thead = head.next\\n\\t\\t\\treturn False",
                "codeTag": "Java"
            },
            {
                "id": 835202,
                "title": "c-implementation",
                "content": "```\\nbool hasCycle(struct ListNode *head) {\\n    struct ListNode * slow=head,*fast=NULL;\\n    \\n    if(!head || !(head->next))\\n        return false;\\n    \\n    fast=head->next;\\n    \\n    while(slow!=fast)\\n    {\\n        if(fast==NULL)\\n        {\\n            return false;\\n        }\\n        slow=slow->next;\\n        if(fast->next && fast->next->next)\\n            fast=fast->next->next;\\n        else\\n            fast = fast->next;\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Two Pointers",
                    "Iterator"
                ],
                "code": "```\\nbool hasCycle(struct ListNode *head) {\\n    struct ListNode * slow=head,*fast=NULL;\\n    \\n    if(!head || !(head->next))\\n        return false;\\n    \\n    fast=head->next;\\n    \\n    while(slow!=fast)\\n    {\\n        if(fast==NULL)\\n        {\\n            return false;\\n        }\\n        slow=slow->next;\\n        if(fast->next && fast->next->next)\\n            fast=fast->next->next;\\n        else\\n            fast = fast->next;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 392464,
                "title": "solved-video-editorial-for-linked-list-cycle-leetcode",
                "content": "Hi all,\\n\\nClick on the below link for the solved video editorial for finding the  Linked List Cycle problem.\\nAlso, i will be adding more problems to my collection. Please follow and feedback is always appreciated.\\n\\nLink - [Click Here](https://www.youtube.com/watch?v=0DqxhTiVPGM&feature=youtu.be)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "Hi all,\\n\\nClick on the below link for the solved video editorial for finding the  Linked List Cycle problem.\\nAlso, i will be adding more problems to my collection. Please follow and feedback is always appreciated.\\n\\nLink - [Click Here](https://www.youtube.com/watch?v=0DqxhTiVPGM&feature=youtu.be)",
                "codeTag": "Unknown"
            },
            {
                "id": 44649,
                "title": "share-my-c-solution-easy-to-understand",
                "content": "    /**\\n     * Definition for singly-linked list.\\n     * struct ListNode {\\n     *     int val;\\n     *     ListNode *next;\\n     *     ListNode(int x) : val(x), next(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        bool hasCycle(ListNode *head) {\\n            if (head == NULL || head->next == NULL) return false;\\n            \\n            ListNode *fast = head, *slow = head;\\n            \\n            while (fast != NULL && fast->next != NULL)\\n            {\\n                fast = fast->next->next;\\n                slow = slow->next;\\n                \\n                if (fast == slow)\\n                    return true;\\n            }\\n            \\n            return false;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool hasCycle(ListNode *head) {\\n            if (head == NULL || head->next == NULL) return false;\\n            \\n            ListNode *fast = head, *slow = head;\\n            \\n            while (fast != NULL && fast->next != NULL)\\n            {\\n                fast = fast->next->next;\\n                slow = slow->next;\\n                \\n                if (fast == slow)\\n                    return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 44733,
                "title": "ac-solution-with-o-1-space-and-o-n-time-in-c",
                "content": "    class Solution {\\n    public:\\n    bool hasCycle(ListNode *head) {\\n        if(!head||!head->next)\\n            return false;\\n        ListNode* i = head; //slower pointer\\n        ListNode* j = i->next; //faster pointer\\n        while(i&&j&&j->next)\\n        {\\n            i = i->next;\\n            j = j->next->next;\\n            if(i==j)\\n                return true;\\n        }\\n        return false;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    bool hasCycle(ListNode *head) {\\n        if(!head||!head->next)\\n            return false;\\n        ListNode* i = head; //slower pointer\\n        ListNode* j = i->next; //faster pointer\\n        while(i&&j&&j->next)\\n        {\\n            i = i->next;\\n            j = j->next->next;\\n            if(i==j)\\n                return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3999262,
                "title": "python3-solution",
                "content": "\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self,head:Optional[ListNode])->bool:\\n        slow=head\\n        fast=head\\n        while slow and fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n            if slow==fast:\\n                return True\\n\\n        return False                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self,head:Optional[ListNode])->bool:\\n        slow=head\\n        fast=head\\n        while slow and fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n            if slow==fast:\\n                return True\\n\\n        return False                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999151,
                "title": "c-o-n-slow-fast-pointers",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach :**\\n* Slow pointer moves one step at a time and Fast pointer moves two steps at a time.\\n* Taking analogy from 2 people on a race track, if track is circular, they both will certainly meet at a point which is not the starting position as person sprinting fast will cover the lap 1st and eventually cross the slow person again on subsequent laps.\\n\\n```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        \\n        if(!head) return false;\\n        \\n        ListNode *slow, *fast;\\n        slow = fast = head;\\n        \\n        do{\\n            slow=slow->next;\\n            fast=fast->next;\\n            if(fast) fast=fast->next;\\n        }while(fast!=NULL && fast!=slow);\\n        \\n        return (fast!=NULL && fast == slow);\\n    }\\n};\\n```\\n\\n**Do upvote if it helps :)**",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        \\n        if(!head) return false;\\n        \\n        ListNode *slow, *fast;\\n        slow = fast = head;\\n        \\n        do{\\n            slow=slow->next;\\n            fast=fast->next;\\n            if(fast) fast=fast->next;\\n        }while(fast!=NULL && fast!=slow);\\n        \\n        return (fast!=NULL && fast == slow);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276905,
                "title": "python3-easy-detailed-2-methods",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Using two pointer**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- as per floyd\\'s cycle detection algorithen, we keep slow and fast pointers.\\n- increment slow by 1 and fast by 2.\\n- whenever they meet we found cycle in list.\\n- return True.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        slow = None\\n        fast = head\\n        while fast and fast.next:\\n            if slow == fast and slow:\\n                return slow\\n            slow = slow.next if slow else fast.next\\n            fast = fast.next.next\\n```\\n---\\n# Intuition \\n**Using hashmap**\\n# Approach\\n- keep hashmap of nodes.\\n- if we encounter node that is not in hashmap then add it.\\n- if it\\'s already in map then we found cycle.\\n- return true\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        hashmap = {}\\n        while head:\\n            if head in hashmap.keys():\\n                return head\\n            else:\\n                hashmap[head] = 1\\n            head = head.next\\n```\\n # Please like and comment below :-)",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        slow = None\\n        fast = head\\n        while fast and fast.next:\\n            if slow == fast and slow:\\n                return slow\\n            slow = slow.next if slow else fast.next\\n            fast = fast.next.next\\n```\n```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        hashmap = {}\\n        while head:\\n            if head in hashmap.keys():\\n                return head\\n            else:\\n                hashmap[head] = 1\\n            head = head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765240,
                "title": "python-fast",
                "content": "```\\ndef hasCycle(self, head):\\n    try:\\n        slow = head\\n        fast = head.next\\n        while slow is not fast:\\n            slow = slow.next\\n            fast = fast.next.next\\n        return True\\n    except:\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\ndef hasCycle(self, head):\\n    try:\\n        slow = head\\n        fast = head.next\\n        while slow is not fast:\\n            slow = slow.next\\n            fast = fast.next.next\\n        return True\\n    except:\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2048722,
                "title": "javascript-maximum-efficiency-o-n-time-o-1-space",
                "content": "This solution iterates through every node, setting the value within the node to null. Since we know the values are integers by default, if we encounter one of these null values, we know that we have cycled back to a value we have already iterated over.\\n```\\nconst hasCycle = (head) => {\\n  while (head) {\\n    if (!head.val) return true;\\n\\n    head.val = null;\\n    head = head.next;\\n  }\\n\\n  return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst hasCycle = (head) => {\\n  while (head) {\\n    if (!head.val) return true;\\n\\n    head.val = null;\\n    head = head.next;\\n  }\\n\\n  return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1830651,
                "title": "python-simple-o-n-with-comments",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        hsh = {} # hsh is not required. thanks for pointing it in comments\\n        \\n        while head:\\n            #empty the value of every node\\n            if head.val:\\n                head.val = None\\n            else:\\n                #if we come across empty node during traversal, it is a cycle\\n                return True\\n            head = head.next\\n        #if we reach the end, we can return False as no cycle formed\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        hsh = {} # hsh is not required. thanks for pointing it in comments\\n        \\n        while head:\\n            #empty the value of every node\\n            if head.val:\\n                head.val = None\\n            else:\\n                #if we come across empty node during traversal, it is a cycle\\n                return True\\n            head = head.next\\n        #if we reach the end, we can return False as no cycle formed\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1829692,
                "title": "java-3-approaches",
                "content": "**Using slow and fast pointer**\\nTC - O(N)\\nSC - O(1)\\n```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if (head == null) {\\n            return false;\\n        }\\n        ListNode slow = head, fast = head;\\n        \\n        while (fast.next != null && fast.next.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            \\n            if (fast == slow) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n**Using Java Set.**\\nTC - O(N)\\nSC - O(N)\\n```\\n\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if (head == null) {\\n            return false;\\n        }\\n        \\n        Set<ListNode> set = new HashSet<>();\\n        \\n        while (head != null) {\\n            if (set.contains(head)) {\\n                return true;\\n            }\\n            \\n            set.add(head);\\n            head = head.next;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n**Using flagging mechanism**\\nTC - O(N)\\nSC - O(1)\\n\\n-10 ^ 5 <= node.val <=  10^5 \\nWe can use some other value out of this range so we can mark the node as visited. When the node comes with the marked value then we can say there is a cycke.\\n\\n```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if (head == null) {\\n            return false;\\n        }\\n        \\n        while (head != null) {\\n            if (head.val == Integer.MAX_VALUE) { // already visited\\n                return true;\\n            }\\n\\t\\t\\t//flagging the node\\n            head.val = Integer.MAX_VALUE;\\n            head = head.next;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if (head == null) {\\n            return false;\\n        }\\n        ListNode slow = head, fast = head;\\n        \\n        while (fast.next != null && fast.next.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            \\n            if (fast == slow) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\n```\\n\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if (head == null) {\\n            return false;\\n        }\\n        \\n        Set<ListNode> set = new HashSet<>();\\n        \\n        while (head != null) {\\n            if (set.contains(head)) {\\n                return true;\\n            }\\n            \\n            set.add(head);\\n            head = head.next;\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if (head == null) {\\n            return false;\\n        }\\n        \\n        while (head != null) {\\n            if (head.val == Integer.MAX_VALUE) { // already visited\\n                return true;\\n            }\\n\\t\\t\\t//flagging the node\\n            head.val = Integer.MAX_VALUE;\\n            head = head.next;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787725,
                "title": "go-multiple-solutions-clean-code-0ms-100",
                "content": "Hello Gophers!\\n\\n### Solution 1: HashSet (0ms 100%)\\n\\nWe simply iterate over all nodes and record them until:\\n- we are on a node  that we already checked (cycle) **or**\\n- until the current node is nil (not cycle)\\n\\nTime: `O(n)`\\nSpace: `O(n)`\\n\\n```go\\n// Time: O(n)\\n// Space: O(n)\\nfunc hasCycle(head *ListNode) bool {\\n    // Space: O(n)\\n    current, set := head, NewSet()\\n    \\n    // Time: O(n)\\n    for current != nil {\\n        if set.Has(current) {\\n            return true\\n        }\\n        set.Add(current)\\n        current = current.Next\\n    }\\n    return false\\n}\\n\\ntype Set struct {\\n    items map[*ListNode]struct{}\\n}\\n\\nfunc NewSet() *Set{\\n    return &Set{\\n        items: make(map[*ListNode]struct{}),\\n    }\\n}\\n\\nfunc (s *Set) Has(n *ListNode) bool {\\n    _, exists := s.items[n]\\n    return exists\\n}\\n\\nfunc (s *Set) Add(n *ListNode) {\\n    s.items[n] = struct{}{}\\n}\\n```\\n\\n### Solution 2: Fast & Slow Pointers (0ms 100%)\\n\\nThis is called the `Fast & Slow Pointers Algorithm`, the `Hair & Tortoise Algorithm` and the `Floyd\\'s Cycle Finding Algorithm`.  \\nIt\\'s like the `Two Pointers` algorithm, but one of the pointers is going faster than the other one.  \\nIt is useful when dealing with cyclic linked list: the \"fast pointer\" will reach the \"slow pointer\" if there is a cycle!\\n\\nTime: `O(n)`\\nSpace: `O(1)`\\n\\n```go\\n// Time: O(n)\\n// Space: O(1)\\nfunc hasCycle(head *ListNode) bool {\\n    if head == nil {\\n        return false\\n    }\\n\\t\\n\\t// Time: O(n)\\n    for slow, fast := head, head; fast != nil && fast.Next != nil; {\\n        fast, slow = fast.Next.Next, slow.Next\\n        if fast == slow { return true }\\n    }\\n    return false\\n}\\n```\\n\\n### Solution 3: Mixt of solution 1 and 2 (0ms 100%)\\n\\nIf we want to make it faster and we don\\'t care about the `O(1)` space complexity, we can merge both solution, maybe the \"fast pointer\" will cycle on his path before reaching the slow pointer:\\n\\nTime: `O(n)`\\nSpace: `O(n)`\\n\\n```go\\n// Time: O(n)\\n// Space: O(n)\\nfunc hasCycle(head *ListNode) bool {\\n    if head == nil {\\n        return false\\n    }\\n\\t\\n\\t// Space: O(n)\\n    set := NewSet()\\n\\t\\n\\t// Time: O(n)\\n    for slow, fast := head, head; fast != nil && fast.Next != nil; {\\n        if set.Has(fast.Next) || set.Has(fast.Next.Next) {\\n            return true\\n        }\\n        set.Add(fast.Next, fast.Next.Next)\\n    \\n        fast, slow = fast.Next.Next, slow.Next\\n        if fast == slow {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\ntype Set struct {\\n    items map[*ListNode]struct{}\\n}\\n\\nfunc NewSet() *Set{\\n    return &Set{\\n        items: make(map[*ListNode]struct{}),\\n    }\\n}\\n\\nfunc (s *Set) Has(n *ListNode) bool {\\n    _, exists := s.items[n]\\n    return exists\\n}\\n\\nfunc (s *Set) Add(nodes ...*ListNode) {\\n    for _, node := range nodes {\\n        s.items[node] = struct{}{}\\n    }\\n}\\n```\\n\\nHere are my solutions to other problems with this same algorithm pattern (Fast and Slow pointer):\\n\\n- [Happy Number](https://leetcode.com/problems/happy-number/discuss/1790169/go-multiple-solutions-clean-code-0ms-100) \\n- [Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/discuss/1787725/go-multiple-solutions-clean-code-0ms-100) (this problem)\\n- [Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/discuss/1790316/go-multiple-solutions-clean-and-commented-code-0ms-100)\\n- [Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/discuss/1801437/go-multiple-solutions-clean-code-with-comments)\\n- [Delete the Middle Node of a Linked List](https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/discuss/1804509/Go-Fast-and-Slow-pointer-Clean-code-(220ms-100))\\n- [Reorder List](https://leetcode.com/problems/reorder-list/discuss/1804821/Go-Clean-and-commented-code-(4ms-100)) \\n\\nI hope it helped! :)",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\n// Time: O(n)\\n// Space: O(n)\\nfunc hasCycle(head *ListNode) bool {\\n    // Space: O(n)\\n    current, set := head, NewSet()\\n    \\n    // Time: O(n)\\n    for current != nil {\\n        if set.Has(current) {\\n            return true\\n        }\\n        set.Add(current)\\n        current = current.Next\\n    }\\n    return false\\n}\\n\\ntype Set struct {\\n    items map[*ListNode]struct{}\\n}\\n\\nfunc NewSet() *Set{\\n    return &Set{\\n        items: make(map[*ListNode]struct{}),\\n    }\\n}\\n\\nfunc (s *Set) Has(n *ListNode) bool {\\n    _, exists := s.items[n]\\n    return exists\\n}\\n\\nfunc (s *Set) Add(n *ListNode) {\\n    s.items[n] = struct{}{}\\n}\\n```\n```go\\n// Time: O(n)\\n// Space: O(1)\\nfunc hasCycle(head *ListNode) bool {\\n    if head == nil {\\n        return false\\n    }\\n\\t\\n\\t// Time: O(n)\\n    for slow, fast := head, head; fast != nil && fast.Next != nil; {\\n        fast, slow = fast.Next.Next, slow.Next\\n        if fast == slow { return true }\\n    }\\n    return false\\n}\\n```\n```go\\n// Time: O(n)\\n// Space: O(n)\\nfunc hasCycle(head *ListNode) bool {\\n    if head == nil {\\n        return false\\n    }\\n\\t\\n\\t// Space: O(n)\\n    set := NewSet()\\n\\t\\n\\t// Time: O(n)\\n    for slow, fast := head, head; fast != nil && fast.Next != nil; {\\n        if set.Has(fast.Next) || set.Has(fast.Next.Next) {\\n            return true\\n        }\\n        set.Add(fast.Next, fast.Next.Next)\\n    \\n        fast, slow = fast.Next.Next, slow.Next\\n        if fast == slow {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\ntype Set struct {\\n    items map[*ListNode]struct{}\\n}\\n\\nfunc NewSet() *Set{\\n    return &Set{\\n        items: make(map[*ListNode]struct{}),\\n    }\\n}\\n\\nfunc (s *Set) Has(n *ListNode) bool {\\n    _, exists := s.items[n]\\n    return exists\\n}\\n\\nfunc (s *Set) Add(nodes ...*ListNode) {\\n    for _, node := range nodes {\\n        s.items[node] = struct{}{}\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1601414,
                "title": "simple-python-solution-with-explaination",
                "content": "To check the **presence of cycle in LinkedList**. we can using the **slow and fast pointer approach.**\\n1. We are traversing the whole LinkedList using the slow pointer. which take **1 step** at a time **(slow.next)** and fast poiner which take** 2 steps (fast.next.next)** every time.\\n2. If the slow pointer and fast pointer **collide with each other** then there is presence of cycle in LinkedList. \\n\\n\\n```\\ndef hasCycle(self, head: Optional[ListNode]) -> bool:\\n        \\n        slow = head\\n        fast = head\\n        \\n        while fast!= None and fast.next!= None:\\n            slow = slow.next\\n            fast = fast.next.next \\n            if slow==fast:\\n                return True\\n            \\n        return False\\n```\\n\\nIf you find this post helpful then do **upvote!** It give me motivation to write more.\\nThanks!",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\ndef hasCycle(self, head: Optional[ListNode]) -> bool:\\n        \\n        slow = head\\n        fast = head\\n        \\n        while fast!= None and fast.next!= None:\\n            slow = slow.next\\n            fast = fast.next.next \\n            if slow==fast:\\n                return True\\n            \\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1597757,
                "title": "o-1-space-solution-easy-to-understand",
                "content": "We know that minimum value that a node value can take is -10^5. \\nSo I looped through all elements and change their values to negative infinity. \\nAnd when the pointer come back to a node that were previously visited then its value will be negative infinity.\\nIf there is no cycle the while loop will end and the program will return false;\\n```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        \\n        ListNode curr = head;\\n        \\n        while(curr!=null){\\n            if(curr.val==Integer.MIN_VALUE)\\n                return true;\\n            else{\\n                curr.val=Integer.MIN_VALUE;\\n                curr = curr.next;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n\\nIf you find it Informitive please don\\'t forget to upvote so others can benefit.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        \\n        ListNode curr = head;\\n        \\n        while(curr!=null){\\n            if(curr.val==Integer.MIN_VALUE)\\n                return true;\\n            else{\\n                curr.val=Integer.MIN_VALUE;\\n                curr = curr.next;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1047646,
                "title": "c-c-cool-solution",
                "content": "```\\nbool hasCycle(struct ListNode *head) \\n{\\n    if (!head || !head->next)\\n        return false;\\n    \\n    struct ListNode *slow = head->next, *fast = head->next->next;\\n    \\n    while (fast && fast->next)\\n    {\\n        if (slow == fast)\\n            return true;\\n        \\n        slow = slow->next;\\n        fast = fast->next->next;\\n    }\\n    \\n    return false;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool hasCycle(struct ListNode *head) \\n{\\n    if (!head || !head->next)\\n        return false;\\n    \\n    struct ListNode *slow = head->next, *fast = head->next->next;\\n    \\n    while (fast && fast->next)\\n    {\\n        if (slow == fast)\\n            return true;\\n        \\n        slow = slow->next;\\n        fast = fast->next->next;\\n    }\\n    \\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 499021,
                "title": "intuitive-javascript-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n\\n/**\\n * @param {ListNode} head\\n * @return {boolean}\\n */\\nvar hasCycle = function(head) {\\n    const set = new Set();\\n    let node = head;\\n    // return true when node has been visited and saved in the set\\n    while (node !== null) {\\n        if (set.has(node)) {\\n            return true;\\n        }\\n        set.add(node);\\n        node = node.next\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n\\n/**\\n * @param {ListNode} head\\n * @return {boolean}\\n */\\nvar hasCycle = function(head) {\\n    const set = new Set();\\n    let node = head;\\n    // return true when node has been visited and saved in the set\\n    while (node !== null) {\\n        if (set.has(node)) {\\n            return true;\\n        }\\n        set.add(node);\\n        node = node.next\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 289830,
                "title": "c-slow-fast",
                "content": "```\\npublic class Solution {\\n    public bool HasCycle(ListNode head) {\\n        if (head == null) return false;\\n        \\n        var slow = head;\\n        var fast = head.next;\\n\\n        while (slow != fast) {\\n            if (fast == null || fast.next == null) {\\n                return false;\\n            }\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool HasCycle(ListNode head) {\\n        if (head == null) return false;\\n        \\n        var slow = head;\\n        var fast = head.next;\\n\\n        while (slow != fast) {\\n            if (fast == null || fast.next == null) {\\n                return false;\\n            }\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44725,
                "title": "very-clear-python-solution-where-you-don-t-need-to-worry-about-the-corner-case",
                "content": "    class Solution:\\n        # @param head, a ListNode\\n        # @return a boolean\\n        def hasCycle(self, head):\\n            try:\\n                fast = head.next.next\\n                slow = head.next\\n                \\n                while fast != slow:\\n                    fast = fast.next.next\\n                    slow = slow.next\\n                \\n                return True\\n            except:\\n                return False",
                "solutionTags": [],
                "code": "    class Solution:\\n        # @param head, a ListNode\\n        # @return a boolean\\n        def hasCycle(self, head):\\n            try:\\n                fast = head.next.next\\n                slow = head.next\\n                \\n                while fast != slow:\\n                    fast = fast.next.next\\n                    slow = slow.next\\n                \\n                return True\\n            except:\\n                return False",
                "codeTag": "Java"
            },
            {
                "id": 3403199,
                "title": "python-easy-dictionary",
                "content": "# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        nodes = {}\\n    \\n        while (head):\\n            if head.next not in nodes:\\n                nodes[head.next] = 1\\n            else:\\n                return True\\n            head = head.next\\n\\n        return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        nodes = {}\\n    \\n        while (head):\\n            if head.next not in nodes:\\n                nodes[head.next] = 1\\n            else:\\n                return True\\n            head = head.next\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276274,
                "title": "slow-fast-pointer-logic-python3",
                "content": "\\n# 1. Slow and Fast Concept at same node\\n```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        slow,fast=head,head\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n            if slow==fast:\\n                return True\\n        return False\\n#   please upvote me it would encourage me alot\\n\\n```\\n# 2. Slow and fast at different Node\\n```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        if not head:\\n            return False\\n        slow,fast=head,head.next\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n            if slow==fast:\\n                return True\\n        return False\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        slow,fast=head,head\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n            if slow==fast:\\n                return True\\n        return False\\n#   please upvote me it would encourage me alot\\n\\n```\n```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        if not head:\\n            return False\\n        slow,fast=head,head.next\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n            if slow==fast:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181800,
                "title": "tc-o-n-sc-o-1-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n    \\n    if(head==NULL || head->next==NULL)\\n    return false;\\n\\n    ListNode* slow=head;\\n    ListNode* fast=head;\\n\\n    while(slow!=NULL && fast!=NULL){\\n        fast=fast->next;\\n        if(fast!=NULL){\\n            fast=fast->next;\\n        }\\n        slow=slow->next;\\n\\n        if(slow==fast){\\n            // cout<<\"cycle present on element \"<<slow->data<<endl;\\n            return true; \\n        }\\n    }\\n    return false; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n    \\n    if(head==NULL || head->next==NULL)\\n    return false;\\n\\n    ListNode* slow=head;\\n    ListNode* fast=head;\\n\\n    while(slow!=NULL && fast!=NULL){\\n        fast=fast->next;\\n        if(fast!=NULL){\\n            fast=fast->next;\\n        }\\n        slow=slow->next;\\n\\n        if(slow==fast){\\n            // cout<<\"cycle present on element \"<<slow->data<<endl;\\n            return true; \\n        }\\n    }\\n    return false; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2791622,
                "title": "java-fast-slow-pointer-method",
                "content": "# Intuition\\nThumb-Rule: If need to detect a cycle anywhere first use Fast-Slow Pointer method.\\n\\n# Approach\\nUse the Two pointer Approach. Fast pointer will move ahead by two nodes and slow pointer willl move one node. If they meet at certain point, then it confirms the availability of the cycle.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n\\n        while(fast != null && fast.next != null){\\n            fast = fast.next.next;\\n            slow = slow.next;\\n\\n            if(fast == slow){\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n\\n        while(fast != null && fast.next != null){\\n            fast = fast.next.next;\\n            slow = slow.next;\\n\\n            if(fast == slow){\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2501273,
                "title": "java-solution-using-hashset-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/65d7f87d-21a6-4666-93e6-6814ffec3b24_1661795327.8672297.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/65d7f87d-21a6-4666-93e6-6814ffec3b24_1661795327.8672297.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1857668,
                "title": "2-python-solutions",
                "content": "-----------------\\n### ***Two pointers Solution***\\n```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        slow=fast=head\\n        while fast and fast.next:\\n            fast=fast.next.next\\n            slow=slow.next\\n            if slow==fast: return True\\n        return False\\n```\\n-----------------\\n### ***Dictionary Solution***\\n-------------------\\n```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        D={}\\n        while head:\\n            if head in D: return True\\n            D[head]=True\\n            head=head.next\\n        return False\\n```\\n-----------------\\n### ***Set Solution***\\n-------------------\\n```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        S=set()\\n        while head:\\n            if head in S: return True\\n            S.add(head)\\n            head=head.next\\n        return False\\n```\\n***----- Taha Choura -----***\\n*taha.choura@outlook.com*",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        slow=fast=head\\n        while fast and fast.next:\\n            fast=fast.next.next\\n            slow=slow.next\\n            if slow==fast: return True\\n        return False\\n```\n```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        D={}\\n        while head:\\n            if head in D: return True\\n            D[head]=True\\n            head=head.next\\n        return False\\n```\n```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        S=set()\\n        while head:\\n            if head in S: return True\\n            S.add(head)\\n            head=head.next\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1531932,
                "title": "c-solution-o-1-auxiliary-space-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if(head == NULL){\\n            return NULL;\\n        }\\n        \\n        ListNode *slow = head;\\n        ListNode *fast = head->next;\\n        \\n        while(fast!=NULL && fast->next!=NULL){\\n            if(slow == fast)\\n                return true;\\n            \\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n\\n**Consider UPVOTING this content if you find it useful.**\\n\\nThank you.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if(head == NULL){\\n            return NULL;\\n        }\\n        \\n        ListNode *slow = head;\\n        ListNode *fast = head->next;\\n        \\n        while(fast!=NULL && fast->next!=NULL){\\n            if(slow == fast)\\n                return true;\\n            \\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526451,
                "title": "go",
                "content": "two pointers\\n```\\nfunc hasCycle(head *ListNode) bool {\\n    if head == nil || head.Next == nil {\\n        return false\\n    }\\n    p1, p2 := head, head.Next\\n    for p1 != p2 {\\n        if p2 == nil || p2.Next == nil {\\n            return false\\n        }\\n        p1 = p1.Next\\n        p2 = p2.Next.Next\\n    }\\n    return true\\n}\\n```\\nhash\\n```\\nfunc hasCycle(head *ListNode) bool {\\n    dict := make(map[*ListNode]struct{})\\n    for head != nil {\\n        if _, ok := dict[head]; ok {\\n            return true\\n        } \\n        dict[head] = struct{}{}\\n        head = head.Next\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc hasCycle(head *ListNode) bool {\\n    if head == nil || head.Next == nil {\\n        return false\\n    }\\n    p1, p2 := head, head.Next\\n    for p1 != p2 {\\n        if p2 == nil || p2.Next == nil {\\n            return false\\n        }\\n        p1 = p1.Next\\n        p2 = p2.Next.Next\\n    }\\n    return true\\n}\\n```\n```\\nfunc hasCycle(head *ListNode) bool {\\n    dict := make(map[*ListNode]struct{})\\n    for head != nil {\\n        if _, ok := dict[head]; ok {\\n            return true\\n        } \\n        dict[head] = struct{}{}\\n        head = head.Next\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 44535,
                "title": "python-solution",
                "content": "Python O(n) Solution\\n```Python\\nclass Solution(object):\\n    def hasCycle(self, head):\\n        fast = slow = head\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n            if slow == fast:\\n                return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution(object):\\n    def hasCycle(self, head):\\n        fast = slow = head\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n            if slow == fast:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44664,
                "title": "c-solutions-set-and-two-pointer",
                "content": "    // O(n) space\\n    bool hasCycle1(ListNode *head) {\\n        unordered_set<ListNode *> mySet;\\n        while (head) {\\n            if (mySet.find(head) != mySet.end())\\n                return true;\\n            mySet.insert(head);\\n            head = head->next;\\n        }\\n        return false;\\n    }\\n    \\n    // O(1) space\\n    bool hasCycle(ListNode *head) {\\n        ListNode *fast, *slow;\\n        fast = slow = head;\\n        while (fast && fast->next) {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n            if (slow == fast)\\n                return true;\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Ordered Set"
                ],
                "code": "    // O(n) space\\n    bool hasCycle1(ListNode *head) {\\n        unordered_set<ListNode *> mySet;\\n        while (head) {\\n            if (mySet.find(head) != mySet.end())\\n                return true;\\n            mySet.insert(head);\\n            head = head->next;\\n        }\\n        return false;\\n    }\\n    \\n    // O(1) space\\n    bool hasCycle(ListNode *head) {\\n        ListNode *fast, *slow;\\n        fast = slow = head;\\n        while (fast && fast->next) {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n            if (slow == fast)\\n                return true;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3999313,
                "title": "simple-c-single-pointer-no-hash-map-o-n-space-o-1",
                "content": "# Intuition\\nThe constraints for node->val are from -10^5 to 10^5. Simply change the value out of this range so that we will know if we visited that node or not.\\n\\n# Approach\\nFirst we iterate the list untill we get null. First we check if `val == -100001`. `-100001` (say `bignum`) is just a number outside the constraints bounds. If the node val is equal to bignum then that means the node is already visites so we `return true` because cycle is there. \\nElse we change the value to bignum and go to the next node. After few iteration if any node val == bignum that means we already visited that node so cycle is present. \\nIf we get out of that loop that means we didnot visit the same node twice, so no cycle is present so we `return false`. \\n\\n`bignum` can be any number outside the range `-10^5 to 10^5`\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {     \\n        while(head)\\n        {\\n            if(head->val == -100001) return true;\\n            head->val = -100001;\\n            head = head->next;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {     \\n        while(head)\\n        {\\n            if(head->val == -100001) return true;\\n            head->val = -100001;\\n            head = head->next;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443184,
                "title": "c-easy-solution-3-approaches",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool HasCycle(ListNode head) {\\n        \\n        //-------------------Approach 1(HASHSET)-------------------\\n\\n        HashSet<ListNode> visited = new HashSet<ListNode>();\\n\\n        while(head != null){\\n            if(visited.Contains(head))  return true;\\n                \\n             visited.Add(head);\\n             head = head.next;\\n        }\\n        return false;\\n\\n\\n\\n        //-------------------Approach 2(TWO POINTER)---------------------\\n\\n        if(head == null) return false;\\n            \\n\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while(fast != null && fast.next != null){\\n\\n            slow = slow.next;\\n            fast = fast.next.next;\\n\\n            if(slow == fast)  return true;    \\n                  \\n        }\\n        return false;\\n\\n\\n\\n        //-----------Approach 3-------------------\\n\\n        if(head == null) return false;\\n\\n        while(head != null){\\n            if(head.val == Int32.MaxValue) return true;\\n                \\n            head.val = Int32.MaxValue;\\n            head = head.next;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool HasCycle(ListNode head) {\\n        \\n        //-------------------Approach 1(HASHSET)-------------------\\n\\n        HashSet<ListNode> visited = new HashSet<ListNode>();\\n\\n        while(head != null){\\n            if(visited.Contains(head))  return true;\\n                \\n             visited.Add(head);\\n             head = head.next;\\n        }\\n        return false;\\n\\n\\n\\n        //-------------------Approach 2(TWO POINTER)---------------------\\n\\n        if(head == null) return false;\\n            \\n\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while(fast != null && fast.next != null){\\n\\n            slow = slow.next;\\n            fast = fast.next.next;\\n\\n            if(slow == fast)  return true;    \\n                  \\n        }\\n        return false;\\n\\n\\n\\n        //-----------Approach 3-------------------\\n\\n        if(head == null) return false;\\n\\n        while(head != null){\\n            if(head.val == Int32.MaxValue) return true;\\n                \\n            head.val = Int32.MaxValue;\\n            head = head.next;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205798,
                "title": "141-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this algorithm is O(n), where n is the number of nodes in the linked list.\\n\\n- Space complexity:\\nSpace complexity is O(1), since we only need two pointers to traverse the linked list.\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n  def hasCycle(self, head: ListNode) -> bool:\\n    # Initialize two pointers to point to the head of the linked list\\n    slow = fast = head\\n    \\n    # Loop through the linked list\\n    while fast and fast.next:\\n        # Move the slow pointer one node at a time\\n        slow = slow.next\\n        \\n        # Move the fast pointer two nodes at a time\\n        fast = fast.next.next\\n        \\n        # If the slow and fast pointers ever point to the same node, then there is a cycle in the linked list\\n        if slow == fast:\\n            return True\\n    \\n    # If the fast pointer encounters a null value, then there is no cycle in the linked list\\n    return False\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n  def hasCycle(self, head: ListNode) -> bool:\\n    # Initialize two pointers to point to the head of the linked list\\n    slow = fast = head\\n    \\n    # Loop through the linked list\\n    while fast and fast.next:\\n        # Move the slow pointer one node at a time\\n        slow = slow.next\\n        \\n        # Move the fast pointer two nodes at a time\\n        fast = fast.next.next\\n        \\n        # If the slow and fast pointers ever point to the same node, then there is a cycle in the linked list\\n        if slow == fast:\\n            return True\\n    \\n    # If the fast pointer encounters a null value, then there is no cycle in the linked list\\n    return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198356,
                "title": "python-clean-simple-floyd-s-cycle-detaction-using-2-pointer-slow-fast",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        slow = fast = head\\n        cnt = 0\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            if slow == fast:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        slow = fast = head\\n        cnt = 0\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            if slow == fast:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135556,
                "title": "python-simple-and-clean-beats-92-69",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n*This is an NFT*\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first thought in solving this problem is to find a way to detect if a linked list has a cycle. To accomplish this, we can use two pointers, a slow pointer, and a fast pointer. The slow pointer moves one step at a time while the fast pointer moves two steps at a time. If the linked list has a cycle, the fast pointer will eventually catch up with the slow pointer, and they will both point to the same node.\\n# Approach\\nThe approach to solving this problem is to use the two pointers, slow and fast, to traverse the linked list. The slow pointer moves one step at a time, and the fast pointer moves two steps at a time. If the linked list has a cycle, the fast pointer will eventually catch up with the slow pointer, and they will both point to the same node.\\n\\nTo check if the linked list has a cycle, we first check if the head of the linked list is None or if the next node is None. If either of these conditions is True, then the linked list has no cycle, and we return False.\\n\\nNext, we initialize the slow pointer to the head of the linked list, and the fast pointer to the next node. We then enter a while loop that continues as long as the fast pointer is not None and the next node of the fast pointer is not None.\\n\\nIn the while loop, we check if the slow pointer is equal to the fast pointer. If this is True, then we have found a cycle in the linked list, and we return True.\\n\\nIf the slow pointer is not equal to the fast pointer, we move the slow pointer one step at a time and the fast pointer two steps at a time. We repeat this process until either the fast pointer is None or the next node of the fast pointer is None.\\n\\nIf the while loop terminates, then the linked list has no cycle, and we return False.\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        if not head or not head.next:\\n            return False\\n        slow=head\\n        fast=head.next\\n        while(fast and fast.next):\\n            if slow==fast:\\n                return True\\n            slow=slow.next\\n            fast=fast.next.next\\n        return False\\n```\\n### Please upvote!",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        if not head or not head.next:\\n            return False\\n        slow=head\\n        fast=head.next\\n        while(fast and fast.next):\\n            if slow==fast:\\n                return True\\n            slow=slow.next\\n            fast=fast.next.next\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054968,
                "title": "c-2-easy-approaches-slow-fast-pointer-set",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Slow & Fast Pointer Approach\\n```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n\\n        while(fast != NULL && fast -> next != NULL){\\n            fast = fast -> next ->next;\\n            slow = slow -> next;\\n            if(slow == fast)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n# Set Approach\\n```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        set<ListNode*> st;\\n        while(!st.count(head) && head != NULL){\\n            st.insert(head);\\n            head = head->next;\\n        }\\n        if(head == NULL)\\n            return false;\\n        \\n        return true;\\n    }\\n};\\n```\\n\\n# Please Upvote \\uD83D\\uDE4F, if you find this helpful\\n#### Thank you in advance :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n\\n        while(fast != NULL && fast -> next != NULL){\\n            fast = fast -> next ->next;\\n            slow = slow -> next;\\n            if(slow == fast)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        set<ListNode*> st;\\n        while(!st.count(head) && head != NULL){\\n            st.insert(head);\\n            head = head->next;\\n        }\\n        if(head == NULL)\\n            return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011940,
                "title": "two-pointers-c",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (!head) \\n            return false;\\n        \\n        ListNode *slow = head, *fast = head;\\n        \\n        while (fast->next && fast->next->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if (slow == fast) \\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (!head) \\n            return false;\\n        \\n        ListNode *slow = head, *fast = head;\\n        \\n        while (fast->next && fast->next->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if (slow == fast) \\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671994,
                "title": "easy-slow-and-fast-pointer-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if(!head) return false;\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n        while(fast && fast->next){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if(!head) return false;\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n        while(fast && fast->next){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563252,
                "title": "java-2-pointer-approach-easy-understandable-code",
                "content": "**Please upvote if it helps you. I\\'ll keep updating with quality code.**\\n*if any query, pls comment. I\\'ll respond as quickly as possible.*\\n# Two-Pointer Approach\\nImagine there are two runners with different speed. If they are running on a straight path, the fast runner will first arrive at the destination. However, if they are running on a circular track, the fast runner will catch up with the slow runner if they keep running.\\n\\nThat\\'s exactly what we will come across using two pointers with different speed in a linked list:\\n\\n* **If there is no cycle, the fast pointer will stop at the end of the linked list.**\\n* **If there is a cycle, the fast pointer will eventually meet with the slow pointer.**\\n\\n***In this solution, Slow runner is moving 1 step while Fast runner is moving 2 step forward.***\\n```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    \\n    //  Time Complexity = O(N)\\n    //  Space Complexity = O(1)\\n    \\n    public boolean hasCycle(ListNode head) {\\n        //   Edge Case\\n        if(head == null )\\n            return false;\\n        \\n        //  2 Pointers slow and fast\\n        ListNode slow = head, fast = head;\\n        \\n        while(fast != null && fast.next != null){\\n            slow = slow.next;\\n            fast = fast.next.next;      //  2 times of slow pointer\\n            \\n            //  if slow pointer met the same value as of fast pointer then it means linked list contains cycle inside it\\n            if(slow == fast)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    \\n    //  Time Complexity = O(N)\\n    //  Space Complexity = O(1)\\n    \\n    public boolean hasCycle(ListNode head) {\\n        //   Edge Case\\n        if(head == null )\\n            return false;\\n        \\n        //  2 Pointers slow and fast\\n        ListNode slow = head, fast = head;\\n        \\n        while(fast != null && fast.next != null){\\n            slow = slow.next;\\n            fast = fast.next.next;      //  2 times of slow pointer\\n            \\n            //  if slow pointer met the same value as of fast pointer then it means linked list contains cycle inside it\\n            if(slow == fast)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2092812,
                "title": "easy-destructive-solution-c",
                "content": "Since we know that -10^5 <= Node.val <= 10^5, an easy way to mark a node as visited is to set its value to something beyond the range of valid values. Note: this will destroy the list unlike some other solutions.\\n\\n```\\npublic class Solution\\n{\\n    public bool HasCycle(ListNode head)\\n    {\\n        if (head == null) return false;\\n        \\n        while (head.next != null)\\n        {\\n            if (head.val == Int32.MaxValue) return true;\\n\\t\\t\\t\\n            head.val = Int32.MaxValue;\\n            head = head.next;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public bool HasCycle(ListNode head)\\n    {\\n        if (head == null) return false;\\n        \\n        while (head.next != null)\\n        {\\n            if (head.val == Int32.MaxValue) return true;\\n\\t\\t\\t\\n            head.val = Int32.MaxValue;\\n            head = head.next;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830141,
                "title": "typescript-easy",
                "content": "1. In a list with a cycle, the nodes will be `Error! Cycle in List Found`.\\n2. Add each node to a set `check` as you iterate through a `while` loop.\\n\\n\\n```\\nfunction hasCycle(head: ListNode | null): boolean {\\n    const check = new Set<ListNode | null>()\\n    let res: boolean = false\\n    \\n    while (head && !res){\\n        {check.has(head)\\n            ?\\n            res = true\\n            :\\n            check.add(head)\\n            head = head.next\\n        }\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Ordered Set"
                ],
                "code": "```\\nfunction hasCycle(head: ListNode | null): boolean {\\n    const check = new Set<ListNode | null>()\\n    let res: boolean = false\\n    \\n    while (head && !res){\\n        {check.has(head)\\n            ?\\n            res = true\\n            :\\n            check.add(head)\\n            head = head.next\\n        }\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1797732,
                "title": "java-clean-solution-beats-100",
                "content": "This problem uses famous Tortoise-Haire Algorithm.\\nHere slowPointer is Tortoise and FastPointer is Haire.\\nWhile Tortoise moves one step at a time, Haire moves 2 steps at a time, so it should reach end earlier than tortoise.\\nBut in any case, they both meet, that means there is a cycle present.\\n**O(N) Time, O(1) Space**\\n```\\npublic boolean hasCycle(ListNode head) {\\n        ListNode slowPointer = head;\\n        ListNode fastPointer = head;\\n        \\n        do {\\n            if (slowPointer == null || fastPointer == null || fastPointer.next == null) {\\n                return false;\\n            } \\n            slowPointer = slowPointer.next;\\n            fastPointer = fastPointer.next.next;\\n        } while (slowPointer != fastPointer);\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\npublic boolean hasCycle(ListNode head) {\\n        ListNode slowPointer = head;\\n        ListNode fastPointer = head;\\n        \\n        do {\\n            if (slowPointer == null || fastPointer == null || fastPointer.next == null) {\\n                return false;\\n            } \\n            slowPointer = slowPointer.next;\\n            fastPointer = fastPointer.next.next;\\n        } while (slowPointer != fastPointer);\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1766179,
                "title": "abuse-the-constraints-single-pointer-solution",
                "content": "A very notable constraint in the problem definition: \\n> The number of the nodes in the list is in the range [0, 10^4].\\n\\nYou don\\'t need two pointers when you know exactly how long the list can be!\\n\\n```\\npublic class Solution {\\n    public bool HasCycle(ListNode head) {\\n        ushort count = 0;\\n        while (count++ < 10001) {\\n            if (head == null) return false;\\n            head = head.next;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool HasCycle(ListNode head) {\\n        ushort count = 0;\\n        while (count++ < 10001) {\\n            if (head == null) return false;\\n            head = head.next;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701581,
                "title": "o-1-space-using-floyd-cycle-algo-easy",
                "content": "In floyd Cycle detection algo\\nwe use 2 ptr slow and fast and by moving them forward in such way\\n**slow = slow->next\\nfast = fast->next->next**\\nwhenever they meet that means there is cycle present in our Linked List if not that means Linked List is linear. :)\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    // by floyd cycle method\\n    bool hasCycle(ListNode *head) {\\n        if(head == NULL || head->next == NULL){\\n            return false;\\n        }\\n        \\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        \\n        while(fast != NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            \\n            if(slow == fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\nPlease Upvote if you like the sloution :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // by floyd cycle method\\n    bool hasCycle(ListNode *head) {\\n        if(head == NULL || head->next == NULL){\\n            return false;\\n        }\\n        \\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        \\n        while(fast != NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            \\n            if(slow == fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1674356,
                "title": "two-pointer-approach-easy-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* fast = head , *slow = head;\\n        while(fast && fast->next){\\n            fast = fast->next->next;\\n            slow = slow->next;\\n            if(fast == slow) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* fast = head , *slow = head;\\n        while(fast && fast->next){\\n            fast = fast->next->next;\\n            slow = slow->next;\\n            if(fast == slow) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1639985,
                "title": "o-1-space-10-liner-with-easy-explanation",
                "content": "Time Complexity: **O(N)**\\nSpace Complexity: **O(1)**\\n\\n### Algorithm\\n- Use 2 pointer. And looping the given linked list.\\n- The pointer `double` is faster one which passes though double nodes per step.\\n- Another pointer `single` is slower one which passes though single node per step.\\n- the pointer `double` and `single` gonna meets, if there are **cycle**. We gonna stop the looping and return `true`.\\n- Eventually pointer meets end of the node, if there are **no cycle**. We gonna stop the looping and return `false`.\\n\\n### Example\\n![image](https://assets.leetcode.com/users/images/d500c239-5f75-4358-9b7b-559e01305f88_1640107593.2537055.png)\\n- step 1\\n  - `double` -> 0 \\n  - `single` -> 2\\n- step 2\\n  - `double` -> 2\\n  - `single` -> 0\\n- step 3\\n  - `double` -> -4\\n  - `single` -> -4\\n  - `double` and `single` meet! return `true`\\n\\n\\n![image](https://assets.leetcode.com/users/images/f54417e1-4999-44f3-a516-e2f88d368d57_1640107614.5570474.png)\\n- step 1\\n  - `double` -> 1\\n  - `single` -> 2\\n- step 2\\n  - `double` -> 1\\n  - `single` -> 1\\n  - `double` and `single` meet! return `true`\\n\\n![image](https://assets.leetcode.com/users/images/2c5688f6-9297-41d2-8eaf-ac03f1587b51_1640107623.5081694.png)\\n- step 1\\n  - `double` -> null\\n  - `single` -> null\\n- step 2\\n  - `double` is null! Stop looping and return `false`\\n\\n\\n### Code\\n```JavaScript\\n/**\\n * @param {ListNode} head\\n * @return {boolean}\\n */\\nvar hasCycle = head => {\\n    let double = head\\n    let single = head;\\n    while (double) {\\n        double = double.next?.next;\\n        single = single.next;\\n        if (double && double == single) {\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n```\\n`?.` is optional chaining, which only working when object is not nullable.\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```JavaScript\\n/**\\n * @param {ListNode} head\\n * @return {boolean}\\n */\\nvar hasCycle = head => {\\n    let double = head\\n    let single = head;\\n    while (double) {\\n        double = double.next?.next;\\n        single = single.next;\\n        if (double && double == single) {\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1422031,
                "title": "python-single-pass-o-n-98-time-o-1-80-space-commented-and-explained",
                "content": "# 141. Linked List Cycle\\nI originally approached this problem simply seeking a solution. After getting a solution I read the little follow up at the bottom (can you do it in O(1) space) and it immediately clicked for me. This post will still go through the same logic and thought process. We will just take the extra step to get to the optimized solution.\\n\\n## Initial Thoughts\\n* If we travel through the linked list and encounter a value twice there is a cycle\\n* If we store all of the nodes in an array of seen nodes we increase both runtime and space complexity\\n* Instead of storing values we can use flag values to denote encountered nodes (note on this below)\\n* An apporpriate flag value would be 10<sup>6</sup> since it is out of the defined Node.val bounds (-10<sup>5</sup> < Node.val < 10<sup>5</sup>)\\n\\n## Approach\\n\\nThis problem breaks down on the smallest level to a decision structure. Has the current node been seen or not? If it has been seen then we have a cycle and return True. Otherwise, flag the node and move on.\\nThat is the hard part really. As long as our current node has a value we execute this decision structure and move on. Rinse, lather, repeat.\\n\\nWe start with while head != None. This does a few things for us.\\n\\n1. If we reach a node that has a value of None, the previous node was the last node. This means we traversed a linear (non-cyclic) linked list. Success!\\n2. Handles the edge case of null input\\n\\nOnce we have our loop set each time we havent seen a node we flag it and move on. If we encounter a flagged node the stop everything and return True. Successfully traversing the liked list and reaching the end guarantees that our input had no cycle.\\n\\n#### Note on bullet point 3\\nIf you thought about the fact that the data is being altered, I did too. What if we need this data to use somewhere else? The way I figured this could be done is assume the data value constraints and choose a addition/subtraction factor. In this case if we encounter a positive value add 10<sup>6</sup> and if it is negative subtract 10<sup>6</sup>. Then the flags are now ranges of numbers. For example: `if num in range(-10e5, 10e5 + 1)` could replace `if head.val == 10e6`. Then at the end we could call a \"fix\" function that would go through an fix all the flags.\\n\\n```\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        \\n        # We want to visit each node and mark it as visited\\n        # We can use a simple boolean value or a value outside of our Node.val range \\n        # (ex. -10e6 or 10e6 would be fine)\\n        while head != None:\\n            \\n            # We will use the flag value of 10e6. If Node.val == 10e6 we\\'ve encountered a cycle\\n            # else change the node\\'s value to 10e6 and move to the next node\\n            if head.val == 10e6:\\n                return True\\n            else:\\n                head.val = 10e6\\n                head = head.next\\n                \\n        # Breaking out of the while loop indicates we have no cycles\\n        # This would mean we encountered a node with Node.next = None\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        \\n        # We want to visit each node and mark it as visited\\n        # We can use a simple boolean value or a value outside of our Node.val range \\n        # (ex. -10e6 or 10e6 would be fine)\\n        while head != None:\\n            \\n            # We will use the flag value of 10e6. If Node.val == 10e6 we\\'ve encountered a cycle\\n            # else change the node\\'s value to 10e6 and move to the next node\\n            if head.val == 10e6:\\n                return True\\n            else:\\n                head.val = 10e6\\n                head = head.next\\n                \\n        # Breaking out of the while loop indicates we have no cycles\\n        # This would mean we encountered a node with Node.next = None\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355291,
                "title": "golang-slow-and-fast-pointer-method-time-o-n-space-o-1",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc hasCycle(head *ListNode) bool {\\n    //slow and fast pointer\\n    slow := head\\n    fast := head\\n    for fast != nil && fast.Next != nil {\\n        slow = slow.Next\\n        fast = fast.Next.Next\\n        if slow == fast {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc hasCycle(head *ListNode) bool {\\n    //slow and fast pointer\\n    slow := head\\n    fast := head\\n    for fast != nil && fast.Next != nil {\\n        slow = slow.Next\\n        fast = fast.Next.Next\\n        if slow == fast {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1145123,
                "title": "faster-than-99-two-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head){\\n        ListNode* slow=head, *fast=head;\\n        while (slow && fast && fast->next){\\n        slow= slow->next; fast= fast->next->next;\\n        if(slow==fast) return 1;\\n    }\\n    return 0;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    bool hasCycle(ListNode *head){\\n        ListNode* slow=head, *fast=head;\\n        while (slow && fast && fast->next){\\n        slow= slow->next; fast= fast->next->next;\\n        if(slow==fast) return 1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1048356,
                "title": "linked-list-cycle-floyd-s-algorithm-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n***Idea:***\\n\\nOne brute force solution here would be to map every single pointer in the list until we either reach the end of the list or find a duplicate, but that would use **O(n) space**.\\n\\nThe other brute force solution would involve counting nodes until we reached the designated constraint (**10e4**). If we pass that amount before reaching the end of the linked list, it must be a cycle. This solution is **O(1) space**, but much slower than an optimal solution.\\n\\nBut this problem is also an entry into the common question of **cycle detection**. One of the easiest methods of cycle detection is **Floyd\\'s Tortoise and the Hare algorithm**, which states that if you define two branches (**slow** and **fast**), and have the slow branch perform a given function once per iteration and the fast branch perform the same function twice per iteration, that they will eventually meet at the same point if the function is cyclical.\\n\\nIn essence, we start the hare just ahead of the tortoise, let them go, and see if the hare cycles back around to catch up with the tortoise again.\\n\\nOtherwise, if we ever reach the end of the linked list, we know that there can be no cycle.\\n\\n---\\n\\n***Implementation:***\\n\\nFor the javascript solution, we can also use **optional chaining** to good effect here to make the code slightly more readable.\\n\\n---\\n\\n**Javascript Code:**\\n\\nThe best result for the code below is **80ms / 41.1MB** (beats 96%).\\n```javascript\\nvar hasCycle = function(head) {\\n    let slow = head, fast = head?.next\\n    while (slow && fast)\\n        if (slow === fast) return true\\n        else slow = slow.next, fast = fast.next?.next\\n    return false\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar hasCycle = function(head) {\\n    let slow = head, fast = head?.next\\n    while (slow && fast)\\n        if (slow === fast) return true\\n        else slow = slow.next, fast = fast.next?.next\\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1047666,
                "title": "java-solution-100-faster-0ms",
                "content": "```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) \\n    {\\n        if (head == null || head.next == null) \\n    \\t\\treturn false; \\n  \\n        ListNode slow = head, fast = head; \\n  \\n        slow = slow.next; \\n        fast = fast.next.next; \\n\\n        while (fast != null && fast.next != null)\\n        { \\n            if (slow == fast) \\n                return true; \\n\\n            slow = slow.next; \\n            fast = fast.next.next; \\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) \\n    {\\n        if (head == null || head.next == null) \\n    \\t\\treturn false; \\n  \\n        ListNode slow = head, fast = head; \\n  \\n        slow = slow.next; \\n        fast = fast.next.next; \\n\\n        while (fast != null && fast.next != null)\\n        { \\n            if (slow == fast) \\n                return true; \\n\\n            slow = slow.next; \\n            fast = fast.next.next; \\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1004321,
                "title": "simple-approach-with-hashmap-88-faster",
                "content": "\\n```\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        dix = {} # to store the addresses of the nodes \\n        while head:\\n            if id(head) in dix:\\n                return True # if an address is already pointed by another node i.e. there is cycle\\n            else:\\n                dix[id(head)] =  1\\n                head = head.next\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        dix = {} # to store the addresses of the nodes \\n        while head:\\n            if id(head) in dix:\\n                return True # if an address is already pointed by another node i.e. there is cycle\\n            else:\\n                dix[id(head)] =  1\\n                head = head.next\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 802137,
                "title": "javascript-solution-141",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n\\n/**\\n * @param {ListNode} head\\n * @return {boolean}\\n */\\nvar hasCycle = function(head) {\\n    let r1 = head, r2 = head;\\n    while (r1 && r1.next) {\\n        r1 = r1.next.next;\\n        r2 = r2.next;\\n        if (r1 == r2) {\\n            return true;\\n        }\\n    } \\n    return false;\\n};\\n```\\n\\n**Runtime: 76 ms, faster than 90.45% of JavaScript online submissions for Linked List Cycle.**\\n\\n**Memory Usage: 39.6 MB, less than 15.59% of JavaScript online submissions for Linked List Cycle.**\\n\\n**Feedback Appreciated**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n\\n/**\\n * @param {ListNode} head\\n * @return {boolean}\\n */\\nvar hasCycle = function(head) {\\n    let r1 = head, r2 = head;\\n    while (r1 && r1.next) {\\n        r1 = r1.next.next;\\n        r2 = r2.next;\\n        if (r1 == r2) {\\n            return true;\\n        }\\n    } \\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 712820,
                "title": "c-easy-to-understand-solution-94-59",
                "content": "***Runtime: 8 ms, faster than 94.59% of C++ online submissions for Linked List Cycle.\\nMemory Usage: 7.6 MB, less than 86.65% of C++ online submissions for Linked List Cycle.***\\n\\n```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if(!head)   return false;\\n        ListNode *slowptr = head;\\n        ListNode *fastptr = head;\\n        do{\\n            slowptr = slowptr->next;\\n            fastptr = fastptr->next;\\n            if(fastptr)\\n                fastptr = fastptr->next;\\n        }while(fastptr && slowptr!=fastptr);\\n        return fastptr ? true : false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if(!head)   return false;\\n        ListNode *slowptr = head;\\n        ListNode *fastptr = head;\\n        do{\\n            slowptr = slowptr->next;\\n            fastptr = fastptr->next;\\n            if(fastptr)\\n                fastptr = fastptr->next;\\n        }while(fastptr && slowptr!=fastptr);\\n        return fastptr ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 535603,
                "title": "c-12ms-constant-space-solution-runner-technique",
                "content": "```\\n    bool hasCycle(ListNode *head) {\\n        ListNode *slow = head, *fast = head;\\n        while(fast && fast->next){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast) return true;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    bool hasCycle(ListNode *head) {\\n        ListNode *slow = head, *fast = head;\\n        while(fast && fast->next){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast) return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 44629,
                "title": "java-fast-slow-pointers-solution",
                "content": "        \\n    public boolean hasCycle(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return false;\\n        }\\n        ListNode slow = head, fast = head.next.next;\\n        // if \"fast\" is null, there is no circle\\n        while (fast != null && fast.next != null) {\\n            if (slow == fast) {\\n                return true;\\n            }\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        } \\n        return false;\\n    }",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "        \\n    public boolean hasCycle(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return false;\\n        }\\n        ListNode slow = head, fast = head.next.next;\\n        // if \"fast\" is null, there is no circle\\n        while (fast != null && fast.next != null) {\\n            if (slow == fast) {\\n                return true;\\n            }\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        } \\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4102699,
                "title": "video-visualization-of-tortoise-and-hare-floyd-s-cycle-detection-algorithm",
                "content": "https://youtu.be/RRSItF-Ts4Q\\n\\nThe last pointer in a linked list usually points to a null value to singal the end of the list, but if the last pointer points back to another node in the linked list instead, we now have a cycle.  The most common way to solve this problem is by using the Tortoise and Hare algorithm.\\n\\nThe idea is that we create two pointers,  a slow one and a fast one.  The slow pointer traverses the linked list 1 node at a time, while the fast pointer traverses the linked list 2 nodes at a time.  If at some point the two pointers meet on the same node, then that means a cycle exists.\\n\\nWhy does this work? For a visual animation, please see the video, but for a simple explanation, think of two people running on a circular track.  If both people run and one of them runs faster than the other, then the faster person will eventually catch up to the slower one and \"lap\" them.  In other words, they will be back at the same position again.  This is what we\\'re looking for in the algorithm and it\\'s how we detect a cycle. \\n\\n# Code\\n```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        fast = head\\n        while fast and fast.next:\\n            head = head.next\\n            fast = fast.next.next\\n            if head is fast:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        fast = head\\n        while fast and fast.next:\\n            head = head.next\\n            fast = fast.next.next\\n            if head is fast:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999419,
                "title": "java-0ms-100-faster",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null)\\n            return false;\\n\\n        ListNode fast = head.next;\\n        ListNode slow = head;\\n\\n        while(slow != fast && fast != null && fast.next != null){\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n\\n        if(slow == fast)\\n            return true;\\n\\n        return false;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null)\\n            return false;\\n\\n        ListNode fast = head.next;\\n        ListNode slow = head;\\n\\n        while(slow != fast && fast != null && fast.next != null){\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n\\n        if(slow == fast)\\n            return true;\\n\\n        return false;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999114,
                "title": "easy-c-slow-fast-with-different-strides-beats-91-08",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse 2 pointers slow & fast to detect the cycle. Floyd\\'s Algorithm\\n(Tortoise and Hare Algorithm)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf once fast==slow then there is a cycle, otherwise til null.\\nIn usual, the stride for slow is taken 1, and the stride for fast is taken 2.\\nIn 2nd approach, the stride for slow is taken 2, and the stride for fast is taken  3. since 2, 3 are coprime, if there is a cycle, fast & slow will meet.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (!head||!head->next || !head->next->next) \\n            return 0;\\n        ListNode *fast=head, *slow=head;\\n        //int i=0;\\n        while(fast!=NULL && fast->next!=NULL){\\n            fast=fast->next->next;\\n            slow=slow->next;\\n        //    cout<<++i<<\",\";\\n            if (fast==slow) return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n# 2nd Code slow with stride=2 and fast with stride=3\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (!head||!head->next || !head->next->next) \\n            return 0;\\n        ListNode *fast=head, *slow=head;\\n        //int i=0;\\n        while(fast && fast->next && fast->next->next){\\n            fast=fast->next->next->next;\\n            slow=slow->next->next;\\n        //    cout<<++i<<\",\";\\n            if (fast==slow) return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (!head||!head->next || !head->next->next) \\n            return 0;\\n        ListNode *fast=head, *slow=head;\\n        //int i=0;\\n        while(fast!=NULL && fast->next!=NULL){\\n            fast=fast->next->next;\\n            slow=slow->next;\\n        //    cout<<++i<<\",\";\\n            if (fast==slow) return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (!head||!head->next || !head->next->next) \\n            return 0;\\n        ListNode *fast=head, *slow=head;\\n        //int i=0;\\n        while(fast && fast->next && fast->next->next){\\n            fast=fast->next->next->next;\\n            slow=slow->next->next;\\n        //    cout<<++i<<\",\";\\n            if (fast==slow) return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3473808,
                "title": "c-easy-to-understand-100-fast-slow-and-fast-pointer",
                "content": "\\nclass Solution {\\npublic:\\n\\n    bool hasCycle(ListNode *head) {\\n        if(head == NULL)\\n            return false;\\n        if(head-> next == NULL)\\n            return false;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n         while(slow != NULL && fast != NULL){\\n             fast = fast->next;\\n             if(fast != NULL)\\n                 fast = fast->next;\\n             slow = slow-> next;\\n             if(slow == fast)\\n                 return true;\\n         }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool hasCycle(ListNode *head) {\\n        if(head == NULL)\\n            return false;\\n        if(head-> next == NULL)\\n            return false;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n         while(slow != NULL && fast != NULL){\\n             fast = fast->next;\\n             if(fast != NULL)\\n                 fast = fast->next;\\n             slow = slow-> next;\\n             if(slow == fast)\\n                 return true;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 3460021,
                "title": "beats-92-12-20-145-top-interview-question",
                "content": "# Intuition\\n*Floyds, fast and slow two pointer technique*\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis is a Python implementation of the Floyd\\'s Cycle Detection Algorithm to detect whether a linked list has a cycle or not. Here\\'s an explanation of the code:\\n\\nThe input is a linked list represented by the head node.\\n\\nThe function `hasCycle` takes in the head node as an argument and returns a boolean value indicating whether the linked list contains a cycle or not.\\n\\nWe initialize two pointers, `s` (slow) and `f` (fast), both pointing to the head node.\\n\\nWe then start iterating over the linked list using `s` and `f` pointers. The `s` pointer moves one step at a time while the `f` pointer moves two steps at a time.\\n\\nIf there is a cycle in the linked list, the `f` pointer will eventually catch up to the `s` pointer from behind, i.e., `f` will eventually become equal to `s`.\\n\\nAt this point, we can return `True` as there is a cycle in the linked list.\\n\\nIf `f` reaches the end of the linked list, i.e., `f` becomes `None`, it means that there is no cycle in the linked list. We can return `False` in this case.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n\\nThe `time complexity` of this algorithm is `O(n)`, where `n` is the number of nodes in the linked list. The `space complexity` is `O(1)` since we are only using two pointers, regardless of the size of the linked list.\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        s, f = head,head\\n        while f and f.next: \\n            s = s.next\\n            f = f.next.next\\n            if f == s: return True\\n        return False\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        s, f = head,head\\n        while f and f.next: \\n            s = s.next\\n            f = f.next.next\\n            if f == s: return True\\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442290,
                "title": "java",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if (head == null) {\\n            return false;\\n        }\\n\\n        ListNode slow = head;\\n        ListNode fast = head;\\n\\n        while (fast.next != null && fast.next.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (fast == slow) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if (head == null) {\\n            return false;\\n        }\\n\\n        ListNode slow = head;\\n        ListNode fast = head;\\n\\n        while (fast.next != null && fast.next.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (fast == slow) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360992,
                "title": "java-solution-in-o-1-easy-two-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to print ``true`` or ``false`` if Cylce in the list repeats then we have to print ``true`` otherwise ``false``. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake Two pointers, one for head and second for next node.\\nStart traversal with a ``while`` loop with condition if ``p1 != p2``\\nand first check that ``p2 and p2.next`` must not ``null``  because if it is null then ``no cycle found`` and after it taking another value in pointes `p1 = p1.next && p2 = p2.next.next`. If the loop sucessfully run then there is cycle present other wise not.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if (head == null || head.next == null)\\n            return false;\\n        ListNode p1 = head;\\n        ListNode p2 = head.next;\\n        while (p1 != p2){\\n            if (p2 == null || p2.next == null)\\n                return false;\\n            p1 = p1.next;\\n            p2 = p2.next.next;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n# UpVote If you like and Understand otherwise not.\\n#### Thank you",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if (head == null || head.next == null)\\n            return false;\\n        ListNode p1 = head;\\n        ListNode p2 = head.next;\\n        while (p1 != p2){\\n            if (p2 == null || p2.next == null)\\n                return false;\\n            p1 = p1.next;\\n            p2 = p2.next.next;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300459,
                "title": "trust-me-no-one-can-beat-this-2-approaches-step-by-step-explained",
                "content": "\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot 2023-03-15 185755.png](https://assets.leetcode.com/users/images/0b16712a-c2f1-402b-a89f-f73f64a230b0_1678889126.3366673.png)\\n\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        // Check if the list is empty\\n        if (head == null) {\\n            return false;\\n        }\\n    \\n        // Initialize two pointers: slow and fast\\n        ListNode slow = head;\\n        ListNode fast = head.next;\\n    \\n        // Loop until the fast pointer reaches the end of the list or catches up to the slow pointer\\n        while (fast != null && fast.next != null) {\\n            // Check if the slow and fast pointers point to the same node, indicating a cycle\\n            if (slow == fast) {\\n                return true;\\n            }\\n            // Move the slow pointer one step forward and the fast pointer two steps forward\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n    \\n    // If the loop completes without finding a cycle, return false\\n    return false;\\n    }\\n}\\n```\\n\\n\\n# HASHSET APPROACH\\n\\n    public boolean hasCycle(ListNode head) {\\n\\n        //check if head or head.next is null\\n\\n        if(head==null || head.next == null){\\n            return false;\\n        }\\n        //creat a HashSet\\n        HashSet<ListNode> map = new HashSet<>();\\n\\n        //Run a loop till head is not null\\n\\n        while(head.next != null){\\n\\n            //If map contains head then there is loop\\n\\n            if(map.contains(head)){\\n                return true;\\n            }\\n            //If it has occured for the first time then add it to hashmap\\n            else{\\n                map.add(head);\\n            }\\n            //move the head pointer\\n            head = head.next;\\n        }\\n        return false;\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        // Check if the list is empty\\n        if (head == null) {\\n            return false;\\n        }\\n    \\n        // Initialize two pointers: slow and fast\\n        ListNode slow = head;\\n        ListNode fast = head.next;\\n    \\n        // Loop until the fast pointer reaches the end of the list or catches up to the slow pointer\\n        while (fast != null && fast.next != null) {\\n            // Check if the slow and fast pointers point to the same node, indicating a cycle\\n            if (slow == fast) {\\n                return true;\\n            }\\n            // Move the slow pointer one step forward and the fast pointer two steps forward\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n    \\n    // If the loop completes without finding a cycle, return false\\n    return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198648,
                "title": "using-floyd-s-cycle-finding-algorithm-to-detect-a-cycle-in-a-linked-list",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo detect a cycle in a linked list, we can use the \"Floyd\\'s cycle-finding algorithm\" (also known as the \"tortoise and hare algorithm\").\\n\\nThe idea behind this algorithm is to use two pointers - a slow pointer and a fast pointer - to traverse the linked list. The slow pointer moves one node at a time, while the fast pointer moves two nodes at a time. If there is a cycle in the linked list, the fast pointer will eventually catch up to the slow pointer, and they will meet at some node in the cycle.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere\\'s the algorithm:\\n\\n1. Initialize two pointers, slow and fast, to the head of the linked list.\\n2. Traverse the linked list using the slow and fast pointers as follows:\\na. Move the slow pointer one node at a time.\\nb. Move the fast pointer two nodes at a time.\\nc. If the fast pointer reaches the end of the linked list (i.e., its next node is null), then the linked list has no cycle, so return false.\\nd. If the fast pointer ever equals the slow pointer, then there is a cycle in the linked list, so return true.\\n3. If we have reached the end of the linked list (i.e., the fast pointer is null), then the linked list has no cycle, so return false.\\n\\n# Complexity\\n- Time complexity: The algorithm traverses the linked list once using two pointers. The slow pointer moves one step at a time, and the fast pointer moves two steps at a time. The maximum number of steps that the fast pointer can take is N/2, where N is the length of the linked list. Therefore, the time complexity of the algorithm is O(N).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  The algorithm only uses two pointers, so the space complexity is O(1) (constant space).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nnote : This algorithm has a time complexity of O(n) and a space complexity of O(1), as it only uses two pointers to traverse the linked list.\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        # Initialize two pointers to the head of the linked list\\n        slow = head\\n        fast = head\\n    \\n        # Traverse the linked list using the slow and fast pointers\\n        while fast and fast.next:\\n        # Move the slow pointer one node at a time\\n            slow = slow.next\\n        \\n        # Move the fast pointer two nodes at a time\\n            fast = fast.next.next\\n        \\n        # If the fast pointer ever equals the slow pointer, then there is a cycle\\n            if slow == fast:\\n                return True\\n    \\n        # If we have reached the end of the linked list, then there is no cycle\\n        return False\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        # Initialize two pointers to the head of the linked list\\n        slow = head\\n        fast = head\\n    \\n        # Traverse the linked list using the slow and fast pointers\\n        while fast and fast.next:\\n        # Move the slow pointer one node at a time\\n            slow = slow.next\\n        \\n        # Move the fast pointer two nodes at a time\\n            fast = fast.next.next\\n        \\n        # If the fast pointer ever equals the slow pointer, then there is a cycle\\n            if slow == fast:\\n                return True\\n    \\n        # If we have reached the end of the linked list, then there is no cycle\\n        return False\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080048,
                "title": "brute-force-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbrute force\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n         int n=0;\\n        ListNode temp=head;\\n        while(temp!=null){\\n            temp=temp.next;\\n            n++; \\n            if(n>10000){\\n                return true;\\n            }     \\n        }\\n       return false;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n         int n=0;\\n        ListNode temp=head;\\n        while(temp!=null){\\n            temp=temp.next;\\n            n++; \\n            if(n>10000){\\n                return true;\\n            }     \\n        }\\n       return false;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931329,
                "title": "simplest-java-sloution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow= head;\\n        ListNode fast= head;\\n        while(fast != null && fast.next != null){\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            if(slow == fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow= head;\\n        ListNode fast= head;\\n        while(fast != null && fast.next != null){\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            if(slow == fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765271,
                "title": "two-pointers",
                "content": "```\\nclass Solution:\\n    def hasCycle(self, head):\\n        slow = fast = head\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n            if slow == fast: return True\\n            \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasCycle(self, head):\\n        slow = fast = head\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n            if slow == fast: return True\\n            \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714734,
                "title": "easy-python-solution",
                "content": "\\n        try:\\n            slow = head\\n            fast = head.next\\n            while slow is not fast:\\n                slow = slow.next\\n                fast = fast.next.next\\n            return True\\n        except:\\n            return False\\n\\t\\t\\t\\n\\t\\t\\t\"\"\"create two pointers and make them chase each other ,when the fast catches the slow ,you have your condition ,Make sure all errors are returned as false\"\"\"",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "\\n        try:\\n            slow = head\\n            fast = head.next\\n            while slow is not fast:\\n                slow = slow.next\\n                fast = fast.next.next\\n            return True\\n        except:\\n            return False\\n\\t\\t\\t\\n\\t\\t\\t\"\"\"create two pointers and make them chase each other ,when the fast catches the slow ,you have your condition ,Make sure all errors are returned as false\"\"\"",
                "codeTag": "Unknown"
            },
            {
                "id": 1900811,
                "title": "java-easy-to-understand-2-methods-detailed-explanation",
                "content": "We can solve this problem by using any of the 2 methods below-\\n***Please upvote if this explanation helps you.***\\n\\n1. Using **Floyd\\'s Cycle Finding Algorithm**-\\nFloyd\\u2019s cycle-finding algorithm is a pointer algorithm that uses only two pointers, moving through the sequence at different speeds. It states the usage of Linked List in this algorithm and its output.\\nThe purpose is to determine whether the linked list has a cycle or not. First, we keep two pointers of the head node they are, **slow pointer** and **fast pointer**. At each iteration, you move one of the pointers by two steps and the other one by one step. So you have two pointers tortoise and the hare. Eventually one of the two cases will happen:\\n\\n- **fastPointer** will reach the tail of the linked list(null), which means that there is no cycle in it\\n- **fastPointer** will meet **slowPointer**, which means that there is a cycle.\\n\\n\\nLet\\'s understand by the below example-\\nHere the **Car M** is **SlowPointer** and **Car B** is **FastPointer**.\\n\\n![image](https://assets.leetcode.com/users/images/d5d5ace4-2acd-49e9-8426-ae1deefb2cd0_1648740035.1112502.png)\\n![image](https://assets.leetcode.com/users/images/922c80fe-b2bd-4969-8323-8a063267e39d_1648740045.818089.png)\\n![image](https://assets.leetcode.com/users/images/4debbcc6-2098-4853-ad03-15338b2828b1_1648740053.1831126.png)\\n![image](https://assets.leetcode.com/users/images/b7bc0632-72da-4123-b3ee-7a4187ba3ef2_1648740059.1595976.png)\\n![image](https://assets.leetcode.com/users/images/b00d602e-ac6e-494f-a93a-de820f9ca028_1648740064.7201557.png)\\n![image](https://assets.leetcode.com/users/images/f870c926-189b-4f31-bc6b-770f4dfb27f1_1648740071.0575871.png)\\n![image](https://assets.leetcode.com/users/images/3601f3f4-0a21-4db9-abad-7f094ce79e69_1648740077.4067209.png)\\n\\n```\\npublic boolean hasCycle(ListNode head) {\\n        ListNode slowPointer = head;\\n        ListNode fastPointer = head;\\n        \\n        do {\\n            if (slowPointer == null || fastPointer == null || fastPointer.next == null) {\\n                return false;\\n            } \\n            slowPointer = slowPointer.next;\\n            fastPointer = fastPointer.next.next;\\n        } while (slowPointer != fastPointer);\\n        \\n        return true;\\n    }\\n```\\n**Time Complexity- O(N) \\nSpace Complexity- O(1)**\\n\\n\\n2. Using **HashSet**-\\n- Hashset posses an unique property of storing only distinct values.\\n- The boolean **contains(element)** method in Java HashSet returns false if a same element exists in the set.If the element doesn\\'t exists in the HashSet then add the element by using **add(element)** method.\\n```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head==null || head.next == null){\\n            return false;\\n        }\\n        HashSet<ListNode> llSet = new HashSet<>();\\n        while(head.next!=null){\\n            if(llSet.contains(head)){\\n                return true;\\n            }\\n            else{\\n                llSet.add(head);\\n            }\\n            head = head.next;\\n        }\\n        return false;\\n    }\\n}\\n```\\n**Time Complexity- O(N) \\nSpace Complexity- O(N)**\\n\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\npublic boolean hasCycle(ListNode head) {\\n        ListNode slowPointer = head;\\n        ListNode fastPointer = head;\\n        \\n        do {\\n            if (slowPointer == null || fastPointer == null || fastPointer.next == null) {\\n                return false;\\n            } \\n            slowPointer = slowPointer.next;\\n            fastPointer = fastPointer.next.next;\\n        } while (slowPointer != fastPointer);\\n        \\n        return true;\\n    }\\n```\n```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head==null || head.next == null){\\n            return false;\\n        }\\n        HashSet<ListNode> llSet = new HashSet<>();\\n        while(head.next!=null){\\n            if(llSet.contains(head)){\\n                return true;\\n            }\\n            else{\\n                llSet.add(head);\\n            }\\n            head = head.next;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830937,
                "title": "c-easy-to-understand-using-tortoise-approach-daily-leetcoding-challenge-day-8",
                "content": "// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09If it helps please Upvote\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\n\\nEXPLANATION : \\n* **Traverse linked list using two pointers.**\\n\\n*  **Move one pointer(slow) by one and another pointer(fast) by two.**\\n\\n* **If these pointers meet at the same node then there is a loop. If pointers do not meet then linked list doesn\\u2019t have a loop.** \\n\\n\\n* **Time Complexity : O(N)**\\n* **Space Complexity : O(1)**\\n```\\nclass Solution \\n{\\npublic:\\n    bool hasCycle(ListNode *head) \\n    {\\n        // check if head is on null or head next is on null\\n        if(head==NULL or head->next==NULL)\\n        {\\n            return false;\\n        }\\n        \\n        // 2 pointer approach\\n        // Tortoise and Hare approach\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        \\n        // till next->null or null is not find\\n        while(fast->next && fast->next->next)\\n        {\\n            slow = slow->next;       // move slow by one\\n            fast = fast->next->next; // move fast by two\\n            \\n            // if they collide\\n            if(slow==fast)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n// Example : \\n// [3,2,0,-4]\\n\\n// 1. slow = 3 , fast = 3\\n\\n// 2. slow = 2 , fast = 0\\n    \\n// 3. slow = 0 , fast = 2\\n    \\n// 4. slow = -4 , fast = -4     (they collide it means there is a cycle exist in the given linked list)\\n```\\n// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09If it helps please Upvote\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool hasCycle(ListNode *head) \\n    {\\n        // check if head is on null or head next is on null\\n        if(head==NULL or head->next==NULL)\\n        {\\n            return false;\\n        }\\n        \\n        // 2 pointer approach\\n        // Tortoise and Hare approach\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        \\n        // till next->null or null is not find\\n        while(fast->next && fast->next->next)\\n        {\\n            slow = slow->next;       // move slow by one\\n            fast = fast->next->next; // move fast by two\\n            \\n            // if they collide\\n            if(slow==fast)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n// Example : \\n// [3,2,0,-4]\\n\\n// 1. slow = 3 , fast = 3\\n\\n// 2. slow = 2 , fast = 0\\n    \\n// 3. slow = 0 , fast = 2\\n    \\n// 4. slow = -4 , fast = -4     (they collide it means there is a cycle exist in the given linked list)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1829480,
                "title": "c-3-methods-100-faster-easy",
                "content": "```\\nMethod 1\\n\\n//Using hashing\\n//Here we will chech if the node we have visisted is present or not if we have visited it then it mean there is cycle.\\n\\n//Time complexity: O(n)\\n//Space complexity: O(n)\\n\\nclass Solution {\\npublic:\\n    unordered_map<ListNode*,int> mp;\\n    bool hasCycle(ListNode *head) {\\n        while(head!=NULL){\\n            if(mp.find(head) == mp.end()){\\n                mp[head]++;\\n            }\\n            else{\\n                return true;\\n            }\\n            head=head->next;\\n        }\\n        return false;\\n    }\\n};\\n\\nMethod 2\\n\\n//Floyd\\u2019s Cycle-Finding Algorithm \\n//Here we will use two pointers slow and fast \\n//where slow will travel one step and fast two step\\n//if they become same at some time there is cycle\\n//if fast is null then there is no cycle\\n\\n//Time complexity: O(n)\\n//Space complexity: O(1)\\n\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if(head==NULL){\\n            return false;\\n        }\\n        ListNode* slow=head;\\n        ListNode* fast=head;\\n        while(fast && fast->next){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n            if(slow==fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\nMethod 3\\n\\n//One easy methos is to modify the values of the linked list to tha value which is not in the range.\\n//When you encounter this value again then there is loop\\n\\n//Time complexity: O(n)\\n//Space complexity: O(1)\\n\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if(head==NULL){\\n            return false;\\n        }\\n        while(head){\\n            if(head->val==1000000){\\n                return true;\\n            }\\n            head->val=1000000;\\n            head=head->next;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nMethod 1\\n\\n//Using hashing\\n//Here we will chech if the node we have visisted is present or not if we have visited it then it mean there is cycle.\\n\\n//Time complexity: O(n)\\n//Space complexity: O(n)\\n\\nclass Solution {\\npublic:\\n    unordered_map<ListNode*,int> mp;\\n    bool hasCycle(ListNode *head) {\\n        while(head!=NULL){\\n            if(mp.find(head) == mp.end()){\\n                mp[head]++;\\n            }\\n            else{\\n                return true;\\n            }\\n            head=head->next;\\n        }\\n        return false;\\n    }\\n};\\n\\nMethod 2\\n\\n//Floyd\\u2019s Cycle-Finding Algorithm \\n//Here we will use two pointers slow and fast \\n//where slow will travel one step and fast two step\\n//if they become same at some time there is cycle\\n//if fast is null then there is no cycle\\n\\n//Time complexity: O(n)\\n//Space complexity: O(1)\\n\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if(head==NULL){\\n            return false;\\n        }\\n        ListNode* slow=head;\\n        ListNode* fast=head;\\n        while(fast && fast->next){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n            if(slow==fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\nMethod 3\\n\\n//One easy methos is to modify the values of the linked list to tha value which is not in the range.\\n//When you encounter this value again then there is loop\\n\\n//Time complexity: O(n)\\n//Space complexity: O(1)\\n\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if(head==NULL){\\n            return false;\\n        }\\n        while(head){\\n            if(head->val==1000000){\\n                return true;\\n            }\\n            head->val=1000000;\\n            head=head->next;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777202,
                "title": "simple-java-code-2-pointers-100-faster",
                "content": "```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode a=head,b=head;\\n        while(a!=null && a.next!=null){\\n            a=a.next.next;\\n            b=b.next;\\n            if(a==b && a.val==b.val)\\n                break;\\n        }\\n        return a!=null && a.next!=null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode a=head,b=head;\\n        while(a!=null && a.next!=null){\\n            a=a.next.next;\\n            b=b.next;\\n            if(a==b && a.val==b.val)\\n                break;\\n        }\\n        return a!=null && a.next!=null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1626949,
                "title": "c-o-n-two-approaches-with-explanation",
                "content": "**The Problem can be solved with two different approaches**\\n* Method-1: Using extra space(HashTable)\\nThe idea here is to traverse through the LinkedList and For every node: check if it exists in the unordered_set.\\n->  If yes we simply return true\\n->otherwise we store the address of this node in the set   \\nThe intuition is that if there is no cycle in the Linkedlist then we will never reach a node again which has already \\nbeen visited.\\n```\\n\\t\\t\\t// there must be atleast two nodes to form a cycle\\n\\t\\t\\tif (head == NULL || head->next == NULL)\\n                return false;\\n            ListNode *dummy = head;\\n            unordered_set<ListNode *> s;\\n            while (dummy != NULL)\\n            {\\n                if (s.find(dummy) != s.end())\\n                {\\n                    return true;\\n                }\\n                s.insert(dummy);\\n                dummy = dummy->next;\\n            }\\n            return false;\\n```\\nThe Time Complexity is O(n) and and extra space O(n) is needed to store the nodes.\\n\\n* Method-2: Two Pointer Approach\\n->This is an efficient method of finding the cycle as it doesnot use any extra space.\\n->The idea is to use two pointers fast and slow where slow moves by one step and fast by two steps.\\n->If there is no cycle in the Linkedlist the two pointers will never meet and fast pointer will eventually become null.\\n->if there is a cycle then the pointers will revolve around the cycle and will definitely meet at some node because fast will chase down slow at some point of time.\\n\\n```         // base case\\n\\t\\t\\tif (head == NULL || head->next == NULL)\\n                return false;\\n            ListNode *slow, *fast;\\n            slow = fast = head;\\n            while (fast != NULL && fast->next != NULL)\\n            {\\n                slow = slow->next;\\n                fast = fast->next->next;\\n                if (slow == fast)\\n                {\\n                    return true;\\n                }\\n            }\\n\\t\\t\\t// the control will come out of while loop only when the List is linear\\n            return false;\\n```\\nTime Complexity: O(n) \\nDo upvote if u like this. Happy Coding :)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\t\\t\\t// there must be atleast two nodes to form a cycle\\n\\t\\t\\tif (head == NULL || head->next == NULL)\\n                return false;\\n            ListNode *dummy = head;\\n            unordered_set<ListNode *> s;\\n            while (dummy != NULL)\\n            {\\n                if (s.find(dummy) != s.end())\\n                {\\n                    return true;\\n                }\\n                s.insert(dummy);\\n                dummy = dummy->next;\\n            }\\n            return false;\\n```\n```         // base case\\n\\t\\t\\tif (head == NULL || head->next == NULL)\\n                return false;\\n            ListNode *slow, *fast;\\n            slow = fast = head;\\n            while (fast != NULL && fast->next != NULL)\\n            {\\n                slow = slow->next;\\n                fast = fast->next->next;\\n                if (slow == fast)\\n                {\\n                    return true;\\n                }\\n            }\\n\\t\\t\\t// the control will come out of while loop only when the List is linear\\n            return false;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1511575,
                "title": "accepted-clean-c-solution",
                "content": "class Solution {\\npublic:\\n\\n    bool hasCycle(ListNode *head) {\\n        ListNode* slow=head;\\n        ListNode* fast=head;\\n        \\n        while(fast!=NULL && fast->next!=NULL){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n            if(fast==slow){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    bool hasCycle(ListNode *head) {\\n        ListNode* slow=head;\\n        ListNode* fast=head;\\n        \\n        while(fast!=NULL && fast->next!=NULL){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n            if(fast==slow){\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1460220,
                "title": "linked-list-cycle-c-floyd-s-cycle-finding-algorithm-optimal-solution",
                "content": "**Floyd\\'s Cycle Detection Algorithm** (**Two Pointer Approach**) :\\n\\nclass Solution {\\npublic:\\n\\n    bool hasCycle(ListNode *head) {\\n    \\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n       \\n        while(slow && fast && fast->next)\\n        {\\n            slow=slow->next;\\n            fast=fast->next->next;\\n            if(slow == fast)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\nTime Complexity :- O(N)\\nSpace Complexity :- O(1)\\n\\n**if you like this solution. so please upvoted.**\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool hasCycle(ListNode *head) {\\n    \\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n       \\n        while(slow && fast && fast->next)\\n        {\\n            slow=slow->next;\\n            fast=fast->next->next;\\n            if(slow == fast)\\n            {\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1447426,
                "title": "optimised-c-solution-floyd-s-algorithm-full-explanation-of-code",
                "content": "This is the **Floyd\\'s Algorithm** also known as **Hare and Tortoise Algorithm**. It use two pointers ```slow``` and ```fast``` pointer.\\nAccording to the algorithm we will move the ```slow``` pointer by one step and ```fast```pointer by 2 steps , and if the ```slow``` and ```fast``` pointers colides that means there is a cycle in a linked list and we return true .\\n\\n```\\nbool hasCycle(ListNode *head) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        \\n        while(fast != NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            \\n            if(slow == fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\nHope This explaination was helpful !!! \\uD83D\\uDE4C",
                "solutionTags": [],
                "code": "```slow```\n```fast```\n```slow```\n```fast```\n```slow```\n```fast```\n```\\nbool hasCycle(ListNode *head) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        \\n        while(fast != NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            \\n            if(slow == fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1165659,
                "title": "c-unique-single-traversal-time-o-n-and-space-o-1",
                "content": "**This approach is little bit faster than two-pointer approach. Because here we are traversing each element only single time.**\\n```\\n    bool hasCycle(ListNode *head) {  \\n        while(head && head->val != INT_MIN) {\\n            head->val = INT_MIN;\\n            head = head->next;\\n        }\\t\\t\\n        return head != NULL;\\n    }\\n```\\n\\n**Comment below if you have any queries. I would love to answer them and don\\'t forget to upvote, if you like the solution.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    bool hasCycle(ListNode *head) {  \\n        while(head && head->val != INT_MIN) {\\n            head->val = INT_MIN;\\n            head = head->next;\\n        }\\t\\t\\n        return head != NULL;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1164503,
                "title": "easy-to-understand-2-java-solution-using-two-pointers-beats-100",
                "content": "we will use two pointers slow and fast. if it is not a cyclic list then it will end in null so check that condition in while loop for fast pointer as it will aprroach to end first.\\nif it is cyclic list then sometimes slow and fast will always meet.\\nfor example consider a cricular Racing car track  one car is moving slow and one is moving fast just like our pointer now fast will finish first and if it keeps moving in circular track(like in this case) then on its way it will always meet the slow car , may be in first round may be in second but it will meet for sure.\\n\\n```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null){\\n            return false;\\n        }\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        \\n        while(fast.next != null && fast.next.next != null){     \\n            slow = slow.next;\\n            fast = fast.next.next;\\n            \\n             if(slow == fast){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n\\nApproach 2(Point the next of every node to head and check it some node\\'s next is already pointing to head it means there is a cycle in linked list\\n```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null){\\n            return false;\\n        }\\n        ListNode curr = head;\\n        ListNode next = head.next;\\n        \\n        while(curr != null && curr.next != null){\\n            if(curr.next == head){\\n                return true;\\n            }\\n            next = curr.next;//secure the remaining chain so that we don\\'t loose it after changing the link\\n            curr.next = head; // pointing every pointer to head\\n            curr = next; // iteration logic\\n            \\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null){\\n            return false;\\n        }\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        \\n        while(fast.next != null && fast.next.next != null){     \\n            slow = slow.next;\\n            fast = fast.next.next;\\n            \\n             if(slow == fast){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null){\\n            return false;\\n        }\\n        ListNode curr = head;\\n        ListNode next = head.next;\\n        \\n        while(curr != null && curr.next != null){\\n            if(curr.next == head){\\n                return true;\\n            }\\n            next = curr.next;//secure the remaining chain so that we don\\'t loose it after changing the link\\n            curr.next = head; // pointing every pointer to head\\n            curr = next; // iteration logic\\n            \\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1088956,
                "title": "destructively-fast-python-faster-than-99-o-n-time-o-1-space",
                "content": "Seeing this problem, a couple things come to mind:\\n\\nWe have to traverse the entire linked list -> leading to minimum O(n) runtime. \\n\\nWhen does this worst case occur? In the case that there is no cycle, or the last node creates the cycle.\\n\\nWe alse need to ensure that if there is a cycle, we are not looping around endlessly.\\n\\nOne way to solve this would be to keep a record of what nodes we have seen, and then check each time, however this increases space complexity (This is a good start though)\\n\\nIf we allow ourself to destruct the original list -> we can just set the value of the nodes we have seen to None, and then check the value each time to make sure it is not None (we havent seen it). If we have seen it, so value is None, return True (Cycle Exists)\\n\\nElse, the loop will reach the end of the linkedlist and return False.\\n\\n```\\n    def hasCycle(self, head: ListNode) -> bool:        \\n        curr = head\\n        \\n        while curr:\\n            if curr.val is None:\\n                return True\\n            curr.val = None\\n            curr = curr.next\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\n    def hasCycle(self, head: ListNode) -> bool:        \\n        curr = head\\n        \\n        while curr:\\n            if curr.val is None:\\n                return True\\n            curr.val = None\\n            curr = curr.next\\n        \\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1048061,
                "title": "linkedlistcycle-two-solutions-fully-explained-3ms-0ms",
                "content": "Key problem is that there is a linked list which may loop back on itself, forming a cycle.\\nWhen walking the list the cycle can be detected by noticing that the tail node points to a node that has already been seen.\\n\\nMy initial approach was to use a set to maintain a set of nodes previously traversed. Then if I came across a node already in the set I had a cycle. This ran in 3ms.\\n\\nA better approach was to use [Floyd\\'s Tortoise and Hare algorithm](https://en.wikipedia.org/wiki/Cycle_detection#Floyd\\'s_tortoise_and_hare). This ran in 0ms.\\n\\nBoth algorithms are outlined below:\\n\\n**Set Based Algorithm**\\nThis maintains a set of previously visited nodes. If a pointer to a null node is reached then the algorithm terminates, otherwise it checks the current node against the set and if it already exists then a cycle has been found.\\n\\n**Time Complexity O(N)** as adding/checking entries in the set is O(1) and we run until we find the cycle or reach the end.\\n**Space Complexity O(N)** because we maintain a set of all the previously seen nodes and we will not detect a cycle until we have seen all nodes and added them to the set.\\n\\n**Algorithm**\\n* While node != null\\n\\t* if set contains node then found a cycle\\n\\t\\t* return false\\n\\t* Add node to set\\n\\t* Set node to successor node\\n* return false as found a null\\n\\nNote the code below could be improved by noting that the add operation returns false if the iterm is already in the set, reducing the number of calls in the loop to the set by half. This would change the code to\\n```\\n\\t\\tif (!set.add(head))\\n\\t\\t\\treturn true;\\n```\\nwhich is more efficient but I feel lacks some clarity of purpose.\\n```\\npublic boolean hasCycle(ListNode head) {\\n\\tSet<ListNode> set = new HashSet<>();\\n\\twhile (head != null) {\\n\\t\\tif (set.contains(head))\\n\\t\\t\\treturn true;\\n\\t\\tset.add(head);\\n\\t\\thead = head.next;\\n\\t}\\n\\treturn false;\\n}\\n```\\n\\n**Floyd\\'s Tortoise & Hare Algorithm**\\nThe [Wikipedia article](https://en.wikipedia.org/wiki/Cycle_detection#Floyd\\'s_tortoise_and_hare) mentioned above is a little technical but the concept is very simple. We maintain two pointers, a slow pointer and a fast pointer. The slow pointer moves one node at a time while the fast pointer moves two nodes at a time. Eventually both pointers will be going around the cycle. Because of this we can imagine that the fast pointer is behind the slow pointer and  closes in on it one node at a time. This means that the fast pointer will always catch up with the slow pointer. For example if the fast pointer is 3 nodes behind the slow pointer (remember that this is a cycle so in one sense the fast pointer is always behind the slow pointer), then the slow pointer moves one node to open the gap to four nodes, but the fast pointer moves two nodes to reduce the gap to two node, thus closing the gap by one node. So for a loop of K nodes the fast pointer will always reach the slow pointer in at most K steps of the slow pointer.\\n\\nThis algorithm ran in 0ms.\\n\\n**Time Complexity O(N)** because slow pointer takes N-K steps to reach K sized cycle and once in the cycle in worst case fast pointer will reach it in K steps. So total complexity is O(3N) as we do two fast pointer operations for every slow pointer operation.\\n\\n**Space Complexity O(1)** as no extra storage required beyond fast and slow pointers.\\n\\n**Algorithm**\\n* If head or head.next is null reach end without cycle\\n\\t* return false\\n* Initialise slow pointer to head and fast pointer to successor to head\\n* While fast ! = slow\\n\\t* Check if either of next two nodes for fast are null, if so then no cycles\\n\\t\\t* return false\\n\\t* Move slow to next node\\n\\t* Move fast two nodes ahead\\n* return true as fast and slow are pointing to same node so muct be a cycle\\n```\\npublic boolean hasCycle(ListNode head) {\\n\\tif (head == null || head.next == null)\\n\\t\\treturn false;\\n\\tListNode slow = head;\\n\\tListNode fast = head.next;\\n\\twhile (slow != fast) {\\n\\t\\tif (fast.next == null || fast.next.next == null)\\n\\t\\t\\treturn false;\\n\\t\\tslow = slow.next;\\n\\t\\tfast = fast.next.next;\\n\\t}\\n\\treturn true;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\tif (!set.add(head))\\n\\t\\t\\treturn true;\\n```\n```\\npublic boolean hasCycle(ListNode head) {\\n\\tSet<ListNode> set = new HashSet<>();\\n\\twhile (head != null) {\\n\\t\\tif (set.contains(head))\\n\\t\\t\\treturn true;\\n\\t\\tset.add(head);\\n\\t\\thead = head.next;\\n\\t}\\n\\treturn false;\\n}\\n```\n```\\npublic boolean hasCycle(ListNode head) {\\n\\tif (head == null || head.next == null)\\n\\t\\treturn false;\\n\\tListNode slow = head;\\n\\tListNode fast = head.next;\\n\\twhile (slow != fast) {\\n\\t\\tif (fast.next == null || fast.next.next == null)\\n\\t\\t\\treturn false;\\n\\t\\tslow = slow.next;\\n\\t\\tfast = fast.next.next;\\n\\t}\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1047745,
                "title": "o-n-easy-solution-no-slow-and-fast-pointer-no-maping-for-visited-node-only-constraint-analysis",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        int test=-1*999999;\\n        while(head)\\n        {\\n            if(head->val==test)\\n                return true;\\n            head->val=test;\\n            head=head->next;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        int test=-1*999999;\\n        while(head)\\n        {\\n            if(head->val==test)\\n                return true;\\n            head->val=test;\\n            head=head->next;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030589,
                "title": "easy-solution-without-hashtable-and-floyd-s-cycle-finding-algorithm",
                "content": "The key idea is to use constraint `-10^5 <= Node.val <= 10^5`.\\n1. Choose value out of range, for example `Int32.MaxValue`\\n2. Traverse LinkedList\\n3. Mark all nodes with chosen value\\n4. Once we meet chosen value -> we have a cycle!\\n```\\npublic class Solution {\\n    public bool HasCycle(ListNode head) {\\n        var cycle = Int32.MaxValue;\\n        while(head != null)\\n        {\\n            if(head.val == cycle) return true;\\n            head.val = cycle;\\n            head = head.next;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public bool HasCycle(ListNode head) {\\n        var cycle = Int32.MaxValue;\\n        while(head != null)\\n        {\\n            if(head.val == cycle) return true;\\n            head.val = cycle;\\n            head = head.next;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856032,
                "title": "ruby-thank-you-safe-navigation-operator",
                "content": "```ruby\\ndef hasCycle(head)\\n  return false unless head\\n  hare = tortoise = head\\n\\n  loop do\\n    return false unless hare = hare&.next&.next\\n    tortoise = tortoise.next\\n    return true if hare == tortoise\\n  end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef hasCycle(head)\\n  return false unless head\\n  hare = tortoise = head\\n\\n  loop do\\n    return false unless hare = hare&.next&.next\\n    tortoise = tortoise.next\\n    return true if hare == tortoise\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 816171,
                "title": "c-solution",
                "content": "```\\nbool hasCycle(struct ListNode *head) {\\n    for(; head!=NULL; head = head->next)\\n    {\\n        if(head->val == -100000)\\n            return true;\\n        head->val = -100000;   \\n    }\\n    return false;\\n}\\n```\\nI used -100000, but there wasn\\'t any indication about the range of values, in this case btw it works",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool hasCycle(struct ListNode *head) {\\n    for(; head!=NULL; head = head->next)\\n    {\\n        if(head->val == -100000)\\n            return true;\\n        head->val = -100000;   \\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564592,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1566358,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1566128,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1575449,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1570510,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1566240,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1570016,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1569995,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1662891,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1838322,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1564592,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1566358,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1566128,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1575449,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1570510,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1566240,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1570016,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1569995,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1662891,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1838322,
                "content": [
                    {
                        "username": "HT_Wang",
                        "content": "I don\\'t see why we need \\'pos\\' in the inputs, while we don\\'t see it in the code. It\\'s kind confusing."
                    },
                    {
                        "username": "Jayant_Rajput",
                        "content": "pos is not included as parameter. It is discussed in description for us to understand the concept of looping in linked-list, so no need to worry about this pos while solving."
                    },
                    {
                        "username": "mochy",
                        "content": "The ACTUAL reason `pos` is included is to distinguish between testcases, which is especially useful for custom testcases because you can select which index to cycle to."
                    },
                    {
                        "username": "vani-shivanand",
                        "content": "`pos` is not passed as a parameter. It\\'s only for the us to see if there is a loop. Because we can\\'t make it out through inputs."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Also, I think is used for test cases."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "It is for us to know that linked list is circular at some point or not (in the console box)."
                    },
                    {
                        "username": "pstrait",
                        "content": "You don\\'t see any elements of the list besides the head in the code. You have to traverse the list to see the elements. the \\'pos\\' is just telling you if the last element in the list points to any of the previous elements. That\\'s literally the thing that you are trying to discover here."
                    },
                    {
                        "username": "AymenSekhri",
                        "content": "I\\'m confused why `pos` is a input and not in argument list ?"
                    },
                    {
                        "username": "lycuid",
                        "content": "useful if you wanna add your own custom testcases."
                    },
                    {
                        "username": "user7734BK",
                        "content": "pos is needed to understand the assignment, it\\'s not an input. It\\'s your goal to find pos (although you don\\'t need to return its value)"
                    },
                    {
                        "username": "jasonbayk",
                        "content": "The \"pos\" should not be a part of the input, in fact it is not known a priori. Should be removed for better clarity."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@jasonbayk](/jasonbayk)     \"pos\" is used for telling the position from where loop is present and that value is for using in our code but for internal code which check all test cases.  (I think so , any suggestions are welcomed)"
                    },
                    {
                        "username": "justdvl",
                        "content": "Can someone please explain this task? Not solution, I don\\'t understand the task itself."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In conventional `singly linear linked lists`, the last node of the list points to NULL.\\nHere you have to find whether the last node is pointing to NULL (hence not forming any loop) or\\nthe last node is pointing to one of the previous nodes (hence forming a loop)\\n\\nIn the case of loop, linear traversal will end up in an infinite loop (hence you will never reach to the state where `temp->next == NULL`."
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "[@sprodaturu](/sprodaturu) To check if the pos has been visited you would have to store all visited nodes in a data structure and therefore the space complexity would not be constant as the task is demanding."
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "[@sdhru](/sdhru) The only way I know I\\'ve reached the end of a list is when next is null, but if it\\'s never null, then how do you know you reached the end?"
                    },
                    {
                        "username": "sprodaturu",
                        "content": "[[@amanuelgaromsa](/amanuelgaromsa) If the last node is pointing to another node, it means we have a cycle, which we had to find. Include a condition like the pos is already visited then break the loop and return based on the position you are at."
                    },
                    {
                        "username": "amanuelgaromsa",
                        "content": "[@sdhru](/sdhru) how can we terminate the traverse if the last node is still pointing to another node?\\n\\n"
                    },
                    {
                        "username": "sdhru",
                        "content": "If we iterate through a linked list in conventional way(head = head.next) . We need to find if the next pointer of the last node points to null value or to a prepresent node in the list"
                    },
                    {
                        "username": "captainpromoted",
                        "content": "We can prove it using relative velocity kind of thing.\\n\\nIf there is a cycle then there will be a time when walker will enter the cycle for the first time.\\n\\nAt that moment runner will already be present in the cycle(because he was fast and ahead).\\n\\nNow if the runner is also on the same node as walker problem solved.\\n\\nOtherwise If both fast and slow are on different nodes on cycle then relative velocity of runner with respect to walker is one node per iteration (because walker moves one step then runner moves two step therefore relative velocity is 2 - 1 = 1 it can we viewed as runner is closing in on walker). So that means runner will surely catch the walker."
                    },
                    {
                        "username": "user0899B",
                        "content": "That\\'s a very clever way to think about it."
                    },
                    {
                        "username": "uralbekxd",
                        "content": "[@swisstackle](/swisstackle) by comparing obj address in memory"
                    },
                    {
                        "username": "Emerold",
                        "content": "[@swisstackle](/swisstackle) To know whether the runner and the walker point to the same object you can just check for object equality. In Java you can do so simply by using \\'==\\'. No need to look at the values."
                    },
                    {
                        "username": "swisstackle",
                        "content": "But how do you compare the nodes? Is val distinct? It doesn\\'t guarantee it in the problem description."
                    },
                    {
                        "username": "Decision",
                        "content": "My code is O(n<sup>2</sup>) and was told time exceeded.\\n\\nI define a variable called *flags*, where *flags* is a big number, (ie: *flags*=2<sup>31</sup>)\\n\\nAs I iterate the list from head, I change the node's value to be *flags*. When i found the value of the current node is *flags*, that means the list has a cycle."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@DevPro1993](/DevPro1993)  its absolutely beginners approach but it may work here because of the value of each node cannot exeed 10^5\nOptimization: 2 pointers fast and slow"
                    },
                    {
                        "username": "DevPro1993",
                        "content": "Actually, just comparing the value wont work since there can be multiple nodes in the list with same value"
                    },
                    {
                        "username": "sbrytskyy",
                        "content": "Could someone please explain, how to understand input \"Input: head = [3,2,0,-4], pos = 1\" if there is just \"ListNode head\" as an input to method (e.g. Java code)?\\n"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@idraksheikh333](/idraksheikh333) Right, simple interpretation is: -1 means \"No cycle\" other than that there is a cycle."
                    },
                    {
                        "username": "idraksheikh333",
                        "content": "It is just for our understanding that the following list has [3, 2, 0, -4] nodes with the last node has the reference of the node at 1 index that is node with data 2 and when the pos is -1 the there is no cycle \\n"
                    },
                    {
                        "username": "RyanCarrierIsCoding",
                        "content": "Hello everyone, can you expalin me how could I get Pos please ? It doesn\\'t appears in the function definition, just the Node appears"
                    },
                    {
                        "username": "bhavanagurram14",
                        "content": "Ignore the pos, it does not come in the input as well."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "what does pos = -1  mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "It\\'s the tail pointing to the node at index -1, which doesn\\'t exist and therefore is null. So yes, it\\'s the tail pointing to null. "
                    },
                    {
                        "username": "Vithesh",
                        "content": "Guys don\\'t worry if you cant answer it. its just that you guys don\\'t know about fast and slow pointer algorithm of linked list."
                    }
                ]
            },
            {
                "id": 1652162,
                "content": [
                    {
                        "username": "YananLyu",
                        "content": "if there is cycle, it would meet together,\\nif there is no cycle, it would reach out to tail.\\n\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n\\n        while(fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (fast == slow) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@codymorazan](/codymorazan) Exactly! I\\'m thinking about the same and looks like it doesn\\'t matter. From the description it\\'s not clear that the cycle can\\'t be between first and last nodes. Or I could understand that moment. \\nCould someone explain? \\n"
                    },
                    {
                        "username": "codymorazan",
                        "content": "Doesn\\'t this only account for cycles that exist either 1 or 2 indices behind the farthest pointer? How does this account for pointer with large spaces in between them, say 1 -> 2 -> 3 -> 4 -> 5 -> 1?"
                    },
                    {
                        "username": "jabberwky",
                        "content": "Where is the `pos` input parameter in the input?\\nThe question is just simply checking if there is a loop in the linked list."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the Tortoise and Hare algorithm\\n\\nhttps://youtu.be/RRSItF-Ts4Q"
                    },
                    {
                        "username": "anon301176",
                        "content": "my solution is failing under this test case: [-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5] very clearly there is a loop in this data, but its telling me i should be returning false. can someone explain this?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "If pos == -1, than it should return false."
                    },
                    {
                        "username": "amiramri",
                        "content": "How did you find that there is a loop? are you saying that base on the existing of the same value more than once? if so you are not correct. we can have different nodes with the same value."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I would not be so sure that there is a cycle. The same value doesn\\'t mean that it is the same Object. \\nI could create two ListNodes like this: \\nvar a = new ListNode(1) and\\nvar b = new ListNode(1), \\nthey will be different Objects, thus a == b will return false (but a.equals(b) may return true, if it\\'s implemented correctly).\\nNow, for this task we are compering reference a and b, not values. Think about it in terms of OOP.  "
                    },
                    {
                        "username": "krenast",
                        "content": "I understand how to answer the question, however I am still struggling how can I perform test case on my computer (construct the list and the linkedlist). Can someone can explain me how to code it ?\\n\\nThanks!"
                    },
                    {
                        "username": "user2903My",
                        "content": "You\\'ve commented part of code in code editor. For this task it\\'s looks like \"\\n* class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\"\\nOnly one that you can do - it\\'s create instances of all ListNode intances and set next property for everyone to next created instance"
                    },
                    {
                        "username": "maheshdeverapu",
                        "content": "[@njalgo](/njalgo) no need of constructing list and linkedlist. just take head as linkedlist and perform the logic and return the sol."
                    },
                    {
                        "username": "njalgo",
                        "content": "On your local computer, just set the Next pointer of the last node to any previous node. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked list problem! A hint: just use 2 pointers 1 fast & 1 slow. It\\'s fine."
                    },
                    {
                        "username": "ybank",
                        "content": "Basically, I came up with an accepted solution without using extra space, but destructed the linked list internally. The way I did was that after traversing the current node but before moving to the next node, I make the next pointer pointing to the current node.\\n\\nThis works fine but resetting the next pointer really annoys me. Other solutions I saw from the discussions either change the next pointers in other ways, or rely on a lucky number for the val of the node.\\n\\nI was wondering if anyone has a non-destructive solution, in the way that it preserves all the next pointers, that uses no extra space?\\n\\nThanks!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/linked-list-cycle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Cycle Finding Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tifv",
                        "content": "Hey, LeetCode, what the hell? I was happily writing Rust solutions for 126 days straight\\u2026"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Maybe LeetCode doesn\\'t want to change the design of struct from using `next: Option<Box<ListNode>>`..."
                    },
                    {
                        "username": "SheekhaJ",
                        "content": "Hi, \\n\\nThe question mentions that pos is used to identify the location where the tail connects to. How is this being used during judging? \\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1569603,
                "content": [
                    {
                        "username": "YananLyu",
                        "content": "if there is cycle, it would meet together,\\nif there is no cycle, it would reach out to tail.\\n\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n\\n        while(fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (fast == slow) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@codymorazan](/codymorazan) Exactly! I\\'m thinking about the same and looks like it doesn\\'t matter. From the description it\\'s not clear that the cycle can\\'t be between first and last nodes. Or I could understand that moment. \\nCould someone explain? \\n"
                    },
                    {
                        "username": "codymorazan",
                        "content": "Doesn\\'t this only account for cycles that exist either 1 or 2 indices behind the farthest pointer? How does this account for pointer with large spaces in between them, say 1 -> 2 -> 3 -> 4 -> 5 -> 1?"
                    },
                    {
                        "username": "jabberwky",
                        "content": "Where is the `pos` input parameter in the input?\\nThe question is just simply checking if there is a loop in the linked list."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the Tortoise and Hare algorithm\\n\\nhttps://youtu.be/RRSItF-Ts4Q"
                    },
                    {
                        "username": "anon301176",
                        "content": "my solution is failing under this test case: [-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5] very clearly there is a loop in this data, but its telling me i should be returning false. can someone explain this?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "If pos == -1, than it should return false."
                    },
                    {
                        "username": "amiramri",
                        "content": "How did you find that there is a loop? are you saying that base on the existing of the same value more than once? if so you are not correct. we can have different nodes with the same value."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I would not be so sure that there is a cycle. The same value doesn\\'t mean that it is the same Object. \\nI could create two ListNodes like this: \\nvar a = new ListNode(1) and\\nvar b = new ListNode(1), \\nthey will be different Objects, thus a == b will return false (but a.equals(b) may return true, if it\\'s implemented correctly).\\nNow, for this task we are compering reference a and b, not values. Think about it in terms of OOP.  "
                    },
                    {
                        "username": "krenast",
                        "content": "I understand how to answer the question, however I am still struggling how can I perform test case on my computer (construct the list and the linkedlist). Can someone can explain me how to code it ?\\n\\nThanks!"
                    },
                    {
                        "username": "user2903My",
                        "content": "You\\'ve commented part of code in code editor. For this task it\\'s looks like \"\\n* class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\"\\nOnly one that you can do - it\\'s create instances of all ListNode intances and set next property for everyone to next created instance"
                    },
                    {
                        "username": "maheshdeverapu",
                        "content": "[@njalgo](/njalgo) no need of constructing list and linkedlist. just take head as linkedlist and perform the logic and return the sol."
                    },
                    {
                        "username": "njalgo",
                        "content": "On your local computer, just set the Next pointer of the last node to any previous node. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked list problem! A hint: just use 2 pointers 1 fast & 1 slow. It\\'s fine."
                    },
                    {
                        "username": "ybank",
                        "content": "Basically, I came up with an accepted solution without using extra space, but destructed the linked list internally. The way I did was that after traversing the current node but before moving to the next node, I make the next pointer pointing to the current node.\\n\\nThis works fine but resetting the next pointer really annoys me. Other solutions I saw from the discussions either change the next pointers in other ways, or rely on a lucky number for the val of the node.\\n\\nI was wondering if anyone has a non-destructive solution, in the way that it preserves all the next pointers, that uses no extra space?\\n\\nThanks!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/linked-list-cycle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Cycle Finding Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tifv",
                        "content": "Hey, LeetCode, what the hell? I was happily writing Rust solutions for 126 days straight\\u2026"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Maybe LeetCode doesn\\'t want to change the design of struct from using `next: Option<Box<ListNode>>`..."
                    },
                    {
                        "username": "SheekhaJ",
                        "content": "Hi, \\n\\nThe question mentions that pos is used to identify the location where the tail connects to. How is this being used during judging? \\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1992444,
                "content": [
                    {
                        "username": "YananLyu",
                        "content": "if there is cycle, it would meet together,\\nif there is no cycle, it would reach out to tail.\\n\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n\\n        while(fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (fast == slow) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@codymorazan](/codymorazan) Exactly! I\\'m thinking about the same and looks like it doesn\\'t matter. From the description it\\'s not clear that the cycle can\\'t be between first and last nodes. Or I could understand that moment. \\nCould someone explain? \\n"
                    },
                    {
                        "username": "codymorazan",
                        "content": "Doesn\\'t this only account for cycles that exist either 1 or 2 indices behind the farthest pointer? How does this account for pointer with large spaces in between them, say 1 -> 2 -> 3 -> 4 -> 5 -> 1?"
                    },
                    {
                        "username": "jabberwky",
                        "content": "Where is the `pos` input parameter in the input?\\nThe question is just simply checking if there is a loop in the linked list."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the Tortoise and Hare algorithm\\n\\nhttps://youtu.be/RRSItF-Ts4Q"
                    },
                    {
                        "username": "anon301176",
                        "content": "my solution is failing under this test case: [-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5] very clearly there is a loop in this data, but its telling me i should be returning false. can someone explain this?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "If pos == -1, than it should return false."
                    },
                    {
                        "username": "amiramri",
                        "content": "How did you find that there is a loop? are you saying that base on the existing of the same value more than once? if so you are not correct. we can have different nodes with the same value."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I would not be so sure that there is a cycle. The same value doesn\\'t mean that it is the same Object. \\nI could create two ListNodes like this: \\nvar a = new ListNode(1) and\\nvar b = new ListNode(1), \\nthey will be different Objects, thus a == b will return false (but a.equals(b) may return true, if it\\'s implemented correctly).\\nNow, for this task we are compering reference a and b, not values. Think about it in terms of OOP.  "
                    },
                    {
                        "username": "krenast",
                        "content": "I understand how to answer the question, however I am still struggling how can I perform test case on my computer (construct the list and the linkedlist). Can someone can explain me how to code it ?\\n\\nThanks!"
                    },
                    {
                        "username": "user2903My",
                        "content": "You\\'ve commented part of code in code editor. For this task it\\'s looks like \"\\n* class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\"\\nOnly one that you can do - it\\'s create instances of all ListNode intances and set next property for everyone to next created instance"
                    },
                    {
                        "username": "maheshdeverapu",
                        "content": "[@njalgo](/njalgo) no need of constructing list and linkedlist. just take head as linkedlist and perform the logic and return the sol."
                    },
                    {
                        "username": "njalgo",
                        "content": "On your local computer, just set the Next pointer of the last node to any previous node. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked list problem! A hint: just use 2 pointers 1 fast & 1 slow. It\\'s fine."
                    },
                    {
                        "username": "ybank",
                        "content": "Basically, I came up with an accepted solution without using extra space, but destructed the linked list internally. The way I did was that after traversing the current node but before moving to the next node, I make the next pointer pointing to the current node.\\n\\nThis works fine but resetting the next pointer really annoys me. Other solutions I saw from the discussions either change the next pointers in other ways, or rely on a lucky number for the val of the node.\\n\\nI was wondering if anyone has a non-destructive solution, in the way that it preserves all the next pointers, that uses no extra space?\\n\\nThanks!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/linked-list-cycle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Cycle Finding Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tifv",
                        "content": "Hey, LeetCode, what the hell? I was happily writing Rust solutions for 126 days straight\\u2026"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Maybe LeetCode doesn\\'t want to change the design of struct from using `next: Option<Box<ListNode>>`..."
                    },
                    {
                        "username": "SheekhaJ",
                        "content": "Hi, \\n\\nThe question mentions that pos is used to identify the location where the tail connects to. How is this being used during judging? \\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1801398,
                "content": [
                    {
                        "username": "YananLyu",
                        "content": "if there is cycle, it would meet together,\\nif there is no cycle, it would reach out to tail.\\n\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n\\n        while(fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (fast == slow) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@codymorazan](/codymorazan) Exactly! I\\'m thinking about the same and looks like it doesn\\'t matter. From the description it\\'s not clear that the cycle can\\'t be between first and last nodes. Or I could understand that moment. \\nCould someone explain? \\n"
                    },
                    {
                        "username": "codymorazan",
                        "content": "Doesn\\'t this only account for cycles that exist either 1 or 2 indices behind the farthest pointer? How does this account for pointer with large spaces in between them, say 1 -> 2 -> 3 -> 4 -> 5 -> 1?"
                    },
                    {
                        "username": "jabberwky",
                        "content": "Where is the `pos` input parameter in the input?\\nThe question is just simply checking if there is a loop in the linked list."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the Tortoise and Hare algorithm\\n\\nhttps://youtu.be/RRSItF-Ts4Q"
                    },
                    {
                        "username": "anon301176",
                        "content": "my solution is failing under this test case: [-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5] very clearly there is a loop in this data, but its telling me i should be returning false. can someone explain this?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "If pos == -1, than it should return false."
                    },
                    {
                        "username": "amiramri",
                        "content": "How did you find that there is a loop? are you saying that base on the existing of the same value more than once? if so you are not correct. we can have different nodes with the same value."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I would not be so sure that there is a cycle. The same value doesn\\'t mean that it is the same Object. \\nI could create two ListNodes like this: \\nvar a = new ListNode(1) and\\nvar b = new ListNode(1), \\nthey will be different Objects, thus a == b will return false (but a.equals(b) may return true, if it\\'s implemented correctly).\\nNow, for this task we are compering reference a and b, not values. Think about it in terms of OOP.  "
                    },
                    {
                        "username": "krenast",
                        "content": "I understand how to answer the question, however I am still struggling how can I perform test case on my computer (construct the list and the linkedlist). Can someone can explain me how to code it ?\\n\\nThanks!"
                    },
                    {
                        "username": "user2903My",
                        "content": "You\\'ve commented part of code in code editor. For this task it\\'s looks like \"\\n* class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\"\\nOnly one that you can do - it\\'s create instances of all ListNode intances and set next property for everyone to next created instance"
                    },
                    {
                        "username": "maheshdeverapu",
                        "content": "[@njalgo](/njalgo) no need of constructing list and linkedlist. just take head as linkedlist and perform the logic and return the sol."
                    },
                    {
                        "username": "njalgo",
                        "content": "On your local computer, just set the Next pointer of the last node to any previous node. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked list problem! A hint: just use 2 pointers 1 fast & 1 slow. It\\'s fine."
                    },
                    {
                        "username": "ybank",
                        "content": "Basically, I came up with an accepted solution without using extra space, but destructed the linked list internally. The way I did was that after traversing the current node but before moving to the next node, I make the next pointer pointing to the current node.\\n\\nThis works fine but resetting the next pointer really annoys me. Other solutions I saw from the discussions either change the next pointers in other ways, or rely on a lucky number for the val of the node.\\n\\nI was wondering if anyone has a non-destructive solution, in the way that it preserves all the next pointers, that uses no extra space?\\n\\nThanks!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/linked-list-cycle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Cycle Finding Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tifv",
                        "content": "Hey, LeetCode, what the hell? I was happily writing Rust solutions for 126 days straight\\u2026"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Maybe LeetCode doesn\\'t want to change the design of struct from using `next: Option<Box<ListNode>>`..."
                    },
                    {
                        "username": "SheekhaJ",
                        "content": "Hi, \\n\\nThe question mentions that pos is used to identify the location where the tail connects to. How is this being used during judging? \\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1573467,
                "content": [
                    {
                        "username": "YananLyu",
                        "content": "if there is cycle, it would meet together,\\nif there is no cycle, it would reach out to tail.\\n\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n\\n        while(fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (fast == slow) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@codymorazan](/codymorazan) Exactly! I\\'m thinking about the same and looks like it doesn\\'t matter. From the description it\\'s not clear that the cycle can\\'t be between first and last nodes. Or I could understand that moment. \\nCould someone explain? \\n"
                    },
                    {
                        "username": "codymorazan",
                        "content": "Doesn\\'t this only account for cycles that exist either 1 or 2 indices behind the farthest pointer? How does this account for pointer with large spaces in between them, say 1 -> 2 -> 3 -> 4 -> 5 -> 1?"
                    },
                    {
                        "username": "jabberwky",
                        "content": "Where is the `pos` input parameter in the input?\\nThe question is just simply checking if there is a loop in the linked list."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the Tortoise and Hare algorithm\\n\\nhttps://youtu.be/RRSItF-Ts4Q"
                    },
                    {
                        "username": "anon301176",
                        "content": "my solution is failing under this test case: [-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5] very clearly there is a loop in this data, but its telling me i should be returning false. can someone explain this?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "If pos == -1, than it should return false."
                    },
                    {
                        "username": "amiramri",
                        "content": "How did you find that there is a loop? are you saying that base on the existing of the same value more than once? if so you are not correct. we can have different nodes with the same value."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I would not be so sure that there is a cycle. The same value doesn\\'t mean that it is the same Object. \\nI could create two ListNodes like this: \\nvar a = new ListNode(1) and\\nvar b = new ListNode(1), \\nthey will be different Objects, thus a == b will return false (but a.equals(b) may return true, if it\\'s implemented correctly).\\nNow, for this task we are compering reference a and b, not values. Think about it in terms of OOP.  "
                    },
                    {
                        "username": "krenast",
                        "content": "I understand how to answer the question, however I am still struggling how can I perform test case on my computer (construct the list and the linkedlist). Can someone can explain me how to code it ?\\n\\nThanks!"
                    },
                    {
                        "username": "user2903My",
                        "content": "You\\'ve commented part of code in code editor. For this task it\\'s looks like \"\\n* class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\"\\nOnly one that you can do - it\\'s create instances of all ListNode intances and set next property for everyone to next created instance"
                    },
                    {
                        "username": "maheshdeverapu",
                        "content": "[@njalgo](/njalgo) no need of constructing list and linkedlist. just take head as linkedlist and perform the logic and return the sol."
                    },
                    {
                        "username": "njalgo",
                        "content": "On your local computer, just set the Next pointer of the last node to any previous node. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked list problem! A hint: just use 2 pointers 1 fast & 1 slow. It\\'s fine."
                    },
                    {
                        "username": "ybank",
                        "content": "Basically, I came up with an accepted solution without using extra space, but destructed the linked list internally. The way I did was that after traversing the current node but before moving to the next node, I make the next pointer pointing to the current node.\\n\\nThis works fine but resetting the next pointer really annoys me. Other solutions I saw from the discussions either change the next pointers in other ways, or rely on a lucky number for the val of the node.\\n\\nI was wondering if anyone has a non-destructive solution, in the way that it preserves all the next pointers, that uses no extra space?\\n\\nThanks!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/linked-list-cycle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Cycle Finding Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tifv",
                        "content": "Hey, LeetCode, what the hell? I was happily writing Rust solutions for 126 days straight\\u2026"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Maybe LeetCode doesn\\'t want to change the design of struct from using `next: Option<Box<ListNode>>`..."
                    },
                    {
                        "username": "SheekhaJ",
                        "content": "Hi, \\n\\nThe question mentions that pos is used to identify the location where the tail connects to. How is this being used during judging? \\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 2043260,
                "content": [
                    {
                        "username": "YananLyu",
                        "content": "if there is cycle, it would meet together,\\nif there is no cycle, it would reach out to tail.\\n\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n\\n        while(fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (fast == slow) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@codymorazan](/codymorazan) Exactly! I\\'m thinking about the same and looks like it doesn\\'t matter. From the description it\\'s not clear that the cycle can\\'t be between first and last nodes. Or I could understand that moment. \\nCould someone explain? \\n"
                    },
                    {
                        "username": "codymorazan",
                        "content": "Doesn\\'t this only account for cycles that exist either 1 or 2 indices behind the farthest pointer? How does this account for pointer with large spaces in between them, say 1 -> 2 -> 3 -> 4 -> 5 -> 1?"
                    },
                    {
                        "username": "jabberwky",
                        "content": "Where is the `pos` input parameter in the input?\\nThe question is just simply checking if there is a loop in the linked list."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the Tortoise and Hare algorithm\\n\\nhttps://youtu.be/RRSItF-Ts4Q"
                    },
                    {
                        "username": "anon301176",
                        "content": "my solution is failing under this test case: [-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5] very clearly there is a loop in this data, but its telling me i should be returning false. can someone explain this?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "If pos == -1, than it should return false."
                    },
                    {
                        "username": "amiramri",
                        "content": "How did you find that there is a loop? are you saying that base on the existing of the same value more than once? if so you are not correct. we can have different nodes with the same value."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I would not be so sure that there is a cycle. The same value doesn\\'t mean that it is the same Object. \\nI could create two ListNodes like this: \\nvar a = new ListNode(1) and\\nvar b = new ListNode(1), \\nthey will be different Objects, thus a == b will return false (but a.equals(b) may return true, if it\\'s implemented correctly).\\nNow, for this task we are compering reference a and b, not values. Think about it in terms of OOP.  "
                    },
                    {
                        "username": "krenast",
                        "content": "I understand how to answer the question, however I am still struggling how can I perform test case on my computer (construct the list and the linkedlist). Can someone can explain me how to code it ?\\n\\nThanks!"
                    },
                    {
                        "username": "user2903My",
                        "content": "You\\'ve commented part of code in code editor. For this task it\\'s looks like \"\\n* class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\"\\nOnly one that you can do - it\\'s create instances of all ListNode intances and set next property for everyone to next created instance"
                    },
                    {
                        "username": "maheshdeverapu",
                        "content": "[@njalgo](/njalgo) no need of constructing list and linkedlist. just take head as linkedlist and perform the logic and return the sol."
                    },
                    {
                        "username": "njalgo",
                        "content": "On your local computer, just set the Next pointer of the last node to any previous node. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked list problem! A hint: just use 2 pointers 1 fast & 1 slow. It\\'s fine."
                    },
                    {
                        "username": "ybank",
                        "content": "Basically, I came up with an accepted solution without using extra space, but destructed the linked list internally. The way I did was that after traversing the current node but before moving to the next node, I make the next pointer pointing to the current node.\\n\\nThis works fine but resetting the next pointer really annoys me. Other solutions I saw from the discussions either change the next pointers in other ways, or rely on a lucky number for the val of the node.\\n\\nI was wondering if anyone has a non-destructive solution, in the way that it preserves all the next pointers, that uses no extra space?\\n\\nThanks!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/linked-list-cycle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Cycle Finding Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tifv",
                        "content": "Hey, LeetCode, what the hell? I was happily writing Rust solutions for 126 days straight\\u2026"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Maybe LeetCode doesn\\'t want to change the design of struct from using `next: Option<Box<ListNode>>`..."
                    },
                    {
                        "username": "SheekhaJ",
                        "content": "Hi, \\n\\nThe question mentions that pos is used to identify the location where the tail connects to. How is this being used during judging? \\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1571307,
                "content": [
                    {
                        "username": "YananLyu",
                        "content": "if there is cycle, it would meet together,\\nif there is no cycle, it would reach out to tail.\\n\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n\\n        while(fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (fast == slow) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@codymorazan](/codymorazan) Exactly! I\\'m thinking about the same and looks like it doesn\\'t matter. From the description it\\'s not clear that the cycle can\\'t be between first and last nodes. Or I could understand that moment. \\nCould someone explain? \\n"
                    },
                    {
                        "username": "codymorazan",
                        "content": "Doesn\\'t this only account for cycles that exist either 1 or 2 indices behind the farthest pointer? How does this account for pointer with large spaces in between them, say 1 -> 2 -> 3 -> 4 -> 5 -> 1?"
                    },
                    {
                        "username": "jabberwky",
                        "content": "Where is the `pos` input parameter in the input?\\nThe question is just simply checking if there is a loop in the linked list."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the Tortoise and Hare algorithm\\n\\nhttps://youtu.be/RRSItF-Ts4Q"
                    },
                    {
                        "username": "anon301176",
                        "content": "my solution is failing under this test case: [-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5] very clearly there is a loop in this data, but its telling me i should be returning false. can someone explain this?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "If pos == -1, than it should return false."
                    },
                    {
                        "username": "amiramri",
                        "content": "How did you find that there is a loop? are you saying that base on the existing of the same value more than once? if so you are not correct. we can have different nodes with the same value."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I would not be so sure that there is a cycle. The same value doesn\\'t mean that it is the same Object. \\nI could create two ListNodes like this: \\nvar a = new ListNode(1) and\\nvar b = new ListNode(1), \\nthey will be different Objects, thus a == b will return false (but a.equals(b) may return true, if it\\'s implemented correctly).\\nNow, for this task we are compering reference a and b, not values. Think about it in terms of OOP.  "
                    },
                    {
                        "username": "krenast",
                        "content": "I understand how to answer the question, however I am still struggling how can I perform test case on my computer (construct the list and the linkedlist). Can someone can explain me how to code it ?\\n\\nThanks!"
                    },
                    {
                        "username": "user2903My",
                        "content": "You\\'ve commented part of code in code editor. For this task it\\'s looks like \"\\n* class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\"\\nOnly one that you can do - it\\'s create instances of all ListNode intances and set next property for everyone to next created instance"
                    },
                    {
                        "username": "maheshdeverapu",
                        "content": "[@njalgo](/njalgo) no need of constructing list and linkedlist. just take head as linkedlist and perform the logic and return the sol."
                    },
                    {
                        "username": "njalgo",
                        "content": "On your local computer, just set the Next pointer of the last node to any previous node. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked list problem! A hint: just use 2 pointers 1 fast & 1 slow. It\\'s fine."
                    },
                    {
                        "username": "ybank",
                        "content": "Basically, I came up with an accepted solution without using extra space, but destructed the linked list internally. The way I did was that after traversing the current node but before moving to the next node, I make the next pointer pointing to the current node.\\n\\nThis works fine but resetting the next pointer really annoys me. Other solutions I saw from the discussions either change the next pointers in other ways, or rely on a lucky number for the val of the node.\\n\\nI was wondering if anyone has a non-destructive solution, in the way that it preserves all the next pointers, that uses no extra space?\\n\\nThanks!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/linked-list-cycle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Cycle Finding Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tifv",
                        "content": "Hey, LeetCode, what the hell? I was happily writing Rust solutions for 126 days straight\\u2026"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Maybe LeetCode doesn\\'t want to change the design of struct from using `next: Option<Box<ListNode>>`..."
                    },
                    {
                        "username": "SheekhaJ",
                        "content": "Hi, \\n\\nThe question mentions that pos is used to identify the location where the tail connects to. How is this being used during judging? \\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1566212,
                "content": [
                    {
                        "username": "YananLyu",
                        "content": "if there is cycle, it would meet together,\\nif there is no cycle, it would reach out to tail.\\n\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n\\n        while(fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (fast == slow) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@codymorazan](/codymorazan) Exactly! I\\'m thinking about the same and looks like it doesn\\'t matter. From the description it\\'s not clear that the cycle can\\'t be between first and last nodes. Or I could understand that moment. \\nCould someone explain? \\n"
                    },
                    {
                        "username": "codymorazan",
                        "content": "Doesn\\'t this only account for cycles that exist either 1 or 2 indices behind the farthest pointer? How does this account for pointer with large spaces in between them, say 1 -> 2 -> 3 -> 4 -> 5 -> 1?"
                    },
                    {
                        "username": "jabberwky",
                        "content": "Where is the `pos` input parameter in the input?\\nThe question is just simply checking if there is a loop in the linked list."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the Tortoise and Hare algorithm\\n\\nhttps://youtu.be/RRSItF-Ts4Q"
                    },
                    {
                        "username": "anon301176",
                        "content": "my solution is failing under this test case: [-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5] very clearly there is a loop in this data, but its telling me i should be returning false. can someone explain this?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "If pos == -1, than it should return false."
                    },
                    {
                        "username": "amiramri",
                        "content": "How did you find that there is a loop? are you saying that base on the existing of the same value more than once? if so you are not correct. we can have different nodes with the same value."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I would not be so sure that there is a cycle. The same value doesn\\'t mean that it is the same Object. \\nI could create two ListNodes like this: \\nvar a = new ListNode(1) and\\nvar b = new ListNode(1), \\nthey will be different Objects, thus a == b will return false (but a.equals(b) may return true, if it\\'s implemented correctly).\\nNow, for this task we are compering reference a and b, not values. Think about it in terms of OOP.  "
                    },
                    {
                        "username": "krenast",
                        "content": "I understand how to answer the question, however I am still struggling how can I perform test case on my computer (construct the list and the linkedlist). Can someone can explain me how to code it ?\\n\\nThanks!"
                    },
                    {
                        "username": "user2903My",
                        "content": "You\\'ve commented part of code in code editor. For this task it\\'s looks like \"\\n* class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\"\\nOnly one that you can do - it\\'s create instances of all ListNode intances and set next property for everyone to next created instance"
                    },
                    {
                        "username": "maheshdeverapu",
                        "content": "[@njalgo](/njalgo) no need of constructing list and linkedlist. just take head as linkedlist and perform the logic and return the sol."
                    },
                    {
                        "username": "njalgo",
                        "content": "On your local computer, just set the Next pointer of the last node to any previous node. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked list problem! A hint: just use 2 pointers 1 fast & 1 slow. It\\'s fine."
                    },
                    {
                        "username": "ybank",
                        "content": "Basically, I came up with an accepted solution without using extra space, but destructed the linked list internally. The way I did was that after traversing the current node but before moving to the next node, I make the next pointer pointing to the current node.\\n\\nThis works fine but resetting the next pointer really annoys me. Other solutions I saw from the discussions either change the next pointers in other ways, or rely on a lucky number for the val of the node.\\n\\nI was wondering if anyone has a non-destructive solution, in the way that it preserves all the next pointers, that uses no extra space?\\n\\nThanks!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/linked-list-cycle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Cycle Finding Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tifv",
                        "content": "Hey, LeetCode, what the hell? I was happily writing Rust solutions for 126 days straight\\u2026"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Maybe LeetCode doesn\\'t want to change the design of struct from using `next: Option<Box<ListNode>>`..."
                    },
                    {
                        "username": "SheekhaJ",
                        "content": "Hi, \\n\\nThe question mentions that pos is used to identify the location where the tail connects to. How is this being used during judging? \\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 2043317,
                "content": [
                    {
                        "username": "YananLyu",
                        "content": "if there is cycle, it would meet together,\\nif there is no cycle, it would reach out to tail.\\n\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n\\n        while(fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (fast == slow) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@codymorazan](/codymorazan) Exactly! I\\'m thinking about the same and looks like it doesn\\'t matter. From the description it\\'s not clear that the cycle can\\'t be between first and last nodes. Or I could understand that moment. \\nCould someone explain? \\n"
                    },
                    {
                        "username": "codymorazan",
                        "content": "Doesn\\'t this only account for cycles that exist either 1 or 2 indices behind the farthest pointer? How does this account for pointer with large spaces in between them, say 1 -> 2 -> 3 -> 4 -> 5 -> 1?"
                    },
                    {
                        "username": "jabberwky",
                        "content": "Where is the `pos` input parameter in the input?\\nThe question is just simply checking if there is a loop in the linked list."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the Tortoise and Hare algorithm\\n\\nhttps://youtu.be/RRSItF-Ts4Q"
                    },
                    {
                        "username": "anon301176",
                        "content": "my solution is failing under this test case: [-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5] very clearly there is a loop in this data, but its telling me i should be returning false. can someone explain this?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "If pos == -1, than it should return false."
                    },
                    {
                        "username": "amiramri",
                        "content": "How did you find that there is a loop? are you saying that base on the existing of the same value more than once? if so you are not correct. we can have different nodes with the same value."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I would not be so sure that there is a cycle. The same value doesn\\'t mean that it is the same Object. \\nI could create two ListNodes like this: \\nvar a = new ListNode(1) and\\nvar b = new ListNode(1), \\nthey will be different Objects, thus a == b will return false (but a.equals(b) may return true, if it\\'s implemented correctly).\\nNow, for this task we are compering reference a and b, not values. Think about it in terms of OOP.  "
                    },
                    {
                        "username": "krenast",
                        "content": "I understand how to answer the question, however I am still struggling how can I perform test case on my computer (construct the list and the linkedlist). Can someone can explain me how to code it ?\\n\\nThanks!"
                    },
                    {
                        "username": "user2903My",
                        "content": "You\\'ve commented part of code in code editor. For this task it\\'s looks like \"\\n* class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\"\\nOnly one that you can do - it\\'s create instances of all ListNode intances and set next property for everyone to next created instance"
                    },
                    {
                        "username": "maheshdeverapu",
                        "content": "[@njalgo](/njalgo) no need of constructing list and linkedlist. just take head as linkedlist and perform the logic and return the sol."
                    },
                    {
                        "username": "njalgo",
                        "content": "On your local computer, just set the Next pointer of the last node to any previous node. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked list problem! A hint: just use 2 pointers 1 fast & 1 slow. It\\'s fine."
                    },
                    {
                        "username": "ybank",
                        "content": "Basically, I came up with an accepted solution without using extra space, but destructed the linked list internally. The way I did was that after traversing the current node but before moving to the next node, I make the next pointer pointing to the current node.\\n\\nThis works fine but resetting the next pointer really annoys me. Other solutions I saw from the discussions either change the next pointers in other ways, or rely on a lucky number for the val of the node.\\n\\nI was wondering if anyone has a non-destructive solution, in the way that it preserves all the next pointers, that uses no extra space?\\n\\nThanks!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/linked-list-cycle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Cycle Finding Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tifv",
                        "content": "Hey, LeetCode, what the hell? I was happily writing Rust solutions for 126 days straight\\u2026"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Maybe LeetCode doesn\\'t want to change the design of struct from using `next: Option<Box<ListNode>>`..."
                    },
                    {
                        "username": "SheekhaJ",
                        "content": "Hi, \\n\\nThe question mentions that pos is used to identify the location where the tail connects to. How is this being used during judging? \\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1569830,
                "content": [
                    {
                        "username": "YananLyu",
                        "content": "if there is cycle, it would meet together,\\nif there is no cycle, it would reach out to tail.\\n\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n\\n        while(fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (fast == slow) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@codymorazan](/codymorazan) Exactly! I\\'m thinking about the same and looks like it doesn\\'t matter. From the description it\\'s not clear that the cycle can\\'t be between first and last nodes. Or I could understand that moment. \\nCould someone explain? \\n"
                    },
                    {
                        "username": "codymorazan",
                        "content": "Doesn\\'t this only account for cycles that exist either 1 or 2 indices behind the farthest pointer? How does this account for pointer with large spaces in between them, say 1 -> 2 -> 3 -> 4 -> 5 -> 1?"
                    },
                    {
                        "username": "jabberwky",
                        "content": "Where is the `pos` input parameter in the input?\\nThe question is just simply checking if there is a loop in the linked list."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the Tortoise and Hare algorithm\\n\\nhttps://youtu.be/RRSItF-Ts4Q"
                    },
                    {
                        "username": "anon301176",
                        "content": "my solution is failing under this test case: [-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5] very clearly there is a loop in this data, but its telling me i should be returning false. can someone explain this?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "If pos == -1, than it should return false."
                    },
                    {
                        "username": "amiramri",
                        "content": "How did you find that there is a loop? are you saying that base on the existing of the same value more than once? if so you are not correct. we can have different nodes with the same value."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I would not be so sure that there is a cycle. The same value doesn\\'t mean that it is the same Object. \\nI could create two ListNodes like this: \\nvar a = new ListNode(1) and\\nvar b = new ListNode(1), \\nthey will be different Objects, thus a == b will return false (but a.equals(b) may return true, if it\\'s implemented correctly).\\nNow, for this task we are compering reference a and b, not values. Think about it in terms of OOP.  "
                    },
                    {
                        "username": "krenast",
                        "content": "I understand how to answer the question, however I am still struggling how can I perform test case on my computer (construct the list and the linkedlist). Can someone can explain me how to code it ?\\n\\nThanks!"
                    },
                    {
                        "username": "user2903My",
                        "content": "You\\'ve commented part of code in code editor. For this task it\\'s looks like \"\\n* class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\"\\nOnly one that you can do - it\\'s create instances of all ListNode intances and set next property for everyone to next created instance"
                    },
                    {
                        "username": "maheshdeverapu",
                        "content": "[@njalgo](/njalgo) no need of constructing list and linkedlist. just take head as linkedlist and perform the logic and return the sol."
                    },
                    {
                        "username": "njalgo",
                        "content": "On your local computer, just set the Next pointer of the last node to any previous node. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked list problem! A hint: just use 2 pointers 1 fast & 1 slow. It\\'s fine."
                    },
                    {
                        "username": "ybank",
                        "content": "Basically, I came up with an accepted solution without using extra space, but destructed the linked list internally. The way I did was that after traversing the current node but before moving to the next node, I make the next pointer pointing to the current node.\\n\\nThis works fine but resetting the next pointer really annoys me. Other solutions I saw from the discussions either change the next pointers in other ways, or rely on a lucky number for the val of the node.\\n\\nI was wondering if anyone has a non-destructive solution, in the way that it preserves all the next pointers, that uses no extra space?\\n\\nThanks!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/linked-list-cycle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Cycle Finding Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tifv",
                        "content": "Hey, LeetCode, what the hell? I was happily writing Rust solutions for 126 days straight\\u2026"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Maybe LeetCode doesn\\'t want to change the design of struct from using `next: Option<Box<ListNode>>`..."
                    },
                    {
                        "username": "SheekhaJ",
                        "content": "Hi, \\n\\nThe question mentions that pos is used to identify the location where the tail connects to. How is this being used during judging? \\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1569542,
                "content": [
                    {
                        "username": "tanghao",
                        "content": "Even though my code is correct the test case [3,2,0,-4] 1 always output False. Also where is python3 option for this question?"
                    },
                    {
                        "username": "rkaldawy",
                        "content": "Hello, when I try to submit a solution for this problem in C, I get double free/corruption errors. This is nonsensical, since my solution never malloc\\'s or frees. I suspect that the solution tester for C is broken. "
                    },
                    {
                        "username": "Ishika_07",
                        "content": "I was out of practice for some time, and have been attempting leetcode daily problems for past one month and was not able to solve the problems on my own but finally yesterday and today I'm just glad that I finally was able to solve the problems on my own (although they are not of much difficulty, it does help boost confidence)\nIf you are reading this post, I hope you are able to solve the daily problems by yourself and if not keep working hard. ALL THE BEST!! "
                    },
                    {
                        "username": "i_am_guts",
                        "content": "the problem was very interesting and the question does not ask you to find the head of the circular list , just you have to confirm if it has a cycle or not , the  `pos` variable here is non of anyone's business , Hint - Floyd's Cycle Detection Algorithm "
                    },
                    {
                        "username": "4ndr01d",
                        "content": "terrible description\\n"
                    },
                    {
                        "username": "yliang12",
                        "content": "I am not sure if it is acceptable to modify the linkedlist, but it uses space O(1). After visited the node, make the node point to itself, so that it can be recognized that it is visited."
                    },
                    {
                        "username": "nitin135",
                        "content": "Where the hell is \\'Run Code\\' button in this problem ?"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "in console"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I don't understand this question. From some answers, I find maybe only 1->2->3->1 exists a cycle. 1->2->3->2 doesn't exist cycle????\\nReally thx yr help"
                    },
                    {
                        "username": "Darth-InVader15",
                        "content": "This is the first question I solved on Leetcode, 2 years back. I guess my life\\'s also a cycle :)"
                    },
                    {
                        "username": "Prikers",
                        "content": "Do you think a recruter would find this solution amusing? \\uD83E\\uDD23\\n ```python\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return head.__repr__() == \\'Error - Found cycle in the ListNode\\'\\n``` "
                    },
                    {
                        "username": "arshita129",
                        "content": "Instantly Hired!!! \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sergei99",
                        "content": "I think this should be shown to an IT person, not HR. At least, if they give you a boot, you would know that you have successfully evaded a dark place where nobody is ever smiling."
                    }
                ]
            },
            {
                "id": 1572169,
                "content": [
                    {
                        "username": "tanghao",
                        "content": "Even though my code is correct the test case [3,2,0,-4] 1 always output False. Also where is python3 option for this question?"
                    },
                    {
                        "username": "rkaldawy",
                        "content": "Hello, when I try to submit a solution for this problem in C, I get double free/corruption errors. This is nonsensical, since my solution never malloc\\'s or frees. I suspect that the solution tester for C is broken. "
                    },
                    {
                        "username": "Ishika_07",
                        "content": "I was out of practice for some time, and have been attempting leetcode daily problems for past one month and was not able to solve the problems on my own but finally yesterday and today I'm just glad that I finally was able to solve the problems on my own (although they are not of much difficulty, it does help boost confidence)\nIf you are reading this post, I hope you are able to solve the daily problems by yourself and if not keep working hard. ALL THE BEST!! "
                    },
                    {
                        "username": "i_am_guts",
                        "content": "the problem was very interesting and the question does not ask you to find the head of the circular list , just you have to confirm if it has a cycle or not , the  `pos` variable here is non of anyone's business , Hint - Floyd's Cycle Detection Algorithm "
                    },
                    {
                        "username": "4ndr01d",
                        "content": "terrible description\\n"
                    },
                    {
                        "username": "yliang12",
                        "content": "I am not sure if it is acceptable to modify the linkedlist, but it uses space O(1). After visited the node, make the node point to itself, so that it can be recognized that it is visited."
                    },
                    {
                        "username": "nitin135",
                        "content": "Where the hell is \\'Run Code\\' button in this problem ?"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "in console"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I don't understand this question. From some answers, I find maybe only 1->2->3->1 exists a cycle. 1->2->3->2 doesn't exist cycle????\\nReally thx yr help"
                    },
                    {
                        "username": "Darth-InVader15",
                        "content": "This is the first question I solved on Leetcode, 2 years back. I guess my life\\'s also a cycle :)"
                    },
                    {
                        "username": "Prikers",
                        "content": "Do you think a recruter would find this solution amusing? \\uD83E\\uDD23\\n ```python\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return head.__repr__() == \\'Error - Found cycle in the ListNode\\'\\n``` "
                    },
                    {
                        "username": "arshita129",
                        "content": "Instantly Hired!!! \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sergei99",
                        "content": "I think this should be shown to an IT person, not HR. At least, if they give you a boot, you would know that you have successfully evaded a dark place where nobody is ever smiling."
                    }
                ]
            },
            {
                "id": 2043398,
                "content": [
                    {
                        "username": "tanghao",
                        "content": "Even though my code is correct the test case [3,2,0,-4] 1 always output False. Also where is python3 option for this question?"
                    },
                    {
                        "username": "rkaldawy",
                        "content": "Hello, when I try to submit a solution for this problem in C, I get double free/corruption errors. This is nonsensical, since my solution never malloc\\'s or frees. I suspect that the solution tester for C is broken. "
                    },
                    {
                        "username": "Ishika_07",
                        "content": "I was out of practice for some time, and have been attempting leetcode daily problems for past one month and was not able to solve the problems on my own but finally yesterday and today I'm just glad that I finally was able to solve the problems on my own (although they are not of much difficulty, it does help boost confidence)\nIf you are reading this post, I hope you are able to solve the daily problems by yourself and if not keep working hard. ALL THE BEST!! "
                    },
                    {
                        "username": "i_am_guts",
                        "content": "the problem was very interesting and the question does not ask you to find the head of the circular list , just you have to confirm if it has a cycle or not , the  `pos` variable here is non of anyone's business , Hint - Floyd's Cycle Detection Algorithm "
                    },
                    {
                        "username": "4ndr01d",
                        "content": "terrible description\\n"
                    },
                    {
                        "username": "yliang12",
                        "content": "I am not sure if it is acceptable to modify the linkedlist, but it uses space O(1). After visited the node, make the node point to itself, so that it can be recognized that it is visited."
                    },
                    {
                        "username": "nitin135",
                        "content": "Where the hell is \\'Run Code\\' button in this problem ?"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "in console"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I don't understand this question. From some answers, I find maybe only 1->2->3->1 exists a cycle. 1->2->3->2 doesn't exist cycle????\\nReally thx yr help"
                    },
                    {
                        "username": "Darth-InVader15",
                        "content": "This is the first question I solved on Leetcode, 2 years back. I guess my life\\'s also a cycle :)"
                    },
                    {
                        "username": "Prikers",
                        "content": "Do you think a recruter would find this solution amusing? \\uD83E\\uDD23\\n ```python\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return head.__repr__() == \\'Error - Found cycle in the ListNode\\'\\n``` "
                    },
                    {
                        "username": "arshita129",
                        "content": "Instantly Hired!!! \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sergei99",
                        "content": "I think this should be shown to an IT person, not HR. At least, if they give you a boot, you would know that you have successfully evaded a dark place where nobody is ever smiling."
                    }
                ]
            },
            {
                "id": 2002631,
                "content": [
                    {
                        "username": "tanghao",
                        "content": "Even though my code is correct the test case [3,2,0,-4] 1 always output False. Also where is python3 option for this question?"
                    },
                    {
                        "username": "rkaldawy",
                        "content": "Hello, when I try to submit a solution for this problem in C, I get double free/corruption errors. This is nonsensical, since my solution never malloc\\'s or frees. I suspect that the solution tester for C is broken. "
                    },
                    {
                        "username": "Ishika_07",
                        "content": "I was out of practice for some time, and have been attempting leetcode daily problems for past one month and was not able to solve the problems on my own but finally yesterday and today I'm just glad that I finally was able to solve the problems on my own (although they are not of much difficulty, it does help boost confidence)\nIf you are reading this post, I hope you are able to solve the daily problems by yourself and if not keep working hard. ALL THE BEST!! "
                    },
                    {
                        "username": "i_am_guts",
                        "content": "the problem was very interesting and the question does not ask you to find the head of the circular list , just you have to confirm if it has a cycle or not , the  `pos` variable here is non of anyone's business , Hint - Floyd's Cycle Detection Algorithm "
                    },
                    {
                        "username": "4ndr01d",
                        "content": "terrible description\\n"
                    },
                    {
                        "username": "yliang12",
                        "content": "I am not sure if it is acceptable to modify the linkedlist, but it uses space O(1). After visited the node, make the node point to itself, so that it can be recognized that it is visited."
                    },
                    {
                        "username": "nitin135",
                        "content": "Where the hell is \\'Run Code\\' button in this problem ?"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "in console"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I don't understand this question. From some answers, I find maybe only 1->2->3->1 exists a cycle. 1->2->3->2 doesn't exist cycle????\\nReally thx yr help"
                    },
                    {
                        "username": "Darth-InVader15",
                        "content": "This is the first question I solved on Leetcode, 2 years back. I guess my life\\'s also a cycle :)"
                    },
                    {
                        "username": "Prikers",
                        "content": "Do you think a recruter would find this solution amusing? \\uD83E\\uDD23\\n ```python\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return head.__repr__() == \\'Error - Found cycle in the ListNode\\'\\n``` "
                    },
                    {
                        "username": "arshita129",
                        "content": "Instantly Hired!!! \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sergei99",
                        "content": "I think this should be shown to an IT person, not HR. At least, if they give you a boot, you would know that you have successfully evaded a dark place where nobody is ever smiling."
                    }
                ]
            },
            {
                "id": 2001886,
                "content": [
                    {
                        "username": "tanghao",
                        "content": "Even though my code is correct the test case [3,2,0,-4] 1 always output False. Also where is python3 option for this question?"
                    },
                    {
                        "username": "rkaldawy",
                        "content": "Hello, when I try to submit a solution for this problem in C, I get double free/corruption errors. This is nonsensical, since my solution never malloc\\'s or frees. I suspect that the solution tester for C is broken. "
                    },
                    {
                        "username": "Ishika_07",
                        "content": "I was out of practice for some time, and have been attempting leetcode daily problems for past one month and was not able to solve the problems on my own but finally yesterday and today I'm just glad that I finally was able to solve the problems on my own (although they are not of much difficulty, it does help boost confidence)\nIf you are reading this post, I hope you are able to solve the daily problems by yourself and if not keep working hard. ALL THE BEST!! "
                    },
                    {
                        "username": "i_am_guts",
                        "content": "the problem was very interesting and the question does not ask you to find the head of the circular list , just you have to confirm if it has a cycle or not , the  `pos` variable here is non of anyone's business , Hint - Floyd's Cycle Detection Algorithm "
                    },
                    {
                        "username": "4ndr01d",
                        "content": "terrible description\\n"
                    },
                    {
                        "username": "yliang12",
                        "content": "I am not sure if it is acceptable to modify the linkedlist, but it uses space O(1). After visited the node, make the node point to itself, so that it can be recognized that it is visited."
                    },
                    {
                        "username": "nitin135",
                        "content": "Where the hell is \\'Run Code\\' button in this problem ?"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "in console"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I don't understand this question. From some answers, I find maybe only 1->2->3->1 exists a cycle. 1->2->3->2 doesn't exist cycle????\\nReally thx yr help"
                    },
                    {
                        "username": "Darth-InVader15",
                        "content": "This is the first question I solved on Leetcode, 2 years back. I guess my life\\'s also a cycle :)"
                    },
                    {
                        "username": "Prikers",
                        "content": "Do you think a recruter would find this solution amusing? \\uD83E\\uDD23\\n ```python\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return head.__repr__() == \\'Error - Found cycle in the ListNode\\'\\n``` "
                    },
                    {
                        "username": "arshita129",
                        "content": "Instantly Hired!!! \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sergei99",
                        "content": "I think this should be shown to an IT person, not HR. At least, if they give you a boot, you would know that you have successfully evaded a dark place where nobody is ever smiling."
                    }
                ]
            },
            {
                "id": 1572012,
                "content": [
                    {
                        "username": "tanghao",
                        "content": "Even though my code is correct the test case [3,2,0,-4] 1 always output False. Also where is python3 option for this question?"
                    },
                    {
                        "username": "rkaldawy",
                        "content": "Hello, when I try to submit a solution for this problem in C, I get double free/corruption errors. This is nonsensical, since my solution never malloc\\'s or frees. I suspect that the solution tester for C is broken. "
                    },
                    {
                        "username": "Ishika_07",
                        "content": "I was out of practice for some time, and have been attempting leetcode daily problems for past one month and was not able to solve the problems on my own but finally yesterday and today I'm just glad that I finally was able to solve the problems on my own (although they are not of much difficulty, it does help boost confidence)\nIf you are reading this post, I hope you are able to solve the daily problems by yourself and if not keep working hard. ALL THE BEST!! "
                    },
                    {
                        "username": "i_am_guts",
                        "content": "the problem was very interesting and the question does not ask you to find the head of the circular list , just you have to confirm if it has a cycle or not , the  `pos` variable here is non of anyone's business , Hint - Floyd's Cycle Detection Algorithm "
                    },
                    {
                        "username": "4ndr01d",
                        "content": "terrible description\\n"
                    },
                    {
                        "username": "yliang12",
                        "content": "I am not sure if it is acceptable to modify the linkedlist, but it uses space O(1). After visited the node, make the node point to itself, so that it can be recognized that it is visited."
                    },
                    {
                        "username": "nitin135",
                        "content": "Where the hell is \\'Run Code\\' button in this problem ?"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "in console"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I don't understand this question. From some answers, I find maybe only 1->2->3->1 exists a cycle. 1->2->3->2 doesn't exist cycle????\\nReally thx yr help"
                    },
                    {
                        "username": "Darth-InVader15",
                        "content": "This is the first question I solved on Leetcode, 2 years back. I guess my life\\'s also a cycle :)"
                    },
                    {
                        "username": "Prikers",
                        "content": "Do you think a recruter would find this solution amusing? \\uD83E\\uDD23\\n ```python\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return head.__repr__() == \\'Error - Found cycle in the ListNode\\'\\n``` "
                    },
                    {
                        "username": "arshita129",
                        "content": "Instantly Hired!!! \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sergei99",
                        "content": "I think this should be shown to an IT person, not HR. At least, if they give you a boot, you would know that you have successfully evaded a dark place where nobody is ever smiling."
                    }
                ]
            },
            {
                "id": 1567303,
                "content": [
                    {
                        "username": "tanghao",
                        "content": "Even though my code is correct the test case [3,2,0,-4] 1 always output False. Also where is python3 option for this question?"
                    },
                    {
                        "username": "rkaldawy",
                        "content": "Hello, when I try to submit a solution for this problem in C, I get double free/corruption errors. This is nonsensical, since my solution never malloc\\'s or frees. I suspect that the solution tester for C is broken. "
                    },
                    {
                        "username": "Ishika_07",
                        "content": "I was out of practice for some time, and have been attempting leetcode daily problems for past one month and was not able to solve the problems on my own but finally yesterday and today I'm just glad that I finally was able to solve the problems on my own (although they are not of much difficulty, it does help boost confidence)\nIf you are reading this post, I hope you are able to solve the daily problems by yourself and if not keep working hard. ALL THE BEST!! "
                    },
                    {
                        "username": "i_am_guts",
                        "content": "the problem was very interesting and the question does not ask you to find the head of the circular list , just you have to confirm if it has a cycle or not , the  `pos` variable here is non of anyone's business , Hint - Floyd's Cycle Detection Algorithm "
                    },
                    {
                        "username": "4ndr01d",
                        "content": "terrible description\\n"
                    },
                    {
                        "username": "yliang12",
                        "content": "I am not sure if it is acceptable to modify the linkedlist, but it uses space O(1). After visited the node, make the node point to itself, so that it can be recognized that it is visited."
                    },
                    {
                        "username": "nitin135",
                        "content": "Where the hell is \\'Run Code\\' button in this problem ?"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "in console"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I don't understand this question. From some answers, I find maybe only 1->2->3->1 exists a cycle. 1->2->3->2 doesn't exist cycle????\\nReally thx yr help"
                    },
                    {
                        "username": "Darth-InVader15",
                        "content": "This is the first question I solved on Leetcode, 2 years back. I guess my life\\'s also a cycle :)"
                    },
                    {
                        "username": "Prikers",
                        "content": "Do you think a recruter would find this solution amusing? \\uD83E\\uDD23\\n ```python\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return head.__repr__() == \\'Error - Found cycle in the ListNode\\'\\n``` "
                    },
                    {
                        "username": "arshita129",
                        "content": "Instantly Hired!!! \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sergei99",
                        "content": "I think this should be shown to an IT person, not HR. At least, if they give you a boot, you would know that you have successfully evaded a dark place where nobody is ever smiling."
                    }
                ]
            },
            {
                "id": 1568965,
                "content": [
                    {
                        "username": "tanghao",
                        "content": "Even though my code is correct the test case [3,2,0,-4] 1 always output False. Also where is python3 option for this question?"
                    },
                    {
                        "username": "rkaldawy",
                        "content": "Hello, when I try to submit a solution for this problem in C, I get double free/corruption errors. This is nonsensical, since my solution never malloc\\'s or frees. I suspect that the solution tester for C is broken. "
                    },
                    {
                        "username": "Ishika_07",
                        "content": "I was out of practice for some time, and have been attempting leetcode daily problems for past one month and was not able to solve the problems on my own but finally yesterday and today I'm just glad that I finally was able to solve the problems on my own (although they are not of much difficulty, it does help boost confidence)\nIf you are reading this post, I hope you are able to solve the daily problems by yourself and if not keep working hard. ALL THE BEST!! "
                    },
                    {
                        "username": "i_am_guts",
                        "content": "the problem was very interesting and the question does not ask you to find the head of the circular list , just you have to confirm if it has a cycle or not , the  `pos` variable here is non of anyone's business , Hint - Floyd's Cycle Detection Algorithm "
                    },
                    {
                        "username": "4ndr01d",
                        "content": "terrible description\\n"
                    },
                    {
                        "username": "yliang12",
                        "content": "I am not sure if it is acceptable to modify the linkedlist, but it uses space O(1). After visited the node, make the node point to itself, so that it can be recognized that it is visited."
                    },
                    {
                        "username": "nitin135",
                        "content": "Where the hell is \\'Run Code\\' button in this problem ?"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "in console"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I don't understand this question. From some answers, I find maybe only 1->2->3->1 exists a cycle. 1->2->3->2 doesn't exist cycle????\\nReally thx yr help"
                    },
                    {
                        "username": "Darth-InVader15",
                        "content": "This is the first question I solved on Leetcode, 2 years back. I guess my life\\'s also a cycle :)"
                    },
                    {
                        "username": "Prikers",
                        "content": "Do you think a recruter would find this solution amusing? \\uD83E\\uDD23\\n ```python\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return head.__repr__() == \\'Error - Found cycle in the ListNode\\'\\n``` "
                    },
                    {
                        "username": "arshita129",
                        "content": "Instantly Hired!!! \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sergei99",
                        "content": "I think this should be shown to an IT person, not HR. At least, if they give you a boot, you would know that you have successfully evaded a dark place where nobody is ever smiling."
                    }
                ]
            },
            {
                "id": 2043846,
                "content": [
                    {
                        "username": "tanghao",
                        "content": "Even though my code is correct the test case [3,2,0,-4] 1 always output False. Also where is python3 option for this question?"
                    },
                    {
                        "username": "rkaldawy",
                        "content": "Hello, when I try to submit a solution for this problem in C, I get double free/corruption errors. This is nonsensical, since my solution never malloc\\'s or frees. I suspect that the solution tester for C is broken. "
                    },
                    {
                        "username": "Ishika_07",
                        "content": "I was out of practice for some time, and have been attempting leetcode daily problems for past one month and was not able to solve the problems on my own but finally yesterday and today I'm just glad that I finally was able to solve the problems on my own (although they are not of much difficulty, it does help boost confidence)\nIf you are reading this post, I hope you are able to solve the daily problems by yourself and if not keep working hard. ALL THE BEST!! "
                    },
                    {
                        "username": "i_am_guts",
                        "content": "the problem was very interesting and the question does not ask you to find the head of the circular list , just you have to confirm if it has a cycle or not , the  `pos` variable here is non of anyone's business , Hint - Floyd's Cycle Detection Algorithm "
                    },
                    {
                        "username": "4ndr01d",
                        "content": "terrible description\\n"
                    },
                    {
                        "username": "yliang12",
                        "content": "I am not sure if it is acceptable to modify the linkedlist, but it uses space O(1). After visited the node, make the node point to itself, so that it can be recognized that it is visited."
                    },
                    {
                        "username": "nitin135",
                        "content": "Where the hell is \\'Run Code\\' button in this problem ?"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "in console"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I don't understand this question. From some answers, I find maybe only 1->2->3->1 exists a cycle. 1->2->3->2 doesn't exist cycle????\\nReally thx yr help"
                    },
                    {
                        "username": "Darth-InVader15",
                        "content": "This is the first question I solved on Leetcode, 2 years back. I guess my life\\'s also a cycle :)"
                    },
                    {
                        "username": "Prikers",
                        "content": "Do you think a recruter would find this solution amusing? \\uD83E\\uDD23\\n ```python\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return head.__repr__() == \\'Error - Found cycle in the ListNode\\'\\n``` "
                    },
                    {
                        "username": "arshita129",
                        "content": "Instantly Hired!!! \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sergei99",
                        "content": "I think this should be shown to an IT person, not HR. At least, if they give you a boot, you would know that you have successfully evaded a dark place where nobody is ever smiling."
                    }
                ]
            },
            {
                "id": 2043769,
                "content": [
                    {
                        "username": "tanghao",
                        "content": "Even though my code is correct the test case [3,2,0,-4] 1 always output False. Also where is python3 option for this question?"
                    },
                    {
                        "username": "rkaldawy",
                        "content": "Hello, when I try to submit a solution for this problem in C, I get double free/corruption errors. This is nonsensical, since my solution never malloc\\'s or frees. I suspect that the solution tester for C is broken. "
                    },
                    {
                        "username": "Ishika_07",
                        "content": "I was out of practice for some time, and have been attempting leetcode daily problems for past one month and was not able to solve the problems on my own but finally yesterday and today I'm just glad that I finally was able to solve the problems on my own (although they are not of much difficulty, it does help boost confidence)\nIf you are reading this post, I hope you are able to solve the daily problems by yourself and if not keep working hard. ALL THE BEST!! "
                    },
                    {
                        "username": "i_am_guts",
                        "content": "the problem was very interesting and the question does not ask you to find the head of the circular list , just you have to confirm if it has a cycle or not , the  `pos` variable here is non of anyone's business , Hint - Floyd's Cycle Detection Algorithm "
                    },
                    {
                        "username": "4ndr01d",
                        "content": "terrible description\\n"
                    },
                    {
                        "username": "yliang12",
                        "content": "I am not sure if it is acceptable to modify the linkedlist, but it uses space O(1). After visited the node, make the node point to itself, so that it can be recognized that it is visited."
                    },
                    {
                        "username": "nitin135",
                        "content": "Where the hell is \\'Run Code\\' button in this problem ?"
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "in console"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I don't understand this question. From some answers, I find maybe only 1->2->3->1 exists a cycle. 1->2->3->2 doesn't exist cycle????\\nReally thx yr help"
                    },
                    {
                        "username": "Darth-InVader15",
                        "content": "This is the first question I solved on Leetcode, 2 years back. I guess my life\\'s also a cycle :)"
                    },
                    {
                        "username": "Prikers",
                        "content": "Do you think a recruter would find this solution amusing? \\uD83E\\uDD23\\n ```python\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return head.__repr__() == \\'Error - Found cycle in the ListNode\\'\\n``` "
                    },
                    {
                        "username": "arshita129",
                        "content": "Instantly Hired!!! \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sergei99",
                        "content": "I think this should be shown to an IT person, not HR. At least, if they give you a boot, you would know that you have successfully evaded a dark place where nobody is ever smiling."
                    }
                ]
            },
            {
                "id": 2043369,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "Try using two pointers that move at different speeds. If either of them can get to a null then it\\'s obvious there isn\\'t a cycle. But what happens if there is a cycle? Eventually the faster pointer will make a full lap and be equal to the slow pointer. Therefore if during the traversal the faster pointer == slower pointer, you can return true."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Nodes that contains in my life cycle are eat,sleep..repeat :("
                    },
                    {
                        "username": "HikuMai",
                        "content": "Leetcode has mercy on me this time :))"
                    },
                    {
                        "username": "harshit1271gupta",
                        "content": " public boolean hasCycle(ListNode head) {\\n    // apparoch 1   using hashset cuz if it store same location that means there is a cycle \\n    // HashSet<ListNode> map = new HashSet<>();\\n    //     ListNode temp = head;\\n    //     while (temp != null) {\\n    //         if (map.contains(temp)) {\\n    //             return true;\\n    //         }else{\\n    //             map.add(temp);\\n    //         }\\n    //         temp = temp.next;\\n    //     }\\n    //     return false;\\n    // }\\n   // apparoch 2    space complexity 0(1)\\n    ListNode slow = head;\\n    ListNode fast = head;\\n    if(head==null || head.next==null){\\n        return false;\\n    }\\n    while(fast!=null){\\n\\n        if(slow==null)return false;\\n        if(fast.next==null)return false;\\n        slow = slow.next;\\n        fast = fast.next.next;\\n        if(slow==fast)return true;\\n    }\\n    return false;"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "underdogsourav",
                        "content": "what is the use of mentioning the pos +  "
                    },
                    {
                        "username": "soukumpan",
                        "content": "ignore that "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "Here the set logic will not work because node-values may be repeated means for ex 2->4->3->7->4->6->null  then by set logic it will return true but actually it\\'s not containing any cycle so we need to use another logic for detect cycle ."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Why not? You just need to use node1 == node2 instead of node1.val == node2.val, means we check if a node actually refers to the same rather than checking a val. Works for Java.\\nBtw, it\\'s not necessary to use HashSet (or HashMap), it will work with simple list too, however Set seems to be faster.   "
                    },
                    {
                        "username": "ali__code",
                        "content": "how to use pos when it is not in parameter."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\n\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/3024832/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "knightryder098",
                        "content": "It\\'s given that POS is the valid position in the linked list. So if we just comapre it with 0, it should give us whether cycle is present or not. \\n\\nAm i am wrong? Plz explain . Thank You"
                    },
                    {
                        "username": "yazanmaini",
                        "content": "![image](https://assets.leetcode.com/users/images/e4307283-b136-4212-babe-2f7dd6051505_1596530623.2097838.png)\\n"
                    }
                ]
            },
            {
                "id": 2043282,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "Try using two pointers that move at different speeds. If either of them can get to a null then it\\'s obvious there isn\\'t a cycle. But what happens if there is a cycle? Eventually the faster pointer will make a full lap and be equal to the slow pointer. Therefore if during the traversal the faster pointer == slower pointer, you can return true."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Nodes that contains in my life cycle are eat,sleep..repeat :("
                    },
                    {
                        "username": "HikuMai",
                        "content": "Leetcode has mercy on me this time :))"
                    },
                    {
                        "username": "harshit1271gupta",
                        "content": " public boolean hasCycle(ListNode head) {\\n    // apparoch 1   using hashset cuz if it store same location that means there is a cycle \\n    // HashSet<ListNode> map = new HashSet<>();\\n    //     ListNode temp = head;\\n    //     while (temp != null) {\\n    //         if (map.contains(temp)) {\\n    //             return true;\\n    //         }else{\\n    //             map.add(temp);\\n    //         }\\n    //         temp = temp.next;\\n    //     }\\n    //     return false;\\n    // }\\n   // apparoch 2    space complexity 0(1)\\n    ListNode slow = head;\\n    ListNode fast = head;\\n    if(head==null || head.next==null){\\n        return false;\\n    }\\n    while(fast!=null){\\n\\n        if(slow==null)return false;\\n        if(fast.next==null)return false;\\n        slow = slow.next;\\n        fast = fast.next.next;\\n        if(slow==fast)return true;\\n    }\\n    return false;"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "underdogsourav",
                        "content": "what is the use of mentioning the pos +  "
                    },
                    {
                        "username": "soukumpan",
                        "content": "ignore that "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "Here the set logic will not work because node-values may be repeated means for ex 2->4->3->7->4->6->null  then by set logic it will return true but actually it\\'s not containing any cycle so we need to use another logic for detect cycle ."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Why not? You just need to use node1 == node2 instead of node1.val == node2.val, means we check if a node actually refers to the same rather than checking a val. Works for Java.\\nBtw, it\\'s not necessary to use HashSet (or HashMap), it will work with simple list too, however Set seems to be faster.   "
                    },
                    {
                        "username": "ali__code",
                        "content": "how to use pos when it is not in parameter."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\n\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/3024832/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "knightryder098",
                        "content": "It\\'s given that POS is the valid position in the linked list. So if we just comapre it with 0, it should give us whether cycle is present or not. \\n\\nAm i am wrong? Plz explain . Thank You"
                    },
                    {
                        "username": "yazanmaini",
                        "content": "![image](https://assets.leetcode.com/users/images/e4307283-b136-4212-babe-2f7dd6051505_1596530623.2097838.png)\\n"
                    }
                ]
            },
            {
                "id": 2043248,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "Try using two pointers that move at different speeds. If either of them can get to a null then it\\'s obvious there isn\\'t a cycle. But what happens if there is a cycle? Eventually the faster pointer will make a full lap and be equal to the slow pointer. Therefore if during the traversal the faster pointer == slower pointer, you can return true."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Nodes that contains in my life cycle are eat,sleep..repeat :("
                    },
                    {
                        "username": "HikuMai",
                        "content": "Leetcode has mercy on me this time :))"
                    },
                    {
                        "username": "harshit1271gupta",
                        "content": " public boolean hasCycle(ListNode head) {\\n    // apparoch 1   using hashset cuz if it store same location that means there is a cycle \\n    // HashSet<ListNode> map = new HashSet<>();\\n    //     ListNode temp = head;\\n    //     while (temp != null) {\\n    //         if (map.contains(temp)) {\\n    //             return true;\\n    //         }else{\\n    //             map.add(temp);\\n    //         }\\n    //         temp = temp.next;\\n    //     }\\n    //     return false;\\n    // }\\n   // apparoch 2    space complexity 0(1)\\n    ListNode slow = head;\\n    ListNode fast = head;\\n    if(head==null || head.next==null){\\n        return false;\\n    }\\n    while(fast!=null){\\n\\n        if(slow==null)return false;\\n        if(fast.next==null)return false;\\n        slow = slow.next;\\n        fast = fast.next.next;\\n        if(slow==fast)return true;\\n    }\\n    return false;"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "underdogsourav",
                        "content": "what is the use of mentioning the pos +  "
                    },
                    {
                        "username": "soukumpan",
                        "content": "ignore that "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "Here the set logic will not work because node-values may be repeated means for ex 2->4->3->7->4->6->null  then by set logic it will return true but actually it\\'s not containing any cycle so we need to use another logic for detect cycle ."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Why not? You just need to use node1 == node2 instead of node1.val == node2.val, means we check if a node actually refers to the same rather than checking a val. Works for Java.\\nBtw, it\\'s not necessary to use HashSet (or HashMap), it will work with simple list too, however Set seems to be faster.   "
                    },
                    {
                        "username": "ali__code",
                        "content": "how to use pos when it is not in parameter."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\n\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/3024832/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "knightryder098",
                        "content": "It\\'s given that POS is the valid position in the linked list. So if we just comapre it with 0, it should give us whether cycle is present or not. \\n\\nAm i am wrong? Plz explain . Thank You"
                    },
                    {
                        "username": "yazanmaini",
                        "content": "![image](https://assets.leetcode.com/users/images/e4307283-b136-4212-babe-2f7dd6051505_1596530623.2097838.png)\\n"
                    }
                ]
            },
            {
                "id": 1953864,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "Try using two pointers that move at different speeds. If either of them can get to a null then it\\'s obvious there isn\\'t a cycle. But what happens if there is a cycle? Eventually the faster pointer will make a full lap and be equal to the slow pointer. Therefore if during the traversal the faster pointer == slower pointer, you can return true."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Nodes that contains in my life cycle are eat,sleep..repeat :("
                    },
                    {
                        "username": "HikuMai",
                        "content": "Leetcode has mercy on me this time :))"
                    },
                    {
                        "username": "harshit1271gupta",
                        "content": " public boolean hasCycle(ListNode head) {\\n    // apparoch 1   using hashset cuz if it store same location that means there is a cycle \\n    // HashSet<ListNode> map = new HashSet<>();\\n    //     ListNode temp = head;\\n    //     while (temp != null) {\\n    //         if (map.contains(temp)) {\\n    //             return true;\\n    //         }else{\\n    //             map.add(temp);\\n    //         }\\n    //         temp = temp.next;\\n    //     }\\n    //     return false;\\n    // }\\n   // apparoch 2    space complexity 0(1)\\n    ListNode slow = head;\\n    ListNode fast = head;\\n    if(head==null || head.next==null){\\n        return false;\\n    }\\n    while(fast!=null){\\n\\n        if(slow==null)return false;\\n        if(fast.next==null)return false;\\n        slow = slow.next;\\n        fast = fast.next.next;\\n        if(slow==fast)return true;\\n    }\\n    return false;"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "underdogsourav",
                        "content": "what is the use of mentioning the pos +  "
                    },
                    {
                        "username": "soukumpan",
                        "content": "ignore that "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "Here the set logic will not work because node-values may be repeated means for ex 2->4->3->7->4->6->null  then by set logic it will return true but actually it\\'s not containing any cycle so we need to use another logic for detect cycle ."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Why not? You just need to use node1 == node2 instead of node1.val == node2.val, means we check if a node actually refers to the same rather than checking a val. Works for Java.\\nBtw, it\\'s not necessary to use HashSet (or HashMap), it will work with simple list too, however Set seems to be faster.   "
                    },
                    {
                        "username": "ali__code",
                        "content": "how to use pos when it is not in parameter."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\n\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/3024832/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "knightryder098",
                        "content": "It\\'s given that POS is the valid position in the linked list. So if we just comapre it with 0, it should give us whether cycle is present or not. \\n\\nAm i am wrong? Plz explain . Thank You"
                    },
                    {
                        "username": "yazanmaini",
                        "content": "![image](https://assets.leetcode.com/users/images/e4307283-b136-4212-babe-2f7dd6051505_1596530623.2097838.png)\\n"
                    }
                ]
            },
            {
                "id": 1826966,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "Try using two pointers that move at different speeds. If either of them can get to a null then it\\'s obvious there isn\\'t a cycle. But what happens if there is a cycle? Eventually the faster pointer will make a full lap and be equal to the slow pointer. Therefore if during the traversal the faster pointer == slower pointer, you can return true."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Nodes that contains in my life cycle are eat,sleep..repeat :("
                    },
                    {
                        "username": "HikuMai",
                        "content": "Leetcode has mercy on me this time :))"
                    },
                    {
                        "username": "harshit1271gupta",
                        "content": " public boolean hasCycle(ListNode head) {\\n    // apparoch 1   using hashset cuz if it store same location that means there is a cycle \\n    // HashSet<ListNode> map = new HashSet<>();\\n    //     ListNode temp = head;\\n    //     while (temp != null) {\\n    //         if (map.contains(temp)) {\\n    //             return true;\\n    //         }else{\\n    //             map.add(temp);\\n    //         }\\n    //         temp = temp.next;\\n    //     }\\n    //     return false;\\n    // }\\n   // apparoch 2    space complexity 0(1)\\n    ListNode slow = head;\\n    ListNode fast = head;\\n    if(head==null || head.next==null){\\n        return false;\\n    }\\n    while(fast!=null){\\n\\n        if(slow==null)return false;\\n        if(fast.next==null)return false;\\n        slow = slow.next;\\n        fast = fast.next.next;\\n        if(slow==fast)return true;\\n    }\\n    return false;"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "underdogsourav",
                        "content": "what is the use of mentioning the pos +  "
                    },
                    {
                        "username": "soukumpan",
                        "content": "ignore that "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "Here the set logic will not work because node-values may be repeated means for ex 2->4->3->7->4->6->null  then by set logic it will return true but actually it\\'s not containing any cycle so we need to use another logic for detect cycle ."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Why not? You just need to use node1 == node2 instead of node1.val == node2.val, means we check if a node actually refers to the same rather than checking a val. Works for Java.\\nBtw, it\\'s not necessary to use HashSet (or HashMap), it will work with simple list too, however Set seems to be faster.   "
                    },
                    {
                        "username": "ali__code",
                        "content": "how to use pos when it is not in parameter."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\n\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/3024832/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "knightryder098",
                        "content": "It\\'s given that POS is the valid position in the linked list. So if we just comapre it with 0, it should give us whether cycle is present or not. \\n\\nAm i am wrong? Plz explain . Thank You"
                    },
                    {
                        "username": "yazanmaini",
                        "content": "![image](https://assets.leetcode.com/users/images/e4307283-b136-4212-babe-2f7dd6051505_1596530623.2097838.png)\\n"
                    }
                ]
            },
            {
                "id": 1794706,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "Try using two pointers that move at different speeds. If either of them can get to a null then it\\'s obvious there isn\\'t a cycle. But what happens if there is a cycle? Eventually the faster pointer will make a full lap and be equal to the slow pointer. Therefore if during the traversal the faster pointer == slower pointer, you can return true."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Nodes that contains in my life cycle are eat,sleep..repeat :("
                    },
                    {
                        "username": "HikuMai",
                        "content": "Leetcode has mercy on me this time :))"
                    },
                    {
                        "username": "harshit1271gupta",
                        "content": " public boolean hasCycle(ListNode head) {\\n    // apparoch 1   using hashset cuz if it store same location that means there is a cycle \\n    // HashSet<ListNode> map = new HashSet<>();\\n    //     ListNode temp = head;\\n    //     while (temp != null) {\\n    //         if (map.contains(temp)) {\\n    //             return true;\\n    //         }else{\\n    //             map.add(temp);\\n    //         }\\n    //         temp = temp.next;\\n    //     }\\n    //     return false;\\n    // }\\n   // apparoch 2    space complexity 0(1)\\n    ListNode slow = head;\\n    ListNode fast = head;\\n    if(head==null || head.next==null){\\n        return false;\\n    }\\n    while(fast!=null){\\n\\n        if(slow==null)return false;\\n        if(fast.next==null)return false;\\n        slow = slow.next;\\n        fast = fast.next.next;\\n        if(slow==fast)return true;\\n    }\\n    return false;"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "underdogsourav",
                        "content": "what is the use of mentioning the pos +  "
                    },
                    {
                        "username": "soukumpan",
                        "content": "ignore that "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "Here the set logic will not work because node-values may be repeated means for ex 2->4->3->7->4->6->null  then by set logic it will return true but actually it\\'s not containing any cycle so we need to use another logic for detect cycle ."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Why not? You just need to use node1 == node2 instead of node1.val == node2.val, means we check if a node actually refers to the same rather than checking a val. Works for Java.\\nBtw, it\\'s not necessary to use HashSet (or HashMap), it will work with simple list too, however Set seems to be faster.   "
                    },
                    {
                        "username": "ali__code",
                        "content": "how to use pos when it is not in parameter."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\n\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/3024832/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "knightryder098",
                        "content": "It\\'s given that POS is the valid position in the linked list. So if we just comapre it with 0, it should give us whether cycle is present or not. \\n\\nAm i am wrong? Plz explain . Thank You"
                    },
                    {
                        "username": "yazanmaini",
                        "content": "![image](https://assets.leetcode.com/users/images/e4307283-b136-4212-babe-2f7dd6051505_1596530623.2097838.png)\\n"
                    }
                ]
            },
            {
                "id": 1785619,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "Try using two pointers that move at different speeds. If either of them can get to a null then it\\'s obvious there isn\\'t a cycle. But what happens if there is a cycle? Eventually the faster pointer will make a full lap and be equal to the slow pointer. Therefore if during the traversal the faster pointer == slower pointer, you can return true."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Nodes that contains in my life cycle are eat,sleep..repeat :("
                    },
                    {
                        "username": "HikuMai",
                        "content": "Leetcode has mercy on me this time :))"
                    },
                    {
                        "username": "harshit1271gupta",
                        "content": " public boolean hasCycle(ListNode head) {\\n    // apparoch 1   using hashset cuz if it store same location that means there is a cycle \\n    // HashSet<ListNode> map = new HashSet<>();\\n    //     ListNode temp = head;\\n    //     while (temp != null) {\\n    //         if (map.contains(temp)) {\\n    //             return true;\\n    //         }else{\\n    //             map.add(temp);\\n    //         }\\n    //         temp = temp.next;\\n    //     }\\n    //     return false;\\n    // }\\n   // apparoch 2    space complexity 0(1)\\n    ListNode slow = head;\\n    ListNode fast = head;\\n    if(head==null || head.next==null){\\n        return false;\\n    }\\n    while(fast!=null){\\n\\n        if(slow==null)return false;\\n        if(fast.next==null)return false;\\n        slow = slow.next;\\n        fast = fast.next.next;\\n        if(slow==fast)return true;\\n    }\\n    return false;"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "underdogsourav",
                        "content": "what is the use of mentioning the pos +  "
                    },
                    {
                        "username": "soukumpan",
                        "content": "ignore that "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "Here the set logic will not work because node-values may be repeated means for ex 2->4->3->7->4->6->null  then by set logic it will return true but actually it\\'s not containing any cycle so we need to use another logic for detect cycle ."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Why not? You just need to use node1 == node2 instead of node1.val == node2.val, means we check if a node actually refers to the same rather than checking a val. Works for Java.\\nBtw, it\\'s not necessary to use HashSet (or HashMap), it will work with simple list too, however Set seems to be faster.   "
                    },
                    {
                        "username": "ali__code",
                        "content": "how to use pos when it is not in parameter."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\n\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/3024832/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "knightryder098",
                        "content": "It\\'s given that POS is the valid position in the linked list. So if we just comapre it with 0, it should give us whether cycle is present or not. \\n\\nAm i am wrong? Plz explain . Thank You"
                    },
                    {
                        "username": "yazanmaini",
                        "content": "![image](https://assets.leetcode.com/users/images/e4307283-b136-4212-babe-2f7dd6051505_1596530623.2097838.png)\\n"
                    }
                ]
            },
            {
                "id": 1749805,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "Try using two pointers that move at different speeds. If either of them can get to a null then it\\'s obvious there isn\\'t a cycle. But what happens if there is a cycle? Eventually the faster pointer will make a full lap and be equal to the slow pointer. Therefore if during the traversal the faster pointer == slower pointer, you can return true."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Nodes that contains in my life cycle are eat,sleep..repeat :("
                    },
                    {
                        "username": "HikuMai",
                        "content": "Leetcode has mercy on me this time :))"
                    },
                    {
                        "username": "harshit1271gupta",
                        "content": " public boolean hasCycle(ListNode head) {\\n    // apparoch 1   using hashset cuz if it store same location that means there is a cycle \\n    // HashSet<ListNode> map = new HashSet<>();\\n    //     ListNode temp = head;\\n    //     while (temp != null) {\\n    //         if (map.contains(temp)) {\\n    //             return true;\\n    //         }else{\\n    //             map.add(temp);\\n    //         }\\n    //         temp = temp.next;\\n    //     }\\n    //     return false;\\n    // }\\n   // apparoch 2    space complexity 0(1)\\n    ListNode slow = head;\\n    ListNode fast = head;\\n    if(head==null || head.next==null){\\n        return false;\\n    }\\n    while(fast!=null){\\n\\n        if(slow==null)return false;\\n        if(fast.next==null)return false;\\n        slow = slow.next;\\n        fast = fast.next.next;\\n        if(slow==fast)return true;\\n    }\\n    return false;"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "underdogsourav",
                        "content": "what is the use of mentioning the pos +  "
                    },
                    {
                        "username": "soukumpan",
                        "content": "ignore that "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "Here the set logic will not work because node-values may be repeated means for ex 2->4->3->7->4->6->null  then by set logic it will return true but actually it\\'s not containing any cycle so we need to use another logic for detect cycle ."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Why not? You just need to use node1 == node2 instead of node1.val == node2.val, means we check if a node actually refers to the same rather than checking a val. Works for Java.\\nBtw, it\\'s not necessary to use HashSet (or HashMap), it will work with simple list too, however Set seems to be faster.   "
                    },
                    {
                        "username": "ali__code",
                        "content": "how to use pos when it is not in parameter."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\n\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/3024832/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "knightryder098",
                        "content": "It\\'s given that POS is the valid position in the linked list. So if we just comapre it with 0, it should give us whether cycle is present or not. \\n\\nAm i am wrong? Plz explain . Thank You"
                    },
                    {
                        "username": "yazanmaini",
                        "content": "![image](https://assets.leetcode.com/users/images/e4307283-b136-4212-babe-2f7dd6051505_1596530623.2097838.png)\\n"
                    }
                ]
            },
            {
                "id": 1574921,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "Try using two pointers that move at different speeds. If either of them can get to a null then it\\'s obvious there isn\\'t a cycle. But what happens if there is a cycle? Eventually the faster pointer will make a full lap and be equal to the slow pointer. Therefore if during the traversal the faster pointer == slower pointer, you can return true."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Nodes that contains in my life cycle are eat,sleep..repeat :("
                    },
                    {
                        "username": "HikuMai",
                        "content": "Leetcode has mercy on me this time :))"
                    },
                    {
                        "username": "harshit1271gupta",
                        "content": " public boolean hasCycle(ListNode head) {\\n    // apparoch 1   using hashset cuz if it store same location that means there is a cycle \\n    // HashSet<ListNode> map = new HashSet<>();\\n    //     ListNode temp = head;\\n    //     while (temp != null) {\\n    //         if (map.contains(temp)) {\\n    //             return true;\\n    //         }else{\\n    //             map.add(temp);\\n    //         }\\n    //         temp = temp.next;\\n    //     }\\n    //     return false;\\n    // }\\n   // apparoch 2    space complexity 0(1)\\n    ListNode slow = head;\\n    ListNode fast = head;\\n    if(head==null || head.next==null){\\n        return false;\\n    }\\n    while(fast!=null){\\n\\n        if(slow==null)return false;\\n        if(fast.next==null)return false;\\n        slow = slow.next;\\n        fast = fast.next.next;\\n        if(slow==fast)return true;\\n    }\\n    return false;"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "underdogsourav",
                        "content": "what is the use of mentioning the pos +  "
                    },
                    {
                        "username": "soukumpan",
                        "content": "ignore that "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "Here the set logic will not work because node-values may be repeated means for ex 2->4->3->7->4->6->null  then by set logic it will return true but actually it\\'s not containing any cycle so we need to use another logic for detect cycle ."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Why not? You just need to use node1 == node2 instead of node1.val == node2.val, means we check if a node actually refers to the same rather than checking a val. Works for Java.\\nBtw, it\\'s not necessary to use HashSet (or HashMap), it will work with simple list too, however Set seems to be faster.   "
                    },
                    {
                        "username": "ali__code",
                        "content": "how to use pos when it is not in parameter."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\n\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/3024832/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "knightryder098",
                        "content": "It\\'s given that POS is the valid position in the linked list. So if we just comapre it with 0, it should give us whether cycle is present or not. \\n\\nAm i am wrong? Plz explain . Thank You"
                    },
                    {
                        "username": "yazanmaini",
                        "content": "![image](https://assets.leetcode.com/users/images/e4307283-b136-4212-babe-2f7dd6051505_1596530623.2097838.png)\\n"
                    }
                ]
            },
            {
                "id": 1574160,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "Try using two pointers that move at different speeds. If either of them can get to a null then it\\'s obvious there isn\\'t a cycle. But what happens if there is a cycle? Eventually the faster pointer will make a full lap and be equal to the slow pointer. Therefore if during the traversal the faster pointer == slower pointer, you can return true."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Nodes that contains in my life cycle are eat,sleep..repeat :("
                    },
                    {
                        "username": "HikuMai",
                        "content": "Leetcode has mercy on me this time :))"
                    },
                    {
                        "username": "harshit1271gupta",
                        "content": " public boolean hasCycle(ListNode head) {\\n    // apparoch 1   using hashset cuz if it store same location that means there is a cycle \\n    // HashSet<ListNode> map = new HashSet<>();\\n    //     ListNode temp = head;\\n    //     while (temp != null) {\\n    //         if (map.contains(temp)) {\\n    //             return true;\\n    //         }else{\\n    //             map.add(temp);\\n    //         }\\n    //         temp = temp.next;\\n    //     }\\n    //     return false;\\n    // }\\n   // apparoch 2    space complexity 0(1)\\n    ListNode slow = head;\\n    ListNode fast = head;\\n    if(head==null || head.next==null){\\n        return false;\\n    }\\n    while(fast!=null){\\n\\n        if(slow==null)return false;\\n        if(fast.next==null)return false;\\n        slow = slow.next;\\n        fast = fast.next.next;\\n        if(slow==fast)return true;\\n    }\\n    return false;"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "underdogsourav",
                        "content": "what is the use of mentioning the pos +  "
                    },
                    {
                        "username": "soukumpan",
                        "content": "ignore that "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "Here the set logic will not work because node-values may be repeated means for ex 2->4->3->7->4->6->null  then by set logic it will return true but actually it\\'s not containing any cycle so we need to use another logic for detect cycle ."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Why not? You just need to use node1 == node2 instead of node1.val == node2.val, means we check if a node actually refers to the same rather than checking a val. Works for Java.\\nBtw, it\\'s not necessary to use HashSet (or HashMap), it will work with simple list too, however Set seems to be faster.   "
                    },
                    {
                        "username": "ali__code",
                        "content": "how to use pos when it is not in parameter."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\n\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/3024832/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "knightryder098",
                        "content": "It\\'s given that POS is the valid position in the linked list. So if we just comapre it with 0, it should give us whether cycle is present or not. \\n\\nAm i am wrong? Plz explain . Thank You"
                    },
                    {
                        "username": "yazanmaini",
                        "content": "![image](https://assets.leetcode.com/users/images/e4307283-b136-4212-babe-2f7dd6051505_1596530623.2097838.png)\\n"
                    }
                ]
            },
            {
                "id": 1573831,
                "content": [
                    {
                        "username": "Skidro",
                        "content": "Why are we moving the fast pointer with 2x speed why not with 3x or any other ?"
                    },
                    {
                        "username": "lmckeon",
                        "content": "By only gaining on the slow node by one node at a time, you guarantee that you only have to make one full loop through the cycle once slow enters it. Other values can cause you to jump over slow node and make more loops through the cycle which is slower. This is my opinion."
                    },
                    {
                        "username": "ShawnDu2020",
                        "content": "may i ask I cannot see the pos in the input variable, am I wrong?"
                    },
                    {
                        "username": "theonewhocreates",
                        "content": "In the example, it is given that position we have to check for will be part of the input. But it is not one of the attirbutes of the function. Is there something I\\'m missing?"
                    },
                    {
                        "username": "GCC97",
                        "content": "Input ixample in the question description has a pos variable and so does the test input. I cannot  access it. Why is it put there?"
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "therahulgoel",
                        "content": "Hi,\\nPlease suggest how can i submit the solution in Swift language as i dont see it the langauges options dropdown.\\n"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "so it doesnt depend on pos argument just check if any of the nodes are forming a cycle, i think this needs pure logical thinking"
                    },
                    {
                        "username": "roycwc",
                        "content": "For js user, you need to set up this at the beginning:\\n\\n```\\nlet toLinkedList = (arr, pos) => {\\n    class ListNode {\\n        constructor(val){\\n            this.val = val;\\n            this.next = null;\\n        }\\n    }\\n\\n    for(let i=0;i<arr.length;i++){\\n        arr[i] = new ListNode(arr[i])\\n    }\\n    for(let i=0;i<arr.length;i++){\\n        arr[i].next = i === arr.length - 1 ? (pos === -1 ? null : arr[pos]) : arr[i+1]\\n    }\\n    return arr[0]\\n}\\n\\nmodule.exports = { toLinkedList }\\n```\\n\\n```\\nvar arr  = [3,2,0,-4]\\nvar pos  = 1\\nvar linkedList = toLinkedList(arr, pos)\\n\\nvar result = hasCycle(linkedList)\\nassert.equal(true, result)\\n```"
                    },
                    {
                        "username": "chumaumenze",
                        "content": "#### Just testing out a Leetcode hack. Haha!\\n\\n```py\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return True if \"Error\" in str(head) else False\\n```"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`pos`  helps to indicate the node where the last node of the linked list points to\nfor example: [1,2,3,4,5,6]\nif `pos == 0` then `6->next = 1`\nif `pos == 1` then `6->next = 2`\nif `pos == 5` then `6->next = 6` (i.e. 6 points to itself, so there's also a valid cycle in the list)\nif `pos == -1` then `6->next = null`. hence, there's no cycle in the list\n\nbasically, if they give us `pos`, we can easily `return pos != -1` as the answer"
                    }
                ]
            },
            {
                "id": 1573061,
                "content": [
                    {
                        "username": "Skidro",
                        "content": "Why are we moving the fast pointer with 2x speed why not with 3x or any other ?"
                    },
                    {
                        "username": "lmckeon",
                        "content": "By only gaining on the slow node by one node at a time, you guarantee that you only have to make one full loop through the cycle once slow enters it. Other values can cause you to jump over slow node and make more loops through the cycle which is slower. This is my opinion."
                    },
                    {
                        "username": "ShawnDu2020",
                        "content": "may i ask I cannot see the pos in the input variable, am I wrong?"
                    },
                    {
                        "username": "theonewhocreates",
                        "content": "In the example, it is given that position we have to check for will be part of the input. But it is not one of the attirbutes of the function. Is there something I\\'m missing?"
                    },
                    {
                        "username": "GCC97",
                        "content": "Input ixample in the question description has a pos variable and so does the test input. I cannot  access it. Why is it put there?"
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "therahulgoel",
                        "content": "Hi,\\nPlease suggest how can i submit the solution in Swift language as i dont see it the langauges options dropdown.\\n"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "so it doesnt depend on pos argument just check if any of the nodes are forming a cycle, i think this needs pure logical thinking"
                    },
                    {
                        "username": "roycwc",
                        "content": "For js user, you need to set up this at the beginning:\\n\\n```\\nlet toLinkedList = (arr, pos) => {\\n    class ListNode {\\n        constructor(val){\\n            this.val = val;\\n            this.next = null;\\n        }\\n    }\\n\\n    for(let i=0;i<arr.length;i++){\\n        arr[i] = new ListNode(arr[i])\\n    }\\n    for(let i=0;i<arr.length;i++){\\n        arr[i].next = i === arr.length - 1 ? (pos === -1 ? null : arr[pos]) : arr[i+1]\\n    }\\n    return arr[0]\\n}\\n\\nmodule.exports = { toLinkedList }\\n```\\n\\n```\\nvar arr  = [3,2,0,-4]\\nvar pos  = 1\\nvar linkedList = toLinkedList(arr, pos)\\n\\nvar result = hasCycle(linkedList)\\nassert.equal(true, result)\\n```"
                    },
                    {
                        "username": "chumaumenze",
                        "content": "#### Just testing out a Leetcode hack. Haha!\\n\\n```py\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return True if \"Error\" in str(head) else False\\n```"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`pos`  helps to indicate the node where the last node of the linked list points to\nfor example: [1,2,3,4,5,6]\nif `pos == 0` then `6->next = 1`\nif `pos == 1` then `6->next = 2`\nif `pos == 5` then `6->next = 6` (i.e. 6 points to itself, so there's also a valid cycle in the list)\nif `pos == -1` then `6->next = null`. hence, there's no cycle in the list\n\nbasically, if they give us `pos`, we can easily `return pos != -1` as the answer"
                    }
                ]
            },
            {
                "id": 1572763,
                "content": [
                    {
                        "username": "Skidro",
                        "content": "Why are we moving the fast pointer with 2x speed why not with 3x or any other ?"
                    },
                    {
                        "username": "lmckeon",
                        "content": "By only gaining on the slow node by one node at a time, you guarantee that you only have to make one full loop through the cycle once slow enters it. Other values can cause you to jump over slow node and make more loops through the cycle which is slower. This is my opinion."
                    },
                    {
                        "username": "ShawnDu2020",
                        "content": "may i ask I cannot see the pos in the input variable, am I wrong?"
                    },
                    {
                        "username": "theonewhocreates",
                        "content": "In the example, it is given that position we have to check for will be part of the input. But it is not one of the attirbutes of the function. Is there something I\\'m missing?"
                    },
                    {
                        "username": "GCC97",
                        "content": "Input ixample in the question description has a pos variable and so does the test input. I cannot  access it. Why is it put there?"
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "therahulgoel",
                        "content": "Hi,\\nPlease suggest how can i submit the solution in Swift language as i dont see it the langauges options dropdown.\\n"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "so it doesnt depend on pos argument just check if any of the nodes are forming a cycle, i think this needs pure logical thinking"
                    },
                    {
                        "username": "roycwc",
                        "content": "For js user, you need to set up this at the beginning:\\n\\n```\\nlet toLinkedList = (arr, pos) => {\\n    class ListNode {\\n        constructor(val){\\n            this.val = val;\\n            this.next = null;\\n        }\\n    }\\n\\n    for(let i=0;i<arr.length;i++){\\n        arr[i] = new ListNode(arr[i])\\n    }\\n    for(let i=0;i<arr.length;i++){\\n        arr[i].next = i === arr.length - 1 ? (pos === -1 ? null : arr[pos]) : arr[i+1]\\n    }\\n    return arr[0]\\n}\\n\\nmodule.exports = { toLinkedList }\\n```\\n\\n```\\nvar arr  = [3,2,0,-4]\\nvar pos  = 1\\nvar linkedList = toLinkedList(arr, pos)\\n\\nvar result = hasCycle(linkedList)\\nassert.equal(true, result)\\n```"
                    },
                    {
                        "username": "chumaumenze",
                        "content": "#### Just testing out a Leetcode hack. Haha!\\n\\n```py\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return True if \"Error\" in str(head) else False\\n```"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`pos`  helps to indicate the node where the last node of the linked list points to\nfor example: [1,2,3,4,5,6]\nif `pos == 0` then `6->next = 1`\nif `pos == 1` then `6->next = 2`\nif `pos == 5` then `6->next = 6` (i.e. 6 points to itself, so there's also a valid cycle in the list)\nif `pos == -1` then `6->next = null`. hence, there's no cycle in the list\n\nbasically, if they give us `pos`, we can easily `return pos != -1` as the answer"
                    }
                ]
            },
            {
                "id": 1572342,
                "content": [
                    {
                        "username": "Skidro",
                        "content": "Why are we moving the fast pointer with 2x speed why not with 3x or any other ?"
                    },
                    {
                        "username": "lmckeon",
                        "content": "By only gaining on the slow node by one node at a time, you guarantee that you only have to make one full loop through the cycle once slow enters it. Other values can cause you to jump over slow node and make more loops through the cycle which is slower. This is my opinion."
                    },
                    {
                        "username": "ShawnDu2020",
                        "content": "may i ask I cannot see the pos in the input variable, am I wrong?"
                    },
                    {
                        "username": "theonewhocreates",
                        "content": "In the example, it is given that position we have to check for will be part of the input. But it is not one of the attirbutes of the function. Is there something I\\'m missing?"
                    },
                    {
                        "username": "GCC97",
                        "content": "Input ixample in the question description has a pos variable and so does the test input. I cannot  access it. Why is it put there?"
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "therahulgoel",
                        "content": "Hi,\\nPlease suggest how can i submit the solution in Swift language as i dont see it the langauges options dropdown.\\n"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "so it doesnt depend on pos argument just check if any of the nodes are forming a cycle, i think this needs pure logical thinking"
                    },
                    {
                        "username": "roycwc",
                        "content": "For js user, you need to set up this at the beginning:\\n\\n```\\nlet toLinkedList = (arr, pos) => {\\n    class ListNode {\\n        constructor(val){\\n            this.val = val;\\n            this.next = null;\\n        }\\n    }\\n\\n    for(let i=0;i<arr.length;i++){\\n        arr[i] = new ListNode(arr[i])\\n    }\\n    for(let i=0;i<arr.length;i++){\\n        arr[i].next = i === arr.length - 1 ? (pos === -1 ? null : arr[pos]) : arr[i+1]\\n    }\\n    return arr[0]\\n}\\n\\nmodule.exports = { toLinkedList }\\n```\\n\\n```\\nvar arr  = [3,2,0,-4]\\nvar pos  = 1\\nvar linkedList = toLinkedList(arr, pos)\\n\\nvar result = hasCycle(linkedList)\\nassert.equal(true, result)\\n```"
                    },
                    {
                        "username": "chumaumenze",
                        "content": "#### Just testing out a Leetcode hack. Haha!\\n\\n```py\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return True if \"Error\" in str(head) else False\\n```"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`pos`  helps to indicate the node where the last node of the linked list points to\nfor example: [1,2,3,4,5,6]\nif `pos == 0` then `6->next = 1`\nif `pos == 1` then `6->next = 2`\nif `pos == 5` then `6->next = 6` (i.e. 6 points to itself, so there's also a valid cycle in the list)\nif `pos == -1` then `6->next = null`. hence, there's no cycle in the list\n\nbasically, if they give us `pos`, we can easily `return pos != -1` as the answer"
                    }
                ]
            },
            {
                "id": 1575690,
                "content": [
                    {
                        "username": "Skidro",
                        "content": "Why are we moving the fast pointer with 2x speed why not with 3x or any other ?"
                    },
                    {
                        "username": "lmckeon",
                        "content": "By only gaining on the slow node by one node at a time, you guarantee that you only have to make one full loop through the cycle once slow enters it. Other values can cause you to jump over slow node and make more loops through the cycle which is slower. This is my opinion."
                    },
                    {
                        "username": "ShawnDu2020",
                        "content": "may i ask I cannot see the pos in the input variable, am I wrong?"
                    },
                    {
                        "username": "theonewhocreates",
                        "content": "In the example, it is given that position we have to check for will be part of the input. But it is not one of the attirbutes of the function. Is there something I\\'m missing?"
                    },
                    {
                        "username": "GCC97",
                        "content": "Input ixample in the question description has a pos variable and so does the test input. I cannot  access it. Why is it put there?"
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "therahulgoel",
                        "content": "Hi,\\nPlease suggest how can i submit the solution in Swift language as i dont see it the langauges options dropdown.\\n"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "so it doesnt depend on pos argument just check if any of the nodes are forming a cycle, i think this needs pure logical thinking"
                    },
                    {
                        "username": "roycwc",
                        "content": "For js user, you need to set up this at the beginning:\\n\\n```\\nlet toLinkedList = (arr, pos) => {\\n    class ListNode {\\n        constructor(val){\\n            this.val = val;\\n            this.next = null;\\n        }\\n    }\\n\\n    for(let i=0;i<arr.length;i++){\\n        arr[i] = new ListNode(arr[i])\\n    }\\n    for(let i=0;i<arr.length;i++){\\n        arr[i].next = i === arr.length - 1 ? (pos === -1 ? null : arr[pos]) : arr[i+1]\\n    }\\n    return arr[0]\\n}\\n\\nmodule.exports = { toLinkedList }\\n```\\n\\n```\\nvar arr  = [3,2,0,-4]\\nvar pos  = 1\\nvar linkedList = toLinkedList(arr, pos)\\n\\nvar result = hasCycle(linkedList)\\nassert.equal(true, result)\\n```"
                    },
                    {
                        "username": "chumaumenze",
                        "content": "#### Just testing out a Leetcode hack. Haha!\\n\\n```py\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return True if \"Error\" in str(head) else False\\n```"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`pos`  helps to indicate the node where the last node of the linked list points to\nfor example: [1,2,3,4,5,6]\nif `pos == 0` then `6->next = 1`\nif `pos == 1` then `6->next = 2`\nif `pos == 5` then `6->next = 6` (i.e. 6 points to itself, so there's also a valid cycle in the list)\nif `pos == -1` then `6->next = null`. hence, there's no cycle in the list\n\nbasically, if they give us `pos`, we can easily `return pos != -1` as the answer"
                    }
                ]
            },
            {
                "id": 1573017,
                "content": [
                    {
                        "username": "Skidro",
                        "content": "Why are we moving the fast pointer with 2x speed why not with 3x or any other ?"
                    },
                    {
                        "username": "lmckeon",
                        "content": "By only gaining on the slow node by one node at a time, you guarantee that you only have to make one full loop through the cycle once slow enters it. Other values can cause you to jump over slow node and make more loops through the cycle which is slower. This is my opinion."
                    },
                    {
                        "username": "ShawnDu2020",
                        "content": "may i ask I cannot see the pos in the input variable, am I wrong?"
                    },
                    {
                        "username": "theonewhocreates",
                        "content": "In the example, it is given that position we have to check for will be part of the input. But it is not one of the attirbutes of the function. Is there something I\\'m missing?"
                    },
                    {
                        "username": "GCC97",
                        "content": "Input ixample in the question description has a pos variable and so does the test input. I cannot  access it. Why is it put there?"
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "therahulgoel",
                        "content": "Hi,\\nPlease suggest how can i submit the solution in Swift language as i dont see it the langauges options dropdown.\\n"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "so it doesnt depend on pos argument just check if any of the nodes are forming a cycle, i think this needs pure logical thinking"
                    },
                    {
                        "username": "roycwc",
                        "content": "For js user, you need to set up this at the beginning:\\n\\n```\\nlet toLinkedList = (arr, pos) => {\\n    class ListNode {\\n        constructor(val){\\n            this.val = val;\\n            this.next = null;\\n        }\\n    }\\n\\n    for(let i=0;i<arr.length;i++){\\n        arr[i] = new ListNode(arr[i])\\n    }\\n    for(let i=0;i<arr.length;i++){\\n        arr[i].next = i === arr.length - 1 ? (pos === -1 ? null : arr[pos]) : arr[i+1]\\n    }\\n    return arr[0]\\n}\\n\\nmodule.exports = { toLinkedList }\\n```\\n\\n```\\nvar arr  = [3,2,0,-4]\\nvar pos  = 1\\nvar linkedList = toLinkedList(arr, pos)\\n\\nvar result = hasCycle(linkedList)\\nassert.equal(true, result)\\n```"
                    },
                    {
                        "username": "chumaumenze",
                        "content": "#### Just testing out a Leetcode hack. Haha!\\n\\n```py\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return True if \"Error\" in str(head) else False\\n```"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`pos`  helps to indicate the node where the last node of the linked list points to\nfor example: [1,2,3,4,5,6]\nif `pos == 0` then `6->next = 1`\nif `pos == 1` then `6->next = 2`\nif `pos == 5` then `6->next = 6` (i.e. 6 points to itself, so there's also a valid cycle in the list)\nif `pos == -1` then `6->next = null`. hence, there's no cycle in the list\n\nbasically, if they give us `pos`, we can easily `return pos != -1` as the answer"
                    }
                ]
            },
            {
                "id": 2075357,
                "content": [
                    {
                        "username": "Skidro",
                        "content": "Why are we moving the fast pointer with 2x speed why not with 3x or any other ?"
                    },
                    {
                        "username": "lmckeon",
                        "content": "By only gaining on the slow node by one node at a time, you guarantee that you only have to make one full loop through the cycle once slow enters it. Other values can cause you to jump over slow node and make more loops through the cycle which is slower. This is my opinion."
                    },
                    {
                        "username": "ShawnDu2020",
                        "content": "may i ask I cannot see the pos in the input variable, am I wrong?"
                    },
                    {
                        "username": "theonewhocreates",
                        "content": "In the example, it is given that position we have to check for will be part of the input. But it is not one of the attirbutes of the function. Is there something I\\'m missing?"
                    },
                    {
                        "username": "GCC97",
                        "content": "Input ixample in the question description has a pos variable and so does the test input. I cannot  access it. Why is it put there?"
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "therahulgoel",
                        "content": "Hi,\\nPlease suggest how can i submit the solution in Swift language as i dont see it the langauges options dropdown.\\n"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "so it doesnt depend on pos argument just check if any of the nodes are forming a cycle, i think this needs pure logical thinking"
                    },
                    {
                        "username": "roycwc",
                        "content": "For js user, you need to set up this at the beginning:\\n\\n```\\nlet toLinkedList = (arr, pos) => {\\n    class ListNode {\\n        constructor(val){\\n            this.val = val;\\n            this.next = null;\\n        }\\n    }\\n\\n    for(let i=0;i<arr.length;i++){\\n        arr[i] = new ListNode(arr[i])\\n    }\\n    for(let i=0;i<arr.length;i++){\\n        arr[i].next = i === arr.length - 1 ? (pos === -1 ? null : arr[pos]) : arr[i+1]\\n    }\\n    return arr[0]\\n}\\n\\nmodule.exports = { toLinkedList }\\n```\\n\\n```\\nvar arr  = [3,2,0,-4]\\nvar pos  = 1\\nvar linkedList = toLinkedList(arr, pos)\\n\\nvar result = hasCycle(linkedList)\\nassert.equal(true, result)\\n```"
                    },
                    {
                        "username": "chumaumenze",
                        "content": "#### Just testing out a Leetcode hack. Haha!\\n\\n```py\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return True if \"Error\" in str(head) else False\\n```"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`pos`  helps to indicate the node where the last node of the linked list points to\nfor example: [1,2,3,4,5,6]\nif `pos == 0` then `6->next = 1`\nif `pos == 1` then `6->next = 2`\nif `pos == 5` then `6->next = 6` (i.e. 6 points to itself, so there's also a valid cycle in the list)\nif `pos == -1` then `6->next = null`. hence, there's no cycle in the list\n\nbasically, if they give us `pos`, we can easily `return pos != -1` as the answer"
                    }
                ]
            },
            {
                "id": 2067090,
                "content": [
                    {
                        "username": "Skidro",
                        "content": "Why are we moving the fast pointer with 2x speed why not with 3x or any other ?"
                    },
                    {
                        "username": "lmckeon",
                        "content": "By only gaining on the slow node by one node at a time, you guarantee that you only have to make one full loop through the cycle once slow enters it. Other values can cause you to jump over slow node and make more loops through the cycle which is slower. This is my opinion."
                    },
                    {
                        "username": "ShawnDu2020",
                        "content": "may i ask I cannot see the pos in the input variable, am I wrong?"
                    },
                    {
                        "username": "theonewhocreates",
                        "content": "In the example, it is given that position we have to check for will be part of the input. But it is not one of the attirbutes of the function. Is there something I\\'m missing?"
                    },
                    {
                        "username": "GCC97",
                        "content": "Input ixample in the question description has a pos variable and so does the test input. I cannot  access it. Why is it put there?"
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "therahulgoel",
                        "content": "Hi,\\nPlease suggest how can i submit the solution in Swift language as i dont see it the langauges options dropdown.\\n"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "so it doesnt depend on pos argument just check if any of the nodes are forming a cycle, i think this needs pure logical thinking"
                    },
                    {
                        "username": "roycwc",
                        "content": "For js user, you need to set up this at the beginning:\\n\\n```\\nlet toLinkedList = (arr, pos) => {\\n    class ListNode {\\n        constructor(val){\\n            this.val = val;\\n            this.next = null;\\n        }\\n    }\\n\\n    for(let i=0;i<arr.length;i++){\\n        arr[i] = new ListNode(arr[i])\\n    }\\n    for(let i=0;i<arr.length;i++){\\n        arr[i].next = i === arr.length - 1 ? (pos === -1 ? null : arr[pos]) : arr[i+1]\\n    }\\n    return arr[0]\\n}\\n\\nmodule.exports = { toLinkedList }\\n```\\n\\n```\\nvar arr  = [3,2,0,-4]\\nvar pos  = 1\\nvar linkedList = toLinkedList(arr, pos)\\n\\nvar result = hasCycle(linkedList)\\nassert.equal(true, result)\\n```"
                    },
                    {
                        "username": "chumaumenze",
                        "content": "#### Just testing out a Leetcode hack. Haha!\\n\\n```py\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return True if \"Error\" in str(head) else False\\n```"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`pos`  helps to indicate the node where the last node of the linked list points to\nfor example: [1,2,3,4,5,6]\nif `pos == 0` then `6->next = 1`\nif `pos == 1` then `6->next = 2`\nif `pos == 5` then `6->next = 6` (i.e. 6 points to itself, so there's also a valid cycle in the list)\nif `pos == -1` then `6->next = null`. hence, there's no cycle in the list\n\nbasically, if they give us `pos`, we can easily `return pos != -1` as the answer"
                    }
                ]
            },
            {
                "id": 2064454,
                "content": [
                    {
                        "username": "Skidro",
                        "content": "Why are we moving the fast pointer with 2x speed why not with 3x or any other ?"
                    },
                    {
                        "username": "lmckeon",
                        "content": "By only gaining on the slow node by one node at a time, you guarantee that you only have to make one full loop through the cycle once slow enters it. Other values can cause you to jump over slow node and make more loops through the cycle which is slower. This is my opinion."
                    },
                    {
                        "username": "ShawnDu2020",
                        "content": "may i ask I cannot see the pos in the input variable, am I wrong?"
                    },
                    {
                        "username": "theonewhocreates",
                        "content": "In the example, it is given that position we have to check for will be part of the input. But it is not one of the attirbutes of the function. Is there something I\\'m missing?"
                    },
                    {
                        "username": "GCC97",
                        "content": "Input ixample in the question description has a pos variable and so does the test input. I cannot  access it. Why is it put there?"
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "therahulgoel",
                        "content": "Hi,\\nPlease suggest how can i submit the solution in Swift language as i dont see it the langauges options dropdown.\\n"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "so it doesnt depend on pos argument just check if any of the nodes are forming a cycle, i think this needs pure logical thinking"
                    },
                    {
                        "username": "roycwc",
                        "content": "For js user, you need to set up this at the beginning:\\n\\n```\\nlet toLinkedList = (arr, pos) => {\\n    class ListNode {\\n        constructor(val){\\n            this.val = val;\\n            this.next = null;\\n        }\\n    }\\n\\n    for(let i=0;i<arr.length;i++){\\n        arr[i] = new ListNode(arr[i])\\n    }\\n    for(let i=0;i<arr.length;i++){\\n        arr[i].next = i === arr.length - 1 ? (pos === -1 ? null : arr[pos]) : arr[i+1]\\n    }\\n    return arr[0]\\n}\\n\\nmodule.exports = { toLinkedList }\\n```\\n\\n```\\nvar arr  = [3,2,0,-4]\\nvar pos  = 1\\nvar linkedList = toLinkedList(arr, pos)\\n\\nvar result = hasCycle(linkedList)\\nassert.equal(true, result)\\n```"
                    },
                    {
                        "username": "chumaumenze",
                        "content": "#### Just testing out a Leetcode hack. Haha!\\n\\n```py\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return True if \"Error\" in str(head) else False\\n```"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`pos`  helps to indicate the node where the last node of the linked list points to\nfor example: [1,2,3,4,5,6]\nif `pos == 0` then `6->next = 1`\nif `pos == 1` then `6->next = 2`\nif `pos == 5` then `6->next = 6` (i.e. 6 points to itself, so there's also a valid cycle in the list)\nif `pos == -1` then `6->next = null`. hence, there's no cycle in the list\n\nbasically, if they give us `pos`, we can easily `return pos != -1` as the answer"
                    }
                ]
            },
            {
                "id": 2063886,
                "content": [
                    {
                        "username": "Skidro",
                        "content": "Why are we moving the fast pointer with 2x speed why not with 3x or any other ?"
                    },
                    {
                        "username": "lmckeon",
                        "content": "By only gaining on the slow node by one node at a time, you guarantee that you only have to make one full loop through the cycle once slow enters it. Other values can cause you to jump over slow node and make more loops through the cycle which is slower. This is my opinion."
                    },
                    {
                        "username": "ShawnDu2020",
                        "content": "may i ask I cannot see the pos in the input variable, am I wrong?"
                    },
                    {
                        "username": "theonewhocreates",
                        "content": "In the example, it is given that position we have to check for will be part of the input. But it is not one of the attirbutes of the function. Is there something I\\'m missing?"
                    },
                    {
                        "username": "GCC97",
                        "content": "Input ixample in the question description has a pos variable and so does the test input. I cannot  access it. Why is it put there?"
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "therahulgoel",
                        "content": "Hi,\\nPlease suggest how can i submit the solution in Swift language as i dont see it the langauges options dropdown.\\n"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "so it doesnt depend on pos argument just check if any of the nodes are forming a cycle, i think this needs pure logical thinking"
                    },
                    {
                        "username": "roycwc",
                        "content": "For js user, you need to set up this at the beginning:\\n\\n```\\nlet toLinkedList = (arr, pos) => {\\n    class ListNode {\\n        constructor(val){\\n            this.val = val;\\n            this.next = null;\\n        }\\n    }\\n\\n    for(let i=0;i<arr.length;i++){\\n        arr[i] = new ListNode(arr[i])\\n    }\\n    for(let i=0;i<arr.length;i++){\\n        arr[i].next = i === arr.length - 1 ? (pos === -1 ? null : arr[pos]) : arr[i+1]\\n    }\\n    return arr[0]\\n}\\n\\nmodule.exports = { toLinkedList }\\n```\\n\\n```\\nvar arr  = [3,2,0,-4]\\nvar pos  = 1\\nvar linkedList = toLinkedList(arr, pos)\\n\\nvar result = hasCycle(linkedList)\\nassert.equal(true, result)\\n```"
                    },
                    {
                        "username": "chumaumenze",
                        "content": "#### Just testing out a Leetcode hack. Haha!\\n\\n```py\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        return True if \"Error\" in str(head) else False\\n```"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`pos`  helps to indicate the node where the last node of the linked list points to\nfor example: [1,2,3,4,5,6]\nif `pos == 0` then `6->next = 1`\nif `pos == 1` then `6->next = 2`\nif `pos == 5` then `6->next = 6` (i.e. 6 points to itself, so there's also a valid cycle in the list)\nif `pos == -1` then `6->next = null`. hence, there's no cycle in the list\n\nbasically, if they give us `pos`, we can easily `return pos != -1` as the answer"
                    }
                ]
            },
            {
                "id": 2059854,
                "content": [
                    {
                        "username": "AayushSrivastav29",
                        "content": "Make two pointers-\\n1) fast; which travels two nodes at once\\n2) slow; which travels one node at a time. \\nat any future node they will meet bcz its a circle, then return true, otherwise false."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "runtime error although the cases are passed in the test runs,  any idea?  thanks\n\nattributeError: 'NoneType' object has no attribute 'next'\n    fast=head.next\nLine 29 in hasCycle (Solution.py)\n    ret = Solution().hasCycle(param_1)\nLine 61 in _driver (Solution.py)\n    _driver()\nLine 74 in <module> (Solution.py)"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) oh yeah, I missed a small test case lol. Updated the answer."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) I copied and pasted your code,  it got the same error.\\n"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) This is a rather simple but confusing error. \nThis code would fail for the testcases:\n```\n[1,2,3]\n-1\n[]\n-1\n```\n\nYou initialized the fast pointer to `head.next` (in this case 2), incremented fast twice (now pointing at `None`). Now `while` tries to call `fast.next` which is `None.next` and hence the error. Set both to `head` at first but then don't forget to reorder the if statement to increment pointers and then check and check if `fast` is not `None` in the `while` loop.\n `slow.next` can never be `None` (why? because `fast` would've already got there), instead you should be checking whether `fast` is `None`.\n\nAlso, check if `slow` is same as `fast` instead of checking if they are equal. Because some test cases have repeated values, but they are not the same node. Example test case:\n```\n[1,2,3,2,4]\n-1\n```\n\nFixed code:\n```python\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        slow=head\n        fast=head\n        while fast and fast.next:\n            # print('here')\n            slow=slow.next\n            fast=fast.next.next\n            if(slow==fast):\n                return True\n                \n        return False\n```\n\nHope this helps. \n"
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) # Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.next = None\\n\\n\\n\\n\\n# Time complexity is O(N) \\n# Space Complexity is O(1)\\n\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        slow=head\\n        fast=head.next\\n\\n        while(slow.next!=None and fast.next!=None):\\n            # print(\\'here\\')\\n            if(slow.val==fast.val):\\n                return True\\n            else:\\n                slow=slow.next\\n                fast=fast.next.next\\n        return False"
                    },
                    {
                        "username": "parapsychic",
                        "content": "you are calling next on a NoneType. If you could post the code, I can check. It\\'s usually because you reached the end of the list and still called next which returns a None, but then you call next again on that None."
                    },
                    {
                        "username": "parapsychic",
                        "content": "So, I was looking at some of the best memory efficient solution and I found that they just took the `pos` variable and returned true or false. Isn\\'t that cheating? I think those submissions should be removed.\\n[sample of cheating](https://imgur.com/yo6IPk2)"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Don\\'t worry. Practice for your own self-improvement. People who cheat are harming themselves. They won\\'t gain anything. Just keep improving, man!"
                    },
                    {
                        "username": "sergei99",
                        "content": "There is lots of cheating here. E.g. people open the output file (they somehow know its name) and write the hardcoded solution output from a static block executed prior to measurement stuff. So they get a really low execution time of their code, which is totally useless in solving real life problems."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "EASY   | |   USING SLOW & FAST POINTER\nconsider this example as you are in a circular racing track and there another person (he is faster then you ) , so if in 1second you go 1metre he in 1second goes 2meter, so now you start running and there will be a time where he will catch you from behind (as track is circular) if this happens then our list is circular else our list is not circular(consider the track was straight and the faster person finished the track but didn't overtake you as it was a straight track)\n\nNOTE:- there is no need to use 'pos' , our logic works fine.\n\n1. Check a base condition if list is empty or not.\n\n2. Initialize two pointer slow and fast to head.\n\n3. traverse the list and during each iteration move 'slow' 1 step ahead and move 'fast' 2 step ahead. And within this loop check if our slow and fast pointer are pointing to same node or not , if they are pointing to same node somewhere in the list then we got our cycle and return true.\n\n4. But even after loop termination if these two pointers didn't point same position then it is sure that they never met and we can say our list does not has any cycle.\n\n\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if(head == NULL)\n            return false;\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while(fast!=NULL && fast->next !=NULL){\n            slow = slow->next;\n            fast = fast->next->next;\n            if(slow==fast)\n                return true;\n        }\n        return false;\n    }\n};\n"
                    },
                    {
                        "username": "Bhedanti",
                        "content": "My solution was to go throught entire LinkedList and keep saving the values in a list. If I come across any values in the linkedlist which is already present in the list I will return false. But for one of my test cases I can see 2 5s in the LL and pos = -1 the expected output is false. Why? Shouldn\\'t it be true?"
                    },
                    {
                        "username": "toanngo",
                        "content": "Instead of using a fast/slow pointer, you can just use one, and have a map that checks whether you\\'ve visited the node. In python, do something like `visited = {head:True}`"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Think about 2 pointers where one moves one node at a time while the other moves 2 at a time. What will happen then??"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "Ignore Pos . We can use fast and slow pointers or regular old reliable set."
                    },
                    {
                        "username": "Mouli_ch",
                        "content": "can anyone please explain the problem briefly"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "So, we need to find if there is a cycle in the linked list or not. In the explanation, they propose this pos argument in order to show that the \\'last\\' element of the linked list is pointing to. another element in the same list, creating then a infinite cycle in it. \\nSo our duty is to identify if a cycle exists in the leetcode tests."
                    },
                    {
                        "username": "jebbe",
                        "content": "As a beginner with JS, There is no way to log the head object to understand the linked list properties due to there being a cycle in the object. The third testcase is only one element.    \\nIncluding a longer true testcase would be more beginner friendly for me :)"
                    }
                ]
            },
            {
                "id": 2056077,
                "content": [
                    {
                        "username": "AayushSrivastav29",
                        "content": "Make two pointers-\\n1) fast; which travels two nodes at once\\n2) slow; which travels one node at a time. \\nat any future node they will meet bcz its a circle, then return true, otherwise false."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "runtime error although the cases are passed in the test runs,  any idea?  thanks\n\nattributeError: 'NoneType' object has no attribute 'next'\n    fast=head.next\nLine 29 in hasCycle (Solution.py)\n    ret = Solution().hasCycle(param_1)\nLine 61 in _driver (Solution.py)\n    _driver()\nLine 74 in <module> (Solution.py)"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) oh yeah, I missed a small test case lol. Updated the answer."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) I copied and pasted your code,  it got the same error.\\n"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) This is a rather simple but confusing error. \nThis code would fail for the testcases:\n```\n[1,2,3]\n-1\n[]\n-1\n```\n\nYou initialized the fast pointer to `head.next` (in this case 2), incremented fast twice (now pointing at `None`). Now `while` tries to call `fast.next` which is `None.next` and hence the error. Set both to `head` at first but then don't forget to reorder the if statement to increment pointers and then check and check if `fast` is not `None` in the `while` loop.\n `slow.next` can never be `None` (why? because `fast` would've already got there), instead you should be checking whether `fast` is `None`.\n\nAlso, check if `slow` is same as `fast` instead of checking if they are equal. Because some test cases have repeated values, but they are not the same node. Example test case:\n```\n[1,2,3,2,4]\n-1\n```\n\nFixed code:\n```python\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        slow=head\n        fast=head\n        while fast and fast.next:\n            # print('here')\n            slow=slow.next\n            fast=fast.next.next\n            if(slow==fast):\n                return True\n                \n        return False\n```\n\nHope this helps. \n"
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) # Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.next = None\\n\\n\\n\\n\\n# Time complexity is O(N) \\n# Space Complexity is O(1)\\n\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        slow=head\\n        fast=head.next\\n\\n        while(slow.next!=None and fast.next!=None):\\n            # print(\\'here\\')\\n            if(slow.val==fast.val):\\n                return True\\n            else:\\n                slow=slow.next\\n                fast=fast.next.next\\n        return False"
                    },
                    {
                        "username": "parapsychic",
                        "content": "you are calling next on a NoneType. If you could post the code, I can check. It\\'s usually because you reached the end of the list and still called next which returns a None, but then you call next again on that None."
                    },
                    {
                        "username": "parapsychic",
                        "content": "So, I was looking at some of the best memory efficient solution and I found that they just took the `pos` variable and returned true or false. Isn\\'t that cheating? I think those submissions should be removed.\\n[sample of cheating](https://imgur.com/yo6IPk2)"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Don\\'t worry. Practice for your own self-improvement. People who cheat are harming themselves. They won\\'t gain anything. Just keep improving, man!"
                    },
                    {
                        "username": "sergei99",
                        "content": "There is lots of cheating here. E.g. people open the output file (they somehow know its name) and write the hardcoded solution output from a static block executed prior to measurement stuff. So they get a really low execution time of their code, which is totally useless in solving real life problems."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "EASY   | |   USING SLOW & FAST POINTER\nconsider this example as you are in a circular racing track and there another person (he is faster then you ) , so if in 1second you go 1metre he in 1second goes 2meter, so now you start running and there will be a time where he will catch you from behind (as track is circular) if this happens then our list is circular else our list is not circular(consider the track was straight and the faster person finished the track but didn't overtake you as it was a straight track)\n\nNOTE:- there is no need to use 'pos' , our logic works fine.\n\n1. Check a base condition if list is empty or not.\n\n2. Initialize two pointer slow and fast to head.\n\n3. traverse the list and during each iteration move 'slow' 1 step ahead and move 'fast' 2 step ahead. And within this loop check if our slow and fast pointer are pointing to same node or not , if they are pointing to same node somewhere in the list then we got our cycle and return true.\n\n4. But even after loop termination if these two pointers didn't point same position then it is sure that they never met and we can say our list does not has any cycle.\n\n\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if(head == NULL)\n            return false;\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while(fast!=NULL && fast->next !=NULL){\n            slow = slow->next;\n            fast = fast->next->next;\n            if(slow==fast)\n                return true;\n        }\n        return false;\n    }\n};\n"
                    },
                    {
                        "username": "Bhedanti",
                        "content": "My solution was to go throught entire LinkedList and keep saving the values in a list. If I come across any values in the linkedlist which is already present in the list I will return false. But for one of my test cases I can see 2 5s in the LL and pos = -1 the expected output is false. Why? Shouldn\\'t it be true?"
                    },
                    {
                        "username": "toanngo",
                        "content": "Instead of using a fast/slow pointer, you can just use one, and have a map that checks whether you\\'ve visited the node. In python, do something like `visited = {head:True}`"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Think about 2 pointers where one moves one node at a time while the other moves 2 at a time. What will happen then??"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "Ignore Pos . We can use fast and slow pointers or regular old reliable set."
                    },
                    {
                        "username": "Mouli_ch",
                        "content": "can anyone please explain the problem briefly"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "So, we need to find if there is a cycle in the linked list or not. In the explanation, they propose this pos argument in order to show that the \\'last\\' element of the linked list is pointing to. another element in the same list, creating then a infinite cycle in it. \\nSo our duty is to identify if a cycle exists in the leetcode tests."
                    },
                    {
                        "username": "jebbe",
                        "content": "As a beginner with JS, There is no way to log the head object to understand the linked list properties due to there being a cycle in the object. The third testcase is only one element.    \\nIncluding a longer true testcase would be more beginner friendly for me :)"
                    }
                ]
            },
            {
                "id": 2053519,
                "content": [
                    {
                        "username": "AayushSrivastav29",
                        "content": "Make two pointers-\\n1) fast; which travels two nodes at once\\n2) slow; which travels one node at a time. \\nat any future node they will meet bcz its a circle, then return true, otherwise false."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "runtime error although the cases are passed in the test runs,  any idea?  thanks\n\nattributeError: 'NoneType' object has no attribute 'next'\n    fast=head.next\nLine 29 in hasCycle (Solution.py)\n    ret = Solution().hasCycle(param_1)\nLine 61 in _driver (Solution.py)\n    _driver()\nLine 74 in <module> (Solution.py)"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) oh yeah, I missed a small test case lol. Updated the answer."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) I copied and pasted your code,  it got the same error.\\n"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) This is a rather simple but confusing error. \nThis code would fail for the testcases:\n```\n[1,2,3]\n-1\n[]\n-1\n```\n\nYou initialized the fast pointer to `head.next` (in this case 2), incremented fast twice (now pointing at `None`). Now `while` tries to call `fast.next` which is `None.next` and hence the error. Set both to `head` at first but then don't forget to reorder the if statement to increment pointers and then check and check if `fast` is not `None` in the `while` loop.\n `slow.next` can never be `None` (why? because `fast` would've already got there), instead you should be checking whether `fast` is `None`.\n\nAlso, check if `slow` is same as `fast` instead of checking if they are equal. Because some test cases have repeated values, but they are not the same node. Example test case:\n```\n[1,2,3,2,4]\n-1\n```\n\nFixed code:\n```python\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        slow=head\n        fast=head\n        while fast and fast.next:\n            # print('here')\n            slow=slow.next\n            fast=fast.next.next\n            if(slow==fast):\n                return True\n                \n        return False\n```\n\nHope this helps. \n"
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) # Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.next = None\\n\\n\\n\\n\\n# Time complexity is O(N) \\n# Space Complexity is O(1)\\n\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        slow=head\\n        fast=head.next\\n\\n        while(slow.next!=None and fast.next!=None):\\n            # print(\\'here\\')\\n            if(slow.val==fast.val):\\n                return True\\n            else:\\n                slow=slow.next\\n                fast=fast.next.next\\n        return False"
                    },
                    {
                        "username": "parapsychic",
                        "content": "you are calling next on a NoneType. If you could post the code, I can check. It\\'s usually because you reached the end of the list and still called next which returns a None, but then you call next again on that None."
                    },
                    {
                        "username": "parapsychic",
                        "content": "So, I was looking at some of the best memory efficient solution and I found that they just took the `pos` variable and returned true or false. Isn\\'t that cheating? I think those submissions should be removed.\\n[sample of cheating](https://imgur.com/yo6IPk2)"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Don\\'t worry. Practice for your own self-improvement. People who cheat are harming themselves. They won\\'t gain anything. Just keep improving, man!"
                    },
                    {
                        "username": "sergei99",
                        "content": "There is lots of cheating here. E.g. people open the output file (they somehow know its name) and write the hardcoded solution output from a static block executed prior to measurement stuff. So they get a really low execution time of their code, which is totally useless in solving real life problems."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "EASY   | |   USING SLOW & FAST POINTER\nconsider this example as you are in a circular racing track and there another person (he is faster then you ) , so if in 1second you go 1metre he in 1second goes 2meter, so now you start running and there will be a time where he will catch you from behind (as track is circular) if this happens then our list is circular else our list is not circular(consider the track was straight and the faster person finished the track but didn't overtake you as it was a straight track)\n\nNOTE:- there is no need to use 'pos' , our logic works fine.\n\n1. Check a base condition if list is empty or not.\n\n2. Initialize two pointer slow and fast to head.\n\n3. traverse the list and during each iteration move 'slow' 1 step ahead and move 'fast' 2 step ahead. And within this loop check if our slow and fast pointer are pointing to same node or not , if they are pointing to same node somewhere in the list then we got our cycle and return true.\n\n4. But even after loop termination if these two pointers didn't point same position then it is sure that they never met and we can say our list does not has any cycle.\n\n\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if(head == NULL)\n            return false;\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while(fast!=NULL && fast->next !=NULL){\n            slow = slow->next;\n            fast = fast->next->next;\n            if(slow==fast)\n                return true;\n        }\n        return false;\n    }\n};\n"
                    },
                    {
                        "username": "Bhedanti",
                        "content": "My solution was to go throught entire LinkedList and keep saving the values in a list. If I come across any values in the linkedlist which is already present in the list I will return false. But for one of my test cases I can see 2 5s in the LL and pos = -1 the expected output is false. Why? Shouldn\\'t it be true?"
                    },
                    {
                        "username": "toanngo",
                        "content": "Instead of using a fast/slow pointer, you can just use one, and have a map that checks whether you\\'ve visited the node. In python, do something like `visited = {head:True}`"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Think about 2 pointers where one moves one node at a time while the other moves 2 at a time. What will happen then??"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "Ignore Pos . We can use fast and slow pointers or regular old reliable set."
                    },
                    {
                        "username": "Mouli_ch",
                        "content": "can anyone please explain the problem briefly"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "So, we need to find if there is a cycle in the linked list or not. In the explanation, they propose this pos argument in order to show that the \\'last\\' element of the linked list is pointing to. another element in the same list, creating then a infinite cycle in it. \\nSo our duty is to identify if a cycle exists in the leetcode tests."
                    },
                    {
                        "username": "jebbe",
                        "content": "As a beginner with JS, There is no way to log the head object to understand the linked list properties due to there being a cycle in the object. The third testcase is only one element.    \\nIncluding a longer true testcase would be more beginner friendly for me :)"
                    }
                ]
            },
            {
                "id": 2049018,
                "content": [
                    {
                        "username": "AayushSrivastav29",
                        "content": "Make two pointers-\\n1) fast; which travels two nodes at once\\n2) slow; which travels one node at a time. \\nat any future node they will meet bcz its a circle, then return true, otherwise false."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "runtime error although the cases are passed in the test runs,  any idea?  thanks\n\nattributeError: 'NoneType' object has no attribute 'next'\n    fast=head.next\nLine 29 in hasCycle (Solution.py)\n    ret = Solution().hasCycle(param_1)\nLine 61 in _driver (Solution.py)\n    _driver()\nLine 74 in <module> (Solution.py)"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) oh yeah, I missed a small test case lol. Updated the answer."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) I copied and pasted your code,  it got the same error.\\n"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) This is a rather simple but confusing error. \nThis code would fail for the testcases:\n```\n[1,2,3]\n-1\n[]\n-1\n```\n\nYou initialized the fast pointer to `head.next` (in this case 2), incremented fast twice (now pointing at `None`). Now `while` tries to call `fast.next` which is `None.next` and hence the error. Set both to `head` at first but then don't forget to reorder the if statement to increment pointers and then check and check if `fast` is not `None` in the `while` loop.\n `slow.next` can never be `None` (why? because `fast` would've already got there), instead you should be checking whether `fast` is `None`.\n\nAlso, check if `slow` is same as `fast` instead of checking if they are equal. Because some test cases have repeated values, but they are not the same node. Example test case:\n```\n[1,2,3,2,4]\n-1\n```\n\nFixed code:\n```python\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        slow=head\n        fast=head\n        while fast and fast.next:\n            # print('here')\n            slow=slow.next\n            fast=fast.next.next\n            if(slow==fast):\n                return True\n                \n        return False\n```\n\nHope this helps. \n"
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) # Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.next = None\\n\\n\\n\\n\\n# Time complexity is O(N) \\n# Space Complexity is O(1)\\n\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        slow=head\\n        fast=head.next\\n\\n        while(slow.next!=None and fast.next!=None):\\n            # print(\\'here\\')\\n            if(slow.val==fast.val):\\n                return True\\n            else:\\n                slow=slow.next\\n                fast=fast.next.next\\n        return False"
                    },
                    {
                        "username": "parapsychic",
                        "content": "you are calling next on a NoneType. If you could post the code, I can check. It\\'s usually because you reached the end of the list and still called next which returns a None, but then you call next again on that None."
                    },
                    {
                        "username": "parapsychic",
                        "content": "So, I was looking at some of the best memory efficient solution and I found that they just took the `pos` variable and returned true or false. Isn\\'t that cheating? I think those submissions should be removed.\\n[sample of cheating](https://imgur.com/yo6IPk2)"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Don\\'t worry. Practice for your own self-improvement. People who cheat are harming themselves. They won\\'t gain anything. Just keep improving, man!"
                    },
                    {
                        "username": "sergei99",
                        "content": "There is lots of cheating here. E.g. people open the output file (they somehow know its name) and write the hardcoded solution output from a static block executed prior to measurement stuff. So they get a really low execution time of their code, which is totally useless in solving real life problems."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "EASY   | |   USING SLOW & FAST POINTER\nconsider this example as you are in a circular racing track and there another person (he is faster then you ) , so if in 1second you go 1metre he in 1second goes 2meter, so now you start running and there will be a time where he will catch you from behind (as track is circular) if this happens then our list is circular else our list is not circular(consider the track was straight and the faster person finished the track but didn't overtake you as it was a straight track)\n\nNOTE:- there is no need to use 'pos' , our logic works fine.\n\n1. Check a base condition if list is empty or not.\n\n2. Initialize two pointer slow and fast to head.\n\n3. traverse the list and during each iteration move 'slow' 1 step ahead and move 'fast' 2 step ahead. And within this loop check if our slow and fast pointer are pointing to same node or not , if they are pointing to same node somewhere in the list then we got our cycle and return true.\n\n4. But even after loop termination if these two pointers didn't point same position then it is sure that they never met and we can say our list does not has any cycle.\n\n\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if(head == NULL)\n            return false;\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while(fast!=NULL && fast->next !=NULL){\n            slow = slow->next;\n            fast = fast->next->next;\n            if(slow==fast)\n                return true;\n        }\n        return false;\n    }\n};\n"
                    },
                    {
                        "username": "Bhedanti",
                        "content": "My solution was to go throught entire LinkedList and keep saving the values in a list. If I come across any values in the linkedlist which is already present in the list I will return false. But for one of my test cases I can see 2 5s in the LL and pos = -1 the expected output is false. Why? Shouldn\\'t it be true?"
                    },
                    {
                        "username": "toanngo",
                        "content": "Instead of using a fast/slow pointer, you can just use one, and have a map that checks whether you\\'ve visited the node. In python, do something like `visited = {head:True}`"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Think about 2 pointers where one moves one node at a time while the other moves 2 at a time. What will happen then??"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "Ignore Pos . We can use fast and slow pointers or regular old reliable set."
                    },
                    {
                        "username": "Mouli_ch",
                        "content": "can anyone please explain the problem briefly"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "So, we need to find if there is a cycle in the linked list or not. In the explanation, they propose this pos argument in order to show that the \\'last\\' element of the linked list is pointing to. another element in the same list, creating then a infinite cycle in it. \\nSo our duty is to identify if a cycle exists in the leetcode tests."
                    },
                    {
                        "username": "jebbe",
                        "content": "As a beginner with JS, There is no way to log the head object to understand the linked list properties due to there being a cycle in the object. The third testcase is only one element.    \\nIncluding a longer true testcase would be more beginner friendly for me :)"
                    }
                ]
            },
            {
                "id": 2046422,
                "content": [
                    {
                        "username": "AayushSrivastav29",
                        "content": "Make two pointers-\\n1) fast; which travels two nodes at once\\n2) slow; which travels one node at a time. \\nat any future node they will meet bcz its a circle, then return true, otherwise false."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "runtime error although the cases are passed in the test runs,  any idea?  thanks\n\nattributeError: 'NoneType' object has no attribute 'next'\n    fast=head.next\nLine 29 in hasCycle (Solution.py)\n    ret = Solution().hasCycle(param_1)\nLine 61 in _driver (Solution.py)\n    _driver()\nLine 74 in <module> (Solution.py)"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) oh yeah, I missed a small test case lol. Updated the answer."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) I copied and pasted your code,  it got the same error.\\n"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) This is a rather simple but confusing error. \nThis code would fail for the testcases:\n```\n[1,2,3]\n-1\n[]\n-1\n```\n\nYou initialized the fast pointer to `head.next` (in this case 2), incremented fast twice (now pointing at `None`). Now `while` tries to call `fast.next` which is `None.next` and hence the error. Set both to `head` at first but then don't forget to reorder the if statement to increment pointers and then check and check if `fast` is not `None` in the `while` loop.\n `slow.next` can never be `None` (why? because `fast` would've already got there), instead you should be checking whether `fast` is `None`.\n\nAlso, check if `slow` is same as `fast` instead of checking if they are equal. Because some test cases have repeated values, but they are not the same node. Example test case:\n```\n[1,2,3,2,4]\n-1\n```\n\nFixed code:\n```python\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        slow=head\n        fast=head\n        while fast and fast.next:\n            # print('here')\n            slow=slow.next\n            fast=fast.next.next\n            if(slow==fast):\n                return True\n                \n        return False\n```\n\nHope this helps. \n"
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) # Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.next = None\\n\\n\\n\\n\\n# Time complexity is O(N) \\n# Space Complexity is O(1)\\n\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        slow=head\\n        fast=head.next\\n\\n        while(slow.next!=None and fast.next!=None):\\n            # print(\\'here\\')\\n            if(slow.val==fast.val):\\n                return True\\n            else:\\n                slow=slow.next\\n                fast=fast.next.next\\n        return False"
                    },
                    {
                        "username": "parapsychic",
                        "content": "you are calling next on a NoneType. If you could post the code, I can check. It\\'s usually because you reached the end of the list and still called next which returns a None, but then you call next again on that None."
                    },
                    {
                        "username": "parapsychic",
                        "content": "So, I was looking at some of the best memory efficient solution and I found that they just took the `pos` variable and returned true or false. Isn\\'t that cheating? I think those submissions should be removed.\\n[sample of cheating](https://imgur.com/yo6IPk2)"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Don\\'t worry. Practice for your own self-improvement. People who cheat are harming themselves. They won\\'t gain anything. Just keep improving, man!"
                    },
                    {
                        "username": "sergei99",
                        "content": "There is lots of cheating here. E.g. people open the output file (they somehow know its name) and write the hardcoded solution output from a static block executed prior to measurement stuff. So they get a really low execution time of their code, which is totally useless in solving real life problems."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "EASY   | |   USING SLOW & FAST POINTER\nconsider this example as you are in a circular racing track and there another person (he is faster then you ) , so if in 1second you go 1metre he in 1second goes 2meter, so now you start running and there will be a time where he will catch you from behind (as track is circular) if this happens then our list is circular else our list is not circular(consider the track was straight and the faster person finished the track but didn't overtake you as it was a straight track)\n\nNOTE:- there is no need to use 'pos' , our logic works fine.\n\n1. Check a base condition if list is empty or not.\n\n2. Initialize two pointer slow and fast to head.\n\n3. traverse the list and during each iteration move 'slow' 1 step ahead and move 'fast' 2 step ahead. And within this loop check if our slow and fast pointer are pointing to same node or not , if they are pointing to same node somewhere in the list then we got our cycle and return true.\n\n4. But even after loop termination if these two pointers didn't point same position then it is sure that they never met and we can say our list does not has any cycle.\n\n\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if(head == NULL)\n            return false;\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while(fast!=NULL && fast->next !=NULL){\n            slow = slow->next;\n            fast = fast->next->next;\n            if(slow==fast)\n                return true;\n        }\n        return false;\n    }\n};\n"
                    },
                    {
                        "username": "Bhedanti",
                        "content": "My solution was to go throught entire LinkedList and keep saving the values in a list. If I come across any values in the linkedlist which is already present in the list I will return false. But for one of my test cases I can see 2 5s in the LL and pos = -1 the expected output is false. Why? Shouldn\\'t it be true?"
                    },
                    {
                        "username": "toanngo",
                        "content": "Instead of using a fast/slow pointer, you can just use one, and have a map that checks whether you\\'ve visited the node. In python, do something like `visited = {head:True}`"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Think about 2 pointers where one moves one node at a time while the other moves 2 at a time. What will happen then??"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "Ignore Pos . We can use fast and slow pointers or regular old reliable set."
                    },
                    {
                        "username": "Mouli_ch",
                        "content": "can anyone please explain the problem briefly"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "So, we need to find if there is a cycle in the linked list or not. In the explanation, they propose this pos argument in order to show that the \\'last\\' element of the linked list is pointing to. another element in the same list, creating then a infinite cycle in it. \\nSo our duty is to identify if a cycle exists in the leetcode tests."
                    },
                    {
                        "username": "jebbe",
                        "content": "As a beginner with JS, There is no way to log the head object to understand the linked list properties due to there being a cycle in the object. The third testcase is only one element.    \\nIncluding a longer true testcase would be more beginner friendly for me :)"
                    }
                ]
            },
            {
                "id": 2045565,
                "content": [
                    {
                        "username": "AayushSrivastav29",
                        "content": "Make two pointers-\\n1) fast; which travels two nodes at once\\n2) slow; which travels one node at a time. \\nat any future node they will meet bcz its a circle, then return true, otherwise false."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "runtime error although the cases are passed in the test runs,  any idea?  thanks\n\nattributeError: 'NoneType' object has no attribute 'next'\n    fast=head.next\nLine 29 in hasCycle (Solution.py)\n    ret = Solution().hasCycle(param_1)\nLine 61 in _driver (Solution.py)\n    _driver()\nLine 74 in <module> (Solution.py)"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) oh yeah, I missed a small test case lol. Updated the answer."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) I copied and pasted your code,  it got the same error.\\n"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) This is a rather simple but confusing error. \nThis code would fail for the testcases:\n```\n[1,2,3]\n-1\n[]\n-1\n```\n\nYou initialized the fast pointer to `head.next` (in this case 2), incremented fast twice (now pointing at `None`). Now `while` tries to call `fast.next` which is `None.next` and hence the error. Set both to `head` at first but then don't forget to reorder the if statement to increment pointers and then check and check if `fast` is not `None` in the `while` loop.\n `slow.next` can never be `None` (why? because `fast` would've already got there), instead you should be checking whether `fast` is `None`.\n\nAlso, check if `slow` is same as `fast` instead of checking if they are equal. Because some test cases have repeated values, but they are not the same node. Example test case:\n```\n[1,2,3,2,4]\n-1\n```\n\nFixed code:\n```python\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        slow=head\n        fast=head\n        while fast and fast.next:\n            # print('here')\n            slow=slow.next\n            fast=fast.next.next\n            if(slow==fast):\n                return True\n                \n        return False\n```\n\nHope this helps. \n"
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) # Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.next = None\\n\\n\\n\\n\\n# Time complexity is O(N) \\n# Space Complexity is O(1)\\n\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        slow=head\\n        fast=head.next\\n\\n        while(slow.next!=None and fast.next!=None):\\n            # print(\\'here\\')\\n            if(slow.val==fast.val):\\n                return True\\n            else:\\n                slow=slow.next\\n                fast=fast.next.next\\n        return False"
                    },
                    {
                        "username": "parapsychic",
                        "content": "you are calling next on a NoneType. If you could post the code, I can check. It\\'s usually because you reached the end of the list and still called next which returns a None, but then you call next again on that None."
                    },
                    {
                        "username": "parapsychic",
                        "content": "So, I was looking at some of the best memory efficient solution and I found that they just took the `pos` variable and returned true or false. Isn\\'t that cheating? I think those submissions should be removed.\\n[sample of cheating](https://imgur.com/yo6IPk2)"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Don\\'t worry. Practice for your own self-improvement. People who cheat are harming themselves. They won\\'t gain anything. Just keep improving, man!"
                    },
                    {
                        "username": "sergei99",
                        "content": "There is lots of cheating here. E.g. people open the output file (they somehow know its name) and write the hardcoded solution output from a static block executed prior to measurement stuff. So they get a really low execution time of their code, which is totally useless in solving real life problems."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "EASY   | |   USING SLOW & FAST POINTER\nconsider this example as you are in a circular racing track and there another person (he is faster then you ) , so if in 1second you go 1metre he in 1second goes 2meter, so now you start running and there will be a time where he will catch you from behind (as track is circular) if this happens then our list is circular else our list is not circular(consider the track was straight and the faster person finished the track but didn't overtake you as it was a straight track)\n\nNOTE:- there is no need to use 'pos' , our logic works fine.\n\n1. Check a base condition if list is empty or not.\n\n2. Initialize two pointer slow and fast to head.\n\n3. traverse the list and during each iteration move 'slow' 1 step ahead and move 'fast' 2 step ahead. And within this loop check if our slow and fast pointer are pointing to same node or not , if they are pointing to same node somewhere in the list then we got our cycle and return true.\n\n4. But even after loop termination if these two pointers didn't point same position then it is sure that they never met and we can say our list does not has any cycle.\n\n\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if(head == NULL)\n            return false;\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while(fast!=NULL && fast->next !=NULL){\n            slow = slow->next;\n            fast = fast->next->next;\n            if(slow==fast)\n                return true;\n        }\n        return false;\n    }\n};\n"
                    },
                    {
                        "username": "Bhedanti",
                        "content": "My solution was to go throught entire LinkedList and keep saving the values in a list. If I come across any values in the linkedlist which is already present in the list I will return false. But for one of my test cases I can see 2 5s in the LL and pos = -1 the expected output is false. Why? Shouldn\\'t it be true?"
                    },
                    {
                        "username": "toanngo",
                        "content": "Instead of using a fast/slow pointer, you can just use one, and have a map that checks whether you\\'ve visited the node. In python, do something like `visited = {head:True}`"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Think about 2 pointers where one moves one node at a time while the other moves 2 at a time. What will happen then??"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "Ignore Pos . We can use fast and slow pointers or regular old reliable set."
                    },
                    {
                        "username": "Mouli_ch",
                        "content": "can anyone please explain the problem briefly"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "So, we need to find if there is a cycle in the linked list or not. In the explanation, they propose this pos argument in order to show that the \\'last\\' element of the linked list is pointing to. another element in the same list, creating then a infinite cycle in it. \\nSo our duty is to identify if a cycle exists in the leetcode tests."
                    },
                    {
                        "username": "jebbe",
                        "content": "As a beginner with JS, There is no way to log the head object to understand the linked list properties due to there being a cycle in the object. The third testcase is only one element.    \\nIncluding a longer true testcase would be more beginner friendly for me :)"
                    }
                ]
            },
            {
                "id": 2044423,
                "content": [
                    {
                        "username": "AayushSrivastav29",
                        "content": "Make two pointers-\\n1) fast; which travels two nodes at once\\n2) slow; which travels one node at a time. \\nat any future node they will meet bcz its a circle, then return true, otherwise false."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "runtime error although the cases are passed in the test runs,  any idea?  thanks\n\nattributeError: 'NoneType' object has no attribute 'next'\n    fast=head.next\nLine 29 in hasCycle (Solution.py)\n    ret = Solution().hasCycle(param_1)\nLine 61 in _driver (Solution.py)\n    _driver()\nLine 74 in <module> (Solution.py)"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) oh yeah, I missed a small test case lol. Updated the answer."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) I copied and pasted your code,  it got the same error.\\n"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) This is a rather simple but confusing error. \nThis code would fail for the testcases:\n```\n[1,2,3]\n-1\n[]\n-1\n```\n\nYou initialized the fast pointer to `head.next` (in this case 2), incremented fast twice (now pointing at `None`). Now `while` tries to call `fast.next` which is `None.next` and hence the error. Set both to `head` at first but then don't forget to reorder the if statement to increment pointers and then check and check if `fast` is not `None` in the `while` loop.\n `slow.next` can never be `None` (why? because `fast` would've already got there), instead you should be checking whether `fast` is `None`.\n\nAlso, check if `slow` is same as `fast` instead of checking if they are equal. Because some test cases have repeated values, but they are not the same node. Example test case:\n```\n[1,2,3,2,4]\n-1\n```\n\nFixed code:\n```python\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        slow=head\n        fast=head\n        while fast and fast.next:\n            # print('here')\n            slow=slow.next\n            fast=fast.next.next\n            if(slow==fast):\n                return True\n                \n        return False\n```\n\nHope this helps. \n"
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) # Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.next = None\\n\\n\\n\\n\\n# Time complexity is O(N) \\n# Space Complexity is O(1)\\n\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        slow=head\\n        fast=head.next\\n\\n        while(slow.next!=None and fast.next!=None):\\n            # print(\\'here\\')\\n            if(slow.val==fast.val):\\n                return True\\n            else:\\n                slow=slow.next\\n                fast=fast.next.next\\n        return False"
                    },
                    {
                        "username": "parapsychic",
                        "content": "you are calling next on a NoneType. If you could post the code, I can check. It\\'s usually because you reached the end of the list and still called next which returns a None, but then you call next again on that None."
                    },
                    {
                        "username": "parapsychic",
                        "content": "So, I was looking at some of the best memory efficient solution and I found that they just took the `pos` variable and returned true or false. Isn\\'t that cheating? I think those submissions should be removed.\\n[sample of cheating](https://imgur.com/yo6IPk2)"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Don\\'t worry. Practice for your own self-improvement. People who cheat are harming themselves. They won\\'t gain anything. Just keep improving, man!"
                    },
                    {
                        "username": "sergei99",
                        "content": "There is lots of cheating here. E.g. people open the output file (they somehow know its name) and write the hardcoded solution output from a static block executed prior to measurement stuff. So they get a really low execution time of their code, which is totally useless in solving real life problems."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "EASY   | |   USING SLOW & FAST POINTER\nconsider this example as you are in a circular racing track and there another person (he is faster then you ) , so if in 1second you go 1metre he in 1second goes 2meter, so now you start running and there will be a time where he will catch you from behind (as track is circular) if this happens then our list is circular else our list is not circular(consider the track was straight and the faster person finished the track but didn't overtake you as it was a straight track)\n\nNOTE:- there is no need to use 'pos' , our logic works fine.\n\n1. Check a base condition if list is empty or not.\n\n2. Initialize two pointer slow and fast to head.\n\n3. traverse the list and during each iteration move 'slow' 1 step ahead and move 'fast' 2 step ahead. And within this loop check if our slow and fast pointer are pointing to same node or not , if they are pointing to same node somewhere in the list then we got our cycle and return true.\n\n4. But even after loop termination if these two pointers didn't point same position then it is sure that they never met and we can say our list does not has any cycle.\n\n\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if(head == NULL)\n            return false;\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while(fast!=NULL && fast->next !=NULL){\n            slow = slow->next;\n            fast = fast->next->next;\n            if(slow==fast)\n                return true;\n        }\n        return false;\n    }\n};\n"
                    },
                    {
                        "username": "Bhedanti",
                        "content": "My solution was to go throught entire LinkedList and keep saving the values in a list. If I come across any values in the linkedlist which is already present in the list I will return false. But for one of my test cases I can see 2 5s in the LL and pos = -1 the expected output is false. Why? Shouldn\\'t it be true?"
                    },
                    {
                        "username": "toanngo",
                        "content": "Instead of using a fast/slow pointer, you can just use one, and have a map that checks whether you\\'ve visited the node. In python, do something like `visited = {head:True}`"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Think about 2 pointers where one moves one node at a time while the other moves 2 at a time. What will happen then??"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "Ignore Pos . We can use fast and slow pointers or regular old reliable set."
                    },
                    {
                        "username": "Mouli_ch",
                        "content": "can anyone please explain the problem briefly"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "So, we need to find if there is a cycle in the linked list or not. In the explanation, they propose this pos argument in order to show that the \\'last\\' element of the linked list is pointing to. another element in the same list, creating then a infinite cycle in it. \\nSo our duty is to identify if a cycle exists in the leetcode tests."
                    },
                    {
                        "username": "jebbe",
                        "content": "As a beginner with JS, There is no way to log the head object to understand the linked list properties due to there being a cycle in the object. The third testcase is only one element.    \\nIncluding a longer true testcase would be more beginner friendly for me :)"
                    }
                ]
            },
            {
                "id": 2044240,
                "content": [
                    {
                        "username": "AayushSrivastav29",
                        "content": "Make two pointers-\\n1) fast; which travels two nodes at once\\n2) slow; which travels one node at a time. \\nat any future node they will meet bcz its a circle, then return true, otherwise false."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "runtime error although the cases are passed in the test runs,  any idea?  thanks\n\nattributeError: 'NoneType' object has no attribute 'next'\n    fast=head.next\nLine 29 in hasCycle (Solution.py)\n    ret = Solution().hasCycle(param_1)\nLine 61 in _driver (Solution.py)\n    _driver()\nLine 74 in <module> (Solution.py)"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) oh yeah, I missed a small test case lol. Updated the answer."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) I copied and pasted your code,  it got the same error.\\n"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) This is a rather simple but confusing error. \nThis code would fail for the testcases:\n```\n[1,2,3]\n-1\n[]\n-1\n```\n\nYou initialized the fast pointer to `head.next` (in this case 2), incremented fast twice (now pointing at `None`). Now `while` tries to call `fast.next` which is `None.next` and hence the error. Set both to `head` at first but then don't forget to reorder the if statement to increment pointers and then check and check if `fast` is not `None` in the `while` loop.\n `slow.next` can never be `None` (why? because `fast` would've already got there), instead you should be checking whether `fast` is `None`.\n\nAlso, check if `slow` is same as `fast` instead of checking if they are equal. Because some test cases have repeated values, but they are not the same node. Example test case:\n```\n[1,2,3,2,4]\n-1\n```\n\nFixed code:\n```python\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        slow=head\n        fast=head\n        while fast and fast.next:\n            # print('here')\n            slow=slow.next\n            fast=fast.next.next\n            if(slow==fast):\n                return True\n                \n        return False\n```\n\nHope this helps. \n"
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) # Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.next = None\\n\\n\\n\\n\\n# Time complexity is O(N) \\n# Space Complexity is O(1)\\n\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        slow=head\\n        fast=head.next\\n\\n        while(slow.next!=None and fast.next!=None):\\n            # print(\\'here\\')\\n            if(slow.val==fast.val):\\n                return True\\n            else:\\n                slow=slow.next\\n                fast=fast.next.next\\n        return False"
                    },
                    {
                        "username": "parapsychic",
                        "content": "you are calling next on a NoneType. If you could post the code, I can check. It\\'s usually because you reached the end of the list and still called next which returns a None, but then you call next again on that None."
                    },
                    {
                        "username": "parapsychic",
                        "content": "So, I was looking at some of the best memory efficient solution and I found that they just took the `pos` variable and returned true or false. Isn\\'t that cheating? I think those submissions should be removed.\\n[sample of cheating](https://imgur.com/yo6IPk2)"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Don\\'t worry. Practice for your own self-improvement. People who cheat are harming themselves. They won\\'t gain anything. Just keep improving, man!"
                    },
                    {
                        "username": "sergei99",
                        "content": "There is lots of cheating here. E.g. people open the output file (they somehow know its name) and write the hardcoded solution output from a static block executed prior to measurement stuff. So they get a really low execution time of their code, which is totally useless in solving real life problems."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "EASY   | |   USING SLOW & FAST POINTER\nconsider this example as you are in a circular racing track and there another person (he is faster then you ) , so if in 1second you go 1metre he in 1second goes 2meter, so now you start running and there will be a time where he will catch you from behind (as track is circular) if this happens then our list is circular else our list is not circular(consider the track was straight and the faster person finished the track but didn't overtake you as it was a straight track)\n\nNOTE:- there is no need to use 'pos' , our logic works fine.\n\n1. Check a base condition if list is empty or not.\n\n2. Initialize two pointer slow and fast to head.\n\n3. traverse the list and during each iteration move 'slow' 1 step ahead and move 'fast' 2 step ahead. And within this loop check if our slow and fast pointer are pointing to same node or not , if they are pointing to same node somewhere in the list then we got our cycle and return true.\n\n4. But even after loop termination if these two pointers didn't point same position then it is sure that they never met and we can say our list does not has any cycle.\n\n\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if(head == NULL)\n            return false;\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while(fast!=NULL && fast->next !=NULL){\n            slow = slow->next;\n            fast = fast->next->next;\n            if(slow==fast)\n                return true;\n        }\n        return false;\n    }\n};\n"
                    },
                    {
                        "username": "Bhedanti",
                        "content": "My solution was to go throught entire LinkedList and keep saving the values in a list. If I come across any values in the linkedlist which is already present in the list I will return false. But for one of my test cases I can see 2 5s in the LL and pos = -1 the expected output is false. Why? Shouldn\\'t it be true?"
                    },
                    {
                        "username": "toanngo",
                        "content": "Instead of using a fast/slow pointer, you can just use one, and have a map that checks whether you\\'ve visited the node. In python, do something like `visited = {head:True}`"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Think about 2 pointers where one moves one node at a time while the other moves 2 at a time. What will happen then??"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "Ignore Pos . We can use fast and slow pointers or regular old reliable set."
                    },
                    {
                        "username": "Mouli_ch",
                        "content": "can anyone please explain the problem briefly"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "So, we need to find if there is a cycle in the linked list or not. In the explanation, they propose this pos argument in order to show that the \\'last\\' element of the linked list is pointing to. another element in the same list, creating then a infinite cycle in it. \\nSo our duty is to identify if a cycle exists in the leetcode tests."
                    },
                    {
                        "username": "jebbe",
                        "content": "As a beginner with JS, There is no way to log the head object to understand the linked list properties due to there being a cycle in the object. The third testcase is only one element.    \\nIncluding a longer true testcase would be more beginner friendly for me :)"
                    }
                ]
            },
            {
                "id": 2044047,
                "content": [
                    {
                        "username": "AayushSrivastav29",
                        "content": "Make two pointers-\\n1) fast; which travels two nodes at once\\n2) slow; which travels one node at a time. \\nat any future node they will meet bcz its a circle, then return true, otherwise false."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "runtime error although the cases are passed in the test runs,  any idea?  thanks\n\nattributeError: 'NoneType' object has no attribute 'next'\n    fast=head.next\nLine 29 in hasCycle (Solution.py)\n    ret = Solution().hasCycle(param_1)\nLine 61 in _driver (Solution.py)\n    _driver()\nLine 74 in <module> (Solution.py)"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) oh yeah, I missed a small test case lol. Updated the answer."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) I copied and pasted your code,  it got the same error.\\n"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) This is a rather simple but confusing error. \nThis code would fail for the testcases:\n```\n[1,2,3]\n-1\n[]\n-1\n```\n\nYou initialized the fast pointer to `head.next` (in this case 2), incremented fast twice (now pointing at `None`). Now `while` tries to call `fast.next` which is `None.next` and hence the error. Set both to `head` at first but then don't forget to reorder the if statement to increment pointers and then check and check if `fast` is not `None` in the `while` loop.\n `slow.next` can never be `None` (why? because `fast` would've already got there), instead you should be checking whether `fast` is `None`.\n\nAlso, check if `slow` is same as `fast` instead of checking if they are equal. Because some test cases have repeated values, but they are not the same node. Example test case:\n```\n[1,2,3,2,4]\n-1\n```\n\nFixed code:\n```python\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        slow=head\n        fast=head\n        while fast and fast.next:\n            # print('here')\n            slow=slow.next\n            fast=fast.next.next\n            if(slow==fast):\n                return True\n                \n        return False\n```\n\nHope this helps. \n"
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) # Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.next = None\\n\\n\\n\\n\\n# Time complexity is O(N) \\n# Space Complexity is O(1)\\n\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        slow=head\\n        fast=head.next\\n\\n        while(slow.next!=None and fast.next!=None):\\n            # print(\\'here\\')\\n            if(slow.val==fast.val):\\n                return True\\n            else:\\n                slow=slow.next\\n                fast=fast.next.next\\n        return False"
                    },
                    {
                        "username": "parapsychic",
                        "content": "you are calling next on a NoneType. If you could post the code, I can check. It\\'s usually because you reached the end of the list and still called next which returns a None, but then you call next again on that None."
                    },
                    {
                        "username": "parapsychic",
                        "content": "So, I was looking at some of the best memory efficient solution and I found that they just took the `pos` variable and returned true or false. Isn\\'t that cheating? I think those submissions should be removed.\\n[sample of cheating](https://imgur.com/yo6IPk2)"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Don\\'t worry. Practice for your own self-improvement. People who cheat are harming themselves. They won\\'t gain anything. Just keep improving, man!"
                    },
                    {
                        "username": "sergei99",
                        "content": "There is lots of cheating here. E.g. people open the output file (they somehow know its name) and write the hardcoded solution output from a static block executed prior to measurement stuff. So they get a really low execution time of their code, which is totally useless in solving real life problems."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "EASY   | |   USING SLOW & FAST POINTER\nconsider this example as you are in a circular racing track and there another person (he is faster then you ) , so if in 1second you go 1metre he in 1second goes 2meter, so now you start running and there will be a time where he will catch you from behind (as track is circular) if this happens then our list is circular else our list is not circular(consider the track was straight and the faster person finished the track but didn't overtake you as it was a straight track)\n\nNOTE:- there is no need to use 'pos' , our logic works fine.\n\n1. Check a base condition if list is empty or not.\n\n2. Initialize two pointer slow and fast to head.\n\n3. traverse the list and during each iteration move 'slow' 1 step ahead and move 'fast' 2 step ahead. And within this loop check if our slow and fast pointer are pointing to same node or not , if they are pointing to same node somewhere in the list then we got our cycle and return true.\n\n4. But even after loop termination if these two pointers didn't point same position then it is sure that they never met and we can say our list does not has any cycle.\n\n\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if(head == NULL)\n            return false;\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while(fast!=NULL && fast->next !=NULL){\n            slow = slow->next;\n            fast = fast->next->next;\n            if(slow==fast)\n                return true;\n        }\n        return false;\n    }\n};\n"
                    },
                    {
                        "username": "Bhedanti",
                        "content": "My solution was to go throught entire LinkedList and keep saving the values in a list. If I come across any values in the linkedlist which is already present in the list I will return false. But for one of my test cases I can see 2 5s in the LL and pos = -1 the expected output is false. Why? Shouldn\\'t it be true?"
                    },
                    {
                        "username": "toanngo",
                        "content": "Instead of using a fast/slow pointer, you can just use one, and have a map that checks whether you\\'ve visited the node. In python, do something like `visited = {head:True}`"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Think about 2 pointers where one moves one node at a time while the other moves 2 at a time. What will happen then??"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "Ignore Pos . We can use fast and slow pointers or regular old reliable set."
                    },
                    {
                        "username": "Mouli_ch",
                        "content": "can anyone please explain the problem briefly"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "So, we need to find if there is a cycle in the linked list or not. In the explanation, they propose this pos argument in order to show that the \\'last\\' element of the linked list is pointing to. another element in the same list, creating then a infinite cycle in it. \\nSo our duty is to identify if a cycle exists in the leetcode tests."
                    },
                    {
                        "username": "jebbe",
                        "content": "As a beginner with JS, There is no way to log the head object to understand the linked list properties due to there being a cycle in the object. The third testcase is only one element.    \\nIncluding a longer true testcase would be more beginner friendly for me :)"
                    }
                ]
            },
            {
                "id": 2044042,
                "content": [
                    {
                        "username": "AayushSrivastav29",
                        "content": "Make two pointers-\\n1) fast; which travels two nodes at once\\n2) slow; which travels one node at a time. \\nat any future node they will meet bcz its a circle, then return true, otherwise false."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "runtime error although the cases are passed in the test runs,  any idea?  thanks\n\nattributeError: 'NoneType' object has no attribute 'next'\n    fast=head.next\nLine 29 in hasCycle (Solution.py)\n    ret = Solution().hasCycle(param_1)\nLine 61 in _driver (Solution.py)\n    _driver()\nLine 74 in <module> (Solution.py)"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) oh yeah, I missed a small test case lol. Updated the answer."
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) I copied and pasted your code,  it got the same error.\\n"
                    },
                    {
                        "username": "parapsychic",
                        "content": "[@lg12lglg34lg](/lg12lglg34lg) This is a rather simple but confusing error. \nThis code would fail for the testcases:\n```\n[1,2,3]\n-1\n[]\n-1\n```\n\nYou initialized the fast pointer to `head.next` (in this case 2), incremented fast twice (now pointing at `None`). Now `while` tries to call `fast.next` which is `None.next` and hence the error. Set both to `head` at first but then don't forget to reorder the if statement to increment pointers and then check and check if `fast` is not `None` in the `while` loop.\n `slow.next` can never be `None` (why? because `fast` would've already got there), instead you should be checking whether `fast` is `None`.\n\nAlso, check if `slow` is same as `fast` instead of checking if they are equal. Because some test cases have repeated values, but they are not the same node. Example test case:\n```\n[1,2,3,2,4]\n-1\n```\n\nFixed code:\n```python\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        slow=head\n        fast=head\n        while fast and fast.next:\n            # print('here')\n            slow=slow.next\n            fast=fast.next.next\n            if(slow==fast):\n                return True\n                \n        return False\n```\n\nHope this helps. \n"
                    },
                    {
                        "username": "lg12lglg34lg",
                        "content": "[@parapsychic](/parapsychic) # Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.next = None\\n\\n\\n\\n\\n# Time complexity is O(N) \\n# Space Complexity is O(1)\\n\\nclass Solution:\\n    def hasCycle(self, head: ListNode) -> bool:\\n        slow=head\\n        fast=head.next\\n\\n        while(slow.next!=None and fast.next!=None):\\n            # print(\\'here\\')\\n            if(slow.val==fast.val):\\n                return True\\n            else:\\n                slow=slow.next\\n                fast=fast.next.next\\n        return False"
                    },
                    {
                        "username": "parapsychic",
                        "content": "you are calling next on a NoneType. If you could post the code, I can check. It\\'s usually because you reached the end of the list and still called next which returns a None, but then you call next again on that None."
                    },
                    {
                        "username": "parapsychic",
                        "content": "So, I was looking at some of the best memory efficient solution and I found that they just took the `pos` variable and returned true or false. Isn\\'t that cheating? I think those submissions should be removed.\\n[sample of cheating](https://imgur.com/yo6IPk2)"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Don\\'t worry. Practice for your own self-improvement. People who cheat are harming themselves. They won\\'t gain anything. Just keep improving, man!"
                    },
                    {
                        "username": "sergei99",
                        "content": "There is lots of cheating here. E.g. people open the output file (they somehow know its name) and write the hardcoded solution output from a static block executed prior to measurement stuff. So they get a really low execution time of their code, which is totally useless in solving real life problems."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "EASY   | |   USING SLOW & FAST POINTER\nconsider this example as you are in a circular racing track and there another person (he is faster then you ) , so if in 1second you go 1metre he in 1second goes 2meter, so now you start running and there will be a time where he will catch you from behind (as track is circular) if this happens then our list is circular else our list is not circular(consider the track was straight and the faster person finished the track but didn't overtake you as it was a straight track)\n\nNOTE:- there is no need to use 'pos' , our logic works fine.\n\n1. Check a base condition if list is empty or not.\n\n2. Initialize two pointer slow and fast to head.\n\n3. traverse the list and during each iteration move 'slow' 1 step ahead and move 'fast' 2 step ahead. And within this loop check if our slow and fast pointer are pointing to same node or not , if they are pointing to same node somewhere in the list then we got our cycle and return true.\n\n4. But even after loop termination if these two pointers didn't point same position then it is sure that they never met and we can say our list does not has any cycle.\n\n\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if(head == NULL)\n            return false;\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while(fast!=NULL && fast->next !=NULL){\n            slow = slow->next;\n            fast = fast->next->next;\n            if(slow==fast)\n                return true;\n        }\n        return false;\n    }\n};\n"
                    },
                    {
                        "username": "Bhedanti",
                        "content": "My solution was to go throught entire LinkedList and keep saving the values in a list. If I come across any values in the linkedlist which is already present in the list I will return false. But for one of my test cases I can see 2 5s in the LL and pos = -1 the expected output is false. Why? Shouldn\\'t it be true?"
                    },
                    {
                        "username": "toanngo",
                        "content": "Instead of using a fast/slow pointer, you can just use one, and have a map that checks whether you\\'ve visited the node. In python, do something like `visited = {head:True}`"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Think about 2 pointers where one moves one node at a time while the other moves 2 at a time. What will happen then??"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "Ignore Pos . We can use fast and slow pointers or regular old reliable set."
                    },
                    {
                        "username": "Mouli_ch",
                        "content": "can anyone please explain the problem briefly"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "So, we need to find if there is a cycle in the linked list or not. In the explanation, they propose this pos argument in order to show that the \\'last\\' element of the linked list is pointing to. another element in the same list, creating then a infinite cycle in it. \\nSo our duty is to identify if a cycle exists in the leetcode tests."
                    },
                    {
                        "username": "jebbe",
                        "content": "As a beginner with JS, There is no way to log the head object to understand the linked list properties due to there being a cycle in the object. The third testcase is only one element.    \\nIncluding a longer true testcase would be more beginner friendly for me :)"
                    }
                ]
            },
            {
                "id": 2043952,
                "content": [
                    {
                        "username": "julkar9",
                        "content": "I hate this kind of questions, its either you know the solution or don\\'t. There\\'s no in-between."
                    },
                    {
                        "username": "psionl0",
                        "content": "The fast and slow pointer technique is useful in a variety of linked list situations. It is worth while learning about it."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "I\\'m not going to read the whole question just for \"Find cycle\""
                    },
                    {
                        "username": "katalma",
                        "content": "Beginning of the week, beginning of the month. I can believe I am smart. But in the end..."
                    },
                    {
                        "username": "sakibmondal7",
                        "content": "Just check the solution with minimum space under Python language.. They did some strange things.. \n\nThey edited the user response in backend with pos variable. I guess that is why `POS` is given.\n\nThis is cheatings at next level.. "
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "## there is no use of pos here ##\\n`\\nhead = [3,2,0,-4], pos = 3\\n`\\nWill pass the test case since refreance of last node is to pos 1 node"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Okay, so we all know the constant memory solution - but is there a different approach (that uses more than constant space) that also takes linear time? Best I can think of is quadratic."
                    },
                    {
                        "username": "aitachii",
                        "content": "Hash table/dictionary of ListNodes take up O(n) space. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Is LeetCode softening us up?"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Check out this testcase\n```\n[-158, -157, -156, -155, -154, -153, -152, -151, -150, -149, -148, -147, -146, -145, -144, -143, -142, -141, -140, -139, -138, -137, -136, -135, -134, -133, -132, -131, -130, -129, -128, -127, -126, -125, -124, -123, -122, -121, -120, -119, -118, -117, -116, -115, -114, -113, -112, -111, -110, -109, -108, -107, -106, -105, -104, -103, -102, -101, -100, -99, -98, -97, -96, -95, -94, -93, -92, -91, -90, -89, -88, -87, -86, -85, -84, -83, -82, -81, -80, -79, -78, -77, -76, -75, -74, -73, -72, -71, -70, -69, -68, -67, -66, -65, -64, -63, -62, -61, -60, -59, -58, -57, -56, -55, -54, -53, -52, -51, -50, -49, -48, -47, -46, -45, -44, -43, -42, -41, -40, -39, -38, -37, -36, -35, -34, -33, -32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1633, 1634, 1635, 1636, 1637, 1638, 1639, 1640, 1641, 1642, 1643, 1644, 1645, 1646, 1647, 1648, 1649, 1650, 1651, 1652, 1653, 1654, 1655, 1656, 1657, 1658, 1659, 1660, 1661, 1662, 1663, 1664, 1665, 1666, 1667, 1668, 1669, 1670, 1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684, 1685, 1686, 1687, 1688, 1689, 1690, 1691, 1692, 1693, 1694, 1695, 1696, 1697, 1698, 1699, 1700, 1701, 1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709, 1710, 1711, 1712, 1713, 1714, 1715, 1716, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1724, 1725, 1726, 1727, 1728, 1729, 1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738, 1739, 1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749, 1750, 1751, 1752, 1753, 1754, 1755, 1756, 1757, 1758, 1759, 1760, 1761, 1762, 1763, 1764, 1765, 1766, 1767, 1768, 1769, 1770, 1771, 1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1780, 1781, 1782, 1783, 1784, 1785, 1786, 1787, 1788, 1789, 1790, 1791, 1792, 1793, 1794, 1795, 1796, 1797, 1798, 1799, 1800, 1801, 1802, 1803, 1804, 1805, 1806, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 1815, 1816, 1817, 1818, 1819, 1820, 1821, 1822, 1823, 1824, 1825, 1826, 1827, 1828, 1829, 1830, 1831, 1832, 1833, 1834, 1835, 1836, 1837, 1838, 1839, 1840, 1841, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849, 1850, 1851, 1852, 1853, 1854, 1855, 1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879, 1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 2039, 2040, 2041, 2042, 2043, 2044, 2045, 2046, 2047, 2048, 2049, 2050, 2051, 2052, 2053, 2054, 2055, 2056, 2057, 2058, 2059, 2060, 2061, 2062, 2063, 2064, 2065, 2066, 2067, 2068, 2069, 2070, 2071, 2072, 2073, 2074, 2075, 2076, 2077, 2078, 2079, 2080, 2081, 2082, 2083, 2084, 2085, 2086, 2087, 2088, 2089, 2090, 2091, 2092, 2093, 2094, 2095, 2096, 2097, 2098, 2099, 2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107, 2108, 2109, 2110, 2111, 2112, 2113, 2114, 2115, 2116, 2117, 2118, 2119, 2120, 2121, 2122, 2123, 2124, 2125, 2126, 2127, 2128, 2129, 2130, 2131, 2132, 2133, 2134, 2135, 2136, 2137, 2138, 2139, 2140, 2141, 2142, 2143, 2144, 2145, 2146, 2147, 2148, 2149, 2150, 2151, 2152, 2153, 2154, 2155, 2156, 2157, 2158, 2159, 2160, 2161, 2162, 2163, 2164, 2165, 2166, 2167, 2168, 2169, 2170, 2171, 2172, 2173, 2174, 2175, 2176, 2177, 2178, 2179, 2180, 2181, 2182, 2183, 2184, 2185, 2186, 2187, 2188, 2189, 2190, 2191, 2192, 2193, 2194, 2195, 2196, 2197, 2198, 2199, 2200, 2201, 2202, 2203, 2204, 2205, 2206, 2207, 2208, 2209, 2210, 2211, 2212, 2213, 2214, 2215, 2216, 2217, 2218, 2219, 2220, 2221, 2222, 2223, 2224, 2225, 2226, 2227, 2228, 2229, 2230, 2231, 2232, 2233, 2234, 2235, 2236, 2237, 2238, 2239, 2240, 2241, 2242, 2243, 2244, 2245, 2246, 2247, 2248, 2249, 2250, 2251, 2252, 2253, 2254, 2255, 2256, 2257, 2258, 2259, 2260, 2261, 2262, 2263, 2264, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2272, 2273, 2274, 2275, 2276, 2277, 2278, 2279, 2280, 2281, 2282, 2283, 2284, 2285, 2286, 2287, 2288, 2289, 2290, 2291, 2292, 2293, 2294, 2295, 2296, 2297, 2298, 2299, 2300, 2301, 2302, 2303, 2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2319, 2320, 2321, 2322, 2323, 2324, 2325, 2326, 2327, 2328, 2329, 2330, 2331, 2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341, 2342, 2343, 2344, 2345, 2346, 2347, 2348, 2349, 2350, 2351, 2352, 2353, 2354, 2355, 2356, 2357, 2358, 2359, 2360, 2361, 2362, 2363, 2364, 2365, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2384, 2385, 2386, 2387, 2388, 2389, 2390, 2391, 2392, 2393, 2394, 2395, 2396, 2397, 2398, 2399, 2400, 2401, 2402, 2403, 2404, 2405, 2406, 2407, 2408, 2409, 2410, 2411, 2412, 2413, 2414, 2415, 2416, 2417, 2418, 2419, 2420, 2421, 2422, 2423, 2424, 2425, 2426, 2427, 2428, 2429, 2430, 2431, 2432, 2433, 2434, 2435, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2443, 2444, 2445, 2446, 2447, 2448, 2449, 2450, 2451, 2452, 2453, 2454, 2455, 2456, 2457, 2458, 2459, 2460, 2461, 2462, 2463, 2464, 2465, 2466, 2467, 2468, 2469, 2470, 2471, 2472, 2473, 2474, 2475, 2476, 2477, 2478, 2479, 2480, 2481, 2482, 2483, 2484, 2485, 2486, 2487, 2488, 2489, 2490, 2491, 2492, 2493, 2494, 2495, 2496, 2497, 2498, 2499, 2500, 2501, 2502, 2503, 2504, 2505, 2506, 2507, 2508, 2509, 2510, 2511, 2512, 2513, 2514, 2515, 2516, 2517, 2518, 2519, 2520, 2521, 2522, 2523, 2524, 2525, 2526, 2527, 2528, 2529, 2530, 2531, 2532, 2533, 2534, 2535, 2536, 2537, 2538, 2539, 2540, 2541, 2542, 2543, 2544, 2545, 2546, 2547, 2548, 2549, 2550, 2551, 2552, 2553, 2554, 2555, 2556, 2557, 2558, 2559, 2560, 2561, 2562, 2563, 2564, 2565, 2566, 2567, 2568, 2569, 2570, 2571, 2572, 2573, 2574, 2575, 2576, 2577, 2578, 2579, 2580, 2581, 2582, 2583, 2584, 2585, 2586, 2587, 2588, 2589, 2590, 2591, 2592, 2593, 2594, 2595, 2596, 2597, 2598, 2599, 2600, 2601, 2602, 2603, 2604, 2605, 2606, 2607, 2608, 2609, 2610, 2611, 2612, 2613, 2614, 2615, 2616, 2617, 2618, 2619, 2620, 2621, 2622, 2623, 2624, 2625, 2626, 2627, 2628, 2629, 2630, 2631, 2632, 2633, 2634, 2635, 2636, 2637, 2638, 2639, 2640, 2641, 2642, 2643, 2644, 2645, 2646, 2647, 2648, 2649, 2650, 2651, 2652, 2653, 2654, 2655, 2656, 2657, 2658, 2659, 2660, 2661, 2662, 2663, 2664, 2665, 2666, 2667, 2668, 2669, 2670, 2671, 2672, 2673, 2674, 2675, 2676, 2677, 2678, 2679, 2680, 2681, 2682, 2683, 2684, 2685, 2686, 2687, 2688, 2689, 2690, 2691, 2692, 2693, 2694, 2695, 2696, 2697, 2698, 2699, 2700, 2701, 2702, 2703, 2704, 2705, 2706, 2707, 2708, 2709, 2710, 2711, 2712, 2713, 2714, 2715, 2716, 2717, 2718, 2719, 2720, 2721, 2722, 2723, 2724, 2725, 2726, 2727, 2728, 2729, 2730, 2731, 2732, 2733, 2734, 2735, 2736, 2737, 2738, 2739, 2740, 2741, 2742, 2743, 2744, 2745, 2746, 2747, 2748, 2749, 2750, 2751, 2752, 2753, 2754, 2755, 2756, 2757, 2758, 2759, 2760, 2761, 2762, 2763, 2764, 2765, 2766, 2767, 2768, 2769, 2770, 2771, 2772, 2773, 2774, 2775, 2776, 2777, 2778, 2779, 2780, 2781, 2782, 2783, 2784, 2785, 2786, 2787, 2788, 2789, 2790, 2791, 2792, 2793, 2794, 2795, 2796, 2797, 2798, 2799, 2800, 2801, 2802, 2803, 2804, 2805, 2806, 2807, 2808, 2809, 2810, 2811, 2812, 2813, 2814, 2815, 2816, 2817, 2818, 2819, 2820, 2821, 2822, 2823, 2824, 2825, 2826, 2827, 2828, 2829, 2830, 2831, 2832, 2833, 2834, 2835, 2836, 2837, 2838, 2839, 2840, 2841, 2842, 2843, 2844, 2845, 2846, 2847, 2848, 2849, 2850, 2851, 2852, 2853, 2854, 2855, 2856, 2857, 2858, 2859, 2860, 2861, 2862, 2863, 2864, 2865, 2866, 2867, 2868, 2869, 2870, 2871, 2872, 2873, 2874, 2875, 2876, 2877, 2878, 2879, 2880, 2881, 2882, 2883, 2884, 2885, 2886, 2887, 2888, 2889, 2890, 2891, 2892, 2893, 2894, 2895, 2896, 2897, 2898, 2899, 2900, 2901, 2902, 2903, 2904, 2905, 2906, 2907, 2908, 2909, 2910, 2911, 2912, 2913, 2914, 2915, 2916, 2917, 2918, 2919, 2920, 2921, 2922, 2923, 2924, 2925, 2926, 2927, 2928, 2929, 2930, 2931, 2932, 2933, 2934, 2935, 2936, 2937, 2938, 2939, 2940, 2941, 2942, 2943, 2944, 2945, 2946, 2947, 2948, 2949, 2950, 2951, 2952, 2953, 2954, 2955, 2956, 2957, 2958, 2959, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2969, 2970, 2971, 2972, 2973, 2974, 2975, 2976, 2977, 2978, 2979, 2980, 2981, 2982, 2983, 2984, 2985, 2986, 2987, 2988, 2989, 2990, 2991, 2992, 2993, 2994, 2995, 2996, 2997, 2998, 2999, 3000, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 3009, 3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019, 3020, 3021, 3022, 3023, 3024, 3025, 3026, 3027, 3028, 3029, 3030, 3031, 3032, 3033, 3034, 3035, 3036, 3037, 3038, 3039, 3040, 3041, 3042, 3043, 3044, 3045, 3046, 3047, 3048, 3049, 3050, 3051, 3052, 3053, 3054, 3055, 3056, 3057, 3058, 3059, 3060, 3061, 3062, 3063, 3064, 3065, 3066, 3067, 3068, 3069, 3070, 3071, 3072, 3073, 3074, 3075, 3076, 3077, 3078, 3079, 3080, 3081, 3082, 3083, 3084, 3085, 3086, 3087, 3088, 3089, 3090, 3091, 3092, 3093, 3094, 3095, 3096, 3097, 3098, 3099, 3100, 3101, 3102, 3103, 3104, 3105, 3106, 3107, 3108, 3109, 3110, 3111, 3112, 3113, 3114, 3115, 3116, 3117, 3118, 3119, 3120, 3121, 3122, 3123, 3124, 3125, 3126, 3127, 3128, 3129, 3130, 3131, 3132, 3133, 3134, 3135, 3136, 3137, 3138, 3139, 3140, 3141, 3142, 3143, 3144, 3145, 3146, 3147, 3148, 3149, 3150, 3151, 3152, 3153, 3154, 3155, 3156, 3157, 3158, 3159, 3160, 3161, 3162, 3163, 3164, 3165, 3166, 3167, 3168, 3169, 3170, 3171, 3172, 3173, 3174, 3175, 3176, 3177, 3178, 3179, 3180, 3181, 3182, 3183, 3184, 3185, 3186, 3187, 3188, 3189, 3190, 3191, 3192, 3193, 3194, 3195, 3196, 3197, 3198, 3199, 3200, 3201, 3202, 3203, 3204, 3205, 3206, 3207, 3208, 3209, 3210, 3211, 3212, 3213, 3214, 3215, 3216, 3217, 3218, 3219, 3220, 3221, 3222, 3223, 3224, 3225, 3226, 3227, 3228, 3229, 3230, 3231, 3232, 3233, 3234, 3235, 3236, 3237, 3238, 3239, 3240, 3241, 3242, 3243, 3244, 3245, 3246, 3247, 3248, 3249, 3250, 3251, 3252, 3253, 3254, 3255, 3256, 3257, 3258, 3259, 3260, 3261, 3262, 3263, 3264, 3265, 3266, 3267, 3268, 3269, 3270, 3271, 3272, 3273, 3274, 3275, 3276, 3277, 3278, 3279, 3280, 3281, 3282, 3283, 3284, 3285, 3286, 3287, 3288, 3289, 3290, 3291, 3292, 3293, 3294, 3295, 3296, 3297, 3298, 3299, 3300, 3301, 3302, 3303, 3304, 3305, 3306, 3307, 3308, 3309, 3310, 3311, 3312, 3313, 3314, 3315, 3316, 3317, 3318, 3319, 3320, 3321, 3322, 3323, 3324, 3325, 3326, 3327, 3328, 3329, 3330, 3331, 3332, 3333, 3334, 3335, 3336, 3337, 3338, 3339, 3340, 3341, 3342, 3343, 3344, 3345, 3346, 3347, 3348, 3349, 3350, 3351, 3352, 3353, 3354, 3355, 3356, 3357, 3358, 3359, 3360, 3361, 3362, 3363, 3364, 3365, 3366, 3367, 3368, 3369, 3370, 3371, 3372, 3373, 3374, 3375, 3376, 3377, 3378, 3379, 3380, 3381, 3382, 3383, 3384, 3385, 3386, 3387, 3388, 3389, 3390, 3391, 3392, 3393, 3394, 3395, 3396, 3397, 3398, 3399, 3400, 3401, 3402, 3403, 3404, 3405, 3406, 3407, 3408, 3409, 3410, 3411, 3412, 3413, 3414, 3415, 3416, 3417, 3418, 3419, 3420, 3421, 3422, 3423, 3424, 3425, 3426, 3427, 3428, 3429, 3430, 3431, 3432, 3433, 3434, 3435, 3436, 3437, 3438, 3439, 3440, 3441, 3442, 3443, 3444, 3445, 3446, 3447, 3448, 3449, 3450, 3451, 3452, 3453, 3454, 3455, 3456, 3457, 3458, 3459, 3460, 3461, 3462, 3463, 3464, 3465, 3466, 3467, 3468, 3469, 3470, 3471, 3472, 3473, 3474, 3475, 3476, 3477, 3478, 3479, 3480, 3481, 3482, 3483, 3484, 3485, 3486, 3487, 3488, 3489, 3490, 3491, 3492, 3493, 3494, 3495, 3496, 3497, 3498, 3499, 3500, 3501, 3502, 3503, 3504, 3505, 3506, 3507, 3508, 3509, 3510, 3511, 3512, 3513, 3514, 3515, 3516, 3517, 3518, 3519, 3520, 3521, 3522, 3523, 3524, 3525, 3526, 3527, 3528, 3529, 3530, 3531, 3532, 3533, 3534, 3535, 3536, 3537, 3538, 3539, 3540, 3541, 3542, 3543, 3544, 3545, 3546, 3547, 3548, 3549, 3550, 3551, 3552, 3553, 3554, 3555, 3556, 3557, 3558, 3559, 3560, 3561, 3562, 3563, 3564, 3565, 3566, 3567, 3568, 3569, 3570, 3571, 3572, 3573, 3574, 3575, 3576, 3577, 3578, 3579, 3580, 3581, 3582, 3583, 3584, 3585, 3586, 3587, 3588, 3589, 3590, 3591, 3592, 3593, 3594, 3595, 3596, 3597, 3598, 3599, 3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609, 3610, 3611, 3612, 3613, 3614, 3615, 3616, 3617, 3618, 3619, 3620, 3621, 3622, 3623, 3624, 3625, 3626, 3627, 3628, 3629, 3630, 3631, 3632, 3633, 3634, 3635, 3636, 3637, 3638, 3639, 3640, 3641, 3642, 3643, 3644, 3645, 3646, 3647, 3648, 3649, 3650, 3651, 3652, 3653, 3654, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3662, 3663, 3664, 3665, 3666, 3667, 3668, 3669, 3670, 3671, 3672, 3673, 3674, 3675, 3676, 3677, 3678, 3679, 3680, 3681, 3682, 3683, 3684, 3685, 3686, 3687, 3688, 3689, 3690, 3691, 3692, 3693, 3694, 3695, 3696, 3697, 3698, 3699, 3700, 3701, 3702, 3703, 3704, 3705, 3706, 3707, 3708, 3709, 3710, 3711, 3712, 3713, 3714, 3715, 3716, 3717, 3718, 3719, 3720, 3721, 3722, 3723, 3724, 3725, 3726, 3727, 3728, 3729, 3730, 3731, 3732, 3733, 3734, 3735, 3736, 3737, 3738, 3739, 3740, 3741, 3742, 3743, 3744, 3745, 3746, 3747, 3748, 3749, 3750, 3751, 3752, 3753, 3754, 3755, 3756, 3757, 3758, 3759, 3760, 3761, 3762, 3763, 3764, 3765, 3766, 3767, 3768, 3769, 3770, 3771, 3772, 3773, 3774, 3775, 3776, 3777, 3778, 3779, 3780, 3781, 3782, 3783, 3784, 3785, 3786, 3787, 3788, 3789, 3790, 3791, 3792, 3793, 3794, 3795, 3796, 3797, 3798, 3799, 3800, 3801, 3802, 3803, 3804, 3805, 3806, 3807, 3808, 3809, 3810, 3811, 3812, 3813, 3814, 3815, 3816, 3817, 3818, 3819, 3820, 3821, 3822, 3823, 3824, 3825, 3826, 3827, 3828, 3829, 3830, 3831, 3832, 3833, 3834, 3835, 3836, 3837, 3838, 3839, 3840, 3841, 3842, 3843, 3844, 3845, 3846, 3847, 3848, 3849, 3850, 3851, 3852, 3853, 3854, 3855, 3856, 3857, 3858, 3859, 3860, 3861, 3862, 3863, 3864, 3865, 3866, 3867, 3868, 3869, 3870, 3871, 3872, 3873, 3874, 3875, 3876, 3877, 3878, 3879, 3880, 3881, 3882, 3883, 3884, 3885, 3886, 3887, 3888, 3889, 3890, 3891, 3892, 3893, 3894, 3895, 3896, 3897, 3898, 3899, 3900, 3901, 3902, 3903, 3904, 3905, 3906, 3907, 3908, 3909, 3910, 3911, 3912, 3913, 3914, 3915, 3916, 3917, 3918, 3919, 3920, 3921, 3922, 3923, 3924, 3925, 3926, 3927, 3928, 3929, 3930, 3931, 3932, 3933, 3934, 3935, 3936, 3937, 3938, 3939, 3940, 3941, 3942, 3943, 3944, 3945, 3946, 3947, 3948, 3949, 3950, 3951, 3952, 3953, 3954, 3955, 3956, 3957, 3958, 3959, 3960, 3961, 3962, 3963, 3964, 3965, 3966, 3967, 3968, 3969, 3970, 3971, 3972, 3973, 3974, 3975, 3976, 3977, 3978, 3979, 3980, 3981, 3982, 3983, 3984, 3985, 3986, 3987, 3988, 3989, 3990, 3991, 3992, 3993, 3994, 3995, 3996, 3997, 3998, 3999, 4000, 4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008, 4009, 4010, 4011, 4012, 4013, 4014, 4015, 4016, 4017, 4018, 4019, 4020, 4021, 4022, 4023, 4024, 4025, 4026, 4027, 4028, 4029, 4030, 4031, 4032, 4033, 4034, 4035, 4036, 4037, 4038, 4039, 4040, 4041, 4042, 4043, 4044, 4045, 4046, 4047, 4048, 4049, 4050, 4051, 4052, 4053, 4054, 4055, 4056, 4057, 4058, 4059, 4060, 4061, 4062, 4063, 4064, 4065, 4066, 4067, 4068, 4069, 4070, 4071, 4072, 4073, 4074, 4075, 4076, 4077, 4078, 4079, 4080, 4081, 4082, 4083, 4084, 4085, 4086, 4087, 4088, 4089, 4090, 4091, 4092, 4093, 4094, 4095, 4096, 4097, 4098, 4099, 4100, 4101, 4102, 4103, 4104, 4105, 4106, 4107, 4108, 4109, 4110, 4111, 4112, 4113, 4114, 4115, 4116, 4117, 4118, 4119, 4120, 4121, 4122, 4123, 4124, 4125, 4126, 4127, 4128, 4129, 4130, 4131, 4132, 4133, 4134, 4135, 4136, 4137, 4138, 4139, 4140, 4141, 4142, 4143, 4144, 4145, 4146, 4147, 4148, 4149, 4150, 4151, 4152, 4153, 4154, 4155, 4156, 4157, 4158, 4159, 4160, 4161, 4162, 4163, 4164, 4165, 4166, 4167, 4168, 4169, 4170, 4171, 4172, 4173, 4174, 4175, 4176, 4177, 4178, 4179, 4180, 4181, 4182, 4183, 4184, 4185, 4186, 4187, 4188, 4189, 4190, 4191, 4192, 4193, 4194, 4195, 4196, 4197, 4198, 4199, 4200, 4201, 4202, 4203, 4204, 4205, 4206, 4207, 4208, 4209, 4210, 4211, 4212, 4213, 4214, 4215, 4216, 4217, 4218, 4219, 4220, 4221, 4222, 4223, 4224, 4225, 4226, 4227, 4228, 4229, 4230, 4231, 4232, 4233, 4234, 4235, 4236, 4237, 4238, 4239, 4240, 4241, 4242, 4243, 4244, 4245, 4246, 4247, 4248, 4249, 4250, 4251, 4252, 4253, 4254, 4255, 4256, 4257, 4258, 4259, 4260, 4261, 4262, 4263, 4264, 4265, 4266, 4267, 4268, 4269, 4270, 4271, 4272, 4273, 4274, 4275, 4276, 4277, 4278, 4279, 4280, 4281, 4282, 4283, 4284, 4285, 4286, 4287, 4288, 4289, 4290, 4291, 4292, 4293, 4294, 4295, 4296, 4297, 4298, 4299, 4300, 4301, 4302, 4303, 4304, 4305, 4306, 4307, 4308, 4309, 4310, 4311, 4312, 4313, 4314, 4315, 4316, 4317, 4318, 4319, 4320, 4321, 4322, 4323, 4324, 4325, 4326, 4327, 4328, 4329, 4330, 4331, 4332, 4333, 4334, 4335, 4336, 4337, 4338, 4339, 4340, 4341, 4342, 4343, 4344, 4345, 4346, 4347, 4348, 4349, 4350, 4351, 4352, 4353, 4354, 4355, 4356, 4357, 4358, 4359, 4360, 4361, 4362, 4363, 4364, 4365, 4366, 4367, 4368, 4369, 4370, 4371, 4372, 4373, 4374, 4375, 4376, 4377, 4378, 4379, 4380, 4381, 4382, 4383, 4384, 4385, 4386, 4387, 4388, 4389, 4390, 4391, 4392, 4393, 4394, 4395, 4396, 4397, 4398, 4399, 4400, 4401, 4402, 4403, 4404, 4405, 4406, 4407, 4408, 4409, 4410, 4411, 4412, 4413, 4414, 4415, 4416, 4417, 4418, 4419, 4420, 4421, 4422, 4423, 4424, 4425, 4426, 4427, 4428, 4429, 4430, 4431, 4432, 4433, 4434, 4435, 4436, 4437, 4438, 4439, 4440, 4441, 4442, 4443, 4444, 4445, 4446, 4447, 4448, 4449, 4450, 4451, 4452, 4453, 4454, 4455, 4456, 4457, 4458, 4459, 4460, 4461, 4462, 4463, 4464, 4465, 4466, 4467, 4468, 4469, 4470, 4471, 4472, 4473, 4474, 4475, 4476, 4477, 4478, 4479, 4480, 4481, 4482, 4483, 4484, 4485, 4486, 4487, 4488, 4489, 4490, 4491, 4492, 4493, 4494, 4495, 4496, 4497, 4498, 4499, -500, -499, -498, -497, -496, -495, -494, -493, -492, -491, -490, -489, -488, -487, -486, -485, -484, -483, -482, -481, -480, -479, -478, -477, -476, -475, -474, -473, -472, -471, -470, -469, -468, -467, -466, -465, -464, -463, -462, -461, -460, -459, -458, -457, -456, -455, -454, -453, -452, -451, -450, -449, -448, -447, -446, -445, -444, -443, -442, -441, -440, -439, -438, -437, -436, -435, -434, -433, -432, -431, -430, -429, -428, -427, -426, -425, -424, -423, -422, -421, -420, -419, -418, -417, -416, -415, -414, -413, -412, -411, -410, -409, -408, -407, -406, -405, -404, -403, -402, -401, -400, -399, -398, -397, -396, -395, -394, -393, -392, -391, -390, -389, -388, -387, -386, -385, -384, -383, -382, -381, -380, -379, -378, -377, -376, -375, -374, -373, -372, -371, -370, -369, -368, -367, -366, -365, -364, -363, -362, -361, -360, -359, -358, -357, -356, -355, -354, -353, -352, -351, -350, -349, -348, -347, -346, -345, -344, -343, -342, -341, -340, -339, -338, -337, -336, -335, -334, -333, -332, -331, -330, -329, -328, -327, -326, -325, -324, -323, -322, -321, -320, -319, -318, -317, -316, -315, -314, -313, -312, -311, -310, -309, -308, -307, -306, -305, -304, -303, -302, -301, -300, -299, -298, -297, -296, -295, -294, -293, -292, -291, -290, -289, -288, -287, -286, -285, -284, -283, -282, -281, -280, -279, -278, -277, -276, -275, -274, -273, -272, -271, -270, -269, -268, -267, -266, -265, -264, -263, -262, -261, -260, -259, -258, -257, -256, -255, -254, -253, -252, -251, -250, -249, -248, -247, -246, -245, -244, -243, -242, -241, -240, -239, -238, -237, -236, -235, -234, -233, -232, -231, -230, -229, -228, -227, -226, -225, -224, -223, -222, -221, -220, -219, -218, -217, -216, -215, -214, -213, -212, -211, -210, -209, -208, -207, -206, -205, -204, -203, -202, -201, -200, -199, -198, -197, -196, -195, -194, -193, -192, -191, -190, -189, -188, -187, -186, -185, -184, -183, -182, -181, -180, -179, -178, -177, -176, -175, -174, -173, -172, -171, -170, -169, -168, -167, -166, -165, -164, -163, -162, -161, -160, -159]\n0\n```\nand also this one\n```\n[1,2,1,2,1,2,1,2,1,2]\n-1\n```"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, we need to find out cycle means cycle detection.\\nLet\\'s say Two people are running on a circle then definately they meet at any point. If they meet means cycle present. \\n\\n# Approach\\nSo, Here I will use Fast and Slow pointer (Two pointer approach).\\n1- Initialize two pointer slow and fast.\\n2- Initially both are pointing to head.\\n3- When loop run slow pointer move step ahead while fast pointer move it\\'s double.\\n4- If both pointer meet at a particular point it means cycle present other no."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Forget the garbage task.\\n\\nRead the real one:\\nRetuen `True` for neighboring Nodes with equal values, otherwise `False`"
                    },
                    {
                        "username": "arshita129",
                        "content": "neighboring nodes with equal values?? We are not trying to see if neighboring nodes have equal values.\\n"
                    }
                ]
            },
            {
                "id": 2043939,
                "content": [
                    {
                        "username": "julkar9",
                        "content": "I hate this kind of questions, its either you know the solution or don\\'t. There\\'s no in-between."
                    },
                    {
                        "username": "psionl0",
                        "content": "The fast and slow pointer technique is useful in a variety of linked list situations. It is worth while learning about it."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "I\\'m not going to read the whole question just for \"Find cycle\""
                    },
                    {
                        "username": "katalma",
                        "content": "Beginning of the week, beginning of the month. I can believe I am smart. But in the end..."
                    },
                    {
                        "username": "sakibmondal7",
                        "content": "Just check the solution with minimum space under Python language.. They did some strange things.. \n\nThey edited the user response in backend with pos variable. I guess that is why `POS` is given.\n\nThis is cheatings at next level.. "
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "## there is no use of pos here ##\\n`\\nhead = [3,2,0,-4], pos = 3\\n`\\nWill pass the test case since refreance of last node is to pos 1 node"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Okay, so we all know the constant memory solution - but is there a different approach (that uses more than constant space) that also takes linear time? Best I can think of is quadratic."
                    },
                    {
                        "username": "aitachii",
                        "content": "Hash table/dictionary of ListNodes take up O(n) space. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Is LeetCode softening us up?"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Check out this testcase\n```\n[-158, -157, -156, -155, -154, -153, -152, -151, -150, -149, -148, -147, -146, -145, -144, -143, -142, -141, -140, -139, -138, -137, -136, -135, -134, -133, -132, -131, -130, -129, -128, -127, -126, -125, -124, -123, -122, -121, -120, -119, -118, -117, -116, -115, -114, -113, -112, -111, -110, -109, -108, -107, -106, -105, -104, -103, -102, -101, -100, -99, -98, -97, -96, -95, -94, -93, -92, -91, -90, -89, -88, -87, -86, -85, -84, -83, -82, -81, -80, -79, -78, -77, -76, -75, -74, -73, -72, -71, -70, -69, -68, -67, -66, -65, -64, -63, -62, -61, -60, -59, -58, -57, -56, -55, -54, -53, -52, -51, -50, -49, -48, -47, -46, -45, -44, -43, -42, -41, -40, -39, -38, -37, -36, -35, -34, -33, -32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1633, 1634, 1635, 1636, 1637, 1638, 1639, 1640, 1641, 1642, 1643, 1644, 1645, 1646, 1647, 1648, 1649, 1650, 1651, 1652, 1653, 1654, 1655, 1656, 1657, 1658, 1659, 1660, 1661, 1662, 1663, 1664, 1665, 1666, 1667, 1668, 1669, 1670, 1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684, 1685, 1686, 1687, 1688, 1689, 1690, 1691, 1692, 1693, 1694, 1695, 1696, 1697, 1698, 1699, 1700, 1701, 1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709, 1710, 1711, 1712, 1713, 1714, 1715, 1716, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1724, 1725, 1726, 1727, 1728, 1729, 1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738, 1739, 1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749, 1750, 1751, 1752, 1753, 1754, 1755, 1756, 1757, 1758, 1759, 1760, 1761, 1762, 1763, 1764, 1765, 1766, 1767, 1768, 1769, 1770, 1771, 1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1780, 1781, 1782, 1783, 1784, 1785, 1786, 1787, 1788, 1789, 1790, 1791, 1792, 1793, 1794, 1795, 1796, 1797, 1798, 1799, 1800, 1801, 1802, 1803, 1804, 1805, 1806, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 1815, 1816, 1817, 1818, 1819, 1820, 1821, 1822, 1823, 1824, 1825, 1826, 1827, 1828, 1829, 1830, 1831, 1832, 1833, 1834, 1835, 1836, 1837, 1838, 1839, 1840, 1841, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849, 1850, 1851, 1852, 1853, 1854, 1855, 1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879, 1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 2039, 2040, 2041, 2042, 2043, 2044, 2045, 2046, 2047, 2048, 2049, 2050, 2051, 2052, 2053, 2054, 2055, 2056, 2057, 2058, 2059, 2060, 2061, 2062, 2063, 2064, 2065, 2066, 2067, 2068, 2069, 2070, 2071, 2072, 2073, 2074, 2075, 2076, 2077, 2078, 2079, 2080, 2081, 2082, 2083, 2084, 2085, 2086, 2087, 2088, 2089, 2090, 2091, 2092, 2093, 2094, 2095, 2096, 2097, 2098, 2099, 2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107, 2108, 2109, 2110, 2111, 2112, 2113, 2114, 2115, 2116, 2117, 2118, 2119, 2120, 2121, 2122, 2123, 2124, 2125, 2126, 2127, 2128, 2129, 2130, 2131, 2132, 2133, 2134, 2135, 2136, 2137, 2138, 2139, 2140, 2141, 2142, 2143, 2144, 2145, 2146, 2147, 2148, 2149, 2150, 2151, 2152, 2153, 2154, 2155, 2156, 2157, 2158, 2159, 2160, 2161, 2162, 2163, 2164, 2165, 2166, 2167, 2168, 2169, 2170, 2171, 2172, 2173, 2174, 2175, 2176, 2177, 2178, 2179, 2180, 2181, 2182, 2183, 2184, 2185, 2186, 2187, 2188, 2189, 2190, 2191, 2192, 2193, 2194, 2195, 2196, 2197, 2198, 2199, 2200, 2201, 2202, 2203, 2204, 2205, 2206, 2207, 2208, 2209, 2210, 2211, 2212, 2213, 2214, 2215, 2216, 2217, 2218, 2219, 2220, 2221, 2222, 2223, 2224, 2225, 2226, 2227, 2228, 2229, 2230, 2231, 2232, 2233, 2234, 2235, 2236, 2237, 2238, 2239, 2240, 2241, 2242, 2243, 2244, 2245, 2246, 2247, 2248, 2249, 2250, 2251, 2252, 2253, 2254, 2255, 2256, 2257, 2258, 2259, 2260, 2261, 2262, 2263, 2264, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2272, 2273, 2274, 2275, 2276, 2277, 2278, 2279, 2280, 2281, 2282, 2283, 2284, 2285, 2286, 2287, 2288, 2289, 2290, 2291, 2292, 2293, 2294, 2295, 2296, 2297, 2298, 2299, 2300, 2301, 2302, 2303, 2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2319, 2320, 2321, 2322, 2323, 2324, 2325, 2326, 2327, 2328, 2329, 2330, 2331, 2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341, 2342, 2343, 2344, 2345, 2346, 2347, 2348, 2349, 2350, 2351, 2352, 2353, 2354, 2355, 2356, 2357, 2358, 2359, 2360, 2361, 2362, 2363, 2364, 2365, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2384, 2385, 2386, 2387, 2388, 2389, 2390, 2391, 2392, 2393, 2394, 2395, 2396, 2397, 2398, 2399, 2400, 2401, 2402, 2403, 2404, 2405, 2406, 2407, 2408, 2409, 2410, 2411, 2412, 2413, 2414, 2415, 2416, 2417, 2418, 2419, 2420, 2421, 2422, 2423, 2424, 2425, 2426, 2427, 2428, 2429, 2430, 2431, 2432, 2433, 2434, 2435, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2443, 2444, 2445, 2446, 2447, 2448, 2449, 2450, 2451, 2452, 2453, 2454, 2455, 2456, 2457, 2458, 2459, 2460, 2461, 2462, 2463, 2464, 2465, 2466, 2467, 2468, 2469, 2470, 2471, 2472, 2473, 2474, 2475, 2476, 2477, 2478, 2479, 2480, 2481, 2482, 2483, 2484, 2485, 2486, 2487, 2488, 2489, 2490, 2491, 2492, 2493, 2494, 2495, 2496, 2497, 2498, 2499, 2500, 2501, 2502, 2503, 2504, 2505, 2506, 2507, 2508, 2509, 2510, 2511, 2512, 2513, 2514, 2515, 2516, 2517, 2518, 2519, 2520, 2521, 2522, 2523, 2524, 2525, 2526, 2527, 2528, 2529, 2530, 2531, 2532, 2533, 2534, 2535, 2536, 2537, 2538, 2539, 2540, 2541, 2542, 2543, 2544, 2545, 2546, 2547, 2548, 2549, 2550, 2551, 2552, 2553, 2554, 2555, 2556, 2557, 2558, 2559, 2560, 2561, 2562, 2563, 2564, 2565, 2566, 2567, 2568, 2569, 2570, 2571, 2572, 2573, 2574, 2575, 2576, 2577, 2578, 2579, 2580, 2581, 2582, 2583, 2584, 2585, 2586, 2587, 2588, 2589, 2590, 2591, 2592, 2593, 2594, 2595, 2596, 2597, 2598, 2599, 2600, 2601, 2602, 2603, 2604, 2605, 2606, 2607, 2608, 2609, 2610, 2611, 2612, 2613, 2614, 2615, 2616, 2617, 2618, 2619, 2620, 2621, 2622, 2623, 2624, 2625, 2626, 2627, 2628, 2629, 2630, 2631, 2632, 2633, 2634, 2635, 2636, 2637, 2638, 2639, 2640, 2641, 2642, 2643, 2644, 2645, 2646, 2647, 2648, 2649, 2650, 2651, 2652, 2653, 2654, 2655, 2656, 2657, 2658, 2659, 2660, 2661, 2662, 2663, 2664, 2665, 2666, 2667, 2668, 2669, 2670, 2671, 2672, 2673, 2674, 2675, 2676, 2677, 2678, 2679, 2680, 2681, 2682, 2683, 2684, 2685, 2686, 2687, 2688, 2689, 2690, 2691, 2692, 2693, 2694, 2695, 2696, 2697, 2698, 2699, 2700, 2701, 2702, 2703, 2704, 2705, 2706, 2707, 2708, 2709, 2710, 2711, 2712, 2713, 2714, 2715, 2716, 2717, 2718, 2719, 2720, 2721, 2722, 2723, 2724, 2725, 2726, 2727, 2728, 2729, 2730, 2731, 2732, 2733, 2734, 2735, 2736, 2737, 2738, 2739, 2740, 2741, 2742, 2743, 2744, 2745, 2746, 2747, 2748, 2749, 2750, 2751, 2752, 2753, 2754, 2755, 2756, 2757, 2758, 2759, 2760, 2761, 2762, 2763, 2764, 2765, 2766, 2767, 2768, 2769, 2770, 2771, 2772, 2773, 2774, 2775, 2776, 2777, 2778, 2779, 2780, 2781, 2782, 2783, 2784, 2785, 2786, 2787, 2788, 2789, 2790, 2791, 2792, 2793, 2794, 2795, 2796, 2797, 2798, 2799, 2800, 2801, 2802, 2803, 2804, 2805, 2806, 2807, 2808, 2809, 2810, 2811, 2812, 2813, 2814, 2815, 2816, 2817, 2818, 2819, 2820, 2821, 2822, 2823, 2824, 2825, 2826, 2827, 2828, 2829, 2830, 2831, 2832, 2833, 2834, 2835, 2836, 2837, 2838, 2839, 2840, 2841, 2842, 2843, 2844, 2845, 2846, 2847, 2848, 2849, 2850, 2851, 2852, 2853, 2854, 2855, 2856, 2857, 2858, 2859, 2860, 2861, 2862, 2863, 2864, 2865, 2866, 2867, 2868, 2869, 2870, 2871, 2872, 2873, 2874, 2875, 2876, 2877, 2878, 2879, 2880, 2881, 2882, 2883, 2884, 2885, 2886, 2887, 2888, 2889, 2890, 2891, 2892, 2893, 2894, 2895, 2896, 2897, 2898, 2899, 2900, 2901, 2902, 2903, 2904, 2905, 2906, 2907, 2908, 2909, 2910, 2911, 2912, 2913, 2914, 2915, 2916, 2917, 2918, 2919, 2920, 2921, 2922, 2923, 2924, 2925, 2926, 2927, 2928, 2929, 2930, 2931, 2932, 2933, 2934, 2935, 2936, 2937, 2938, 2939, 2940, 2941, 2942, 2943, 2944, 2945, 2946, 2947, 2948, 2949, 2950, 2951, 2952, 2953, 2954, 2955, 2956, 2957, 2958, 2959, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2969, 2970, 2971, 2972, 2973, 2974, 2975, 2976, 2977, 2978, 2979, 2980, 2981, 2982, 2983, 2984, 2985, 2986, 2987, 2988, 2989, 2990, 2991, 2992, 2993, 2994, 2995, 2996, 2997, 2998, 2999, 3000, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 3009, 3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019, 3020, 3021, 3022, 3023, 3024, 3025, 3026, 3027, 3028, 3029, 3030, 3031, 3032, 3033, 3034, 3035, 3036, 3037, 3038, 3039, 3040, 3041, 3042, 3043, 3044, 3045, 3046, 3047, 3048, 3049, 3050, 3051, 3052, 3053, 3054, 3055, 3056, 3057, 3058, 3059, 3060, 3061, 3062, 3063, 3064, 3065, 3066, 3067, 3068, 3069, 3070, 3071, 3072, 3073, 3074, 3075, 3076, 3077, 3078, 3079, 3080, 3081, 3082, 3083, 3084, 3085, 3086, 3087, 3088, 3089, 3090, 3091, 3092, 3093, 3094, 3095, 3096, 3097, 3098, 3099, 3100, 3101, 3102, 3103, 3104, 3105, 3106, 3107, 3108, 3109, 3110, 3111, 3112, 3113, 3114, 3115, 3116, 3117, 3118, 3119, 3120, 3121, 3122, 3123, 3124, 3125, 3126, 3127, 3128, 3129, 3130, 3131, 3132, 3133, 3134, 3135, 3136, 3137, 3138, 3139, 3140, 3141, 3142, 3143, 3144, 3145, 3146, 3147, 3148, 3149, 3150, 3151, 3152, 3153, 3154, 3155, 3156, 3157, 3158, 3159, 3160, 3161, 3162, 3163, 3164, 3165, 3166, 3167, 3168, 3169, 3170, 3171, 3172, 3173, 3174, 3175, 3176, 3177, 3178, 3179, 3180, 3181, 3182, 3183, 3184, 3185, 3186, 3187, 3188, 3189, 3190, 3191, 3192, 3193, 3194, 3195, 3196, 3197, 3198, 3199, 3200, 3201, 3202, 3203, 3204, 3205, 3206, 3207, 3208, 3209, 3210, 3211, 3212, 3213, 3214, 3215, 3216, 3217, 3218, 3219, 3220, 3221, 3222, 3223, 3224, 3225, 3226, 3227, 3228, 3229, 3230, 3231, 3232, 3233, 3234, 3235, 3236, 3237, 3238, 3239, 3240, 3241, 3242, 3243, 3244, 3245, 3246, 3247, 3248, 3249, 3250, 3251, 3252, 3253, 3254, 3255, 3256, 3257, 3258, 3259, 3260, 3261, 3262, 3263, 3264, 3265, 3266, 3267, 3268, 3269, 3270, 3271, 3272, 3273, 3274, 3275, 3276, 3277, 3278, 3279, 3280, 3281, 3282, 3283, 3284, 3285, 3286, 3287, 3288, 3289, 3290, 3291, 3292, 3293, 3294, 3295, 3296, 3297, 3298, 3299, 3300, 3301, 3302, 3303, 3304, 3305, 3306, 3307, 3308, 3309, 3310, 3311, 3312, 3313, 3314, 3315, 3316, 3317, 3318, 3319, 3320, 3321, 3322, 3323, 3324, 3325, 3326, 3327, 3328, 3329, 3330, 3331, 3332, 3333, 3334, 3335, 3336, 3337, 3338, 3339, 3340, 3341, 3342, 3343, 3344, 3345, 3346, 3347, 3348, 3349, 3350, 3351, 3352, 3353, 3354, 3355, 3356, 3357, 3358, 3359, 3360, 3361, 3362, 3363, 3364, 3365, 3366, 3367, 3368, 3369, 3370, 3371, 3372, 3373, 3374, 3375, 3376, 3377, 3378, 3379, 3380, 3381, 3382, 3383, 3384, 3385, 3386, 3387, 3388, 3389, 3390, 3391, 3392, 3393, 3394, 3395, 3396, 3397, 3398, 3399, 3400, 3401, 3402, 3403, 3404, 3405, 3406, 3407, 3408, 3409, 3410, 3411, 3412, 3413, 3414, 3415, 3416, 3417, 3418, 3419, 3420, 3421, 3422, 3423, 3424, 3425, 3426, 3427, 3428, 3429, 3430, 3431, 3432, 3433, 3434, 3435, 3436, 3437, 3438, 3439, 3440, 3441, 3442, 3443, 3444, 3445, 3446, 3447, 3448, 3449, 3450, 3451, 3452, 3453, 3454, 3455, 3456, 3457, 3458, 3459, 3460, 3461, 3462, 3463, 3464, 3465, 3466, 3467, 3468, 3469, 3470, 3471, 3472, 3473, 3474, 3475, 3476, 3477, 3478, 3479, 3480, 3481, 3482, 3483, 3484, 3485, 3486, 3487, 3488, 3489, 3490, 3491, 3492, 3493, 3494, 3495, 3496, 3497, 3498, 3499, 3500, 3501, 3502, 3503, 3504, 3505, 3506, 3507, 3508, 3509, 3510, 3511, 3512, 3513, 3514, 3515, 3516, 3517, 3518, 3519, 3520, 3521, 3522, 3523, 3524, 3525, 3526, 3527, 3528, 3529, 3530, 3531, 3532, 3533, 3534, 3535, 3536, 3537, 3538, 3539, 3540, 3541, 3542, 3543, 3544, 3545, 3546, 3547, 3548, 3549, 3550, 3551, 3552, 3553, 3554, 3555, 3556, 3557, 3558, 3559, 3560, 3561, 3562, 3563, 3564, 3565, 3566, 3567, 3568, 3569, 3570, 3571, 3572, 3573, 3574, 3575, 3576, 3577, 3578, 3579, 3580, 3581, 3582, 3583, 3584, 3585, 3586, 3587, 3588, 3589, 3590, 3591, 3592, 3593, 3594, 3595, 3596, 3597, 3598, 3599, 3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609, 3610, 3611, 3612, 3613, 3614, 3615, 3616, 3617, 3618, 3619, 3620, 3621, 3622, 3623, 3624, 3625, 3626, 3627, 3628, 3629, 3630, 3631, 3632, 3633, 3634, 3635, 3636, 3637, 3638, 3639, 3640, 3641, 3642, 3643, 3644, 3645, 3646, 3647, 3648, 3649, 3650, 3651, 3652, 3653, 3654, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3662, 3663, 3664, 3665, 3666, 3667, 3668, 3669, 3670, 3671, 3672, 3673, 3674, 3675, 3676, 3677, 3678, 3679, 3680, 3681, 3682, 3683, 3684, 3685, 3686, 3687, 3688, 3689, 3690, 3691, 3692, 3693, 3694, 3695, 3696, 3697, 3698, 3699, 3700, 3701, 3702, 3703, 3704, 3705, 3706, 3707, 3708, 3709, 3710, 3711, 3712, 3713, 3714, 3715, 3716, 3717, 3718, 3719, 3720, 3721, 3722, 3723, 3724, 3725, 3726, 3727, 3728, 3729, 3730, 3731, 3732, 3733, 3734, 3735, 3736, 3737, 3738, 3739, 3740, 3741, 3742, 3743, 3744, 3745, 3746, 3747, 3748, 3749, 3750, 3751, 3752, 3753, 3754, 3755, 3756, 3757, 3758, 3759, 3760, 3761, 3762, 3763, 3764, 3765, 3766, 3767, 3768, 3769, 3770, 3771, 3772, 3773, 3774, 3775, 3776, 3777, 3778, 3779, 3780, 3781, 3782, 3783, 3784, 3785, 3786, 3787, 3788, 3789, 3790, 3791, 3792, 3793, 3794, 3795, 3796, 3797, 3798, 3799, 3800, 3801, 3802, 3803, 3804, 3805, 3806, 3807, 3808, 3809, 3810, 3811, 3812, 3813, 3814, 3815, 3816, 3817, 3818, 3819, 3820, 3821, 3822, 3823, 3824, 3825, 3826, 3827, 3828, 3829, 3830, 3831, 3832, 3833, 3834, 3835, 3836, 3837, 3838, 3839, 3840, 3841, 3842, 3843, 3844, 3845, 3846, 3847, 3848, 3849, 3850, 3851, 3852, 3853, 3854, 3855, 3856, 3857, 3858, 3859, 3860, 3861, 3862, 3863, 3864, 3865, 3866, 3867, 3868, 3869, 3870, 3871, 3872, 3873, 3874, 3875, 3876, 3877, 3878, 3879, 3880, 3881, 3882, 3883, 3884, 3885, 3886, 3887, 3888, 3889, 3890, 3891, 3892, 3893, 3894, 3895, 3896, 3897, 3898, 3899, 3900, 3901, 3902, 3903, 3904, 3905, 3906, 3907, 3908, 3909, 3910, 3911, 3912, 3913, 3914, 3915, 3916, 3917, 3918, 3919, 3920, 3921, 3922, 3923, 3924, 3925, 3926, 3927, 3928, 3929, 3930, 3931, 3932, 3933, 3934, 3935, 3936, 3937, 3938, 3939, 3940, 3941, 3942, 3943, 3944, 3945, 3946, 3947, 3948, 3949, 3950, 3951, 3952, 3953, 3954, 3955, 3956, 3957, 3958, 3959, 3960, 3961, 3962, 3963, 3964, 3965, 3966, 3967, 3968, 3969, 3970, 3971, 3972, 3973, 3974, 3975, 3976, 3977, 3978, 3979, 3980, 3981, 3982, 3983, 3984, 3985, 3986, 3987, 3988, 3989, 3990, 3991, 3992, 3993, 3994, 3995, 3996, 3997, 3998, 3999, 4000, 4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008, 4009, 4010, 4011, 4012, 4013, 4014, 4015, 4016, 4017, 4018, 4019, 4020, 4021, 4022, 4023, 4024, 4025, 4026, 4027, 4028, 4029, 4030, 4031, 4032, 4033, 4034, 4035, 4036, 4037, 4038, 4039, 4040, 4041, 4042, 4043, 4044, 4045, 4046, 4047, 4048, 4049, 4050, 4051, 4052, 4053, 4054, 4055, 4056, 4057, 4058, 4059, 4060, 4061, 4062, 4063, 4064, 4065, 4066, 4067, 4068, 4069, 4070, 4071, 4072, 4073, 4074, 4075, 4076, 4077, 4078, 4079, 4080, 4081, 4082, 4083, 4084, 4085, 4086, 4087, 4088, 4089, 4090, 4091, 4092, 4093, 4094, 4095, 4096, 4097, 4098, 4099, 4100, 4101, 4102, 4103, 4104, 4105, 4106, 4107, 4108, 4109, 4110, 4111, 4112, 4113, 4114, 4115, 4116, 4117, 4118, 4119, 4120, 4121, 4122, 4123, 4124, 4125, 4126, 4127, 4128, 4129, 4130, 4131, 4132, 4133, 4134, 4135, 4136, 4137, 4138, 4139, 4140, 4141, 4142, 4143, 4144, 4145, 4146, 4147, 4148, 4149, 4150, 4151, 4152, 4153, 4154, 4155, 4156, 4157, 4158, 4159, 4160, 4161, 4162, 4163, 4164, 4165, 4166, 4167, 4168, 4169, 4170, 4171, 4172, 4173, 4174, 4175, 4176, 4177, 4178, 4179, 4180, 4181, 4182, 4183, 4184, 4185, 4186, 4187, 4188, 4189, 4190, 4191, 4192, 4193, 4194, 4195, 4196, 4197, 4198, 4199, 4200, 4201, 4202, 4203, 4204, 4205, 4206, 4207, 4208, 4209, 4210, 4211, 4212, 4213, 4214, 4215, 4216, 4217, 4218, 4219, 4220, 4221, 4222, 4223, 4224, 4225, 4226, 4227, 4228, 4229, 4230, 4231, 4232, 4233, 4234, 4235, 4236, 4237, 4238, 4239, 4240, 4241, 4242, 4243, 4244, 4245, 4246, 4247, 4248, 4249, 4250, 4251, 4252, 4253, 4254, 4255, 4256, 4257, 4258, 4259, 4260, 4261, 4262, 4263, 4264, 4265, 4266, 4267, 4268, 4269, 4270, 4271, 4272, 4273, 4274, 4275, 4276, 4277, 4278, 4279, 4280, 4281, 4282, 4283, 4284, 4285, 4286, 4287, 4288, 4289, 4290, 4291, 4292, 4293, 4294, 4295, 4296, 4297, 4298, 4299, 4300, 4301, 4302, 4303, 4304, 4305, 4306, 4307, 4308, 4309, 4310, 4311, 4312, 4313, 4314, 4315, 4316, 4317, 4318, 4319, 4320, 4321, 4322, 4323, 4324, 4325, 4326, 4327, 4328, 4329, 4330, 4331, 4332, 4333, 4334, 4335, 4336, 4337, 4338, 4339, 4340, 4341, 4342, 4343, 4344, 4345, 4346, 4347, 4348, 4349, 4350, 4351, 4352, 4353, 4354, 4355, 4356, 4357, 4358, 4359, 4360, 4361, 4362, 4363, 4364, 4365, 4366, 4367, 4368, 4369, 4370, 4371, 4372, 4373, 4374, 4375, 4376, 4377, 4378, 4379, 4380, 4381, 4382, 4383, 4384, 4385, 4386, 4387, 4388, 4389, 4390, 4391, 4392, 4393, 4394, 4395, 4396, 4397, 4398, 4399, 4400, 4401, 4402, 4403, 4404, 4405, 4406, 4407, 4408, 4409, 4410, 4411, 4412, 4413, 4414, 4415, 4416, 4417, 4418, 4419, 4420, 4421, 4422, 4423, 4424, 4425, 4426, 4427, 4428, 4429, 4430, 4431, 4432, 4433, 4434, 4435, 4436, 4437, 4438, 4439, 4440, 4441, 4442, 4443, 4444, 4445, 4446, 4447, 4448, 4449, 4450, 4451, 4452, 4453, 4454, 4455, 4456, 4457, 4458, 4459, 4460, 4461, 4462, 4463, 4464, 4465, 4466, 4467, 4468, 4469, 4470, 4471, 4472, 4473, 4474, 4475, 4476, 4477, 4478, 4479, 4480, 4481, 4482, 4483, 4484, 4485, 4486, 4487, 4488, 4489, 4490, 4491, 4492, 4493, 4494, 4495, 4496, 4497, 4498, 4499, -500, -499, -498, -497, -496, -495, -494, -493, -492, -491, -490, -489, -488, -487, -486, -485, -484, -483, -482, -481, -480, -479, -478, -477, -476, -475, -474, -473, -472, -471, -470, -469, -468, -467, -466, -465, -464, -463, -462, -461, -460, -459, -458, -457, -456, -455, -454, -453, -452, -451, -450, -449, -448, -447, -446, -445, -444, -443, -442, -441, -440, -439, -438, -437, -436, -435, -434, -433, -432, -431, -430, -429, -428, -427, -426, -425, -424, -423, -422, -421, -420, -419, -418, -417, -416, -415, -414, -413, -412, -411, -410, -409, -408, -407, -406, -405, -404, -403, -402, -401, -400, -399, -398, -397, -396, -395, -394, -393, -392, -391, -390, -389, -388, -387, -386, -385, -384, -383, -382, -381, -380, -379, -378, -377, -376, -375, -374, -373, -372, -371, -370, -369, -368, -367, -366, -365, -364, -363, -362, -361, -360, -359, -358, -357, -356, -355, -354, -353, -352, -351, -350, -349, -348, -347, -346, -345, -344, -343, -342, -341, -340, -339, -338, -337, -336, -335, -334, -333, -332, -331, -330, -329, -328, -327, -326, -325, -324, -323, -322, -321, -320, -319, -318, -317, -316, -315, -314, -313, -312, -311, -310, -309, -308, -307, -306, -305, -304, -303, -302, -301, -300, -299, -298, -297, -296, -295, -294, -293, -292, -291, -290, -289, -288, -287, -286, -285, -284, -283, -282, -281, -280, -279, -278, -277, -276, -275, -274, -273, -272, -271, -270, -269, -268, -267, -266, -265, -264, -263, -262, -261, -260, -259, -258, -257, -256, -255, -254, -253, -252, -251, -250, -249, -248, -247, -246, -245, -244, -243, -242, -241, -240, -239, -238, -237, -236, -235, -234, -233, -232, -231, -230, -229, -228, -227, -226, -225, -224, -223, -222, -221, -220, -219, -218, -217, -216, -215, -214, -213, -212, -211, -210, -209, -208, -207, -206, -205, -204, -203, -202, -201, -200, -199, -198, -197, -196, -195, -194, -193, -192, -191, -190, -189, -188, -187, -186, -185, -184, -183, -182, -181, -180, -179, -178, -177, -176, -175, -174, -173, -172, -171, -170, -169, -168, -167, -166, -165, -164, -163, -162, -161, -160, -159]\n0\n```\nand also this one\n```\n[1,2,1,2,1,2,1,2,1,2]\n-1\n```"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, we need to find out cycle means cycle detection.\\nLet\\'s say Two people are running on a circle then definately they meet at any point. If they meet means cycle present. \\n\\n# Approach\\nSo, Here I will use Fast and Slow pointer (Two pointer approach).\\n1- Initialize two pointer slow and fast.\\n2- Initially both are pointing to head.\\n3- When loop run slow pointer move step ahead while fast pointer move it\\'s double.\\n4- If both pointer meet at a particular point it means cycle present other no."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Forget the garbage task.\\n\\nRead the real one:\\nRetuen `True` for neighboring Nodes with equal values, otherwise `False`"
                    },
                    {
                        "username": "arshita129",
                        "content": "neighboring nodes with equal values?? We are not trying to see if neighboring nodes have equal values.\\n"
                    }
                ]
            },
            {
                "id": 2043842,
                "content": [
                    {
                        "username": "julkar9",
                        "content": "I hate this kind of questions, its either you know the solution or don\\'t. There\\'s no in-between."
                    },
                    {
                        "username": "psionl0",
                        "content": "The fast and slow pointer technique is useful in a variety of linked list situations. It is worth while learning about it."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "I\\'m not going to read the whole question just for \"Find cycle\""
                    },
                    {
                        "username": "katalma",
                        "content": "Beginning of the week, beginning of the month. I can believe I am smart. But in the end..."
                    },
                    {
                        "username": "sakibmondal7",
                        "content": "Just check the solution with minimum space under Python language.. They did some strange things.. \n\nThey edited the user response in backend with pos variable. I guess that is why `POS` is given.\n\nThis is cheatings at next level.. "
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "## there is no use of pos here ##\\n`\\nhead = [3,2,0,-4], pos = 3\\n`\\nWill pass the test case since refreance of last node is to pos 1 node"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Okay, so we all know the constant memory solution - but is there a different approach (that uses more than constant space) that also takes linear time? Best I can think of is quadratic."
                    },
                    {
                        "username": "aitachii",
                        "content": "Hash table/dictionary of ListNodes take up O(n) space. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Is LeetCode softening us up?"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Check out this testcase\n```\n[-158, -157, -156, -155, -154, -153, -152, -151, -150, -149, -148, -147, -146, -145, -144, -143, -142, -141, -140, -139, -138, -137, -136, -135, -134, -133, -132, -131, -130, -129, -128, -127, -126, -125, -124, -123, -122, -121, -120, -119, -118, -117, -116, -115, -114, -113, -112, -111, -110, -109, -108, -107, -106, -105, -104, -103, -102, -101, -100, -99, -98, -97, -96, -95, -94, -93, -92, -91, -90, -89, -88, -87, -86, -85, -84, -83, -82, -81, -80, -79, -78, -77, -76, -75, -74, -73, -72, -71, -70, -69, -68, -67, -66, -65, -64, -63, -62, -61, -60, -59, -58, -57, -56, -55, -54, -53, -52, -51, -50, -49, -48, -47, -46, -45, -44, -43, -42, -41, -40, -39, -38, -37, -36, -35, -34, -33, -32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1633, 1634, 1635, 1636, 1637, 1638, 1639, 1640, 1641, 1642, 1643, 1644, 1645, 1646, 1647, 1648, 1649, 1650, 1651, 1652, 1653, 1654, 1655, 1656, 1657, 1658, 1659, 1660, 1661, 1662, 1663, 1664, 1665, 1666, 1667, 1668, 1669, 1670, 1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684, 1685, 1686, 1687, 1688, 1689, 1690, 1691, 1692, 1693, 1694, 1695, 1696, 1697, 1698, 1699, 1700, 1701, 1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709, 1710, 1711, 1712, 1713, 1714, 1715, 1716, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1724, 1725, 1726, 1727, 1728, 1729, 1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738, 1739, 1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749, 1750, 1751, 1752, 1753, 1754, 1755, 1756, 1757, 1758, 1759, 1760, 1761, 1762, 1763, 1764, 1765, 1766, 1767, 1768, 1769, 1770, 1771, 1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1780, 1781, 1782, 1783, 1784, 1785, 1786, 1787, 1788, 1789, 1790, 1791, 1792, 1793, 1794, 1795, 1796, 1797, 1798, 1799, 1800, 1801, 1802, 1803, 1804, 1805, 1806, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 1815, 1816, 1817, 1818, 1819, 1820, 1821, 1822, 1823, 1824, 1825, 1826, 1827, 1828, 1829, 1830, 1831, 1832, 1833, 1834, 1835, 1836, 1837, 1838, 1839, 1840, 1841, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849, 1850, 1851, 1852, 1853, 1854, 1855, 1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879, 1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 2039, 2040, 2041, 2042, 2043, 2044, 2045, 2046, 2047, 2048, 2049, 2050, 2051, 2052, 2053, 2054, 2055, 2056, 2057, 2058, 2059, 2060, 2061, 2062, 2063, 2064, 2065, 2066, 2067, 2068, 2069, 2070, 2071, 2072, 2073, 2074, 2075, 2076, 2077, 2078, 2079, 2080, 2081, 2082, 2083, 2084, 2085, 2086, 2087, 2088, 2089, 2090, 2091, 2092, 2093, 2094, 2095, 2096, 2097, 2098, 2099, 2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107, 2108, 2109, 2110, 2111, 2112, 2113, 2114, 2115, 2116, 2117, 2118, 2119, 2120, 2121, 2122, 2123, 2124, 2125, 2126, 2127, 2128, 2129, 2130, 2131, 2132, 2133, 2134, 2135, 2136, 2137, 2138, 2139, 2140, 2141, 2142, 2143, 2144, 2145, 2146, 2147, 2148, 2149, 2150, 2151, 2152, 2153, 2154, 2155, 2156, 2157, 2158, 2159, 2160, 2161, 2162, 2163, 2164, 2165, 2166, 2167, 2168, 2169, 2170, 2171, 2172, 2173, 2174, 2175, 2176, 2177, 2178, 2179, 2180, 2181, 2182, 2183, 2184, 2185, 2186, 2187, 2188, 2189, 2190, 2191, 2192, 2193, 2194, 2195, 2196, 2197, 2198, 2199, 2200, 2201, 2202, 2203, 2204, 2205, 2206, 2207, 2208, 2209, 2210, 2211, 2212, 2213, 2214, 2215, 2216, 2217, 2218, 2219, 2220, 2221, 2222, 2223, 2224, 2225, 2226, 2227, 2228, 2229, 2230, 2231, 2232, 2233, 2234, 2235, 2236, 2237, 2238, 2239, 2240, 2241, 2242, 2243, 2244, 2245, 2246, 2247, 2248, 2249, 2250, 2251, 2252, 2253, 2254, 2255, 2256, 2257, 2258, 2259, 2260, 2261, 2262, 2263, 2264, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2272, 2273, 2274, 2275, 2276, 2277, 2278, 2279, 2280, 2281, 2282, 2283, 2284, 2285, 2286, 2287, 2288, 2289, 2290, 2291, 2292, 2293, 2294, 2295, 2296, 2297, 2298, 2299, 2300, 2301, 2302, 2303, 2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2319, 2320, 2321, 2322, 2323, 2324, 2325, 2326, 2327, 2328, 2329, 2330, 2331, 2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341, 2342, 2343, 2344, 2345, 2346, 2347, 2348, 2349, 2350, 2351, 2352, 2353, 2354, 2355, 2356, 2357, 2358, 2359, 2360, 2361, 2362, 2363, 2364, 2365, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2384, 2385, 2386, 2387, 2388, 2389, 2390, 2391, 2392, 2393, 2394, 2395, 2396, 2397, 2398, 2399, 2400, 2401, 2402, 2403, 2404, 2405, 2406, 2407, 2408, 2409, 2410, 2411, 2412, 2413, 2414, 2415, 2416, 2417, 2418, 2419, 2420, 2421, 2422, 2423, 2424, 2425, 2426, 2427, 2428, 2429, 2430, 2431, 2432, 2433, 2434, 2435, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2443, 2444, 2445, 2446, 2447, 2448, 2449, 2450, 2451, 2452, 2453, 2454, 2455, 2456, 2457, 2458, 2459, 2460, 2461, 2462, 2463, 2464, 2465, 2466, 2467, 2468, 2469, 2470, 2471, 2472, 2473, 2474, 2475, 2476, 2477, 2478, 2479, 2480, 2481, 2482, 2483, 2484, 2485, 2486, 2487, 2488, 2489, 2490, 2491, 2492, 2493, 2494, 2495, 2496, 2497, 2498, 2499, 2500, 2501, 2502, 2503, 2504, 2505, 2506, 2507, 2508, 2509, 2510, 2511, 2512, 2513, 2514, 2515, 2516, 2517, 2518, 2519, 2520, 2521, 2522, 2523, 2524, 2525, 2526, 2527, 2528, 2529, 2530, 2531, 2532, 2533, 2534, 2535, 2536, 2537, 2538, 2539, 2540, 2541, 2542, 2543, 2544, 2545, 2546, 2547, 2548, 2549, 2550, 2551, 2552, 2553, 2554, 2555, 2556, 2557, 2558, 2559, 2560, 2561, 2562, 2563, 2564, 2565, 2566, 2567, 2568, 2569, 2570, 2571, 2572, 2573, 2574, 2575, 2576, 2577, 2578, 2579, 2580, 2581, 2582, 2583, 2584, 2585, 2586, 2587, 2588, 2589, 2590, 2591, 2592, 2593, 2594, 2595, 2596, 2597, 2598, 2599, 2600, 2601, 2602, 2603, 2604, 2605, 2606, 2607, 2608, 2609, 2610, 2611, 2612, 2613, 2614, 2615, 2616, 2617, 2618, 2619, 2620, 2621, 2622, 2623, 2624, 2625, 2626, 2627, 2628, 2629, 2630, 2631, 2632, 2633, 2634, 2635, 2636, 2637, 2638, 2639, 2640, 2641, 2642, 2643, 2644, 2645, 2646, 2647, 2648, 2649, 2650, 2651, 2652, 2653, 2654, 2655, 2656, 2657, 2658, 2659, 2660, 2661, 2662, 2663, 2664, 2665, 2666, 2667, 2668, 2669, 2670, 2671, 2672, 2673, 2674, 2675, 2676, 2677, 2678, 2679, 2680, 2681, 2682, 2683, 2684, 2685, 2686, 2687, 2688, 2689, 2690, 2691, 2692, 2693, 2694, 2695, 2696, 2697, 2698, 2699, 2700, 2701, 2702, 2703, 2704, 2705, 2706, 2707, 2708, 2709, 2710, 2711, 2712, 2713, 2714, 2715, 2716, 2717, 2718, 2719, 2720, 2721, 2722, 2723, 2724, 2725, 2726, 2727, 2728, 2729, 2730, 2731, 2732, 2733, 2734, 2735, 2736, 2737, 2738, 2739, 2740, 2741, 2742, 2743, 2744, 2745, 2746, 2747, 2748, 2749, 2750, 2751, 2752, 2753, 2754, 2755, 2756, 2757, 2758, 2759, 2760, 2761, 2762, 2763, 2764, 2765, 2766, 2767, 2768, 2769, 2770, 2771, 2772, 2773, 2774, 2775, 2776, 2777, 2778, 2779, 2780, 2781, 2782, 2783, 2784, 2785, 2786, 2787, 2788, 2789, 2790, 2791, 2792, 2793, 2794, 2795, 2796, 2797, 2798, 2799, 2800, 2801, 2802, 2803, 2804, 2805, 2806, 2807, 2808, 2809, 2810, 2811, 2812, 2813, 2814, 2815, 2816, 2817, 2818, 2819, 2820, 2821, 2822, 2823, 2824, 2825, 2826, 2827, 2828, 2829, 2830, 2831, 2832, 2833, 2834, 2835, 2836, 2837, 2838, 2839, 2840, 2841, 2842, 2843, 2844, 2845, 2846, 2847, 2848, 2849, 2850, 2851, 2852, 2853, 2854, 2855, 2856, 2857, 2858, 2859, 2860, 2861, 2862, 2863, 2864, 2865, 2866, 2867, 2868, 2869, 2870, 2871, 2872, 2873, 2874, 2875, 2876, 2877, 2878, 2879, 2880, 2881, 2882, 2883, 2884, 2885, 2886, 2887, 2888, 2889, 2890, 2891, 2892, 2893, 2894, 2895, 2896, 2897, 2898, 2899, 2900, 2901, 2902, 2903, 2904, 2905, 2906, 2907, 2908, 2909, 2910, 2911, 2912, 2913, 2914, 2915, 2916, 2917, 2918, 2919, 2920, 2921, 2922, 2923, 2924, 2925, 2926, 2927, 2928, 2929, 2930, 2931, 2932, 2933, 2934, 2935, 2936, 2937, 2938, 2939, 2940, 2941, 2942, 2943, 2944, 2945, 2946, 2947, 2948, 2949, 2950, 2951, 2952, 2953, 2954, 2955, 2956, 2957, 2958, 2959, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2969, 2970, 2971, 2972, 2973, 2974, 2975, 2976, 2977, 2978, 2979, 2980, 2981, 2982, 2983, 2984, 2985, 2986, 2987, 2988, 2989, 2990, 2991, 2992, 2993, 2994, 2995, 2996, 2997, 2998, 2999, 3000, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 3009, 3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019, 3020, 3021, 3022, 3023, 3024, 3025, 3026, 3027, 3028, 3029, 3030, 3031, 3032, 3033, 3034, 3035, 3036, 3037, 3038, 3039, 3040, 3041, 3042, 3043, 3044, 3045, 3046, 3047, 3048, 3049, 3050, 3051, 3052, 3053, 3054, 3055, 3056, 3057, 3058, 3059, 3060, 3061, 3062, 3063, 3064, 3065, 3066, 3067, 3068, 3069, 3070, 3071, 3072, 3073, 3074, 3075, 3076, 3077, 3078, 3079, 3080, 3081, 3082, 3083, 3084, 3085, 3086, 3087, 3088, 3089, 3090, 3091, 3092, 3093, 3094, 3095, 3096, 3097, 3098, 3099, 3100, 3101, 3102, 3103, 3104, 3105, 3106, 3107, 3108, 3109, 3110, 3111, 3112, 3113, 3114, 3115, 3116, 3117, 3118, 3119, 3120, 3121, 3122, 3123, 3124, 3125, 3126, 3127, 3128, 3129, 3130, 3131, 3132, 3133, 3134, 3135, 3136, 3137, 3138, 3139, 3140, 3141, 3142, 3143, 3144, 3145, 3146, 3147, 3148, 3149, 3150, 3151, 3152, 3153, 3154, 3155, 3156, 3157, 3158, 3159, 3160, 3161, 3162, 3163, 3164, 3165, 3166, 3167, 3168, 3169, 3170, 3171, 3172, 3173, 3174, 3175, 3176, 3177, 3178, 3179, 3180, 3181, 3182, 3183, 3184, 3185, 3186, 3187, 3188, 3189, 3190, 3191, 3192, 3193, 3194, 3195, 3196, 3197, 3198, 3199, 3200, 3201, 3202, 3203, 3204, 3205, 3206, 3207, 3208, 3209, 3210, 3211, 3212, 3213, 3214, 3215, 3216, 3217, 3218, 3219, 3220, 3221, 3222, 3223, 3224, 3225, 3226, 3227, 3228, 3229, 3230, 3231, 3232, 3233, 3234, 3235, 3236, 3237, 3238, 3239, 3240, 3241, 3242, 3243, 3244, 3245, 3246, 3247, 3248, 3249, 3250, 3251, 3252, 3253, 3254, 3255, 3256, 3257, 3258, 3259, 3260, 3261, 3262, 3263, 3264, 3265, 3266, 3267, 3268, 3269, 3270, 3271, 3272, 3273, 3274, 3275, 3276, 3277, 3278, 3279, 3280, 3281, 3282, 3283, 3284, 3285, 3286, 3287, 3288, 3289, 3290, 3291, 3292, 3293, 3294, 3295, 3296, 3297, 3298, 3299, 3300, 3301, 3302, 3303, 3304, 3305, 3306, 3307, 3308, 3309, 3310, 3311, 3312, 3313, 3314, 3315, 3316, 3317, 3318, 3319, 3320, 3321, 3322, 3323, 3324, 3325, 3326, 3327, 3328, 3329, 3330, 3331, 3332, 3333, 3334, 3335, 3336, 3337, 3338, 3339, 3340, 3341, 3342, 3343, 3344, 3345, 3346, 3347, 3348, 3349, 3350, 3351, 3352, 3353, 3354, 3355, 3356, 3357, 3358, 3359, 3360, 3361, 3362, 3363, 3364, 3365, 3366, 3367, 3368, 3369, 3370, 3371, 3372, 3373, 3374, 3375, 3376, 3377, 3378, 3379, 3380, 3381, 3382, 3383, 3384, 3385, 3386, 3387, 3388, 3389, 3390, 3391, 3392, 3393, 3394, 3395, 3396, 3397, 3398, 3399, 3400, 3401, 3402, 3403, 3404, 3405, 3406, 3407, 3408, 3409, 3410, 3411, 3412, 3413, 3414, 3415, 3416, 3417, 3418, 3419, 3420, 3421, 3422, 3423, 3424, 3425, 3426, 3427, 3428, 3429, 3430, 3431, 3432, 3433, 3434, 3435, 3436, 3437, 3438, 3439, 3440, 3441, 3442, 3443, 3444, 3445, 3446, 3447, 3448, 3449, 3450, 3451, 3452, 3453, 3454, 3455, 3456, 3457, 3458, 3459, 3460, 3461, 3462, 3463, 3464, 3465, 3466, 3467, 3468, 3469, 3470, 3471, 3472, 3473, 3474, 3475, 3476, 3477, 3478, 3479, 3480, 3481, 3482, 3483, 3484, 3485, 3486, 3487, 3488, 3489, 3490, 3491, 3492, 3493, 3494, 3495, 3496, 3497, 3498, 3499, 3500, 3501, 3502, 3503, 3504, 3505, 3506, 3507, 3508, 3509, 3510, 3511, 3512, 3513, 3514, 3515, 3516, 3517, 3518, 3519, 3520, 3521, 3522, 3523, 3524, 3525, 3526, 3527, 3528, 3529, 3530, 3531, 3532, 3533, 3534, 3535, 3536, 3537, 3538, 3539, 3540, 3541, 3542, 3543, 3544, 3545, 3546, 3547, 3548, 3549, 3550, 3551, 3552, 3553, 3554, 3555, 3556, 3557, 3558, 3559, 3560, 3561, 3562, 3563, 3564, 3565, 3566, 3567, 3568, 3569, 3570, 3571, 3572, 3573, 3574, 3575, 3576, 3577, 3578, 3579, 3580, 3581, 3582, 3583, 3584, 3585, 3586, 3587, 3588, 3589, 3590, 3591, 3592, 3593, 3594, 3595, 3596, 3597, 3598, 3599, 3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609, 3610, 3611, 3612, 3613, 3614, 3615, 3616, 3617, 3618, 3619, 3620, 3621, 3622, 3623, 3624, 3625, 3626, 3627, 3628, 3629, 3630, 3631, 3632, 3633, 3634, 3635, 3636, 3637, 3638, 3639, 3640, 3641, 3642, 3643, 3644, 3645, 3646, 3647, 3648, 3649, 3650, 3651, 3652, 3653, 3654, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3662, 3663, 3664, 3665, 3666, 3667, 3668, 3669, 3670, 3671, 3672, 3673, 3674, 3675, 3676, 3677, 3678, 3679, 3680, 3681, 3682, 3683, 3684, 3685, 3686, 3687, 3688, 3689, 3690, 3691, 3692, 3693, 3694, 3695, 3696, 3697, 3698, 3699, 3700, 3701, 3702, 3703, 3704, 3705, 3706, 3707, 3708, 3709, 3710, 3711, 3712, 3713, 3714, 3715, 3716, 3717, 3718, 3719, 3720, 3721, 3722, 3723, 3724, 3725, 3726, 3727, 3728, 3729, 3730, 3731, 3732, 3733, 3734, 3735, 3736, 3737, 3738, 3739, 3740, 3741, 3742, 3743, 3744, 3745, 3746, 3747, 3748, 3749, 3750, 3751, 3752, 3753, 3754, 3755, 3756, 3757, 3758, 3759, 3760, 3761, 3762, 3763, 3764, 3765, 3766, 3767, 3768, 3769, 3770, 3771, 3772, 3773, 3774, 3775, 3776, 3777, 3778, 3779, 3780, 3781, 3782, 3783, 3784, 3785, 3786, 3787, 3788, 3789, 3790, 3791, 3792, 3793, 3794, 3795, 3796, 3797, 3798, 3799, 3800, 3801, 3802, 3803, 3804, 3805, 3806, 3807, 3808, 3809, 3810, 3811, 3812, 3813, 3814, 3815, 3816, 3817, 3818, 3819, 3820, 3821, 3822, 3823, 3824, 3825, 3826, 3827, 3828, 3829, 3830, 3831, 3832, 3833, 3834, 3835, 3836, 3837, 3838, 3839, 3840, 3841, 3842, 3843, 3844, 3845, 3846, 3847, 3848, 3849, 3850, 3851, 3852, 3853, 3854, 3855, 3856, 3857, 3858, 3859, 3860, 3861, 3862, 3863, 3864, 3865, 3866, 3867, 3868, 3869, 3870, 3871, 3872, 3873, 3874, 3875, 3876, 3877, 3878, 3879, 3880, 3881, 3882, 3883, 3884, 3885, 3886, 3887, 3888, 3889, 3890, 3891, 3892, 3893, 3894, 3895, 3896, 3897, 3898, 3899, 3900, 3901, 3902, 3903, 3904, 3905, 3906, 3907, 3908, 3909, 3910, 3911, 3912, 3913, 3914, 3915, 3916, 3917, 3918, 3919, 3920, 3921, 3922, 3923, 3924, 3925, 3926, 3927, 3928, 3929, 3930, 3931, 3932, 3933, 3934, 3935, 3936, 3937, 3938, 3939, 3940, 3941, 3942, 3943, 3944, 3945, 3946, 3947, 3948, 3949, 3950, 3951, 3952, 3953, 3954, 3955, 3956, 3957, 3958, 3959, 3960, 3961, 3962, 3963, 3964, 3965, 3966, 3967, 3968, 3969, 3970, 3971, 3972, 3973, 3974, 3975, 3976, 3977, 3978, 3979, 3980, 3981, 3982, 3983, 3984, 3985, 3986, 3987, 3988, 3989, 3990, 3991, 3992, 3993, 3994, 3995, 3996, 3997, 3998, 3999, 4000, 4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008, 4009, 4010, 4011, 4012, 4013, 4014, 4015, 4016, 4017, 4018, 4019, 4020, 4021, 4022, 4023, 4024, 4025, 4026, 4027, 4028, 4029, 4030, 4031, 4032, 4033, 4034, 4035, 4036, 4037, 4038, 4039, 4040, 4041, 4042, 4043, 4044, 4045, 4046, 4047, 4048, 4049, 4050, 4051, 4052, 4053, 4054, 4055, 4056, 4057, 4058, 4059, 4060, 4061, 4062, 4063, 4064, 4065, 4066, 4067, 4068, 4069, 4070, 4071, 4072, 4073, 4074, 4075, 4076, 4077, 4078, 4079, 4080, 4081, 4082, 4083, 4084, 4085, 4086, 4087, 4088, 4089, 4090, 4091, 4092, 4093, 4094, 4095, 4096, 4097, 4098, 4099, 4100, 4101, 4102, 4103, 4104, 4105, 4106, 4107, 4108, 4109, 4110, 4111, 4112, 4113, 4114, 4115, 4116, 4117, 4118, 4119, 4120, 4121, 4122, 4123, 4124, 4125, 4126, 4127, 4128, 4129, 4130, 4131, 4132, 4133, 4134, 4135, 4136, 4137, 4138, 4139, 4140, 4141, 4142, 4143, 4144, 4145, 4146, 4147, 4148, 4149, 4150, 4151, 4152, 4153, 4154, 4155, 4156, 4157, 4158, 4159, 4160, 4161, 4162, 4163, 4164, 4165, 4166, 4167, 4168, 4169, 4170, 4171, 4172, 4173, 4174, 4175, 4176, 4177, 4178, 4179, 4180, 4181, 4182, 4183, 4184, 4185, 4186, 4187, 4188, 4189, 4190, 4191, 4192, 4193, 4194, 4195, 4196, 4197, 4198, 4199, 4200, 4201, 4202, 4203, 4204, 4205, 4206, 4207, 4208, 4209, 4210, 4211, 4212, 4213, 4214, 4215, 4216, 4217, 4218, 4219, 4220, 4221, 4222, 4223, 4224, 4225, 4226, 4227, 4228, 4229, 4230, 4231, 4232, 4233, 4234, 4235, 4236, 4237, 4238, 4239, 4240, 4241, 4242, 4243, 4244, 4245, 4246, 4247, 4248, 4249, 4250, 4251, 4252, 4253, 4254, 4255, 4256, 4257, 4258, 4259, 4260, 4261, 4262, 4263, 4264, 4265, 4266, 4267, 4268, 4269, 4270, 4271, 4272, 4273, 4274, 4275, 4276, 4277, 4278, 4279, 4280, 4281, 4282, 4283, 4284, 4285, 4286, 4287, 4288, 4289, 4290, 4291, 4292, 4293, 4294, 4295, 4296, 4297, 4298, 4299, 4300, 4301, 4302, 4303, 4304, 4305, 4306, 4307, 4308, 4309, 4310, 4311, 4312, 4313, 4314, 4315, 4316, 4317, 4318, 4319, 4320, 4321, 4322, 4323, 4324, 4325, 4326, 4327, 4328, 4329, 4330, 4331, 4332, 4333, 4334, 4335, 4336, 4337, 4338, 4339, 4340, 4341, 4342, 4343, 4344, 4345, 4346, 4347, 4348, 4349, 4350, 4351, 4352, 4353, 4354, 4355, 4356, 4357, 4358, 4359, 4360, 4361, 4362, 4363, 4364, 4365, 4366, 4367, 4368, 4369, 4370, 4371, 4372, 4373, 4374, 4375, 4376, 4377, 4378, 4379, 4380, 4381, 4382, 4383, 4384, 4385, 4386, 4387, 4388, 4389, 4390, 4391, 4392, 4393, 4394, 4395, 4396, 4397, 4398, 4399, 4400, 4401, 4402, 4403, 4404, 4405, 4406, 4407, 4408, 4409, 4410, 4411, 4412, 4413, 4414, 4415, 4416, 4417, 4418, 4419, 4420, 4421, 4422, 4423, 4424, 4425, 4426, 4427, 4428, 4429, 4430, 4431, 4432, 4433, 4434, 4435, 4436, 4437, 4438, 4439, 4440, 4441, 4442, 4443, 4444, 4445, 4446, 4447, 4448, 4449, 4450, 4451, 4452, 4453, 4454, 4455, 4456, 4457, 4458, 4459, 4460, 4461, 4462, 4463, 4464, 4465, 4466, 4467, 4468, 4469, 4470, 4471, 4472, 4473, 4474, 4475, 4476, 4477, 4478, 4479, 4480, 4481, 4482, 4483, 4484, 4485, 4486, 4487, 4488, 4489, 4490, 4491, 4492, 4493, 4494, 4495, 4496, 4497, 4498, 4499, -500, -499, -498, -497, -496, -495, -494, -493, -492, -491, -490, -489, -488, -487, -486, -485, -484, -483, -482, -481, -480, -479, -478, -477, -476, -475, -474, -473, -472, -471, -470, -469, -468, -467, -466, -465, -464, -463, -462, -461, -460, -459, -458, -457, -456, -455, -454, -453, -452, -451, -450, -449, -448, -447, -446, -445, -444, -443, -442, -441, -440, -439, -438, -437, -436, -435, -434, -433, -432, -431, -430, -429, -428, -427, -426, -425, -424, -423, -422, -421, -420, -419, -418, -417, -416, -415, -414, -413, -412, -411, -410, -409, -408, -407, -406, -405, -404, -403, -402, -401, -400, -399, -398, -397, -396, -395, -394, -393, -392, -391, -390, -389, -388, -387, -386, -385, -384, -383, -382, -381, -380, -379, -378, -377, -376, -375, -374, -373, -372, -371, -370, -369, -368, -367, -366, -365, -364, -363, -362, -361, -360, -359, -358, -357, -356, -355, -354, -353, -352, -351, -350, -349, -348, -347, -346, -345, -344, -343, -342, -341, -340, -339, -338, -337, -336, -335, -334, -333, -332, -331, -330, -329, -328, -327, -326, -325, -324, -323, -322, -321, -320, -319, -318, -317, -316, -315, -314, -313, -312, -311, -310, -309, -308, -307, -306, -305, -304, -303, -302, -301, -300, -299, -298, -297, -296, -295, -294, -293, -292, -291, -290, -289, -288, -287, -286, -285, -284, -283, -282, -281, -280, -279, -278, -277, -276, -275, -274, -273, -272, -271, -270, -269, -268, -267, -266, -265, -264, -263, -262, -261, -260, -259, -258, -257, -256, -255, -254, -253, -252, -251, -250, -249, -248, -247, -246, -245, -244, -243, -242, -241, -240, -239, -238, -237, -236, -235, -234, -233, -232, -231, -230, -229, -228, -227, -226, -225, -224, -223, -222, -221, -220, -219, -218, -217, -216, -215, -214, -213, -212, -211, -210, -209, -208, -207, -206, -205, -204, -203, -202, -201, -200, -199, -198, -197, -196, -195, -194, -193, -192, -191, -190, -189, -188, -187, -186, -185, -184, -183, -182, -181, -180, -179, -178, -177, -176, -175, -174, -173, -172, -171, -170, -169, -168, -167, -166, -165, -164, -163, -162, -161, -160, -159]\n0\n```\nand also this one\n```\n[1,2,1,2,1,2,1,2,1,2]\n-1\n```"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, we need to find out cycle means cycle detection.\\nLet\\'s say Two people are running on a circle then definately they meet at any point. If they meet means cycle present. \\n\\n# Approach\\nSo, Here I will use Fast and Slow pointer (Two pointer approach).\\n1- Initialize two pointer slow and fast.\\n2- Initially both are pointing to head.\\n3- When loop run slow pointer move step ahead while fast pointer move it\\'s double.\\n4- If both pointer meet at a particular point it means cycle present other no."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Forget the garbage task.\\n\\nRead the real one:\\nRetuen `True` for neighboring Nodes with equal values, otherwise `False`"
                    },
                    {
                        "username": "arshita129",
                        "content": "neighboring nodes with equal values?? We are not trying to see if neighboring nodes have equal values.\\n"
                    }
                ]
            },
            {
                "id": 2043654,
                "content": [
                    {
                        "username": "julkar9",
                        "content": "I hate this kind of questions, its either you know the solution or don\\'t. There\\'s no in-between."
                    },
                    {
                        "username": "psionl0",
                        "content": "The fast and slow pointer technique is useful in a variety of linked list situations. It is worth while learning about it."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "I\\'m not going to read the whole question just for \"Find cycle\""
                    },
                    {
                        "username": "katalma",
                        "content": "Beginning of the week, beginning of the month. I can believe I am smart. But in the end..."
                    },
                    {
                        "username": "sakibmondal7",
                        "content": "Just check the solution with minimum space under Python language.. They did some strange things.. \n\nThey edited the user response in backend with pos variable. I guess that is why `POS` is given.\n\nThis is cheatings at next level.. "
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "## there is no use of pos here ##\\n`\\nhead = [3,2,0,-4], pos = 3\\n`\\nWill pass the test case since refreance of last node is to pos 1 node"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Okay, so we all know the constant memory solution - but is there a different approach (that uses more than constant space) that also takes linear time? Best I can think of is quadratic."
                    },
                    {
                        "username": "aitachii",
                        "content": "Hash table/dictionary of ListNodes take up O(n) space. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Is LeetCode softening us up?"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Check out this testcase\n```\n[-158, -157, -156, -155, -154, -153, -152, -151, -150, -149, -148, -147, -146, -145, -144, -143, -142, -141, -140, -139, -138, -137, -136, -135, -134, -133, -132, -131, -130, -129, -128, -127, -126, -125, -124, -123, -122, -121, -120, -119, -118, -117, -116, -115, -114, -113, -112, -111, -110, -109, -108, -107, -106, -105, -104, -103, -102, -101, -100, -99, -98, -97, -96, -95, -94, -93, -92, -91, -90, -89, -88, -87, -86, -85, -84, -83, -82, -81, -80, -79, -78, -77, -76, -75, -74, -73, -72, -71, -70, -69, -68, -67, -66, -65, -64, -63, -62, -61, -60, -59, -58, -57, -56, -55, -54, -53, -52, -51, -50, -49, -48, -47, -46, -45, -44, -43, -42, -41, -40, -39, -38, -37, -36, -35, -34, -33, -32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1633, 1634, 1635, 1636, 1637, 1638, 1639, 1640, 1641, 1642, 1643, 1644, 1645, 1646, 1647, 1648, 1649, 1650, 1651, 1652, 1653, 1654, 1655, 1656, 1657, 1658, 1659, 1660, 1661, 1662, 1663, 1664, 1665, 1666, 1667, 1668, 1669, 1670, 1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684, 1685, 1686, 1687, 1688, 1689, 1690, 1691, 1692, 1693, 1694, 1695, 1696, 1697, 1698, 1699, 1700, 1701, 1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709, 1710, 1711, 1712, 1713, 1714, 1715, 1716, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1724, 1725, 1726, 1727, 1728, 1729, 1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738, 1739, 1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749, 1750, 1751, 1752, 1753, 1754, 1755, 1756, 1757, 1758, 1759, 1760, 1761, 1762, 1763, 1764, 1765, 1766, 1767, 1768, 1769, 1770, 1771, 1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1780, 1781, 1782, 1783, 1784, 1785, 1786, 1787, 1788, 1789, 1790, 1791, 1792, 1793, 1794, 1795, 1796, 1797, 1798, 1799, 1800, 1801, 1802, 1803, 1804, 1805, 1806, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 1815, 1816, 1817, 1818, 1819, 1820, 1821, 1822, 1823, 1824, 1825, 1826, 1827, 1828, 1829, 1830, 1831, 1832, 1833, 1834, 1835, 1836, 1837, 1838, 1839, 1840, 1841, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849, 1850, 1851, 1852, 1853, 1854, 1855, 1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879, 1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 2039, 2040, 2041, 2042, 2043, 2044, 2045, 2046, 2047, 2048, 2049, 2050, 2051, 2052, 2053, 2054, 2055, 2056, 2057, 2058, 2059, 2060, 2061, 2062, 2063, 2064, 2065, 2066, 2067, 2068, 2069, 2070, 2071, 2072, 2073, 2074, 2075, 2076, 2077, 2078, 2079, 2080, 2081, 2082, 2083, 2084, 2085, 2086, 2087, 2088, 2089, 2090, 2091, 2092, 2093, 2094, 2095, 2096, 2097, 2098, 2099, 2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107, 2108, 2109, 2110, 2111, 2112, 2113, 2114, 2115, 2116, 2117, 2118, 2119, 2120, 2121, 2122, 2123, 2124, 2125, 2126, 2127, 2128, 2129, 2130, 2131, 2132, 2133, 2134, 2135, 2136, 2137, 2138, 2139, 2140, 2141, 2142, 2143, 2144, 2145, 2146, 2147, 2148, 2149, 2150, 2151, 2152, 2153, 2154, 2155, 2156, 2157, 2158, 2159, 2160, 2161, 2162, 2163, 2164, 2165, 2166, 2167, 2168, 2169, 2170, 2171, 2172, 2173, 2174, 2175, 2176, 2177, 2178, 2179, 2180, 2181, 2182, 2183, 2184, 2185, 2186, 2187, 2188, 2189, 2190, 2191, 2192, 2193, 2194, 2195, 2196, 2197, 2198, 2199, 2200, 2201, 2202, 2203, 2204, 2205, 2206, 2207, 2208, 2209, 2210, 2211, 2212, 2213, 2214, 2215, 2216, 2217, 2218, 2219, 2220, 2221, 2222, 2223, 2224, 2225, 2226, 2227, 2228, 2229, 2230, 2231, 2232, 2233, 2234, 2235, 2236, 2237, 2238, 2239, 2240, 2241, 2242, 2243, 2244, 2245, 2246, 2247, 2248, 2249, 2250, 2251, 2252, 2253, 2254, 2255, 2256, 2257, 2258, 2259, 2260, 2261, 2262, 2263, 2264, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2272, 2273, 2274, 2275, 2276, 2277, 2278, 2279, 2280, 2281, 2282, 2283, 2284, 2285, 2286, 2287, 2288, 2289, 2290, 2291, 2292, 2293, 2294, 2295, 2296, 2297, 2298, 2299, 2300, 2301, 2302, 2303, 2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2319, 2320, 2321, 2322, 2323, 2324, 2325, 2326, 2327, 2328, 2329, 2330, 2331, 2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341, 2342, 2343, 2344, 2345, 2346, 2347, 2348, 2349, 2350, 2351, 2352, 2353, 2354, 2355, 2356, 2357, 2358, 2359, 2360, 2361, 2362, 2363, 2364, 2365, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2384, 2385, 2386, 2387, 2388, 2389, 2390, 2391, 2392, 2393, 2394, 2395, 2396, 2397, 2398, 2399, 2400, 2401, 2402, 2403, 2404, 2405, 2406, 2407, 2408, 2409, 2410, 2411, 2412, 2413, 2414, 2415, 2416, 2417, 2418, 2419, 2420, 2421, 2422, 2423, 2424, 2425, 2426, 2427, 2428, 2429, 2430, 2431, 2432, 2433, 2434, 2435, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2443, 2444, 2445, 2446, 2447, 2448, 2449, 2450, 2451, 2452, 2453, 2454, 2455, 2456, 2457, 2458, 2459, 2460, 2461, 2462, 2463, 2464, 2465, 2466, 2467, 2468, 2469, 2470, 2471, 2472, 2473, 2474, 2475, 2476, 2477, 2478, 2479, 2480, 2481, 2482, 2483, 2484, 2485, 2486, 2487, 2488, 2489, 2490, 2491, 2492, 2493, 2494, 2495, 2496, 2497, 2498, 2499, 2500, 2501, 2502, 2503, 2504, 2505, 2506, 2507, 2508, 2509, 2510, 2511, 2512, 2513, 2514, 2515, 2516, 2517, 2518, 2519, 2520, 2521, 2522, 2523, 2524, 2525, 2526, 2527, 2528, 2529, 2530, 2531, 2532, 2533, 2534, 2535, 2536, 2537, 2538, 2539, 2540, 2541, 2542, 2543, 2544, 2545, 2546, 2547, 2548, 2549, 2550, 2551, 2552, 2553, 2554, 2555, 2556, 2557, 2558, 2559, 2560, 2561, 2562, 2563, 2564, 2565, 2566, 2567, 2568, 2569, 2570, 2571, 2572, 2573, 2574, 2575, 2576, 2577, 2578, 2579, 2580, 2581, 2582, 2583, 2584, 2585, 2586, 2587, 2588, 2589, 2590, 2591, 2592, 2593, 2594, 2595, 2596, 2597, 2598, 2599, 2600, 2601, 2602, 2603, 2604, 2605, 2606, 2607, 2608, 2609, 2610, 2611, 2612, 2613, 2614, 2615, 2616, 2617, 2618, 2619, 2620, 2621, 2622, 2623, 2624, 2625, 2626, 2627, 2628, 2629, 2630, 2631, 2632, 2633, 2634, 2635, 2636, 2637, 2638, 2639, 2640, 2641, 2642, 2643, 2644, 2645, 2646, 2647, 2648, 2649, 2650, 2651, 2652, 2653, 2654, 2655, 2656, 2657, 2658, 2659, 2660, 2661, 2662, 2663, 2664, 2665, 2666, 2667, 2668, 2669, 2670, 2671, 2672, 2673, 2674, 2675, 2676, 2677, 2678, 2679, 2680, 2681, 2682, 2683, 2684, 2685, 2686, 2687, 2688, 2689, 2690, 2691, 2692, 2693, 2694, 2695, 2696, 2697, 2698, 2699, 2700, 2701, 2702, 2703, 2704, 2705, 2706, 2707, 2708, 2709, 2710, 2711, 2712, 2713, 2714, 2715, 2716, 2717, 2718, 2719, 2720, 2721, 2722, 2723, 2724, 2725, 2726, 2727, 2728, 2729, 2730, 2731, 2732, 2733, 2734, 2735, 2736, 2737, 2738, 2739, 2740, 2741, 2742, 2743, 2744, 2745, 2746, 2747, 2748, 2749, 2750, 2751, 2752, 2753, 2754, 2755, 2756, 2757, 2758, 2759, 2760, 2761, 2762, 2763, 2764, 2765, 2766, 2767, 2768, 2769, 2770, 2771, 2772, 2773, 2774, 2775, 2776, 2777, 2778, 2779, 2780, 2781, 2782, 2783, 2784, 2785, 2786, 2787, 2788, 2789, 2790, 2791, 2792, 2793, 2794, 2795, 2796, 2797, 2798, 2799, 2800, 2801, 2802, 2803, 2804, 2805, 2806, 2807, 2808, 2809, 2810, 2811, 2812, 2813, 2814, 2815, 2816, 2817, 2818, 2819, 2820, 2821, 2822, 2823, 2824, 2825, 2826, 2827, 2828, 2829, 2830, 2831, 2832, 2833, 2834, 2835, 2836, 2837, 2838, 2839, 2840, 2841, 2842, 2843, 2844, 2845, 2846, 2847, 2848, 2849, 2850, 2851, 2852, 2853, 2854, 2855, 2856, 2857, 2858, 2859, 2860, 2861, 2862, 2863, 2864, 2865, 2866, 2867, 2868, 2869, 2870, 2871, 2872, 2873, 2874, 2875, 2876, 2877, 2878, 2879, 2880, 2881, 2882, 2883, 2884, 2885, 2886, 2887, 2888, 2889, 2890, 2891, 2892, 2893, 2894, 2895, 2896, 2897, 2898, 2899, 2900, 2901, 2902, 2903, 2904, 2905, 2906, 2907, 2908, 2909, 2910, 2911, 2912, 2913, 2914, 2915, 2916, 2917, 2918, 2919, 2920, 2921, 2922, 2923, 2924, 2925, 2926, 2927, 2928, 2929, 2930, 2931, 2932, 2933, 2934, 2935, 2936, 2937, 2938, 2939, 2940, 2941, 2942, 2943, 2944, 2945, 2946, 2947, 2948, 2949, 2950, 2951, 2952, 2953, 2954, 2955, 2956, 2957, 2958, 2959, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2969, 2970, 2971, 2972, 2973, 2974, 2975, 2976, 2977, 2978, 2979, 2980, 2981, 2982, 2983, 2984, 2985, 2986, 2987, 2988, 2989, 2990, 2991, 2992, 2993, 2994, 2995, 2996, 2997, 2998, 2999, 3000, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 3009, 3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019, 3020, 3021, 3022, 3023, 3024, 3025, 3026, 3027, 3028, 3029, 3030, 3031, 3032, 3033, 3034, 3035, 3036, 3037, 3038, 3039, 3040, 3041, 3042, 3043, 3044, 3045, 3046, 3047, 3048, 3049, 3050, 3051, 3052, 3053, 3054, 3055, 3056, 3057, 3058, 3059, 3060, 3061, 3062, 3063, 3064, 3065, 3066, 3067, 3068, 3069, 3070, 3071, 3072, 3073, 3074, 3075, 3076, 3077, 3078, 3079, 3080, 3081, 3082, 3083, 3084, 3085, 3086, 3087, 3088, 3089, 3090, 3091, 3092, 3093, 3094, 3095, 3096, 3097, 3098, 3099, 3100, 3101, 3102, 3103, 3104, 3105, 3106, 3107, 3108, 3109, 3110, 3111, 3112, 3113, 3114, 3115, 3116, 3117, 3118, 3119, 3120, 3121, 3122, 3123, 3124, 3125, 3126, 3127, 3128, 3129, 3130, 3131, 3132, 3133, 3134, 3135, 3136, 3137, 3138, 3139, 3140, 3141, 3142, 3143, 3144, 3145, 3146, 3147, 3148, 3149, 3150, 3151, 3152, 3153, 3154, 3155, 3156, 3157, 3158, 3159, 3160, 3161, 3162, 3163, 3164, 3165, 3166, 3167, 3168, 3169, 3170, 3171, 3172, 3173, 3174, 3175, 3176, 3177, 3178, 3179, 3180, 3181, 3182, 3183, 3184, 3185, 3186, 3187, 3188, 3189, 3190, 3191, 3192, 3193, 3194, 3195, 3196, 3197, 3198, 3199, 3200, 3201, 3202, 3203, 3204, 3205, 3206, 3207, 3208, 3209, 3210, 3211, 3212, 3213, 3214, 3215, 3216, 3217, 3218, 3219, 3220, 3221, 3222, 3223, 3224, 3225, 3226, 3227, 3228, 3229, 3230, 3231, 3232, 3233, 3234, 3235, 3236, 3237, 3238, 3239, 3240, 3241, 3242, 3243, 3244, 3245, 3246, 3247, 3248, 3249, 3250, 3251, 3252, 3253, 3254, 3255, 3256, 3257, 3258, 3259, 3260, 3261, 3262, 3263, 3264, 3265, 3266, 3267, 3268, 3269, 3270, 3271, 3272, 3273, 3274, 3275, 3276, 3277, 3278, 3279, 3280, 3281, 3282, 3283, 3284, 3285, 3286, 3287, 3288, 3289, 3290, 3291, 3292, 3293, 3294, 3295, 3296, 3297, 3298, 3299, 3300, 3301, 3302, 3303, 3304, 3305, 3306, 3307, 3308, 3309, 3310, 3311, 3312, 3313, 3314, 3315, 3316, 3317, 3318, 3319, 3320, 3321, 3322, 3323, 3324, 3325, 3326, 3327, 3328, 3329, 3330, 3331, 3332, 3333, 3334, 3335, 3336, 3337, 3338, 3339, 3340, 3341, 3342, 3343, 3344, 3345, 3346, 3347, 3348, 3349, 3350, 3351, 3352, 3353, 3354, 3355, 3356, 3357, 3358, 3359, 3360, 3361, 3362, 3363, 3364, 3365, 3366, 3367, 3368, 3369, 3370, 3371, 3372, 3373, 3374, 3375, 3376, 3377, 3378, 3379, 3380, 3381, 3382, 3383, 3384, 3385, 3386, 3387, 3388, 3389, 3390, 3391, 3392, 3393, 3394, 3395, 3396, 3397, 3398, 3399, 3400, 3401, 3402, 3403, 3404, 3405, 3406, 3407, 3408, 3409, 3410, 3411, 3412, 3413, 3414, 3415, 3416, 3417, 3418, 3419, 3420, 3421, 3422, 3423, 3424, 3425, 3426, 3427, 3428, 3429, 3430, 3431, 3432, 3433, 3434, 3435, 3436, 3437, 3438, 3439, 3440, 3441, 3442, 3443, 3444, 3445, 3446, 3447, 3448, 3449, 3450, 3451, 3452, 3453, 3454, 3455, 3456, 3457, 3458, 3459, 3460, 3461, 3462, 3463, 3464, 3465, 3466, 3467, 3468, 3469, 3470, 3471, 3472, 3473, 3474, 3475, 3476, 3477, 3478, 3479, 3480, 3481, 3482, 3483, 3484, 3485, 3486, 3487, 3488, 3489, 3490, 3491, 3492, 3493, 3494, 3495, 3496, 3497, 3498, 3499, 3500, 3501, 3502, 3503, 3504, 3505, 3506, 3507, 3508, 3509, 3510, 3511, 3512, 3513, 3514, 3515, 3516, 3517, 3518, 3519, 3520, 3521, 3522, 3523, 3524, 3525, 3526, 3527, 3528, 3529, 3530, 3531, 3532, 3533, 3534, 3535, 3536, 3537, 3538, 3539, 3540, 3541, 3542, 3543, 3544, 3545, 3546, 3547, 3548, 3549, 3550, 3551, 3552, 3553, 3554, 3555, 3556, 3557, 3558, 3559, 3560, 3561, 3562, 3563, 3564, 3565, 3566, 3567, 3568, 3569, 3570, 3571, 3572, 3573, 3574, 3575, 3576, 3577, 3578, 3579, 3580, 3581, 3582, 3583, 3584, 3585, 3586, 3587, 3588, 3589, 3590, 3591, 3592, 3593, 3594, 3595, 3596, 3597, 3598, 3599, 3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609, 3610, 3611, 3612, 3613, 3614, 3615, 3616, 3617, 3618, 3619, 3620, 3621, 3622, 3623, 3624, 3625, 3626, 3627, 3628, 3629, 3630, 3631, 3632, 3633, 3634, 3635, 3636, 3637, 3638, 3639, 3640, 3641, 3642, 3643, 3644, 3645, 3646, 3647, 3648, 3649, 3650, 3651, 3652, 3653, 3654, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3662, 3663, 3664, 3665, 3666, 3667, 3668, 3669, 3670, 3671, 3672, 3673, 3674, 3675, 3676, 3677, 3678, 3679, 3680, 3681, 3682, 3683, 3684, 3685, 3686, 3687, 3688, 3689, 3690, 3691, 3692, 3693, 3694, 3695, 3696, 3697, 3698, 3699, 3700, 3701, 3702, 3703, 3704, 3705, 3706, 3707, 3708, 3709, 3710, 3711, 3712, 3713, 3714, 3715, 3716, 3717, 3718, 3719, 3720, 3721, 3722, 3723, 3724, 3725, 3726, 3727, 3728, 3729, 3730, 3731, 3732, 3733, 3734, 3735, 3736, 3737, 3738, 3739, 3740, 3741, 3742, 3743, 3744, 3745, 3746, 3747, 3748, 3749, 3750, 3751, 3752, 3753, 3754, 3755, 3756, 3757, 3758, 3759, 3760, 3761, 3762, 3763, 3764, 3765, 3766, 3767, 3768, 3769, 3770, 3771, 3772, 3773, 3774, 3775, 3776, 3777, 3778, 3779, 3780, 3781, 3782, 3783, 3784, 3785, 3786, 3787, 3788, 3789, 3790, 3791, 3792, 3793, 3794, 3795, 3796, 3797, 3798, 3799, 3800, 3801, 3802, 3803, 3804, 3805, 3806, 3807, 3808, 3809, 3810, 3811, 3812, 3813, 3814, 3815, 3816, 3817, 3818, 3819, 3820, 3821, 3822, 3823, 3824, 3825, 3826, 3827, 3828, 3829, 3830, 3831, 3832, 3833, 3834, 3835, 3836, 3837, 3838, 3839, 3840, 3841, 3842, 3843, 3844, 3845, 3846, 3847, 3848, 3849, 3850, 3851, 3852, 3853, 3854, 3855, 3856, 3857, 3858, 3859, 3860, 3861, 3862, 3863, 3864, 3865, 3866, 3867, 3868, 3869, 3870, 3871, 3872, 3873, 3874, 3875, 3876, 3877, 3878, 3879, 3880, 3881, 3882, 3883, 3884, 3885, 3886, 3887, 3888, 3889, 3890, 3891, 3892, 3893, 3894, 3895, 3896, 3897, 3898, 3899, 3900, 3901, 3902, 3903, 3904, 3905, 3906, 3907, 3908, 3909, 3910, 3911, 3912, 3913, 3914, 3915, 3916, 3917, 3918, 3919, 3920, 3921, 3922, 3923, 3924, 3925, 3926, 3927, 3928, 3929, 3930, 3931, 3932, 3933, 3934, 3935, 3936, 3937, 3938, 3939, 3940, 3941, 3942, 3943, 3944, 3945, 3946, 3947, 3948, 3949, 3950, 3951, 3952, 3953, 3954, 3955, 3956, 3957, 3958, 3959, 3960, 3961, 3962, 3963, 3964, 3965, 3966, 3967, 3968, 3969, 3970, 3971, 3972, 3973, 3974, 3975, 3976, 3977, 3978, 3979, 3980, 3981, 3982, 3983, 3984, 3985, 3986, 3987, 3988, 3989, 3990, 3991, 3992, 3993, 3994, 3995, 3996, 3997, 3998, 3999, 4000, 4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008, 4009, 4010, 4011, 4012, 4013, 4014, 4015, 4016, 4017, 4018, 4019, 4020, 4021, 4022, 4023, 4024, 4025, 4026, 4027, 4028, 4029, 4030, 4031, 4032, 4033, 4034, 4035, 4036, 4037, 4038, 4039, 4040, 4041, 4042, 4043, 4044, 4045, 4046, 4047, 4048, 4049, 4050, 4051, 4052, 4053, 4054, 4055, 4056, 4057, 4058, 4059, 4060, 4061, 4062, 4063, 4064, 4065, 4066, 4067, 4068, 4069, 4070, 4071, 4072, 4073, 4074, 4075, 4076, 4077, 4078, 4079, 4080, 4081, 4082, 4083, 4084, 4085, 4086, 4087, 4088, 4089, 4090, 4091, 4092, 4093, 4094, 4095, 4096, 4097, 4098, 4099, 4100, 4101, 4102, 4103, 4104, 4105, 4106, 4107, 4108, 4109, 4110, 4111, 4112, 4113, 4114, 4115, 4116, 4117, 4118, 4119, 4120, 4121, 4122, 4123, 4124, 4125, 4126, 4127, 4128, 4129, 4130, 4131, 4132, 4133, 4134, 4135, 4136, 4137, 4138, 4139, 4140, 4141, 4142, 4143, 4144, 4145, 4146, 4147, 4148, 4149, 4150, 4151, 4152, 4153, 4154, 4155, 4156, 4157, 4158, 4159, 4160, 4161, 4162, 4163, 4164, 4165, 4166, 4167, 4168, 4169, 4170, 4171, 4172, 4173, 4174, 4175, 4176, 4177, 4178, 4179, 4180, 4181, 4182, 4183, 4184, 4185, 4186, 4187, 4188, 4189, 4190, 4191, 4192, 4193, 4194, 4195, 4196, 4197, 4198, 4199, 4200, 4201, 4202, 4203, 4204, 4205, 4206, 4207, 4208, 4209, 4210, 4211, 4212, 4213, 4214, 4215, 4216, 4217, 4218, 4219, 4220, 4221, 4222, 4223, 4224, 4225, 4226, 4227, 4228, 4229, 4230, 4231, 4232, 4233, 4234, 4235, 4236, 4237, 4238, 4239, 4240, 4241, 4242, 4243, 4244, 4245, 4246, 4247, 4248, 4249, 4250, 4251, 4252, 4253, 4254, 4255, 4256, 4257, 4258, 4259, 4260, 4261, 4262, 4263, 4264, 4265, 4266, 4267, 4268, 4269, 4270, 4271, 4272, 4273, 4274, 4275, 4276, 4277, 4278, 4279, 4280, 4281, 4282, 4283, 4284, 4285, 4286, 4287, 4288, 4289, 4290, 4291, 4292, 4293, 4294, 4295, 4296, 4297, 4298, 4299, 4300, 4301, 4302, 4303, 4304, 4305, 4306, 4307, 4308, 4309, 4310, 4311, 4312, 4313, 4314, 4315, 4316, 4317, 4318, 4319, 4320, 4321, 4322, 4323, 4324, 4325, 4326, 4327, 4328, 4329, 4330, 4331, 4332, 4333, 4334, 4335, 4336, 4337, 4338, 4339, 4340, 4341, 4342, 4343, 4344, 4345, 4346, 4347, 4348, 4349, 4350, 4351, 4352, 4353, 4354, 4355, 4356, 4357, 4358, 4359, 4360, 4361, 4362, 4363, 4364, 4365, 4366, 4367, 4368, 4369, 4370, 4371, 4372, 4373, 4374, 4375, 4376, 4377, 4378, 4379, 4380, 4381, 4382, 4383, 4384, 4385, 4386, 4387, 4388, 4389, 4390, 4391, 4392, 4393, 4394, 4395, 4396, 4397, 4398, 4399, 4400, 4401, 4402, 4403, 4404, 4405, 4406, 4407, 4408, 4409, 4410, 4411, 4412, 4413, 4414, 4415, 4416, 4417, 4418, 4419, 4420, 4421, 4422, 4423, 4424, 4425, 4426, 4427, 4428, 4429, 4430, 4431, 4432, 4433, 4434, 4435, 4436, 4437, 4438, 4439, 4440, 4441, 4442, 4443, 4444, 4445, 4446, 4447, 4448, 4449, 4450, 4451, 4452, 4453, 4454, 4455, 4456, 4457, 4458, 4459, 4460, 4461, 4462, 4463, 4464, 4465, 4466, 4467, 4468, 4469, 4470, 4471, 4472, 4473, 4474, 4475, 4476, 4477, 4478, 4479, 4480, 4481, 4482, 4483, 4484, 4485, 4486, 4487, 4488, 4489, 4490, 4491, 4492, 4493, 4494, 4495, 4496, 4497, 4498, 4499, -500, -499, -498, -497, -496, -495, -494, -493, -492, -491, -490, -489, -488, -487, -486, -485, -484, -483, -482, -481, -480, -479, -478, -477, -476, -475, -474, -473, -472, -471, -470, -469, -468, -467, -466, -465, -464, -463, -462, -461, -460, -459, -458, -457, -456, -455, -454, -453, -452, -451, -450, -449, -448, -447, -446, -445, -444, -443, -442, -441, -440, -439, -438, -437, -436, -435, -434, -433, -432, -431, -430, -429, -428, -427, -426, -425, -424, -423, -422, -421, -420, -419, -418, -417, -416, -415, -414, -413, -412, -411, -410, -409, -408, -407, -406, -405, -404, -403, -402, -401, -400, -399, -398, -397, -396, -395, -394, -393, -392, -391, -390, -389, -388, -387, -386, -385, -384, -383, -382, -381, -380, -379, -378, -377, -376, -375, -374, -373, -372, -371, -370, -369, -368, -367, -366, -365, -364, -363, -362, -361, -360, -359, -358, -357, -356, -355, -354, -353, -352, -351, -350, -349, -348, -347, -346, -345, -344, -343, -342, -341, -340, -339, -338, -337, -336, -335, -334, -333, -332, -331, -330, -329, -328, -327, -326, -325, -324, -323, -322, -321, -320, -319, -318, -317, -316, -315, -314, -313, -312, -311, -310, -309, -308, -307, -306, -305, -304, -303, -302, -301, -300, -299, -298, -297, -296, -295, -294, -293, -292, -291, -290, -289, -288, -287, -286, -285, -284, -283, -282, -281, -280, -279, -278, -277, -276, -275, -274, -273, -272, -271, -270, -269, -268, -267, -266, -265, -264, -263, -262, -261, -260, -259, -258, -257, -256, -255, -254, -253, -252, -251, -250, -249, -248, -247, -246, -245, -244, -243, -242, -241, -240, -239, -238, -237, -236, -235, -234, -233, -232, -231, -230, -229, -228, -227, -226, -225, -224, -223, -222, -221, -220, -219, -218, -217, -216, -215, -214, -213, -212, -211, -210, -209, -208, -207, -206, -205, -204, -203, -202, -201, -200, -199, -198, -197, -196, -195, -194, -193, -192, -191, -190, -189, -188, -187, -186, -185, -184, -183, -182, -181, -180, -179, -178, -177, -176, -175, -174, -173, -172, -171, -170, -169, -168, -167, -166, -165, -164, -163, -162, -161, -160, -159]\n0\n```\nand also this one\n```\n[1,2,1,2,1,2,1,2,1,2]\n-1\n```"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, we need to find out cycle means cycle detection.\\nLet\\'s say Two people are running on a circle then definately they meet at any point. If they meet means cycle present. \\n\\n# Approach\\nSo, Here I will use Fast and Slow pointer (Two pointer approach).\\n1- Initialize two pointer slow and fast.\\n2- Initially both are pointing to head.\\n3- When loop run slow pointer move step ahead while fast pointer move it\\'s double.\\n4- If both pointer meet at a particular point it means cycle present other no."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Forget the garbage task.\\n\\nRead the real one:\\nRetuen `True` for neighboring Nodes with equal values, otherwise `False`"
                    },
                    {
                        "username": "arshita129",
                        "content": "neighboring nodes with equal values?? We are not trying to see if neighboring nodes have equal values.\\n"
                    }
                ]
            },
            {
                "id": 2043653,
                "content": [
                    {
                        "username": "julkar9",
                        "content": "I hate this kind of questions, its either you know the solution or don\\'t. There\\'s no in-between."
                    },
                    {
                        "username": "psionl0",
                        "content": "The fast and slow pointer technique is useful in a variety of linked list situations. It is worth while learning about it."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "I\\'m not going to read the whole question just for \"Find cycle\""
                    },
                    {
                        "username": "katalma",
                        "content": "Beginning of the week, beginning of the month. I can believe I am smart. But in the end..."
                    },
                    {
                        "username": "sakibmondal7",
                        "content": "Just check the solution with minimum space under Python language.. They did some strange things.. \n\nThey edited the user response in backend with pos variable. I guess that is why `POS` is given.\n\nThis is cheatings at next level.. "
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "## there is no use of pos here ##\\n`\\nhead = [3,2,0,-4], pos = 3\\n`\\nWill pass the test case since refreance of last node is to pos 1 node"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Okay, so we all know the constant memory solution - but is there a different approach (that uses more than constant space) that also takes linear time? Best I can think of is quadratic."
                    },
                    {
                        "username": "aitachii",
                        "content": "Hash table/dictionary of ListNodes take up O(n) space. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Is LeetCode softening us up?"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Check out this testcase\n```\n[-158, -157, -156, -155, -154, -153, -152, -151, -150, -149, -148, -147, -146, -145, -144, -143, -142, -141, -140, -139, -138, -137, -136, -135, -134, -133, -132, -131, -130, -129, -128, -127, -126, -125, -124, -123, -122, -121, -120, -119, -118, -117, -116, -115, -114, -113, -112, -111, -110, -109, -108, -107, -106, -105, -104, -103, -102, -101, -100, -99, -98, -97, -96, -95, -94, -93, -92, -91, -90, -89, -88, -87, -86, -85, -84, -83, -82, -81, -80, -79, -78, -77, -76, -75, -74, -73, -72, -71, -70, -69, -68, -67, -66, -65, -64, -63, -62, -61, -60, -59, -58, -57, -56, -55, -54, -53, -52, -51, -50, -49, -48, -47, -46, -45, -44, -43, -42, -41, -40, -39, -38, -37, -36, -35, -34, -33, -32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1633, 1634, 1635, 1636, 1637, 1638, 1639, 1640, 1641, 1642, 1643, 1644, 1645, 1646, 1647, 1648, 1649, 1650, 1651, 1652, 1653, 1654, 1655, 1656, 1657, 1658, 1659, 1660, 1661, 1662, 1663, 1664, 1665, 1666, 1667, 1668, 1669, 1670, 1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684, 1685, 1686, 1687, 1688, 1689, 1690, 1691, 1692, 1693, 1694, 1695, 1696, 1697, 1698, 1699, 1700, 1701, 1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709, 1710, 1711, 1712, 1713, 1714, 1715, 1716, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1724, 1725, 1726, 1727, 1728, 1729, 1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738, 1739, 1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749, 1750, 1751, 1752, 1753, 1754, 1755, 1756, 1757, 1758, 1759, 1760, 1761, 1762, 1763, 1764, 1765, 1766, 1767, 1768, 1769, 1770, 1771, 1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1780, 1781, 1782, 1783, 1784, 1785, 1786, 1787, 1788, 1789, 1790, 1791, 1792, 1793, 1794, 1795, 1796, 1797, 1798, 1799, 1800, 1801, 1802, 1803, 1804, 1805, 1806, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 1815, 1816, 1817, 1818, 1819, 1820, 1821, 1822, 1823, 1824, 1825, 1826, 1827, 1828, 1829, 1830, 1831, 1832, 1833, 1834, 1835, 1836, 1837, 1838, 1839, 1840, 1841, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849, 1850, 1851, 1852, 1853, 1854, 1855, 1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879, 1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 2039, 2040, 2041, 2042, 2043, 2044, 2045, 2046, 2047, 2048, 2049, 2050, 2051, 2052, 2053, 2054, 2055, 2056, 2057, 2058, 2059, 2060, 2061, 2062, 2063, 2064, 2065, 2066, 2067, 2068, 2069, 2070, 2071, 2072, 2073, 2074, 2075, 2076, 2077, 2078, 2079, 2080, 2081, 2082, 2083, 2084, 2085, 2086, 2087, 2088, 2089, 2090, 2091, 2092, 2093, 2094, 2095, 2096, 2097, 2098, 2099, 2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107, 2108, 2109, 2110, 2111, 2112, 2113, 2114, 2115, 2116, 2117, 2118, 2119, 2120, 2121, 2122, 2123, 2124, 2125, 2126, 2127, 2128, 2129, 2130, 2131, 2132, 2133, 2134, 2135, 2136, 2137, 2138, 2139, 2140, 2141, 2142, 2143, 2144, 2145, 2146, 2147, 2148, 2149, 2150, 2151, 2152, 2153, 2154, 2155, 2156, 2157, 2158, 2159, 2160, 2161, 2162, 2163, 2164, 2165, 2166, 2167, 2168, 2169, 2170, 2171, 2172, 2173, 2174, 2175, 2176, 2177, 2178, 2179, 2180, 2181, 2182, 2183, 2184, 2185, 2186, 2187, 2188, 2189, 2190, 2191, 2192, 2193, 2194, 2195, 2196, 2197, 2198, 2199, 2200, 2201, 2202, 2203, 2204, 2205, 2206, 2207, 2208, 2209, 2210, 2211, 2212, 2213, 2214, 2215, 2216, 2217, 2218, 2219, 2220, 2221, 2222, 2223, 2224, 2225, 2226, 2227, 2228, 2229, 2230, 2231, 2232, 2233, 2234, 2235, 2236, 2237, 2238, 2239, 2240, 2241, 2242, 2243, 2244, 2245, 2246, 2247, 2248, 2249, 2250, 2251, 2252, 2253, 2254, 2255, 2256, 2257, 2258, 2259, 2260, 2261, 2262, 2263, 2264, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2272, 2273, 2274, 2275, 2276, 2277, 2278, 2279, 2280, 2281, 2282, 2283, 2284, 2285, 2286, 2287, 2288, 2289, 2290, 2291, 2292, 2293, 2294, 2295, 2296, 2297, 2298, 2299, 2300, 2301, 2302, 2303, 2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2319, 2320, 2321, 2322, 2323, 2324, 2325, 2326, 2327, 2328, 2329, 2330, 2331, 2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341, 2342, 2343, 2344, 2345, 2346, 2347, 2348, 2349, 2350, 2351, 2352, 2353, 2354, 2355, 2356, 2357, 2358, 2359, 2360, 2361, 2362, 2363, 2364, 2365, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2384, 2385, 2386, 2387, 2388, 2389, 2390, 2391, 2392, 2393, 2394, 2395, 2396, 2397, 2398, 2399, 2400, 2401, 2402, 2403, 2404, 2405, 2406, 2407, 2408, 2409, 2410, 2411, 2412, 2413, 2414, 2415, 2416, 2417, 2418, 2419, 2420, 2421, 2422, 2423, 2424, 2425, 2426, 2427, 2428, 2429, 2430, 2431, 2432, 2433, 2434, 2435, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2443, 2444, 2445, 2446, 2447, 2448, 2449, 2450, 2451, 2452, 2453, 2454, 2455, 2456, 2457, 2458, 2459, 2460, 2461, 2462, 2463, 2464, 2465, 2466, 2467, 2468, 2469, 2470, 2471, 2472, 2473, 2474, 2475, 2476, 2477, 2478, 2479, 2480, 2481, 2482, 2483, 2484, 2485, 2486, 2487, 2488, 2489, 2490, 2491, 2492, 2493, 2494, 2495, 2496, 2497, 2498, 2499, 2500, 2501, 2502, 2503, 2504, 2505, 2506, 2507, 2508, 2509, 2510, 2511, 2512, 2513, 2514, 2515, 2516, 2517, 2518, 2519, 2520, 2521, 2522, 2523, 2524, 2525, 2526, 2527, 2528, 2529, 2530, 2531, 2532, 2533, 2534, 2535, 2536, 2537, 2538, 2539, 2540, 2541, 2542, 2543, 2544, 2545, 2546, 2547, 2548, 2549, 2550, 2551, 2552, 2553, 2554, 2555, 2556, 2557, 2558, 2559, 2560, 2561, 2562, 2563, 2564, 2565, 2566, 2567, 2568, 2569, 2570, 2571, 2572, 2573, 2574, 2575, 2576, 2577, 2578, 2579, 2580, 2581, 2582, 2583, 2584, 2585, 2586, 2587, 2588, 2589, 2590, 2591, 2592, 2593, 2594, 2595, 2596, 2597, 2598, 2599, 2600, 2601, 2602, 2603, 2604, 2605, 2606, 2607, 2608, 2609, 2610, 2611, 2612, 2613, 2614, 2615, 2616, 2617, 2618, 2619, 2620, 2621, 2622, 2623, 2624, 2625, 2626, 2627, 2628, 2629, 2630, 2631, 2632, 2633, 2634, 2635, 2636, 2637, 2638, 2639, 2640, 2641, 2642, 2643, 2644, 2645, 2646, 2647, 2648, 2649, 2650, 2651, 2652, 2653, 2654, 2655, 2656, 2657, 2658, 2659, 2660, 2661, 2662, 2663, 2664, 2665, 2666, 2667, 2668, 2669, 2670, 2671, 2672, 2673, 2674, 2675, 2676, 2677, 2678, 2679, 2680, 2681, 2682, 2683, 2684, 2685, 2686, 2687, 2688, 2689, 2690, 2691, 2692, 2693, 2694, 2695, 2696, 2697, 2698, 2699, 2700, 2701, 2702, 2703, 2704, 2705, 2706, 2707, 2708, 2709, 2710, 2711, 2712, 2713, 2714, 2715, 2716, 2717, 2718, 2719, 2720, 2721, 2722, 2723, 2724, 2725, 2726, 2727, 2728, 2729, 2730, 2731, 2732, 2733, 2734, 2735, 2736, 2737, 2738, 2739, 2740, 2741, 2742, 2743, 2744, 2745, 2746, 2747, 2748, 2749, 2750, 2751, 2752, 2753, 2754, 2755, 2756, 2757, 2758, 2759, 2760, 2761, 2762, 2763, 2764, 2765, 2766, 2767, 2768, 2769, 2770, 2771, 2772, 2773, 2774, 2775, 2776, 2777, 2778, 2779, 2780, 2781, 2782, 2783, 2784, 2785, 2786, 2787, 2788, 2789, 2790, 2791, 2792, 2793, 2794, 2795, 2796, 2797, 2798, 2799, 2800, 2801, 2802, 2803, 2804, 2805, 2806, 2807, 2808, 2809, 2810, 2811, 2812, 2813, 2814, 2815, 2816, 2817, 2818, 2819, 2820, 2821, 2822, 2823, 2824, 2825, 2826, 2827, 2828, 2829, 2830, 2831, 2832, 2833, 2834, 2835, 2836, 2837, 2838, 2839, 2840, 2841, 2842, 2843, 2844, 2845, 2846, 2847, 2848, 2849, 2850, 2851, 2852, 2853, 2854, 2855, 2856, 2857, 2858, 2859, 2860, 2861, 2862, 2863, 2864, 2865, 2866, 2867, 2868, 2869, 2870, 2871, 2872, 2873, 2874, 2875, 2876, 2877, 2878, 2879, 2880, 2881, 2882, 2883, 2884, 2885, 2886, 2887, 2888, 2889, 2890, 2891, 2892, 2893, 2894, 2895, 2896, 2897, 2898, 2899, 2900, 2901, 2902, 2903, 2904, 2905, 2906, 2907, 2908, 2909, 2910, 2911, 2912, 2913, 2914, 2915, 2916, 2917, 2918, 2919, 2920, 2921, 2922, 2923, 2924, 2925, 2926, 2927, 2928, 2929, 2930, 2931, 2932, 2933, 2934, 2935, 2936, 2937, 2938, 2939, 2940, 2941, 2942, 2943, 2944, 2945, 2946, 2947, 2948, 2949, 2950, 2951, 2952, 2953, 2954, 2955, 2956, 2957, 2958, 2959, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2969, 2970, 2971, 2972, 2973, 2974, 2975, 2976, 2977, 2978, 2979, 2980, 2981, 2982, 2983, 2984, 2985, 2986, 2987, 2988, 2989, 2990, 2991, 2992, 2993, 2994, 2995, 2996, 2997, 2998, 2999, 3000, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 3009, 3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019, 3020, 3021, 3022, 3023, 3024, 3025, 3026, 3027, 3028, 3029, 3030, 3031, 3032, 3033, 3034, 3035, 3036, 3037, 3038, 3039, 3040, 3041, 3042, 3043, 3044, 3045, 3046, 3047, 3048, 3049, 3050, 3051, 3052, 3053, 3054, 3055, 3056, 3057, 3058, 3059, 3060, 3061, 3062, 3063, 3064, 3065, 3066, 3067, 3068, 3069, 3070, 3071, 3072, 3073, 3074, 3075, 3076, 3077, 3078, 3079, 3080, 3081, 3082, 3083, 3084, 3085, 3086, 3087, 3088, 3089, 3090, 3091, 3092, 3093, 3094, 3095, 3096, 3097, 3098, 3099, 3100, 3101, 3102, 3103, 3104, 3105, 3106, 3107, 3108, 3109, 3110, 3111, 3112, 3113, 3114, 3115, 3116, 3117, 3118, 3119, 3120, 3121, 3122, 3123, 3124, 3125, 3126, 3127, 3128, 3129, 3130, 3131, 3132, 3133, 3134, 3135, 3136, 3137, 3138, 3139, 3140, 3141, 3142, 3143, 3144, 3145, 3146, 3147, 3148, 3149, 3150, 3151, 3152, 3153, 3154, 3155, 3156, 3157, 3158, 3159, 3160, 3161, 3162, 3163, 3164, 3165, 3166, 3167, 3168, 3169, 3170, 3171, 3172, 3173, 3174, 3175, 3176, 3177, 3178, 3179, 3180, 3181, 3182, 3183, 3184, 3185, 3186, 3187, 3188, 3189, 3190, 3191, 3192, 3193, 3194, 3195, 3196, 3197, 3198, 3199, 3200, 3201, 3202, 3203, 3204, 3205, 3206, 3207, 3208, 3209, 3210, 3211, 3212, 3213, 3214, 3215, 3216, 3217, 3218, 3219, 3220, 3221, 3222, 3223, 3224, 3225, 3226, 3227, 3228, 3229, 3230, 3231, 3232, 3233, 3234, 3235, 3236, 3237, 3238, 3239, 3240, 3241, 3242, 3243, 3244, 3245, 3246, 3247, 3248, 3249, 3250, 3251, 3252, 3253, 3254, 3255, 3256, 3257, 3258, 3259, 3260, 3261, 3262, 3263, 3264, 3265, 3266, 3267, 3268, 3269, 3270, 3271, 3272, 3273, 3274, 3275, 3276, 3277, 3278, 3279, 3280, 3281, 3282, 3283, 3284, 3285, 3286, 3287, 3288, 3289, 3290, 3291, 3292, 3293, 3294, 3295, 3296, 3297, 3298, 3299, 3300, 3301, 3302, 3303, 3304, 3305, 3306, 3307, 3308, 3309, 3310, 3311, 3312, 3313, 3314, 3315, 3316, 3317, 3318, 3319, 3320, 3321, 3322, 3323, 3324, 3325, 3326, 3327, 3328, 3329, 3330, 3331, 3332, 3333, 3334, 3335, 3336, 3337, 3338, 3339, 3340, 3341, 3342, 3343, 3344, 3345, 3346, 3347, 3348, 3349, 3350, 3351, 3352, 3353, 3354, 3355, 3356, 3357, 3358, 3359, 3360, 3361, 3362, 3363, 3364, 3365, 3366, 3367, 3368, 3369, 3370, 3371, 3372, 3373, 3374, 3375, 3376, 3377, 3378, 3379, 3380, 3381, 3382, 3383, 3384, 3385, 3386, 3387, 3388, 3389, 3390, 3391, 3392, 3393, 3394, 3395, 3396, 3397, 3398, 3399, 3400, 3401, 3402, 3403, 3404, 3405, 3406, 3407, 3408, 3409, 3410, 3411, 3412, 3413, 3414, 3415, 3416, 3417, 3418, 3419, 3420, 3421, 3422, 3423, 3424, 3425, 3426, 3427, 3428, 3429, 3430, 3431, 3432, 3433, 3434, 3435, 3436, 3437, 3438, 3439, 3440, 3441, 3442, 3443, 3444, 3445, 3446, 3447, 3448, 3449, 3450, 3451, 3452, 3453, 3454, 3455, 3456, 3457, 3458, 3459, 3460, 3461, 3462, 3463, 3464, 3465, 3466, 3467, 3468, 3469, 3470, 3471, 3472, 3473, 3474, 3475, 3476, 3477, 3478, 3479, 3480, 3481, 3482, 3483, 3484, 3485, 3486, 3487, 3488, 3489, 3490, 3491, 3492, 3493, 3494, 3495, 3496, 3497, 3498, 3499, 3500, 3501, 3502, 3503, 3504, 3505, 3506, 3507, 3508, 3509, 3510, 3511, 3512, 3513, 3514, 3515, 3516, 3517, 3518, 3519, 3520, 3521, 3522, 3523, 3524, 3525, 3526, 3527, 3528, 3529, 3530, 3531, 3532, 3533, 3534, 3535, 3536, 3537, 3538, 3539, 3540, 3541, 3542, 3543, 3544, 3545, 3546, 3547, 3548, 3549, 3550, 3551, 3552, 3553, 3554, 3555, 3556, 3557, 3558, 3559, 3560, 3561, 3562, 3563, 3564, 3565, 3566, 3567, 3568, 3569, 3570, 3571, 3572, 3573, 3574, 3575, 3576, 3577, 3578, 3579, 3580, 3581, 3582, 3583, 3584, 3585, 3586, 3587, 3588, 3589, 3590, 3591, 3592, 3593, 3594, 3595, 3596, 3597, 3598, 3599, 3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609, 3610, 3611, 3612, 3613, 3614, 3615, 3616, 3617, 3618, 3619, 3620, 3621, 3622, 3623, 3624, 3625, 3626, 3627, 3628, 3629, 3630, 3631, 3632, 3633, 3634, 3635, 3636, 3637, 3638, 3639, 3640, 3641, 3642, 3643, 3644, 3645, 3646, 3647, 3648, 3649, 3650, 3651, 3652, 3653, 3654, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3662, 3663, 3664, 3665, 3666, 3667, 3668, 3669, 3670, 3671, 3672, 3673, 3674, 3675, 3676, 3677, 3678, 3679, 3680, 3681, 3682, 3683, 3684, 3685, 3686, 3687, 3688, 3689, 3690, 3691, 3692, 3693, 3694, 3695, 3696, 3697, 3698, 3699, 3700, 3701, 3702, 3703, 3704, 3705, 3706, 3707, 3708, 3709, 3710, 3711, 3712, 3713, 3714, 3715, 3716, 3717, 3718, 3719, 3720, 3721, 3722, 3723, 3724, 3725, 3726, 3727, 3728, 3729, 3730, 3731, 3732, 3733, 3734, 3735, 3736, 3737, 3738, 3739, 3740, 3741, 3742, 3743, 3744, 3745, 3746, 3747, 3748, 3749, 3750, 3751, 3752, 3753, 3754, 3755, 3756, 3757, 3758, 3759, 3760, 3761, 3762, 3763, 3764, 3765, 3766, 3767, 3768, 3769, 3770, 3771, 3772, 3773, 3774, 3775, 3776, 3777, 3778, 3779, 3780, 3781, 3782, 3783, 3784, 3785, 3786, 3787, 3788, 3789, 3790, 3791, 3792, 3793, 3794, 3795, 3796, 3797, 3798, 3799, 3800, 3801, 3802, 3803, 3804, 3805, 3806, 3807, 3808, 3809, 3810, 3811, 3812, 3813, 3814, 3815, 3816, 3817, 3818, 3819, 3820, 3821, 3822, 3823, 3824, 3825, 3826, 3827, 3828, 3829, 3830, 3831, 3832, 3833, 3834, 3835, 3836, 3837, 3838, 3839, 3840, 3841, 3842, 3843, 3844, 3845, 3846, 3847, 3848, 3849, 3850, 3851, 3852, 3853, 3854, 3855, 3856, 3857, 3858, 3859, 3860, 3861, 3862, 3863, 3864, 3865, 3866, 3867, 3868, 3869, 3870, 3871, 3872, 3873, 3874, 3875, 3876, 3877, 3878, 3879, 3880, 3881, 3882, 3883, 3884, 3885, 3886, 3887, 3888, 3889, 3890, 3891, 3892, 3893, 3894, 3895, 3896, 3897, 3898, 3899, 3900, 3901, 3902, 3903, 3904, 3905, 3906, 3907, 3908, 3909, 3910, 3911, 3912, 3913, 3914, 3915, 3916, 3917, 3918, 3919, 3920, 3921, 3922, 3923, 3924, 3925, 3926, 3927, 3928, 3929, 3930, 3931, 3932, 3933, 3934, 3935, 3936, 3937, 3938, 3939, 3940, 3941, 3942, 3943, 3944, 3945, 3946, 3947, 3948, 3949, 3950, 3951, 3952, 3953, 3954, 3955, 3956, 3957, 3958, 3959, 3960, 3961, 3962, 3963, 3964, 3965, 3966, 3967, 3968, 3969, 3970, 3971, 3972, 3973, 3974, 3975, 3976, 3977, 3978, 3979, 3980, 3981, 3982, 3983, 3984, 3985, 3986, 3987, 3988, 3989, 3990, 3991, 3992, 3993, 3994, 3995, 3996, 3997, 3998, 3999, 4000, 4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008, 4009, 4010, 4011, 4012, 4013, 4014, 4015, 4016, 4017, 4018, 4019, 4020, 4021, 4022, 4023, 4024, 4025, 4026, 4027, 4028, 4029, 4030, 4031, 4032, 4033, 4034, 4035, 4036, 4037, 4038, 4039, 4040, 4041, 4042, 4043, 4044, 4045, 4046, 4047, 4048, 4049, 4050, 4051, 4052, 4053, 4054, 4055, 4056, 4057, 4058, 4059, 4060, 4061, 4062, 4063, 4064, 4065, 4066, 4067, 4068, 4069, 4070, 4071, 4072, 4073, 4074, 4075, 4076, 4077, 4078, 4079, 4080, 4081, 4082, 4083, 4084, 4085, 4086, 4087, 4088, 4089, 4090, 4091, 4092, 4093, 4094, 4095, 4096, 4097, 4098, 4099, 4100, 4101, 4102, 4103, 4104, 4105, 4106, 4107, 4108, 4109, 4110, 4111, 4112, 4113, 4114, 4115, 4116, 4117, 4118, 4119, 4120, 4121, 4122, 4123, 4124, 4125, 4126, 4127, 4128, 4129, 4130, 4131, 4132, 4133, 4134, 4135, 4136, 4137, 4138, 4139, 4140, 4141, 4142, 4143, 4144, 4145, 4146, 4147, 4148, 4149, 4150, 4151, 4152, 4153, 4154, 4155, 4156, 4157, 4158, 4159, 4160, 4161, 4162, 4163, 4164, 4165, 4166, 4167, 4168, 4169, 4170, 4171, 4172, 4173, 4174, 4175, 4176, 4177, 4178, 4179, 4180, 4181, 4182, 4183, 4184, 4185, 4186, 4187, 4188, 4189, 4190, 4191, 4192, 4193, 4194, 4195, 4196, 4197, 4198, 4199, 4200, 4201, 4202, 4203, 4204, 4205, 4206, 4207, 4208, 4209, 4210, 4211, 4212, 4213, 4214, 4215, 4216, 4217, 4218, 4219, 4220, 4221, 4222, 4223, 4224, 4225, 4226, 4227, 4228, 4229, 4230, 4231, 4232, 4233, 4234, 4235, 4236, 4237, 4238, 4239, 4240, 4241, 4242, 4243, 4244, 4245, 4246, 4247, 4248, 4249, 4250, 4251, 4252, 4253, 4254, 4255, 4256, 4257, 4258, 4259, 4260, 4261, 4262, 4263, 4264, 4265, 4266, 4267, 4268, 4269, 4270, 4271, 4272, 4273, 4274, 4275, 4276, 4277, 4278, 4279, 4280, 4281, 4282, 4283, 4284, 4285, 4286, 4287, 4288, 4289, 4290, 4291, 4292, 4293, 4294, 4295, 4296, 4297, 4298, 4299, 4300, 4301, 4302, 4303, 4304, 4305, 4306, 4307, 4308, 4309, 4310, 4311, 4312, 4313, 4314, 4315, 4316, 4317, 4318, 4319, 4320, 4321, 4322, 4323, 4324, 4325, 4326, 4327, 4328, 4329, 4330, 4331, 4332, 4333, 4334, 4335, 4336, 4337, 4338, 4339, 4340, 4341, 4342, 4343, 4344, 4345, 4346, 4347, 4348, 4349, 4350, 4351, 4352, 4353, 4354, 4355, 4356, 4357, 4358, 4359, 4360, 4361, 4362, 4363, 4364, 4365, 4366, 4367, 4368, 4369, 4370, 4371, 4372, 4373, 4374, 4375, 4376, 4377, 4378, 4379, 4380, 4381, 4382, 4383, 4384, 4385, 4386, 4387, 4388, 4389, 4390, 4391, 4392, 4393, 4394, 4395, 4396, 4397, 4398, 4399, 4400, 4401, 4402, 4403, 4404, 4405, 4406, 4407, 4408, 4409, 4410, 4411, 4412, 4413, 4414, 4415, 4416, 4417, 4418, 4419, 4420, 4421, 4422, 4423, 4424, 4425, 4426, 4427, 4428, 4429, 4430, 4431, 4432, 4433, 4434, 4435, 4436, 4437, 4438, 4439, 4440, 4441, 4442, 4443, 4444, 4445, 4446, 4447, 4448, 4449, 4450, 4451, 4452, 4453, 4454, 4455, 4456, 4457, 4458, 4459, 4460, 4461, 4462, 4463, 4464, 4465, 4466, 4467, 4468, 4469, 4470, 4471, 4472, 4473, 4474, 4475, 4476, 4477, 4478, 4479, 4480, 4481, 4482, 4483, 4484, 4485, 4486, 4487, 4488, 4489, 4490, 4491, 4492, 4493, 4494, 4495, 4496, 4497, 4498, 4499, -500, -499, -498, -497, -496, -495, -494, -493, -492, -491, -490, -489, -488, -487, -486, -485, -484, -483, -482, -481, -480, -479, -478, -477, -476, -475, -474, -473, -472, -471, -470, -469, -468, -467, -466, -465, -464, -463, -462, -461, -460, -459, -458, -457, -456, -455, -454, -453, -452, -451, -450, -449, -448, -447, -446, -445, -444, -443, -442, -441, -440, -439, -438, -437, -436, -435, -434, -433, -432, -431, -430, -429, -428, -427, -426, -425, -424, -423, -422, -421, -420, -419, -418, -417, -416, -415, -414, -413, -412, -411, -410, -409, -408, -407, -406, -405, -404, -403, -402, -401, -400, -399, -398, -397, -396, -395, -394, -393, -392, -391, -390, -389, -388, -387, -386, -385, -384, -383, -382, -381, -380, -379, -378, -377, -376, -375, -374, -373, -372, -371, -370, -369, -368, -367, -366, -365, -364, -363, -362, -361, -360, -359, -358, -357, -356, -355, -354, -353, -352, -351, -350, -349, -348, -347, -346, -345, -344, -343, -342, -341, -340, -339, -338, -337, -336, -335, -334, -333, -332, -331, -330, -329, -328, -327, -326, -325, -324, -323, -322, -321, -320, -319, -318, -317, -316, -315, -314, -313, -312, -311, -310, -309, -308, -307, -306, -305, -304, -303, -302, -301, -300, -299, -298, -297, -296, -295, -294, -293, -292, -291, -290, -289, -288, -287, -286, -285, -284, -283, -282, -281, -280, -279, -278, -277, -276, -275, -274, -273, -272, -271, -270, -269, -268, -267, -266, -265, -264, -263, -262, -261, -260, -259, -258, -257, -256, -255, -254, -253, -252, -251, -250, -249, -248, -247, -246, -245, -244, -243, -242, -241, -240, -239, -238, -237, -236, -235, -234, -233, -232, -231, -230, -229, -228, -227, -226, -225, -224, -223, -222, -221, -220, -219, -218, -217, -216, -215, -214, -213, -212, -211, -210, -209, -208, -207, -206, -205, -204, -203, -202, -201, -200, -199, -198, -197, -196, -195, -194, -193, -192, -191, -190, -189, -188, -187, -186, -185, -184, -183, -182, -181, -180, -179, -178, -177, -176, -175, -174, -173, -172, -171, -170, -169, -168, -167, -166, -165, -164, -163, -162, -161, -160, -159]\n0\n```\nand also this one\n```\n[1,2,1,2,1,2,1,2,1,2]\n-1\n```"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, we need to find out cycle means cycle detection.\\nLet\\'s say Two people are running on a circle then definately they meet at any point. If they meet means cycle present. \\n\\n# Approach\\nSo, Here I will use Fast and Slow pointer (Two pointer approach).\\n1- Initialize two pointer slow and fast.\\n2- Initially both are pointing to head.\\n3- When loop run slow pointer move step ahead while fast pointer move it\\'s double.\\n4- If both pointer meet at a particular point it means cycle present other no."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Forget the garbage task.\\n\\nRead the real one:\\nRetuen `True` for neighboring Nodes with equal values, otherwise `False`"
                    },
                    {
                        "username": "arshita129",
                        "content": "neighboring nodes with equal values?? We are not trying to see if neighboring nodes have equal values.\\n"
                    }
                ]
            },
            {
                "id": 2043635,
                "content": [
                    {
                        "username": "julkar9",
                        "content": "I hate this kind of questions, its either you know the solution or don\\'t. There\\'s no in-between."
                    },
                    {
                        "username": "psionl0",
                        "content": "The fast and slow pointer technique is useful in a variety of linked list situations. It is worth while learning about it."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "I\\'m not going to read the whole question just for \"Find cycle\""
                    },
                    {
                        "username": "katalma",
                        "content": "Beginning of the week, beginning of the month. I can believe I am smart. But in the end..."
                    },
                    {
                        "username": "sakibmondal7",
                        "content": "Just check the solution with minimum space under Python language.. They did some strange things.. \n\nThey edited the user response in backend with pos variable. I guess that is why `POS` is given.\n\nThis is cheatings at next level.. "
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "## there is no use of pos here ##\\n`\\nhead = [3,2,0,-4], pos = 3\\n`\\nWill pass the test case since refreance of last node is to pos 1 node"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Okay, so we all know the constant memory solution - but is there a different approach (that uses more than constant space) that also takes linear time? Best I can think of is quadratic."
                    },
                    {
                        "username": "aitachii",
                        "content": "Hash table/dictionary of ListNodes take up O(n) space. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Is LeetCode softening us up?"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Check out this testcase\n```\n[-158, -157, -156, -155, -154, -153, -152, -151, -150, -149, -148, -147, -146, -145, -144, -143, -142, -141, -140, -139, -138, -137, -136, -135, -134, -133, -132, -131, -130, -129, -128, -127, -126, -125, -124, -123, -122, -121, -120, -119, -118, -117, -116, -115, -114, -113, -112, -111, -110, -109, -108, -107, -106, -105, -104, -103, -102, -101, -100, -99, -98, -97, -96, -95, -94, -93, -92, -91, -90, -89, -88, -87, -86, -85, -84, -83, -82, -81, -80, -79, -78, -77, -76, -75, -74, -73, -72, -71, -70, -69, -68, -67, -66, -65, -64, -63, -62, -61, -60, -59, -58, -57, -56, -55, -54, -53, -52, -51, -50, -49, -48, -47, -46, -45, -44, -43, -42, -41, -40, -39, -38, -37, -36, -35, -34, -33, -32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1633, 1634, 1635, 1636, 1637, 1638, 1639, 1640, 1641, 1642, 1643, 1644, 1645, 1646, 1647, 1648, 1649, 1650, 1651, 1652, 1653, 1654, 1655, 1656, 1657, 1658, 1659, 1660, 1661, 1662, 1663, 1664, 1665, 1666, 1667, 1668, 1669, 1670, 1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684, 1685, 1686, 1687, 1688, 1689, 1690, 1691, 1692, 1693, 1694, 1695, 1696, 1697, 1698, 1699, 1700, 1701, 1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709, 1710, 1711, 1712, 1713, 1714, 1715, 1716, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1724, 1725, 1726, 1727, 1728, 1729, 1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738, 1739, 1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749, 1750, 1751, 1752, 1753, 1754, 1755, 1756, 1757, 1758, 1759, 1760, 1761, 1762, 1763, 1764, 1765, 1766, 1767, 1768, 1769, 1770, 1771, 1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1780, 1781, 1782, 1783, 1784, 1785, 1786, 1787, 1788, 1789, 1790, 1791, 1792, 1793, 1794, 1795, 1796, 1797, 1798, 1799, 1800, 1801, 1802, 1803, 1804, 1805, 1806, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 1815, 1816, 1817, 1818, 1819, 1820, 1821, 1822, 1823, 1824, 1825, 1826, 1827, 1828, 1829, 1830, 1831, 1832, 1833, 1834, 1835, 1836, 1837, 1838, 1839, 1840, 1841, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849, 1850, 1851, 1852, 1853, 1854, 1855, 1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879, 1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 2039, 2040, 2041, 2042, 2043, 2044, 2045, 2046, 2047, 2048, 2049, 2050, 2051, 2052, 2053, 2054, 2055, 2056, 2057, 2058, 2059, 2060, 2061, 2062, 2063, 2064, 2065, 2066, 2067, 2068, 2069, 2070, 2071, 2072, 2073, 2074, 2075, 2076, 2077, 2078, 2079, 2080, 2081, 2082, 2083, 2084, 2085, 2086, 2087, 2088, 2089, 2090, 2091, 2092, 2093, 2094, 2095, 2096, 2097, 2098, 2099, 2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107, 2108, 2109, 2110, 2111, 2112, 2113, 2114, 2115, 2116, 2117, 2118, 2119, 2120, 2121, 2122, 2123, 2124, 2125, 2126, 2127, 2128, 2129, 2130, 2131, 2132, 2133, 2134, 2135, 2136, 2137, 2138, 2139, 2140, 2141, 2142, 2143, 2144, 2145, 2146, 2147, 2148, 2149, 2150, 2151, 2152, 2153, 2154, 2155, 2156, 2157, 2158, 2159, 2160, 2161, 2162, 2163, 2164, 2165, 2166, 2167, 2168, 2169, 2170, 2171, 2172, 2173, 2174, 2175, 2176, 2177, 2178, 2179, 2180, 2181, 2182, 2183, 2184, 2185, 2186, 2187, 2188, 2189, 2190, 2191, 2192, 2193, 2194, 2195, 2196, 2197, 2198, 2199, 2200, 2201, 2202, 2203, 2204, 2205, 2206, 2207, 2208, 2209, 2210, 2211, 2212, 2213, 2214, 2215, 2216, 2217, 2218, 2219, 2220, 2221, 2222, 2223, 2224, 2225, 2226, 2227, 2228, 2229, 2230, 2231, 2232, 2233, 2234, 2235, 2236, 2237, 2238, 2239, 2240, 2241, 2242, 2243, 2244, 2245, 2246, 2247, 2248, 2249, 2250, 2251, 2252, 2253, 2254, 2255, 2256, 2257, 2258, 2259, 2260, 2261, 2262, 2263, 2264, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2272, 2273, 2274, 2275, 2276, 2277, 2278, 2279, 2280, 2281, 2282, 2283, 2284, 2285, 2286, 2287, 2288, 2289, 2290, 2291, 2292, 2293, 2294, 2295, 2296, 2297, 2298, 2299, 2300, 2301, 2302, 2303, 2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2319, 2320, 2321, 2322, 2323, 2324, 2325, 2326, 2327, 2328, 2329, 2330, 2331, 2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341, 2342, 2343, 2344, 2345, 2346, 2347, 2348, 2349, 2350, 2351, 2352, 2353, 2354, 2355, 2356, 2357, 2358, 2359, 2360, 2361, 2362, 2363, 2364, 2365, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2384, 2385, 2386, 2387, 2388, 2389, 2390, 2391, 2392, 2393, 2394, 2395, 2396, 2397, 2398, 2399, 2400, 2401, 2402, 2403, 2404, 2405, 2406, 2407, 2408, 2409, 2410, 2411, 2412, 2413, 2414, 2415, 2416, 2417, 2418, 2419, 2420, 2421, 2422, 2423, 2424, 2425, 2426, 2427, 2428, 2429, 2430, 2431, 2432, 2433, 2434, 2435, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2443, 2444, 2445, 2446, 2447, 2448, 2449, 2450, 2451, 2452, 2453, 2454, 2455, 2456, 2457, 2458, 2459, 2460, 2461, 2462, 2463, 2464, 2465, 2466, 2467, 2468, 2469, 2470, 2471, 2472, 2473, 2474, 2475, 2476, 2477, 2478, 2479, 2480, 2481, 2482, 2483, 2484, 2485, 2486, 2487, 2488, 2489, 2490, 2491, 2492, 2493, 2494, 2495, 2496, 2497, 2498, 2499, 2500, 2501, 2502, 2503, 2504, 2505, 2506, 2507, 2508, 2509, 2510, 2511, 2512, 2513, 2514, 2515, 2516, 2517, 2518, 2519, 2520, 2521, 2522, 2523, 2524, 2525, 2526, 2527, 2528, 2529, 2530, 2531, 2532, 2533, 2534, 2535, 2536, 2537, 2538, 2539, 2540, 2541, 2542, 2543, 2544, 2545, 2546, 2547, 2548, 2549, 2550, 2551, 2552, 2553, 2554, 2555, 2556, 2557, 2558, 2559, 2560, 2561, 2562, 2563, 2564, 2565, 2566, 2567, 2568, 2569, 2570, 2571, 2572, 2573, 2574, 2575, 2576, 2577, 2578, 2579, 2580, 2581, 2582, 2583, 2584, 2585, 2586, 2587, 2588, 2589, 2590, 2591, 2592, 2593, 2594, 2595, 2596, 2597, 2598, 2599, 2600, 2601, 2602, 2603, 2604, 2605, 2606, 2607, 2608, 2609, 2610, 2611, 2612, 2613, 2614, 2615, 2616, 2617, 2618, 2619, 2620, 2621, 2622, 2623, 2624, 2625, 2626, 2627, 2628, 2629, 2630, 2631, 2632, 2633, 2634, 2635, 2636, 2637, 2638, 2639, 2640, 2641, 2642, 2643, 2644, 2645, 2646, 2647, 2648, 2649, 2650, 2651, 2652, 2653, 2654, 2655, 2656, 2657, 2658, 2659, 2660, 2661, 2662, 2663, 2664, 2665, 2666, 2667, 2668, 2669, 2670, 2671, 2672, 2673, 2674, 2675, 2676, 2677, 2678, 2679, 2680, 2681, 2682, 2683, 2684, 2685, 2686, 2687, 2688, 2689, 2690, 2691, 2692, 2693, 2694, 2695, 2696, 2697, 2698, 2699, 2700, 2701, 2702, 2703, 2704, 2705, 2706, 2707, 2708, 2709, 2710, 2711, 2712, 2713, 2714, 2715, 2716, 2717, 2718, 2719, 2720, 2721, 2722, 2723, 2724, 2725, 2726, 2727, 2728, 2729, 2730, 2731, 2732, 2733, 2734, 2735, 2736, 2737, 2738, 2739, 2740, 2741, 2742, 2743, 2744, 2745, 2746, 2747, 2748, 2749, 2750, 2751, 2752, 2753, 2754, 2755, 2756, 2757, 2758, 2759, 2760, 2761, 2762, 2763, 2764, 2765, 2766, 2767, 2768, 2769, 2770, 2771, 2772, 2773, 2774, 2775, 2776, 2777, 2778, 2779, 2780, 2781, 2782, 2783, 2784, 2785, 2786, 2787, 2788, 2789, 2790, 2791, 2792, 2793, 2794, 2795, 2796, 2797, 2798, 2799, 2800, 2801, 2802, 2803, 2804, 2805, 2806, 2807, 2808, 2809, 2810, 2811, 2812, 2813, 2814, 2815, 2816, 2817, 2818, 2819, 2820, 2821, 2822, 2823, 2824, 2825, 2826, 2827, 2828, 2829, 2830, 2831, 2832, 2833, 2834, 2835, 2836, 2837, 2838, 2839, 2840, 2841, 2842, 2843, 2844, 2845, 2846, 2847, 2848, 2849, 2850, 2851, 2852, 2853, 2854, 2855, 2856, 2857, 2858, 2859, 2860, 2861, 2862, 2863, 2864, 2865, 2866, 2867, 2868, 2869, 2870, 2871, 2872, 2873, 2874, 2875, 2876, 2877, 2878, 2879, 2880, 2881, 2882, 2883, 2884, 2885, 2886, 2887, 2888, 2889, 2890, 2891, 2892, 2893, 2894, 2895, 2896, 2897, 2898, 2899, 2900, 2901, 2902, 2903, 2904, 2905, 2906, 2907, 2908, 2909, 2910, 2911, 2912, 2913, 2914, 2915, 2916, 2917, 2918, 2919, 2920, 2921, 2922, 2923, 2924, 2925, 2926, 2927, 2928, 2929, 2930, 2931, 2932, 2933, 2934, 2935, 2936, 2937, 2938, 2939, 2940, 2941, 2942, 2943, 2944, 2945, 2946, 2947, 2948, 2949, 2950, 2951, 2952, 2953, 2954, 2955, 2956, 2957, 2958, 2959, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2969, 2970, 2971, 2972, 2973, 2974, 2975, 2976, 2977, 2978, 2979, 2980, 2981, 2982, 2983, 2984, 2985, 2986, 2987, 2988, 2989, 2990, 2991, 2992, 2993, 2994, 2995, 2996, 2997, 2998, 2999, 3000, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 3009, 3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019, 3020, 3021, 3022, 3023, 3024, 3025, 3026, 3027, 3028, 3029, 3030, 3031, 3032, 3033, 3034, 3035, 3036, 3037, 3038, 3039, 3040, 3041, 3042, 3043, 3044, 3045, 3046, 3047, 3048, 3049, 3050, 3051, 3052, 3053, 3054, 3055, 3056, 3057, 3058, 3059, 3060, 3061, 3062, 3063, 3064, 3065, 3066, 3067, 3068, 3069, 3070, 3071, 3072, 3073, 3074, 3075, 3076, 3077, 3078, 3079, 3080, 3081, 3082, 3083, 3084, 3085, 3086, 3087, 3088, 3089, 3090, 3091, 3092, 3093, 3094, 3095, 3096, 3097, 3098, 3099, 3100, 3101, 3102, 3103, 3104, 3105, 3106, 3107, 3108, 3109, 3110, 3111, 3112, 3113, 3114, 3115, 3116, 3117, 3118, 3119, 3120, 3121, 3122, 3123, 3124, 3125, 3126, 3127, 3128, 3129, 3130, 3131, 3132, 3133, 3134, 3135, 3136, 3137, 3138, 3139, 3140, 3141, 3142, 3143, 3144, 3145, 3146, 3147, 3148, 3149, 3150, 3151, 3152, 3153, 3154, 3155, 3156, 3157, 3158, 3159, 3160, 3161, 3162, 3163, 3164, 3165, 3166, 3167, 3168, 3169, 3170, 3171, 3172, 3173, 3174, 3175, 3176, 3177, 3178, 3179, 3180, 3181, 3182, 3183, 3184, 3185, 3186, 3187, 3188, 3189, 3190, 3191, 3192, 3193, 3194, 3195, 3196, 3197, 3198, 3199, 3200, 3201, 3202, 3203, 3204, 3205, 3206, 3207, 3208, 3209, 3210, 3211, 3212, 3213, 3214, 3215, 3216, 3217, 3218, 3219, 3220, 3221, 3222, 3223, 3224, 3225, 3226, 3227, 3228, 3229, 3230, 3231, 3232, 3233, 3234, 3235, 3236, 3237, 3238, 3239, 3240, 3241, 3242, 3243, 3244, 3245, 3246, 3247, 3248, 3249, 3250, 3251, 3252, 3253, 3254, 3255, 3256, 3257, 3258, 3259, 3260, 3261, 3262, 3263, 3264, 3265, 3266, 3267, 3268, 3269, 3270, 3271, 3272, 3273, 3274, 3275, 3276, 3277, 3278, 3279, 3280, 3281, 3282, 3283, 3284, 3285, 3286, 3287, 3288, 3289, 3290, 3291, 3292, 3293, 3294, 3295, 3296, 3297, 3298, 3299, 3300, 3301, 3302, 3303, 3304, 3305, 3306, 3307, 3308, 3309, 3310, 3311, 3312, 3313, 3314, 3315, 3316, 3317, 3318, 3319, 3320, 3321, 3322, 3323, 3324, 3325, 3326, 3327, 3328, 3329, 3330, 3331, 3332, 3333, 3334, 3335, 3336, 3337, 3338, 3339, 3340, 3341, 3342, 3343, 3344, 3345, 3346, 3347, 3348, 3349, 3350, 3351, 3352, 3353, 3354, 3355, 3356, 3357, 3358, 3359, 3360, 3361, 3362, 3363, 3364, 3365, 3366, 3367, 3368, 3369, 3370, 3371, 3372, 3373, 3374, 3375, 3376, 3377, 3378, 3379, 3380, 3381, 3382, 3383, 3384, 3385, 3386, 3387, 3388, 3389, 3390, 3391, 3392, 3393, 3394, 3395, 3396, 3397, 3398, 3399, 3400, 3401, 3402, 3403, 3404, 3405, 3406, 3407, 3408, 3409, 3410, 3411, 3412, 3413, 3414, 3415, 3416, 3417, 3418, 3419, 3420, 3421, 3422, 3423, 3424, 3425, 3426, 3427, 3428, 3429, 3430, 3431, 3432, 3433, 3434, 3435, 3436, 3437, 3438, 3439, 3440, 3441, 3442, 3443, 3444, 3445, 3446, 3447, 3448, 3449, 3450, 3451, 3452, 3453, 3454, 3455, 3456, 3457, 3458, 3459, 3460, 3461, 3462, 3463, 3464, 3465, 3466, 3467, 3468, 3469, 3470, 3471, 3472, 3473, 3474, 3475, 3476, 3477, 3478, 3479, 3480, 3481, 3482, 3483, 3484, 3485, 3486, 3487, 3488, 3489, 3490, 3491, 3492, 3493, 3494, 3495, 3496, 3497, 3498, 3499, 3500, 3501, 3502, 3503, 3504, 3505, 3506, 3507, 3508, 3509, 3510, 3511, 3512, 3513, 3514, 3515, 3516, 3517, 3518, 3519, 3520, 3521, 3522, 3523, 3524, 3525, 3526, 3527, 3528, 3529, 3530, 3531, 3532, 3533, 3534, 3535, 3536, 3537, 3538, 3539, 3540, 3541, 3542, 3543, 3544, 3545, 3546, 3547, 3548, 3549, 3550, 3551, 3552, 3553, 3554, 3555, 3556, 3557, 3558, 3559, 3560, 3561, 3562, 3563, 3564, 3565, 3566, 3567, 3568, 3569, 3570, 3571, 3572, 3573, 3574, 3575, 3576, 3577, 3578, 3579, 3580, 3581, 3582, 3583, 3584, 3585, 3586, 3587, 3588, 3589, 3590, 3591, 3592, 3593, 3594, 3595, 3596, 3597, 3598, 3599, 3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609, 3610, 3611, 3612, 3613, 3614, 3615, 3616, 3617, 3618, 3619, 3620, 3621, 3622, 3623, 3624, 3625, 3626, 3627, 3628, 3629, 3630, 3631, 3632, 3633, 3634, 3635, 3636, 3637, 3638, 3639, 3640, 3641, 3642, 3643, 3644, 3645, 3646, 3647, 3648, 3649, 3650, 3651, 3652, 3653, 3654, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3662, 3663, 3664, 3665, 3666, 3667, 3668, 3669, 3670, 3671, 3672, 3673, 3674, 3675, 3676, 3677, 3678, 3679, 3680, 3681, 3682, 3683, 3684, 3685, 3686, 3687, 3688, 3689, 3690, 3691, 3692, 3693, 3694, 3695, 3696, 3697, 3698, 3699, 3700, 3701, 3702, 3703, 3704, 3705, 3706, 3707, 3708, 3709, 3710, 3711, 3712, 3713, 3714, 3715, 3716, 3717, 3718, 3719, 3720, 3721, 3722, 3723, 3724, 3725, 3726, 3727, 3728, 3729, 3730, 3731, 3732, 3733, 3734, 3735, 3736, 3737, 3738, 3739, 3740, 3741, 3742, 3743, 3744, 3745, 3746, 3747, 3748, 3749, 3750, 3751, 3752, 3753, 3754, 3755, 3756, 3757, 3758, 3759, 3760, 3761, 3762, 3763, 3764, 3765, 3766, 3767, 3768, 3769, 3770, 3771, 3772, 3773, 3774, 3775, 3776, 3777, 3778, 3779, 3780, 3781, 3782, 3783, 3784, 3785, 3786, 3787, 3788, 3789, 3790, 3791, 3792, 3793, 3794, 3795, 3796, 3797, 3798, 3799, 3800, 3801, 3802, 3803, 3804, 3805, 3806, 3807, 3808, 3809, 3810, 3811, 3812, 3813, 3814, 3815, 3816, 3817, 3818, 3819, 3820, 3821, 3822, 3823, 3824, 3825, 3826, 3827, 3828, 3829, 3830, 3831, 3832, 3833, 3834, 3835, 3836, 3837, 3838, 3839, 3840, 3841, 3842, 3843, 3844, 3845, 3846, 3847, 3848, 3849, 3850, 3851, 3852, 3853, 3854, 3855, 3856, 3857, 3858, 3859, 3860, 3861, 3862, 3863, 3864, 3865, 3866, 3867, 3868, 3869, 3870, 3871, 3872, 3873, 3874, 3875, 3876, 3877, 3878, 3879, 3880, 3881, 3882, 3883, 3884, 3885, 3886, 3887, 3888, 3889, 3890, 3891, 3892, 3893, 3894, 3895, 3896, 3897, 3898, 3899, 3900, 3901, 3902, 3903, 3904, 3905, 3906, 3907, 3908, 3909, 3910, 3911, 3912, 3913, 3914, 3915, 3916, 3917, 3918, 3919, 3920, 3921, 3922, 3923, 3924, 3925, 3926, 3927, 3928, 3929, 3930, 3931, 3932, 3933, 3934, 3935, 3936, 3937, 3938, 3939, 3940, 3941, 3942, 3943, 3944, 3945, 3946, 3947, 3948, 3949, 3950, 3951, 3952, 3953, 3954, 3955, 3956, 3957, 3958, 3959, 3960, 3961, 3962, 3963, 3964, 3965, 3966, 3967, 3968, 3969, 3970, 3971, 3972, 3973, 3974, 3975, 3976, 3977, 3978, 3979, 3980, 3981, 3982, 3983, 3984, 3985, 3986, 3987, 3988, 3989, 3990, 3991, 3992, 3993, 3994, 3995, 3996, 3997, 3998, 3999, 4000, 4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008, 4009, 4010, 4011, 4012, 4013, 4014, 4015, 4016, 4017, 4018, 4019, 4020, 4021, 4022, 4023, 4024, 4025, 4026, 4027, 4028, 4029, 4030, 4031, 4032, 4033, 4034, 4035, 4036, 4037, 4038, 4039, 4040, 4041, 4042, 4043, 4044, 4045, 4046, 4047, 4048, 4049, 4050, 4051, 4052, 4053, 4054, 4055, 4056, 4057, 4058, 4059, 4060, 4061, 4062, 4063, 4064, 4065, 4066, 4067, 4068, 4069, 4070, 4071, 4072, 4073, 4074, 4075, 4076, 4077, 4078, 4079, 4080, 4081, 4082, 4083, 4084, 4085, 4086, 4087, 4088, 4089, 4090, 4091, 4092, 4093, 4094, 4095, 4096, 4097, 4098, 4099, 4100, 4101, 4102, 4103, 4104, 4105, 4106, 4107, 4108, 4109, 4110, 4111, 4112, 4113, 4114, 4115, 4116, 4117, 4118, 4119, 4120, 4121, 4122, 4123, 4124, 4125, 4126, 4127, 4128, 4129, 4130, 4131, 4132, 4133, 4134, 4135, 4136, 4137, 4138, 4139, 4140, 4141, 4142, 4143, 4144, 4145, 4146, 4147, 4148, 4149, 4150, 4151, 4152, 4153, 4154, 4155, 4156, 4157, 4158, 4159, 4160, 4161, 4162, 4163, 4164, 4165, 4166, 4167, 4168, 4169, 4170, 4171, 4172, 4173, 4174, 4175, 4176, 4177, 4178, 4179, 4180, 4181, 4182, 4183, 4184, 4185, 4186, 4187, 4188, 4189, 4190, 4191, 4192, 4193, 4194, 4195, 4196, 4197, 4198, 4199, 4200, 4201, 4202, 4203, 4204, 4205, 4206, 4207, 4208, 4209, 4210, 4211, 4212, 4213, 4214, 4215, 4216, 4217, 4218, 4219, 4220, 4221, 4222, 4223, 4224, 4225, 4226, 4227, 4228, 4229, 4230, 4231, 4232, 4233, 4234, 4235, 4236, 4237, 4238, 4239, 4240, 4241, 4242, 4243, 4244, 4245, 4246, 4247, 4248, 4249, 4250, 4251, 4252, 4253, 4254, 4255, 4256, 4257, 4258, 4259, 4260, 4261, 4262, 4263, 4264, 4265, 4266, 4267, 4268, 4269, 4270, 4271, 4272, 4273, 4274, 4275, 4276, 4277, 4278, 4279, 4280, 4281, 4282, 4283, 4284, 4285, 4286, 4287, 4288, 4289, 4290, 4291, 4292, 4293, 4294, 4295, 4296, 4297, 4298, 4299, 4300, 4301, 4302, 4303, 4304, 4305, 4306, 4307, 4308, 4309, 4310, 4311, 4312, 4313, 4314, 4315, 4316, 4317, 4318, 4319, 4320, 4321, 4322, 4323, 4324, 4325, 4326, 4327, 4328, 4329, 4330, 4331, 4332, 4333, 4334, 4335, 4336, 4337, 4338, 4339, 4340, 4341, 4342, 4343, 4344, 4345, 4346, 4347, 4348, 4349, 4350, 4351, 4352, 4353, 4354, 4355, 4356, 4357, 4358, 4359, 4360, 4361, 4362, 4363, 4364, 4365, 4366, 4367, 4368, 4369, 4370, 4371, 4372, 4373, 4374, 4375, 4376, 4377, 4378, 4379, 4380, 4381, 4382, 4383, 4384, 4385, 4386, 4387, 4388, 4389, 4390, 4391, 4392, 4393, 4394, 4395, 4396, 4397, 4398, 4399, 4400, 4401, 4402, 4403, 4404, 4405, 4406, 4407, 4408, 4409, 4410, 4411, 4412, 4413, 4414, 4415, 4416, 4417, 4418, 4419, 4420, 4421, 4422, 4423, 4424, 4425, 4426, 4427, 4428, 4429, 4430, 4431, 4432, 4433, 4434, 4435, 4436, 4437, 4438, 4439, 4440, 4441, 4442, 4443, 4444, 4445, 4446, 4447, 4448, 4449, 4450, 4451, 4452, 4453, 4454, 4455, 4456, 4457, 4458, 4459, 4460, 4461, 4462, 4463, 4464, 4465, 4466, 4467, 4468, 4469, 4470, 4471, 4472, 4473, 4474, 4475, 4476, 4477, 4478, 4479, 4480, 4481, 4482, 4483, 4484, 4485, 4486, 4487, 4488, 4489, 4490, 4491, 4492, 4493, 4494, 4495, 4496, 4497, 4498, 4499, -500, -499, -498, -497, -496, -495, -494, -493, -492, -491, -490, -489, -488, -487, -486, -485, -484, -483, -482, -481, -480, -479, -478, -477, -476, -475, -474, -473, -472, -471, -470, -469, -468, -467, -466, -465, -464, -463, -462, -461, -460, -459, -458, -457, -456, -455, -454, -453, -452, -451, -450, -449, -448, -447, -446, -445, -444, -443, -442, -441, -440, -439, -438, -437, -436, -435, -434, -433, -432, -431, -430, -429, -428, -427, -426, -425, -424, -423, -422, -421, -420, -419, -418, -417, -416, -415, -414, -413, -412, -411, -410, -409, -408, -407, -406, -405, -404, -403, -402, -401, -400, -399, -398, -397, -396, -395, -394, -393, -392, -391, -390, -389, -388, -387, -386, -385, -384, -383, -382, -381, -380, -379, -378, -377, -376, -375, -374, -373, -372, -371, -370, -369, -368, -367, -366, -365, -364, -363, -362, -361, -360, -359, -358, -357, -356, -355, -354, -353, -352, -351, -350, -349, -348, -347, -346, -345, -344, -343, -342, -341, -340, -339, -338, -337, -336, -335, -334, -333, -332, -331, -330, -329, -328, -327, -326, -325, -324, -323, -322, -321, -320, -319, -318, -317, -316, -315, -314, -313, -312, -311, -310, -309, -308, -307, -306, -305, -304, -303, -302, -301, -300, -299, -298, -297, -296, -295, -294, -293, -292, -291, -290, -289, -288, -287, -286, -285, -284, -283, -282, -281, -280, -279, -278, -277, -276, -275, -274, -273, -272, -271, -270, -269, -268, -267, -266, -265, -264, -263, -262, -261, -260, -259, -258, -257, -256, -255, -254, -253, -252, -251, -250, -249, -248, -247, -246, -245, -244, -243, -242, -241, -240, -239, -238, -237, -236, -235, -234, -233, -232, -231, -230, -229, -228, -227, -226, -225, -224, -223, -222, -221, -220, -219, -218, -217, -216, -215, -214, -213, -212, -211, -210, -209, -208, -207, -206, -205, -204, -203, -202, -201, -200, -199, -198, -197, -196, -195, -194, -193, -192, -191, -190, -189, -188, -187, -186, -185, -184, -183, -182, -181, -180, -179, -178, -177, -176, -175, -174, -173, -172, -171, -170, -169, -168, -167, -166, -165, -164, -163, -162, -161, -160, -159]\n0\n```\nand also this one\n```\n[1,2,1,2,1,2,1,2,1,2]\n-1\n```"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, we need to find out cycle means cycle detection.\\nLet\\'s say Two people are running on a circle then definately they meet at any point. If they meet means cycle present. \\n\\n# Approach\\nSo, Here I will use Fast and Slow pointer (Two pointer approach).\\n1- Initialize two pointer slow and fast.\\n2- Initially both are pointing to head.\\n3- When loop run slow pointer move step ahead while fast pointer move it\\'s double.\\n4- If both pointer meet at a particular point it means cycle present other no."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Forget the garbage task.\\n\\nRead the real one:\\nRetuen `True` for neighboring Nodes with equal values, otherwise `False`"
                    },
                    {
                        "username": "arshita129",
                        "content": "neighboring nodes with equal values?? We are not trying to see if neighboring nodes have equal values.\\n"
                    }
                ]
            },
            {
                "id": 2043419,
                "content": [
                    {
                        "username": "julkar9",
                        "content": "I hate this kind of questions, its either you know the solution or don\\'t. There\\'s no in-between."
                    },
                    {
                        "username": "psionl0",
                        "content": "The fast and slow pointer technique is useful in a variety of linked list situations. It is worth while learning about it."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "I\\'m not going to read the whole question just for \"Find cycle\""
                    },
                    {
                        "username": "katalma",
                        "content": "Beginning of the week, beginning of the month. I can believe I am smart. But in the end..."
                    },
                    {
                        "username": "sakibmondal7",
                        "content": "Just check the solution with minimum space under Python language.. They did some strange things.. \n\nThey edited the user response in backend with pos variable. I guess that is why `POS` is given.\n\nThis is cheatings at next level.. "
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "## there is no use of pos here ##\\n`\\nhead = [3,2,0,-4], pos = 3\\n`\\nWill pass the test case since refreance of last node is to pos 1 node"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Okay, so we all know the constant memory solution - but is there a different approach (that uses more than constant space) that also takes linear time? Best I can think of is quadratic."
                    },
                    {
                        "username": "aitachii",
                        "content": "Hash table/dictionary of ListNodes take up O(n) space. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Is LeetCode softening us up?"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Check out this testcase\n```\n[-158, -157, -156, -155, -154, -153, -152, -151, -150, -149, -148, -147, -146, -145, -144, -143, -142, -141, -140, -139, -138, -137, -136, -135, -134, -133, -132, -131, -130, -129, -128, -127, -126, -125, -124, -123, -122, -121, -120, -119, -118, -117, -116, -115, -114, -113, -112, -111, -110, -109, -108, -107, -106, -105, -104, -103, -102, -101, -100, -99, -98, -97, -96, -95, -94, -93, -92, -91, -90, -89, -88, -87, -86, -85, -84, -83, -82, -81, -80, -79, -78, -77, -76, -75, -74, -73, -72, -71, -70, -69, -68, -67, -66, -65, -64, -63, -62, -61, -60, -59, -58, -57, -56, -55, -54, -53, -52, -51, -50, -49, -48, -47, -46, -45, -44, -43, -42, -41, -40, -39, -38, -37, -36, -35, -34, -33, -32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1633, 1634, 1635, 1636, 1637, 1638, 1639, 1640, 1641, 1642, 1643, 1644, 1645, 1646, 1647, 1648, 1649, 1650, 1651, 1652, 1653, 1654, 1655, 1656, 1657, 1658, 1659, 1660, 1661, 1662, 1663, 1664, 1665, 1666, 1667, 1668, 1669, 1670, 1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684, 1685, 1686, 1687, 1688, 1689, 1690, 1691, 1692, 1693, 1694, 1695, 1696, 1697, 1698, 1699, 1700, 1701, 1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709, 1710, 1711, 1712, 1713, 1714, 1715, 1716, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1724, 1725, 1726, 1727, 1728, 1729, 1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738, 1739, 1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749, 1750, 1751, 1752, 1753, 1754, 1755, 1756, 1757, 1758, 1759, 1760, 1761, 1762, 1763, 1764, 1765, 1766, 1767, 1768, 1769, 1770, 1771, 1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1780, 1781, 1782, 1783, 1784, 1785, 1786, 1787, 1788, 1789, 1790, 1791, 1792, 1793, 1794, 1795, 1796, 1797, 1798, 1799, 1800, 1801, 1802, 1803, 1804, 1805, 1806, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 1815, 1816, 1817, 1818, 1819, 1820, 1821, 1822, 1823, 1824, 1825, 1826, 1827, 1828, 1829, 1830, 1831, 1832, 1833, 1834, 1835, 1836, 1837, 1838, 1839, 1840, 1841, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849, 1850, 1851, 1852, 1853, 1854, 1855, 1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879, 1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 2039, 2040, 2041, 2042, 2043, 2044, 2045, 2046, 2047, 2048, 2049, 2050, 2051, 2052, 2053, 2054, 2055, 2056, 2057, 2058, 2059, 2060, 2061, 2062, 2063, 2064, 2065, 2066, 2067, 2068, 2069, 2070, 2071, 2072, 2073, 2074, 2075, 2076, 2077, 2078, 2079, 2080, 2081, 2082, 2083, 2084, 2085, 2086, 2087, 2088, 2089, 2090, 2091, 2092, 2093, 2094, 2095, 2096, 2097, 2098, 2099, 2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107, 2108, 2109, 2110, 2111, 2112, 2113, 2114, 2115, 2116, 2117, 2118, 2119, 2120, 2121, 2122, 2123, 2124, 2125, 2126, 2127, 2128, 2129, 2130, 2131, 2132, 2133, 2134, 2135, 2136, 2137, 2138, 2139, 2140, 2141, 2142, 2143, 2144, 2145, 2146, 2147, 2148, 2149, 2150, 2151, 2152, 2153, 2154, 2155, 2156, 2157, 2158, 2159, 2160, 2161, 2162, 2163, 2164, 2165, 2166, 2167, 2168, 2169, 2170, 2171, 2172, 2173, 2174, 2175, 2176, 2177, 2178, 2179, 2180, 2181, 2182, 2183, 2184, 2185, 2186, 2187, 2188, 2189, 2190, 2191, 2192, 2193, 2194, 2195, 2196, 2197, 2198, 2199, 2200, 2201, 2202, 2203, 2204, 2205, 2206, 2207, 2208, 2209, 2210, 2211, 2212, 2213, 2214, 2215, 2216, 2217, 2218, 2219, 2220, 2221, 2222, 2223, 2224, 2225, 2226, 2227, 2228, 2229, 2230, 2231, 2232, 2233, 2234, 2235, 2236, 2237, 2238, 2239, 2240, 2241, 2242, 2243, 2244, 2245, 2246, 2247, 2248, 2249, 2250, 2251, 2252, 2253, 2254, 2255, 2256, 2257, 2258, 2259, 2260, 2261, 2262, 2263, 2264, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2272, 2273, 2274, 2275, 2276, 2277, 2278, 2279, 2280, 2281, 2282, 2283, 2284, 2285, 2286, 2287, 2288, 2289, 2290, 2291, 2292, 2293, 2294, 2295, 2296, 2297, 2298, 2299, 2300, 2301, 2302, 2303, 2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2319, 2320, 2321, 2322, 2323, 2324, 2325, 2326, 2327, 2328, 2329, 2330, 2331, 2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341, 2342, 2343, 2344, 2345, 2346, 2347, 2348, 2349, 2350, 2351, 2352, 2353, 2354, 2355, 2356, 2357, 2358, 2359, 2360, 2361, 2362, 2363, 2364, 2365, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2384, 2385, 2386, 2387, 2388, 2389, 2390, 2391, 2392, 2393, 2394, 2395, 2396, 2397, 2398, 2399, 2400, 2401, 2402, 2403, 2404, 2405, 2406, 2407, 2408, 2409, 2410, 2411, 2412, 2413, 2414, 2415, 2416, 2417, 2418, 2419, 2420, 2421, 2422, 2423, 2424, 2425, 2426, 2427, 2428, 2429, 2430, 2431, 2432, 2433, 2434, 2435, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2443, 2444, 2445, 2446, 2447, 2448, 2449, 2450, 2451, 2452, 2453, 2454, 2455, 2456, 2457, 2458, 2459, 2460, 2461, 2462, 2463, 2464, 2465, 2466, 2467, 2468, 2469, 2470, 2471, 2472, 2473, 2474, 2475, 2476, 2477, 2478, 2479, 2480, 2481, 2482, 2483, 2484, 2485, 2486, 2487, 2488, 2489, 2490, 2491, 2492, 2493, 2494, 2495, 2496, 2497, 2498, 2499, 2500, 2501, 2502, 2503, 2504, 2505, 2506, 2507, 2508, 2509, 2510, 2511, 2512, 2513, 2514, 2515, 2516, 2517, 2518, 2519, 2520, 2521, 2522, 2523, 2524, 2525, 2526, 2527, 2528, 2529, 2530, 2531, 2532, 2533, 2534, 2535, 2536, 2537, 2538, 2539, 2540, 2541, 2542, 2543, 2544, 2545, 2546, 2547, 2548, 2549, 2550, 2551, 2552, 2553, 2554, 2555, 2556, 2557, 2558, 2559, 2560, 2561, 2562, 2563, 2564, 2565, 2566, 2567, 2568, 2569, 2570, 2571, 2572, 2573, 2574, 2575, 2576, 2577, 2578, 2579, 2580, 2581, 2582, 2583, 2584, 2585, 2586, 2587, 2588, 2589, 2590, 2591, 2592, 2593, 2594, 2595, 2596, 2597, 2598, 2599, 2600, 2601, 2602, 2603, 2604, 2605, 2606, 2607, 2608, 2609, 2610, 2611, 2612, 2613, 2614, 2615, 2616, 2617, 2618, 2619, 2620, 2621, 2622, 2623, 2624, 2625, 2626, 2627, 2628, 2629, 2630, 2631, 2632, 2633, 2634, 2635, 2636, 2637, 2638, 2639, 2640, 2641, 2642, 2643, 2644, 2645, 2646, 2647, 2648, 2649, 2650, 2651, 2652, 2653, 2654, 2655, 2656, 2657, 2658, 2659, 2660, 2661, 2662, 2663, 2664, 2665, 2666, 2667, 2668, 2669, 2670, 2671, 2672, 2673, 2674, 2675, 2676, 2677, 2678, 2679, 2680, 2681, 2682, 2683, 2684, 2685, 2686, 2687, 2688, 2689, 2690, 2691, 2692, 2693, 2694, 2695, 2696, 2697, 2698, 2699, 2700, 2701, 2702, 2703, 2704, 2705, 2706, 2707, 2708, 2709, 2710, 2711, 2712, 2713, 2714, 2715, 2716, 2717, 2718, 2719, 2720, 2721, 2722, 2723, 2724, 2725, 2726, 2727, 2728, 2729, 2730, 2731, 2732, 2733, 2734, 2735, 2736, 2737, 2738, 2739, 2740, 2741, 2742, 2743, 2744, 2745, 2746, 2747, 2748, 2749, 2750, 2751, 2752, 2753, 2754, 2755, 2756, 2757, 2758, 2759, 2760, 2761, 2762, 2763, 2764, 2765, 2766, 2767, 2768, 2769, 2770, 2771, 2772, 2773, 2774, 2775, 2776, 2777, 2778, 2779, 2780, 2781, 2782, 2783, 2784, 2785, 2786, 2787, 2788, 2789, 2790, 2791, 2792, 2793, 2794, 2795, 2796, 2797, 2798, 2799, 2800, 2801, 2802, 2803, 2804, 2805, 2806, 2807, 2808, 2809, 2810, 2811, 2812, 2813, 2814, 2815, 2816, 2817, 2818, 2819, 2820, 2821, 2822, 2823, 2824, 2825, 2826, 2827, 2828, 2829, 2830, 2831, 2832, 2833, 2834, 2835, 2836, 2837, 2838, 2839, 2840, 2841, 2842, 2843, 2844, 2845, 2846, 2847, 2848, 2849, 2850, 2851, 2852, 2853, 2854, 2855, 2856, 2857, 2858, 2859, 2860, 2861, 2862, 2863, 2864, 2865, 2866, 2867, 2868, 2869, 2870, 2871, 2872, 2873, 2874, 2875, 2876, 2877, 2878, 2879, 2880, 2881, 2882, 2883, 2884, 2885, 2886, 2887, 2888, 2889, 2890, 2891, 2892, 2893, 2894, 2895, 2896, 2897, 2898, 2899, 2900, 2901, 2902, 2903, 2904, 2905, 2906, 2907, 2908, 2909, 2910, 2911, 2912, 2913, 2914, 2915, 2916, 2917, 2918, 2919, 2920, 2921, 2922, 2923, 2924, 2925, 2926, 2927, 2928, 2929, 2930, 2931, 2932, 2933, 2934, 2935, 2936, 2937, 2938, 2939, 2940, 2941, 2942, 2943, 2944, 2945, 2946, 2947, 2948, 2949, 2950, 2951, 2952, 2953, 2954, 2955, 2956, 2957, 2958, 2959, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2969, 2970, 2971, 2972, 2973, 2974, 2975, 2976, 2977, 2978, 2979, 2980, 2981, 2982, 2983, 2984, 2985, 2986, 2987, 2988, 2989, 2990, 2991, 2992, 2993, 2994, 2995, 2996, 2997, 2998, 2999, 3000, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 3009, 3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019, 3020, 3021, 3022, 3023, 3024, 3025, 3026, 3027, 3028, 3029, 3030, 3031, 3032, 3033, 3034, 3035, 3036, 3037, 3038, 3039, 3040, 3041, 3042, 3043, 3044, 3045, 3046, 3047, 3048, 3049, 3050, 3051, 3052, 3053, 3054, 3055, 3056, 3057, 3058, 3059, 3060, 3061, 3062, 3063, 3064, 3065, 3066, 3067, 3068, 3069, 3070, 3071, 3072, 3073, 3074, 3075, 3076, 3077, 3078, 3079, 3080, 3081, 3082, 3083, 3084, 3085, 3086, 3087, 3088, 3089, 3090, 3091, 3092, 3093, 3094, 3095, 3096, 3097, 3098, 3099, 3100, 3101, 3102, 3103, 3104, 3105, 3106, 3107, 3108, 3109, 3110, 3111, 3112, 3113, 3114, 3115, 3116, 3117, 3118, 3119, 3120, 3121, 3122, 3123, 3124, 3125, 3126, 3127, 3128, 3129, 3130, 3131, 3132, 3133, 3134, 3135, 3136, 3137, 3138, 3139, 3140, 3141, 3142, 3143, 3144, 3145, 3146, 3147, 3148, 3149, 3150, 3151, 3152, 3153, 3154, 3155, 3156, 3157, 3158, 3159, 3160, 3161, 3162, 3163, 3164, 3165, 3166, 3167, 3168, 3169, 3170, 3171, 3172, 3173, 3174, 3175, 3176, 3177, 3178, 3179, 3180, 3181, 3182, 3183, 3184, 3185, 3186, 3187, 3188, 3189, 3190, 3191, 3192, 3193, 3194, 3195, 3196, 3197, 3198, 3199, 3200, 3201, 3202, 3203, 3204, 3205, 3206, 3207, 3208, 3209, 3210, 3211, 3212, 3213, 3214, 3215, 3216, 3217, 3218, 3219, 3220, 3221, 3222, 3223, 3224, 3225, 3226, 3227, 3228, 3229, 3230, 3231, 3232, 3233, 3234, 3235, 3236, 3237, 3238, 3239, 3240, 3241, 3242, 3243, 3244, 3245, 3246, 3247, 3248, 3249, 3250, 3251, 3252, 3253, 3254, 3255, 3256, 3257, 3258, 3259, 3260, 3261, 3262, 3263, 3264, 3265, 3266, 3267, 3268, 3269, 3270, 3271, 3272, 3273, 3274, 3275, 3276, 3277, 3278, 3279, 3280, 3281, 3282, 3283, 3284, 3285, 3286, 3287, 3288, 3289, 3290, 3291, 3292, 3293, 3294, 3295, 3296, 3297, 3298, 3299, 3300, 3301, 3302, 3303, 3304, 3305, 3306, 3307, 3308, 3309, 3310, 3311, 3312, 3313, 3314, 3315, 3316, 3317, 3318, 3319, 3320, 3321, 3322, 3323, 3324, 3325, 3326, 3327, 3328, 3329, 3330, 3331, 3332, 3333, 3334, 3335, 3336, 3337, 3338, 3339, 3340, 3341, 3342, 3343, 3344, 3345, 3346, 3347, 3348, 3349, 3350, 3351, 3352, 3353, 3354, 3355, 3356, 3357, 3358, 3359, 3360, 3361, 3362, 3363, 3364, 3365, 3366, 3367, 3368, 3369, 3370, 3371, 3372, 3373, 3374, 3375, 3376, 3377, 3378, 3379, 3380, 3381, 3382, 3383, 3384, 3385, 3386, 3387, 3388, 3389, 3390, 3391, 3392, 3393, 3394, 3395, 3396, 3397, 3398, 3399, 3400, 3401, 3402, 3403, 3404, 3405, 3406, 3407, 3408, 3409, 3410, 3411, 3412, 3413, 3414, 3415, 3416, 3417, 3418, 3419, 3420, 3421, 3422, 3423, 3424, 3425, 3426, 3427, 3428, 3429, 3430, 3431, 3432, 3433, 3434, 3435, 3436, 3437, 3438, 3439, 3440, 3441, 3442, 3443, 3444, 3445, 3446, 3447, 3448, 3449, 3450, 3451, 3452, 3453, 3454, 3455, 3456, 3457, 3458, 3459, 3460, 3461, 3462, 3463, 3464, 3465, 3466, 3467, 3468, 3469, 3470, 3471, 3472, 3473, 3474, 3475, 3476, 3477, 3478, 3479, 3480, 3481, 3482, 3483, 3484, 3485, 3486, 3487, 3488, 3489, 3490, 3491, 3492, 3493, 3494, 3495, 3496, 3497, 3498, 3499, 3500, 3501, 3502, 3503, 3504, 3505, 3506, 3507, 3508, 3509, 3510, 3511, 3512, 3513, 3514, 3515, 3516, 3517, 3518, 3519, 3520, 3521, 3522, 3523, 3524, 3525, 3526, 3527, 3528, 3529, 3530, 3531, 3532, 3533, 3534, 3535, 3536, 3537, 3538, 3539, 3540, 3541, 3542, 3543, 3544, 3545, 3546, 3547, 3548, 3549, 3550, 3551, 3552, 3553, 3554, 3555, 3556, 3557, 3558, 3559, 3560, 3561, 3562, 3563, 3564, 3565, 3566, 3567, 3568, 3569, 3570, 3571, 3572, 3573, 3574, 3575, 3576, 3577, 3578, 3579, 3580, 3581, 3582, 3583, 3584, 3585, 3586, 3587, 3588, 3589, 3590, 3591, 3592, 3593, 3594, 3595, 3596, 3597, 3598, 3599, 3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609, 3610, 3611, 3612, 3613, 3614, 3615, 3616, 3617, 3618, 3619, 3620, 3621, 3622, 3623, 3624, 3625, 3626, 3627, 3628, 3629, 3630, 3631, 3632, 3633, 3634, 3635, 3636, 3637, 3638, 3639, 3640, 3641, 3642, 3643, 3644, 3645, 3646, 3647, 3648, 3649, 3650, 3651, 3652, 3653, 3654, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3662, 3663, 3664, 3665, 3666, 3667, 3668, 3669, 3670, 3671, 3672, 3673, 3674, 3675, 3676, 3677, 3678, 3679, 3680, 3681, 3682, 3683, 3684, 3685, 3686, 3687, 3688, 3689, 3690, 3691, 3692, 3693, 3694, 3695, 3696, 3697, 3698, 3699, 3700, 3701, 3702, 3703, 3704, 3705, 3706, 3707, 3708, 3709, 3710, 3711, 3712, 3713, 3714, 3715, 3716, 3717, 3718, 3719, 3720, 3721, 3722, 3723, 3724, 3725, 3726, 3727, 3728, 3729, 3730, 3731, 3732, 3733, 3734, 3735, 3736, 3737, 3738, 3739, 3740, 3741, 3742, 3743, 3744, 3745, 3746, 3747, 3748, 3749, 3750, 3751, 3752, 3753, 3754, 3755, 3756, 3757, 3758, 3759, 3760, 3761, 3762, 3763, 3764, 3765, 3766, 3767, 3768, 3769, 3770, 3771, 3772, 3773, 3774, 3775, 3776, 3777, 3778, 3779, 3780, 3781, 3782, 3783, 3784, 3785, 3786, 3787, 3788, 3789, 3790, 3791, 3792, 3793, 3794, 3795, 3796, 3797, 3798, 3799, 3800, 3801, 3802, 3803, 3804, 3805, 3806, 3807, 3808, 3809, 3810, 3811, 3812, 3813, 3814, 3815, 3816, 3817, 3818, 3819, 3820, 3821, 3822, 3823, 3824, 3825, 3826, 3827, 3828, 3829, 3830, 3831, 3832, 3833, 3834, 3835, 3836, 3837, 3838, 3839, 3840, 3841, 3842, 3843, 3844, 3845, 3846, 3847, 3848, 3849, 3850, 3851, 3852, 3853, 3854, 3855, 3856, 3857, 3858, 3859, 3860, 3861, 3862, 3863, 3864, 3865, 3866, 3867, 3868, 3869, 3870, 3871, 3872, 3873, 3874, 3875, 3876, 3877, 3878, 3879, 3880, 3881, 3882, 3883, 3884, 3885, 3886, 3887, 3888, 3889, 3890, 3891, 3892, 3893, 3894, 3895, 3896, 3897, 3898, 3899, 3900, 3901, 3902, 3903, 3904, 3905, 3906, 3907, 3908, 3909, 3910, 3911, 3912, 3913, 3914, 3915, 3916, 3917, 3918, 3919, 3920, 3921, 3922, 3923, 3924, 3925, 3926, 3927, 3928, 3929, 3930, 3931, 3932, 3933, 3934, 3935, 3936, 3937, 3938, 3939, 3940, 3941, 3942, 3943, 3944, 3945, 3946, 3947, 3948, 3949, 3950, 3951, 3952, 3953, 3954, 3955, 3956, 3957, 3958, 3959, 3960, 3961, 3962, 3963, 3964, 3965, 3966, 3967, 3968, 3969, 3970, 3971, 3972, 3973, 3974, 3975, 3976, 3977, 3978, 3979, 3980, 3981, 3982, 3983, 3984, 3985, 3986, 3987, 3988, 3989, 3990, 3991, 3992, 3993, 3994, 3995, 3996, 3997, 3998, 3999, 4000, 4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008, 4009, 4010, 4011, 4012, 4013, 4014, 4015, 4016, 4017, 4018, 4019, 4020, 4021, 4022, 4023, 4024, 4025, 4026, 4027, 4028, 4029, 4030, 4031, 4032, 4033, 4034, 4035, 4036, 4037, 4038, 4039, 4040, 4041, 4042, 4043, 4044, 4045, 4046, 4047, 4048, 4049, 4050, 4051, 4052, 4053, 4054, 4055, 4056, 4057, 4058, 4059, 4060, 4061, 4062, 4063, 4064, 4065, 4066, 4067, 4068, 4069, 4070, 4071, 4072, 4073, 4074, 4075, 4076, 4077, 4078, 4079, 4080, 4081, 4082, 4083, 4084, 4085, 4086, 4087, 4088, 4089, 4090, 4091, 4092, 4093, 4094, 4095, 4096, 4097, 4098, 4099, 4100, 4101, 4102, 4103, 4104, 4105, 4106, 4107, 4108, 4109, 4110, 4111, 4112, 4113, 4114, 4115, 4116, 4117, 4118, 4119, 4120, 4121, 4122, 4123, 4124, 4125, 4126, 4127, 4128, 4129, 4130, 4131, 4132, 4133, 4134, 4135, 4136, 4137, 4138, 4139, 4140, 4141, 4142, 4143, 4144, 4145, 4146, 4147, 4148, 4149, 4150, 4151, 4152, 4153, 4154, 4155, 4156, 4157, 4158, 4159, 4160, 4161, 4162, 4163, 4164, 4165, 4166, 4167, 4168, 4169, 4170, 4171, 4172, 4173, 4174, 4175, 4176, 4177, 4178, 4179, 4180, 4181, 4182, 4183, 4184, 4185, 4186, 4187, 4188, 4189, 4190, 4191, 4192, 4193, 4194, 4195, 4196, 4197, 4198, 4199, 4200, 4201, 4202, 4203, 4204, 4205, 4206, 4207, 4208, 4209, 4210, 4211, 4212, 4213, 4214, 4215, 4216, 4217, 4218, 4219, 4220, 4221, 4222, 4223, 4224, 4225, 4226, 4227, 4228, 4229, 4230, 4231, 4232, 4233, 4234, 4235, 4236, 4237, 4238, 4239, 4240, 4241, 4242, 4243, 4244, 4245, 4246, 4247, 4248, 4249, 4250, 4251, 4252, 4253, 4254, 4255, 4256, 4257, 4258, 4259, 4260, 4261, 4262, 4263, 4264, 4265, 4266, 4267, 4268, 4269, 4270, 4271, 4272, 4273, 4274, 4275, 4276, 4277, 4278, 4279, 4280, 4281, 4282, 4283, 4284, 4285, 4286, 4287, 4288, 4289, 4290, 4291, 4292, 4293, 4294, 4295, 4296, 4297, 4298, 4299, 4300, 4301, 4302, 4303, 4304, 4305, 4306, 4307, 4308, 4309, 4310, 4311, 4312, 4313, 4314, 4315, 4316, 4317, 4318, 4319, 4320, 4321, 4322, 4323, 4324, 4325, 4326, 4327, 4328, 4329, 4330, 4331, 4332, 4333, 4334, 4335, 4336, 4337, 4338, 4339, 4340, 4341, 4342, 4343, 4344, 4345, 4346, 4347, 4348, 4349, 4350, 4351, 4352, 4353, 4354, 4355, 4356, 4357, 4358, 4359, 4360, 4361, 4362, 4363, 4364, 4365, 4366, 4367, 4368, 4369, 4370, 4371, 4372, 4373, 4374, 4375, 4376, 4377, 4378, 4379, 4380, 4381, 4382, 4383, 4384, 4385, 4386, 4387, 4388, 4389, 4390, 4391, 4392, 4393, 4394, 4395, 4396, 4397, 4398, 4399, 4400, 4401, 4402, 4403, 4404, 4405, 4406, 4407, 4408, 4409, 4410, 4411, 4412, 4413, 4414, 4415, 4416, 4417, 4418, 4419, 4420, 4421, 4422, 4423, 4424, 4425, 4426, 4427, 4428, 4429, 4430, 4431, 4432, 4433, 4434, 4435, 4436, 4437, 4438, 4439, 4440, 4441, 4442, 4443, 4444, 4445, 4446, 4447, 4448, 4449, 4450, 4451, 4452, 4453, 4454, 4455, 4456, 4457, 4458, 4459, 4460, 4461, 4462, 4463, 4464, 4465, 4466, 4467, 4468, 4469, 4470, 4471, 4472, 4473, 4474, 4475, 4476, 4477, 4478, 4479, 4480, 4481, 4482, 4483, 4484, 4485, 4486, 4487, 4488, 4489, 4490, 4491, 4492, 4493, 4494, 4495, 4496, 4497, 4498, 4499, -500, -499, -498, -497, -496, -495, -494, -493, -492, -491, -490, -489, -488, -487, -486, -485, -484, -483, -482, -481, -480, -479, -478, -477, -476, -475, -474, -473, -472, -471, -470, -469, -468, -467, -466, -465, -464, -463, -462, -461, -460, -459, -458, -457, -456, -455, -454, -453, -452, -451, -450, -449, -448, -447, -446, -445, -444, -443, -442, -441, -440, -439, -438, -437, -436, -435, -434, -433, -432, -431, -430, -429, -428, -427, -426, -425, -424, -423, -422, -421, -420, -419, -418, -417, -416, -415, -414, -413, -412, -411, -410, -409, -408, -407, -406, -405, -404, -403, -402, -401, -400, -399, -398, -397, -396, -395, -394, -393, -392, -391, -390, -389, -388, -387, -386, -385, -384, -383, -382, -381, -380, -379, -378, -377, -376, -375, -374, -373, -372, -371, -370, -369, -368, -367, -366, -365, -364, -363, -362, -361, -360, -359, -358, -357, -356, -355, -354, -353, -352, -351, -350, -349, -348, -347, -346, -345, -344, -343, -342, -341, -340, -339, -338, -337, -336, -335, -334, -333, -332, -331, -330, -329, -328, -327, -326, -325, -324, -323, -322, -321, -320, -319, -318, -317, -316, -315, -314, -313, -312, -311, -310, -309, -308, -307, -306, -305, -304, -303, -302, -301, -300, -299, -298, -297, -296, -295, -294, -293, -292, -291, -290, -289, -288, -287, -286, -285, -284, -283, -282, -281, -280, -279, -278, -277, -276, -275, -274, -273, -272, -271, -270, -269, -268, -267, -266, -265, -264, -263, -262, -261, -260, -259, -258, -257, -256, -255, -254, -253, -252, -251, -250, -249, -248, -247, -246, -245, -244, -243, -242, -241, -240, -239, -238, -237, -236, -235, -234, -233, -232, -231, -230, -229, -228, -227, -226, -225, -224, -223, -222, -221, -220, -219, -218, -217, -216, -215, -214, -213, -212, -211, -210, -209, -208, -207, -206, -205, -204, -203, -202, -201, -200, -199, -198, -197, -196, -195, -194, -193, -192, -191, -190, -189, -188, -187, -186, -185, -184, -183, -182, -181, -180, -179, -178, -177, -176, -175, -174, -173, -172, -171, -170, -169, -168, -167, -166, -165, -164, -163, -162, -161, -160, -159]\n0\n```\nand also this one\n```\n[1,2,1,2,1,2,1,2,1,2]\n-1\n```"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, we need to find out cycle means cycle detection.\\nLet\\'s say Two people are running on a circle then definately they meet at any point. If they meet means cycle present. \\n\\n# Approach\\nSo, Here I will use Fast and Slow pointer (Two pointer approach).\\n1- Initialize two pointer slow and fast.\\n2- Initially both are pointing to head.\\n3- When loop run slow pointer move step ahead while fast pointer move it\\'s double.\\n4- If both pointer meet at a particular point it means cycle present other no."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Forget the garbage task.\\n\\nRead the real one:\\nRetuen `True` for neighboring Nodes with equal values, otherwise `False`"
                    },
                    {
                        "username": "arshita129",
                        "content": "neighboring nodes with equal values?? We are not trying to see if neighboring nodes have equal values.\\n"
                    }
                ]
            },
            {
                "id": 2043410,
                "content": [
                    {
                        "username": "julkar9",
                        "content": "I hate this kind of questions, its either you know the solution or don\\'t. There\\'s no in-between."
                    },
                    {
                        "username": "psionl0",
                        "content": "The fast and slow pointer technique is useful in a variety of linked list situations. It is worth while learning about it."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "I\\'m not going to read the whole question just for \"Find cycle\""
                    },
                    {
                        "username": "katalma",
                        "content": "Beginning of the week, beginning of the month. I can believe I am smart. But in the end..."
                    },
                    {
                        "username": "sakibmondal7",
                        "content": "Just check the solution with minimum space under Python language.. They did some strange things.. \n\nThey edited the user response in backend with pos variable. I guess that is why `POS` is given.\n\nThis is cheatings at next level.. "
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "## there is no use of pos here ##\\n`\\nhead = [3,2,0,-4], pos = 3\\n`\\nWill pass the test case since refreance of last node is to pos 1 node"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Okay, so we all know the constant memory solution - but is there a different approach (that uses more than constant space) that also takes linear time? Best I can think of is quadratic."
                    },
                    {
                        "username": "aitachii",
                        "content": "Hash table/dictionary of ListNodes take up O(n) space. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Is LeetCode softening us up?"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Check out this testcase\n```\n[-158, -157, -156, -155, -154, -153, -152, -151, -150, -149, -148, -147, -146, -145, -144, -143, -142, -141, -140, -139, -138, -137, -136, -135, -134, -133, -132, -131, -130, -129, -128, -127, -126, -125, -124, -123, -122, -121, -120, -119, -118, -117, -116, -115, -114, -113, -112, -111, -110, -109, -108, -107, -106, -105, -104, -103, -102, -101, -100, -99, -98, -97, -96, -95, -94, -93, -92, -91, -90, -89, -88, -87, -86, -85, -84, -83, -82, -81, -80, -79, -78, -77, -76, -75, -74, -73, -72, -71, -70, -69, -68, -67, -66, -65, -64, -63, -62, -61, -60, -59, -58, -57, -56, -55, -54, -53, -52, -51, -50, -49, -48, -47, -46, -45, -44, -43, -42, -41, -40, -39, -38, -37, -36, -35, -34, -33, -32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1633, 1634, 1635, 1636, 1637, 1638, 1639, 1640, 1641, 1642, 1643, 1644, 1645, 1646, 1647, 1648, 1649, 1650, 1651, 1652, 1653, 1654, 1655, 1656, 1657, 1658, 1659, 1660, 1661, 1662, 1663, 1664, 1665, 1666, 1667, 1668, 1669, 1670, 1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684, 1685, 1686, 1687, 1688, 1689, 1690, 1691, 1692, 1693, 1694, 1695, 1696, 1697, 1698, 1699, 1700, 1701, 1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709, 1710, 1711, 1712, 1713, 1714, 1715, 1716, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1724, 1725, 1726, 1727, 1728, 1729, 1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738, 1739, 1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749, 1750, 1751, 1752, 1753, 1754, 1755, 1756, 1757, 1758, 1759, 1760, 1761, 1762, 1763, 1764, 1765, 1766, 1767, 1768, 1769, 1770, 1771, 1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1780, 1781, 1782, 1783, 1784, 1785, 1786, 1787, 1788, 1789, 1790, 1791, 1792, 1793, 1794, 1795, 1796, 1797, 1798, 1799, 1800, 1801, 1802, 1803, 1804, 1805, 1806, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 1815, 1816, 1817, 1818, 1819, 1820, 1821, 1822, 1823, 1824, 1825, 1826, 1827, 1828, 1829, 1830, 1831, 1832, 1833, 1834, 1835, 1836, 1837, 1838, 1839, 1840, 1841, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849, 1850, 1851, 1852, 1853, 1854, 1855, 1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879, 1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 2039, 2040, 2041, 2042, 2043, 2044, 2045, 2046, 2047, 2048, 2049, 2050, 2051, 2052, 2053, 2054, 2055, 2056, 2057, 2058, 2059, 2060, 2061, 2062, 2063, 2064, 2065, 2066, 2067, 2068, 2069, 2070, 2071, 2072, 2073, 2074, 2075, 2076, 2077, 2078, 2079, 2080, 2081, 2082, 2083, 2084, 2085, 2086, 2087, 2088, 2089, 2090, 2091, 2092, 2093, 2094, 2095, 2096, 2097, 2098, 2099, 2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107, 2108, 2109, 2110, 2111, 2112, 2113, 2114, 2115, 2116, 2117, 2118, 2119, 2120, 2121, 2122, 2123, 2124, 2125, 2126, 2127, 2128, 2129, 2130, 2131, 2132, 2133, 2134, 2135, 2136, 2137, 2138, 2139, 2140, 2141, 2142, 2143, 2144, 2145, 2146, 2147, 2148, 2149, 2150, 2151, 2152, 2153, 2154, 2155, 2156, 2157, 2158, 2159, 2160, 2161, 2162, 2163, 2164, 2165, 2166, 2167, 2168, 2169, 2170, 2171, 2172, 2173, 2174, 2175, 2176, 2177, 2178, 2179, 2180, 2181, 2182, 2183, 2184, 2185, 2186, 2187, 2188, 2189, 2190, 2191, 2192, 2193, 2194, 2195, 2196, 2197, 2198, 2199, 2200, 2201, 2202, 2203, 2204, 2205, 2206, 2207, 2208, 2209, 2210, 2211, 2212, 2213, 2214, 2215, 2216, 2217, 2218, 2219, 2220, 2221, 2222, 2223, 2224, 2225, 2226, 2227, 2228, 2229, 2230, 2231, 2232, 2233, 2234, 2235, 2236, 2237, 2238, 2239, 2240, 2241, 2242, 2243, 2244, 2245, 2246, 2247, 2248, 2249, 2250, 2251, 2252, 2253, 2254, 2255, 2256, 2257, 2258, 2259, 2260, 2261, 2262, 2263, 2264, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2272, 2273, 2274, 2275, 2276, 2277, 2278, 2279, 2280, 2281, 2282, 2283, 2284, 2285, 2286, 2287, 2288, 2289, 2290, 2291, 2292, 2293, 2294, 2295, 2296, 2297, 2298, 2299, 2300, 2301, 2302, 2303, 2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2319, 2320, 2321, 2322, 2323, 2324, 2325, 2326, 2327, 2328, 2329, 2330, 2331, 2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341, 2342, 2343, 2344, 2345, 2346, 2347, 2348, 2349, 2350, 2351, 2352, 2353, 2354, 2355, 2356, 2357, 2358, 2359, 2360, 2361, 2362, 2363, 2364, 2365, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2384, 2385, 2386, 2387, 2388, 2389, 2390, 2391, 2392, 2393, 2394, 2395, 2396, 2397, 2398, 2399, 2400, 2401, 2402, 2403, 2404, 2405, 2406, 2407, 2408, 2409, 2410, 2411, 2412, 2413, 2414, 2415, 2416, 2417, 2418, 2419, 2420, 2421, 2422, 2423, 2424, 2425, 2426, 2427, 2428, 2429, 2430, 2431, 2432, 2433, 2434, 2435, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2443, 2444, 2445, 2446, 2447, 2448, 2449, 2450, 2451, 2452, 2453, 2454, 2455, 2456, 2457, 2458, 2459, 2460, 2461, 2462, 2463, 2464, 2465, 2466, 2467, 2468, 2469, 2470, 2471, 2472, 2473, 2474, 2475, 2476, 2477, 2478, 2479, 2480, 2481, 2482, 2483, 2484, 2485, 2486, 2487, 2488, 2489, 2490, 2491, 2492, 2493, 2494, 2495, 2496, 2497, 2498, 2499, 2500, 2501, 2502, 2503, 2504, 2505, 2506, 2507, 2508, 2509, 2510, 2511, 2512, 2513, 2514, 2515, 2516, 2517, 2518, 2519, 2520, 2521, 2522, 2523, 2524, 2525, 2526, 2527, 2528, 2529, 2530, 2531, 2532, 2533, 2534, 2535, 2536, 2537, 2538, 2539, 2540, 2541, 2542, 2543, 2544, 2545, 2546, 2547, 2548, 2549, 2550, 2551, 2552, 2553, 2554, 2555, 2556, 2557, 2558, 2559, 2560, 2561, 2562, 2563, 2564, 2565, 2566, 2567, 2568, 2569, 2570, 2571, 2572, 2573, 2574, 2575, 2576, 2577, 2578, 2579, 2580, 2581, 2582, 2583, 2584, 2585, 2586, 2587, 2588, 2589, 2590, 2591, 2592, 2593, 2594, 2595, 2596, 2597, 2598, 2599, 2600, 2601, 2602, 2603, 2604, 2605, 2606, 2607, 2608, 2609, 2610, 2611, 2612, 2613, 2614, 2615, 2616, 2617, 2618, 2619, 2620, 2621, 2622, 2623, 2624, 2625, 2626, 2627, 2628, 2629, 2630, 2631, 2632, 2633, 2634, 2635, 2636, 2637, 2638, 2639, 2640, 2641, 2642, 2643, 2644, 2645, 2646, 2647, 2648, 2649, 2650, 2651, 2652, 2653, 2654, 2655, 2656, 2657, 2658, 2659, 2660, 2661, 2662, 2663, 2664, 2665, 2666, 2667, 2668, 2669, 2670, 2671, 2672, 2673, 2674, 2675, 2676, 2677, 2678, 2679, 2680, 2681, 2682, 2683, 2684, 2685, 2686, 2687, 2688, 2689, 2690, 2691, 2692, 2693, 2694, 2695, 2696, 2697, 2698, 2699, 2700, 2701, 2702, 2703, 2704, 2705, 2706, 2707, 2708, 2709, 2710, 2711, 2712, 2713, 2714, 2715, 2716, 2717, 2718, 2719, 2720, 2721, 2722, 2723, 2724, 2725, 2726, 2727, 2728, 2729, 2730, 2731, 2732, 2733, 2734, 2735, 2736, 2737, 2738, 2739, 2740, 2741, 2742, 2743, 2744, 2745, 2746, 2747, 2748, 2749, 2750, 2751, 2752, 2753, 2754, 2755, 2756, 2757, 2758, 2759, 2760, 2761, 2762, 2763, 2764, 2765, 2766, 2767, 2768, 2769, 2770, 2771, 2772, 2773, 2774, 2775, 2776, 2777, 2778, 2779, 2780, 2781, 2782, 2783, 2784, 2785, 2786, 2787, 2788, 2789, 2790, 2791, 2792, 2793, 2794, 2795, 2796, 2797, 2798, 2799, 2800, 2801, 2802, 2803, 2804, 2805, 2806, 2807, 2808, 2809, 2810, 2811, 2812, 2813, 2814, 2815, 2816, 2817, 2818, 2819, 2820, 2821, 2822, 2823, 2824, 2825, 2826, 2827, 2828, 2829, 2830, 2831, 2832, 2833, 2834, 2835, 2836, 2837, 2838, 2839, 2840, 2841, 2842, 2843, 2844, 2845, 2846, 2847, 2848, 2849, 2850, 2851, 2852, 2853, 2854, 2855, 2856, 2857, 2858, 2859, 2860, 2861, 2862, 2863, 2864, 2865, 2866, 2867, 2868, 2869, 2870, 2871, 2872, 2873, 2874, 2875, 2876, 2877, 2878, 2879, 2880, 2881, 2882, 2883, 2884, 2885, 2886, 2887, 2888, 2889, 2890, 2891, 2892, 2893, 2894, 2895, 2896, 2897, 2898, 2899, 2900, 2901, 2902, 2903, 2904, 2905, 2906, 2907, 2908, 2909, 2910, 2911, 2912, 2913, 2914, 2915, 2916, 2917, 2918, 2919, 2920, 2921, 2922, 2923, 2924, 2925, 2926, 2927, 2928, 2929, 2930, 2931, 2932, 2933, 2934, 2935, 2936, 2937, 2938, 2939, 2940, 2941, 2942, 2943, 2944, 2945, 2946, 2947, 2948, 2949, 2950, 2951, 2952, 2953, 2954, 2955, 2956, 2957, 2958, 2959, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2969, 2970, 2971, 2972, 2973, 2974, 2975, 2976, 2977, 2978, 2979, 2980, 2981, 2982, 2983, 2984, 2985, 2986, 2987, 2988, 2989, 2990, 2991, 2992, 2993, 2994, 2995, 2996, 2997, 2998, 2999, 3000, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 3009, 3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019, 3020, 3021, 3022, 3023, 3024, 3025, 3026, 3027, 3028, 3029, 3030, 3031, 3032, 3033, 3034, 3035, 3036, 3037, 3038, 3039, 3040, 3041, 3042, 3043, 3044, 3045, 3046, 3047, 3048, 3049, 3050, 3051, 3052, 3053, 3054, 3055, 3056, 3057, 3058, 3059, 3060, 3061, 3062, 3063, 3064, 3065, 3066, 3067, 3068, 3069, 3070, 3071, 3072, 3073, 3074, 3075, 3076, 3077, 3078, 3079, 3080, 3081, 3082, 3083, 3084, 3085, 3086, 3087, 3088, 3089, 3090, 3091, 3092, 3093, 3094, 3095, 3096, 3097, 3098, 3099, 3100, 3101, 3102, 3103, 3104, 3105, 3106, 3107, 3108, 3109, 3110, 3111, 3112, 3113, 3114, 3115, 3116, 3117, 3118, 3119, 3120, 3121, 3122, 3123, 3124, 3125, 3126, 3127, 3128, 3129, 3130, 3131, 3132, 3133, 3134, 3135, 3136, 3137, 3138, 3139, 3140, 3141, 3142, 3143, 3144, 3145, 3146, 3147, 3148, 3149, 3150, 3151, 3152, 3153, 3154, 3155, 3156, 3157, 3158, 3159, 3160, 3161, 3162, 3163, 3164, 3165, 3166, 3167, 3168, 3169, 3170, 3171, 3172, 3173, 3174, 3175, 3176, 3177, 3178, 3179, 3180, 3181, 3182, 3183, 3184, 3185, 3186, 3187, 3188, 3189, 3190, 3191, 3192, 3193, 3194, 3195, 3196, 3197, 3198, 3199, 3200, 3201, 3202, 3203, 3204, 3205, 3206, 3207, 3208, 3209, 3210, 3211, 3212, 3213, 3214, 3215, 3216, 3217, 3218, 3219, 3220, 3221, 3222, 3223, 3224, 3225, 3226, 3227, 3228, 3229, 3230, 3231, 3232, 3233, 3234, 3235, 3236, 3237, 3238, 3239, 3240, 3241, 3242, 3243, 3244, 3245, 3246, 3247, 3248, 3249, 3250, 3251, 3252, 3253, 3254, 3255, 3256, 3257, 3258, 3259, 3260, 3261, 3262, 3263, 3264, 3265, 3266, 3267, 3268, 3269, 3270, 3271, 3272, 3273, 3274, 3275, 3276, 3277, 3278, 3279, 3280, 3281, 3282, 3283, 3284, 3285, 3286, 3287, 3288, 3289, 3290, 3291, 3292, 3293, 3294, 3295, 3296, 3297, 3298, 3299, 3300, 3301, 3302, 3303, 3304, 3305, 3306, 3307, 3308, 3309, 3310, 3311, 3312, 3313, 3314, 3315, 3316, 3317, 3318, 3319, 3320, 3321, 3322, 3323, 3324, 3325, 3326, 3327, 3328, 3329, 3330, 3331, 3332, 3333, 3334, 3335, 3336, 3337, 3338, 3339, 3340, 3341, 3342, 3343, 3344, 3345, 3346, 3347, 3348, 3349, 3350, 3351, 3352, 3353, 3354, 3355, 3356, 3357, 3358, 3359, 3360, 3361, 3362, 3363, 3364, 3365, 3366, 3367, 3368, 3369, 3370, 3371, 3372, 3373, 3374, 3375, 3376, 3377, 3378, 3379, 3380, 3381, 3382, 3383, 3384, 3385, 3386, 3387, 3388, 3389, 3390, 3391, 3392, 3393, 3394, 3395, 3396, 3397, 3398, 3399, 3400, 3401, 3402, 3403, 3404, 3405, 3406, 3407, 3408, 3409, 3410, 3411, 3412, 3413, 3414, 3415, 3416, 3417, 3418, 3419, 3420, 3421, 3422, 3423, 3424, 3425, 3426, 3427, 3428, 3429, 3430, 3431, 3432, 3433, 3434, 3435, 3436, 3437, 3438, 3439, 3440, 3441, 3442, 3443, 3444, 3445, 3446, 3447, 3448, 3449, 3450, 3451, 3452, 3453, 3454, 3455, 3456, 3457, 3458, 3459, 3460, 3461, 3462, 3463, 3464, 3465, 3466, 3467, 3468, 3469, 3470, 3471, 3472, 3473, 3474, 3475, 3476, 3477, 3478, 3479, 3480, 3481, 3482, 3483, 3484, 3485, 3486, 3487, 3488, 3489, 3490, 3491, 3492, 3493, 3494, 3495, 3496, 3497, 3498, 3499, 3500, 3501, 3502, 3503, 3504, 3505, 3506, 3507, 3508, 3509, 3510, 3511, 3512, 3513, 3514, 3515, 3516, 3517, 3518, 3519, 3520, 3521, 3522, 3523, 3524, 3525, 3526, 3527, 3528, 3529, 3530, 3531, 3532, 3533, 3534, 3535, 3536, 3537, 3538, 3539, 3540, 3541, 3542, 3543, 3544, 3545, 3546, 3547, 3548, 3549, 3550, 3551, 3552, 3553, 3554, 3555, 3556, 3557, 3558, 3559, 3560, 3561, 3562, 3563, 3564, 3565, 3566, 3567, 3568, 3569, 3570, 3571, 3572, 3573, 3574, 3575, 3576, 3577, 3578, 3579, 3580, 3581, 3582, 3583, 3584, 3585, 3586, 3587, 3588, 3589, 3590, 3591, 3592, 3593, 3594, 3595, 3596, 3597, 3598, 3599, 3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609, 3610, 3611, 3612, 3613, 3614, 3615, 3616, 3617, 3618, 3619, 3620, 3621, 3622, 3623, 3624, 3625, 3626, 3627, 3628, 3629, 3630, 3631, 3632, 3633, 3634, 3635, 3636, 3637, 3638, 3639, 3640, 3641, 3642, 3643, 3644, 3645, 3646, 3647, 3648, 3649, 3650, 3651, 3652, 3653, 3654, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3662, 3663, 3664, 3665, 3666, 3667, 3668, 3669, 3670, 3671, 3672, 3673, 3674, 3675, 3676, 3677, 3678, 3679, 3680, 3681, 3682, 3683, 3684, 3685, 3686, 3687, 3688, 3689, 3690, 3691, 3692, 3693, 3694, 3695, 3696, 3697, 3698, 3699, 3700, 3701, 3702, 3703, 3704, 3705, 3706, 3707, 3708, 3709, 3710, 3711, 3712, 3713, 3714, 3715, 3716, 3717, 3718, 3719, 3720, 3721, 3722, 3723, 3724, 3725, 3726, 3727, 3728, 3729, 3730, 3731, 3732, 3733, 3734, 3735, 3736, 3737, 3738, 3739, 3740, 3741, 3742, 3743, 3744, 3745, 3746, 3747, 3748, 3749, 3750, 3751, 3752, 3753, 3754, 3755, 3756, 3757, 3758, 3759, 3760, 3761, 3762, 3763, 3764, 3765, 3766, 3767, 3768, 3769, 3770, 3771, 3772, 3773, 3774, 3775, 3776, 3777, 3778, 3779, 3780, 3781, 3782, 3783, 3784, 3785, 3786, 3787, 3788, 3789, 3790, 3791, 3792, 3793, 3794, 3795, 3796, 3797, 3798, 3799, 3800, 3801, 3802, 3803, 3804, 3805, 3806, 3807, 3808, 3809, 3810, 3811, 3812, 3813, 3814, 3815, 3816, 3817, 3818, 3819, 3820, 3821, 3822, 3823, 3824, 3825, 3826, 3827, 3828, 3829, 3830, 3831, 3832, 3833, 3834, 3835, 3836, 3837, 3838, 3839, 3840, 3841, 3842, 3843, 3844, 3845, 3846, 3847, 3848, 3849, 3850, 3851, 3852, 3853, 3854, 3855, 3856, 3857, 3858, 3859, 3860, 3861, 3862, 3863, 3864, 3865, 3866, 3867, 3868, 3869, 3870, 3871, 3872, 3873, 3874, 3875, 3876, 3877, 3878, 3879, 3880, 3881, 3882, 3883, 3884, 3885, 3886, 3887, 3888, 3889, 3890, 3891, 3892, 3893, 3894, 3895, 3896, 3897, 3898, 3899, 3900, 3901, 3902, 3903, 3904, 3905, 3906, 3907, 3908, 3909, 3910, 3911, 3912, 3913, 3914, 3915, 3916, 3917, 3918, 3919, 3920, 3921, 3922, 3923, 3924, 3925, 3926, 3927, 3928, 3929, 3930, 3931, 3932, 3933, 3934, 3935, 3936, 3937, 3938, 3939, 3940, 3941, 3942, 3943, 3944, 3945, 3946, 3947, 3948, 3949, 3950, 3951, 3952, 3953, 3954, 3955, 3956, 3957, 3958, 3959, 3960, 3961, 3962, 3963, 3964, 3965, 3966, 3967, 3968, 3969, 3970, 3971, 3972, 3973, 3974, 3975, 3976, 3977, 3978, 3979, 3980, 3981, 3982, 3983, 3984, 3985, 3986, 3987, 3988, 3989, 3990, 3991, 3992, 3993, 3994, 3995, 3996, 3997, 3998, 3999, 4000, 4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008, 4009, 4010, 4011, 4012, 4013, 4014, 4015, 4016, 4017, 4018, 4019, 4020, 4021, 4022, 4023, 4024, 4025, 4026, 4027, 4028, 4029, 4030, 4031, 4032, 4033, 4034, 4035, 4036, 4037, 4038, 4039, 4040, 4041, 4042, 4043, 4044, 4045, 4046, 4047, 4048, 4049, 4050, 4051, 4052, 4053, 4054, 4055, 4056, 4057, 4058, 4059, 4060, 4061, 4062, 4063, 4064, 4065, 4066, 4067, 4068, 4069, 4070, 4071, 4072, 4073, 4074, 4075, 4076, 4077, 4078, 4079, 4080, 4081, 4082, 4083, 4084, 4085, 4086, 4087, 4088, 4089, 4090, 4091, 4092, 4093, 4094, 4095, 4096, 4097, 4098, 4099, 4100, 4101, 4102, 4103, 4104, 4105, 4106, 4107, 4108, 4109, 4110, 4111, 4112, 4113, 4114, 4115, 4116, 4117, 4118, 4119, 4120, 4121, 4122, 4123, 4124, 4125, 4126, 4127, 4128, 4129, 4130, 4131, 4132, 4133, 4134, 4135, 4136, 4137, 4138, 4139, 4140, 4141, 4142, 4143, 4144, 4145, 4146, 4147, 4148, 4149, 4150, 4151, 4152, 4153, 4154, 4155, 4156, 4157, 4158, 4159, 4160, 4161, 4162, 4163, 4164, 4165, 4166, 4167, 4168, 4169, 4170, 4171, 4172, 4173, 4174, 4175, 4176, 4177, 4178, 4179, 4180, 4181, 4182, 4183, 4184, 4185, 4186, 4187, 4188, 4189, 4190, 4191, 4192, 4193, 4194, 4195, 4196, 4197, 4198, 4199, 4200, 4201, 4202, 4203, 4204, 4205, 4206, 4207, 4208, 4209, 4210, 4211, 4212, 4213, 4214, 4215, 4216, 4217, 4218, 4219, 4220, 4221, 4222, 4223, 4224, 4225, 4226, 4227, 4228, 4229, 4230, 4231, 4232, 4233, 4234, 4235, 4236, 4237, 4238, 4239, 4240, 4241, 4242, 4243, 4244, 4245, 4246, 4247, 4248, 4249, 4250, 4251, 4252, 4253, 4254, 4255, 4256, 4257, 4258, 4259, 4260, 4261, 4262, 4263, 4264, 4265, 4266, 4267, 4268, 4269, 4270, 4271, 4272, 4273, 4274, 4275, 4276, 4277, 4278, 4279, 4280, 4281, 4282, 4283, 4284, 4285, 4286, 4287, 4288, 4289, 4290, 4291, 4292, 4293, 4294, 4295, 4296, 4297, 4298, 4299, 4300, 4301, 4302, 4303, 4304, 4305, 4306, 4307, 4308, 4309, 4310, 4311, 4312, 4313, 4314, 4315, 4316, 4317, 4318, 4319, 4320, 4321, 4322, 4323, 4324, 4325, 4326, 4327, 4328, 4329, 4330, 4331, 4332, 4333, 4334, 4335, 4336, 4337, 4338, 4339, 4340, 4341, 4342, 4343, 4344, 4345, 4346, 4347, 4348, 4349, 4350, 4351, 4352, 4353, 4354, 4355, 4356, 4357, 4358, 4359, 4360, 4361, 4362, 4363, 4364, 4365, 4366, 4367, 4368, 4369, 4370, 4371, 4372, 4373, 4374, 4375, 4376, 4377, 4378, 4379, 4380, 4381, 4382, 4383, 4384, 4385, 4386, 4387, 4388, 4389, 4390, 4391, 4392, 4393, 4394, 4395, 4396, 4397, 4398, 4399, 4400, 4401, 4402, 4403, 4404, 4405, 4406, 4407, 4408, 4409, 4410, 4411, 4412, 4413, 4414, 4415, 4416, 4417, 4418, 4419, 4420, 4421, 4422, 4423, 4424, 4425, 4426, 4427, 4428, 4429, 4430, 4431, 4432, 4433, 4434, 4435, 4436, 4437, 4438, 4439, 4440, 4441, 4442, 4443, 4444, 4445, 4446, 4447, 4448, 4449, 4450, 4451, 4452, 4453, 4454, 4455, 4456, 4457, 4458, 4459, 4460, 4461, 4462, 4463, 4464, 4465, 4466, 4467, 4468, 4469, 4470, 4471, 4472, 4473, 4474, 4475, 4476, 4477, 4478, 4479, 4480, 4481, 4482, 4483, 4484, 4485, 4486, 4487, 4488, 4489, 4490, 4491, 4492, 4493, 4494, 4495, 4496, 4497, 4498, 4499, -500, -499, -498, -497, -496, -495, -494, -493, -492, -491, -490, -489, -488, -487, -486, -485, -484, -483, -482, -481, -480, -479, -478, -477, -476, -475, -474, -473, -472, -471, -470, -469, -468, -467, -466, -465, -464, -463, -462, -461, -460, -459, -458, -457, -456, -455, -454, -453, -452, -451, -450, -449, -448, -447, -446, -445, -444, -443, -442, -441, -440, -439, -438, -437, -436, -435, -434, -433, -432, -431, -430, -429, -428, -427, -426, -425, -424, -423, -422, -421, -420, -419, -418, -417, -416, -415, -414, -413, -412, -411, -410, -409, -408, -407, -406, -405, -404, -403, -402, -401, -400, -399, -398, -397, -396, -395, -394, -393, -392, -391, -390, -389, -388, -387, -386, -385, -384, -383, -382, -381, -380, -379, -378, -377, -376, -375, -374, -373, -372, -371, -370, -369, -368, -367, -366, -365, -364, -363, -362, -361, -360, -359, -358, -357, -356, -355, -354, -353, -352, -351, -350, -349, -348, -347, -346, -345, -344, -343, -342, -341, -340, -339, -338, -337, -336, -335, -334, -333, -332, -331, -330, -329, -328, -327, -326, -325, -324, -323, -322, -321, -320, -319, -318, -317, -316, -315, -314, -313, -312, -311, -310, -309, -308, -307, -306, -305, -304, -303, -302, -301, -300, -299, -298, -297, -296, -295, -294, -293, -292, -291, -290, -289, -288, -287, -286, -285, -284, -283, -282, -281, -280, -279, -278, -277, -276, -275, -274, -273, -272, -271, -270, -269, -268, -267, -266, -265, -264, -263, -262, -261, -260, -259, -258, -257, -256, -255, -254, -253, -252, -251, -250, -249, -248, -247, -246, -245, -244, -243, -242, -241, -240, -239, -238, -237, -236, -235, -234, -233, -232, -231, -230, -229, -228, -227, -226, -225, -224, -223, -222, -221, -220, -219, -218, -217, -216, -215, -214, -213, -212, -211, -210, -209, -208, -207, -206, -205, -204, -203, -202, -201, -200, -199, -198, -197, -196, -195, -194, -193, -192, -191, -190, -189, -188, -187, -186, -185, -184, -183, -182, -181, -180, -179, -178, -177, -176, -175, -174, -173, -172, -171, -170, -169, -168, -167, -166, -165, -164, -163, -162, -161, -160, -159]\n0\n```\nand also this one\n```\n[1,2,1,2,1,2,1,2,1,2]\n-1\n```"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, we need to find out cycle means cycle detection.\\nLet\\'s say Two people are running on a circle then definately they meet at any point. If they meet means cycle present. \\n\\n# Approach\\nSo, Here I will use Fast and Slow pointer (Two pointer approach).\\n1- Initialize two pointer slow and fast.\\n2- Initially both are pointing to head.\\n3- When loop run slow pointer move step ahead while fast pointer move it\\'s double.\\n4- If both pointer meet at a particular point it means cycle present other no."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Forget the garbage task.\\n\\nRead the real one:\\nRetuen `True` for neighboring Nodes with equal values, otherwise `False`"
                    },
                    {
                        "username": "arshita129",
                        "content": "neighboring nodes with equal values?? We are not trying to see if neighboring nodes have equal values.\\n"
                    }
                ]
            },
            {
                "id": 2043401,
                "content": [
                    {
                        "username": "julkar9",
                        "content": "I hate this kind of questions, its either you know the solution or don\\'t. There\\'s no in-between."
                    },
                    {
                        "username": "psionl0",
                        "content": "The fast and slow pointer technique is useful in a variety of linked list situations. It is worth while learning about it."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "I\\'m not going to read the whole question just for \"Find cycle\""
                    },
                    {
                        "username": "katalma",
                        "content": "Beginning of the week, beginning of the month. I can believe I am smart. But in the end..."
                    },
                    {
                        "username": "sakibmondal7",
                        "content": "Just check the solution with minimum space under Python language.. They did some strange things.. \n\nThey edited the user response in backend with pos variable. I guess that is why `POS` is given.\n\nThis is cheatings at next level.. "
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "## there is no use of pos here ##\\n`\\nhead = [3,2,0,-4], pos = 3\\n`\\nWill pass the test case since refreance of last node is to pos 1 node"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Okay, so we all know the constant memory solution - but is there a different approach (that uses more than constant space) that also takes linear time? Best I can think of is quadratic."
                    },
                    {
                        "username": "aitachii",
                        "content": "Hash table/dictionary of ListNodes take up O(n) space. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Is LeetCode softening us up?"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Check out this testcase\n```\n[-158, -157, -156, -155, -154, -153, -152, -151, -150, -149, -148, -147, -146, -145, -144, -143, -142, -141, -140, -139, -138, -137, -136, -135, -134, -133, -132, -131, -130, -129, -128, -127, -126, -125, -124, -123, -122, -121, -120, -119, -118, -117, -116, -115, -114, -113, -112, -111, -110, -109, -108, -107, -106, -105, -104, -103, -102, -101, -100, -99, -98, -97, -96, -95, -94, -93, -92, -91, -90, -89, -88, -87, -86, -85, -84, -83, -82, -81, -80, -79, -78, -77, -76, -75, -74, -73, -72, -71, -70, -69, -68, -67, -66, -65, -64, -63, -62, -61, -60, -59, -58, -57, -56, -55, -54, -53, -52, -51, -50, -49, -48, -47, -46, -45, -44, -43, -42, -41, -40, -39, -38, -37, -36, -35, -34, -33, -32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1633, 1634, 1635, 1636, 1637, 1638, 1639, 1640, 1641, 1642, 1643, 1644, 1645, 1646, 1647, 1648, 1649, 1650, 1651, 1652, 1653, 1654, 1655, 1656, 1657, 1658, 1659, 1660, 1661, 1662, 1663, 1664, 1665, 1666, 1667, 1668, 1669, 1670, 1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684, 1685, 1686, 1687, 1688, 1689, 1690, 1691, 1692, 1693, 1694, 1695, 1696, 1697, 1698, 1699, 1700, 1701, 1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709, 1710, 1711, 1712, 1713, 1714, 1715, 1716, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1724, 1725, 1726, 1727, 1728, 1729, 1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738, 1739, 1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749, 1750, 1751, 1752, 1753, 1754, 1755, 1756, 1757, 1758, 1759, 1760, 1761, 1762, 1763, 1764, 1765, 1766, 1767, 1768, 1769, 1770, 1771, 1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1780, 1781, 1782, 1783, 1784, 1785, 1786, 1787, 1788, 1789, 1790, 1791, 1792, 1793, 1794, 1795, 1796, 1797, 1798, 1799, 1800, 1801, 1802, 1803, 1804, 1805, 1806, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 1815, 1816, 1817, 1818, 1819, 1820, 1821, 1822, 1823, 1824, 1825, 1826, 1827, 1828, 1829, 1830, 1831, 1832, 1833, 1834, 1835, 1836, 1837, 1838, 1839, 1840, 1841, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849, 1850, 1851, 1852, 1853, 1854, 1855, 1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879, 1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 2039, 2040, 2041, 2042, 2043, 2044, 2045, 2046, 2047, 2048, 2049, 2050, 2051, 2052, 2053, 2054, 2055, 2056, 2057, 2058, 2059, 2060, 2061, 2062, 2063, 2064, 2065, 2066, 2067, 2068, 2069, 2070, 2071, 2072, 2073, 2074, 2075, 2076, 2077, 2078, 2079, 2080, 2081, 2082, 2083, 2084, 2085, 2086, 2087, 2088, 2089, 2090, 2091, 2092, 2093, 2094, 2095, 2096, 2097, 2098, 2099, 2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107, 2108, 2109, 2110, 2111, 2112, 2113, 2114, 2115, 2116, 2117, 2118, 2119, 2120, 2121, 2122, 2123, 2124, 2125, 2126, 2127, 2128, 2129, 2130, 2131, 2132, 2133, 2134, 2135, 2136, 2137, 2138, 2139, 2140, 2141, 2142, 2143, 2144, 2145, 2146, 2147, 2148, 2149, 2150, 2151, 2152, 2153, 2154, 2155, 2156, 2157, 2158, 2159, 2160, 2161, 2162, 2163, 2164, 2165, 2166, 2167, 2168, 2169, 2170, 2171, 2172, 2173, 2174, 2175, 2176, 2177, 2178, 2179, 2180, 2181, 2182, 2183, 2184, 2185, 2186, 2187, 2188, 2189, 2190, 2191, 2192, 2193, 2194, 2195, 2196, 2197, 2198, 2199, 2200, 2201, 2202, 2203, 2204, 2205, 2206, 2207, 2208, 2209, 2210, 2211, 2212, 2213, 2214, 2215, 2216, 2217, 2218, 2219, 2220, 2221, 2222, 2223, 2224, 2225, 2226, 2227, 2228, 2229, 2230, 2231, 2232, 2233, 2234, 2235, 2236, 2237, 2238, 2239, 2240, 2241, 2242, 2243, 2244, 2245, 2246, 2247, 2248, 2249, 2250, 2251, 2252, 2253, 2254, 2255, 2256, 2257, 2258, 2259, 2260, 2261, 2262, 2263, 2264, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2272, 2273, 2274, 2275, 2276, 2277, 2278, 2279, 2280, 2281, 2282, 2283, 2284, 2285, 2286, 2287, 2288, 2289, 2290, 2291, 2292, 2293, 2294, 2295, 2296, 2297, 2298, 2299, 2300, 2301, 2302, 2303, 2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2319, 2320, 2321, 2322, 2323, 2324, 2325, 2326, 2327, 2328, 2329, 2330, 2331, 2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341, 2342, 2343, 2344, 2345, 2346, 2347, 2348, 2349, 2350, 2351, 2352, 2353, 2354, 2355, 2356, 2357, 2358, 2359, 2360, 2361, 2362, 2363, 2364, 2365, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2384, 2385, 2386, 2387, 2388, 2389, 2390, 2391, 2392, 2393, 2394, 2395, 2396, 2397, 2398, 2399, 2400, 2401, 2402, 2403, 2404, 2405, 2406, 2407, 2408, 2409, 2410, 2411, 2412, 2413, 2414, 2415, 2416, 2417, 2418, 2419, 2420, 2421, 2422, 2423, 2424, 2425, 2426, 2427, 2428, 2429, 2430, 2431, 2432, 2433, 2434, 2435, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2443, 2444, 2445, 2446, 2447, 2448, 2449, 2450, 2451, 2452, 2453, 2454, 2455, 2456, 2457, 2458, 2459, 2460, 2461, 2462, 2463, 2464, 2465, 2466, 2467, 2468, 2469, 2470, 2471, 2472, 2473, 2474, 2475, 2476, 2477, 2478, 2479, 2480, 2481, 2482, 2483, 2484, 2485, 2486, 2487, 2488, 2489, 2490, 2491, 2492, 2493, 2494, 2495, 2496, 2497, 2498, 2499, 2500, 2501, 2502, 2503, 2504, 2505, 2506, 2507, 2508, 2509, 2510, 2511, 2512, 2513, 2514, 2515, 2516, 2517, 2518, 2519, 2520, 2521, 2522, 2523, 2524, 2525, 2526, 2527, 2528, 2529, 2530, 2531, 2532, 2533, 2534, 2535, 2536, 2537, 2538, 2539, 2540, 2541, 2542, 2543, 2544, 2545, 2546, 2547, 2548, 2549, 2550, 2551, 2552, 2553, 2554, 2555, 2556, 2557, 2558, 2559, 2560, 2561, 2562, 2563, 2564, 2565, 2566, 2567, 2568, 2569, 2570, 2571, 2572, 2573, 2574, 2575, 2576, 2577, 2578, 2579, 2580, 2581, 2582, 2583, 2584, 2585, 2586, 2587, 2588, 2589, 2590, 2591, 2592, 2593, 2594, 2595, 2596, 2597, 2598, 2599, 2600, 2601, 2602, 2603, 2604, 2605, 2606, 2607, 2608, 2609, 2610, 2611, 2612, 2613, 2614, 2615, 2616, 2617, 2618, 2619, 2620, 2621, 2622, 2623, 2624, 2625, 2626, 2627, 2628, 2629, 2630, 2631, 2632, 2633, 2634, 2635, 2636, 2637, 2638, 2639, 2640, 2641, 2642, 2643, 2644, 2645, 2646, 2647, 2648, 2649, 2650, 2651, 2652, 2653, 2654, 2655, 2656, 2657, 2658, 2659, 2660, 2661, 2662, 2663, 2664, 2665, 2666, 2667, 2668, 2669, 2670, 2671, 2672, 2673, 2674, 2675, 2676, 2677, 2678, 2679, 2680, 2681, 2682, 2683, 2684, 2685, 2686, 2687, 2688, 2689, 2690, 2691, 2692, 2693, 2694, 2695, 2696, 2697, 2698, 2699, 2700, 2701, 2702, 2703, 2704, 2705, 2706, 2707, 2708, 2709, 2710, 2711, 2712, 2713, 2714, 2715, 2716, 2717, 2718, 2719, 2720, 2721, 2722, 2723, 2724, 2725, 2726, 2727, 2728, 2729, 2730, 2731, 2732, 2733, 2734, 2735, 2736, 2737, 2738, 2739, 2740, 2741, 2742, 2743, 2744, 2745, 2746, 2747, 2748, 2749, 2750, 2751, 2752, 2753, 2754, 2755, 2756, 2757, 2758, 2759, 2760, 2761, 2762, 2763, 2764, 2765, 2766, 2767, 2768, 2769, 2770, 2771, 2772, 2773, 2774, 2775, 2776, 2777, 2778, 2779, 2780, 2781, 2782, 2783, 2784, 2785, 2786, 2787, 2788, 2789, 2790, 2791, 2792, 2793, 2794, 2795, 2796, 2797, 2798, 2799, 2800, 2801, 2802, 2803, 2804, 2805, 2806, 2807, 2808, 2809, 2810, 2811, 2812, 2813, 2814, 2815, 2816, 2817, 2818, 2819, 2820, 2821, 2822, 2823, 2824, 2825, 2826, 2827, 2828, 2829, 2830, 2831, 2832, 2833, 2834, 2835, 2836, 2837, 2838, 2839, 2840, 2841, 2842, 2843, 2844, 2845, 2846, 2847, 2848, 2849, 2850, 2851, 2852, 2853, 2854, 2855, 2856, 2857, 2858, 2859, 2860, 2861, 2862, 2863, 2864, 2865, 2866, 2867, 2868, 2869, 2870, 2871, 2872, 2873, 2874, 2875, 2876, 2877, 2878, 2879, 2880, 2881, 2882, 2883, 2884, 2885, 2886, 2887, 2888, 2889, 2890, 2891, 2892, 2893, 2894, 2895, 2896, 2897, 2898, 2899, 2900, 2901, 2902, 2903, 2904, 2905, 2906, 2907, 2908, 2909, 2910, 2911, 2912, 2913, 2914, 2915, 2916, 2917, 2918, 2919, 2920, 2921, 2922, 2923, 2924, 2925, 2926, 2927, 2928, 2929, 2930, 2931, 2932, 2933, 2934, 2935, 2936, 2937, 2938, 2939, 2940, 2941, 2942, 2943, 2944, 2945, 2946, 2947, 2948, 2949, 2950, 2951, 2952, 2953, 2954, 2955, 2956, 2957, 2958, 2959, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2969, 2970, 2971, 2972, 2973, 2974, 2975, 2976, 2977, 2978, 2979, 2980, 2981, 2982, 2983, 2984, 2985, 2986, 2987, 2988, 2989, 2990, 2991, 2992, 2993, 2994, 2995, 2996, 2997, 2998, 2999, 3000, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 3009, 3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019, 3020, 3021, 3022, 3023, 3024, 3025, 3026, 3027, 3028, 3029, 3030, 3031, 3032, 3033, 3034, 3035, 3036, 3037, 3038, 3039, 3040, 3041, 3042, 3043, 3044, 3045, 3046, 3047, 3048, 3049, 3050, 3051, 3052, 3053, 3054, 3055, 3056, 3057, 3058, 3059, 3060, 3061, 3062, 3063, 3064, 3065, 3066, 3067, 3068, 3069, 3070, 3071, 3072, 3073, 3074, 3075, 3076, 3077, 3078, 3079, 3080, 3081, 3082, 3083, 3084, 3085, 3086, 3087, 3088, 3089, 3090, 3091, 3092, 3093, 3094, 3095, 3096, 3097, 3098, 3099, 3100, 3101, 3102, 3103, 3104, 3105, 3106, 3107, 3108, 3109, 3110, 3111, 3112, 3113, 3114, 3115, 3116, 3117, 3118, 3119, 3120, 3121, 3122, 3123, 3124, 3125, 3126, 3127, 3128, 3129, 3130, 3131, 3132, 3133, 3134, 3135, 3136, 3137, 3138, 3139, 3140, 3141, 3142, 3143, 3144, 3145, 3146, 3147, 3148, 3149, 3150, 3151, 3152, 3153, 3154, 3155, 3156, 3157, 3158, 3159, 3160, 3161, 3162, 3163, 3164, 3165, 3166, 3167, 3168, 3169, 3170, 3171, 3172, 3173, 3174, 3175, 3176, 3177, 3178, 3179, 3180, 3181, 3182, 3183, 3184, 3185, 3186, 3187, 3188, 3189, 3190, 3191, 3192, 3193, 3194, 3195, 3196, 3197, 3198, 3199, 3200, 3201, 3202, 3203, 3204, 3205, 3206, 3207, 3208, 3209, 3210, 3211, 3212, 3213, 3214, 3215, 3216, 3217, 3218, 3219, 3220, 3221, 3222, 3223, 3224, 3225, 3226, 3227, 3228, 3229, 3230, 3231, 3232, 3233, 3234, 3235, 3236, 3237, 3238, 3239, 3240, 3241, 3242, 3243, 3244, 3245, 3246, 3247, 3248, 3249, 3250, 3251, 3252, 3253, 3254, 3255, 3256, 3257, 3258, 3259, 3260, 3261, 3262, 3263, 3264, 3265, 3266, 3267, 3268, 3269, 3270, 3271, 3272, 3273, 3274, 3275, 3276, 3277, 3278, 3279, 3280, 3281, 3282, 3283, 3284, 3285, 3286, 3287, 3288, 3289, 3290, 3291, 3292, 3293, 3294, 3295, 3296, 3297, 3298, 3299, 3300, 3301, 3302, 3303, 3304, 3305, 3306, 3307, 3308, 3309, 3310, 3311, 3312, 3313, 3314, 3315, 3316, 3317, 3318, 3319, 3320, 3321, 3322, 3323, 3324, 3325, 3326, 3327, 3328, 3329, 3330, 3331, 3332, 3333, 3334, 3335, 3336, 3337, 3338, 3339, 3340, 3341, 3342, 3343, 3344, 3345, 3346, 3347, 3348, 3349, 3350, 3351, 3352, 3353, 3354, 3355, 3356, 3357, 3358, 3359, 3360, 3361, 3362, 3363, 3364, 3365, 3366, 3367, 3368, 3369, 3370, 3371, 3372, 3373, 3374, 3375, 3376, 3377, 3378, 3379, 3380, 3381, 3382, 3383, 3384, 3385, 3386, 3387, 3388, 3389, 3390, 3391, 3392, 3393, 3394, 3395, 3396, 3397, 3398, 3399, 3400, 3401, 3402, 3403, 3404, 3405, 3406, 3407, 3408, 3409, 3410, 3411, 3412, 3413, 3414, 3415, 3416, 3417, 3418, 3419, 3420, 3421, 3422, 3423, 3424, 3425, 3426, 3427, 3428, 3429, 3430, 3431, 3432, 3433, 3434, 3435, 3436, 3437, 3438, 3439, 3440, 3441, 3442, 3443, 3444, 3445, 3446, 3447, 3448, 3449, 3450, 3451, 3452, 3453, 3454, 3455, 3456, 3457, 3458, 3459, 3460, 3461, 3462, 3463, 3464, 3465, 3466, 3467, 3468, 3469, 3470, 3471, 3472, 3473, 3474, 3475, 3476, 3477, 3478, 3479, 3480, 3481, 3482, 3483, 3484, 3485, 3486, 3487, 3488, 3489, 3490, 3491, 3492, 3493, 3494, 3495, 3496, 3497, 3498, 3499, 3500, 3501, 3502, 3503, 3504, 3505, 3506, 3507, 3508, 3509, 3510, 3511, 3512, 3513, 3514, 3515, 3516, 3517, 3518, 3519, 3520, 3521, 3522, 3523, 3524, 3525, 3526, 3527, 3528, 3529, 3530, 3531, 3532, 3533, 3534, 3535, 3536, 3537, 3538, 3539, 3540, 3541, 3542, 3543, 3544, 3545, 3546, 3547, 3548, 3549, 3550, 3551, 3552, 3553, 3554, 3555, 3556, 3557, 3558, 3559, 3560, 3561, 3562, 3563, 3564, 3565, 3566, 3567, 3568, 3569, 3570, 3571, 3572, 3573, 3574, 3575, 3576, 3577, 3578, 3579, 3580, 3581, 3582, 3583, 3584, 3585, 3586, 3587, 3588, 3589, 3590, 3591, 3592, 3593, 3594, 3595, 3596, 3597, 3598, 3599, 3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609, 3610, 3611, 3612, 3613, 3614, 3615, 3616, 3617, 3618, 3619, 3620, 3621, 3622, 3623, 3624, 3625, 3626, 3627, 3628, 3629, 3630, 3631, 3632, 3633, 3634, 3635, 3636, 3637, 3638, 3639, 3640, 3641, 3642, 3643, 3644, 3645, 3646, 3647, 3648, 3649, 3650, 3651, 3652, 3653, 3654, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3662, 3663, 3664, 3665, 3666, 3667, 3668, 3669, 3670, 3671, 3672, 3673, 3674, 3675, 3676, 3677, 3678, 3679, 3680, 3681, 3682, 3683, 3684, 3685, 3686, 3687, 3688, 3689, 3690, 3691, 3692, 3693, 3694, 3695, 3696, 3697, 3698, 3699, 3700, 3701, 3702, 3703, 3704, 3705, 3706, 3707, 3708, 3709, 3710, 3711, 3712, 3713, 3714, 3715, 3716, 3717, 3718, 3719, 3720, 3721, 3722, 3723, 3724, 3725, 3726, 3727, 3728, 3729, 3730, 3731, 3732, 3733, 3734, 3735, 3736, 3737, 3738, 3739, 3740, 3741, 3742, 3743, 3744, 3745, 3746, 3747, 3748, 3749, 3750, 3751, 3752, 3753, 3754, 3755, 3756, 3757, 3758, 3759, 3760, 3761, 3762, 3763, 3764, 3765, 3766, 3767, 3768, 3769, 3770, 3771, 3772, 3773, 3774, 3775, 3776, 3777, 3778, 3779, 3780, 3781, 3782, 3783, 3784, 3785, 3786, 3787, 3788, 3789, 3790, 3791, 3792, 3793, 3794, 3795, 3796, 3797, 3798, 3799, 3800, 3801, 3802, 3803, 3804, 3805, 3806, 3807, 3808, 3809, 3810, 3811, 3812, 3813, 3814, 3815, 3816, 3817, 3818, 3819, 3820, 3821, 3822, 3823, 3824, 3825, 3826, 3827, 3828, 3829, 3830, 3831, 3832, 3833, 3834, 3835, 3836, 3837, 3838, 3839, 3840, 3841, 3842, 3843, 3844, 3845, 3846, 3847, 3848, 3849, 3850, 3851, 3852, 3853, 3854, 3855, 3856, 3857, 3858, 3859, 3860, 3861, 3862, 3863, 3864, 3865, 3866, 3867, 3868, 3869, 3870, 3871, 3872, 3873, 3874, 3875, 3876, 3877, 3878, 3879, 3880, 3881, 3882, 3883, 3884, 3885, 3886, 3887, 3888, 3889, 3890, 3891, 3892, 3893, 3894, 3895, 3896, 3897, 3898, 3899, 3900, 3901, 3902, 3903, 3904, 3905, 3906, 3907, 3908, 3909, 3910, 3911, 3912, 3913, 3914, 3915, 3916, 3917, 3918, 3919, 3920, 3921, 3922, 3923, 3924, 3925, 3926, 3927, 3928, 3929, 3930, 3931, 3932, 3933, 3934, 3935, 3936, 3937, 3938, 3939, 3940, 3941, 3942, 3943, 3944, 3945, 3946, 3947, 3948, 3949, 3950, 3951, 3952, 3953, 3954, 3955, 3956, 3957, 3958, 3959, 3960, 3961, 3962, 3963, 3964, 3965, 3966, 3967, 3968, 3969, 3970, 3971, 3972, 3973, 3974, 3975, 3976, 3977, 3978, 3979, 3980, 3981, 3982, 3983, 3984, 3985, 3986, 3987, 3988, 3989, 3990, 3991, 3992, 3993, 3994, 3995, 3996, 3997, 3998, 3999, 4000, 4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008, 4009, 4010, 4011, 4012, 4013, 4014, 4015, 4016, 4017, 4018, 4019, 4020, 4021, 4022, 4023, 4024, 4025, 4026, 4027, 4028, 4029, 4030, 4031, 4032, 4033, 4034, 4035, 4036, 4037, 4038, 4039, 4040, 4041, 4042, 4043, 4044, 4045, 4046, 4047, 4048, 4049, 4050, 4051, 4052, 4053, 4054, 4055, 4056, 4057, 4058, 4059, 4060, 4061, 4062, 4063, 4064, 4065, 4066, 4067, 4068, 4069, 4070, 4071, 4072, 4073, 4074, 4075, 4076, 4077, 4078, 4079, 4080, 4081, 4082, 4083, 4084, 4085, 4086, 4087, 4088, 4089, 4090, 4091, 4092, 4093, 4094, 4095, 4096, 4097, 4098, 4099, 4100, 4101, 4102, 4103, 4104, 4105, 4106, 4107, 4108, 4109, 4110, 4111, 4112, 4113, 4114, 4115, 4116, 4117, 4118, 4119, 4120, 4121, 4122, 4123, 4124, 4125, 4126, 4127, 4128, 4129, 4130, 4131, 4132, 4133, 4134, 4135, 4136, 4137, 4138, 4139, 4140, 4141, 4142, 4143, 4144, 4145, 4146, 4147, 4148, 4149, 4150, 4151, 4152, 4153, 4154, 4155, 4156, 4157, 4158, 4159, 4160, 4161, 4162, 4163, 4164, 4165, 4166, 4167, 4168, 4169, 4170, 4171, 4172, 4173, 4174, 4175, 4176, 4177, 4178, 4179, 4180, 4181, 4182, 4183, 4184, 4185, 4186, 4187, 4188, 4189, 4190, 4191, 4192, 4193, 4194, 4195, 4196, 4197, 4198, 4199, 4200, 4201, 4202, 4203, 4204, 4205, 4206, 4207, 4208, 4209, 4210, 4211, 4212, 4213, 4214, 4215, 4216, 4217, 4218, 4219, 4220, 4221, 4222, 4223, 4224, 4225, 4226, 4227, 4228, 4229, 4230, 4231, 4232, 4233, 4234, 4235, 4236, 4237, 4238, 4239, 4240, 4241, 4242, 4243, 4244, 4245, 4246, 4247, 4248, 4249, 4250, 4251, 4252, 4253, 4254, 4255, 4256, 4257, 4258, 4259, 4260, 4261, 4262, 4263, 4264, 4265, 4266, 4267, 4268, 4269, 4270, 4271, 4272, 4273, 4274, 4275, 4276, 4277, 4278, 4279, 4280, 4281, 4282, 4283, 4284, 4285, 4286, 4287, 4288, 4289, 4290, 4291, 4292, 4293, 4294, 4295, 4296, 4297, 4298, 4299, 4300, 4301, 4302, 4303, 4304, 4305, 4306, 4307, 4308, 4309, 4310, 4311, 4312, 4313, 4314, 4315, 4316, 4317, 4318, 4319, 4320, 4321, 4322, 4323, 4324, 4325, 4326, 4327, 4328, 4329, 4330, 4331, 4332, 4333, 4334, 4335, 4336, 4337, 4338, 4339, 4340, 4341, 4342, 4343, 4344, 4345, 4346, 4347, 4348, 4349, 4350, 4351, 4352, 4353, 4354, 4355, 4356, 4357, 4358, 4359, 4360, 4361, 4362, 4363, 4364, 4365, 4366, 4367, 4368, 4369, 4370, 4371, 4372, 4373, 4374, 4375, 4376, 4377, 4378, 4379, 4380, 4381, 4382, 4383, 4384, 4385, 4386, 4387, 4388, 4389, 4390, 4391, 4392, 4393, 4394, 4395, 4396, 4397, 4398, 4399, 4400, 4401, 4402, 4403, 4404, 4405, 4406, 4407, 4408, 4409, 4410, 4411, 4412, 4413, 4414, 4415, 4416, 4417, 4418, 4419, 4420, 4421, 4422, 4423, 4424, 4425, 4426, 4427, 4428, 4429, 4430, 4431, 4432, 4433, 4434, 4435, 4436, 4437, 4438, 4439, 4440, 4441, 4442, 4443, 4444, 4445, 4446, 4447, 4448, 4449, 4450, 4451, 4452, 4453, 4454, 4455, 4456, 4457, 4458, 4459, 4460, 4461, 4462, 4463, 4464, 4465, 4466, 4467, 4468, 4469, 4470, 4471, 4472, 4473, 4474, 4475, 4476, 4477, 4478, 4479, 4480, 4481, 4482, 4483, 4484, 4485, 4486, 4487, 4488, 4489, 4490, 4491, 4492, 4493, 4494, 4495, 4496, 4497, 4498, 4499, -500, -499, -498, -497, -496, -495, -494, -493, -492, -491, -490, -489, -488, -487, -486, -485, -484, -483, -482, -481, -480, -479, -478, -477, -476, -475, -474, -473, -472, -471, -470, -469, -468, -467, -466, -465, -464, -463, -462, -461, -460, -459, -458, -457, -456, -455, -454, -453, -452, -451, -450, -449, -448, -447, -446, -445, -444, -443, -442, -441, -440, -439, -438, -437, -436, -435, -434, -433, -432, -431, -430, -429, -428, -427, -426, -425, -424, -423, -422, -421, -420, -419, -418, -417, -416, -415, -414, -413, -412, -411, -410, -409, -408, -407, -406, -405, -404, -403, -402, -401, -400, -399, -398, -397, -396, -395, -394, -393, -392, -391, -390, -389, -388, -387, -386, -385, -384, -383, -382, -381, -380, -379, -378, -377, -376, -375, -374, -373, -372, -371, -370, -369, -368, -367, -366, -365, -364, -363, -362, -361, -360, -359, -358, -357, -356, -355, -354, -353, -352, -351, -350, -349, -348, -347, -346, -345, -344, -343, -342, -341, -340, -339, -338, -337, -336, -335, -334, -333, -332, -331, -330, -329, -328, -327, -326, -325, -324, -323, -322, -321, -320, -319, -318, -317, -316, -315, -314, -313, -312, -311, -310, -309, -308, -307, -306, -305, -304, -303, -302, -301, -300, -299, -298, -297, -296, -295, -294, -293, -292, -291, -290, -289, -288, -287, -286, -285, -284, -283, -282, -281, -280, -279, -278, -277, -276, -275, -274, -273, -272, -271, -270, -269, -268, -267, -266, -265, -264, -263, -262, -261, -260, -259, -258, -257, -256, -255, -254, -253, -252, -251, -250, -249, -248, -247, -246, -245, -244, -243, -242, -241, -240, -239, -238, -237, -236, -235, -234, -233, -232, -231, -230, -229, -228, -227, -226, -225, -224, -223, -222, -221, -220, -219, -218, -217, -216, -215, -214, -213, -212, -211, -210, -209, -208, -207, -206, -205, -204, -203, -202, -201, -200, -199, -198, -197, -196, -195, -194, -193, -192, -191, -190, -189, -188, -187, -186, -185, -184, -183, -182, -181, -180, -179, -178, -177, -176, -175, -174, -173, -172, -171, -170, -169, -168, -167, -166, -165, -164, -163, -162, -161, -160, -159]\n0\n```\nand also this one\n```\n[1,2,1,2,1,2,1,2,1,2]\n-1\n```"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, we need to find out cycle means cycle detection.\\nLet\\'s say Two people are running on a circle then definately they meet at any point. If they meet means cycle present. \\n\\n# Approach\\nSo, Here I will use Fast and Slow pointer (Two pointer approach).\\n1- Initialize two pointer slow and fast.\\n2- Initially both are pointing to head.\\n3- When loop run slow pointer move step ahead while fast pointer move it\\'s double.\\n4- If both pointer meet at a particular point it means cycle present other no."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Forget the garbage task.\\n\\nRead the real one:\\nRetuen `True` for neighboring Nodes with equal values, otherwise `False`"
                    },
                    {
                        "username": "arshita129",
                        "content": "neighboring nodes with equal values?? We are not trying to see if neighboring nodes have equal values.\\n"
                    }
                ]
            },
            {
                "id": 2043393,
                "content": [
                    {
                        "username": "julkar9",
                        "content": "I hate this kind of questions, its either you know the solution or don\\'t. There\\'s no in-between."
                    },
                    {
                        "username": "psionl0",
                        "content": "The fast and slow pointer technique is useful in a variety of linked list situations. It is worth while learning about it."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "I\\'m not going to read the whole question just for \"Find cycle\""
                    },
                    {
                        "username": "katalma",
                        "content": "Beginning of the week, beginning of the month. I can believe I am smart. But in the end..."
                    },
                    {
                        "username": "sakibmondal7",
                        "content": "Just check the solution with minimum space under Python language.. They did some strange things.. \n\nThey edited the user response in backend with pos variable. I guess that is why `POS` is given.\n\nThis is cheatings at next level.. "
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "## there is no use of pos here ##\\n`\\nhead = [3,2,0,-4], pos = 3\\n`\\nWill pass the test case since refreance of last node is to pos 1 node"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "Okay, so we all know the constant memory solution - but is there a different approach (that uses more than constant space) that also takes linear time? Best I can think of is quadratic."
                    },
                    {
                        "username": "aitachii",
                        "content": "Hash table/dictionary of ListNodes take up O(n) space. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Is LeetCode softening us up?"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Check out this testcase\n```\n[-158, -157, -156, -155, -154, -153, -152, -151, -150, -149, -148, -147, -146, -145, -144, -143, -142, -141, -140, -139, -138, -137, -136, -135, -134, -133, -132, -131, -130, -129, -128, -127, -126, -125, -124, -123, -122, -121, -120, -119, -118, -117, -116, -115, -114, -113, -112, -111, -110, -109, -108, -107, -106, -105, -104, -103, -102, -101, -100, -99, -98, -97, -96, -95, -94, -93, -92, -91, -90, -89, -88, -87, -86, -85, -84, -83, -82, -81, -80, -79, -78, -77, -76, -75, -74, -73, -72, -71, -70, -69, -68, -67, -66, -65, -64, -63, -62, -61, -60, -59, -58, -57, -56, -55, -54, -53, -52, -51, -50, -49, -48, -47, -46, -45, -44, -43, -42, -41, -40, -39, -38, -37, -36, -35, -34, -33, -32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1633, 1634, 1635, 1636, 1637, 1638, 1639, 1640, 1641, 1642, 1643, 1644, 1645, 1646, 1647, 1648, 1649, 1650, 1651, 1652, 1653, 1654, 1655, 1656, 1657, 1658, 1659, 1660, 1661, 1662, 1663, 1664, 1665, 1666, 1667, 1668, 1669, 1670, 1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684, 1685, 1686, 1687, 1688, 1689, 1690, 1691, 1692, 1693, 1694, 1695, 1696, 1697, 1698, 1699, 1700, 1701, 1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709, 1710, 1711, 1712, 1713, 1714, 1715, 1716, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1724, 1725, 1726, 1727, 1728, 1729, 1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738, 1739, 1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749, 1750, 1751, 1752, 1753, 1754, 1755, 1756, 1757, 1758, 1759, 1760, 1761, 1762, 1763, 1764, 1765, 1766, 1767, 1768, 1769, 1770, 1771, 1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1780, 1781, 1782, 1783, 1784, 1785, 1786, 1787, 1788, 1789, 1790, 1791, 1792, 1793, 1794, 1795, 1796, 1797, 1798, 1799, 1800, 1801, 1802, 1803, 1804, 1805, 1806, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 1815, 1816, 1817, 1818, 1819, 1820, 1821, 1822, 1823, 1824, 1825, 1826, 1827, 1828, 1829, 1830, 1831, 1832, 1833, 1834, 1835, 1836, 1837, 1838, 1839, 1840, 1841, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849, 1850, 1851, 1852, 1853, 1854, 1855, 1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879, 1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 2039, 2040, 2041, 2042, 2043, 2044, 2045, 2046, 2047, 2048, 2049, 2050, 2051, 2052, 2053, 2054, 2055, 2056, 2057, 2058, 2059, 2060, 2061, 2062, 2063, 2064, 2065, 2066, 2067, 2068, 2069, 2070, 2071, 2072, 2073, 2074, 2075, 2076, 2077, 2078, 2079, 2080, 2081, 2082, 2083, 2084, 2085, 2086, 2087, 2088, 2089, 2090, 2091, 2092, 2093, 2094, 2095, 2096, 2097, 2098, 2099, 2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107, 2108, 2109, 2110, 2111, 2112, 2113, 2114, 2115, 2116, 2117, 2118, 2119, 2120, 2121, 2122, 2123, 2124, 2125, 2126, 2127, 2128, 2129, 2130, 2131, 2132, 2133, 2134, 2135, 2136, 2137, 2138, 2139, 2140, 2141, 2142, 2143, 2144, 2145, 2146, 2147, 2148, 2149, 2150, 2151, 2152, 2153, 2154, 2155, 2156, 2157, 2158, 2159, 2160, 2161, 2162, 2163, 2164, 2165, 2166, 2167, 2168, 2169, 2170, 2171, 2172, 2173, 2174, 2175, 2176, 2177, 2178, 2179, 2180, 2181, 2182, 2183, 2184, 2185, 2186, 2187, 2188, 2189, 2190, 2191, 2192, 2193, 2194, 2195, 2196, 2197, 2198, 2199, 2200, 2201, 2202, 2203, 2204, 2205, 2206, 2207, 2208, 2209, 2210, 2211, 2212, 2213, 2214, 2215, 2216, 2217, 2218, 2219, 2220, 2221, 2222, 2223, 2224, 2225, 2226, 2227, 2228, 2229, 2230, 2231, 2232, 2233, 2234, 2235, 2236, 2237, 2238, 2239, 2240, 2241, 2242, 2243, 2244, 2245, 2246, 2247, 2248, 2249, 2250, 2251, 2252, 2253, 2254, 2255, 2256, 2257, 2258, 2259, 2260, 2261, 2262, 2263, 2264, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2272, 2273, 2274, 2275, 2276, 2277, 2278, 2279, 2280, 2281, 2282, 2283, 2284, 2285, 2286, 2287, 2288, 2289, 2290, 2291, 2292, 2293, 2294, 2295, 2296, 2297, 2298, 2299, 2300, 2301, 2302, 2303, 2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2319, 2320, 2321, 2322, 2323, 2324, 2325, 2326, 2327, 2328, 2329, 2330, 2331, 2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341, 2342, 2343, 2344, 2345, 2346, 2347, 2348, 2349, 2350, 2351, 2352, 2353, 2354, 2355, 2356, 2357, 2358, 2359, 2360, 2361, 2362, 2363, 2364, 2365, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2384, 2385, 2386, 2387, 2388, 2389, 2390, 2391, 2392, 2393, 2394, 2395, 2396, 2397, 2398, 2399, 2400, 2401, 2402, 2403, 2404, 2405, 2406, 2407, 2408, 2409, 2410, 2411, 2412, 2413, 2414, 2415, 2416, 2417, 2418, 2419, 2420, 2421, 2422, 2423, 2424, 2425, 2426, 2427, 2428, 2429, 2430, 2431, 2432, 2433, 2434, 2435, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2443, 2444, 2445, 2446, 2447, 2448, 2449, 2450, 2451, 2452, 2453, 2454, 2455, 2456, 2457, 2458, 2459, 2460, 2461, 2462, 2463, 2464, 2465, 2466, 2467, 2468, 2469, 2470, 2471, 2472, 2473, 2474, 2475, 2476, 2477, 2478, 2479, 2480, 2481, 2482, 2483, 2484, 2485, 2486, 2487, 2488, 2489, 2490, 2491, 2492, 2493, 2494, 2495, 2496, 2497, 2498, 2499, 2500, 2501, 2502, 2503, 2504, 2505, 2506, 2507, 2508, 2509, 2510, 2511, 2512, 2513, 2514, 2515, 2516, 2517, 2518, 2519, 2520, 2521, 2522, 2523, 2524, 2525, 2526, 2527, 2528, 2529, 2530, 2531, 2532, 2533, 2534, 2535, 2536, 2537, 2538, 2539, 2540, 2541, 2542, 2543, 2544, 2545, 2546, 2547, 2548, 2549, 2550, 2551, 2552, 2553, 2554, 2555, 2556, 2557, 2558, 2559, 2560, 2561, 2562, 2563, 2564, 2565, 2566, 2567, 2568, 2569, 2570, 2571, 2572, 2573, 2574, 2575, 2576, 2577, 2578, 2579, 2580, 2581, 2582, 2583, 2584, 2585, 2586, 2587, 2588, 2589, 2590, 2591, 2592, 2593, 2594, 2595, 2596, 2597, 2598, 2599, 2600, 2601, 2602, 2603, 2604, 2605, 2606, 2607, 2608, 2609, 2610, 2611, 2612, 2613, 2614, 2615, 2616, 2617, 2618, 2619, 2620, 2621, 2622, 2623, 2624, 2625, 2626, 2627, 2628, 2629, 2630, 2631, 2632, 2633, 2634, 2635, 2636, 2637, 2638, 2639, 2640, 2641, 2642, 2643, 2644, 2645, 2646, 2647, 2648, 2649, 2650, 2651, 2652, 2653, 2654, 2655, 2656, 2657, 2658, 2659, 2660, 2661, 2662, 2663, 2664, 2665, 2666, 2667, 2668, 2669, 2670, 2671, 2672, 2673, 2674, 2675, 2676, 2677, 2678, 2679, 2680, 2681, 2682, 2683, 2684, 2685, 2686, 2687, 2688, 2689, 2690, 2691, 2692, 2693, 2694, 2695, 2696, 2697, 2698, 2699, 2700, 2701, 2702, 2703, 2704, 2705, 2706, 2707, 2708, 2709, 2710, 2711, 2712, 2713, 2714, 2715, 2716, 2717, 2718, 2719, 2720, 2721, 2722, 2723, 2724, 2725, 2726, 2727, 2728, 2729, 2730, 2731, 2732, 2733, 2734, 2735, 2736, 2737, 2738, 2739, 2740, 2741, 2742, 2743, 2744, 2745, 2746, 2747, 2748, 2749, 2750, 2751, 2752, 2753, 2754, 2755, 2756, 2757, 2758, 2759, 2760, 2761, 2762, 2763, 2764, 2765, 2766, 2767, 2768, 2769, 2770, 2771, 2772, 2773, 2774, 2775, 2776, 2777, 2778, 2779, 2780, 2781, 2782, 2783, 2784, 2785, 2786, 2787, 2788, 2789, 2790, 2791, 2792, 2793, 2794, 2795, 2796, 2797, 2798, 2799, 2800, 2801, 2802, 2803, 2804, 2805, 2806, 2807, 2808, 2809, 2810, 2811, 2812, 2813, 2814, 2815, 2816, 2817, 2818, 2819, 2820, 2821, 2822, 2823, 2824, 2825, 2826, 2827, 2828, 2829, 2830, 2831, 2832, 2833, 2834, 2835, 2836, 2837, 2838, 2839, 2840, 2841, 2842, 2843, 2844, 2845, 2846, 2847, 2848, 2849, 2850, 2851, 2852, 2853, 2854, 2855, 2856, 2857, 2858, 2859, 2860, 2861, 2862, 2863, 2864, 2865, 2866, 2867, 2868, 2869, 2870, 2871, 2872, 2873, 2874, 2875, 2876, 2877, 2878, 2879, 2880, 2881, 2882, 2883, 2884, 2885, 2886, 2887, 2888, 2889, 2890, 2891, 2892, 2893, 2894, 2895, 2896, 2897, 2898, 2899, 2900, 2901, 2902, 2903, 2904, 2905, 2906, 2907, 2908, 2909, 2910, 2911, 2912, 2913, 2914, 2915, 2916, 2917, 2918, 2919, 2920, 2921, 2922, 2923, 2924, 2925, 2926, 2927, 2928, 2929, 2930, 2931, 2932, 2933, 2934, 2935, 2936, 2937, 2938, 2939, 2940, 2941, 2942, 2943, 2944, 2945, 2946, 2947, 2948, 2949, 2950, 2951, 2952, 2953, 2954, 2955, 2956, 2957, 2958, 2959, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2969, 2970, 2971, 2972, 2973, 2974, 2975, 2976, 2977, 2978, 2979, 2980, 2981, 2982, 2983, 2984, 2985, 2986, 2987, 2988, 2989, 2990, 2991, 2992, 2993, 2994, 2995, 2996, 2997, 2998, 2999, 3000, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 3009, 3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019, 3020, 3021, 3022, 3023, 3024, 3025, 3026, 3027, 3028, 3029, 3030, 3031, 3032, 3033, 3034, 3035, 3036, 3037, 3038, 3039, 3040, 3041, 3042, 3043, 3044, 3045, 3046, 3047, 3048, 3049, 3050, 3051, 3052, 3053, 3054, 3055, 3056, 3057, 3058, 3059, 3060, 3061, 3062, 3063, 3064, 3065, 3066, 3067, 3068, 3069, 3070, 3071, 3072, 3073, 3074, 3075, 3076, 3077, 3078, 3079, 3080, 3081, 3082, 3083, 3084, 3085, 3086, 3087, 3088, 3089, 3090, 3091, 3092, 3093, 3094, 3095, 3096, 3097, 3098, 3099, 3100, 3101, 3102, 3103, 3104, 3105, 3106, 3107, 3108, 3109, 3110, 3111, 3112, 3113, 3114, 3115, 3116, 3117, 3118, 3119, 3120, 3121, 3122, 3123, 3124, 3125, 3126, 3127, 3128, 3129, 3130, 3131, 3132, 3133, 3134, 3135, 3136, 3137, 3138, 3139, 3140, 3141, 3142, 3143, 3144, 3145, 3146, 3147, 3148, 3149, 3150, 3151, 3152, 3153, 3154, 3155, 3156, 3157, 3158, 3159, 3160, 3161, 3162, 3163, 3164, 3165, 3166, 3167, 3168, 3169, 3170, 3171, 3172, 3173, 3174, 3175, 3176, 3177, 3178, 3179, 3180, 3181, 3182, 3183, 3184, 3185, 3186, 3187, 3188, 3189, 3190, 3191, 3192, 3193, 3194, 3195, 3196, 3197, 3198, 3199, 3200, 3201, 3202, 3203, 3204, 3205, 3206, 3207, 3208, 3209, 3210, 3211, 3212, 3213, 3214, 3215, 3216, 3217, 3218, 3219, 3220, 3221, 3222, 3223, 3224, 3225, 3226, 3227, 3228, 3229, 3230, 3231, 3232, 3233, 3234, 3235, 3236, 3237, 3238, 3239, 3240, 3241, 3242, 3243, 3244, 3245, 3246, 3247, 3248, 3249, 3250, 3251, 3252, 3253, 3254, 3255, 3256, 3257, 3258, 3259, 3260, 3261, 3262, 3263, 3264, 3265, 3266, 3267, 3268, 3269, 3270, 3271, 3272, 3273, 3274, 3275, 3276, 3277, 3278, 3279, 3280, 3281, 3282, 3283, 3284, 3285, 3286, 3287, 3288, 3289, 3290, 3291, 3292, 3293, 3294, 3295, 3296, 3297, 3298, 3299, 3300, 3301, 3302, 3303, 3304, 3305, 3306, 3307, 3308, 3309, 3310, 3311, 3312, 3313, 3314, 3315, 3316, 3317, 3318, 3319, 3320, 3321, 3322, 3323, 3324, 3325, 3326, 3327, 3328, 3329, 3330, 3331, 3332, 3333, 3334, 3335, 3336, 3337, 3338, 3339, 3340, 3341, 3342, 3343, 3344, 3345, 3346, 3347, 3348, 3349, 3350, 3351, 3352, 3353, 3354, 3355, 3356, 3357, 3358, 3359, 3360, 3361, 3362, 3363, 3364, 3365, 3366, 3367, 3368, 3369, 3370, 3371, 3372, 3373, 3374, 3375, 3376, 3377, 3378, 3379, 3380, 3381, 3382, 3383, 3384, 3385, 3386, 3387, 3388, 3389, 3390, 3391, 3392, 3393, 3394, 3395, 3396, 3397, 3398, 3399, 3400, 3401, 3402, 3403, 3404, 3405, 3406, 3407, 3408, 3409, 3410, 3411, 3412, 3413, 3414, 3415, 3416, 3417, 3418, 3419, 3420, 3421, 3422, 3423, 3424, 3425, 3426, 3427, 3428, 3429, 3430, 3431, 3432, 3433, 3434, 3435, 3436, 3437, 3438, 3439, 3440, 3441, 3442, 3443, 3444, 3445, 3446, 3447, 3448, 3449, 3450, 3451, 3452, 3453, 3454, 3455, 3456, 3457, 3458, 3459, 3460, 3461, 3462, 3463, 3464, 3465, 3466, 3467, 3468, 3469, 3470, 3471, 3472, 3473, 3474, 3475, 3476, 3477, 3478, 3479, 3480, 3481, 3482, 3483, 3484, 3485, 3486, 3487, 3488, 3489, 3490, 3491, 3492, 3493, 3494, 3495, 3496, 3497, 3498, 3499, 3500, 3501, 3502, 3503, 3504, 3505, 3506, 3507, 3508, 3509, 3510, 3511, 3512, 3513, 3514, 3515, 3516, 3517, 3518, 3519, 3520, 3521, 3522, 3523, 3524, 3525, 3526, 3527, 3528, 3529, 3530, 3531, 3532, 3533, 3534, 3535, 3536, 3537, 3538, 3539, 3540, 3541, 3542, 3543, 3544, 3545, 3546, 3547, 3548, 3549, 3550, 3551, 3552, 3553, 3554, 3555, 3556, 3557, 3558, 3559, 3560, 3561, 3562, 3563, 3564, 3565, 3566, 3567, 3568, 3569, 3570, 3571, 3572, 3573, 3574, 3575, 3576, 3577, 3578, 3579, 3580, 3581, 3582, 3583, 3584, 3585, 3586, 3587, 3588, 3589, 3590, 3591, 3592, 3593, 3594, 3595, 3596, 3597, 3598, 3599, 3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609, 3610, 3611, 3612, 3613, 3614, 3615, 3616, 3617, 3618, 3619, 3620, 3621, 3622, 3623, 3624, 3625, 3626, 3627, 3628, 3629, 3630, 3631, 3632, 3633, 3634, 3635, 3636, 3637, 3638, 3639, 3640, 3641, 3642, 3643, 3644, 3645, 3646, 3647, 3648, 3649, 3650, 3651, 3652, 3653, 3654, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3662, 3663, 3664, 3665, 3666, 3667, 3668, 3669, 3670, 3671, 3672, 3673, 3674, 3675, 3676, 3677, 3678, 3679, 3680, 3681, 3682, 3683, 3684, 3685, 3686, 3687, 3688, 3689, 3690, 3691, 3692, 3693, 3694, 3695, 3696, 3697, 3698, 3699, 3700, 3701, 3702, 3703, 3704, 3705, 3706, 3707, 3708, 3709, 3710, 3711, 3712, 3713, 3714, 3715, 3716, 3717, 3718, 3719, 3720, 3721, 3722, 3723, 3724, 3725, 3726, 3727, 3728, 3729, 3730, 3731, 3732, 3733, 3734, 3735, 3736, 3737, 3738, 3739, 3740, 3741, 3742, 3743, 3744, 3745, 3746, 3747, 3748, 3749, 3750, 3751, 3752, 3753, 3754, 3755, 3756, 3757, 3758, 3759, 3760, 3761, 3762, 3763, 3764, 3765, 3766, 3767, 3768, 3769, 3770, 3771, 3772, 3773, 3774, 3775, 3776, 3777, 3778, 3779, 3780, 3781, 3782, 3783, 3784, 3785, 3786, 3787, 3788, 3789, 3790, 3791, 3792, 3793, 3794, 3795, 3796, 3797, 3798, 3799, 3800, 3801, 3802, 3803, 3804, 3805, 3806, 3807, 3808, 3809, 3810, 3811, 3812, 3813, 3814, 3815, 3816, 3817, 3818, 3819, 3820, 3821, 3822, 3823, 3824, 3825, 3826, 3827, 3828, 3829, 3830, 3831, 3832, 3833, 3834, 3835, 3836, 3837, 3838, 3839, 3840, 3841, 3842, 3843, 3844, 3845, 3846, 3847, 3848, 3849, 3850, 3851, 3852, 3853, 3854, 3855, 3856, 3857, 3858, 3859, 3860, 3861, 3862, 3863, 3864, 3865, 3866, 3867, 3868, 3869, 3870, 3871, 3872, 3873, 3874, 3875, 3876, 3877, 3878, 3879, 3880, 3881, 3882, 3883, 3884, 3885, 3886, 3887, 3888, 3889, 3890, 3891, 3892, 3893, 3894, 3895, 3896, 3897, 3898, 3899, 3900, 3901, 3902, 3903, 3904, 3905, 3906, 3907, 3908, 3909, 3910, 3911, 3912, 3913, 3914, 3915, 3916, 3917, 3918, 3919, 3920, 3921, 3922, 3923, 3924, 3925, 3926, 3927, 3928, 3929, 3930, 3931, 3932, 3933, 3934, 3935, 3936, 3937, 3938, 3939, 3940, 3941, 3942, 3943, 3944, 3945, 3946, 3947, 3948, 3949, 3950, 3951, 3952, 3953, 3954, 3955, 3956, 3957, 3958, 3959, 3960, 3961, 3962, 3963, 3964, 3965, 3966, 3967, 3968, 3969, 3970, 3971, 3972, 3973, 3974, 3975, 3976, 3977, 3978, 3979, 3980, 3981, 3982, 3983, 3984, 3985, 3986, 3987, 3988, 3989, 3990, 3991, 3992, 3993, 3994, 3995, 3996, 3997, 3998, 3999, 4000, 4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008, 4009, 4010, 4011, 4012, 4013, 4014, 4015, 4016, 4017, 4018, 4019, 4020, 4021, 4022, 4023, 4024, 4025, 4026, 4027, 4028, 4029, 4030, 4031, 4032, 4033, 4034, 4035, 4036, 4037, 4038, 4039, 4040, 4041, 4042, 4043, 4044, 4045, 4046, 4047, 4048, 4049, 4050, 4051, 4052, 4053, 4054, 4055, 4056, 4057, 4058, 4059, 4060, 4061, 4062, 4063, 4064, 4065, 4066, 4067, 4068, 4069, 4070, 4071, 4072, 4073, 4074, 4075, 4076, 4077, 4078, 4079, 4080, 4081, 4082, 4083, 4084, 4085, 4086, 4087, 4088, 4089, 4090, 4091, 4092, 4093, 4094, 4095, 4096, 4097, 4098, 4099, 4100, 4101, 4102, 4103, 4104, 4105, 4106, 4107, 4108, 4109, 4110, 4111, 4112, 4113, 4114, 4115, 4116, 4117, 4118, 4119, 4120, 4121, 4122, 4123, 4124, 4125, 4126, 4127, 4128, 4129, 4130, 4131, 4132, 4133, 4134, 4135, 4136, 4137, 4138, 4139, 4140, 4141, 4142, 4143, 4144, 4145, 4146, 4147, 4148, 4149, 4150, 4151, 4152, 4153, 4154, 4155, 4156, 4157, 4158, 4159, 4160, 4161, 4162, 4163, 4164, 4165, 4166, 4167, 4168, 4169, 4170, 4171, 4172, 4173, 4174, 4175, 4176, 4177, 4178, 4179, 4180, 4181, 4182, 4183, 4184, 4185, 4186, 4187, 4188, 4189, 4190, 4191, 4192, 4193, 4194, 4195, 4196, 4197, 4198, 4199, 4200, 4201, 4202, 4203, 4204, 4205, 4206, 4207, 4208, 4209, 4210, 4211, 4212, 4213, 4214, 4215, 4216, 4217, 4218, 4219, 4220, 4221, 4222, 4223, 4224, 4225, 4226, 4227, 4228, 4229, 4230, 4231, 4232, 4233, 4234, 4235, 4236, 4237, 4238, 4239, 4240, 4241, 4242, 4243, 4244, 4245, 4246, 4247, 4248, 4249, 4250, 4251, 4252, 4253, 4254, 4255, 4256, 4257, 4258, 4259, 4260, 4261, 4262, 4263, 4264, 4265, 4266, 4267, 4268, 4269, 4270, 4271, 4272, 4273, 4274, 4275, 4276, 4277, 4278, 4279, 4280, 4281, 4282, 4283, 4284, 4285, 4286, 4287, 4288, 4289, 4290, 4291, 4292, 4293, 4294, 4295, 4296, 4297, 4298, 4299, 4300, 4301, 4302, 4303, 4304, 4305, 4306, 4307, 4308, 4309, 4310, 4311, 4312, 4313, 4314, 4315, 4316, 4317, 4318, 4319, 4320, 4321, 4322, 4323, 4324, 4325, 4326, 4327, 4328, 4329, 4330, 4331, 4332, 4333, 4334, 4335, 4336, 4337, 4338, 4339, 4340, 4341, 4342, 4343, 4344, 4345, 4346, 4347, 4348, 4349, 4350, 4351, 4352, 4353, 4354, 4355, 4356, 4357, 4358, 4359, 4360, 4361, 4362, 4363, 4364, 4365, 4366, 4367, 4368, 4369, 4370, 4371, 4372, 4373, 4374, 4375, 4376, 4377, 4378, 4379, 4380, 4381, 4382, 4383, 4384, 4385, 4386, 4387, 4388, 4389, 4390, 4391, 4392, 4393, 4394, 4395, 4396, 4397, 4398, 4399, 4400, 4401, 4402, 4403, 4404, 4405, 4406, 4407, 4408, 4409, 4410, 4411, 4412, 4413, 4414, 4415, 4416, 4417, 4418, 4419, 4420, 4421, 4422, 4423, 4424, 4425, 4426, 4427, 4428, 4429, 4430, 4431, 4432, 4433, 4434, 4435, 4436, 4437, 4438, 4439, 4440, 4441, 4442, 4443, 4444, 4445, 4446, 4447, 4448, 4449, 4450, 4451, 4452, 4453, 4454, 4455, 4456, 4457, 4458, 4459, 4460, 4461, 4462, 4463, 4464, 4465, 4466, 4467, 4468, 4469, 4470, 4471, 4472, 4473, 4474, 4475, 4476, 4477, 4478, 4479, 4480, 4481, 4482, 4483, 4484, 4485, 4486, 4487, 4488, 4489, 4490, 4491, 4492, 4493, 4494, 4495, 4496, 4497, 4498, 4499, -500, -499, -498, -497, -496, -495, -494, -493, -492, -491, -490, -489, -488, -487, -486, -485, -484, -483, -482, -481, -480, -479, -478, -477, -476, -475, -474, -473, -472, -471, -470, -469, -468, -467, -466, -465, -464, -463, -462, -461, -460, -459, -458, -457, -456, -455, -454, -453, -452, -451, -450, -449, -448, -447, -446, -445, -444, -443, -442, -441, -440, -439, -438, -437, -436, -435, -434, -433, -432, -431, -430, -429, -428, -427, -426, -425, -424, -423, -422, -421, -420, -419, -418, -417, -416, -415, -414, -413, -412, -411, -410, -409, -408, -407, -406, -405, -404, -403, -402, -401, -400, -399, -398, -397, -396, -395, -394, -393, -392, -391, -390, -389, -388, -387, -386, -385, -384, -383, -382, -381, -380, -379, -378, -377, -376, -375, -374, -373, -372, -371, -370, -369, -368, -367, -366, -365, -364, -363, -362, -361, -360, -359, -358, -357, -356, -355, -354, -353, -352, -351, -350, -349, -348, -347, -346, -345, -344, -343, -342, -341, -340, -339, -338, -337, -336, -335, -334, -333, -332, -331, -330, -329, -328, -327, -326, -325, -324, -323, -322, -321, -320, -319, -318, -317, -316, -315, -314, -313, -312, -311, -310, -309, -308, -307, -306, -305, -304, -303, -302, -301, -300, -299, -298, -297, -296, -295, -294, -293, -292, -291, -290, -289, -288, -287, -286, -285, -284, -283, -282, -281, -280, -279, -278, -277, -276, -275, -274, -273, -272, -271, -270, -269, -268, -267, -266, -265, -264, -263, -262, -261, -260, -259, -258, -257, -256, -255, -254, -253, -252, -251, -250, -249, -248, -247, -246, -245, -244, -243, -242, -241, -240, -239, -238, -237, -236, -235, -234, -233, -232, -231, -230, -229, -228, -227, -226, -225, -224, -223, -222, -221, -220, -219, -218, -217, -216, -215, -214, -213, -212, -211, -210, -209, -208, -207, -206, -205, -204, -203, -202, -201, -200, -199, -198, -197, -196, -195, -194, -193, -192, -191, -190, -189, -188, -187, -186, -185, -184, -183, -182, -181, -180, -179, -178, -177, -176, -175, -174, -173, -172, -171, -170, -169, -168, -167, -166, -165, -164, -163, -162, -161, -160, -159]\n0\n```\nand also this one\n```\n[1,2,1,2,1,2,1,2,1,2]\n-1\n```"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, we need to find out cycle means cycle detection.\\nLet\\'s say Two people are running on a circle then definately they meet at any point. If they meet means cycle present. \\n\\n# Approach\\nSo, Here I will use Fast and Slow pointer (Two pointer approach).\\n1- Initialize two pointer slow and fast.\\n2- Initially both are pointing to head.\\n3- When loop run slow pointer move step ahead while fast pointer move it\\'s double.\\n4- If both pointer meet at a particular point it means cycle present other no."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Forget the garbage task.\\n\\nRead the real one:\\nRetuen `True` for neighboring Nodes with equal values, otherwise `False`"
                    },
                    {
                        "username": "arshita129",
                        "content": "neighboring nodes with equal values?? We are not trying to see if neighboring nodes have equal values.\\n"
                    }
                ]
            },
            {
                "id": 2043349,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "What do you mean Daily Question? I\\'ve already solved it on Aug 26, and then resubmitted a couple improvements to the code just the day before yesterday. Where is my steak now?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@tifv](/tifv) yeah I\\'ve just done that, but in a different language from the previous solution."
                    },
                    {
                        "username": "tifv",
                        "content": "One have to resubmit already solved daily questions."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[floyd\\'s algo solution easy explanation](https://leetcode.com/problems/linked-list-cycle/solutions/3773770/two-pointers-fast-and-slow-floyd-s-tortoise-and-hare-algorithm/?envType=daily-question&envId=2023-09-04) found this useful"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why do we need `pos` here?? why??"
                    },
                    {
                        "username": "psionl0",
                        "content": "The LeetCode program will call your ``hasCycle()`` method and verify that its return value is false when ``pos = -1`` and true otherwise. We don't have any access to this value."
                    },
                    {
                        "username": "tifv",
                        "content": "It specifies whether there is a cycle in the testcase or not. `pos >= 0` implies that there is a cycle, `pos == -1` means that there is no cycle."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Is it possible to do this with $O(1)$ space in linear time?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Yes, fast/slow pointers"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Yes but unless we already know the approach it is not obvious."
                    },
                    {
                        "username": "DraculeMihawk",
                        "content": "ahh here we go again."
                    },
                    {
                        "username": "kcharris77",
                        "content": "Good follow up question."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Was hoping for a little challenge today"
                    },
                    {
                        "username": "psionl0",
                        "content": "Try this one: https://leetcode.com/problems/linked-list-cycle-ii/"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "I have one easy solution. I will use cycle detection trick or also known as Fast and slow methods. Let\\'s discuss :\\n1- Take two pointer as fast and slow.\\n2- Slow pointer will move one step while fast pointer will move two times.\\n3- Hence if fast pointer will reach last then slow pointer cover only half distance.\\n4- If any particular node both fast and slower meet, It means list have cycle otherwise cycle not detected.\\n5- If does not meet, in this case fast pointer will point to null.\\n\\nLet me know if above steps are clear otherwise I will provide more explaination."
                    },
                    {
                        "username": "22mca036",
                        "content": "I have pass all the test cases but when pos is -1 i got a error please let me know if someone has faced same issus."
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "        slow, fast = head, head\\n        while True:\\n            fast = fast.next.next\\n            if not fast:\\n                return False\\n            slow = slow.next\\n            if slow == fast:\\n                return True\\n\\nIt shows 3rd line \"fast = fast.next.next\" is error on python3.\\n\\nWhy it is not available?"
                    }
                ]
            },
            {
                "id": 2043322,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "What do you mean Daily Question? I\\'ve already solved it on Aug 26, and then resubmitted a couple improvements to the code just the day before yesterday. Where is my steak now?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@tifv](/tifv) yeah I\\'ve just done that, but in a different language from the previous solution."
                    },
                    {
                        "username": "tifv",
                        "content": "One have to resubmit already solved daily questions."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[floyd\\'s algo solution easy explanation](https://leetcode.com/problems/linked-list-cycle/solutions/3773770/two-pointers-fast-and-slow-floyd-s-tortoise-and-hare-algorithm/?envType=daily-question&envId=2023-09-04) found this useful"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why do we need `pos` here?? why??"
                    },
                    {
                        "username": "psionl0",
                        "content": "The LeetCode program will call your ``hasCycle()`` method and verify that its return value is false when ``pos = -1`` and true otherwise. We don't have any access to this value."
                    },
                    {
                        "username": "tifv",
                        "content": "It specifies whether there is a cycle in the testcase or not. `pos >= 0` implies that there is a cycle, `pos == -1` means that there is no cycle."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Is it possible to do this with $O(1)$ space in linear time?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Yes, fast/slow pointers"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Yes but unless we already know the approach it is not obvious."
                    },
                    {
                        "username": "DraculeMihawk",
                        "content": "ahh here we go again."
                    },
                    {
                        "username": "kcharris77",
                        "content": "Good follow up question."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Was hoping for a little challenge today"
                    },
                    {
                        "username": "psionl0",
                        "content": "Try this one: https://leetcode.com/problems/linked-list-cycle-ii/"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "I have one easy solution. I will use cycle detection trick or also known as Fast and slow methods. Let\\'s discuss :\\n1- Take two pointer as fast and slow.\\n2- Slow pointer will move one step while fast pointer will move two times.\\n3- Hence if fast pointer will reach last then slow pointer cover only half distance.\\n4- If any particular node both fast and slower meet, It means list have cycle otherwise cycle not detected.\\n5- If does not meet, in this case fast pointer will point to null.\\n\\nLet me know if above steps are clear otherwise I will provide more explaination."
                    },
                    {
                        "username": "22mca036",
                        "content": "I have pass all the test cases but when pos is -1 i got a error please let me know if someone has faced same issus."
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "        slow, fast = head, head\\n        while True:\\n            fast = fast.next.next\\n            if not fast:\\n                return False\\n            slow = slow.next\\n            if slow == fast:\\n                return True\\n\\nIt shows 3rd line \"fast = fast.next.next\" is error on python3.\\n\\nWhy it is not available?"
                    }
                ]
            },
            {
                "id": 2043286,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "What do you mean Daily Question? I\\'ve already solved it on Aug 26, and then resubmitted a couple improvements to the code just the day before yesterday. Where is my steak now?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@tifv](/tifv) yeah I\\'ve just done that, but in a different language from the previous solution."
                    },
                    {
                        "username": "tifv",
                        "content": "One have to resubmit already solved daily questions."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[floyd\\'s algo solution easy explanation](https://leetcode.com/problems/linked-list-cycle/solutions/3773770/two-pointers-fast-and-slow-floyd-s-tortoise-and-hare-algorithm/?envType=daily-question&envId=2023-09-04) found this useful"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why do we need `pos` here?? why??"
                    },
                    {
                        "username": "psionl0",
                        "content": "The LeetCode program will call your ``hasCycle()`` method and verify that its return value is false when ``pos = -1`` and true otherwise. We don't have any access to this value."
                    },
                    {
                        "username": "tifv",
                        "content": "It specifies whether there is a cycle in the testcase or not. `pos >= 0` implies that there is a cycle, `pos == -1` means that there is no cycle."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Is it possible to do this with $O(1)$ space in linear time?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Yes, fast/slow pointers"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Yes but unless we already know the approach it is not obvious."
                    },
                    {
                        "username": "DraculeMihawk",
                        "content": "ahh here we go again."
                    },
                    {
                        "username": "kcharris77",
                        "content": "Good follow up question."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Was hoping for a little challenge today"
                    },
                    {
                        "username": "psionl0",
                        "content": "Try this one: https://leetcode.com/problems/linked-list-cycle-ii/"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "I have one easy solution. I will use cycle detection trick or also known as Fast and slow methods. Let\\'s discuss :\\n1- Take two pointer as fast and slow.\\n2- Slow pointer will move one step while fast pointer will move two times.\\n3- Hence if fast pointer will reach last then slow pointer cover only half distance.\\n4- If any particular node both fast and slower meet, It means list have cycle otherwise cycle not detected.\\n5- If does not meet, in this case fast pointer will point to null.\\n\\nLet me know if above steps are clear otherwise I will provide more explaination."
                    },
                    {
                        "username": "22mca036",
                        "content": "I have pass all the test cases but when pos is -1 i got a error please let me know if someone has faced same issus."
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "        slow, fast = head, head\\n        while True:\\n            fast = fast.next.next\\n            if not fast:\\n                return False\\n            slow = slow.next\\n            if slow == fast:\\n                return True\\n\\nIt shows 3rd line \"fast = fast.next.next\" is error on python3.\\n\\nWhy it is not available?"
                    }
                ]
            },
            {
                "id": 2043264,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "What do you mean Daily Question? I\\'ve already solved it on Aug 26, and then resubmitted a couple improvements to the code just the day before yesterday. Where is my steak now?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@tifv](/tifv) yeah I\\'ve just done that, but in a different language from the previous solution."
                    },
                    {
                        "username": "tifv",
                        "content": "One have to resubmit already solved daily questions."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[floyd\\'s algo solution easy explanation](https://leetcode.com/problems/linked-list-cycle/solutions/3773770/two-pointers-fast-and-slow-floyd-s-tortoise-and-hare-algorithm/?envType=daily-question&envId=2023-09-04) found this useful"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why do we need `pos` here?? why??"
                    },
                    {
                        "username": "psionl0",
                        "content": "The LeetCode program will call your ``hasCycle()`` method and verify that its return value is false when ``pos = -1`` and true otherwise. We don't have any access to this value."
                    },
                    {
                        "username": "tifv",
                        "content": "It specifies whether there is a cycle in the testcase or not. `pos >= 0` implies that there is a cycle, `pos == -1` means that there is no cycle."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Is it possible to do this with $O(1)$ space in linear time?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Yes, fast/slow pointers"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Yes but unless we already know the approach it is not obvious."
                    },
                    {
                        "username": "DraculeMihawk",
                        "content": "ahh here we go again."
                    },
                    {
                        "username": "kcharris77",
                        "content": "Good follow up question."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Was hoping for a little challenge today"
                    },
                    {
                        "username": "psionl0",
                        "content": "Try this one: https://leetcode.com/problems/linked-list-cycle-ii/"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "I have one easy solution. I will use cycle detection trick or also known as Fast and slow methods. Let\\'s discuss :\\n1- Take two pointer as fast and slow.\\n2- Slow pointer will move one step while fast pointer will move two times.\\n3- Hence if fast pointer will reach last then slow pointer cover only half distance.\\n4- If any particular node both fast and slower meet, It means list have cycle otherwise cycle not detected.\\n5- If does not meet, in this case fast pointer will point to null.\\n\\nLet me know if above steps are clear otherwise I will provide more explaination."
                    },
                    {
                        "username": "22mca036",
                        "content": "I have pass all the test cases but when pos is -1 i got a error please let me know if someone has faced same issus."
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "        slow, fast = head, head\\n        while True:\\n            fast = fast.next.next\\n            if not fast:\\n                return False\\n            slow = slow.next\\n            if slow == fast:\\n                return True\\n\\nIt shows 3rd line \"fast = fast.next.next\" is error on python3.\\n\\nWhy it is not available?"
                    }
                ]
            },
            {
                "id": 2043263,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "What do you mean Daily Question? I\\'ve already solved it on Aug 26, and then resubmitted a couple improvements to the code just the day before yesterday. Where is my steak now?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@tifv](/tifv) yeah I\\'ve just done that, but in a different language from the previous solution."
                    },
                    {
                        "username": "tifv",
                        "content": "One have to resubmit already solved daily questions."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[floyd\\'s algo solution easy explanation](https://leetcode.com/problems/linked-list-cycle/solutions/3773770/two-pointers-fast-and-slow-floyd-s-tortoise-and-hare-algorithm/?envType=daily-question&envId=2023-09-04) found this useful"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why do we need `pos` here?? why??"
                    },
                    {
                        "username": "psionl0",
                        "content": "The LeetCode program will call your ``hasCycle()`` method and verify that its return value is false when ``pos = -1`` and true otherwise. We don't have any access to this value."
                    },
                    {
                        "username": "tifv",
                        "content": "It specifies whether there is a cycle in the testcase or not. `pos >= 0` implies that there is a cycle, `pos == -1` means that there is no cycle."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Is it possible to do this with $O(1)$ space in linear time?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Yes, fast/slow pointers"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Yes but unless we already know the approach it is not obvious."
                    },
                    {
                        "username": "DraculeMihawk",
                        "content": "ahh here we go again."
                    },
                    {
                        "username": "kcharris77",
                        "content": "Good follow up question."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Was hoping for a little challenge today"
                    },
                    {
                        "username": "psionl0",
                        "content": "Try this one: https://leetcode.com/problems/linked-list-cycle-ii/"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "I have one easy solution. I will use cycle detection trick or also known as Fast and slow methods. Let\\'s discuss :\\n1- Take two pointer as fast and slow.\\n2- Slow pointer will move one step while fast pointer will move two times.\\n3- Hence if fast pointer will reach last then slow pointer cover only half distance.\\n4- If any particular node both fast and slower meet, It means list have cycle otherwise cycle not detected.\\n5- If does not meet, in this case fast pointer will point to null.\\n\\nLet me know if above steps are clear otherwise I will provide more explaination."
                    },
                    {
                        "username": "22mca036",
                        "content": "I have pass all the test cases but when pos is -1 i got a error please let me know if someone has faced same issus."
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "        slow, fast = head, head\\n        while True:\\n            fast = fast.next.next\\n            if not fast:\\n                return False\\n            slow = slow.next\\n            if slow == fast:\\n                return True\\n\\nIt shows 3rd line \"fast = fast.next.next\" is error on python3.\\n\\nWhy it is not available?"
                    }
                ]
            },
            {
                "id": 2043223,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "What do you mean Daily Question? I\\'ve already solved it on Aug 26, and then resubmitted a couple improvements to the code just the day before yesterday. Where is my steak now?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@tifv](/tifv) yeah I\\'ve just done that, but in a different language from the previous solution."
                    },
                    {
                        "username": "tifv",
                        "content": "One have to resubmit already solved daily questions."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[floyd\\'s algo solution easy explanation](https://leetcode.com/problems/linked-list-cycle/solutions/3773770/two-pointers-fast-and-slow-floyd-s-tortoise-and-hare-algorithm/?envType=daily-question&envId=2023-09-04) found this useful"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why do we need `pos` here?? why??"
                    },
                    {
                        "username": "psionl0",
                        "content": "The LeetCode program will call your ``hasCycle()`` method and verify that its return value is false when ``pos = -1`` and true otherwise. We don't have any access to this value."
                    },
                    {
                        "username": "tifv",
                        "content": "It specifies whether there is a cycle in the testcase or not. `pos >= 0` implies that there is a cycle, `pos == -1` means that there is no cycle."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Is it possible to do this with $O(1)$ space in linear time?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Yes, fast/slow pointers"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Yes but unless we already know the approach it is not obvious."
                    },
                    {
                        "username": "DraculeMihawk",
                        "content": "ahh here we go again."
                    },
                    {
                        "username": "kcharris77",
                        "content": "Good follow up question."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Was hoping for a little challenge today"
                    },
                    {
                        "username": "psionl0",
                        "content": "Try this one: https://leetcode.com/problems/linked-list-cycle-ii/"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "I have one easy solution. I will use cycle detection trick or also known as Fast and slow methods. Let\\'s discuss :\\n1- Take two pointer as fast and slow.\\n2- Slow pointer will move one step while fast pointer will move two times.\\n3- Hence if fast pointer will reach last then slow pointer cover only half distance.\\n4- If any particular node both fast and slower meet, It means list have cycle otherwise cycle not detected.\\n5- If does not meet, in this case fast pointer will point to null.\\n\\nLet me know if above steps are clear otherwise I will provide more explaination."
                    },
                    {
                        "username": "22mca036",
                        "content": "I have pass all the test cases but when pos is -1 i got a error please let me know if someone has faced same issus."
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "        slow, fast = head, head\\n        while True:\\n            fast = fast.next.next\\n            if not fast:\\n                return False\\n            slow = slow.next\\n            if slow == fast:\\n                return True\\n\\nIt shows 3rd line \"fast = fast.next.next\" is error on python3.\\n\\nWhy it is not available?"
                    }
                ]
            },
            {
                "id": 2043217,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "What do you mean Daily Question? I\\'ve already solved it on Aug 26, and then resubmitted a couple improvements to the code just the day before yesterday. Where is my steak now?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@tifv](/tifv) yeah I\\'ve just done that, but in a different language from the previous solution."
                    },
                    {
                        "username": "tifv",
                        "content": "One have to resubmit already solved daily questions."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[floyd\\'s algo solution easy explanation](https://leetcode.com/problems/linked-list-cycle/solutions/3773770/two-pointers-fast-and-slow-floyd-s-tortoise-and-hare-algorithm/?envType=daily-question&envId=2023-09-04) found this useful"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why do we need `pos` here?? why??"
                    },
                    {
                        "username": "psionl0",
                        "content": "The LeetCode program will call your ``hasCycle()`` method and verify that its return value is false when ``pos = -1`` and true otherwise. We don't have any access to this value."
                    },
                    {
                        "username": "tifv",
                        "content": "It specifies whether there is a cycle in the testcase or not. `pos >= 0` implies that there is a cycle, `pos == -1` means that there is no cycle."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Is it possible to do this with $O(1)$ space in linear time?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Yes, fast/slow pointers"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Yes but unless we already know the approach it is not obvious."
                    },
                    {
                        "username": "DraculeMihawk",
                        "content": "ahh here we go again."
                    },
                    {
                        "username": "kcharris77",
                        "content": "Good follow up question."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Was hoping for a little challenge today"
                    },
                    {
                        "username": "psionl0",
                        "content": "Try this one: https://leetcode.com/problems/linked-list-cycle-ii/"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "I have one easy solution. I will use cycle detection trick or also known as Fast and slow methods. Let\\'s discuss :\\n1- Take two pointer as fast and slow.\\n2- Slow pointer will move one step while fast pointer will move two times.\\n3- Hence if fast pointer will reach last then slow pointer cover only half distance.\\n4- If any particular node both fast and slower meet, It means list have cycle otherwise cycle not detected.\\n5- If does not meet, in this case fast pointer will point to null.\\n\\nLet me know if above steps are clear otherwise I will provide more explaination."
                    },
                    {
                        "username": "22mca036",
                        "content": "I have pass all the test cases but when pos is -1 i got a error please let me know if someone has faced same issus."
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "        slow, fast = head, head\\n        while True:\\n            fast = fast.next.next\\n            if not fast:\\n                return False\\n            slow = slow.next\\n            if slow == fast:\\n                return True\\n\\nIt shows 3rd line \"fast = fast.next.next\" is error on python3.\\n\\nWhy it is not available?"
                    }
                ]
            },
            {
                "id": 2038484,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "What do you mean Daily Question? I\\'ve already solved it on Aug 26, and then resubmitted a couple improvements to the code just the day before yesterday. Where is my steak now?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@tifv](/tifv) yeah I\\'ve just done that, but in a different language from the previous solution."
                    },
                    {
                        "username": "tifv",
                        "content": "One have to resubmit already solved daily questions."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[floyd\\'s algo solution easy explanation](https://leetcode.com/problems/linked-list-cycle/solutions/3773770/two-pointers-fast-and-slow-floyd-s-tortoise-and-hare-algorithm/?envType=daily-question&envId=2023-09-04) found this useful"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why do we need `pos` here?? why??"
                    },
                    {
                        "username": "psionl0",
                        "content": "The LeetCode program will call your ``hasCycle()`` method and verify that its return value is false when ``pos = -1`` and true otherwise. We don't have any access to this value."
                    },
                    {
                        "username": "tifv",
                        "content": "It specifies whether there is a cycle in the testcase or not. `pos >= 0` implies that there is a cycle, `pos == -1` means that there is no cycle."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Is it possible to do this with $O(1)$ space in linear time?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Yes, fast/slow pointers"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Yes but unless we already know the approach it is not obvious."
                    },
                    {
                        "username": "DraculeMihawk",
                        "content": "ahh here we go again."
                    },
                    {
                        "username": "kcharris77",
                        "content": "Good follow up question."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Was hoping for a little challenge today"
                    },
                    {
                        "username": "psionl0",
                        "content": "Try this one: https://leetcode.com/problems/linked-list-cycle-ii/"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "I have one easy solution. I will use cycle detection trick or also known as Fast and slow methods. Let\\'s discuss :\\n1- Take two pointer as fast and slow.\\n2- Slow pointer will move one step while fast pointer will move two times.\\n3- Hence if fast pointer will reach last then slow pointer cover only half distance.\\n4- If any particular node both fast and slower meet, It means list have cycle otherwise cycle not detected.\\n5- If does not meet, in this case fast pointer will point to null.\\n\\nLet me know if above steps are clear otherwise I will provide more explaination."
                    },
                    {
                        "username": "22mca036",
                        "content": "I have pass all the test cases but when pos is -1 i got a error please let me know if someone has faced same issus."
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "        slow, fast = head, head\\n        while True:\\n            fast = fast.next.next\\n            if not fast:\\n                return False\\n            slow = slow.next\\n            if slow == fast:\\n                return True\\n\\nIt shows 3rd line \"fast = fast.next.next\" is error on python3.\\n\\nWhy it is not available?"
                    }
                ]
            },
            {
                "id": 2038146,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "What do you mean Daily Question? I\\'ve already solved it on Aug 26, and then resubmitted a couple improvements to the code just the day before yesterday. Where is my steak now?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@tifv](/tifv) yeah I\\'ve just done that, but in a different language from the previous solution."
                    },
                    {
                        "username": "tifv",
                        "content": "One have to resubmit already solved daily questions."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[floyd\\'s algo solution easy explanation](https://leetcode.com/problems/linked-list-cycle/solutions/3773770/two-pointers-fast-and-slow-floyd-s-tortoise-and-hare-algorithm/?envType=daily-question&envId=2023-09-04) found this useful"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why do we need `pos` here?? why??"
                    },
                    {
                        "username": "psionl0",
                        "content": "The LeetCode program will call your ``hasCycle()`` method and verify that its return value is false when ``pos = -1`` and true otherwise. We don't have any access to this value."
                    },
                    {
                        "username": "tifv",
                        "content": "It specifies whether there is a cycle in the testcase or not. `pos >= 0` implies that there is a cycle, `pos == -1` means that there is no cycle."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Is it possible to do this with $O(1)$ space in linear time?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Yes, fast/slow pointers"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Yes but unless we already know the approach it is not obvious."
                    },
                    {
                        "username": "DraculeMihawk",
                        "content": "ahh here we go again."
                    },
                    {
                        "username": "kcharris77",
                        "content": "Good follow up question."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Was hoping for a little challenge today"
                    },
                    {
                        "username": "psionl0",
                        "content": "Try this one: https://leetcode.com/problems/linked-list-cycle-ii/"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "I have one easy solution. I will use cycle detection trick or also known as Fast and slow methods. Let\\'s discuss :\\n1- Take two pointer as fast and slow.\\n2- Slow pointer will move one step while fast pointer will move two times.\\n3- Hence if fast pointer will reach last then slow pointer cover only half distance.\\n4- If any particular node both fast and slower meet, It means list have cycle otherwise cycle not detected.\\n5- If does not meet, in this case fast pointer will point to null.\\n\\nLet me know if above steps are clear otherwise I will provide more explaination."
                    },
                    {
                        "username": "22mca036",
                        "content": "I have pass all the test cases but when pos is -1 i got a error please let me know if someone has faced same issus."
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "        slow, fast = head, head\\n        while True:\\n            fast = fast.next.next\\n            if not fast:\\n                return False\\n            slow = slow.next\\n            if slow == fast:\\n                return True\\n\\nIt shows 3rd line \"fast = fast.next.next\" is error on python3.\\n\\nWhy it is not available?"
                    }
                ]
            },
            {
                "id": 2017282,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "What do you mean Daily Question? I\\'ve already solved it on Aug 26, and then resubmitted a couple improvements to the code just the day before yesterday. Where is my steak now?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@tifv](/tifv) yeah I\\'ve just done that, but in a different language from the previous solution."
                    },
                    {
                        "username": "tifv",
                        "content": "One have to resubmit already solved daily questions."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[floyd\\'s algo solution easy explanation](https://leetcode.com/problems/linked-list-cycle/solutions/3773770/two-pointers-fast-and-slow-floyd-s-tortoise-and-hare-algorithm/?envType=daily-question&envId=2023-09-04) found this useful"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why do we need `pos` here?? why??"
                    },
                    {
                        "username": "psionl0",
                        "content": "The LeetCode program will call your ``hasCycle()`` method and verify that its return value is false when ``pos = -1`` and true otherwise. We don't have any access to this value."
                    },
                    {
                        "username": "tifv",
                        "content": "It specifies whether there is a cycle in the testcase or not. `pos >= 0` implies that there is a cycle, `pos == -1` means that there is no cycle."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Is it possible to do this with $O(1)$ space in linear time?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Yes, fast/slow pointers"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Yes but unless we already know the approach it is not obvious."
                    },
                    {
                        "username": "DraculeMihawk",
                        "content": "ahh here we go again."
                    },
                    {
                        "username": "kcharris77",
                        "content": "Good follow up question."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Was hoping for a little challenge today"
                    },
                    {
                        "username": "psionl0",
                        "content": "Try this one: https://leetcode.com/problems/linked-list-cycle-ii/"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "I have one easy solution. I will use cycle detection trick or also known as Fast and slow methods. Let\\'s discuss :\\n1- Take two pointer as fast and slow.\\n2- Slow pointer will move one step while fast pointer will move two times.\\n3- Hence if fast pointer will reach last then slow pointer cover only half distance.\\n4- If any particular node both fast and slower meet, It means list have cycle otherwise cycle not detected.\\n5- If does not meet, in this case fast pointer will point to null.\\n\\nLet me know if above steps are clear otherwise I will provide more explaination."
                    },
                    {
                        "username": "22mca036",
                        "content": "I have pass all the test cases but when pos is -1 i got a error please let me know if someone has faced same issus."
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "        slow, fast = head, head\\n        while True:\\n            fast = fast.next.next\\n            if not fast:\\n                return False\\n            slow = slow.next\\n            if slow == fast:\\n                return True\\n\\nIt shows 3rd line \"fast = fast.next.next\" is error on python3.\\n\\nWhy it is not available?"
                    }
                ]
            },
            {
                "id": 2012400,
                "content": [
                    {
                        "username": "Prat_2030",
                        "content": "\\n\\n1. Version with Array (nums):\\nIn the first version, the slow and fast pointers are used in the context of manipulating an array. This is often used in cyclic arrays or sequences where you want to detect cycles or perform some other operation. The idea is that the fast pointer advances faster than the slow pointer, and they might eventually meet or cross paths if there\\'s a cycle. This version is commonly used in algorithms like Floyd\\'s cycle detection algorithm for finding cycles in linked lists or arrays.\\nExample use cases:\\n\\nDetecting cycles in an array or linked list.\\nFinding the duplicate element in an array (Floyd\\'s Tortoise and Hare algorithm).\\n\\n```cpp\\n#include <iostream>\\n#include <vector>\\n\\nbool hasCycle(const std::vector<int>& nums) {\\n    int slow = 0, fast = 0;\\n    while (true) {\\n        slow = nums[slow];\\n        fast = nums[nums[fast]];\\n        if (slow == fast) {\\n            return true; // Cycle detected\\n        }\\n        if (slow < 0 || fast < 0 || fast >= nums.size()) {\\n            return false; // No cycle\\n        }\\n    }\\n}\\n\\nint main() {\\n    std::vector<int> nums = {2, 5, 1, 3, 4, 2}; // Example cyclic array\\n    bool hasCycleResult = hasCycle(nums);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n    return 0;\\n}\\n```\\n\\n2. Version with Linked List:\\nIn the second version, the slow and fast pointers are used in the context of a singly linked list. The fast pointer advances by two steps while the slow pointer advances by one step. This approach is often used for operations that require traversing or processing a linked list in a certain way.\\n\\nExample use cases:\\n\\nDetecting a loop in a linked list (similar to Floyd\\'s cycle detection in arrays).\\nFinding the middle element of a linked list.\\nChecking for palindromes in a linked list.\\nMerging two sorted linked lists.\\n\\n```cpp\\n#include <iostream>\\n\\nstruct ListNode {\\n    int val;\\n    ListNode* next;\\n    ListNode(int val) : val(val), next(nullptr) {}\\n};\\n\\nbool hasCycle(ListNode* head) {\\n    if (!head || !head->next) {\\n        return false; // No cycle with 0 or 1 nodes\\n    }\\n    ListNode* slow = head->next;\\n    ListNode* fast = head->next->next;\\n    while (slow != fast) {\\n        if (!fast || !fast->next) {\\n            return false; // No cycle\\n        }\\n        slow = slow->next;\\n        fast = fast->next->next;\\n    }\\n    return true; // Cycle detected\\n}\\n\\nint main() {\\n    // Example linked list with a cycle\\n    ListNode* head = new ListNode(3);\\n    head->next = new ListNode(2);\\n    head->next->next = new ListNode(0);\\n    head->next->next->next = new ListNode(-4);\\n    head->next->next->next->next = head->next; // Creating a cycle\\n\\n    bool hasCycleResult = hasCycle(head);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n\\n    // Clean up memory (not shown in the example)\\n    return 0;\\n}\\n```\\n\\nWhen to use each version:\\n\\nVersion with Array (nums):\\nUse this version when you\\'re dealing with cyclic arrays or sequences, and you need to detect cycles or perform operations related to cycles.\\nVersion with Linked List:\\nUse this version when you\\'re working with linked lists and need to traverse, manipulate, or perform specific operations like detecting loops, finding middle elements, or merging lists."
                    },
                    {
                        "username": "tawashi105",
                        "content": "The \"Input\" (e.g. head=[1], pos=1) in this problem explanation, is not input to the hasCycle function, it is input to the function which produces a ListNode instance, right?\nIf this is true, this explanation is too confusing. I wasted 2 hours."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "detecting cycles is actually a simple solution. All the question is saying that i am passing the initial node\\'s address you check weather it has a loop in it or not neverthless. Congratulations on your progress so far!"
                    },
                    {
                        "username": "louislhotte",
                        "content": "Funny problem. My answer was accepted, but it turns out it was a famous algorithm that we needed to use which was much more efficient! "
                    },
                    {
                        "username": "user8763jW",
                        "content": "class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (head == NULL || head->next == NULL )\\n          return false;\\n        ListNode* slow;\\n        ListNode* fast;\\n        bool t =0;\\n        slow = head;\\n        fast = head;\\n        while (slow->next && fast->next->next)\\n        {\\n            if (slow == fast)\\n           { \\n           t=1;\\n           break;\\n           }\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        return t?1:0;\\n    }\\n};\\n\\n\\n\\nwhy above code failed for \\n[-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5]\\n\\n\\n"
                    },
                    {
                        "username": "user5388FE",
                        "content": "I don\\'t really understand this question, what does cycle mean, how does -4 point to 2??? doesn\\'t the tail of the LL point to null?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@Lokadithya_M](/Lokadithya_M) Given input format: head = [3,2,0,-4], pos = 1 means that the last element -4 i.e. the tail is linked to pos=1 i.e. 2. \\n\\nPos is given with 0-index notation.  Hence, thats the difference here tail doesn\\'t point to null but an element in the list."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "read about circular linked lists  you will understand\\n"
                    },
                    {
                        "username": "Ravi_kant123",
                        "content": "Intution for this problem is if there is a cycle present in present that means we are again traversing over the nodes which we have already encounter. simple use maps to store nodes if node is already present that means there is a cycle.\\naccording to me this one is the most simple solution.\\nthere are other methods also like Floyed cyle detection you guys can also check out that.\\n\\nand in this question pos is in question just to clarify us that yes cycle is present otherwise how will they tell us. so don\\'t worry about that just solve the problem"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "quick neat method?\\n\\ntry using the Floyd cycle method. "
                    },
                    {
                        "username": "Kilderon",
                        "content": "How can i emulate this testcases in my IDE using java?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "You will have to build the whole linked list and then just pass the head as input. "
                    },
                    {
                        "username": "balinome",
                        "content": "i dont understand the 2 pointer approach , lets say we start : slow* = head and fast* = head and the slow moves 1 node at a time and fast moves 2 nodes at a time , what id the cycle is on the second and 4th nodes , the fast will not even get to those nodes ??? the fast will go from 1st to 3rd to 5th , like i just dont understand the logic "
                    },
                    {
                        "username": "Emerold",
                        "content": "If there is a cycle, eventually, you enter it, as this list is a linked list and we go from the front to the end. If the second node is part of the cycle and the second node points to the third node (by definition), the third node is also part of the cycle. You cannot have the situation that the second and 4th node are part of the cycle but the third node is not.\\n\\nAnd then, you can use the logic of the walker and runner variable.\\n\\nOnce, the runner is in the cycle, we will just run around it again and again. Yes, it skips one node every time, but this doesn\\'t matter yet. Assuming, the runner is already in the cycle going in circles, the walker will eventually reach that cycle, too (if it exists).\\n\\nNow, we have the following situation: The runner moves to steps a time, the walker moves one step a time. Lets say, the gap between the runner is of length n. Every time the walker moves one step and the runner moves two steps, this length between the two gets reduced by exactly one. As this gap gets smaller by exactly one per iteration, you will not jump over the walker with the runner by doing two steps at a time while the walker does one.\\n\\nBy that, you will eventually get the situation, that the runner is equal to the walker (if there exists a circle). \\n\\nTo be honest, in the beginning, it was confusing for me, too, that the runner wont skip over the walker. But this argument of the gap getting smaller only by one per iteration answered, why we can\\'t skip over the walker with the runner without having the equality first."
                    },
                    {
                        "username": "ankush57",
                        "content": "`class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        \\n            if(head == NULL || head -> next == NULL)return false ;\\n\\n            int count = 10001 ;\\n\\n            while(count){\\n\\n                if(!head)return false ;\\n\\n                head = head -> next ;\\n                count-- ;\\n            } \\n\\n            return true ;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1990029,
                "content": [
                    {
                        "username": "Prat_2030",
                        "content": "\\n\\n1. Version with Array (nums):\\nIn the first version, the slow and fast pointers are used in the context of manipulating an array. This is often used in cyclic arrays or sequences where you want to detect cycles or perform some other operation. The idea is that the fast pointer advances faster than the slow pointer, and they might eventually meet or cross paths if there\\'s a cycle. This version is commonly used in algorithms like Floyd\\'s cycle detection algorithm for finding cycles in linked lists or arrays.\\nExample use cases:\\n\\nDetecting cycles in an array or linked list.\\nFinding the duplicate element in an array (Floyd\\'s Tortoise and Hare algorithm).\\n\\n```cpp\\n#include <iostream>\\n#include <vector>\\n\\nbool hasCycle(const std::vector<int>& nums) {\\n    int slow = 0, fast = 0;\\n    while (true) {\\n        slow = nums[slow];\\n        fast = nums[nums[fast]];\\n        if (slow == fast) {\\n            return true; // Cycle detected\\n        }\\n        if (slow < 0 || fast < 0 || fast >= nums.size()) {\\n            return false; // No cycle\\n        }\\n    }\\n}\\n\\nint main() {\\n    std::vector<int> nums = {2, 5, 1, 3, 4, 2}; // Example cyclic array\\n    bool hasCycleResult = hasCycle(nums);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n    return 0;\\n}\\n```\\n\\n2. Version with Linked List:\\nIn the second version, the slow and fast pointers are used in the context of a singly linked list. The fast pointer advances by two steps while the slow pointer advances by one step. This approach is often used for operations that require traversing or processing a linked list in a certain way.\\n\\nExample use cases:\\n\\nDetecting a loop in a linked list (similar to Floyd\\'s cycle detection in arrays).\\nFinding the middle element of a linked list.\\nChecking for palindromes in a linked list.\\nMerging two sorted linked lists.\\n\\n```cpp\\n#include <iostream>\\n\\nstruct ListNode {\\n    int val;\\n    ListNode* next;\\n    ListNode(int val) : val(val), next(nullptr) {}\\n};\\n\\nbool hasCycle(ListNode* head) {\\n    if (!head || !head->next) {\\n        return false; // No cycle with 0 or 1 nodes\\n    }\\n    ListNode* slow = head->next;\\n    ListNode* fast = head->next->next;\\n    while (slow != fast) {\\n        if (!fast || !fast->next) {\\n            return false; // No cycle\\n        }\\n        slow = slow->next;\\n        fast = fast->next->next;\\n    }\\n    return true; // Cycle detected\\n}\\n\\nint main() {\\n    // Example linked list with a cycle\\n    ListNode* head = new ListNode(3);\\n    head->next = new ListNode(2);\\n    head->next->next = new ListNode(0);\\n    head->next->next->next = new ListNode(-4);\\n    head->next->next->next->next = head->next; // Creating a cycle\\n\\n    bool hasCycleResult = hasCycle(head);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n\\n    // Clean up memory (not shown in the example)\\n    return 0;\\n}\\n```\\n\\nWhen to use each version:\\n\\nVersion with Array (nums):\\nUse this version when you\\'re dealing with cyclic arrays or sequences, and you need to detect cycles or perform operations related to cycles.\\nVersion with Linked List:\\nUse this version when you\\'re working with linked lists and need to traverse, manipulate, or perform specific operations like detecting loops, finding middle elements, or merging lists."
                    },
                    {
                        "username": "tawashi105",
                        "content": "The \"Input\" (e.g. head=[1], pos=1) in this problem explanation, is not input to the hasCycle function, it is input to the function which produces a ListNode instance, right?\nIf this is true, this explanation is too confusing. I wasted 2 hours."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "detecting cycles is actually a simple solution. All the question is saying that i am passing the initial node\\'s address you check weather it has a loop in it or not neverthless. Congratulations on your progress so far!"
                    },
                    {
                        "username": "louislhotte",
                        "content": "Funny problem. My answer was accepted, but it turns out it was a famous algorithm that we needed to use which was much more efficient! "
                    },
                    {
                        "username": "user8763jW",
                        "content": "class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (head == NULL || head->next == NULL )\\n          return false;\\n        ListNode* slow;\\n        ListNode* fast;\\n        bool t =0;\\n        slow = head;\\n        fast = head;\\n        while (slow->next && fast->next->next)\\n        {\\n            if (slow == fast)\\n           { \\n           t=1;\\n           break;\\n           }\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        return t?1:0;\\n    }\\n};\\n\\n\\n\\nwhy above code failed for \\n[-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5]\\n\\n\\n"
                    },
                    {
                        "username": "user5388FE",
                        "content": "I don\\'t really understand this question, what does cycle mean, how does -4 point to 2??? doesn\\'t the tail of the LL point to null?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@Lokadithya_M](/Lokadithya_M) Given input format: head = [3,2,0,-4], pos = 1 means that the last element -4 i.e. the tail is linked to pos=1 i.e. 2. \\n\\nPos is given with 0-index notation.  Hence, thats the difference here tail doesn\\'t point to null but an element in the list."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "read about circular linked lists  you will understand\\n"
                    },
                    {
                        "username": "Ravi_kant123",
                        "content": "Intution for this problem is if there is a cycle present in present that means we are again traversing over the nodes which we have already encounter. simple use maps to store nodes if node is already present that means there is a cycle.\\naccording to me this one is the most simple solution.\\nthere are other methods also like Floyed cyle detection you guys can also check out that.\\n\\nand in this question pos is in question just to clarify us that yes cycle is present otherwise how will they tell us. so don\\'t worry about that just solve the problem"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "quick neat method?\\n\\ntry using the Floyd cycle method. "
                    },
                    {
                        "username": "Kilderon",
                        "content": "How can i emulate this testcases in my IDE using java?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "You will have to build the whole linked list and then just pass the head as input. "
                    },
                    {
                        "username": "balinome",
                        "content": "i dont understand the 2 pointer approach , lets say we start : slow* = head and fast* = head and the slow moves 1 node at a time and fast moves 2 nodes at a time , what id the cycle is on the second and 4th nodes , the fast will not even get to those nodes ??? the fast will go from 1st to 3rd to 5th , like i just dont understand the logic "
                    },
                    {
                        "username": "Emerold",
                        "content": "If there is a cycle, eventually, you enter it, as this list is a linked list and we go from the front to the end. If the second node is part of the cycle and the second node points to the third node (by definition), the third node is also part of the cycle. You cannot have the situation that the second and 4th node are part of the cycle but the third node is not.\\n\\nAnd then, you can use the logic of the walker and runner variable.\\n\\nOnce, the runner is in the cycle, we will just run around it again and again. Yes, it skips one node every time, but this doesn\\'t matter yet. Assuming, the runner is already in the cycle going in circles, the walker will eventually reach that cycle, too (if it exists).\\n\\nNow, we have the following situation: The runner moves to steps a time, the walker moves one step a time. Lets say, the gap between the runner is of length n. Every time the walker moves one step and the runner moves two steps, this length between the two gets reduced by exactly one. As this gap gets smaller by exactly one per iteration, you will not jump over the walker with the runner by doing two steps at a time while the walker does one.\\n\\nBy that, you will eventually get the situation, that the runner is equal to the walker (if there exists a circle). \\n\\nTo be honest, in the beginning, it was confusing for me, too, that the runner wont skip over the walker. But this argument of the gap getting smaller only by one per iteration answered, why we can\\'t skip over the walker with the runner without having the equality first."
                    },
                    {
                        "username": "ankush57",
                        "content": "`class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        \\n            if(head == NULL || head -> next == NULL)return false ;\\n\\n            int count = 10001 ;\\n\\n            while(count){\\n\\n                if(!head)return false ;\\n\\n                head = head -> next ;\\n                count-- ;\\n            } \\n\\n            return true ;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1982710,
                "content": [
                    {
                        "username": "Prat_2030",
                        "content": "\\n\\n1. Version with Array (nums):\\nIn the first version, the slow and fast pointers are used in the context of manipulating an array. This is often used in cyclic arrays or sequences where you want to detect cycles or perform some other operation. The idea is that the fast pointer advances faster than the slow pointer, and they might eventually meet or cross paths if there\\'s a cycle. This version is commonly used in algorithms like Floyd\\'s cycle detection algorithm for finding cycles in linked lists or arrays.\\nExample use cases:\\n\\nDetecting cycles in an array or linked list.\\nFinding the duplicate element in an array (Floyd\\'s Tortoise and Hare algorithm).\\n\\n```cpp\\n#include <iostream>\\n#include <vector>\\n\\nbool hasCycle(const std::vector<int>& nums) {\\n    int slow = 0, fast = 0;\\n    while (true) {\\n        slow = nums[slow];\\n        fast = nums[nums[fast]];\\n        if (slow == fast) {\\n            return true; // Cycle detected\\n        }\\n        if (slow < 0 || fast < 0 || fast >= nums.size()) {\\n            return false; // No cycle\\n        }\\n    }\\n}\\n\\nint main() {\\n    std::vector<int> nums = {2, 5, 1, 3, 4, 2}; // Example cyclic array\\n    bool hasCycleResult = hasCycle(nums);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n    return 0;\\n}\\n```\\n\\n2. Version with Linked List:\\nIn the second version, the slow and fast pointers are used in the context of a singly linked list. The fast pointer advances by two steps while the slow pointer advances by one step. This approach is often used for operations that require traversing or processing a linked list in a certain way.\\n\\nExample use cases:\\n\\nDetecting a loop in a linked list (similar to Floyd\\'s cycle detection in arrays).\\nFinding the middle element of a linked list.\\nChecking for palindromes in a linked list.\\nMerging two sorted linked lists.\\n\\n```cpp\\n#include <iostream>\\n\\nstruct ListNode {\\n    int val;\\n    ListNode* next;\\n    ListNode(int val) : val(val), next(nullptr) {}\\n};\\n\\nbool hasCycle(ListNode* head) {\\n    if (!head || !head->next) {\\n        return false; // No cycle with 0 or 1 nodes\\n    }\\n    ListNode* slow = head->next;\\n    ListNode* fast = head->next->next;\\n    while (slow != fast) {\\n        if (!fast || !fast->next) {\\n            return false; // No cycle\\n        }\\n        slow = slow->next;\\n        fast = fast->next->next;\\n    }\\n    return true; // Cycle detected\\n}\\n\\nint main() {\\n    // Example linked list with a cycle\\n    ListNode* head = new ListNode(3);\\n    head->next = new ListNode(2);\\n    head->next->next = new ListNode(0);\\n    head->next->next->next = new ListNode(-4);\\n    head->next->next->next->next = head->next; // Creating a cycle\\n\\n    bool hasCycleResult = hasCycle(head);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n\\n    // Clean up memory (not shown in the example)\\n    return 0;\\n}\\n```\\n\\nWhen to use each version:\\n\\nVersion with Array (nums):\\nUse this version when you\\'re dealing with cyclic arrays or sequences, and you need to detect cycles or perform operations related to cycles.\\nVersion with Linked List:\\nUse this version when you\\'re working with linked lists and need to traverse, manipulate, or perform specific operations like detecting loops, finding middle elements, or merging lists."
                    },
                    {
                        "username": "tawashi105",
                        "content": "The \"Input\" (e.g. head=[1], pos=1) in this problem explanation, is not input to the hasCycle function, it is input to the function which produces a ListNode instance, right?\nIf this is true, this explanation is too confusing. I wasted 2 hours."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "detecting cycles is actually a simple solution. All the question is saying that i am passing the initial node\\'s address you check weather it has a loop in it or not neverthless. Congratulations on your progress so far!"
                    },
                    {
                        "username": "louislhotte",
                        "content": "Funny problem. My answer was accepted, but it turns out it was a famous algorithm that we needed to use which was much more efficient! "
                    },
                    {
                        "username": "user8763jW",
                        "content": "class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (head == NULL || head->next == NULL )\\n          return false;\\n        ListNode* slow;\\n        ListNode* fast;\\n        bool t =0;\\n        slow = head;\\n        fast = head;\\n        while (slow->next && fast->next->next)\\n        {\\n            if (slow == fast)\\n           { \\n           t=1;\\n           break;\\n           }\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        return t?1:0;\\n    }\\n};\\n\\n\\n\\nwhy above code failed for \\n[-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5]\\n\\n\\n"
                    },
                    {
                        "username": "user5388FE",
                        "content": "I don\\'t really understand this question, what does cycle mean, how does -4 point to 2??? doesn\\'t the tail of the LL point to null?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@Lokadithya_M](/Lokadithya_M) Given input format: head = [3,2,0,-4], pos = 1 means that the last element -4 i.e. the tail is linked to pos=1 i.e. 2. \\n\\nPos is given with 0-index notation.  Hence, thats the difference here tail doesn\\'t point to null but an element in the list."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "read about circular linked lists  you will understand\\n"
                    },
                    {
                        "username": "Ravi_kant123",
                        "content": "Intution for this problem is if there is a cycle present in present that means we are again traversing over the nodes which we have already encounter. simple use maps to store nodes if node is already present that means there is a cycle.\\naccording to me this one is the most simple solution.\\nthere are other methods also like Floyed cyle detection you guys can also check out that.\\n\\nand in this question pos is in question just to clarify us that yes cycle is present otherwise how will they tell us. so don\\'t worry about that just solve the problem"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "quick neat method?\\n\\ntry using the Floyd cycle method. "
                    },
                    {
                        "username": "Kilderon",
                        "content": "How can i emulate this testcases in my IDE using java?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "You will have to build the whole linked list and then just pass the head as input. "
                    },
                    {
                        "username": "balinome",
                        "content": "i dont understand the 2 pointer approach , lets say we start : slow* = head and fast* = head and the slow moves 1 node at a time and fast moves 2 nodes at a time , what id the cycle is on the second and 4th nodes , the fast will not even get to those nodes ??? the fast will go from 1st to 3rd to 5th , like i just dont understand the logic "
                    },
                    {
                        "username": "Emerold",
                        "content": "If there is a cycle, eventually, you enter it, as this list is a linked list and we go from the front to the end. If the second node is part of the cycle and the second node points to the third node (by definition), the third node is also part of the cycle. You cannot have the situation that the second and 4th node are part of the cycle but the third node is not.\\n\\nAnd then, you can use the logic of the walker and runner variable.\\n\\nOnce, the runner is in the cycle, we will just run around it again and again. Yes, it skips one node every time, but this doesn\\'t matter yet. Assuming, the runner is already in the cycle going in circles, the walker will eventually reach that cycle, too (if it exists).\\n\\nNow, we have the following situation: The runner moves to steps a time, the walker moves one step a time. Lets say, the gap between the runner is of length n. Every time the walker moves one step and the runner moves two steps, this length between the two gets reduced by exactly one. As this gap gets smaller by exactly one per iteration, you will not jump over the walker with the runner by doing two steps at a time while the walker does one.\\n\\nBy that, you will eventually get the situation, that the runner is equal to the walker (if there exists a circle). \\n\\nTo be honest, in the beginning, it was confusing for me, too, that the runner wont skip over the walker. But this argument of the gap getting smaller only by one per iteration answered, why we can\\'t skip over the walker with the runner without having the equality first."
                    },
                    {
                        "username": "ankush57",
                        "content": "`class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        \\n            if(head == NULL || head -> next == NULL)return false ;\\n\\n            int count = 10001 ;\\n\\n            while(count){\\n\\n                if(!head)return false ;\\n\\n                head = head -> next ;\\n                count-- ;\\n            } \\n\\n            return true ;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1976666,
                "content": [
                    {
                        "username": "Prat_2030",
                        "content": "\\n\\n1. Version with Array (nums):\\nIn the first version, the slow and fast pointers are used in the context of manipulating an array. This is often used in cyclic arrays or sequences where you want to detect cycles or perform some other operation. The idea is that the fast pointer advances faster than the slow pointer, and they might eventually meet or cross paths if there\\'s a cycle. This version is commonly used in algorithms like Floyd\\'s cycle detection algorithm for finding cycles in linked lists or arrays.\\nExample use cases:\\n\\nDetecting cycles in an array or linked list.\\nFinding the duplicate element in an array (Floyd\\'s Tortoise and Hare algorithm).\\n\\n```cpp\\n#include <iostream>\\n#include <vector>\\n\\nbool hasCycle(const std::vector<int>& nums) {\\n    int slow = 0, fast = 0;\\n    while (true) {\\n        slow = nums[slow];\\n        fast = nums[nums[fast]];\\n        if (slow == fast) {\\n            return true; // Cycle detected\\n        }\\n        if (slow < 0 || fast < 0 || fast >= nums.size()) {\\n            return false; // No cycle\\n        }\\n    }\\n}\\n\\nint main() {\\n    std::vector<int> nums = {2, 5, 1, 3, 4, 2}; // Example cyclic array\\n    bool hasCycleResult = hasCycle(nums);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n    return 0;\\n}\\n```\\n\\n2. Version with Linked List:\\nIn the second version, the slow and fast pointers are used in the context of a singly linked list. The fast pointer advances by two steps while the slow pointer advances by one step. This approach is often used for operations that require traversing or processing a linked list in a certain way.\\n\\nExample use cases:\\n\\nDetecting a loop in a linked list (similar to Floyd\\'s cycle detection in arrays).\\nFinding the middle element of a linked list.\\nChecking for palindromes in a linked list.\\nMerging two sorted linked lists.\\n\\n```cpp\\n#include <iostream>\\n\\nstruct ListNode {\\n    int val;\\n    ListNode* next;\\n    ListNode(int val) : val(val), next(nullptr) {}\\n};\\n\\nbool hasCycle(ListNode* head) {\\n    if (!head || !head->next) {\\n        return false; // No cycle with 0 or 1 nodes\\n    }\\n    ListNode* slow = head->next;\\n    ListNode* fast = head->next->next;\\n    while (slow != fast) {\\n        if (!fast || !fast->next) {\\n            return false; // No cycle\\n        }\\n        slow = slow->next;\\n        fast = fast->next->next;\\n    }\\n    return true; // Cycle detected\\n}\\n\\nint main() {\\n    // Example linked list with a cycle\\n    ListNode* head = new ListNode(3);\\n    head->next = new ListNode(2);\\n    head->next->next = new ListNode(0);\\n    head->next->next->next = new ListNode(-4);\\n    head->next->next->next->next = head->next; // Creating a cycle\\n\\n    bool hasCycleResult = hasCycle(head);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n\\n    // Clean up memory (not shown in the example)\\n    return 0;\\n}\\n```\\n\\nWhen to use each version:\\n\\nVersion with Array (nums):\\nUse this version when you\\'re dealing with cyclic arrays or sequences, and you need to detect cycles or perform operations related to cycles.\\nVersion with Linked List:\\nUse this version when you\\'re working with linked lists and need to traverse, manipulate, or perform specific operations like detecting loops, finding middle elements, or merging lists."
                    },
                    {
                        "username": "tawashi105",
                        "content": "The \"Input\" (e.g. head=[1], pos=1) in this problem explanation, is not input to the hasCycle function, it is input to the function which produces a ListNode instance, right?\nIf this is true, this explanation is too confusing. I wasted 2 hours."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "detecting cycles is actually a simple solution. All the question is saying that i am passing the initial node\\'s address you check weather it has a loop in it or not neverthless. Congratulations on your progress so far!"
                    },
                    {
                        "username": "louislhotte",
                        "content": "Funny problem. My answer was accepted, but it turns out it was a famous algorithm that we needed to use which was much more efficient! "
                    },
                    {
                        "username": "user8763jW",
                        "content": "class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (head == NULL || head->next == NULL )\\n          return false;\\n        ListNode* slow;\\n        ListNode* fast;\\n        bool t =0;\\n        slow = head;\\n        fast = head;\\n        while (slow->next && fast->next->next)\\n        {\\n            if (slow == fast)\\n           { \\n           t=1;\\n           break;\\n           }\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        return t?1:0;\\n    }\\n};\\n\\n\\n\\nwhy above code failed for \\n[-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5]\\n\\n\\n"
                    },
                    {
                        "username": "user5388FE",
                        "content": "I don\\'t really understand this question, what does cycle mean, how does -4 point to 2??? doesn\\'t the tail of the LL point to null?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@Lokadithya_M](/Lokadithya_M) Given input format: head = [3,2,0,-4], pos = 1 means that the last element -4 i.e. the tail is linked to pos=1 i.e. 2. \\n\\nPos is given with 0-index notation.  Hence, thats the difference here tail doesn\\'t point to null but an element in the list."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "read about circular linked lists  you will understand\\n"
                    },
                    {
                        "username": "Ravi_kant123",
                        "content": "Intution for this problem is if there is a cycle present in present that means we are again traversing over the nodes which we have already encounter. simple use maps to store nodes if node is already present that means there is a cycle.\\naccording to me this one is the most simple solution.\\nthere are other methods also like Floyed cyle detection you guys can also check out that.\\n\\nand in this question pos is in question just to clarify us that yes cycle is present otherwise how will they tell us. so don\\'t worry about that just solve the problem"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "quick neat method?\\n\\ntry using the Floyd cycle method. "
                    },
                    {
                        "username": "Kilderon",
                        "content": "How can i emulate this testcases in my IDE using java?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "You will have to build the whole linked list and then just pass the head as input. "
                    },
                    {
                        "username": "balinome",
                        "content": "i dont understand the 2 pointer approach , lets say we start : slow* = head and fast* = head and the slow moves 1 node at a time and fast moves 2 nodes at a time , what id the cycle is on the second and 4th nodes , the fast will not even get to those nodes ??? the fast will go from 1st to 3rd to 5th , like i just dont understand the logic "
                    },
                    {
                        "username": "Emerold",
                        "content": "If there is a cycle, eventually, you enter it, as this list is a linked list and we go from the front to the end. If the second node is part of the cycle and the second node points to the third node (by definition), the third node is also part of the cycle. You cannot have the situation that the second and 4th node are part of the cycle but the third node is not.\\n\\nAnd then, you can use the logic of the walker and runner variable.\\n\\nOnce, the runner is in the cycle, we will just run around it again and again. Yes, it skips one node every time, but this doesn\\'t matter yet. Assuming, the runner is already in the cycle going in circles, the walker will eventually reach that cycle, too (if it exists).\\n\\nNow, we have the following situation: The runner moves to steps a time, the walker moves one step a time. Lets say, the gap between the runner is of length n. Every time the walker moves one step and the runner moves two steps, this length between the two gets reduced by exactly one. As this gap gets smaller by exactly one per iteration, you will not jump over the walker with the runner by doing two steps at a time while the walker does one.\\n\\nBy that, you will eventually get the situation, that the runner is equal to the walker (if there exists a circle). \\n\\nTo be honest, in the beginning, it was confusing for me, too, that the runner wont skip over the walker. But this argument of the gap getting smaller only by one per iteration answered, why we can\\'t skip over the walker with the runner without having the equality first."
                    },
                    {
                        "username": "ankush57",
                        "content": "`class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        \\n            if(head == NULL || head -> next == NULL)return false ;\\n\\n            int count = 10001 ;\\n\\n            while(count){\\n\\n                if(!head)return false ;\\n\\n                head = head -> next ;\\n                count-- ;\\n            } \\n\\n            return true ;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1976595,
                "content": [
                    {
                        "username": "Prat_2030",
                        "content": "\\n\\n1. Version with Array (nums):\\nIn the first version, the slow and fast pointers are used in the context of manipulating an array. This is often used in cyclic arrays or sequences where you want to detect cycles or perform some other operation. The idea is that the fast pointer advances faster than the slow pointer, and they might eventually meet or cross paths if there\\'s a cycle. This version is commonly used in algorithms like Floyd\\'s cycle detection algorithm for finding cycles in linked lists or arrays.\\nExample use cases:\\n\\nDetecting cycles in an array or linked list.\\nFinding the duplicate element in an array (Floyd\\'s Tortoise and Hare algorithm).\\n\\n```cpp\\n#include <iostream>\\n#include <vector>\\n\\nbool hasCycle(const std::vector<int>& nums) {\\n    int slow = 0, fast = 0;\\n    while (true) {\\n        slow = nums[slow];\\n        fast = nums[nums[fast]];\\n        if (slow == fast) {\\n            return true; // Cycle detected\\n        }\\n        if (slow < 0 || fast < 0 || fast >= nums.size()) {\\n            return false; // No cycle\\n        }\\n    }\\n}\\n\\nint main() {\\n    std::vector<int> nums = {2, 5, 1, 3, 4, 2}; // Example cyclic array\\n    bool hasCycleResult = hasCycle(nums);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n    return 0;\\n}\\n```\\n\\n2. Version with Linked List:\\nIn the second version, the slow and fast pointers are used in the context of a singly linked list. The fast pointer advances by two steps while the slow pointer advances by one step. This approach is often used for operations that require traversing or processing a linked list in a certain way.\\n\\nExample use cases:\\n\\nDetecting a loop in a linked list (similar to Floyd\\'s cycle detection in arrays).\\nFinding the middle element of a linked list.\\nChecking for palindromes in a linked list.\\nMerging two sorted linked lists.\\n\\n```cpp\\n#include <iostream>\\n\\nstruct ListNode {\\n    int val;\\n    ListNode* next;\\n    ListNode(int val) : val(val), next(nullptr) {}\\n};\\n\\nbool hasCycle(ListNode* head) {\\n    if (!head || !head->next) {\\n        return false; // No cycle with 0 or 1 nodes\\n    }\\n    ListNode* slow = head->next;\\n    ListNode* fast = head->next->next;\\n    while (slow != fast) {\\n        if (!fast || !fast->next) {\\n            return false; // No cycle\\n        }\\n        slow = slow->next;\\n        fast = fast->next->next;\\n    }\\n    return true; // Cycle detected\\n}\\n\\nint main() {\\n    // Example linked list with a cycle\\n    ListNode* head = new ListNode(3);\\n    head->next = new ListNode(2);\\n    head->next->next = new ListNode(0);\\n    head->next->next->next = new ListNode(-4);\\n    head->next->next->next->next = head->next; // Creating a cycle\\n\\n    bool hasCycleResult = hasCycle(head);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n\\n    // Clean up memory (not shown in the example)\\n    return 0;\\n}\\n```\\n\\nWhen to use each version:\\n\\nVersion with Array (nums):\\nUse this version when you\\'re dealing with cyclic arrays or sequences, and you need to detect cycles or perform operations related to cycles.\\nVersion with Linked List:\\nUse this version when you\\'re working with linked lists and need to traverse, manipulate, or perform specific operations like detecting loops, finding middle elements, or merging lists."
                    },
                    {
                        "username": "tawashi105",
                        "content": "The \"Input\" (e.g. head=[1], pos=1) in this problem explanation, is not input to the hasCycle function, it is input to the function which produces a ListNode instance, right?\nIf this is true, this explanation is too confusing. I wasted 2 hours."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "detecting cycles is actually a simple solution. All the question is saying that i am passing the initial node\\'s address you check weather it has a loop in it or not neverthless. Congratulations on your progress so far!"
                    },
                    {
                        "username": "louislhotte",
                        "content": "Funny problem. My answer was accepted, but it turns out it was a famous algorithm that we needed to use which was much more efficient! "
                    },
                    {
                        "username": "user8763jW",
                        "content": "class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (head == NULL || head->next == NULL )\\n          return false;\\n        ListNode* slow;\\n        ListNode* fast;\\n        bool t =0;\\n        slow = head;\\n        fast = head;\\n        while (slow->next && fast->next->next)\\n        {\\n            if (slow == fast)\\n           { \\n           t=1;\\n           break;\\n           }\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        return t?1:0;\\n    }\\n};\\n\\n\\n\\nwhy above code failed for \\n[-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5]\\n\\n\\n"
                    },
                    {
                        "username": "user5388FE",
                        "content": "I don\\'t really understand this question, what does cycle mean, how does -4 point to 2??? doesn\\'t the tail of the LL point to null?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@Lokadithya_M](/Lokadithya_M) Given input format: head = [3,2,0,-4], pos = 1 means that the last element -4 i.e. the tail is linked to pos=1 i.e. 2. \\n\\nPos is given with 0-index notation.  Hence, thats the difference here tail doesn\\'t point to null but an element in the list."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "read about circular linked lists  you will understand\\n"
                    },
                    {
                        "username": "Ravi_kant123",
                        "content": "Intution for this problem is if there is a cycle present in present that means we are again traversing over the nodes which we have already encounter. simple use maps to store nodes if node is already present that means there is a cycle.\\naccording to me this one is the most simple solution.\\nthere are other methods also like Floyed cyle detection you guys can also check out that.\\n\\nand in this question pos is in question just to clarify us that yes cycle is present otherwise how will they tell us. so don\\'t worry about that just solve the problem"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "quick neat method?\\n\\ntry using the Floyd cycle method. "
                    },
                    {
                        "username": "Kilderon",
                        "content": "How can i emulate this testcases in my IDE using java?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "You will have to build the whole linked list and then just pass the head as input. "
                    },
                    {
                        "username": "balinome",
                        "content": "i dont understand the 2 pointer approach , lets say we start : slow* = head and fast* = head and the slow moves 1 node at a time and fast moves 2 nodes at a time , what id the cycle is on the second and 4th nodes , the fast will not even get to those nodes ??? the fast will go from 1st to 3rd to 5th , like i just dont understand the logic "
                    },
                    {
                        "username": "Emerold",
                        "content": "If there is a cycle, eventually, you enter it, as this list is a linked list and we go from the front to the end. If the second node is part of the cycle and the second node points to the third node (by definition), the third node is also part of the cycle. You cannot have the situation that the second and 4th node are part of the cycle but the third node is not.\\n\\nAnd then, you can use the logic of the walker and runner variable.\\n\\nOnce, the runner is in the cycle, we will just run around it again and again. Yes, it skips one node every time, but this doesn\\'t matter yet. Assuming, the runner is already in the cycle going in circles, the walker will eventually reach that cycle, too (if it exists).\\n\\nNow, we have the following situation: The runner moves to steps a time, the walker moves one step a time. Lets say, the gap between the runner is of length n. Every time the walker moves one step and the runner moves two steps, this length between the two gets reduced by exactly one. As this gap gets smaller by exactly one per iteration, you will not jump over the walker with the runner by doing two steps at a time while the walker does one.\\n\\nBy that, you will eventually get the situation, that the runner is equal to the walker (if there exists a circle). \\n\\nTo be honest, in the beginning, it was confusing for me, too, that the runner wont skip over the walker. But this argument of the gap getting smaller only by one per iteration answered, why we can\\'t skip over the walker with the runner without having the equality first."
                    },
                    {
                        "username": "ankush57",
                        "content": "`class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        \\n            if(head == NULL || head -> next == NULL)return false ;\\n\\n            int count = 10001 ;\\n\\n            while(count){\\n\\n                if(!head)return false ;\\n\\n                head = head -> next ;\\n                count-- ;\\n            } \\n\\n            return true ;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1965274,
                "content": [
                    {
                        "username": "Prat_2030",
                        "content": "\\n\\n1. Version with Array (nums):\\nIn the first version, the slow and fast pointers are used in the context of manipulating an array. This is often used in cyclic arrays or sequences where you want to detect cycles or perform some other operation. The idea is that the fast pointer advances faster than the slow pointer, and they might eventually meet or cross paths if there\\'s a cycle. This version is commonly used in algorithms like Floyd\\'s cycle detection algorithm for finding cycles in linked lists or arrays.\\nExample use cases:\\n\\nDetecting cycles in an array or linked list.\\nFinding the duplicate element in an array (Floyd\\'s Tortoise and Hare algorithm).\\n\\n```cpp\\n#include <iostream>\\n#include <vector>\\n\\nbool hasCycle(const std::vector<int>& nums) {\\n    int slow = 0, fast = 0;\\n    while (true) {\\n        slow = nums[slow];\\n        fast = nums[nums[fast]];\\n        if (slow == fast) {\\n            return true; // Cycle detected\\n        }\\n        if (slow < 0 || fast < 0 || fast >= nums.size()) {\\n            return false; // No cycle\\n        }\\n    }\\n}\\n\\nint main() {\\n    std::vector<int> nums = {2, 5, 1, 3, 4, 2}; // Example cyclic array\\n    bool hasCycleResult = hasCycle(nums);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n    return 0;\\n}\\n```\\n\\n2. Version with Linked List:\\nIn the second version, the slow and fast pointers are used in the context of a singly linked list. The fast pointer advances by two steps while the slow pointer advances by one step. This approach is often used for operations that require traversing or processing a linked list in a certain way.\\n\\nExample use cases:\\n\\nDetecting a loop in a linked list (similar to Floyd\\'s cycle detection in arrays).\\nFinding the middle element of a linked list.\\nChecking for palindromes in a linked list.\\nMerging two sorted linked lists.\\n\\n```cpp\\n#include <iostream>\\n\\nstruct ListNode {\\n    int val;\\n    ListNode* next;\\n    ListNode(int val) : val(val), next(nullptr) {}\\n};\\n\\nbool hasCycle(ListNode* head) {\\n    if (!head || !head->next) {\\n        return false; // No cycle with 0 or 1 nodes\\n    }\\n    ListNode* slow = head->next;\\n    ListNode* fast = head->next->next;\\n    while (slow != fast) {\\n        if (!fast || !fast->next) {\\n            return false; // No cycle\\n        }\\n        slow = slow->next;\\n        fast = fast->next->next;\\n    }\\n    return true; // Cycle detected\\n}\\n\\nint main() {\\n    // Example linked list with a cycle\\n    ListNode* head = new ListNode(3);\\n    head->next = new ListNode(2);\\n    head->next->next = new ListNode(0);\\n    head->next->next->next = new ListNode(-4);\\n    head->next->next->next->next = head->next; // Creating a cycle\\n\\n    bool hasCycleResult = hasCycle(head);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n\\n    // Clean up memory (not shown in the example)\\n    return 0;\\n}\\n```\\n\\nWhen to use each version:\\n\\nVersion with Array (nums):\\nUse this version when you\\'re dealing with cyclic arrays or sequences, and you need to detect cycles or perform operations related to cycles.\\nVersion with Linked List:\\nUse this version when you\\'re working with linked lists and need to traverse, manipulate, or perform specific operations like detecting loops, finding middle elements, or merging lists."
                    },
                    {
                        "username": "tawashi105",
                        "content": "The \"Input\" (e.g. head=[1], pos=1) in this problem explanation, is not input to the hasCycle function, it is input to the function which produces a ListNode instance, right?\nIf this is true, this explanation is too confusing. I wasted 2 hours."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "detecting cycles is actually a simple solution. All the question is saying that i am passing the initial node\\'s address you check weather it has a loop in it or not neverthless. Congratulations on your progress so far!"
                    },
                    {
                        "username": "louislhotte",
                        "content": "Funny problem. My answer was accepted, but it turns out it was a famous algorithm that we needed to use which was much more efficient! "
                    },
                    {
                        "username": "user8763jW",
                        "content": "class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (head == NULL || head->next == NULL )\\n          return false;\\n        ListNode* slow;\\n        ListNode* fast;\\n        bool t =0;\\n        slow = head;\\n        fast = head;\\n        while (slow->next && fast->next->next)\\n        {\\n            if (slow == fast)\\n           { \\n           t=1;\\n           break;\\n           }\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        return t?1:0;\\n    }\\n};\\n\\n\\n\\nwhy above code failed for \\n[-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5]\\n\\n\\n"
                    },
                    {
                        "username": "user5388FE",
                        "content": "I don\\'t really understand this question, what does cycle mean, how does -4 point to 2??? doesn\\'t the tail of the LL point to null?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@Lokadithya_M](/Lokadithya_M) Given input format: head = [3,2,0,-4], pos = 1 means that the last element -4 i.e. the tail is linked to pos=1 i.e. 2. \\n\\nPos is given with 0-index notation.  Hence, thats the difference here tail doesn\\'t point to null but an element in the list."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "read about circular linked lists  you will understand\\n"
                    },
                    {
                        "username": "Ravi_kant123",
                        "content": "Intution for this problem is if there is a cycle present in present that means we are again traversing over the nodes which we have already encounter. simple use maps to store nodes if node is already present that means there is a cycle.\\naccording to me this one is the most simple solution.\\nthere are other methods also like Floyed cyle detection you guys can also check out that.\\n\\nand in this question pos is in question just to clarify us that yes cycle is present otherwise how will they tell us. so don\\'t worry about that just solve the problem"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "quick neat method?\\n\\ntry using the Floyd cycle method. "
                    },
                    {
                        "username": "Kilderon",
                        "content": "How can i emulate this testcases in my IDE using java?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "You will have to build the whole linked list and then just pass the head as input. "
                    },
                    {
                        "username": "balinome",
                        "content": "i dont understand the 2 pointer approach , lets say we start : slow* = head and fast* = head and the slow moves 1 node at a time and fast moves 2 nodes at a time , what id the cycle is on the second and 4th nodes , the fast will not even get to those nodes ??? the fast will go from 1st to 3rd to 5th , like i just dont understand the logic "
                    },
                    {
                        "username": "Emerold",
                        "content": "If there is a cycle, eventually, you enter it, as this list is a linked list and we go from the front to the end. If the second node is part of the cycle and the second node points to the third node (by definition), the third node is also part of the cycle. You cannot have the situation that the second and 4th node are part of the cycle but the third node is not.\\n\\nAnd then, you can use the logic of the walker and runner variable.\\n\\nOnce, the runner is in the cycle, we will just run around it again and again. Yes, it skips one node every time, but this doesn\\'t matter yet. Assuming, the runner is already in the cycle going in circles, the walker will eventually reach that cycle, too (if it exists).\\n\\nNow, we have the following situation: The runner moves to steps a time, the walker moves one step a time. Lets say, the gap between the runner is of length n. Every time the walker moves one step and the runner moves two steps, this length between the two gets reduced by exactly one. As this gap gets smaller by exactly one per iteration, you will not jump over the walker with the runner by doing two steps at a time while the walker does one.\\n\\nBy that, you will eventually get the situation, that the runner is equal to the walker (if there exists a circle). \\n\\nTo be honest, in the beginning, it was confusing for me, too, that the runner wont skip over the walker. But this argument of the gap getting smaller only by one per iteration answered, why we can\\'t skip over the walker with the runner without having the equality first."
                    },
                    {
                        "username": "ankush57",
                        "content": "`class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        \\n            if(head == NULL || head -> next == NULL)return false ;\\n\\n            int count = 10001 ;\\n\\n            while(count){\\n\\n                if(!head)return false ;\\n\\n                head = head -> next ;\\n                count-- ;\\n            } \\n\\n            return true ;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1950537,
                "content": [
                    {
                        "username": "Prat_2030",
                        "content": "\\n\\n1. Version with Array (nums):\\nIn the first version, the slow and fast pointers are used in the context of manipulating an array. This is often used in cyclic arrays or sequences where you want to detect cycles or perform some other operation. The idea is that the fast pointer advances faster than the slow pointer, and they might eventually meet or cross paths if there\\'s a cycle. This version is commonly used in algorithms like Floyd\\'s cycle detection algorithm for finding cycles in linked lists or arrays.\\nExample use cases:\\n\\nDetecting cycles in an array or linked list.\\nFinding the duplicate element in an array (Floyd\\'s Tortoise and Hare algorithm).\\n\\n```cpp\\n#include <iostream>\\n#include <vector>\\n\\nbool hasCycle(const std::vector<int>& nums) {\\n    int slow = 0, fast = 0;\\n    while (true) {\\n        slow = nums[slow];\\n        fast = nums[nums[fast]];\\n        if (slow == fast) {\\n            return true; // Cycle detected\\n        }\\n        if (slow < 0 || fast < 0 || fast >= nums.size()) {\\n            return false; // No cycle\\n        }\\n    }\\n}\\n\\nint main() {\\n    std::vector<int> nums = {2, 5, 1, 3, 4, 2}; // Example cyclic array\\n    bool hasCycleResult = hasCycle(nums);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n    return 0;\\n}\\n```\\n\\n2. Version with Linked List:\\nIn the second version, the slow and fast pointers are used in the context of a singly linked list. The fast pointer advances by two steps while the slow pointer advances by one step. This approach is often used for operations that require traversing or processing a linked list in a certain way.\\n\\nExample use cases:\\n\\nDetecting a loop in a linked list (similar to Floyd\\'s cycle detection in arrays).\\nFinding the middle element of a linked list.\\nChecking for palindromes in a linked list.\\nMerging two sorted linked lists.\\n\\n```cpp\\n#include <iostream>\\n\\nstruct ListNode {\\n    int val;\\n    ListNode* next;\\n    ListNode(int val) : val(val), next(nullptr) {}\\n};\\n\\nbool hasCycle(ListNode* head) {\\n    if (!head || !head->next) {\\n        return false; // No cycle with 0 or 1 nodes\\n    }\\n    ListNode* slow = head->next;\\n    ListNode* fast = head->next->next;\\n    while (slow != fast) {\\n        if (!fast || !fast->next) {\\n            return false; // No cycle\\n        }\\n        slow = slow->next;\\n        fast = fast->next->next;\\n    }\\n    return true; // Cycle detected\\n}\\n\\nint main() {\\n    // Example linked list with a cycle\\n    ListNode* head = new ListNode(3);\\n    head->next = new ListNode(2);\\n    head->next->next = new ListNode(0);\\n    head->next->next->next = new ListNode(-4);\\n    head->next->next->next->next = head->next; // Creating a cycle\\n\\n    bool hasCycleResult = hasCycle(head);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n\\n    // Clean up memory (not shown in the example)\\n    return 0;\\n}\\n```\\n\\nWhen to use each version:\\n\\nVersion with Array (nums):\\nUse this version when you\\'re dealing with cyclic arrays or sequences, and you need to detect cycles or perform operations related to cycles.\\nVersion with Linked List:\\nUse this version when you\\'re working with linked lists and need to traverse, manipulate, or perform specific operations like detecting loops, finding middle elements, or merging lists."
                    },
                    {
                        "username": "tawashi105",
                        "content": "The \"Input\" (e.g. head=[1], pos=1) in this problem explanation, is not input to the hasCycle function, it is input to the function which produces a ListNode instance, right?\nIf this is true, this explanation is too confusing. I wasted 2 hours."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "detecting cycles is actually a simple solution. All the question is saying that i am passing the initial node\\'s address you check weather it has a loop in it or not neverthless. Congratulations on your progress so far!"
                    },
                    {
                        "username": "louislhotte",
                        "content": "Funny problem. My answer was accepted, but it turns out it was a famous algorithm that we needed to use which was much more efficient! "
                    },
                    {
                        "username": "user8763jW",
                        "content": "class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (head == NULL || head->next == NULL )\\n          return false;\\n        ListNode* slow;\\n        ListNode* fast;\\n        bool t =0;\\n        slow = head;\\n        fast = head;\\n        while (slow->next && fast->next->next)\\n        {\\n            if (slow == fast)\\n           { \\n           t=1;\\n           break;\\n           }\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        return t?1:0;\\n    }\\n};\\n\\n\\n\\nwhy above code failed for \\n[-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5]\\n\\n\\n"
                    },
                    {
                        "username": "user5388FE",
                        "content": "I don\\'t really understand this question, what does cycle mean, how does -4 point to 2??? doesn\\'t the tail of the LL point to null?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@Lokadithya_M](/Lokadithya_M) Given input format: head = [3,2,0,-4], pos = 1 means that the last element -4 i.e. the tail is linked to pos=1 i.e. 2. \\n\\nPos is given with 0-index notation.  Hence, thats the difference here tail doesn\\'t point to null but an element in the list."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "read about circular linked lists  you will understand\\n"
                    },
                    {
                        "username": "Ravi_kant123",
                        "content": "Intution for this problem is if there is a cycle present in present that means we are again traversing over the nodes which we have already encounter. simple use maps to store nodes if node is already present that means there is a cycle.\\naccording to me this one is the most simple solution.\\nthere are other methods also like Floyed cyle detection you guys can also check out that.\\n\\nand in this question pos is in question just to clarify us that yes cycle is present otherwise how will they tell us. so don\\'t worry about that just solve the problem"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "quick neat method?\\n\\ntry using the Floyd cycle method. "
                    },
                    {
                        "username": "Kilderon",
                        "content": "How can i emulate this testcases in my IDE using java?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "You will have to build the whole linked list and then just pass the head as input. "
                    },
                    {
                        "username": "balinome",
                        "content": "i dont understand the 2 pointer approach , lets say we start : slow* = head and fast* = head and the slow moves 1 node at a time and fast moves 2 nodes at a time , what id the cycle is on the second and 4th nodes , the fast will not even get to those nodes ??? the fast will go from 1st to 3rd to 5th , like i just dont understand the logic "
                    },
                    {
                        "username": "Emerold",
                        "content": "If there is a cycle, eventually, you enter it, as this list is a linked list and we go from the front to the end. If the second node is part of the cycle and the second node points to the third node (by definition), the third node is also part of the cycle. You cannot have the situation that the second and 4th node are part of the cycle but the third node is not.\\n\\nAnd then, you can use the logic of the walker and runner variable.\\n\\nOnce, the runner is in the cycle, we will just run around it again and again. Yes, it skips one node every time, but this doesn\\'t matter yet. Assuming, the runner is already in the cycle going in circles, the walker will eventually reach that cycle, too (if it exists).\\n\\nNow, we have the following situation: The runner moves to steps a time, the walker moves one step a time. Lets say, the gap between the runner is of length n. Every time the walker moves one step and the runner moves two steps, this length between the two gets reduced by exactly one. As this gap gets smaller by exactly one per iteration, you will not jump over the walker with the runner by doing two steps at a time while the walker does one.\\n\\nBy that, you will eventually get the situation, that the runner is equal to the walker (if there exists a circle). \\n\\nTo be honest, in the beginning, it was confusing for me, too, that the runner wont skip over the walker. But this argument of the gap getting smaller only by one per iteration answered, why we can\\'t skip over the walker with the runner without having the equality first."
                    },
                    {
                        "username": "ankush57",
                        "content": "`class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        \\n            if(head == NULL || head -> next == NULL)return false ;\\n\\n            int count = 10001 ;\\n\\n            while(count){\\n\\n                if(!head)return false ;\\n\\n                head = head -> next ;\\n                count-- ;\\n            } \\n\\n            return true ;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1944024,
                "content": [
                    {
                        "username": "Prat_2030",
                        "content": "\\n\\n1. Version with Array (nums):\\nIn the first version, the slow and fast pointers are used in the context of manipulating an array. This is often used in cyclic arrays or sequences where you want to detect cycles or perform some other operation. The idea is that the fast pointer advances faster than the slow pointer, and they might eventually meet or cross paths if there\\'s a cycle. This version is commonly used in algorithms like Floyd\\'s cycle detection algorithm for finding cycles in linked lists or arrays.\\nExample use cases:\\n\\nDetecting cycles in an array or linked list.\\nFinding the duplicate element in an array (Floyd\\'s Tortoise and Hare algorithm).\\n\\n```cpp\\n#include <iostream>\\n#include <vector>\\n\\nbool hasCycle(const std::vector<int>& nums) {\\n    int slow = 0, fast = 0;\\n    while (true) {\\n        slow = nums[slow];\\n        fast = nums[nums[fast]];\\n        if (slow == fast) {\\n            return true; // Cycle detected\\n        }\\n        if (slow < 0 || fast < 0 || fast >= nums.size()) {\\n            return false; // No cycle\\n        }\\n    }\\n}\\n\\nint main() {\\n    std::vector<int> nums = {2, 5, 1, 3, 4, 2}; // Example cyclic array\\n    bool hasCycleResult = hasCycle(nums);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n    return 0;\\n}\\n```\\n\\n2. Version with Linked List:\\nIn the second version, the slow and fast pointers are used in the context of a singly linked list. The fast pointer advances by two steps while the slow pointer advances by one step. This approach is often used for operations that require traversing or processing a linked list in a certain way.\\n\\nExample use cases:\\n\\nDetecting a loop in a linked list (similar to Floyd\\'s cycle detection in arrays).\\nFinding the middle element of a linked list.\\nChecking for palindromes in a linked list.\\nMerging two sorted linked lists.\\n\\n```cpp\\n#include <iostream>\\n\\nstruct ListNode {\\n    int val;\\n    ListNode* next;\\n    ListNode(int val) : val(val), next(nullptr) {}\\n};\\n\\nbool hasCycle(ListNode* head) {\\n    if (!head || !head->next) {\\n        return false; // No cycle with 0 or 1 nodes\\n    }\\n    ListNode* slow = head->next;\\n    ListNode* fast = head->next->next;\\n    while (slow != fast) {\\n        if (!fast || !fast->next) {\\n            return false; // No cycle\\n        }\\n        slow = slow->next;\\n        fast = fast->next->next;\\n    }\\n    return true; // Cycle detected\\n}\\n\\nint main() {\\n    // Example linked list with a cycle\\n    ListNode* head = new ListNode(3);\\n    head->next = new ListNode(2);\\n    head->next->next = new ListNode(0);\\n    head->next->next->next = new ListNode(-4);\\n    head->next->next->next->next = head->next; // Creating a cycle\\n\\n    bool hasCycleResult = hasCycle(head);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n\\n    // Clean up memory (not shown in the example)\\n    return 0;\\n}\\n```\\n\\nWhen to use each version:\\n\\nVersion with Array (nums):\\nUse this version when you\\'re dealing with cyclic arrays or sequences, and you need to detect cycles or perform operations related to cycles.\\nVersion with Linked List:\\nUse this version when you\\'re working with linked lists and need to traverse, manipulate, or perform specific operations like detecting loops, finding middle elements, or merging lists."
                    },
                    {
                        "username": "tawashi105",
                        "content": "The \"Input\" (e.g. head=[1], pos=1) in this problem explanation, is not input to the hasCycle function, it is input to the function which produces a ListNode instance, right?\nIf this is true, this explanation is too confusing. I wasted 2 hours."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "detecting cycles is actually a simple solution. All the question is saying that i am passing the initial node\\'s address you check weather it has a loop in it or not neverthless. Congratulations on your progress so far!"
                    },
                    {
                        "username": "louislhotte",
                        "content": "Funny problem. My answer was accepted, but it turns out it was a famous algorithm that we needed to use which was much more efficient! "
                    },
                    {
                        "username": "user8763jW",
                        "content": "class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (head == NULL || head->next == NULL )\\n          return false;\\n        ListNode* slow;\\n        ListNode* fast;\\n        bool t =0;\\n        slow = head;\\n        fast = head;\\n        while (slow->next && fast->next->next)\\n        {\\n            if (slow == fast)\\n           { \\n           t=1;\\n           break;\\n           }\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        return t?1:0;\\n    }\\n};\\n\\n\\n\\nwhy above code failed for \\n[-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5]\\n\\n\\n"
                    },
                    {
                        "username": "user5388FE",
                        "content": "I don\\'t really understand this question, what does cycle mean, how does -4 point to 2??? doesn\\'t the tail of the LL point to null?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@Lokadithya_M](/Lokadithya_M) Given input format: head = [3,2,0,-4], pos = 1 means that the last element -4 i.e. the tail is linked to pos=1 i.e. 2. \\n\\nPos is given with 0-index notation.  Hence, thats the difference here tail doesn\\'t point to null but an element in the list."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "read about circular linked lists  you will understand\\n"
                    },
                    {
                        "username": "Ravi_kant123",
                        "content": "Intution for this problem is if there is a cycle present in present that means we are again traversing over the nodes which we have already encounter. simple use maps to store nodes if node is already present that means there is a cycle.\\naccording to me this one is the most simple solution.\\nthere are other methods also like Floyed cyle detection you guys can also check out that.\\n\\nand in this question pos is in question just to clarify us that yes cycle is present otherwise how will they tell us. so don\\'t worry about that just solve the problem"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "quick neat method?\\n\\ntry using the Floyd cycle method. "
                    },
                    {
                        "username": "Kilderon",
                        "content": "How can i emulate this testcases in my IDE using java?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "You will have to build the whole linked list and then just pass the head as input. "
                    },
                    {
                        "username": "balinome",
                        "content": "i dont understand the 2 pointer approach , lets say we start : slow* = head and fast* = head and the slow moves 1 node at a time and fast moves 2 nodes at a time , what id the cycle is on the second and 4th nodes , the fast will not even get to those nodes ??? the fast will go from 1st to 3rd to 5th , like i just dont understand the logic "
                    },
                    {
                        "username": "Emerold",
                        "content": "If there is a cycle, eventually, you enter it, as this list is a linked list and we go from the front to the end. If the second node is part of the cycle and the second node points to the third node (by definition), the third node is also part of the cycle. You cannot have the situation that the second and 4th node are part of the cycle but the third node is not.\\n\\nAnd then, you can use the logic of the walker and runner variable.\\n\\nOnce, the runner is in the cycle, we will just run around it again and again. Yes, it skips one node every time, but this doesn\\'t matter yet. Assuming, the runner is already in the cycle going in circles, the walker will eventually reach that cycle, too (if it exists).\\n\\nNow, we have the following situation: The runner moves to steps a time, the walker moves one step a time. Lets say, the gap between the runner is of length n. Every time the walker moves one step and the runner moves two steps, this length between the two gets reduced by exactly one. As this gap gets smaller by exactly one per iteration, you will not jump over the walker with the runner by doing two steps at a time while the walker does one.\\n\\nBy that, you will eventually get the situation, that the runner is equal to the walker (if there exists a circle). \\n\\nTo be honest, in the beginning, it was confusing for me, too, that the runner wont skip over the walker. But this argument of the gap getting smaller only by one per iteration answered, why we can\\'t skip over the walker with the runner without having the equality first."
                    },
                    {
                        "username": "ankush57",
                        "content": "`class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        \\n            if(head == NULL || head -> next == NULL)return false ;\\n\\n            int count = 10001 ;\\n\\n            while(count){\\n\\n                if(!head)return false ;\\n\\n                head = head -> next ;\\n                count-- ;\\n            } \\n\\n            return true ;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1917200,
                "content": [
                    {
                        "username": "Prat_2030",
                        "content": "\\n\\n1. Version with Array (nums):\\nIn the first version, the slow and fast pointers are used in the context of manipulating an array. This is often used in cyclic arrays or sequences where you want to detect cycles or perform some other operation. The idea is that the fast pointer advances faster than the slow pointer, and they might eventually meet or cross paths if there\\'s a cycle. This version is commonly used in algorithms like Floyd\\'s cycle detection algorithm for finding cycles in linked lists or arrays.\\nExample use cases:\\n\\nDetecting cycles in an array or linked list.\\nFinding the duplicate element in an array (Floyd\\'s Tortoise and Hare algorithm).\\n\\n```cpp\\n#include <iostream>\\n#include <vector>\\n\\nbool hasCycle(const std::vector<int>& nums) {\\n    int slow = 0, fast = 0;\\n    while (true) {\\n        slow = nums[slow];\\n        fast = nums[nums[fast]];\\n        if (slow == fast) {\\n            return true; // Cycle detected\\n        }\\n        if (slow < 0 || fast < 0 || fast >= nums.size()) {\\n            return false; // No cycle\\n        }\\n    }\\n}\\n\\nint main() {\\n    std::vector<int> nums = {2, 5, 1, 3, 4, 2}; // Example cyclic array\\n    bool hasCycleResult = hasCycle(nums);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n    return 0;\\n}\\n```\\n\\n2. Version with Linked List:\\nIn the second version, the slow and fast pointers are used in the context of a singly linked list. The fast pointer advances by two steps while the slow pointer advances by one step. This approach is often used for operations that require traversing or processing a linked list in a certain way.\\n\\nExample use cases:\\n\\nDetecting a loop in a linked list (similar to Floyd\\'s cycle detection in arrays).\\nFinding the middle element of a linked list.\\nChecking for palindromes in a linked list.\\nMerging two sorted linked lists.\\n\\n```cpp\\n#include <iostream>\\n\\nstruct ListNode {\\n    int val;\\n    ListNode* next;\\n    ListNode(int val) : val(val), next(nullptr) {}\\n};\\n\\nbool hasCycle(ListNode* head) {\\n    if (!head || !head->next) {\\n        return false; // No cycle with 0 or 1 nodes\\n    }\\n    ListNode* slow = head->next;\\n    ListNode* fast = head->next->next;\\n    while (slow != fast) {\\n        if (!fast || !fast->next) {\\n            return false; // No cycle\\n        }\\n        slow = slow->next;\\n        fast = fast->next->next;\\n    }\\n    return true; // Cycle detected\\n}\\n\\nint main() {\\n    // Example linked list with a cycle\\n    ListNode* head = new ListNode(3);\\n    head->next = new ListNode(2);\\n    head->next->next = new ListNode(0);\\n    head->next->next->next = new ListNode(-4);\\n    head->next->next->next->next = head->next; // Creating a cycle\\n\\n    bool hasCycleResult = hasCycle(head);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n\\n    // Clean up memory (not shown in the example)\\n    return 0;\\n}\\n```\\n\\nWhen to use each version:\\n\\nVersion with Array (nums):\\nUse this version when you\\'re dealing with cyclic arrays or sequences, and you need to detect cycles or perform operations related to cycles.\\nVersion with Linked List:\\nUse this version when you\\'re working with linked lists and need to traverse, manipulate, or perform specific operations like detecting loops, finding middle elements, or merging lists."
                    },
                    {
                        "username": "tawashi105",
                        "content": "The \"Input\" (e.g. head=[1], pos=1) in this problem explanation, is not input to the hasCycle function, it is input to the function which produces a ListNode instance, right?\nIf this is true, this explanation is too confusing. I wasted 2 hours."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "detecting cycles is actually a simple solution. All the question is saying that i am passing the initial node\\'s address you check weather it has a loop in it or not neverthless. Congratulations on your progress so far!"
                    },
                    {
                        "username": "louislhotte",
                        "content": "Funny problem. My answer was accepted, but it turns out it was a famous algorithm that we needed to use which was much more efficient! "
                    },
                    {
                        "username": "user8763jW",
                        "content": "class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (head == NULL || head->next == NULL )\\n          return false;\\n        ListNode* slow;\\n        ListNode* fast;\\n        bool t =0;\\n        slow = head;\\n        fast = head;\\n        while (slow->next && fast->next->next)\\n        {\\n            if (slow == fast)\\n           { \\n           t=1;\\n           break;\\n           }\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        return t?1:0;\\n    }\\n};\\n\\n\\n\\nwhy above code failed for \\n[-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5]\\n\\n\\n"
                    },
                    {
                        "username": "user5388FE",
                        "content": "I don\\'t really understand this question, what does cycle mean, how does -4 point to 2??? doesn\\'t the tail of the LL point to null?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@Lokadithya_M](/Lokadithya_M) Given input format: head = [3,2,0,-4], pos = 1 means that the last element -4 i.e. the tail is linked to pos=1 i.e. 2. \\n\\nPos is given with 0-index notation.  Hence, thats the difference here tail doesn\\'t point to null but an element in the list."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "read about circular linked lists  you will understand\\n"
                    },
                    {
                        "username": "Ravi_kant123",
                        "content": "Intution for this problem is if there is a cycle present in present that means we are again traversing over the nodes which we have already encounter. simple use maps to store nodes if node is already present that means there is a cycle.\\naccording to me this one is the most simple solution.\\nthere are other methods also like Floyed cyle detection you guys can also check out that.\\n\\nand in this question pos is in question just to clarify us that yes cycle is present otherwise how will they tell us. so don\\'t worry about that just solve the problem"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "quick neat method?\\n\\ntry using the Floyd cycle method. "
                    },
                    {
                        "username": "Kilderon",
                        "content": "How can i emulate this testcases in my IDE using java?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "You will have to build the whole linked list and then just pass the head as input. "
                    },
                    {
                        "username": "balinome",
                        "content": "i dont understand the 2 pointer approach , lets say we start : slow* = head and fast* = head and the slow moves 1 node at a time and fast moves 2 nodes at a time , what id the cycle is on the second and 4th nodes , the fast will not even get to those nodes ??? the fast will go from 1st to 3rd to 5th , like i just dont understand the logic "
                    },
                    {
                        "username": "Emerold",
                        "content": "If there is a cycle, eventually, you enter it, as this list is a linked list and we go from the front to the end. If the second node is part of the cycle and the second node points to the third node (by definition), the third node is also part of the cycle. You cannot have the situation that the second and 4th node are part of the cycle but the third node is not.\\n\\nAnd then, you can use the logic of the walker and runner variable.\\n\\nOnce, the runner is in the cycle, we will just run around it again and again. Yes, it skips one node every time, but this doesn\\'t matter yet. Assuming, the runner is already in the cycle going in circles, the walker will eventually reach that cycle, too (if it exists).\\n\\nNow, we have the following situation: The runner moves to steps a time, the walker moves one step a time. Lets say, the gap between the runner is of length n. Every time the walker moves one step and the runner moves two steps, this length between the two gets reduced by exactly one. As this gap gets smaller by exactly one per iteration, you will not jump over the walker with the runner by doing two steps at a time while the walker does one.\\n\\nBy that, you will eventually get the situation, that the runner is equal to the walker (if there exists a circle). \\n\\nTo be honest, in the beginning, it was confusing for me, too, that the runner wont skip over the walker. But this argument of the gap getting smaller only by one per iteration answered, why we can\\'t skip over the walker with the runner without having the equality first."
                    },
                    {
                        "username": "ankush57",
                        "content": "`class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        \\n            if(head == NULL || head -> next == NULL)return false ;\\n\\n            int count = 10001 ;\\n\\n            while(count){\\n\\n                if(!head)return false ;\\n\\n                head = head -> next ;\\n                count-- ;\\n            } \\n\\n            return true ;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1910365,
                "content": [
                    {
                        "username": "Prat_2030",
                        "content": "\\n\\n1. Version with Array (nums):\\nIn the first version, the slow and fast pointers are used in the context of manipulating an array. This is often used in cyclic arrays or sequences where you want to detect cycles or perform some other operation. The idea is that the fast pointer advances faster than the slow pointer, and they might eventually meet or cross paths if there\\'s a cycle. This version is commonly used in algorithms like Floyd\\'s cycle detection algorithm for finding cycles in linked lists or arrays.\\nExample use cases:\\n\\nDetecting cycles in an array or linked list.\\nFinding the duplicate element in an array (Floyd\\'s Tortoise and Hare algorithm).\\n\\n```cpp\\n#include <iostream>\\n#include <vector>\\n\\nbool hasCycle(const std::vector<int>& nums) {\\n    int slow = 0, fast = 0;\\n    while (true) {\\n        slow = nums[slow];\\n        fast = nums[nums[fast]];\\n        if (slow == fast) {\\n            return true; // Cycle detected\\n        }\\n        if (slow < 0 || fast < 0 || fast >= nums.size()) {\\n            return false; // No cycle\\n        }\\n    }\\n}\\n\\nint main() {\\n    std::vector<int> nums = {2, 5, 1, 3, 4, 2}; // Example cyclic array\\n    bool hasCycleResult = hasCycle(nums);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n    return 0;\\n}\\n```\\n\\n2. Version with Linked List:\\nIn the second version, the slow and fast pointers are used in the context of a singly linked list. The fast pointer advances by two steps while the slow pointer advances by one step. This approach is often used for operations that require traversing or processing a linked list in a certain way.\\n\\nExample use cases:\\n\\nDetecting a loop in a linked list (similar to Floyd\\'s cycle detection in arrays).\\nFinding the middle element of a linked list.\\nChecking for palindromes in a linked list.\\nMerging two sorted linked lists.\\n\\n```cpp\\n#include <iostream>\\n\\nstruct ListNode {\\n    int val;\\n    ListNode* next;\\n    ListNode(int val) : val(val), next(nullptr) {}\\n};\\n\\nbool hasCycle(ListNode* head) {\\n    if (!head || !head->next) {\\n        return false; // No cycle with 0 or 1 nodes\\n    }\\n    ListNode* slow = head->next;\\n    ListNode* fast = head->next->next;\\n    while (slow != fast) {\\n        if (!fast || !fast->next) {\\n            return false; // No cycle\\n        }\\n        slow = slow->next;\\n        fast = fast->next->next;\\n    }\\n    return true; // Cycle detected\\n}\\n\\nint main() {\\n    // Example linked list with a cycle\\n    ListNode* head = new ListNode(3);\\n    head->next = new ListNode(2);\\n    head->next->next = new ListNode(0);\\n    head->next->next->next = new ListNode(-4);\\n    head->next->next->next->next = head->next; // Creating a cycle\\n\\n    bool hasCycleResult = hasCycle(head);\\n    std::cout << \"Has cycle: \" << (hasCycleResult ? \"Yes\" : \"No\") << std::endl;\\n\\n    // Clean up memory (not shown in the example)\\n    return 0;\\n}\\n```\\n\\nWhen to use each version:\\n\\nVersion with Array (nums):\\nUse this version when you\\'re dealing with cyclic arrays or sequences, and you need to detect cycles or perform operations related to cycles.\\nVersion with Linked List:\\nUse this version when you\\'re working with linked lists and need to traverse, manipulate, or perform specific operations like detecting loops, finding middle elements, or merging lists."
                    },
                    {
                        "username": "tawashi105",
                        "content": "The \"Input\" (e.g. head=[1], pos=1) in this problem explanation, is not input to the hasCycle function, it is input to the function which produces a ListNode instance, right?\nIf this is true, this explanation is too confusing. I wasted 2 hours."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "detecting cycles is actually a simple solution. All the question is saying that i am passing the initial node\\'s address you check weather it has a loop in it or not neverthless. Congratulations on your progress so far!"
                    },
                    {
                        "username": "louislhotte",
                        "content": "Funny problem. My answer was accepted, but it turns out it was a famous algorithm that we needed to use which was much more efficient! "
                    },
                    {
                        "username": "user8763jW",
                        "content": "class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if (head == NULL || head->next == NULL )\\n          return false;\\n        ListNode* slow;\\n        ListNode* fast;\\n        bool t =0;\\n        slow = head;\\n        fast = head;\\n        while (slow->next && fast->next->next)\\n        {\\n            if (slow == fast)\\n           { \\n           t=1;\\n           break;\\n           }\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        return t?1:0;\\n    }\\n};\\n\\n\\n\\nwhy above code failed for \\n[-21,10,17,8,4,26,5,35,33,-7,-16,27,-12,6,29,-12,5,9,20,14,14,2,13,-24,21,23,-21,5]\\n\\n\\n"
                    },
                    {
                        "username": "user5388FE",
                        "content": "I don\\'t really understand this question, what does cycle mean, how does -4 point to 2??? doesn\\'t the tail of the LL point to null?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@Lokadithya_M](/Lokadithya_M) Given input format: head = [3,2,0,-4], pos = 1 means that the last element -4 i.e. the tail is linked to pos=1 i.e. 2. \\n\\nPos is given with 0-index notation.  Hence, thats the difference here tail doesn\\'t point to null but an element in the list."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "read about circular linked lists  you will understand\\n"
                    },
                    {
                        "username": "Ravi_kant123",
                        "content": "Intution for this problem is if there is a cycle present in present that means we are again traversing over the nodes which we have already encounter. simple use maps to store nodes if node is already present that means there is a cycle.\\naccording to me this one is the most simple solution.\\nthere are other methods also like Floyed cyle detection you guys can also check out that.\\n\\nand in this question pos is in question just to clarify us that yes cycle is present otherwise how will they tell us. so don\\'t worry about that just solve the problem"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "quick neat method?\\n\\ntry using the Floyd cycle method. "
                    },
                    {
                        "username": "Kilderon",
                        "content": "How can i emulate this testcases in my IDE using java?"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "You will have to build the whole linked list and then just pass the head as input. "
                    },
                    {
                        "username": "balinome",
                        "content": "i dont understand the 2 pointer approach , lets say we start : slow* = head and fast* = head and the slow moves 1 node at a time and fast moves 2 nodes at a time , what id the cycle is on the second and 4th nodes , the fast will not even get to those nodes ??? the fast will go from 1st to 3rd to 5th , like i just dont understand the logic "
                    },
                    {
                        "username": "Emerold",
                        "content": "If there is a cycle, eventually, you enter it, as this list is a linked list and we go from the front to the end. If the second node is part of the cycle and the second node points to the third node (by definition), the third node is also part of the cycle. You cannot have the situation that the second and 4th node are part of the cycle but the third node is not.\\n\\nAnd then, you can use the logic of the walker and runner variable.\\n\\nOnce, the runner is in the cycle, we will just run around it again and again. Yes, it skips one node every time, but this doesn\\'t matter yet. Assuming, the runner is already in the cycle going in circles, the walker will eventually reach that cycle, too (if it exists).\\n\\nNow, we have the following situation: The runner moves to steps a time, the walker moves one step a time. Lets say, the gap between the runner is of length n. Every time the walker moves one step and the runner moves two steps, this length between the two gets reduced by exactly one. As this gap gets smaller by exactly one per iteration, you will not jump over the walker with the runner by doing two steps at a time while the walker does one.\\n\\nBy that, you will eventually get the situation, that the runner is equal to the walker (if there exists a circle). \\n\\nTo be honest, in the beginning, it was confusing for me, too, that the runner wont skip over the walker. But this argument of the gap getting smaller only by one per iteration answered, why we can\\'t skip over the walker with the runner without having the equality first."
                    },
                    {
                        "username": "ankush57",
                        "content": "`class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        \\n            if(head == NULL || head -> next == NULL)return false ;\\n\\n            int count = 10001 ;\\n\\n            while(count){\\n\\n                if(!head)return false ;\\n\\n                head = head -> next ;\\n                count-- ;\\n            } \\n\\n            return true ;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1894084,
                "content": [
                    {
                        "username": "kevinjoythomas7",
                        "content": "what does pos -1 mean would its be at null or what number"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That means, we don\\'t have any cycle and the last node has as next: null."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases to test some edge cases\n```\n[3,2,0,-4,5]\n4\n[3,2,0,-4,5]\n0\n[3,2,0,-4,5]\n1\n[3,2,0,-4,5]\n-1\n[1,2]\n0\n[1,2]\n1\n[1]\n-1\n[1]\n0\n[]\n-1\n```\n\n"
                    },
                    {
                        "username": "prabal2308",
                        "content": "pos is not passed as parameter but still given as input, seems strange!!\\n"
                    },
                    {
                        "username": "Surya9776036576",
                        "content": "friends here #pos has an important role although we r not going to use this in code but for test cases the #pos value ask ,to which indexed node your  last node will point "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "QUESTTION SOLUTION strikes after reading question I\\'M not pro coder but first understand the condition what task is given how to get solution If not idea strike in mind at that moment then add question in your list after 1 -2 days or week after try same question instead of watching tutorial try to solve by your own ok brother"
                    },
                    {
                        "username": "mo1ok",
                        "content": "JS interpreter seems to be missing [].findLastIndex, which can be used to handily solve this problem."
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "there is no use of \\'pos\\' in the code, it is just for the understanding what is actually going behind the scene , if tail->next points the \\'pos\\' it means cycle is present .\\n\\nYou can do this question using Floyd\\'s cycle detection algorithm\\n"
                    },
                    {
                        "username": "Ornik",
                        "content": "There is a cycle in all lists that are larger than 1 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442. More precisely, except for head = [1], in all the others there is a cycle, let\\'s say head = [1,2], head = [1,2,3] and so on. Do I understand correctly?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In fact, we can change that by changing pos. if pos equal -1, that means no cycle and the last node point at null."
                    },
                    {
                        "username": "mestremi6a",
                        "content": "When hit Submit get `process exited with signal SIGSEGV` error.\n\nDid anyone get this error?"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "\\nWhy can\\'t I do with one node, just check if it\\'s nullptr then it doesn\\'t have a loop, still has it, that\\'s it? "
                    },
                    {
                        "username": "amiramri",
                        "content": "In a list which has a cycle you will never see a nullptr and your programme will never reach the end. In fact you don\\'t know when to decide whether there is a nullptr or not."
                    }
                ]
            },
            {
                "id": 1889430,
                "content": [
                    {
                        "username": "kevinjoythomas7",
                        "content": "what does pos -1 mean would its be at null or what number"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That means, we don\\'t have any cycle and the last node has as next: null."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases to test some edge cases\n```\n[3,2,0,-4,5]\n4\n[3,2,0,-4,5]\n0\n[3,2,0,-4,5]\n1\n[3,2,0,-4,5]\n-1\n[1,2]\n0\n[1,2]\n1\n[1]\n-1\n[1]\n0\n[]\n-1\n```\n\n"
                    },
                    {
                        "username": "prabal2308",
                        "content": "pos is not passed as parameter but still given as input, seems strange!!\\n"
                    },
                    {
                        "username": "Surya9776036576",
                        "content": "friends here #pos has an important role although we r not going to use this in code but for test cases the #pos value ask ,to which indexed node your  last node will point "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "QUESTTION SOLUTION strikes after reading question I\\'M not pro coder but first understand the condition what task is given how to get solution If not idea strike in mind at that moment then add question in your list after 1 -2 days or week after try same question instead of watching tutorial try to solve by your own ok brother"
                    },
                    {
                        "username": "mo1ok",
                        "content": "JS interpreter seems to be missing [].findLastIndex, which can be used to handily solve this problem."
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "there is no use of \\'pos\\' in the code, it is just for the understanding what is actually going behind the scene , if tail->next points the \\'pos\\' it means cycle is present .\\n\\nYou can do this question using Floyd\\'s cycle detection algorithm\\n"
                    },
                    {
                        "username": "Ornik",
                        "content": "There is a cycle in all lists that are larger than 1 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442. More precisely, except for head = [1], in all the others there is a cycle, let\\'s say head = [1,2], head = [1,2,3] and so on. Do I understand correctly?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In fact, we can change that by changing pos. if pos equal -1, that means no cycle and the last node point at null."
                    },
                    {
                        "username": "mestremi6a",
                        "content": "When hit Submit get `process exited with signal SIGSEGV` error.\n\nDid anyone get this error?"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "\\nWhy can\\'t I do with one node, just check if it\\'s nullptr then it doesn\\'t have a loop, still has it, that\\'s it? "
                    },
                    {
                        "username": "amiramri",
                        "content": "In a list which has a cycle you will never see a nullptr and your programme will never reach the end. In fact you don\\'t know when to decide whether there is a nullptr or not."
                    }
                ]
            },
            {
                "id": 1885147,
                "content": [
                    {
                        "username": "kevinjoythomas7",
                        "content": "what does pos -1 mean would its be at null or what number"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That means, we don\\'t have any cycle and the last node has as next: null."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases to test some edge cases\n```\n[3,2,0,-4,5]\n4\n[3,2,0,-4,5]\n0\n[3,2,0,-4,5]\n1\n[3,2,0,-4,5]\n-1\n[1,2]\n0\n[1,2]\n1\n[1]\n-1\n[1]\n0\n[]\n-1\n```\n\n"
                    },
                    {
                        "username": "prabal2308",
                        "content": "pos is not passed as parameter but still given as input, seems strange!!\\n"
                    },
                    {
                        "username": "Surya9776036576",
                        "content": "friends here #pos has an important role although we r not going to use this in code but for test cases the #pos value ask ,to which indexed node your  last node will point "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "QUESTTION SOLUTION strikes after reading question I\\'M not pro coder but first understand the condition what task is given how to get solution If not idea strike in mind at that moment then add question in your list after 1 -2 days or week after try same question instead of watching tutorial try to solve by your own ok brother"
                    },
                    {
                        "username": "mo1ok",
                        "content": "JS interpreter seems to be missing [].findLastIndex, which can be used to handily solve this problem."
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "there is no use of \\'pos\\' in the code, it is just for the understanding what is actually going behind the scene , if tail->next points the \\'pos\\' it means cycle is present .\\n\\nYou can do this question using Floyd\\'s cycle detection algorithm\\n"
                    },
                    {
                        "username": "Ornik",
                        "content": "There is a cycle in all lists that are larger than 1 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442. More precisely, except for head = [1], in all the others there is a cycle, let\\'s say head = [1,2], head = [1,2,3] and so on. Do I understand correctly?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In fact, we can change that by changing pos. if pos equal -1, that means no cycle and the last node point at null."
                    },
                    {
                        "username": "mestremi6a",
                        "content": "When hit Submit get `process exited with signal SIGSEGV` error.\n\nDid anyone get this error?"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "\\nWhy can\\'t I do with one node, just check if it\\'s nullptr then it doesn\\'t have a loop, still has it, that\\'s it? "
                    },
                    {
                        "username": "amiramri",
                        "content": "In a list which has a cycle you will never see a nullptr and your programme will never reach the end. In fact you don\\'t know when to decide whether there is a nullptr or not."
                    }
                ]
            },
            {
                "id": 1879002,
                "content": [
                    {
                        "username": "kevinjoythomas7",
                        "content": "what does pos -1 mean would its be at null or what number"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That means, we don\\'t have any cycle and the last node has as next: null."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases to test some edge cases\n```\n[3,2,0,-4,5]\n4\n[3,2,0,-4,5]\n0\n[3,2,0,-4,5]\n1\n[3,2,0,-4,5]\n-1\n[1,2]\n0\n[1,2]\n1\n[1]\n-1\n[1]\n0\n[]\n-1\n```\n\n"
                    },
                    {
                        "username": "prabal2308",
                        "content": "pos is not passed as parameter but still given as input, seems strange!!\\n"
                    },
                    {
                        "username": "Surya9776036576",
                        "content": "friends here #pos has an important role although we r not going to use this in code but for test cases the #pos value ask ,to which indexed node your  last node will point "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "QUESTTION SOLUTION strikes after reading question I\\'M not pro coder but first understand the condition what task is given how to get solution If not idea strike in mind at that moment then add question in your list after 1 -2 days or week after try same question instead of watching tutorial try to solve by your own ok brother"
                    },
                    {
                        "username": "mo1ok",
                        "content": "JS interpreter seems to be missing [].findLastIndex, which can be used to handily solve this problem."
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "there is no use of \\'pos\\' in the code, it is just for the understanding what is actually going behind the scene , if tail->next points the \\'pos\\' it means cycle is present .\\n\\nYou can do this question using Floyd\\'s cycle detection algorithm\\n"
                    },
                    {
                        "username": "Ornik",
                        "content": "There is a cycle in all lists that are larger than 1 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442. More precisely, except for head = [1], in all the others there is a cycle, let\\'s say head = [1,2], head = [1,2,3] and so on. Do I understand correctly?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In fact, we can change that by changing pos. if pos equal -1, that means no cycle and the last node point at null."
                    },
                    {
                        "username": "mestremi6a",
                        "content": "When hit Submit get `process exited with signal SIGSEGV` error.\n\nDid anyone get this error?"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "\\nWhy can\\'t I do with one node, just check if it\\'s nullptr then it doesn\\'t have a loop, still has it, that\\'s it? "
                    },
                    {
                        "username": "amiramri",
                        "content": "In a list which has a cycle you will never see a nullptr and your programme will never reach the end. In fact you don\\'t know when to decide whether there is a nullptr or not."
                    }
                ]
            },
            {
                "id": 1871713,
                "content": [
                    {
                        "username": "kevinjoythomas7",
                        "content": "what does pos -1 mean would its be at null or what number"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That means, we don\\'t have any cycle and the last node has as next: null."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases to test some edge cases\n```\n[3,2,0,-4,5]\n4\n[3,2,0,-4,5]\n0\n[3,2,0,-4,5]\n1\n[3,2,0,-4,5]\n-1\n[1,2]\n0\n[1,2]\n1\n[1]\n-1\n[1]\n0\n[]\n-1\n```\n\n"
                    },
                    {
                        "username": "prabal2308",
                        "content": "pos is not passed as parameter but still given as input, seems strange!!\\n"
                    },
                    {
                        "username": "Surya9776036576",
                        "content": "friends here #pos has an important role although we r not going to use this in code but for test cases the #pos value ask ,to which indexed node your  last node will point "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "QUESTTION SOLUTION strikes after reading question I\\'M not pro coder but first understand the condition what task is given how to get solution If not idea strike in mind at that moment then add question in your list after 1 -2 days or week after try same question instead of watching tutorial try to solve by your own ok brother"
                    },
                    {
                        "username": "mo1ok",
                        "content": "JS interpreter seems to be missing [].findLastIndex, which can be used to handily solve this problem."
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "there is no use of \\'pos\\' in the code, it is just for the understanding what is actually going behind the scene , if tail->next points the \\'pos\\' it means cycle is present .\\n\\nYou can do this question using Floyd\\'s cycle detection algorithm\\n"
                    },
                    {
                        "username": "Ornik",
                        "content": "There is a cycle in all lists that are larger than 1 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442. More precisely, except for head = [1], in all the others there is a cycle, let\\'s say head = [1,2], head = [1,2,3] and so on. Do I understand correctly?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In fact, we can change that by changing pos. if pos equal -1, that means no cycle and the last node point at null."
                    },
                    {
                        "username": "mestremi6a",
                        "content": "When hit Submit get `process exited with signal SIGSEGV` error.\n\nDid anyone get this error?"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "\\nWhy can\\'t I do with one node, just check if it\\'s nullptr then it doesn\\'t have a loop, still has it, that\\'s it? "
                    },
                    {
                        "username": "amiramri",
                        "content": "In a list which has a cycle you will never see a nullptr and your programme will never reach the end. In fact you don\\'t know when to decide whether there is a nullptr or not."
                    }
                ]
            },
            {
                "id": 1869365,
                "content": [
                    {
                        "username": "kevinjoythomas7",
                        "content": "what does pos -1 mean would its be at null or what number"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That means, we don\\'t have any cycle and the last node has as next: null."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases to test some edge cases\n```\n[3,2,0,-4,5]\n4\n[3,2,0,-4,5]\n0\n[3,2,0,-4,5]\n1\n[3,2,0,-4,5]\n-1\n[1,2]\n0\n[1,2]\n1\n[1]\n-1\n[1]\n0\n[]\n-1\n```\n\n"
                    },
                    {
                        "username": "prabal2308",
                        "content": "pos is not passed as parameter but still given as input, seems strange!!\\n"
                    },
                    {
                        "username": "Surya9776036576",
                        "content": "friends here #pos has an important role although we r not going to use this in code but for test cases the #pos value ask ,to which indexed node your  last node will point "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "QUESTTION SOLUTION strikes after reading question I\\'M not pro coder but first understand the condition what task is given how to get solution If not idea strike in mind at that moment then add question in your list after 1 -2 days or week after try same question instead of watching tutorial try to solve by your own ok brother"
                    },
                    {
                        "username": "mo1ok",
                        "content": "JS interpreter seems to be missing [].findLastIndex, which can be used to handily solve this problem."
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "there is no use of \\'pos\\' in the code, it is just for the understanding what is actually going behind the scene , if tail->next points the \\'pos\\' it means cycle is present .\\n\\nYou can do this question using Floyd\\'s cycle detection algorithm\\n"
                    },
                    {
                        "username": "Ornik",
                        "content": "There is a cycle in all lists that are larger than 1 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442. More precisely, except for head = [1], in all the others there is a cycle, let\\'s say head = [1,2], head = [1,2,3] and so on. Do I understand correctly?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In fact, we can change that by changing pos. if pos equal -1, that means no cycle and the last node point at null."
                    },
                    {
                        "username": "mestremi6a",
                        "content": "When hit Submit get `process exited with signal SIGSEGV` error.\n\nDid anyone get this error?"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "\\nWhy can\\'t I do with one node, just check if it\\'s nullptr then it doesn\\'t have a loop, still has it, that\\'s it? "
                    },
                    {
                        "username": "amiramri",
                        "content": "In a list which has a cycle you will never see a nullptr and your programme will never reach the end. In fact you don\\'t know when to decide whether there is a nullptr or not."
                    }
                ]
            },
            {
                "id": 1862947,
                "content": [
                    {
                        "username": "kevinjoythomas7",
                        "content": "what does pos -1 mean would its be at null or what number"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That means, we don\\'t have any cycle and the last node has as next: null."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases to test some edge cases\n```\n[3,2,0,-4,5]\n4\n[3,2,0,-4,5]\n0\n[3,2,0,-4,5]\n1\n[3,2,0,-4,5]\n-1\n[1,2]\n0\n[1,2]\n1\n[1]\n-1\n[1]\n0\n[]\n-1\n```\n\n"
                    },
                    {
                        "username": "prabal2308",
                        "content": "pos is not passed as parameter but still given as input, seems strange!!\\n"
                    },
                    {
                        "username": "Surya9776036576",
                        "content": "friends here #pos has an important role although we r not going to use this in code but for test cases the #pos value ask ,to which indexed node your  last node will point "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "QUESTTION SOLUTION strikes after reading question I\\'M not pro coder but first understand the condition what task is given how to get solution If not idea strike in mind at that moment then add question in your list after 1 -2 days or week after try same question instead of watching tutorial try to solve by your own ok brother"
                    },
                    {
                        "username": "mo1ok",
                        "content": "JS interpreter seems to be missing [].findLastIndex, which can be used to handily solve this problem."
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "there is no use of \\'pos\\' in the code, it is just for the understanding what is actually going behind the scene , if tail->next points the \\'pos\\' it means cycle is present .\\n\\nYou can do this question using Floyd\\'s cycle detection algorithm\\n"
                    },
                    {
                        "username": "Ornik",
                        "content": "There is a cycle in all lists that are larger than 1 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442. More precisely, except for head = [1], in all the others there is a cycle, let\\'s say head = [1,2], head = [1,2,3] and so on. Do I understand correctly?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In fact, we can change that by changing pos. if pos equal -1, that means no cycle and the last node point at null."
                    },
                    {
                        "username": "mestremi6a",
                        "content": "When hit Submit get `process exited with signal SIGSEGV` error.\n\nDid anyone get this error?"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "\\nWhy can\\'t I do with one node, just check if it\\'s nullptr then it doesn\\'t have a loop, still has it, that\\'s it? "
                    },
                    {
                        "username": "amiramri",
                        "content": "In a list which has a cycle you will never see a nullptr and your programme will never reach the end. In fact you don\\'t know when to decide whether there is a nullptr or not."
                    }
                ]
            },
            {
                "id": 1856433,
                "content": [
                    {
                        "username": "kevinjoythomas7",
                        "content": "what does pos -1 mean would its be at null or what number"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That means, we don\\'t have any cycle and the last node has as next: null."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases to test some edge cases\n```\n[3,2,0,-4,5]\n4\n[3,2,0,-4,5]\n0\n[3,2,0,-4,5]\n1\n[3,2,0,-4,5]\n-1\n[1,2]\n0\n[1,2]\n1\n[1]\n-1\n[1]\n0\n[]\n-1\n```\n\n"
                    },
                    {
                        "username": "prabal2308",
                        "content": "pos is not passed as parameter but still given as input, seems strange!!\\n"
                    },
                    {
                        "username": "Surya9776036576",
                        "content": "friends here #pos has an important role although we r not going to use this in code but for test cases the #pos value ask ,to which indexed node your  last node will point "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "QUESTTION SOLUTION strikes after reading question I\\'M not pro coder but first understand the condition what task is given how to get solution If not idea strike in mind at that moment then add question in your list after 1 -2 days or week after try same question instead of watching tutorial try to solve by your own ok brother"
                    },
                    {
                        "username": "mo1ok",
                        "content": "JS interpreter seems to be missing [].findLastIndex, which can be used to handily solve this problem."
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "there is no use of \\'pos\\' in the code, it is just for the understanding what is actually going behind the scene , if tail->next points the \\'pos\\' it means cycle is present .\\n\\nYou can do this question using Floyd\\'s cycle detection algorithm\\n"
                    },
                    {
                        "username": "Ornik",
                        "content": "There is a cycle in all lists that are larger than 1 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442. More precisely, except for head = [1], in all the others there is a cycle, let\\'s say head = [1,2], head = [1,2,3] and so on. Do I understand correctly?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In fact, we can change that by changing pos. if pos equal -1, that means no cycle and the last node point at null."
                    },
                    {
                        "username": "mestremi6a",
                        "content": "When hit Submit get `process exited with signal SIGSEGV` error.\n\nDid anyone get this error?"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "\\nWhy can\\'t I do with one node, just check if it\\'s nullptr then it doesn\\'t have a loop, still has it, that\\'s it? "
                    },
                    {
                        "username": "amiramri",
                        "content": "In a list which has a cycle you will never see a nullptr and your programme will never reach the end. In fact you don\\'t know when to decide whether there is a nullptr or not."
                    }
                ]
            },
            {
                "id": 1838474,
                "content": [
                    {
                        "username": "kevinjoythomas7",
                        "content": "what does pos -1 mean would its be at null or what number"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That means, we don\\'t have any cycle and the last node has as next: null."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases to test some edge cases\n```\n[3,2,0,-4,5]\n4\n[3,2,0,-4,5]\n0\n[3,2,0,-4,5]\n1\n[3,2,0,-4,5]\n-1\n[1,2]\n0\n[1,2]\n1\n[1]\n-1\n[1]\n0\n[]\n-1\n```\n\n"
                    },
                    {
                        "username": "prabal2308",
                        "content": "pos is not passed as parameter but still given as input, seems strange!!\\n"
                    },
                    {
                        "username": "Surya9776036576",
                        "content": "friends here #pos has an important role although we r not going to use this in code but for test cases the #pos value ask ,to which indexed node your  last node will point "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "QUESTTION SOLUTION strikes after reading question I\\'M not pro coder but first understand the condition what task is given how to get solution If not idea strike in mind at that moment then add question in your list after 1 -2 days or week after try same question instead of watching tutorial try to solve by your own ok brother"
                    },
                    {
                        "username": "mo1ok",
                        "content": "JS interpreter seems to be missing [].findLastIndex, which can be used to handily solve this problem."
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "there is no use of \\'pos\\' in the code, it is just for the understanding what is actually going behind the scene , if tail->next points the \\'pos\\' it means cycle is present .\\n\\nYou can do this question using Floyd\\'s cycle detection algorithm\\n"
                    },
                    {
                        "username": "Ornik",
                        "content": "There is a cycle in all lists that are larger than 1 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442. More precisely, except for head = [1], in all the others there is a cycle, let\\'s say head = [1,2], head = [1,2,3] and so on. Do I understand correctly?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In fact, we can change that by changing pos. if pos equal -1, that means no cycle and the last node point at null."
                    },
                    {
                        "username": "mestremi6a",
                        "content": "When hit Submit get `process exited with signal SIGSEGV` error.\n\nDid anyone get this error?"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "\\nWhy can\\'t I do with one node, just check if it\\'s nullptr then it doesn\\'t have a loop, still has it, that\\'s it? "
                    },
                    {
                        "username": "amiramri",
                        "content": "In a list which has a cycle you will never see a nullptr and your programme will never reach the end. In fact you don\\'t know when to decide whether there is a nullptr or not."
                    }
                ]
            },
            {
                "id": 1834042,
                "content": [
                    {
                        "username": "kevinjoythomas7",
                        "content": "what does pos -1 mean would its be at null or what number"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "That means, we don\\'t have any cycle and the last node has as next: null."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases to test some edge cases\n```\n[3,2,0,-4,5]\n4\n[3,2,0,-4,5]\n0\n[3,2,0,-4,5]\n1\n[3,2,0,-4,5]\n-1\n[1,2]\n0\n[1,2]\n1\n[1]\n-1\n[1]\n0\n[]\n-1\n```\n\n"
                    },
                    {
                        "username": "prabal2308",
                        "content": "pos is not passed as parameter but still given as input, seems strange!!\\n"
                    },
                    {
                        "username": "Surya9776036576",
                        "content": "friends here #pos has an important role although we r not going to use this in code but for test cases the #pos value ask ,to which indexed node your  last node will point "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "QUESTTION SOLUTION strikes after reading question I\\'M not pro coder but first understand the condition what task is given how to get solution If not idea strike in mind at that moment then add question in your list after 1 -2 days or week after try same question instead of watching tutorial try to solve by your own ok brother"
                    },
                    {
                        "username": "mo1ok",
                        "content": "JS interpreter seems to be missing [].findLastIndex, which can be used to handily solve this problem."
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "there is no use of \\'pos\\' in the code, it is just for the understanding what is actually going behind the scene , if tail->next points the \\'pos\\' it means cycle is present .\\n\\nYou can do this question using Floyd\\'s cycle detection algorithm\\n"
                    },
                    {
                        "username": "Ornik",
                        "content": "There is a cycle in all lists that are larger than 1 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442. More precisely, except for head = [1], in all the others there is a cycle, let\\'s say head = [1,2], head = [1,2,3] and so on. Do I understand correctly?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In fact, we can change that by changing pos. if pos equal -1, that means no cycle and the last node point at null."
                    },
                    {
                        "username": "mestremi6a",
                        "content": "When hit Submit get `process exited with signal SIGSEGV` error.\n\nDid anyone get this error?"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "\\nWhy can\\'t I do with one node, just check if it\\'s nullptr then it doesn\\'t have a loop, still has it, that\\'s it? "
                    },
                    {
                        "username": "amiramri",
                        "content": "In a list which has a cycle you will never see a nullptr and your programme will never reach the end. In fact you don\\'t know when to decide whether there is a nullptr or not."
                    }
                ]
            },
            {
                "id": 1828352,
                "content": [
                    {
                        "username": "Mukul_reign",
                        "content": "basically if in the traversal of the linked list if we discover NULL that means the linked list is not in a cycle ,... so to check the loop we can use Floyd\\'s Cycle detection algorithm which uses an two pointer,..."
                    },
                    {
                        "username": "cagils",
                        "content": "A simple solution is using the fast-slow pointer comparison approach and doing the iteration entirely in the header of the for() like this:\\nJavascript example:\\n```js\\n    for(let s = head, f = s?.next?.next; f; s = s.next, f=f.next?.next) if (f === s) return true\\n    return false\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lopharb",
                        "content": "so, can someone please explain the 3rd test case to me? the list consists of just a single element, but i\\'m pretty sure it actually has a cycle (my code returns `true` only of we encounter the same element twice, and, well, it does return `true` on the 3rd case). on the other hand, `head.next == next ` returns `false`, which makes sense cause that\\'s the answer. but, what I can\\'t understand is how does it get into a loop then? are there hidden elements or something?\\n\\nfor those who are interested in how my code works\\ni\\'ve actually tried several methods, including relative velocity, marking elements seen by changing their value to \"-\" and simply storing each element into a dictionary and seeing if any of them appears twice\\nso, i think at least one of them should work on that one\\nand each one of this approaches says there\\'s a loop in the 3rd test case\\nidk maybe i did make a mistake somewhere, but i can\\'t seem to figure out where\\n"
                    },
                    {
                        "username": "Vikasreddy369",
                        "content": "I solved by making use of constraints ,suprisingly  my solution got  accepted, but i dont think it is a better solution  , . May be i need to further optimise it"
                    },
                    {
                        "username": "user0949Z",
                        "content": "Idk what happening here. Why \\'Error - Found cycle in the ListNode\\' shows in head.next?"
                    },
                    {
                        "username": "jdsalasca",
                        "content": "Easy using the tortoise and hate algorithm"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This doesn't make sense to me: \n  class ListNode {\n      int val;\n      ListNode next;\n      ListNode(int x) {\n          val = x;\n          next = null;\n      }\n  }\n\nHow is it possible to create a node that has next different from null? Could someone explain?"
                    },
                    {
                        "username": "aakriti_meh",
                        "content": "it is simply giving the default value for any node .........even if u do not assign any value for val and next then too it will assume the default values as 0 and null [in java it works this way..i am not sure of other languages ]"
                    },
                    {
                        "username": "storzian",
                        "content": "Are all values in the list unique?"
                    },
                    {
                        "username": "vuoxa",
                        "content": "How do I need to understand from the sequences ```[3,2,0,-4]``` and ```[1,2]``` that there\\'s a cycle in them?"
                    },
                    {
                        "username": "Niemand1337",
                        "content": "There is a mistake in this question: In the inputs \\'pos\\' is given, wich is what searched in the code. For the funktion itself it is not given, as this would give the solution away. But with some code it can be read out outside of the solution and the result can be written in the user out.\\nAs this is just reading the \\'pos\\' value it is the fastes way with the least use of memory.\\n\\nI have done this in python in this problem and in the follow-up linked list cycle II, with time beat of 99.9% and memory beat of 100%.\\nThis is unfair and should be fixed in future\\n(If it is not wanted)\\n\\nFor those who want to try this:\\nIn python this can be done with the following:\\n\\'with open(\"user.out\", \"w\") as f\\'\\n\\'__Utils__().read_lines()\\'\\nand\\n\\'f.write()\\'"
                    }
                ]
            },
            {
                "id": 1826204,
                "content": [
                    {
                        "username": "Mukul_reign",
                        "content": "basically if in the traversal of the linked list if we discover NULL that means the linked list is not in a cycle ,... so to check the loop we can use Floyd\\'s Cycle detection algorithm which uses an two pointer,..."
                    },
                    {
                        "username": "cagils",
                        "content": "A simple solution is using the fast-slow pointer comparison approach and doing the iteration entirely in the header of the for() like this:\\nJavascript example:\\n```js\\n    for(let s = head, f = s?.next?.next; f; s = s.next, f=f.next?.next) if (f === s) return true\\n    return false\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lopharb",
                        "content": "so, can someone please explain the 3rd test case to me? the list consists of just a single element, but i\\'m pretty sure it actually has a cycle (my code returns `true` only of we encounter the same element twice, and, well, it does return `true` on the 3rd case). on the other hand, `head.next == next ` returns `false`, which makes sense cause that\\'s the answer. but, what I can\\'t understand is how does it get into a loop then? are there hidden elements or something?\\n\\nfor those who are interested in how my code works\\ni\\'ve actually tried several methods, including relative velocity, marking elements seen by changing their value to \"-\" and simply storing each element into a dictionary and seeing if any of them appears twice\\nso, i think at least one of them should work on that one\\nand each one of this approaches says there\\'s a loop in the 3rd test case\\nidk maybe i did make a mistake somewhere, but i can\\'t seem to figure out where\\n"
                    },
                    {
                        "username": "Vikasreddy369",
                        "content": "I solved by making use of constraints ,suprisingly  my solution got  accepted, but i dont think it is a better solution  , . May be i need to further optimise it"
                    },
                    {
                        "username": "user0949Z",
                        "content": "Idk what happening here. Why \\'Error - Found cycle in the ListNode\\' shows in head.next?"
                    },
                    {
                        "username": "jdsalasca",
                        "content": "Easy using the tortoise and hate algorithm"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This doesn't make sense to me: \n  class ListNode {\n      int val;\n      ListNode next;\n      ListNode(int x) {\n          val = x;\n          next = null;\n      }\n  }\n\nHow is it possible to create a node that has next different from null? Could someone explain?"
                    },
                    {
                        "username": "aakriti_meh",
                        "content": "it is simply giving the default value for any node .........even if u do not assign any value for val and next then too it will assume the default values as 0 and null [in java it works this way..i am not sure of other languages ]"
                    },
                    {
                        "username": "storzian",
                        "content": "Are all values in the list unique?"
                    },
                    {
                        "username": "vuoxa",
                        "content": "How do I need to understand from the sequences ```[3,2,0,-4]``` and ```[1,2]``` that there\\'s a cycle in them?"
                    },
                    {
                        "username": "Niemand1337",
                        "content": "There is a mistake in this question: In the inputs \\'pos\\' is given, wich is what searched in the code. For the funktion itself it is not given, as this would give the solution away. But with some code it can be read out outside of the solution and the result can be written in the user out.\\nAs this is just reading the \\'pos\\' value it is the fastes way with the least use of memory.\\n\\nI have done this in python in this problem and in the follow-up linked list cycle II, with time beat of 99.9% and memory beat of 100%.\\nThis is unfair and should be fixed in future\\n(If it is not wanted)\\n\\nFor those who want to try this:\\nIn python this can be done with the following:\\n\\'with open(\"user.out\", \"w\") as f\\'\\n\\'__Utils__().read_lines()\\'\\nand\\n\\'f.write()\\'"
                    }
                ]
            },
            {
                "id": 1817726,
                "content": [
                    {
                        "username": "Mukul_reign",
                        "content": "basically if in the traversal of the linked list if we discover NULL that means the linked list is not in a cycle ,... so to check the loop we can use Floyd\\'s Cycle detection algorithm which uses an two pointer,..."
                    },
                    {
                        "username": "cagils",
                        "content": "A simple solution is using the fast-slow pointer comparison approach and doing the iteration entirely in the header of the for() like this:\\nJavascript example:\\n```js\\n    for(let s = head, f = s?.next?.next; f; s = s.next, f=f.next?.next) if (f === s) return true\\n    return false\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lopharb",
                        "content": "so, can someone please explain the 3rd test case to me? the list consists of just a single element, but i\\'m pretty sure it actually has a cycle (my code returns `true` only of we encounter the same element twice, and, well, it does return `true` on the 3rd case). on the other hand, `head.next == next ` returns `false`, which makes sense cause that\\'s the answer. but, what I can\\'t understand is how does it get into a loop then? are there hidden elements or something?\\n\\nfor those who are interested in how my code works\\ni\\'ve actually tried several methods, including relative velocity, marking elements seen by changing their value to \"-\" and simply storing each element into a dictionary and seeing if any of them appears twice\\nso, i think at least one of them should work on that one\\nand each one of this approaches says there\\'s a loop in the 3rd test case\\nidk maybe i did make a mistake somewhere, but i can\\'t seem to figure out where\\n"
                    },
                    {
                        "username": "Vikasreddy369",
                        "content": "I solved by making use of constraints ,suprisingly  my solution got  accepted, but i dont think it is a better solution  , . May be i need to further optimise it"
                    },
                    {
                        "username": "user0949Z",
                        "content": "Idk what happening here. Why \\'Error - Found cycle in the ListNode\\' shows in head.next?"
                    },
                    {
                        "username": "jdsalasca",
                        "content": "Easy using the tortoise and hate algorithm"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This doesn't make sense to me: \n  class ListNode {\n      int val;\n      ListNode next;\n      ListNode(int x) {\n          val = x;\n          next = null;\n      }\n  }\n\nHow is it possible to create a node that has next different from null? Could someone explain?"
                    },
                    {
                        "username": "aakriti_meh",
                        "content": "it is simply giving the default value for any node .........even if u do not assign any value for val and next then too it will assume the default values as 0 and null [in java it works this way..i am not sure of other languages ]"
                    },
                    {
                        "username": "storzian",
                        "content": "Are all values in the list unique?"
                    },
                    {
                        "username": "vuoxa",
                        "content": "How do I need to understand from the sequences ```[3,2,0,-4]``` and ```[1,2]``` that there\\'s a cycle in them?"
                    },
                    {
                        "username": "Niemand1337",
                        "content": "There is a mistake in this question: In the inputs \\'pos\\' is given, wich is what searched in the code. For the funktion itself it is not given, as this would give the solution away. But with some code it can be read out outside of the solution and the result can be written in the user out.\\nAs this is just reading the \\'pos\\' value it is the fastes way with the least use of memory.\\n\\nI have done this in python in this problem and in the follow-up linked list cycle II, with time beat of 99.9% and memory beat of 100%.\\nThis is unfair and should be fixed in future\\n(If it is not wanted)\\n\\nFor those who want to try this:\\nIn python this can be done with the following:\\n\\'with open(\"user.out\", \"w\") as f\\'\\n\\'__Utils__().read_lines()\\'\\nand\\n\\'f.write()\\'"
                    }
                ]
            },
            {
                "id": 1808526,
                "content": [
                    {
                        "username": "Mukul_reign",
                        "content": "basically if in the traversal of the linked list if we discover NULL that means the linked list is not in a cycle ,... so to check the loop we can use Floyd\\'s Cycle detection algorithm which uses an two pointer,..."
                    },
                    {
                        "username": "cagils",
                        "content": "A simple solution is using the fast-slow pointer comparison approach and doing the iteration entirely in the header of the for() like this:\\nJavascript example:\\n```js\\n    for(let s = head, f = s?.next?.next; f; s = s.next, f=f.next?.next) if (f === s) return true\\n    return false\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lopharb",
                        "content": "so, can someone please explain the 3rd test case to me? the list consists of just a single element, but i\\'m pretty sure it actually has a cycle (my code returns `true` only of we encounter the same element twice, and, well, it does return `true` on the 3rd case). on the other hand, `head.next == next ` returns `false`, which makes sense cause that\\'s the answer. but, what I can\\'t understand is how does it get into a loop then? are there hidden elements or something?\\n\\nfor those who are interested in how my code works\\ni\\'ve actually tried several methods, including relative velocity, marking elements seen by changing their value to \"-\" and simply storing each element into a dictionary and seeing if any of them appears twice\\nso, i think at least one of them should work on that one\\nand each one of this approaches says there\\'s a loop in the 3rd test case\\nidk maybe i did make a mistake somewhere, but i can\\'t seem to figure out where\\n"
                    },
                    {
                        "username": "Vikasreddy369",
                        "content": "I solved by making use of constraints ,suprisingly  my solution got  accepted, but i dont think it is a better solution  , . May be i need to further optimise it"
                    },
                    {
                        "username": "user0949Z",
                        "content": "Idk what happening here. Why \\'Error - Found cycle in the ListNode\\' shows in head.next?"
                    },
                    {
                        "username": "jdsalasca",
                        "content": "Easy using the tortoise and hate algorithm"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This doesn't make sense to me: \n  class ListNode {\n      int val;\n      ListNode next;\n      ListNode(int x) {\n          val = x;\n          next = null;\n      }\n  }\n\nHow is it possible to create a node that has next different from null? Could someone explain?"
                    },
                    {
                        "username": "aakriti_meh",
                        "content": "it is simply giving the default value for any node .........even if u do not assign any value for val and next then too it will assume the default values as 0 and null [in java it works this way..i am not sure of other languages ]"
                    },
                    {
                        "username": "storzian",
                        "content": "Are all values in the list unique?"
                    },
                    {
                        "username": "vuoxa",
                        "content": "How do I need to understand from the sequences ```[3,2,0,-4]``` and ```[1,2]``` that there\\'s a cycle in them?"
                    },
                    {
                        "username": "Niemand1337",
                        "content": "There is a mistake in this question: In the inputs \\'pos\\' is given, wich is what searched in the code. For the funktion itself it is not given, as this would give the solution away. But with some code it can be read out outside of the solution and the result can be written in the user out.\\nAs this is just reading the \\'pos\\' value it is the fastes way with the least use of memory.\\n\\nI have done this in python in this problem and in the follow-up linked list cycle II, with time beat of 99.9% and memory beat of 100%.\\nThis is unfair and should be fixed in future\\n(If it is not wanted)\\n\\nFor those who want to try this:\\nIn python this can be done with the following:\\n\\'with open(\"user.out\", \"w\") as f\\'\\n\\'__Utils__().read_lines()\\'\\nand\\n\\'f.write()\\'"
                    }
                ]
            },
            {
                "id": 1797981,
                "content": [
                    {
                        "username": "Mukul_reign",
                        "content": "basically if in the traversal of the linked list if we discover NULL that means the linked list is not in a cycle ,... so to check the loop we can use Floyd\\'s Cycle detection algorithm which uses an two pointer,..."
                    },
                    {
                        "username": "cagils",
                        "content": "A simple solution is using the fast-slow pointer comparison approach and doing the iteration entirely in the header of the for() like this:\\nJavascript example:\\n```js\\n    for(let s = head, f = s?.next?.next; f; s = s.next, f=f.next?.next) if (f === s) return true\\n    return false\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lopharb",
                        "content": "so, can someone please explain the 3rd test case to me? the list consists of just a single element, but i\\'m pretty sure it actually has a cycle (my code returns `true` only of we encounter the same element twice, and, well, it does return `true` on the 3rd case). on the other hand, `head.next == next ` returns `false`, which makes sense cause that\\'s the answer. but, what I can\\'t understand is how does it get into a loop then? are there hidden elements or something?\\n\\nfor those who are interested in how my code works\\ni\\'ve actually tried several methods, including relative velocity, marking elements seen by changing their value to \"-\" and simply storing each element into a dictionary and seeing if any of them appears twice\\nso, i think at least one of them should work on that one\\nand each one of this approaches says there\\'s a loop in the 3rd test case\\nidk maybe i did make a mistake somewhere, but i can\\'t seem to figure out where\\n"
                    },
                    {
                        "username": "Vikasreddy369",
                        "content": "I solved by making use of constraints ,suprisingly  my solution got  accepted, but i dont think it is a better solution  , . May be i need to further optimise it"
                    },
                    {
                        "username": "user0949Z",
                        "content": "Idk what happening here. Why \\'Error - Found cycle in the ListNode\\' shows in head.next?"
                    },
                    {
                        "username": "jdsalasca",
                        "content": "Easy using the tortoise and hate algorithm"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This doesn't make sense to me: \n  class ListNode {\n      int val;\n      ListNode next;\n      ListNode(int x) {\n          val = x;\n          next = null;\n      }\n  }\n\nHow is it possible to create a node that has next different from null? Could someone explain?"
                    },
                    {
                        "username": "aakriti_meh",
                        "content": "it is simply giving the default value for any node .........even if u do not assign any value for val and next then too it will assume the default values as 0 and null [in java it works this way..i am not sure of other languages ]"
                    },
                    {
                        "username": "storzian",
                        "content": "Are all values in the list unique?"
                    },
                    {
                        "username": "vuoxa",
                        "content": "How do I need to understand from the sequences ```[3,2,0,-4]``` and ```[1,2]``` that there\\'s a cycle in them?"
                    },
                    {
                        "username": "Niemand1337",
                        "content": "There is a mistake in this question: In the inputs \\'pos\\' is given, wich is what searched in the code. For the funktion itself it is not given, as this would give the solution away. But with some code it can be read out outside of the solution and the result can be written in the user out.\\nAs this is just reading the \\'pos\\' value it is the fastes way with the least use of memory.\\n\\nI have done this in python in this problem and in the follow-up linked list cycle II, with time beat of 99.9% and memory beat of 100%.\\nThis is unfair and should be fixed in future\\n(If it is not wanted)\\n\\nFor those who want to try this:\\nIn python this can be done with the following:\\n\\'with open(\"user.out\", \"w\") as f\\'\\n\\'__Utils__().read_lines()\\'\\nand\\n\\'f.write()\\'"
                    }
                ]
            },
            {
                "id": 1796905,
                "content": [
                    {
                        "username": "Mukul_reign",
                        "content": "basically if in the traversal of the linked list if we discover NULL that means the linked list is not in a cycle ,... so to check the loop we can use Floyd\\'s Cycle detection algorithm which uses an two pointer,..."
                    },
                    {
                        "username": "cagils",
                        "content": "A simple solution is using the fast-slow pointer comparison approach and doing the iteration entirely in the header of the for() like this:\\nJavascript example:\\n```js\\n    for(let s = head, f = s?.next?.next; f; s = s.next, f=f.next?.next) if (f === s) return true\\n    return false\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lopharb",
                        "content": "so, can someone please explain the 3rd test case to me? the list consists of just a single element, but i\\'m pretty sure it actually has a cycle (my code returns `true` only of we encounter the same element twice, and, well, it does return `true` on the 3rd case). on the other hand, `head.next == next ` returns `false`, which makes sense cause that\\'s the answer. but, what I can\\'t understand is how does it get into a loop then? are there hidden elements or something?\\n\\nfor those who are interested in how my code works\\ni\\'ve actually tried several methods, including relative velocity, marking elements seen by changing their value to \"-\" and simply storing each element into a dictionary and seeing if any of them appears twice\\nso, i think at least one of them should work on that one\\nand each one of this approaches says there\\'s a loop in the 3rd test case\\nidk maybe i did make a mistake somewhere, but i can\\'t seem to figure out where\\n"
                    },
                    {
                        "username": "Vikasreddy369",
                        "content": "I solved by making use of constraints ,suprisingly  my solution got  accepted, but i dont think it is a better solution  , . May be i need to further optimise it"
                    },
                    {
                        "username": "user0949Z",
                        "content": "Idk what happening here. Why \\'Error - Found cycle in the ListNode\\' shows in head.next?"
                    },
                    {
                        "username": "jdsalasca",
                        "content": "Easy using the tortoise and hate algorithm"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This doesn't make sense to me: \n  class ListNode {\n      int val;\n      ListNode next;\n      ListNode(int x) {\n          val = x;\n          next = null;\n      }\n  }\n\nHow is it possible to create a node that has next different from null? Could someone explain?"
                    },
                    {
                        "username": "aakriti_meh",
                        "content": "it is simply giving the default value for any node .........even if u do not assign any value for val and next then too it will assume the default values as 0 and null [in java it works this way..i am not sure of other languages ]"
                    },
                    {
                        "username": "storzian",
                        "content": "Are all values in the list unique?"
                    },
                    {
                        "username": "vuoxa",
                        "content": "How do I need to understand from the sequences ```[3,2,0,-4]``` and ```[1,2]``` that there\\'s a cycle in them?"
                    },
                    {
                        "username": "Niemand1337",
                        "content": "There is a mistake in this question: In the inputs \\'pos\\' is given, wich is what searched in the code. For the funktion itself it is not given, as this would give the solution away. But with some code it can be read out outside of the solution and the result can be written in the user out.\\nAs this is just reading the \\'pos\\' value it is the fastes way with the least use of memory.\\n\\nI have done this in python in this problem and in the follow-up linked list cycle II, with time beat of 99.9% and memory beat of 100%.\\nThis is unfair and should be fixed in future\\n(If it is not wanted)\\n\\nFor those who want to try this:\\nIn python this can be done with the following:\\n\\'with open(\"user.out\", \"w\") as f\\'\\n\\'__Utils__().read_lines()\\'\\nand\\n\\'f.write()\\'"
                    }
                ]
            },
            {
                "id": 1796031,
                "content": [
                    {
                        "username": "Mukul_reign",
                        "content": "basically if in the traversal of the linked list if we discover NULL that means the linked list is not in a cycle ,... so to check the loop we can use Floyd\\'s Cycle detection algorithm which uses an two pointer,..."
                    },
                    {
                        "username": "cagils",
                        "content": "A simple solution is using the fast-slow pointer comparison approach and doing the iteration entirely in the header of the for() like this:\\nJavascript example:\\n```js\\n    for(let s = head, f = s?.next?.next; f; s = s.next, f=f.next?.next) if (f === s) return true\\n    return false\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lopharb",
                        "content": "so, can someone please explain the 3rd test case to me? the list consists of just a single element, but i\\'m pretty sure it actually has a cycle (my code returns `true` only of we encounter the same element twice, and, well, it does return `true` on the 3rd case). on the other hand, `head.next == next ` returns `false`, which makes sense cause that\\'s the answer. but, what I can\\'t understand is how does it get into a loop then? are there hidden elements or something?\\n\\nfor those who are interested in how my code works\\ni\\'ve actually tried several methods, including relative velocity, marking elements seen by changing their value to \"-\" and simply storing each element into a dictionary and seeing if any of them appears twice\\nso, i think at least one of them should work on that one\\nand each one of this approaches says there\\'s a loop in the 3rd test case\\nidk maybe i did make a mistake somewhere, but i can\\'t seem to figure out where\\n"
                    },
                    {
                        "username": "Vikasreddy369",
                        "content": "I solved by making use of constraints ,suprisingly  my solution got  accepted, but i dont think it is a better solution  , . May be i need to further optimise it"
                    },
                    {
                        "username": "user0949Z",
                        "content": "Idk what happening here. Why \\'Error - Found cycle in the ListNode\\' shows in head.next?"
                    },
                    {
                        "username": "jdsalasca",
                        "content": "Easy using the tortoise and hate algorithm"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This doesn't make sense to me: \n  class ListNode {\n      int val;\n      ListNode next;\n      ListNode(int x) {\n          val = x;\n          next = null;\n      }\n  }\n\nHow is it possible to create a node that has next different from null? Could someone explain?"
                    },
                    {
                        "username": "aakriti_meh",
                        "content": "it is simply giving the default value for any node .........even if u do not assign any value for val and next then too it will assume the default values as 0 and null [in java it works this way..i am not sure of other languages ]"
                    },
                    {
                        "username": "storzian",
                        "content": "Are all values in the list unique?"
                    },
                    {
                        "username": "vuoxa",
                        "content": "How do I need to understand from the sequences ```[3,2,0,-4]``` and ```[1,2]``` that there\\'s a cycle in them?"
                    },
                    {
                        "username": "Niemand1337",
                        "content": "There is a mistake in this question: In the inputs \\'pos\\' is given, wich is what searched in the code. For the funktion itself it is not given, as this would give the solution away. But with some code it can be read out outside of the solution and the result can be written in the user out.\\nAs this is just reading the \\'pos\\' value it is the fastes way with the least use of memory.\\n\\nI have done this in python in this problem and in the follow-up linked list cycle II, with time beat of 99.9% and memory beat of 100%.\\nThis is unfair and should be fixed in future\\n(If it is not wanted)\\n\\nFor those who want to try this:\\nIn python this can be done with the following:\\n\\'with open(\"user.out\", \"w\") as f\\'\\n\\'__Utils__().read_lines()\\'\\nand\\n\\'f.write()\\'"
                    }
                ]
            },
            {
                "id": 1795810,
                "content": [
                    {
                        "username": "Mukul_reign",
                        "content": "basically if in the traversal of the linked list if we discover NULL that means the linked list is not in a cycle ,... so to check the loop we can use Floyd\\'s Cycle detection algorithm which uses an two pointer,..."
                    },
                    {
                        "username": "cagils",
                        "content": "A simple solution is using the fast-slow pointer comparison approach and doing the iteration entirely in the header of the for() like this:\\nJavascript example:\\n```js\\n    for(let s = head, f = s?.next?.next; f; s = s.next, f=f.next?.next) if (f === s) return true\\n    return false\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lopharb",
                        "content": "so, can someone please explain the 3rd test case to me? the list consists of just a single element, but i\\'m pretty sure it actually has a cycle (my code returns `true` only of we encounter the same element twice, and, well, it does return `true` on the 3rd case). on the other hand, `head.next == next ` returns `false`, which makes sense cause that\\'s the answer. but, what I can\\'t understand is how does it get into a loop then? are there hidden elements or something?\\n\\nfor those who are interested in how my code works\\ni\\'ve actually tried several methods, including relative velocity, marking elements seen by changing their value to \"-\" and simply storing each element into a dictionary and seeing if any of them appears twice\\nso, i think at least one of them should work on that one\\nand each one of this approaches says there\\'s a loop in the 3rd test case\\nidk maybe i did make a mistake somewhere, but i can\\'t seem to figure out where\\n"
                    },
                    {
                        "username": "Vikasreddy369",
                        "content": "I solved by making use of constraints ,suprisingly  my solution got  accepted, but i dont think it is a better solution  , . May be i need to further optimise it"
                    },
                    {
                        "username": "user0949Z",
                        "content": "Idk what happening here. Why \\'Error - Found cycle in the ListNode\\' shows in head.next?"
                    },
                    {
                        "username": "jdsalasca",
                        "content": "Easy using the tortoise and hate algorithm"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This doesn't make sense to me: \n  class ListNode {\n      int val;\n      ListNode next;\n      ListNode(int x) {\n          val = x;\n          next = null;\n      }\n  }\n\nHow is it possible to create a node that has next different from null? Could someone explain?"
                    },
                    {
                        "username": "aakriti_meh",
                        "content": "it is simply giving the default value for any node .........even if u do not assign any value for val and next then too it will assume the default values as 0 and null [in java it works this way..i am not sure of other languages ]"
                    },
                    {
                        "username": "storzian",
                        "content": "Are all values in the list unique?"
                    },
                    {
                        "username": "vuoxa",
                        "content": "How do I need to understand from the sequences ```[3,2,0,-4]``` and ```[1,2]``` that there\\'s a cycle in them?"
                    },
                    {
                        "username": "Niemand1337",
                        "content": "There is a mistake in this question: In the inputs \\'pos\\' is given, wich is what searched in the code. For the funktion itself it is not given, as this would give the solution away. But with some code it can be read out outside of the solution and the result can be written in the user out.\\nAs this is just reading the \\'pos\\' value it is the fastes way with the least use of memory.\\n\\nI have done this in python in this problem and in the follow-up linked list cycle II, with time beat of 99.9% and memory beat of 100%.\\nThis is unfair and should be fixed in future\\n(If it is not wanted)\\n\\nFor those who want to try this:\\nIn python this can be done with the following:\\n\\'with open(\"user.out\", \"w\") as f\\'\\n\\'__Utils__().read_lines()\\'\\nand\\n\\'f.write()\\'"
                    }
                ]
            },
            {
                "id": 1789283,
                "content": [
                    {
                        "username": "Mukul_reign",
                        "content": "basically if in the traversal of the linked list if we discover NULL that means the linked list is not in a cycle ,... so to check the loop we can use Floyd\\'s Cycle detection algorithm which uses an two pointer,..."
                    },
                    {
                        "username": "cagils",
                        "content": "A simple solution is using the fast-slow pointer comparison approach and doing the iteration entirely in the header of the for() like this:\\nJavascript example:\\n```js\\n    for(let s = head, f = s?.next?.next; f; s = s.next, f=f.next?.next) if (f === s) return true\\n    return false\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lopharb",
                        "content": "so, can someone please explain the 3rd test case to me? the list consists of just a single element, but i\\'m pretty sure it actually has a cycle (my code returns `true` only of we encounter the same element twice, and, well, it does return `true` on the 3rd case). on the other hand, `head.next == next ` returns `false`, which makes sense cause that\\'s the answer. but, what I can\\'t understand is how does it get into a loop then? are there hidden elements or something?\\n\\nfor those who are interested in how my code works\\ni\\'ve actually tried several methods, including relative velocity, marking elements seen by changing their value to \"-\" and simply storing each element into a dictionary and seeing if any of them appears twice\\nso, i think at least one of them should work on that one\\nand each one of this approaches says there\\'s a loop in the 3rd test case\\nidk maybe i did make a mistake somewhere, but i can\\'t seem to figure out where\\n"
                    },
                    {
                        "username": "Vikasreddy369",
                        "content": "I solved by making use of constraints ,suprisingly  my solution got  accepted, but i dont think it is a better solution  , . May be i need to further optimise it"
                    },
                    {
                        "username": "user0949Z",
                        "content": "Idk what happening here. Why \\'Error - Found cycle in the ListNode\\' shows in head.next?"
                    },
                    {
                        "username": "jdsalasca",
                        "content": "Easy using the tortoise and hate algorithm"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This doesn't make sense to me: \n  class ListNode {\n      int val;\n      ListNode next;\n      ListNode(int x) {\n          val = x;\n          next = null;\n      }\n  }\n\nHow is it possible to create a node that has next different from null? Could someone explain?"
                    },
                    {
                        "username": "aakriti_meh",
                        "content": "it is simply giving the default value for any node .........even if u do not assign any value for val and next then too it will assume the default values as 0 and null [in java it works this way..i am not sure of other languages ]"
                    },
                    {
                        "username": "storzian",
                        "content": "Are all values in the list unique?"
                    },
                    {
                        "username": "vuoxa",
                        "content": "How do I need to understand from the sequences ```[3,2,0,-4]``` and ```[1,2]``` that there\\'s a cycle in them?"
                    },
                    {
                        "username": "Niemand1337",
                        "content": "There is a mistake in this question: In the inputs \\'pos\\' is given, wich is what searched in the code. For the funktion itself it is not given, as this would give the solution away. But with some code it can be read out outside of the solution and the result can be written in the user out.\\nAs this is just reading the \\'pos\\' value it is the fastes way with the least use of memory.\\n\\nI have done this in python in this problem and in the follow-up linked list cycle II, with time beat of 99.9% and memory beat of 100%.\\nThis is unfair and should be fixed in future\\n(If it is not wanted)\\n\\nFor those who want to try this:\\nIn python this can be done with the following:\\n\\'with open(\"user.out\", \"w\") as f\\'\\n\\'__Utils__().read_lines()\\'\\nand\\n\\'f.write()\\'"
                    }
                ]
            },
            {
                "id": 1786432,
                "content": [
                    {
                        "username": "Mukul_reign",
                        "content": "basically if in the traversal of the linked list if we discover NULL that means the linked list is not in a cycle ,... so to check the loop we can use Floyd\\'s Cycle detection algorithm which uses an two pointer,..."
                    },
                    {
                        "username": "cagils",
                        "content": "A simple solution is using the fast-slow pointer comparison approach and doing the iteration entirely in the header of the for() like this:\\nJavascript example:\\n```js\\n    for(let s = head, f = s?.next?.next; f; s = s.next, f=f.next?.next) if (f === s) return true\\n    return false\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lopharb",
                        "content": "so, can someone please explain the 3rd test case to me? the list consists of just a single element, but i\\'m pretty sure it actually has a cycle (my code returns `true` only of we encounter the same element twice, and, well, it does return `true` on the 3rd case). on the other hand, `head.next == next ` returns `false`, which makes sense cause that\\'s the answer. but, what I can\\'t understand is how does it get into a loop then? are there hidden elements or something?\\n\\nfor those who are interested in how my code works\\ni\\'ve actually tried several methods, including relative velocity, marking elements seen by changing their value to \"-\" and simply storing each element into a dictionary and seeing if any of them appears twice\\nso, i think at least one of them should work on that one\\nand each one of this approaches says there\\'s a loop in the 3rd test case\\nidk maybe i did make a mistake somewhere, but i can\\'t seem to figure out where\\n"
                    },
                    {
                        "username": "Vikasreddy369",
                        "content": "I solved by making use of constraints ,suprisingly  my solution got  accepted, but i dont think it is a better solution  , . May be i need to further optimise it"
                    },
                    {
                        "username": "user0949Z",
                        "content": "Idk what happening here. Why \\'Error - Found cycle in the ListNode\\' shows in head.next?"
                    },
                    {
                        "username": "jdsalasca",
                        "content": "Easy using the tortoise and hate algorithm"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This doesn't make sense to me: \n  class ListNode {\n      int val;\n      ListNode next;\n      ListNode(int x) {\n          val = x;\n          next = null;\n      }\n  }\n\nHow is it possible to create a node that has next different from null? Could someone explain?"
                    },
                    {
                        "username": "aakriti_meh",
                        "content": "it is simply giving the default value for any node .........even if u do not assign any value for val and next then too it will assume the default values as 0 and null [in java it works this way..i am not sure of other languages ]"
                    },
                    {
                        "username": "storzian",
                        "content": "Are all values in the list unique?"
                    },
                    {
                        "username": "vuoxa",
                        "content": "How do I need to understand from the sequences ```[3,2,0,-4]``` and ```[1,2]``` that there\\'s a cycle in them?"
                    },
                    {
                        "username": "Niemand1337",
                        "content": "There is a mistake in this question: In the inputs \\'pos\\' is given, wich is what searched in the code. For the funktion itself it is not given, as this would give the solution away. But with some code it can be read out outside of the solution and the result can be written in the user out.\\nAs this is just reading the \\'pos\\' value it is the fastes way with the least use of memory.\\n\\nI have done this in python in this problem and in the follow-up linked list cycle II, with time beat of 99.9% and memory beat of 100%.\\nThis is unfair and should be fixed in future\\n(If it is not wanted)\\n\\nFor those who want to try this:\\nIn python this can be done with the following:\\n\\'with open(\"user.out\", \"w\") as f\\'\\n\\'__Utils__().read_lines()\\'\\nand\\n\\'f.write()\\'"
                    }
                ]
            },
            {
                "id": 1774539,
                "content": [
                    {
                        "username": "NarinderSingh",
                        "content": "NO NEED TO USE ANY POINTER\\n1) Hint - Take Advantage of what credentials they have given in the que.\\n2) Hint - Try to use recursion.\\n3) Hint - Change linked List Values ( we have to just find whether a cycle is there or not. we can manipulate the list )"
                    },
                    {
                        "username": "icantcodeatall",
                        "content": "For anyone confused about the \"pos\", you can safely ignore it. It\\'s an internal detail, not something to worry about. \\nYou just need to do is detect if there\\'s a cycle in the linked list, that\\'s all."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": " //java code \\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n            if(head == null || head.next == null)\\n            {\\n            return false;\\n            }\\n            ListNode slow = head;\\n            ListNode fast = head.next;\\n        while(slow != fast) {\\n                if(fast == null || fast.next == null)\\n                {\\n                return false;\\n                }\\n        slow = slow.next;\\n        fast = fast.next.next;\\n         }\\n         return true;\\n      }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9131YR",
                        "content": "I don't understand why one would even resort to Floyd's cycle detection. Just iterate 10000 times and see if null pointers are hit, no?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Vishwas_Khanna",
                        "content": "pos as input is confusing."
                    },
                    {
                        "username": "aprilman_j",
                        "content": "In case of java solution I think this is bad idea to let people compare objects with `==`. After looking at solution some people might think this is correct approach."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "kzlatt",
                        "content": "OK.. I am confused. At first I thought \"are all values unique and non-repeating\". Later I just blindly use a continuously appended list of heads (a bit dumb) but it works (with runtime <6%  with >1 sec). \\n\\nPlease someone confirms if my understanding is correct.... (i have no formal CS degree so not sure these link-lists are common things in pro-world)\\n......\\nData structure has two elements [value, memory address] or  [v, add] for short..\\nThese data are stored in the memory with address following :\\n\\nMemory -->  what stored in that place\\nadd_0 --> [ val_1, add_1]\\nadd_1 --> [ val_2, add_2]\\nadd_2 --> [ val_3, add_3]\\nadd_3 --> [ val_4, add_1]    # now this is circulating back to add_1\\n\\n\\'head\\' variable actually stored \\'add_0\\', the memory address of [ val, add]..  and  \\'head.val\\' give the \\'val_1\\' (which never used) and \\'head.next\\' give the memory address \\'add_1\\' stored in the head. So when I use    \\'p = head.next\\'... now \\'p = add_1\\'   and   \\'p.val = val_2\\' and \\'p.next = add_2\\'..\\n\\nis that correct.???? I believe that is why there is no two \\'heads\\' alike without cycling but there may be possible that values are circulating .. eg: [head.next.val for i in range(x)]  could gives  [ 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 5, ... so on ]  with repeating pattern of values without \"cycling\" in their sense."
                    }
                ]
            },
            {
                "id": 1768570,
                "content": [
                    {
                        "username": "NarinderSingh",
                        "content": "NO NEED TO USE ANY POINTER\\n1) Hint - Take Advantage of what credentials they have given in the que.\\n2) Hint - Try to use recursion.\\n3) Hint - Change linked List Values ( we have to just find whether a cycle is there or not. we can manipulate the list )"
                    },
                    {
                        "username": "icantcodeatall",
                        "content": "For anyone confused about the \"pos\", you can safely ignore it. It\\'s an internal detail, not something to worry about. \\nYou just need to do is detect if there\\'s a cycle in the linked list, that\\'s all."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": " //java code \\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n            if(head == null || head.next == null)\\n            {\\n            return false;\\n            }\\n            ListNode slow = head;\\n            ListNode fast = head.next;\\n        while(slow != fast) {\\n                if(fast == null || fast.next == null)\\n                {\\n                return false;\\n                }\\n        slow = slow.next;\\n        fast = fast.next.next;\\n         }\\n         return true;\\n      }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9131YR",
                        "content": "I don't understand why one would even resort to Floyd's cycle detection. Just iterate 10000 times and see if null pointers are hit, no?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Vishwas_Khanna",
                        "content": "pos as input is confusing."
                    },
                    {
                        "username": "aprilman_j",
                        "content": "In case of java solution I think this is bad idea to let people compare objects with `==`. After looking at solution some people might think this is correct approach."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "kzlatt",
                        "content": "OK.. I am confused. At first I thought \"are all values unique and non-repeating\". Later I just blindly use a continuously appended list of heads (a bit dumb) but it works (with runtime <6%  with >1 sec). \\n\\nPlease someone confirms if my understanding is correct.... (i have no formal CS degree so not sure these link-lists are common things in pro-world)\\n......\\nData structure has two elements [value, memory address] or  [v, add] for short..\\nThese data are stored in the memory with address following :\\n\\nMemory -->  what stored in that place\\nadd_0 --> [ val_1, add_1]\\nadd_1 --> [ val_2, add_2]\\nadd_2 --> [ val_3, add_3]\\nadd_3 --> [ val_4, add_1]    # now this is circulating back to add_1\\n\\n\\'head\\' variable actually stored \\'add_0\\', the memory address of [ val, add]..  and  \\'head.val\\' give the \\'val_1\\' (which never used) and \\'head.next\\' give the memory address \\'add_1\\' stored in the head. So when I use    \\'p = head.next\\'... now \\'p = add_1\\'   and   \\'p.val = val_2\\' and \\'p.next = add_2\\'..\\n\\nis that correct.???? I believe that is why there is no two \\'heads\\' alike without cycling but there may be possible that values are circulating .. eg: [head.next.val for i in range(x)]  could gives  [ 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 5, ... so on ]  with repeating pattern of values without \"cycling\" in their sense."
                    }
                ]
            },
            {
                "id": 1768473,
                "content": [
                    {
                        "username": "NarinderSingh",
                        "content": "NO NEED TO USE ANY POINTER\\n1) Hint - Take Advantage of what credentials they have given in the que.\\n2) Hint - Try to use recursion.\\n3) Hint - Change linked List Values ( we have to just find whether a cycle is there or not. we can manipulate the list )"
                    },
                    {
                        "username": "icantcodeatall",
                        "content": "For anyone confused about the \"pos\", you can safely ignore it. It\\'s an internal detail, not something to worry about. \\nYou just need to do is detect if there\\'s a cycle in the linked list, that\\'s all."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": " //java code \\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n            if(head == null || head.next == null)\\n            {\\n            return false;\\n            }\\n            ListNode slow = head;\\n            ListNode fast = head.next;\\n        while(slow != fast) {\\n                if(fast == null || fast.next == null)\\n                {\\n                return false;\\n                }\\n        slow = slow.next;\\n        fast = fast.next.next;\\n         }\\n         return true;\\n      }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9131YR",
                        "content": "I don't understand why one would even resort to Floyd's cycle detection. Just iterate 10000 times and see if null pointers are hit, no?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Vishwas_Khanna",
                        "content": "pos as input is confusing."
                    },
                    {
                        "username": "aprilman_j",
                        "content": "In case of java solution I think this is bad idea to let people compare objects with `==`. After looking at solution some people might think this is correct approach."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "kzlatt",
                        "content": "OK.. I am confused. At first I thought \"are all values unique and non-repeating\". Later I just blindly use a continuously appended list of heads (a bit dumb) but it works (with runtime <6%  with >1 sec). \\n\\nPlease someone confirms if my understanding is correct.... (i have no formal CS degree so not sure these link-lists are common things in pro-world)\\n......\\nData structure has two elements [value, memory address] or  [v, add] for short..\\nThese data are stored in the memory with address following :\\n\\nMemory -->  what stored in that place\\nadd_0 --> [ val_1, add_1]\\nadd_1 --> [ val_2, add_2]\\nadd_2 --> [ val_3, add_3]\\nadd_3 --> [ val_4, add_1]    # now this is circulating back to add_1\\n\\n\\'head\\' variable actually stored \\'add_0\\', the memory address of [ val, add]..  and  \\'head.val\\' give the \\'val_1\\' (which never used) and \\'head.next\\' give the memory address \\'add_1\\' stored in the head. So when I use    \\'p = head.next\\'... now \\'p = add_1\\'   and   \\'p.val = val_2\\' and \\'p.next = add_2\\'..\\n\\nis that correct.???? I believe that is why there is no two \\'heads\\' alike without cycling but there may be possible that values are circulating .. eg: [head.next.val for i in range(x)]  could gives  [ 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 5, ... so on ]  with repeating pattern of values without \"cycling\" in their sense."
                    }
                ]
            },
            {
                "id": 1766243,
                "content": [
                    {
                        "username": "NarinderSingh",
                        "content": "NO NEED TO USE ANY POINTER\\n1) Hint - Take Advantage of what credentials they have given in the que.\\n2) Hint - Try to use recursion.\\n3) Hint - Change linked List Values ( we have to just find whether a cycle is there or not. we can manipulate the list )"
                    },
                    {
                        "username": "icantcodeatall",
                        "content": "For anyone confused about the \"pos\", you can safely ignore it. It\\'s an internal detail, not something to worry about. \\nYou just need to do is detect if there\\'s a cycle in the linked list, that\\'s all."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": " //java code \\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n            if(head == null || head.next == null)\\n            {\\n            return false;\\n            }\\n            ListNode slow = head;\\n            ListNode fast = head.next;\\n        while(slow != fast) {\\n                if(fast == null || fast.next == null)\\n                {\\n                return false;\\n                }\\n        slow = slow.next;\\n        fast = fast.next.next;\\n         }\\n         return true;\\n      }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9131YR",
                        "content": "I don't understand why one would even resort to Floyd's cycle detection. Just iterate 10000 times and see if null pointers are hit, no?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Vishwas_Khanna",
                        "content": "pos as input is confusing."
                    },
                    {
                        "username": "aprilman_j",
                        "content": "In case of java solution I think this is bad idea to let people compare objects with `==`. After looking at solution some people might think this is correct approach."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "kzlatt",
                        "content": "OK.. I am confused. At first I thought \"are all values unique and non-repeating\". Later I just blindly use a continuously appended list of heads (a bit dumb) but it works (with runtime <6%  with >1 sec). \\n\\nPlease someone confirms if my understanding is correct.... (i have no formal CS degree so not sure these link-lists are common things in pro-world)\\n......\\nData structure has two elements [value, memory address] or  [v, add] for short..\\nThese data are stored in the memory with address following :\\n\\nMemory -->  what stored in that place\\nadd_0 --> [ val_1, add_1]\\nadd_1 --> [ val_2, add_2]\\nadd_2 --> [ val_3, add_3]\\nadd_3 --> [ val_4, add_1]    # now this is circulating back to add_1\\n\\n\\'head\\' variable actually stored \\'add_0\\', the memory address of [ val, add]..  and  \\'head.val\\' give the \\'val_1\\' (which never used) and \\'head.next\\' give the memory address \\'add_1\\' stored in the head. So when I use    \\'p = head.next\\'... now \\'p = add_1\\'   and   \\'p.val = val_2\\' and \\'p.next = add_2\\'..\\n\\nis that correct.???? I believe that is why there is no two \\'heads\\' alike without cycling but there may be possible that values are circulating .. eg: [head.next.val for i in range(x)]  could gives  [ 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 5, ... so on ]  with repeating pattern of values without \"cycling\" in their sense."
                    }
                ]
            },
            {
                "id": 1762418,
                "content": [
                    {
                        "username": "NarinderSingh",
                        "content": "NO NEED TO USE ANY POINTER\\n1) Hint - Take Advantage of what credentials they have given in the que.\\n2) Hint - Try to use recursion.\\n3) Hint - Change linked List Values ( we have to just find whether a cycle is there or not. we can manipulate the list )"
                    },
                    {
                        "username": "icantcodeatall",
                        "content": "For anyone confused about the \"pos\", you can safely ignore it. It\\'s an internal detail, not something to worry about. \\nYou just need to do is detect if there\\'s a cycle in the linked list, that\\'s all."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": " //java code \\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n            if(head == null || head.next == null)\\n            {\\n            return false;\\n            }\\n            ListNode slow = head;\\n            ListNode fast = head.next;\\n        while(slow != fast) {\\n                if(fast == null || fast.next == null)\\n                {\\n                return false;\\n                }\\n        slow = slow.next;\\n        fast = fast.next.next;\\n         }\\n         return true;\\n      }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9131YR",
                        "content": "I don't understand why one would even resort to Floyd's cycle detection. Just iterate 10000 times and see if null pointers are hit, no?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Vishwas_Khanna",
                        "content": "pos as input is confusing."
                    },
                    {
                        "username": "aprilman_j",
                        "content": "In case of java solution I think this is bad idea to let people compare objects with `==`. After looking at solution some people might think this is correct approach."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "kzlatt",
                        "content": "OK.. I am confused. At first I thought \"are all values unique and non-repeating\". Later I just blindly use a continuously appended list of heads (a bit dumb) but it works (with runtime <6%  with >1 sec). \\n\\nPlease someone confirms if my understanding is correct.... (i have no formal CS degree so not sure these link-lists are common things in pro-world)\\n......\\nData structure has two elements [value, memory address] or  [v, add] for short..\\nThese data are stored in the memory with address following :\\n\\nMemory -->  what stored in that place\\nadd_0 --> [ val_1, add_1]\\nadd_1 --> [ val_2, add_2]\\nadd_2 --> [ val_3, add_3]\\nadd_3 --> [ val_4, add_1]    # now this is circulating back to add_1\\n\\n\\'head\\' variable actually stored \\'add_0\\', the memory address of [ val, add]..  and  \\'head.val\\' give the \\'val_1\\' (which never used) and \\'head.next\\' give the memory address \\'add_1\\' stored in the head. So when I use    \\'p = head.next\\'... now \\'p = add_1\\'   and   \\'p.val = val_2\\' and \\'p.next = add_2\\'..\\n\\nis that correct.???? I believe that is why there is no two \\'heads\\' alike without cycling but there may be possible that values are circulating .. eg: [head.next.val for i in range(x)]  could gives  [ 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 5, ... so on ]  with repeating pattern of values without \"cycling\" in their sense."
                    }
                ]
            },
            {
                "id": 1761014,
                "content": [
                    {
                        "username": "NarinderSingh",
                        "content": "NO NEED TO USE ANY POINTER\\n1) Hint - Take Advantage of what credentials they have given in the que.\\n2) Hint - Try to use recursion.\\n3) Hint - Change linked List Values ( we have to just find whether a cycle is there or not. we can manipulate the list )"
                    },
                    {
                        "username": "icantcodeatall",
                        "content": "For anyone confused about the \"pos\", you can safely ignore it. It\\'s an internal detail, not something to worry about. \\nYou just need to do is detect if there\\'s a cycle in the linked list, that\\'s all."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": " //java code \\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n            if(head == null || head.next == null)\\n            {\\n            return false;\\n            }\\n            ListNode slow = head;\\n            ListNode fast = head.next;\\n        while(slow != fast) {\\n                if(fast == null || fast.next == null)\\n                {\\n                return false;\\n                }\\n        slow = slow.next;\\n        fast = fast.next.next;\\n         }\\n         return true;\\n      }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9131YR",
                        "content": "I don't understand why one would even resort to Floyd's cycle detection. Just iterate 10000 times and see if null pointers are hit, no?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Vishwas_Khanna",
                        "content": "pos as input is confusing."
                    },
                    {
                        "username": "aprilman_j",
                        "content": "In case of java solution I think this is bad idea to let people compare objects with `==`. After looking at solution some people might think this is correct approach."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "kzlatt",
                        "content": "OK.. I am confused. At first I thought \"are all values unique and non-repeating\". Later I just blindly use a continuously appended list of heads (a bit dumb) but it works (with runtime <6%  with >1 sec). \\n\\nPlease someone confirms if my understanding is correct.... (i have no formal CS degree so not sure these link-lists are common things in pro-world)\\n......\\nData structure has two elements [value, memory address] or  [v, add] for short..\\nThese data are stored in the memory with address following :\\n\\nMemory -->  what stored in that place\\nadd_0 --> [ val_1, add_1]\\nadd_1 --> [ val_2, add_2]\\nadd_2 --> [ val_3, add_3]\\nadd_3 --> [ val_4, add_1]    # now this is circulating back to add_1\\n\\n\\'head\\' variable actually stored \\'add_0\\', the memory address of [ val, add]..  and  \\'head.val\\' give the \\'val_1\\' (which never used) and \\'head.next\\' give the memory address \\'add_1\\' stored in the head. So when I use    \\'p = head.next\\'... now \\'p = add_1\\'   and   \\'p.val = val_2\\' and \\'p.next = add_2\\'..\\n\\nis that correct.???? I believe that is why there is no two \\'heads\\' alike without cycling but there may be possible that values are circulating .. eg: [head.next.val for i in range(x)]  could gives  [ 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 5, ... so on ]  with repeating pattern of values without \"cycling\" in their sense."
                    }
                ]
            },
            {
                "id": 1760670,
                "content": [
                    {
                        "username": "NarinderSingh",
                        "content": "NO NEED TO USE ANY POINTER\\n1) Hint - Take Advantage of what credentials they have given in the que.\\n2) Hint - Try to use recursion.\\n3) Hint - Change linked List Values ( we have to just find whether a cycle is there or not. we can manipulate the list )"
                    },
                    {
                        "username": "icantcodeatall",
                        "content": "For anyone confused about the \"pos\", you can safely ignore it. It\\'s an internal detail, not something to worry about. \\nYou just need to do is detect if there\\'s a cycle in the linked list, that\\'s all."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": " //java code \\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n            if(head == null || head.next == null)\\n            {\\n            return false;\\n            }\\n            ListNode slow = head;\\n            ListNode fast = head.next;\\n        while(slow != fast) {\\n                if(fast == null || fast.next == null)\\n                {\\n                return false;\\n                }\\n        slow = slow.next;\\n        fast = fast.next.next;\\n         }\\n         return true;\\n      }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9131YR",
                        "content": "I don't understand why one would even resort to Floyd's cycle detection. Just iterate 10000 times and see if null pointers are hit, no?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Vishwas_Khanna",
                        "content": "pos as input is confusing."
                    },
                    {
                        "username": "aprilman_j",
                        "content": "In case of java solution I think this is bad idea to let people compare objects with `==`. After looking at solution some people might think this is correct approach."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "kzlatt",
                        "content": "OK.. I am confused. At first I thought \"are all values unique and non-repeating\". Later I just blindly use a continuously appended list of heads (a bit dumb) but it works (with runtime <6%  with >1 sec). \\n\\nPlease someone confirms if my understanding is correct.... (i have no formal CS degree so not sure these link-lists are common things in pro-world)\\n......\\nData structure has two elements [value, memory address] or  [v, add] for short..\\nThese data are stored in the memory with address following :\\n\\nMemory -->  what stored in that place\\nadd_0 --> [ val_1, add_1]\\nadd_1 --> [ val_2, add_2]\\nadd_2 --> [ val_3, add_3]\\nadd_3 --> [ val_4, add_1]    # now this is circulating back to add_1\\n\\n\\'head\\' variable actually stored \\'add_0\\', the memory address of [ val, add]..  and  \\'head.val\\' give the \\'val_1\\' (which never used) and \\'head.next\\' give the memory address \\'add_1\\' stored in the head. So when I use    \\'p = head.next\\'... now \\'p = add_1\\'   and   \\'p.val = val_2\\' and \\'p.next = add_2\\'..\\n\\nis that correct.???? I believe that is why there is no two \\'heads\\' alike without cycling but there may be possible that values are circulating .. eg: [head.next.val for i in range(x)]  could gives  [ 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 5, ... so on ]  with repeating pattern of values without \"cycling\" in their sense."
                    }
                ]
            },
            {
                "id": 1752890,
                "content": [
                    {
                        "username": "NarinderSingh",
                        "content": "NO NEED TO USE ANY POINTER\\n1) Hint - Take Advantage of what credentials they have given in the que.\\n2) Hint - Try to use recursion.\\n3) Hint - Change linked List Values ( we have to just find whether a cycle is there or not. we can manipulate the list )"
                    },
                    {
                        "username": "icantcodeatall",
                        "content": "For anyone confused about the \"pos\", you can safely ignore it. It\\'s an internal detail, not something to worry about. \\nYou just need to do is detect if there\\'s a cycle in the linked list, that\\'s all."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": " //java code \\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n            if(head == null || head.next == null)\\n            {\\n            return false;\\n            }\\n            ListNode slow = head;\\n            ListNode fast = head.next;\\n        while(slow != fast) {\\n                if(fast == null || fast.next == null)\\n                {\\n                return false;\\n                }\\n        slow = slow.next;\\n        fast = fast.next.next;\\n         }\\n         return true;\\n      }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9131YR",
                        "content": "I don't understand why one would even resort to Floyd's cycle detection. Just iterate 10000 times and see if null pointers are hit, no?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Vishwas_Khanna",
                        "content": "pos as input is confusing."
                    },
                    {
                        "username": "aprilman_j",
                        "content": "In case of java solution I think this is bad idea to let people compare objects with `==`. After looking at solution some people might think this is correct approach."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "kzlatt",
                        "content": "OK.. I am confused. At first I thought \"are all values unique and non-repeating\". Later I just blindly use a continuously appended list of heads (a bit dumb) but it works (with runtime <6%  with >1 sec). \\n\\nPlease someone confirms if my understanding is correct.... (i have no formal CS degree so not sure these link-lists are common things in pro-world)\\n......\\nData structure has two elements [value, memory address] or  [v, add] for short..\\nThese data are stored in the memory with address following :\\n\\nMemory -->  what stored in that place\\nadd_0 --> [ val_1, add_1]\\nadd_1 --> [ val_2, add_2]\\nadd_2 --> [ val_3, add_3]\\nadd_3 --> [ val_4, add_1]    # now this is circulating back to add_1\\n\\n\\'head\\' variable actually stored \\'add_0\\', the memory address of [ val, add]..  and  \\'head.val\\' give the \\'val_1\\' (which never used) and \\'head.next\\' give the memory address \\'add_1\\' stored in the head. So when I use    \\'p = head.next\\'... now \\'p = add_1\\'   and   \\'p.val = val_2\\' and \\'p.next = add_2\\'..\\n\\nis that correct.???? I believe that is why there is no two \\'heads\\' alike without cycling but there may be possible that values are circulating .. eg: [head.next.val for i in range(x)]  could gives  [ 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 5, ... so on ]  with repeating pattern of values without \"cycling\" in their sense."
                    }
                ]
            },
            {
                "id": 1752682,
                "content": [
                    {
                        "username": "NarinderSingh",
                        "content": "NO NEED TO USE ANY POINTER\\n1) Hint - Take Advantage of what credentials they have given in the que.\\n2) Hint - Try to use recursion.\\n3) Hint - Change linked List Values ( we have to just find whether a cycle is there or not. we can manipulate the list )"
                    },
                    {
                        "username": "icantcodeatall",
                        "content": "For anyone confused about the \"pos\", you can safely ignore it. It\\'s an internal detail, not something to worry about. \\nYou just need to do is detect if there\\'s a cycle in the linked list, that\\'s all."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": " //java code \\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n            if(head == null || head.next == null)\\n            {\\n            return false;\\n            }\\n            ListNode slow = head;\\n            ListNode fast = head.next;\\n        while(slow != fast) {\\n                if(fast == null || fast.next == null)\\n                {\\n                return false;\\n                }\\n        slow = slow.next;\\n        fast = fast.next.next;\\n         }\\n         return true;\\n      }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9131YR",
                        "content": "I don't understand why one would even resort to Floyd's cycle detection. Just iterate 10000 times and see if null pointers are hit, no?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Vishwas_Khanna",
                        "content": "pos as input is confusing."
                    },
                    {
                        "username": "aprilman_j",
                        "content": "In case of java solution I think this is bad idea to let people compare objects with `==`. After looking at solution some people might think this is correct approach."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "kzlatt",
                        "content": "OK.. I am confused. At first I thought \"are all values unique and non-repeating\". Later I just blindly use a continuously appended list of heads (a bit dumb) but it works (with runtime <6%  with >1 sec). \\n\\nPlease someone confirms if my understanding is correct.... (i have no formal CS degree so not sure these link-lists are common things in pro-world)\\n......\\nData structure has two elements [value, memory address] or  [v, add] for short..\\nThese data are stored in the memory with address following :\\n\\nMemory -->  what stored in that place\\nadd_0 --> [ val_1, add_1]\\nadd_1 --> [ val_2, add_2]\\nadd_2 --> [ val_3, add_3]\\nadd_3 --> [ val_4, add_1]    # now this is circulating back to add_1\\n\\n\\'head\\' variable actually stored \\'add_0\\', the memory address of [ val, add]..  and  \\'head.val\\' give the \\'val_1\\' (which never used) and \\'head.next\\' give the memory address \\'add_1\\' stored in the head. So when I use    \\'p = head.next\\'... now \\'p = add_1\\'   and   \\'p.val = val_2\\' and \\'p.next = add_2\\'..\\n\\nis that correct.???? I believe that is why there is no two \\'heads\\' alike without cycling but there may be possible that values are circulating .. eg: [head.next.val for i in range(x)]  could gives  [ 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 5, ... so on ]  with repeating pattern of values without \"cycling\" in their sense."
                    }
                ]
            },
            {
                "id": 1745923,
                "content": [
                    {
                        "username": "NarinderSingh",
                        "content": "NO NEED TO USE ANY POINTER\\n1) Hint - Take Advantage of what credentials they have given in the que.\\n2) Hint - Try to use recursion.\\n3) Hint - Change linked List Values ( we have to just find whether a cycle is there or not. we can manipulate the list )"
                    },
                    {
                        "username": "icantcodeatall",
                        "content": "For anyone confused about the \"pos\", you can safely ignore it. It\\'s an internal detail, not something to worry about. \\nYou just need to do is detect if there\\'s a cycle in the linked list, that\\'s all."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": " //java code \\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n            if(head == null || head.next == null)\\n            {\\n            return false;\\n            }\\n            ListNode slow = head;\\n            ListNode fast = head.next;\\n        while(slow != fast) {\\n                if(fast == null || fast.next == null)\\n                {\\n                return false;\\n                }\\n        slow = slow.next;\\n        fast = fast.next.next;\\n         }\\n         return true;\\n      }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9131YR",
                        "content": "I don't understand why one would even resort to Floyd's cycle detection. Just iterate 10000 times and see if null pointers are hit, no?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Vishwas_Khanna",
                        "content": "pos as input is confusing."
                    },
                    {
                        "username": "aprilman_j",
                        "content": "In case of java solution I think this is bad idea to let people compare objects with `==`. After looking at solution some people might think this is correct approach."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "kzlatt",
                        "content": "OK.. I am confused. At first I thought \"are all values unique and non-repeating\". Later I just blindly use a continuously appended list of heads (a bit dumb) but it works (with runtime <6%  with >1 sec). \\n\\nPlease someone confirms if my understanding is correct.... (i have no formal CS degree so not sure these link-lists are common things in pro-world)\\n......\\nData structure has two elements [value, memory address] or  [v, add] for short..\\nThese data are stored in the memory with address following :\\n\\nMemory -->  what stored in that place\\nadd_0 --> [ val_1, add_1]\\nadd_1 --> [ val_2, add_2]\\nadd_2 --> [ val_3, add_3]\\nadd_3 --> [ val_4, add_1]    # now this is circulating back to add_1\\n\\n\\'head\\' variable actually stored \\'add_0\\', the memory address of [ val, add]..  and  \\'head.val\\' give the \\'val_1\\' (which never used) and \\'head.next\\' give the memory address \\'add_1\\' stored in the head. So when I use    \\'p = head.next\\'... now \\'p = add_1\\'   and   \\'p.val = val_2\\' and \\'p.next = add_2\\'..\\n\\nis that correct.???? I believe that is why there is no two \\'heads\\' alike without cycling but there may be possible that values are circulating .. eg: [head.next.val for i in range(x)]  could gives  [ 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 5, ... so on ]  with repeating pattern of values without \"cycling\" in their sense."
                    }
                ]
            },
            {
                "id": 1730719,
                "content": [
                    {
                        "username": "dariusz007",
                        "content": "A question from a beginner, if I may:\\n\\n1. why can\\'t I print the head? For example:\\n `print(head)`\\nin the Stdout I get:\\n `Error - Found cycle in the ListNode`\\n\\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Since the ListNode has a cycle, we can\\'t reach the end. Because of that the ListNode doesn\\'t stop in any node and keep going. It\\'s hard, very hard to print some thing that doesn\\'t has an end. But I think, we can print the val of the head."
                    },
                    {
                        "username": "Akashverma212",
                        "content": "Easy using hare /turtle approach"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "anishkumarsahoo1",
                        "content": "  slow,fast=head,head\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n            if slow==fast:\\n                return True\\n        return False\\nwhy do i have to write fast.next in while ?will it not work without it? "
                    },
                    {
                        "username": "District_12",
                        "content": "I don\\'t understand the Description."
                    },
                    {
                        "username": "user4628p",
                        "content": "public class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n            if(slow==fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "kasireddy_13177",
                        "content": " @[leetcode](https://leetcode.com)class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* temp=head;\\n        if(head==NULL)\\n        return false;\\n        if(temp->next==head)\\n        return true;\\n        \\n        map<ListNode *,int>mp;\\n        while(1){\\n            auto it=mp.find(temp);\\n            if(it!=mp.end())\\n            return true;\\n            else\\n            mp[temp];\\n            temp=temp->next;\\n            if(temp==NULL)\\n            return false;\\n\\n        }\\n        \\n        \\n    }\\n};\\nConsole\\n"
                    },
                    {
                        "username": "__tejas_01",
                        "content": "\\n// EASY SOLUTION IN C\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nbool hasCycle(struct ListNode *head) {\\n    if(head==NULL){return false;}\\n    struct ListNode *fast=head;\\n    struct ListNode *slow=head;\\n    while(fast!=NULL&&fast->next!=NULL){\\n        fast=fast->next->next;\\n        slow=slow->next;\\n        if(slow==fast){return true;}\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "vvvxxx321",
                        "content": "\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null)\\n            return false;\\n            \\n        while(head.next != null){\\n            if(head.next.val > 100000)\\n                return true;\\n\\n            head = head.next;\\n            head.val = 100001;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harsh_koradiya",
                        "content": "       if(head==null){\\n            return false;\\n        }\\n        ListNode temp =  head;\\n        while(temp!=null){\\n\\n            if(temp.val == 100007){\\n                return true;\\n            }\\n            temp.val = 100007;\\n            temp = temp.next;\\n\\n        }\\n        return false;"
                    }
                ]
            },
            {
                "id": 1729698,
                "content": [
                    {
                        "username": "dariusz007",
                        "content": "A question from a beginner, if I may:\\n\\n1. why can\\'t I print the head? For example:\\n `print(head)`\\nin the Stdout I get:\\n `Error - Found cycle in the ListNode`\\n\\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Since the ListNode has a cycle, we can\\'t reach the end. Because of that the ListNode doesn\\'t stop in any node and keep going. It\\'s hard, very hard to print some thing that doesn\\'t has an end. But I think, we can print the val of the head."
                    },
                    {
                        "username": "Akashverma212",
                        "content": "Easy using hare /turtle approach"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "anishkumarsahoo1",
                        "content": "  slow,fast=head,head\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n            if slow==fast:\\n                return True\\n        return False\\nwhy do i have to write fast.next in while ?will it not work without it? "
                    },
                    {
                        "username": "District_12",
                        "content": "I don\\'t understand the Description."
                    },
                    {
                        "username": "user4628p",
                        "content": "public class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n            if(slow==fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "kasireddy_13177",
                        "content": " @[leetcode](https://leetcode.com)class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* temp=head;\\n        if(head==NULL)\\n        return false;\\n        if(temp->next==head)\\n        return true;\\n        \\n        map<ListNode *,int>mp;\\n        while(1){\\n            auto it=mp.find(temp);\\n            if(it!=mp.end())\\n            return true;\\n            else\\n            mp[temp];\\n            temp=temp->next;\\n            if(temp==NULL)\\n            return false;\\n\\n        }\\n        \\n        \\n    }\\n};\\nConsole\\n"
                    },
                    {
                        "username": "__tejas_01",
                        "content": "\\n// EASY SOLUTION IN C\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nbool hasCycle(struct ListNode *head) {\\n    if(head==NULL){return false;}\\n    struct ListNode *fast=head;\\n    struct ListNode *slow=head;\\n    while(fast!=NULL&&fast->next!=NULL){\\n        fast=fast->next->next;\\n        slow=slow->next;\\n        if(slow==fast){return true;}\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "vvvxxx321",
                        "content": "\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null)\\n            return false;\\n            \\n        while(head.next != null){\\n            if(head.next.val > 100000)\\n                return true;\\n\\n            head = head.next;\\n            head.val = 100001;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harsh_koradiya",
                        "content": "       if(head==null){\\n            return false;\\n        }\\n        ListNode temp =  head;\\n        while(temp!=null){\\n\\n            if(temp.val == 100007){\\n                return true;\\n            }\\n            temp.val = 100007;\\n            temp = temp.next;\\n\\n        }\\n        return false;"
                    }
                ]
            },
            {
                "id": 1729156,
                "content": [
                    {
                        "username": "dariusz007",
                        "content": "A question from a beginner, if I may:\\n\\n1. why can\\'t I print the head? For example:\\n `print(head)`\\nin the Stdout I get:\\n `Error - Found cycle in the ListNode`\\n\\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Since the ListNode has a cycle, we can\\'t reach the end. Because of that the ListNode doesn\\'t stop in any node and keep going. It\\'s hard, very hard to print some thing that doesn\\'t has an end. But I think, we can print the val of the head."
                    },
                    {
                        "username": "Akashverma212",
                        "content": "Easy using hare /turtle approach"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "anishkumarsahoo1",
                        "content": "  slow,fast=head,head\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n            if slow==fast:\\n                return True\\n        return False\\nwhy do i have to write fast.next in while ?will it not work without it? "
                    },
                    {
                        "username": "District_12",
                        "content": "I don\\'t understand the Description."
                    },
                    {
                        "username": "user4628p",
                        "content": "public class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n            if(slow==fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "kasireddy_13177",
                        "content": " @[leetcode](https://leetcode.com)class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* temp=head;\\n        if(head==NULL)\\n        return false;\\n        if(temp->next==head)\\n        return true;\\n        \\n        map<ListNode *,int>mp;\\n        while(1){\\n            auto it=mp.find(temp);\\n            if(it!=mp.end())\\n            return true;\\n            else\\n            mp[temp];\\n            temp=temp->next;\\n            if(temp==NULL)\\n            return false;\\n\\n        }\\n        \\n        \\n    }\\n};\\nConsole\\n"
                    },
                    {
                        "username": "__tejas_01",
                        "content": "\\n// EASY SOLUTION IN C\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nbool hasCycle(struct ListNode *head) {\\n    if(head==NULL){return false;}\\n    struct ListNode *fast=head;\\n    struct ListNode *slow=head;\\n    while(fast!=NULL&&fast->next!=NULL){\\n        fast=fast->next->next;\\n        slow=slow->next;\\n        if(slow==fast){return true;}\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "vvvxxx321",
                        "content": "\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null)\\n            return false;\\n            \\n        while(head.next != null){\\n            if(head.next.val > 100000)\\n                return true;\\n\\n            head = head.next;\\n            head.val = 100001;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harsh_koradiya",
                        "content": "       if(head==null){\\n            return false;\\n        }\\n        ListNode temp =  head;\\n        while(temp!=null){\\n\\n            if(temp.val == 100007){\\n                return true;\\n            }\\n            temp.val = 100007;\\n            temp = temp.next;\\n\\n        }\\n        return false;"
                    }
                ]
            },
            {
                "id": 1725713,
                "content": [
                    {
                        "username": "dariusz007",
                        "content": "A question from a beginner, if I may:\\n\\n1. why can\\'t I print the head? For example:\\n `print(head)`\\nin the Stdout I get:\\n `Error - Found cycle in the ListNode`\\n\\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Since the ListNode has a cycle, we can\\'t reach the end. Because of that the ListNode doesn\\'t stop in any node and keep going. It\\'s hard, very hard to print some thing that doesn\\'t has an end. But I think, we can print the val of the head."
                    },
                    {
                        "username": "Akashverma212",
                        "content": "Easy using hare /turtle approach"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "anishkumarsahoo1",
                        "content": "  slow,fast=head,head\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n            if slow==fast:\\n                return True\\n        return False\\nwhy do i have to write fast.next in while ?will it not work without it? "
                    },
                    {
                        "username": "District_12",
                        "content": "I don\\'t understand the Description."
                    },
                    {
                        "username": "user4628p",
                        "content": "public class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n            if(slow==fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "kasireddy_13177",
                        "content": " @[leetcode](https://leetcode.com)class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* temp=head;\\n        if(head==NULL)\\n        return false;\\n        if(temp->next==head)\\n        return true;\\n        \\n        map<ListNode *,int>mp;\\n        while(1){\\n            auto it=mp.find(temp);\\n            if(it!=mp.end())\\n            return true;\\n            else\\n            mp[temp];\\n            temp=temp->next;\\n            if(temp==NULL)\\n            return false;\\n\\n        }\\n        \\n        \\n    }\\n};\\nConsole\\n"
                    },
                    {
                        "username": "__tejas_01",
                        "content": "\\n// EASY SOLUTION IN C\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nbool hasCycle(struct ListNode *head) {\\n    if(head==NULL){return false;}\\n    struct ListNode *fast=head;\\n    struct ListNode *slow=head;\\n    while(fast!=NULL&&fast->next!=NULL){\\n        fast=fast->next->next;\\n        slow=slow->next;\\n        if(slow==fast){return true;}\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "vvvxxx321",
                        "content": "\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null)\\n            return false;\\n            \\n        while(head.next != null){\\n            if(head.next.val > 100000)\\n                return true;\\n\\n            head = head.next;\\n            head.val = 100001;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harsh_koradiya",
                        "content": "       if(head==null){\\n            return false;\\n        }\\n        ListNode temp =  head;\\n        while(temp!=null){\\n\\n            if(temp.val == 100007){\\n                return true;\\n            }\\n            temp.val = 100007;\\n            temp = temp.next;\\n\\n        }\\n        return false;"
                    }
                ]
            },
            {
                "id": 1724841,
                "content": [
                    {
                        "username": "dariusz007",
                        "content": "A question from a beginner, if I may:\\n\\n1. why can\\'t I print the head? For example:\\n `print(head)`\\nin the Stdout I get:\\n `Error - Found cycle in the ListNode`\\n\\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Since the ListNode has a cycle, we can\\'t reach the end. Because of that the ListNode doesn\\'t stop in any node and keep going. It\\'s hard, very hard to print some thing that doesn\\'t has an end. But I think, we can print the val of the head."
                    },
                    {
                        "username": "Akashverma212",
                        "content": "Easy using hare /turtle approach"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "anishkumarsahoo1",
                        "content": "  slow,fast=head,head\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n            if slow==fast:\\n                return True\\n        return False\\nwhy do i have to write fast.next in while ?will it not work without it? "
                    },
                    {
                        "username": "District_12",
                        "content": "I don\\'t understand the Description."
                    },
                    {
                        "username": "user4628p",
                        "content": "public class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n            if(slow==fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "kasireddy_13177",
                        "content": " @[leetcode](https://leetcode.com)class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* temp=head;\\n        if(head==NULL)\\n        return false;\\n        if(temp->next==head)\\n        return true;\\n        \\n        map<ListNode *,int>mp;\\n        while(1){\\n            auto it=mp.find(temp);\\n            if(it!=mp.end())\\n            return true;\\n            else\\n            mp[temp];\\n            temp=temp->next;\\n            if(temp==NULL)\\n            return false;\\n\\n        }\\n        \\n        \\n    }\\n};\\nConsole\\n"
                    },
                    {
                        "username": "__tejas_01",
                        "content": "\\n// EASY SOLUTION IN C\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nbool hasCycle(struct ListNode *head) {\\n    if(head==NULL){return false;}\\n    struct ListNode *fast=head;\\n    struct ListNode *slow=head;\\n    while(fast!=NULL&&fast->next!=NULL){\\n        fast=fast->next->next;\\n        slow=slow->next;\\n        if(slow==fast){return true;}\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "vvvxxx321",
                        "content": "\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null)\\n            return false;\\n            \\n        while(head.next != null){\\n            if(head.next.val > 100000)\\n                return true;\\n\\n            head = head.next;\\n            head.val = 100001;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harsh_koradiya",
                        "content": "       if(head==null){\\n            return false;\\n        }\\n        ListNode temp =  head;\\n        while(temp!=null){\\n\\n            if(temp.val == 100007){\\n                return true;\\n            }\\n            temp.val = 100007;\\n            temp = temp.next;\\n\\n        }\\n        return false;"
                    }
                ]
            },
            {
                "id": 1722781,
                "content": [
                    {
                        "username": "dariusz007",
                        "content": "A question from a beginner, if I may:\\n\\n1. why can\\'t I print the head? For example:\\n `print(head)`\\nin the Stdout I get:\\n `Error - Found cycle in the ListNode`\\n\\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Since the ListNode has a cycle, we can\\'t reach the end. Because of that the ListNode doesn\\'t stop in any node and keep going. It\\'s hard, very hard to print some thing that doesn\\'t has an end. But I think, we can print the val of the head."
                    },
                    {
                        "username": "Akashverma212",
                        "content": "Easy using hare /turtle approach"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "anishkumarsahoo1",
                        "content": "  slow,fast=head,head\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n            if slow==fast:\\n                return True\\n        return False\\nwhy do i have to write fast.next in while ?will it not work without it? "
                    },
                    {
                        "username": "District_12",
                        "content": "I don\\'t understand the Description."
                    },
                    {
                        "username": "user4628p",
                        "content": "public class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n            if(slow==fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "kasireddy_13177",
                        "content": " @[leetcode](https://leetcode.com)class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* temp=head;\\n        if(head==NULL)\\n        return false;\\n        if(temp->next==head)\\n        return true;\\n        \\n        map<ListNode *,int>mp;\\n        while(1){\\n            auto it=mp.find(temp);\\n            if(it!=mp.end())\\n            return true;\\n            else\\n            mp[temp];\\n            temp=temp->next;\\n            if(temp==NULL)\\n            return false;\\n\\n        }\\n        \\n        \\n    }\\n};\\nConsole\\n"
                    },
                    {
                        "username": "__tejas_01",
                        "content": "\\n// EASY SOLUTION IN C\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nbool hasCycle(struct ListNode *head) {\\n    if(head==NULL){return false;}\\n    struct ListNode *fast=head;\\n    struct ListNode *slow=head;\\n    while(fast!=NULL&&fast->next!=NULL){\\n        fast=fast->next->next;\\n        slow=slow->next;\\n        if(slow==fast){return true;}\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "vvvxxx321",
                        "content": "\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null)\\n            return false;\\n            \\n        while(head.next != null){\\n            if(head.next.val > 100000)\\n                return true;\\n\\n            head = head.next;\\n            head.val = 100001;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harsh_koradiya",
                        "content": "       if(head==null){\\n            return false;\\n        }\\n        ListNode temp =  head;\\n        while(temp!=null){\\n\\n            if(temp.val == 100007){\\n                return true;\\n            }\\n            temp.val = 100007;\\n            temp = temp.next;\\n\\n        }\\n        return false;"
                    }
                ]
            },
            {
                "id": 1719675,
                "content": [
                    {
                        "username": "dariusz007",
                        "content": "A question from a beginner, if I may:\\n\\n1. why can\\'t I print the head? For example:\\n `print(head)`\\nin the Stdout I get:\\n `Error - Found cycle in the ListNode`\\n\\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Since the ListNode has a cycle, we can\\'t reach the end. Because of that the ListNode doesn\\'t stop in any node and keep going. It\\'s hard, very hard to print some thing that doesn\\'t has an end. But I think, we can print the val of the head."
                    },
                    {
                        "username": "Akashverma212",
                        "content": "Easy using hare /turtle approach"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "anishkumarsahoo1",
                        "content": "  slow,fast=head,head\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n            if slow==fast:\\n                return True\\n        return False\\nwhy do i have to write fast.next in while ?will it not work without it? "
                    },
                    {
                        "username": "District_12",
                        "content": "I don\\'t understand the Description."
                    },
                    {
                        "username": "user4628p",
                        "content": "public class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n            if(slow==fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "kasireddy_13177",
                        "content": " @[leetcode](https://leetcode.com)class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* temp=head;\\n        if(head==NULL)\\n        return false;\\n        if(temp->next==head)\\n        return true;\\n        \\n        map<ListNode *,int>mp;\\n        while(1){\\n            auto it=mp.find(temp);\\n            if(it!=mp.end())\\n            return true;\\n            else\\n            mp[temp];\\n            temp=temp->next;\\n            if(temp==NULL)\\n            return false;\\n\\n        }\\n        \\n        \\n    }\\n};\\nConsole\\n"
                    },
                    {
                        "username": "__tejas_01",
                        "content": "\\n// EASY SOLUTION IN C\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nbool hasCycle(struct ListNode *head) {\\n    if(head==NULL){return false;}\\n    struct ListNode *fast=head;\\n    struct ListNode *slow=head;\\n    while(fast!=NULL&&fast->next!=NULL){\\n        fast=fast->next->next;\\n        slow=slow->next;\\n        if(slow==fast){return true;}\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "vvvxxx321",
                        "content": "\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null)\\n            return false;\\n            \\n        while(head.next != null){\\n            if(head.next.val > 100000)\\n                return true;\\n\\n            head = head.next;\\n            head.val = 100001;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harsh_koradiya",
                        "content": "       if(head==null){\\n            return false;\\n        }\\n        ListNode temp =  head;\\n        while(temp!=null){\\n\\n            if(temp.val == 100007){\\n                return true;\\n            }\\n            temp.val = 100007;\\n            temp = temp.next;\\n\\n        }\\n        return false;"
                    }
                ]
            },
            {
                "id": 1713812,
                "content": [
                    {
                        "username": "dariusz007",
                        "content": "A question from a beginner, if I may:\\n\\n1. why can\\'t I print the head? For example:\\n `print(head)`\\nin the Stdout I get:\\n `Error - Found cycle in the ListNode`\\n\\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Since the ListNode has a cycle, we can\\'t reach the end. Because of that the ListNode doesn\\'t stop in any node and keep going. It\\'s hard, very hard to print some thing that doesn\\'t has an end. But I think, we can print the val of the head."
                    },
                    {
                        "username": "Akashverma212",
                        "content": "Easy using hare /turtle approach"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "anishkumarsahoo1",
                        "content": "  slow,fast=head,head\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n            if slow==fast:\\n                return True\\n        return False\\nwhy do i have to write fast.next in while ?will it not work without it? "
                    },
                    {
                        "username": "District_12",
                        "content": "I don\\'t understand the Description."
                    },
                    {
                        "username": "user4628p",
                        "content": "public class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n            if(slow==fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "kasireddy_13177",
                        "content": " @[leetcode](https://leetcode.com)class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* temp=head;\\n        if(head==NULL)\\n        return false;\\n        if(temp->next==head)\\n        return true;\\n        \\n        map<ListNode *,int>mp;\\n        while(1){\\n            auto it=mp.find(temp);\\n            if(it!=mp.end())\\n            return true;\\n            else\\n            mp[temp];\\n            temp=temp->next;\\n            if(temp==NULL)\\n            return false;\\n\\n        }\\n        \\n        \\n    }\\n};\\nConsole\\n"
                    },
                    {
                        "username": "__tejas_01",
                        "content": "\\n// EASY SOLUTION IN C\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nbool hasCycle(struct ListNode *head) {\\n    if(head==NULL){return false;}\\n    struct ListNode *fast=head;\\n    struct ListNode *slow=head;\\n    while(fast!=NULL&&fast->next!=NULL){\\n        fast=fast->next->next;\\n        slow=slow->next;\\n        if(slow==fast){return true;}\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "vvvxxx321",
                        "content": "\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null)\\n            return false;\\n            \\n        while(head.next != null){\\n            if(head.next.val > 100000)\\n                return true;\\n\\n            head = head.next;\\n            head.val = 100001;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harsh_koradiya",
                        "content": "       if(head==null){\\n            return false;\\n        }\\n        ListNode temp =  head;\\n        while(temp!=null){\\n\\n            if(temp.val == 100007){\\n                return true;\\n            }\\n            temp.val = 100007;\\n            temp = temp.next;\\n\\n        }\\n        return false;"
                    }
                ]
            },
            {
                "id": 1713769,
                "content": [
                    {
                        "username": "dariusz007",
                        "content": "A question from a beginner, if I may:\\n\\n1. why can\\'t I print the head? For example:\\n `print(head)`\\nin the Stdout I get:\\n `Error - Found cycle in the ListNode`\\n\\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Since the ListNode has a cycle, we can\\'t reach the end. Because of that the ListNode doesn\\'t stop in any node and keep going. It\\'s hard, very hard to print some thing that doesn\\'t has an end. But I think, we can print the val of the head."
                    },
                    {
                        "username": "Akashverma212",
                        "content": "Easy using hare /turtle approach"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "anishkumarsahoo1",
                        "content": "  slow,fast=head,head\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n            if slow==fast:\\n                return True\\n        return False\\nwhy do i have to write fast.next in while ?will it not work without it? "
                    },
                    {
                        "username": "District_12",
                        "content": "I don\\'t understand the Description."
                    },
                    {
                        "username": "user4628p",
                        "content": "public class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n            if(slow==fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "kasireddy_13177",
                        "content": " @[leetcode](https://leetcode.com)class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* temp=head;\\n        if(head==NULL)\\n        return false;\\n        if(temp->next==head)\\n        return true;\\n        \\n        map<ListNode *,int>mp;\\n        while(1){\\n            auto it=mp.find(temp);\\n            if(it!=mp.end())\\n            return true;\\n            else\\n            mp[temp];\\n            temp=temp->next;\\n            if(temp==NULL)\\n            return false;\\n\\n        }\\n        \\n        \\n    }\\n};\\nConsole\\n"
                    },
                    {
                        "username": "__tejas_01",
                        "content": "\\n// EASY SOLUTION IN C\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nbool hasCycle(struct ListNode *head) {\\n    if(head==NULL){return false;}\\n    struct ListNode *fast=head;\\n    struct ListNode *slow=head;\\n    while(fast!=NULL&&fast->next!=NULL){\\n        fast=fast->next->next;\\n        slow=slow->next;\\n        if(slow==fast){return true;}\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "vvvxxx321",
                        "content": "\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null)\\n            return false;\\n            \\n        while(head.next != null){\\n            if(head.next.val > 100000)\\n                return true;\\n\\n            head = head.next;\\n            head.val = 100001;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harsh_koradiya",
                        "content": "       if(head==null){\\n            return false;\\n        }\\n        ListNode temp =  head;\\n        while(temp!=null){\\n\\n            if(temp.val == 100007){\\n                return true;\\n            }\\n            temp.val = 100007;\\n            temp = temp.next;\\n\\n        }\\n        return false;"
                    }
                ]
            },
            {
                "id": 1710455,
                "content": [
                    {
                        "username": "dariusz007",
                        "content": "A question from a beginner, if I may:\\n\\n1. why can\\'t I print the head? For example:\\n `print(head)`\\nin the Stdout I get:\\n `Error - Found cycle in the ListNode`\\n\\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Since the ListNode has a cycle, we can\\'t reach the end. Because of that the ListNode doesn\\'t stop in any node and keep going. It\\'s hard, very hard to print some thing that doesn\\'t has an end. But I think, we can print the val of the head."
                    },
                    {
                        "username": "Akashverma212",
                        "content": "Easy using hare /turtle approach"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/linked-list-cycle-leet-code-141/"
                    },
                    {
                        "username": "anishkumarsahoo1",
                        "content": "  slow,fast=head,head\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n            if slow==fast:\\n                return True\\n        return False\\nwhy do i have to write fast.next in while ?will it not work without it? "
                    },
                    {
                        "username": "District_12",
                        "content": "I don\\'t understand the Description."
                    },
                    {
                        "username": "user4628p",
                        "content": "public class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n            if(slow==fast){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "kasireddy_13177",
                        "content": " @[leetcode](https://leetcode.com)class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode* temp=head;\\n        if(head==NULL)\\n        return false;\\n        if(temp->next==head)\\n        return true;\\n        \\n        map<ListNode *,int>mp;\\n        while(1){\\n            auto it=mp.find(temp);\\n            if(it!=mp.end())\\n            return true;\\n            else\\n            mp[temp];\\n            temp=temp->next;\\n            if(temp==NULL)\\n            return false;\\n\\n        }\\n        \\n        \\n    }\\n};\\nConsole\\n"
                    },
                    {
                        "username": "__tejas_01",
                        "content": "\\n// EASY SOLUTION IN C\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nbool hasCycle(struct ListNode *head) {\\n    if(head==NULL){return false;}\\n    struct ListNode *fast=head;\\n    struct ListNode *slow=head;\\n    while(fast!=NULL&&fast->next!=NULL){\\n        fast=fast->next->next;\\n        slow=slow->next;\\n        if(slow==fast){return true;}\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "vvvxxx321",
                        "content": "\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if(head == null)\\n            return false;\\n            \\n        while(head.next != null){\\n            if(head.next.val > 100000)\\n                return true;\\n\\n            head = head.next;\\n            head.val = 100001;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harsh_koradiya",
                        "content": "       if(head==null){\\n            return false;\\n        }\\n        ListNode temp =  head;\\n        while(temp!=null){\\n\\n            if(temp.val == 100007){\\n                return true;\\n            }\\n            temp.val = 100007;\\n            temp = temp.next;\\n\\n        }\\n        return false;"
                    }
                ]
            },
            {
                "id": 1708344,
                "content": [
                    {
                        "username": "Sanjeev___Thakur",
                        "content": "\\nclass Solution:\\n    def hasCycle(self, head):\\n        if head == None:\\n            return False\\n        slow = head\\n        fast =  head.next\\n        while fast!= None and slow != None:\\n            slow = head.next\\n            fast = head.next.next\\n            return True\\n\\nWith the above code i am able to pass all test cases but i am unable to submit the code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A1Amazon SDE-1 Interview\\uD83D\\uDCA5\\uD83E\\uDD73 #FAANG\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2875561/amazon-sde-1-interview-faang/?orderBy=most_relevant"
                    },
                    {
                        "username": "aanya_969",
                        "content": "What is the need of pos variable??"
                    },
                    {
                        "username": "AlexTyu",
                        "content": "When I use \\n```\\nfast = fast->next->next;\\n slow = slow->next; \\n```\\nMy program gets accepted, but if I use\\n```\\nslow = slow->next;\\nfast = slow->next;\\n```\\nIt says it is too slow. Anyone mind explaining why it is slower?"
                    },
                    {
                        "username": "ashmitarana616",
                        "content": "Here in this question we just need to check whether the given LL is circular or not .\\nSo to check it we just need tho compare the  head and last node if they are connected to eacthother then the Linked List is circular ...\\nif condition  is true returns true  otherwise false !"
                    },
                    {
                        "username": "shyamimmadi7",
                        "content": "what does pos = -1 mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Anees2778",
                        "content": "Someone please help me out : \\nError msg-\\nLine 17: Char 21: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:21\\n\\nI don\\'t get the point, where is the problem in code? [leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "drumsmanku",
                        "content": "Just use set or map"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "What is the need of `pos`, we don't need it anyways. It just makes the example test cases confusing, it can be a part of the explanation in examples but not the input."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used it to make my own test cases. For example, change pos in the 3 example to 0. The answer will be different."
                    },
                    {
                        "username": "ayushisinghania14",
                        "content": "How can we use \"pos\" for verification?  Since its type is showing a built-in function or method we can\\'t even convert it to integer and use to verify. "
                    }
                ]
            },
            {
                "id": 1704917,
                "content": [
                    {
                        "username": "Sanjeev___Thakur",
                        "content": "\\nclass Solution:\\n    def hasCycle(self, head):\\n        if head == None:\\n            return False\\n        slow = head\\n        fast =  head.next\\n        while fast!= None and slow != None:\\n            slow = head.next\\n            fast = head.next.next\\n            return True\\n\\nWith the above code i am able to pass all test cases but i am unable to submit the code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A1Amazon SDE-1 Interview\\uD83D\\uDCA5\\uD83E\\uDD73 #FAANG\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2875561/amazon-sde-1-interview-faang/?orderBy=most_relevant"
                    },
                    {
                        "username": "aanya_969",
                        "content": "What is the need of pos variable??"
                    },
                    {
                        "username": "AlexTyu",
                        "content": "When I use \\n```\\nfast = fast->next->next;\\n slow = slow->next; \\n```\\nMy program gets accepted, but if I use\\n```\\nslow = slow->next;\\nfast = slow->next;\\n```\\nIt says it is too slow. Anyone mind explaining why it is slower?"
                    },
                    {
                        "username": "ashmitarana616",
                        "content": "Here in this question we just need to check whether the given LL is circular or not .\\nSo to check it we just need tho compare the  head and last node if they are connected to eacthother then the Linked List is circular ...\\nif condition  is true returns true  otherwise false !"
                    },
                    {
                        "username": "shyamimmadi7",
                        "content": "what does pos = -1 mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Anees2778",
                        "content": "Someone please help me out : \\nError msg-\\nLine 17: Char 21: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:21\\n\\nI don\\'t get the point, where is the problem in code? [leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "drumsmanku",
                        "content": "Just use set or map"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "What is the need of `pos`, we don't need it anyways. It just makes the example test cases confusing, it can be a part of the explanation in examples but not the input."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used it to make my own test cases. For example, change pos in the 3 example to 0. The answer will be different."
                    },
                    {
                        "username": "ayushisinghania14",
                        "content": "How can we use \"pos\" for verification?  Since its type is showing a built-in function or method we can\\'t even convert it to integer and use to verify. "
                    }
                ]
            },
            {
                "id": 1701863,
                "content": [
                    {
                        "username": "Sanjeev___Thakur",
                        "content": "\\nclass Solution:\\n    def hasCycle(self, head):\\n        if head == None:\\n            return False\\n        slow = head\\n        fast =  head.next\\n        while fast!= None and slow != None:\\n            slow = head.next\\n            fast = head.next.next\\n            return True\\n\\nWith the above code i am able to pass all test cases but i am unable to submit the code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A1Amazon SDE-1 Interview\\uD83D\\uDCA5\\uD83E\\uDD73 #FAANG\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2875561/amazon-sde-1-interview-faang/?orderBy=most_relevant"
                    },
                    {
                        "username": "aanya_969",
                        "content": "What is the need of pos variable??"
                    },
                    {
                        "username": "AlexTyu",
                        "content": "When I use \\n```\\nfast = fast->next->next;\\n slow = slow->next; \\n```\\nMy program gets accepted, but if I use\\n```\\nslow = slow->next;\\nfast = slow->next;\\n```\\nIt says it is too slow. Anyone mind explaining why it is slower?"
                    },
                    {
                        "username": "ashmitarana616",
                        "content": "Here in this question we just need to check whether the given LL is circular or not .\\nSo to check it we just need tho compare the  head and last node if they are connected to eacthother then the Linked List is circular ...\\nif condition  is true returns true  otherwise false !"
                    },
                    {
                        "username": "shyamimmadi7",
                        "content": "what does pos = -1 mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Anees2778",
                        "content": "Someone please help me out : \\nError msg-\\nLine 17: Char 21: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:21\\n\\nI don\\'t get the point, where is the problem in code? [leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "drumsmanku",
                        "content": "Just use set or map"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "What is the need of `pos`, we don't need it anyways. It just makes the example test cases confusing, it can be a part of the explanation in examples but not the input."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used it to make my own test cases. For example, change pos in the 3 example to 0. The answer will be different."
                    },
                    {
                        "username": "ayushisinghania14",
                        "content": "How can we use \"pos\" for verification?  Since its type is showing a built-in function or method we can\\'t even convert it to integer and use to verify. "
                    }
                ]
            },
            {
                "id": 1699046,
                "content": [
                    {
                        "username": "Sanjeev___Thakur",
                        "content": "\\nclass Solution:\\n    def hasCycle(self, head):\\n        if head == None:\\n            return False\\n        slow = head\\n        fast =  head.next\\n        while fast!= None and slow != None:\\n            slow = head.next\\n            fast = head.next.next\\n            return True\\n\\nWith the above code i am able to pass all test cases but i am unable to submit the code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A1Amazon SDE-1 Interview\\uD83D\\uDCA5\\uD83E\\uDD73 #FAANG\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2875561/amazon-sde-1-interview-faang/?orderBy=most_relevant"
                    },
                    {
                        "username": "aanya_969",
                        "content": "What is the need of pos variable??"
                    },
                    {
                        "username": "AlexTyu",
                        "content": "When I use \\n```\\nfast = fast->next->next;\\n slow = slow->next; \\n```\\nMy program gets accepted, but if I use\\n```\\nslow = slow->next;\\nfast = slow->next;\\n```\\nIt says it is too slow. Anyone mind explaining why it is slower?"
                    },
                    {
                        "username": "ashmitarana616",
                        "content": "Here in this question we just need to check whether the given LL is circular or not .\\nSo to check it we just need tho compare the  head and last node if they are connected to eacthother then the Linked List is circular ...\\nif condition  is true returns true  otherwise false !"
                    },
                    {
                        "username": "shyamimmadi7",
                        "content": "what does pos = -1 mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Anees2778",
                        "content": "Someone please help me out : \\nError msg-\\nLine 17: Char 21: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:21\\n\\nI don\\'t get the point, where is the problem in code? [leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "drumsmanku",
                        "content": "Just use set or map"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "What is the need of `pos`, we don't need it anyways. It just makes the example test cases confusing, it can be a part of the explanation in examples but not the input."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used it to make my own test cases. For example, change pos in the 3 example to 0. The answer will be different."
                    },
                    {
                        "username": "ayushisinghania14",
                        "content": "How can we use \"pos\" for verification?  Since its type is showing a built-in function or method we can\\'t even convert it to integer and use to verify. "
                    }
                ]
            },
            {
                "id": 1696768,
                "content": [
                    {
                        "username": "Sanjeev___Thakur",
                        "content": "\\nclass Solution:\\n    def hasCycle(self, head):\\n        if head == None:\\n            return False\\n        slow = head\\n        fast =  head.next\\n        while fast!= None and slow != None:\\n            slow = head.next\\n            fast = head.next.next\\n            return True\\n\\nWith the above code i am able to pass all test cases but i am unable to submit the code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A1Amazon SDE-1 Interview\\uD83D\\uDCA5\\uD83E\\uDD73 #FAANG\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2875561/amazon-sde-1-interview-faang/?orderBy=most_relevant"
                    },
                    {
                        "username": "aanya_969",
                        "content": "What is the need of pos variable??"
                    },
                    {
                        "username": "AlexTyu",
                        "content": "When I use \\n```\\nfast = fast->next->next;\\n slow = slow->next; \\n```\\nMy program gets accepted, but if I use\\n```\\nslow = slow->next;\\nfast = slow->next;\\n```\\nIt says it is too slow. Anyone mind explaining why it is slower?"
                    },
                    {
                        "username": "ashmitarana616",
                        "content": "Here in this question we just need to check whether the given LL is circular or not .\\nSo to check it we just need tho compare the  head and last node if they are connected to eacthother then the Linked List is circular ...\\nif condition  is true returns true  otherwise false !"
                    },
                    {
                        "username": "shyamimmadi7",
                        "content": "what does pos = -1 mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Anees2778",
                        "content": "Someone please help me out : \\nError msg-\\nLine 17: Char 21: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:21\\n\\nI don\\'t get the point, where is the problem in code? [leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "drumsmanku",
                        "content": "Just use set or map"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "What is the need of `pos`, we don't need it anyways. It just makes the example test cases confusing, it can be a part of the explanation in examples but not the input."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used it to make my own test cases. For example, change pos in the 3 example to 0. The answer will be different."
                    },
                    {
                        "username": "ayushisinghania14",
                        "content": "How can we use \"pos\" for verification?  Since its type is showing a built-in function or method we can\\'t even convert it to integer and use to verify. "
                    }
                ]
            },
            {
                "id": 1696741,
                "content": [
                    {
                        "username": "Sanjeev___Thakur",
                        "content": "\\nclass Solution:\\n    def hasCycle(self, head):\\n        if head == None:\\n            return False\\n        slow = head\\n        fast =  head.next\\n        while fast!= None and slow != None:\\n            slow = head.next\\n            fast = head.next.next\\n            return True\\n\\nWith the above code i am able to pass all test cases but i am unable to submit the code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A1Amazon SDE-1 Interview\\uD83D\\uDCA5\\uD83E\\uDD73 #FAANG\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2875561/amazon-sde-1-interview-faang/?orderBy=most_relevant"
                    },
                    {
                        "username": "aanya_969",
                        "content": "What is the need of pos variable??"
                    },
                    {
                        "username": "AlexTyu",
                        "content": "When I use \\n```\\nfast = fast->next->next;\\n slow = slow->next; \\n```\\nMy program gets accepted, but if I use\\n```\\nslow = slow->next;\\nfast = slow->next;\\n```\\nIt says it is too slow. Anyone mind explaining why it is slower?"
                    },
                    {
                        "username": "ashmitarana616",
                        "content": "Here in this question we just need to check whether the given LL is circular or not .\\nSo to check it we just need tho compare the  head and last node if they are connected to eacthother then the Linked List is circular ...\\nif condition  is true returns true  otherwise false !"
                    },
                    {
                        "username": "shyamimmadi7",
                        "content": "what does pos = -1 mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Anees2778",
                        "content": "Someone please help me out : \\nError msg-\\nLine 17: Char 21: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:21\\n\\nI don\\'t get the point, where is the problem in code? [leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "drumsmanku",
                        "content": "Just use set or map"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "What is the need of `pos`, we don't need it anyways. It just makes the example test cases confusing, it can be a part of the explanation in examples but not the input."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used it to make my own test cases. For example, change pos in the 3 example to 0. The answer will be different."
                    },
                    {
                        "username": "ayushisinghania14",
                        "content": "How can we use \"pos\" for verification?  Since its type is showing a built-in function or method we can\\'t even convert it to integer and use to verify. "
                    }
                ]
            },
            {
                "id": 1694937,
                "content": [
                    {
                        "username": "Sanjeev___Thakur",
                        "content": "\\nclass Solution:\\n    def hasCycle(self, head):\\n        if head == None:\\n            return False\\n        slow = head\\n        fast =  head.next\\n        while fast!= None and slow != None:\\n            slow = head.next\\n            fast = head.next.next\\n            return True\\n\\nWith the above code i am able to pass all test cases but i am unable to submit the code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A1Amazon SDE-1 Interview\\uD83D\\uDCA5\\uD83E\\uDD73 #FAANG\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2875561/amazon-sde-1-interview-faang/?orderBy=most_relevant"
                    },
                    {
                        "username": "aanya_969",
                        "content": "What is the need of pos variable??"
                    },
                    {
                        "username": "AlexTyu",
                        "content": "When I use \\n```\\nfast = fast->next->next;\\n slow = slow->next; \\n```\\nMy program gets accepted, but if I use\\n```\\nslow = slow->next;\\nfast = slow->next;\\n```\\nIt says it is too slow. Anyone mind explaining why it is slower?"
                    },
                    {
                        "username": "ashmitarana616",
                        "content": "Here in this question we just need to check whether the given LL is circular or not .\\nSo to check it we just need tho compare the  head and last node if they are connected to eacthother then the Linked List is circular ...\\nif condition  is true returns true  otherwise false !"
                    },
                    {
                        "username": "shyamimmadi7",
                        "content": "what does pos = -1 mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Anees2778",
                        "content": "Someone please help me out : \\nError msg-\\nLine 17: Char 21: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:21\\n\\nI don\\'t get the point, where is the problem in code? [leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "drumsmanku",
                        "content": "Just use set or map"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "What is the need of `pos`, we don't need it anyways. It just makes the example test cases confusing, it can be a part of the explanation in examples but not the input."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used it to make my own test cases. For example, change pos in the 3 example to 0. The answer will be different."
                    },
                    {
                        "username": "ayushisinghania14",
                        "content": "How can we use \"pos\" for verification?  Since its type is showing a built-in function or method we can\\'t even convert it to integer and use to verify. "
                    }
                ]
            },
            {
                "id": 1691797,
                "content": [
                    {
                        "username": "Sanjeev___Thakur",
                        "content": "\\nclass Solution:\\n    def hasCycle(self, head):\\n        if head == None:\\n            return False\\n        slow = head\\n        fast =  head.next\\n        while fast!= None and slow != None:\\n            slow = head.next\\n            fast = head.next.next\\n            return True\\n\\nWith the above code i am able to pass all test cases but i am unable to submit the code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A1Amazon SDE-1 Interview\\uD83D\\uDCA5\\uD83E\\uDD73 #FAANG\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2875561/amazon-sde-1-interview-faang/?orderBy=most_relevant"
                    },
                    {
                        "username": "aanya_969",
                        "content": "What is the need of pos variable??"
                    },
                    {
                        "username": "AlexTyu",
                        "content": "When I use \\n```\\nfast = fast->next->next;\\n slow = slow->next; \\n```\\nMy program gets accepted, but if I use\\n```\\nslow = slow->next;\\nfast = slow->next;\\n```\\nIt says it is too slow. Anyone mind explaining why it is slower?"
                    },
                    {
                        "username": "ashmitarana616",
                        "content": "Here in this question we just need to check whether the given LL is circular or not .\\nSo to check it we just need tho compare the  head and last node if they are connected to eacthother then the Linked List is circular ...\\nif condition  is true returns true  otherwise false !"
                    },
                    {
                        "username": "shyamimmadi7",
                        "content": "what does pos = -1 mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Anees2778",
                        "content": "Someone please help me out : \\nError msg-\\nLine 17: Char 21: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:21\\n\\nI don\\'t get the point, where is the problem in code? [leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "drumsmanku",
                        "content": "Just use set or map"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "What is the need of `pos`, we don't need it anyways. It just makes the example test cases confusing, it can be a part of the explanation in examples but not the input."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used it to make my own test cases. For example, change pos in the 3 example to 0. The answer will be different."
                    },
                    {
                        "username": "ayushisinghania14",
                        "content": "How can we use \"pos\" for verification?  Since its type is showing a built-in function or method we can\\'t even convert it to integer and use to verify. "
                    }
                ]
            },
            {
                "id": 1687386,
                "content": [
                    {
                        "username": "Sanjeev___Thakur",
                        "content": "\\nclass Solution:\\n    def hasCycle(self, head):\\n        if head == None:\\n            return False\\n        slow = head\\n        fast =  head.next\\n        while fast!= None and slow != None:\\n            slow = head.next\\n            fast = head.next.next\\n            return True\\n\\nWith the above code i am able to pass all test cases but i am unable to submit the code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A1Amazon SDE-1 Interview\\uD83D\\uDCA5\\uD83E\\uDD73 #FAANG\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2875561/amazon-sde-1-interview-faang/?orderBy=most_relevant"
                    },
                    {
                        "username": "aanya_969",
                        "content": "What is the need of pos variable??"
                    },
                    {
                        "username": "AlexTyu",
                        "content": "When I use \\n```\\nfast = fast->next->next;\\n slow = slow->next; \\n```\\nMy program gets accepted, but if I use\\n```\\nslow = slow->next;\\nfast = slow->next;\\n```\\nIt says it is too slow. Anyone mind explaining why it is slower?"
                    },
                    {
                        "username": "ashmitarana616",
                        "content": "Here in this question we just need to check whether the given LL is circular or not .\\nSo to check it we just need tho compare the  head and last node if they are connected to eacthother then the Linked List is circular ...\\nif condition  is true returns true  otherwise false !"
                    },
                    {
                        "username": "shyamimmadi7",
                        "content": "what does pos = -1 mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Anees2778",
                        "content": "Someone please help me out : \\nError msg-\\nLine 17: Char 21: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:21\\n\\nI don\\'t get the point, where is the problem in code? [leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "drumsmanku",
                        "content": "Just use set or map"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "What is the need of `pos`, we don't need it anyways. It just makes the example test cases confusing, it can be a part of the explanation in examples but not the input."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used it to make my own test cases. For example, change pos in the 3 example to 0. The answer will be different."
                    },
                    {
                        "username": "ayushisinghania14",
                        "content": "How can we use \"pos\" for verification?  Since its type is showing a built-in function or method we can\\'t even convert it to integer and use to verify. "
                    }
                ]
            },
            {
                "id": 1668469,
                "content": [
                    {
                        "username": "Sanjeev___Thakur",
                        "content": "\\nclass Solution:\\n    def hasCycle(self, head):\\n        if head == None:\\n            return False\\n        slow = head\\n        fast =  head.next\\n        while fast!= None and slow != None:\\n            slow = head.next\\n            fast = head.next.next\\n            return True\\n\\nWith the above code i am able to pass all test cases but i am unable to submit the code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A1Amazon SDE-1 Interview\\uD83D\\uDCA5\\uD83E\\uDD73 #FAANG\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2875561/amazon-sde-1-interview-faang/?orderBy=most_relevant"
                    },
                    {
                        "username": "aanya_969",
                        "content": "What is the need of pos variable??"
                    },
                    {
                        "username": "AlexTyu",
                        "content": "When I use \\n```\\nfast = fast->next->next;\\n slow = slow->next; \\n```\\nMy program gets accepted, but if I use\\n```\\nslow = slow->next;\\nfast = slow->next;\\n```\\nIt says it is too slow. Anyone mind explaining why it is slower?"
                    },
                    {
                        "username": "ashmitarana616",
                        "content": "Here in this question we just need to check whether the given LL is circular or not .\\nSo to check it we just need tho compare the  head and last node if they are connected to eacthother then the Linked List is circular ...\\nif condition  is true returns true  otherwise false !"
                    },
                    {
                        "username": "shyamimmadi7",
                        "content": "what does pos = -1 mean?.. tail it pointing to null?"
                    },
                    {
                        "username": "Anees2778",
                        "content": "Someone please help me out : \\nError msg-\\nLine 17: Char 21: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:21\\n\\nI don\\'t get the point, where is the problem in code? [leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "drumsmanku",
                        "content": "Just use set or map"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "What is the need of `pos`, we don't need it anyways. It just makes the example test cases confusing, it can be a part of the explanation in examples but not the input."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used it to make my own test cases. For example, change pos in the 3 example to 0. The answer will be different."
                    },
                    {
                        "username": "ayushisinghania14",
                        "content": "How can we use \"pos\" for verification?  Since its type is showing a built-in function or method we can\\'t even convert it to integer and use to verify. "
                    }
                ]
            }
        ]
    }
]