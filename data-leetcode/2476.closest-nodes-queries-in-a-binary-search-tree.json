[
    {
        "title": "Closest Nodes Queries in a Binary Search Tree",
        "question_content": "You are given the root of a binary search tree and an array queries of size n consisting of positive integers.\nFind a 2D array answer of size n where answer[i] = [mini, maxi]:\n\n\tmini is the largest value in the tree that is smaller than or equal to queries[i]. If a such value does not exist, add -1 instead.\n\tmaxi is the smallest value in the tree that is greater than or equal to queries[i]. If a such value does not exist, add -1 instead.\n\nReturn the array answer.\n&nbsp;\nExample 1:\n\nInput: root = [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries = [2,5,16]\nOutput: [[2,2],[4,6],[15,-1]]\nExplanation: We answer the queries in the following way:\n- The largest number that is smaller or equal than 2 in the tree is 2, and the smallest number that is greater or equal than 2 is still 2. So the answer for the first query is [2,2].\n- The largest number that is smaller or equal than 5 in the tree is 4, and the smallest number that is greater or equal than 5 is 6. So the answer for the second query is [4,6].\n- The largest number that is smaller or equal than 16 in the tree is 15, and the smallest number that is greater or equal than 16 does not exist. So the answer for the third query is [15,-1].\n\nExample 2:\n\nInput: root = [4,null,9], queries = [3]\nOutput: [[-1,4]]\nExplanation: The largest number that is smaller or equal to 3 in the tree does not exist, and the smallest number that is greater or equal to 3 is 4. So the answer for the query is [-1,4].\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [2, 105].\n\t1 <= Node.val <= 106\n\tn == queries.length\n\t1 <= n <= 105\n\t1 <= queries[i] <= 106",
        "solutions": [
            {
                "id": 2831692,
                "title": "is-the-tree-balanced",
                "content": "Since we do not know the answer, it\\'s better to collect all values into an array, and then binary-search in that array.\\n\\nA search in a tree takes O(h), which is O(log n) for a balanced, and O(n) for an unbalanced tree.\\n\\n**C++**\\n```cpp\\nvector<int> v;\\nvoid traverse(TreeNode* n) {\\n    if (n != nullptr) {\\n        traverse(n->left);\\n        if (v.empty() || v.back() < n->val)\\n            v.push_back(n->val);\\n        traverse(n->right);\\n    }\\n}\\nvector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n    vector<vector<int>> res;\\n    traverse(root);\\n    for (int q : queries) {\\n        auto it = lower_bound(begin(v), end(v), q);\\n        if (it != end(v) && *it == q)\\n            res.push_back({q, q});\\n        else\\n            res.push_back({it == begin(v) ? -1 : *prev(it), it == end(v) ? -1 : *it});\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<int> v;\\nvoid traverse(TreeNode* n) {\\n    if (n != nullptr) {\\n        traverse(n->left);\\n        if (v.empty() || v.back() < n->val)\\n            v.push_back(n->val);\\n        traverse(n->right);\\n    }\\n}\\nvector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n    vector<vector<int>> res;\\n    traverse(root);\\n    for (int q : queries) {\\n        auto it = lower_bound(begin(v), end(v), q);\\n        if (it != end(v) && *it == q)\\n            res.push_back({q, q});\\n        else\\n            res.push_back({it == begin(v) ? -1 : *prev(it), it == end(v) ? -1 : *it});\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2832814,
                "title": "python-c-inorder-traversal-then-binary-search-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs the main property of a *Binary Search Tree* in order to collect a sorted array of values, then apply binary search. Time complexity is linear: **O(N\\\\*logK)**. Space complexity is linear: **O(N+K)**. Here, `K` is the number of nodes in the tree, `N` is the number of queries.\\n****\\n\\n**Comment.** *Binary Search Tree* is a type of binary tree that allows to collect a list of sorted values using the *Inorder Traversal* approach (see [**94. Binary Tree Inorder Traversal**](https://leetcode.com/problems/binary-tree-inorder-traversal/)). Once collected, these values can be efficiently queried using binary search.\\n\\n**Python.**\\n```\\nclass Solution:\\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        \\n        def dfs(n, v):                                                 # a recursive function for the\\n            if n: dfs(n.left, v), v.append(n.val), dfs(n.right, v)     # inorder traversal of BST\\n        \\n        nums = []                                                      # [1] collect values from BST  \\n        dfs(root, nums)                                                #     in sorted order\\n        \\n        results, n = [], len(nums)\\n        \\n        for q in queries:                                              # [2] make queries using the binary\\n            i = bisect_left(nums, q)                                   #     search, then consider several\\n            if i < n and nums[i] == q : results.append([q,q])          #     conditions on the returned \\n            else:                                                      #     insertion position\\n                if   i == 0 : results.append([-1,nums[0]])\\n                elif i == n : results.append([nums[-1],-1])\\n                else        : results.append([nums[i-1], nums[i]])\\n                    \\n        return results\\n```\\n\\n**C++.**\\n```\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) \\n    {\\n        function<void(TreeNode*, vector<int>&)> dfs;\\n        dfs = [&](TreeNode* n, vector<int>& v)\\n        {\\n            if (n) dfs(n->left, v), v.push_back(n->val), dfs(n->right, v);\\n        };\\n        \\n        vector<int> nums;\\n        dfs(root, nums);\\n        \\n        vector<vector<int>> results;\\n        int n = nums.size();\\n        \\n        for (int q : queries)\\n        {\\n            int i = lower_bound(nums.begin(), nums.end(), q) - nums.begin();\\n            if (i < n && nums[i] == q) results.push_back({q,q});\\n            else\\n                if      (i == 0) results.push_back({-1, nums[0]});\\n                else if (i == n) results.push_back({nums[n-1], -1});\\n                else             results.push_back({nums[i-1], nums[i]});\\n        }\\n        \\n        return results;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        \\n        def dfs(n, v):                                                 # a recursive function for the\\n            if n: dfs(n.left, v), v.append(n.val), dfs(n.right, v)     # inorder traversal of BST\\n        \\n        nums = []                                                      # [1] collect values from BST  \\n        dfs(root, nums)                                                #     in sorted order\\n        \\n        results, n = [], len(nums)\\n        \\n        for q in queries:                                              # [2] make queries using the binary\\n            i = bisect_left(nums, q)                                   #     search, then consider several\\n            if i < n and nums[i] == q : results.append([q,q])          #     conditions on the returned \\n            else:                                                      #     insertion position\\n                if   i == 0 : results.append([-1,nums[0]])\\n                elif i == n : results.append([nums[-1],-1])\\n                else        : results.append([nums[i-1], nums[i]])\\n                    \\n        return results\\n```\n```\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) \\n    {\\n        function<void(TreeNode*, vector<int>&)> dfs;\\n        dfs = [&](TreeNode* n, vector<int>& v)\\n        {\\n            if (n) dfs(n->left, v), v.push_back(n->val), dfs(n->right, v);\\n        };\\n        \\n        vector<int> nums;\\n        dfs(root, nums);\\n        \\n        vector<vector<int>> results;\\n        int n = nums.size();\\n        \\n        for (int q : queries)\\n        {\\n            int i = lower_bound(nums.begin(), nums.end(), q) - nums.begin();\\n            if (i < n && nums[i] == q) results.push_back({q,q});\\n            else\\n                if      (i == 0) results.push_back({-1, nums[0]});\\n                else if (i == n) results.push_back({nums[n-1], -1});\\n                else             results.push_back({nums[i-1], nums[i]});\\n        }\\n        \\n        return results;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831668,
                "title": "c-solution-in-order-traversal-lower-bound-upper-bound-very-simple",
                "content": "<b>Up Vote if you like the solution\\n```\\n/*\\nApproach is to get the sorted list by traversing each node using inorder-traversal.\\nThen take lower bound and upper bound of each querries to get min and max.\\n\\nNote: \\nThere are few conditions that need to be taken care while taking lower and upper bound:\\n1. when the lower bound index is more than array size -> just take the index of last element\\n2. when lower bound value is not present in the array -> take just previous value.\\n3. when upper bound value is evaluated and may be previous value is equal with query -> check and if require take previous index value.\\n \\n */\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int>& nums){\\n        if(root){\\n            inorder(root->left, nums);\\n            nums.push_back(root->val);\\n            inorder(root->right, nums);\\n        }\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<vector<int>> ans;\\n        vector<int> nums;\\n        inorder(root, nums);\\n        \\n        for(auto q: queries){\\n            int mn = -1, mx = -1;\\n            if( nums[0] <= q ) mn = (lower_bound(nums.begin(), nums.end(), q)) - nums.begin();\\n            if( q <= nums.back() ) mx = (upper_bound(nums.begin(), nums.end(), q))-nums.begin();\\n            \\n            if(mn > 0 && mn >= nums.size()) mn--;   //when q is larger than nums.back()\\n            if(mn >= 0 && nums[mn] > q) mn--;         //when q is not present in the nums array\\n            if(mx > 0 && nums[mx - 1] == q) mx--;    //when q is present in nums, upper bound refer to next element\\n            \\n            if(mn != -1) mn = nums[mn];      //get value at index mn\\n            if(mx != -1) mx = nums[mx];      //get value at index mx\\n            ans.push_back({mn, mx});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nApproach is to get the sorted list by traversing each node using inorder-traversal.\\nThen take lower bound and upper bound of each querries to get min and max.\\n\\nNote: \\nThere are few conditions that need to be taken care while taking lower and upper bound:\\n1. when the lower bound index is more than array size -> just take the index of last element\\n2. when lower bound value is not present in the array -> take just previous value.\\n3. when upper bound value is evaluated and may be previous value is equal with query -> check and if require take previous index value.\\n \\n */\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int>& nums){\\n        if(root){\\n            inorder(root->left, nums);\\n            nums.push_back(root->val);\\n            inorder(root->right, nums);\\n        }\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<vector<int>> ans;\\n        vector<int> nums;\\n        inorder(root, nums);\\n        \\n        for(auto q: queries){\\n            int mn = -1, mx = -1;\\n            if( nums[0] <= q ) mn = (lower_bound(nums.begin(), nums.end(), q)) - nums.begin();\\n            if( q <= nums.back() ) mx = (upper_bound(nums.begin(), nums.end(), q))-nums.begin();\\n            \\n            if(mn > 0 && mn >= nums.size()) mn--;   //when q is larger than nums.back()\\n            if(mn >= 0 && nums[mn] > q) mn--;         //when q is not present in the nums array\\n            if(mx > 0 && nums[mx - 1] == q) mx--;    //when q is present in nums, upper bound refer to next element\\n            \\n            if(mn != -1) mn = nums[mn];      //get value at index mn\\n            if(mx != -1) mx = nums[mx];      //get value at index mx\\n            ans.push_back({mn, mx});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832051,
                "title": "using-binary-search-and-inorder-traversal",
                "content": "#####  Finding all values in a tree by inorder traversal as we know inorder traversal of BST gives result in sorted order then performing BS to get lower and upper bound \\n```\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<Integer> l1=new ArrayList<>();\\n        List<List<Integer>> b=new ArrayList<>();\\n        inorder(root,l1);\\n      //  System.out.println(l1);\\n        for(int x:queries){\\n            List<Integer> l2=new ArrayList<>();\\n            int t1=lb(l1,x);\\n            int t2=ub(l1,x);\\n            // if index==list size then storing -1\\n            if(t2==l1.size()){\\n                l2.add(-1);\\n            }\\n            else{\\n                l2.add(l1.get(t2));\\n            }\\n            // if index==list size then storing -1\\n            if(t1==l1.size()){\\n                l2.add(-1);\\n            }\\n            else{\\n                l2.add(l1.get(t1));\\n            }\\n            b.add(l2);\\n        }\\n        return b;\\n    }\\n    //storing in sorted order of the tree values\\n    public void inorder(TreeNode root,List<Integer> l1){\\n        if(root==null){\\n            return;\\n        }\\n        inorder(root.left,l1);\\n        l1.add(root.val);\\n        inorder(root.right,l1);\\n    }\\n    //finding lower bound\\n    public int lb(List<Integer> l,int x){\\n        int i=0;\\n        int j=l.size()-1;\\n        int ans=l.size();\\n        while(i<=j){\\n            int mid=(i+j)/2;\\n            if(l.get(mid)>=x){\\n                ans=mid;\\n                j=mid-1;\\n            }\\n            else{\\n                i=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    //finding upper bound\\n    public int ub(List<Integer> l,int x){\\n        int i=0;\\n        int j=l.size()-1;\\n        int ans=l.size();\\n        while(i<=j){\\n            int mid=(i+j)/2;\\n            if(l.get(mid)<=x){\\n                i=mid+1;\\n                ans=mid;\\n            }\\n            else{\\n                \\n                j=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t}\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<Integer> l1=new ArrayList<>();\\n        List<List<Integer>> b=new ArrayList<>();\\n        inorder(root,l1);\\n      //  System.out.println(l1);\\n        for(int x:queries){\\n            List<Integer> l2=new ArrayList<>();\\n            int t1=lb(l1,x);\\n            int t2=ub(l1,x);\\n            // if index==list size then storing -1\\n            if(t2==l1.size()){\\n                l2.add(-1);\\n            }\\n            else{\\n                l2.add(l1.get(t2));\\n            }\\n            // if index==list size then storing -1\\n            if(t1==l1.size()){\\n                l2.add(-1);\\n            }\\n            else{\\n                l2.add(l1.get(t1));\\n            }\\n            b.add(l2);\\n        }\\n        return b;\\n    }\\n    //storing in sorted order of the tree values\\n    public void inorder(TreeNode root,List<Integer> l1){\\n        if(root==null){\\n            return;\\n        }\\n        inorder(root.left,l1);\\n        l1.add(root.val);\\n        inorder(root.right,l1);\\n    }\\n    //finding lower bound\\n    public int lb(List<Integer> l,int x){\\n        int i=0;\\n        int j=l.size()-1;\\n        int ans=l.size();\\n        while(i<=j){\\n            int mid=(i+j)/2;\\n            if(l.get(mid)>=x){\\n                ans=mid;\\n                j=mid-1;\\n            }\\n            else{\\n                i=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    //finding upper bound\\n    public int ub(List<Integer> l,int x){\\n        int i=0;\\n        int j=l.size()-1;\\n        int ans=l.size();\\n        while(i<=j){\\n            int mid=(i+j)/2;\\n            if(l.get(mid)<=x){\\n                i=mid+1;\\n                ans=mid;\\n            }\\n            else{\\n                \\n                j=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831836,
                "title": "bst-search-variation-o-1-space-array-approach-o-nlogn-for-sure",
                "content": "```c++ \\n// Please upvote uf you like the solution \\n```\\n<hr>\\n\\n#### idea:- \\n\\nWe will use the normal search function of binary search tree . But we will have to make slight modifications. Instead of strictly finding the key in the tree , we will also make sure what is the most maximum element less than key that we have seen in the process of finding the key and also the most minimum element greater than key. \\n\\n<hr>\\n\\n#### why will this work ?\\n\\nThis works because that is how binary search tree structure is at a node all the nodes lesser than that are on left indicating that node itself is the largest possible bound you can get wrto elements on left. \\n\\nSimilarly this idea will work on this right side to it will be a right side to get the upper bound\\n\\n#### problem :- \\n\\nNow a binary search tree is not always gauranteed to be height balanced let us say a bst with all values to left \\n\\n\\t\\t\\t\\t10\\n\\t\\t\\t/\\n\\t\\t9\\n\\t/\\t\\n\\nand so on. \\n\\nSo in these cases the answer can become O(n2) \\n\\n#### Solution to problem:- \\n\\nConvert the tree to array and on that tree apply same lower bound and upper bound approaches\\n\\n<h2>\\n\\n#### Code:- \\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> search(TreeNode *root , int q){\\n        TreeNode* p = root;\\n        int lb = INT_MIN ;\\n        int ub =  INT_MAX;\\n        while(p){\\n            if(p->val > q){\\n\\t\\t\\t\\t// update ub since it can be minimum value greater than the key\\n                ub = min(ub , p->val);\\n                p =p->left;\\n            }else if(p->val < q){\\n\\t\\t\\t\\t// update ub since it can be minimum value greater than the key\\n                lb = max(lb , p->val);\\n                p=p->right;   \\n\\t\\t\\t//if found immediately return \\n            }else{\\n                return {p->val , p->val};\\n            }\\n        }\\n        // check if we could not find the bounds\\n        if(lb == INT_MIN) lb = -1;\\n        if(ub == INT_MAX) ub = -1;\\n        return {lb , ub};\\n    }\\n    \\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<vector<int>> x(queries.size());\\n        int i = 0;\\n        for(int q : queries){\\n            x[i++] = search(root , q);\\n        }\\n        return x;\\n    }\\n};\\n```\\n\\n<hr>\\n\\n```\\n//Time Complexity : O(nlogn) normally O(n2) worst case  \\n//space complexity : O(1)\\n\\n```\\n\\n<hr>\\n\\n#### Array Approach \\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void inorder(TreeNode* root){\\n        if(root){\\n            inorder(root->left);\\n            ans.push_back(root->val);\\n            inorder(root->right);\\n        }\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        inorder(root);\\n        int n = ans.size();\\n        vector<vector<int>> v;\\n        for(int q : queries){\\n            int l = 0 , h = n-1;\\n            int lb = INT_MIN , rb = INT_MAX;\\n            while(l <= h){\\n                int mid = (l + h) /2;\\n                if(ans[mid] == q){\\n                    lb = q , rb = q;\\n                    break;\\n                }else if(ans[mid] < q){\\n                    lb = max(lb , ans[mid]);\\n                    l = mid + 1;\\n                }else{\\n                    rb = min(rb , ans[mid]);\\n                    h = mid - 1;\\n                }\\n            }\\n            if(lb == INT_MIN) lb = -1;\\n            if(rb == INT_MAX) rb = - 1;\\n            v.push_back({lb , rb});\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\n`Time Complexity :- O(nlogn)  || space O(n)`",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```c++ \\n// Please upvote uf you like the solution \\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> search(TreeNode *root , int q){\\n        TreeNode* p = root;\\n        int lb = INT_MIN ;\\n        int ub =  INT_MAX;\\n        while(p){\\n            if(p->val > q){\\n\\t\\t\\t\\t// update ub since it can be minimum value greater than the key\\n                ub = min(ub , p->val);\\n                p =p->left;\\n            }else if(p->val < q){\\n\\t\\t\\t\\t// update ub since it can be minimum value greater than the key\\n                lb = max(lb , p->val);\\n                p=p->right;   \\n\\t\\t\\t//if found immediately return \\n            }else{\\n                return {p->val , p->val};\\n            }\\n        }\\n        // check if we could not find the bounds\\n        if(lb == INT_MIN) lb = -1;\\n        if(ub == INT_MAX) ub = -1;\\n        return {lb , ub};\\n    }\\n    \\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<vector<int>> x(queries.size());\\n        int i = 0;\\n        for(int q : queries){\\n            x[i++] = search(root , q);\\n        }\\n        return x;\\n    }\\n};\\n```\n```\\n//Time Complexity : O(nlogn) normally O(n2) worst case  \\n//space complexity : O(1)\\n\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void inorder(TreeNode* root){\\n        if(root){\\n            inorder(root->left);\\n            ans.push_back(root->val);\\n            inorder(root->right);\\n        }\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        inorder(root);\\n        int n = ans.size();\\n        vector<vector<int>> v;\\n        for(int q : queries){\\n            int l = 0 , h = n-1;\\n            int lb = INT_MIN , rb = INT_MAX;\\n            while(l <= h){\\n                int mid = (l + h) /2;\\n                if(ans[mid] == q){\\n                    lb = q , rb = q;\\n                    break;\\n                }else if(ans[mid] < q){\\n                    lb = max(lb , ans[mid]);\\n                    l = mid + 1;\\n                }else{\\n                    rb = min(rb , ans[mid]);\\n                    h = mid - 1;\\n                }\\n            }\\n            if(lb == INT_MIN) lb = -1;\\n            if(rb == INT_MAX) rb = - 1;\\n            v.push_back({lb , rb});\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831661,
                "title": "treemap-binary-search",
                "content": "\\n```\\nclass Solution {\\n    TreeMap<Integer, Integer> map = new TreeMap<>();\\n\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        helper(root);\\n        for (int num : queries) {\\n\\t\\t//if num is present add num else add lower value than num\\n            Integer low = map.containsKey(num) ? Integer.valueOf(num) : map.lowerKey(num);\\n\\t\\t//if num is present add num else add higher value than num\\n            Integer high = map.containsKey(num) ? Integer.valueOf(num) : map.higherKey(num);\\n\\t\\t//if low or high value also not present add -1 else add low or high\\n            ans.add(Arrays.asList(low == null ? -1 : low, high == null ? -1 : high));\\n        }\\n        return ans;\\n    }\\n\\n    void helper(TreeNode root) {\\n        if (root == null) return;\\n        map.put(root.val, 0);\\n        helper(root.left);\\n        helper(root.right);\\n    }\\n//The `higherKey()`method class is used to return the least key strictly greater than the given key, or null if there is no such key.\\n//AND\\n//The `lowerKey()` method is used to return the greatest key strictly less than to given key, \\n}\\n```\\n\\n**Using TreeSet :**\\n\\n```\\nInteger low = map.floorKey(num); // returns key <= specified key\\nInteger high = map.ceilingKey(num); // returns key >= specified key\\n```\\n\\n```\\nclass Solution {\\n    TreeMap<Integer, Integer> map = new TreeMap<>();\\n\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        helper(root);\\n        for (int num : queries) {\\n            Integer low = map.floorKey(num);\\n            Integer high = map.ceilingKey(num);\\n            ans.add(List.of(low == null ? -1 : low, high == null ? -1 : high));\\n        }\\n        return ans;\\n    }\\n\\n    void helper(TreeNode root) {\\n        if (root == null) return;\\n\\n        map.put(root.val, 0);\\n        helper(root.left);\\n        helper(root.right);\\n    }\\n}\\n```\\n\\n***Using TreeSet :***\\n\\n\\n```\\npublic List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n       var set = new TreeSet<Integer>();\\n       dfs(root, set);\\n       var result = new ArrayList<List<Integer>>();\\n    \\n       for (var query : queries) {\\n           var min = set.lower(query + 1);\\n           var max = set.higher(query - 1);\\n           if (min == null) {\\n               min = -1;\\n           }\\n           if (max == null) {\\n               max = -1;\\n           }\\n           result.add(List.of(min, max));\\n       }\\n       return result;\\n   }\\n\\n   private void dfs(TreeNode root, TreeSet<Integer> set) {\\n       if (root == null) return;\\n       dfs(root.left, set);\\n       set.add(root.val);\\n       dfs(root.right, set);\\n   }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    TreeMap<Integer, Integer> map = new TreeMap<>();\\n\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        helper(root);\\n        for (int num : queries) {\\n\\t\\t//if num is present add num else add lower value than num\\n            Integer low = map.containsKey(num) ? Integer.valueOf(num) : map.lowerKey(num);\\n\\t\\t//if num is present add num else add higher value than num\\n            Integer high = map.containsKey(num) ? Integer.valueOf(num) : map.higherKey(num);\\n\\t\\t//if low or high value also not present add -1 else add low or high\\n            ans.add(Arrays.asList(low == null ? -1 : low, high == null ? -1 : high));\\n        }\\n        return ans;\\n    }\\n\\n    void helper(TreeNode root) {\\n        if (root == null) return;\\n        map.put(root.val, 0);\\n        helper(root.left);\\n        helper(root.right);\\n    }\\n//The `higherKey()`method class is used to return the least key strictly greater than the given key, or null if there is no such key.\\n//AND\\n//The `lowerKey()` method is used to return the greatest key strictly less than to given key, \\n}\\n```\n```\\nInteger low = map.floorKey(num); // returns key <= specified key\\nInteger high = map.ceilingKey(num); // returns key >= specified key\\n```\n```\\nclass Solution {\\n    TreeMap<Integer, Integer> map = new TreeMap<>();\\n\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        helper(root);\\n        for (int num : queries) {\\n            Integer low = map.floorKey(num);\\n            Integer high = map.ceilingKey(num);\\n            ans.add(List.of(low == null ? -1 : low, high == null ? -1 : high));\\n        }\\n        return ans;\\n    }\\n\\n    void helper(TreeNode root) {\\n        if (root == null) return;\\n\\n        map.put(root.val, 0);\\n        helper(root.left);\\n        helper(root.right);\\n    }\\n}\\n```\n```\\npublic List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n       var set = new TreeSet<Integer>();\\n       dfs(root, set);\\n       var result = new ArrayList<List<Integer>>();\\n    \\n       for (var query : queries) {\\n           var min = set.lower(query + 1);\\n           var max = set.higher(query - 1);\\n           if (min == null) {\\n               min = -1;\\n           }\\n           if (max == null) {\\n               max = -1;\\n           }\\n           result.add(List.of(min, max));\\n       }\\n       return result;\\n   }\\n\\n   private void dfs(TreeNode root, TreeSet<Integer> set) {\\n       if (root == null) return;\\n       dfs(root.left, set);\\n       set.add(root.val);\\n       dfs(root.right, set);\\n   }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831726,
                "title": "binary-search-approach-python",
                "content": "```\\nclass Solution(object):\\n    def closestNodes(self, root, queries):\\n        def dfs(root, arr):\\n            if not root: return\\n            dfs(root.left, arr)\\n            arr.append(root.val)\\n            dfs(root.right, arr)\\n        arr = []\\n        dfs(root, arr)\\n        ans = []\\n        n = len(arr)\\n        for key in queries:\\n            left, right = 0, n - 1\\n            while right >= left:\\n                mid = (right + left) // 2\\n                if arr[mid] == key:\\n                    break\\n                elif arr[mid] > key:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n            if arr[mid] == key:\\n                ans.append([arr[mid], arr[mid]])\\n            elif arr[mid] > key:\\n                if (mid - 1) >= 0:\\n                    ans.append([arr[mid - 1], arr[mid]])\\n                else:\\n                    ans.append([-1, arr[mid]])\\n            else:\\n                if (mid + 1) < n:\\n                    ans.append([arr[mid], arr[mid + 1]])\\n                else:\\n                    ans.append([arr[mid], -1])\\n        return ans\\n```\\n**UpVote**, if you like it **:)**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def closestNodes(self, root, queries):\\n        def dfs(root, arr):\\n            if not root: return\\n            dfs(root.left, arr)\\n            arr.append(root.val)\\n            dfs(root.right, arr)\\n        arr = []\\n        dfs(root, arr)\\n        ans = []\\n        n = len(arr)\\n        for key in queries:\\n            left, right = 0, n - 1\\n            while right >= left:\\n                mid = (right + left) // 2\\n                if arr[mid] == key:\\n                    break\\n                elif arr[mid] > key:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n            if arr[mid] == key:\\n                ans.append([arr[mid], arr[mid]])\\n            elif arr[mid] > key:\\n                if (mid - 1) >= 0:\\n                    ans.append([arr[mid - 1], arr[mid]])\\n                else:\\n                    ans.append([-1, arr[mid]])\\n            else:\\n                if (mid + 1) < n:\\n                    ans.append([arr[mid], arr[mid + 1]])\\n                else:\\n                    ans.append([arr[mid], -1])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832286,
                "title": "java-with-easy-treeset-10-lines-of-code",
                "content": "\\n```\\n// step1 :-  Just the fill the element in treeset using recursion\\n// step2 :- then make new List<List<Integer>> for ans\\n// step3 :- use the inbuilt method of treeset ( treeset.floor(num) and treeSet.ceiling(num) ) to get\\n// the floor value andceil value of num\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        fill(set,root);\\n        \\n        List<List<Integer>> list = new ArrayList<>();\\n        \\n        for(int val : queries){\\n            ArrayList<Integer> al = new ArrayList<>();\\n            \\n            al.add(set.floor(val)==null?-1:set.floor(val));\\n            al.add(set.ceiling(val)==null?-1:set.ceiling(val));\\n            \\n            list.add(al);\\n        }\\n        \\n        return list;\\n    }\\n    \\n    public void fill(TreeSet<Integer> set,TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        \\n        set.add(root.val);\\n        \\n        fill(set,root.left);\\n        fill(set,root.right);\\n    }\\n}\\n\\n// please upvote if this solution helps you, for better reach\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```\\n// step1 :-  Just the fill the element in treeset using recursion\\n// step2 :- then make new List<List<Integer>> for ans\\n// step3 :- use the inbuilt method of treeset ( treeset.floor(num) and treeSet.ceiling(num) ) to get\\n// the floor value andceil value of num\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        fill(set,root);\\n        \\n        List<List<Integer>> list = new ArrayList<>();\\n        \\n        for(int val : queries){\\n            ArrayList<Integer> al = new ArrayList<>();\\n            \\n            al.add(set.floor(val)==null?-1:set.floor(val));\\n            al.add(set.ceiling(val)==null?-1:set.ceiling(val));\\n            \\n            list.add(al);\\n        }\\n        \\n        return list;\\n    }\\n    \\n    public void fill(TreeSet<Integer> set,TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        \\n        set.add(root.val);\\n        \\n        fill(set,root.left);\\n        fill(set,root.right);\\n    }\\n}\\n\\n// please upvote if this solution helps you, for better reach\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831680,
                "title": "line-by-line-commented-100-faster-solution",
                "content": "### Approach 1 : Using TreeSet\\n\\n**1. Traverse the whole tree and store nodes in a TreeSet\\n2. Return ceiling as max and floor as min for a particular query.**\\n\\n```java\\nclass Solution {\\n    TreeSet<Integer> set = new TreeSet<Integer>();         // stores all nodes\\n\\t\\n    void traverse(TreeNode root) {                         // simple in-order traversal\\n        if (root == null) return;\\n        \\n        traverse(root.left);\\n        set.add(root.val);\\n        traverse(root.right);\\n    }\\n    \\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        traverse(root);                                         // traverse the whole tree\\n        \\n        List<List<Integer>> ans = new ArrayList<>();\\n        for (int q : queries) {\\n            List<Integer> list = new ArrayList<>();\\n            \\n            Integer min = set.floor(q);                         // greatest value less than or equal to q\\n            if (min != null) list.add(min);                     // add it to list\\n            else list.add(-1);                                  // if no such values exist, add -1\\n            \\n            Integer max = set.ceiling(q);                       // smallest value greaater than or equal to q\\n            if (max != null) list.add(max);                     // add it to list\\n            else list.add(-1);                                  // if no such values exist, add -1\\n            \\n            ans.add(list);\\n        }\\n        \\n        return ans;\\n    } \\n}\\n```\\n\\n### Approach 2 : Using Binary Search (faster than 100%)\\n**1. Traverse the whole tree and store nodes in an ArrayList\\n2. Now you can do binary search to find ceil and floor values\\nNote: The arraylist is already sorted, because we are doing in-order traversal of a binary search tree**\\n```java\\nclass Solution {\\n    List<Integer> nodes = new ArrayList<>(); \\n    void traverse(TreeNode root) {\\n        if (root == null) return;\\n        \\n        traverse(root.left);\\n        nodes.add(root.val);\\n        traverse(root.right);\\n    }\\n    \\n    List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        traverse(root);                         // traverse all nodes and store them in ArrayList\\n        \\n        List<List<Integer>> ans = new ArrayList<>();\\n        int n = nodes.size();\\n        \\n        for (int q : queries) {            \\n            if (q == nodes.get(0) || q == nodes.get(n-1)) {           // if value is already found, no need to do BS\\n            \\tans.add(Arrays.asList(q, q));\\n            }\\n            else if (q < nodes.get(0)) {\\n            \\tans.add(Arrays.asList(-1, nodes.get(0)));             // if value == first element, no need to do BS\\n            }\\n            else if (q > nodes.get(n-1)) {\\n            \\tans.add(Arrays.asList(nodes.get(n-1), -1));          // if value == last element, no need to do BS\\n            }\\n            else {\\n            \\tint lo = 0;\\n            \\tint hi = n-1;\\n            \\tboolean found = false;\\n            \\twhile (lo < hi) {\\n            \\t\\tint m = (lo+hi) >> 1;\\n            \\t\\tint mid = nodes.get(m);\\n            \\t\\tif (q == mid) {\\n            \\t\\t\\tfound = true;\\n            \\t\\t\\tans.add(Arrays.asList(q, q));\\n            \\t\\t\\tbreak;\\n            \\t\\t}\\n            \\t\\telse if (q > mid) {\\n            \\t\\t\\tlo = m + 1;\\n            \\t\\t}\\n            \\t\\telse {\\n            \\t\\t\\thi = m;\\n            \\t\\t}\\n            \\t}\\n            \\t\\n\\t\\t\\t\\t// now lo and hi are equal\\n            \\tif (!found) {\\n            \\t\\tans.add(Arrays.asList(nodes.get(lo-1), nodes.get(lo)));\\n            \\t}\\n            }\\n        }\\n        \\n        return ans;\\n    } \\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/1fb20aed-e9ca-4675-b02f-050166a14235_1668946473.089459.png)\\n\\n\\n**Time complexity : O(NlogN)\\nSpace complexity : O(N)**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    TreeSet<Integer> set = new TreeSet<Integer>();         // stores all nodes\\n\\t\\n    void traverse(TreeNode root) {                         // simple in-order traversal\\n        if (root == null) return;\\n        \\n        traverse(root.left);\\n        set.add(root.val);\\n        traverse(root.right);\\n    }\\n    \\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        traverse(root);                                         // traverse the whole tree\\n        \\n        List<List<Integer>> ans = new ArrayList<>();\\n        for (int q : queries) {\\n            List<Integer> list = new ArrayList<>();\\n            \\n            Integer min = set.floor(q);                         // greatest value less than or equal to q\\n            if (min != null) list.add(min);                     // add it to list\\n            else list.add(-1);                                  // if no such values exist, add -1\\n            \\n            Integer max = set.ceiling(q);                       // smallest value greaater than or equal to q\\n            if (max != null) list.add(max);                     // add it to list\\n            else list.add(-1);                                  // if no such values exist, add -1\\n            \\n            ans.add(list);\\n        }\\n        \\n        return ans;\\n    } \\n}\\n```\n```java\\nclass Solution {\\n    List<Integer> nodes = new ArrayList<>(); \\n    void traverse(TreeNode root) {\\n        if (root == null) return;\\n        \\n        traverse(root.left);\\n        nodes.add(root.val);\\n        traverse(root.right);\\n    }\\n    \\n    List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        traverse(root);                         // traverse all nodes and store them in ArrayList\\n        \\n        List<List<Integer>> ans = new ArrayList<>();\\n        int n = nodes.size();\\n        \\n        for (int q : queries) {            \\n            if (q == nodes.get(0) || q == nodes.get(n-1)) {           // if value is already found, no need to do BS\\n            \\tans.add(Arrays.asList(q, q));\\n            }\\n            else if (q < nodes.get(0)) {\\n            \\tans.add(Arrays.asList(-1, nodes.get(0)));             // if value == first element, no need to do BS\\n            }\\n            else if (q > nodes.get(n-1)) {\\n            \\tans.add(Arrays.asList(nodes.get(n-1), -1));          // if value == last element, no need to do BS\\n            }\\n            else {\\n            \\tint lo = 0;\\n            \\tint hi = n-1;\\n            \\tboolean found = false;\\n            \\twhile (lo < hi) {\\n            \\t\\tint m = (lo+hi) >> 1;\\n            \\t\\tint mid = nodes.get(m);\\n            \\t\\tif (q == mid) {\\n            \\t\\t\\tfound = true;\\n            \\t\\t\\tans.add(Arrays.asList(q, q));\\n            \\t\\t\\tbreak;\\n            \\t\\t}\\n            \\t\\telse if (q > mid) {\\n            \\t\\t\\tlo = m + 1;\\n            \\t\\t}\\n            \\t\\telse {\\n            \\t\\t\\thi = m;\\n            \\t\\t}\\n            \\t}\\n            \\t\\n\\t\\t\\t\\t// now lo and hi are equal\\n            \\tif (!found) {\\n            \\t\\tans.add(Arrays.asList(nodes.get(lo-1), nodes.get(lo)));\\n            \\t}\\n            }\\n        }\\n        \\n        return ans;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831894,
                "title": "binary-search-lower-and-upper-bound",
                "content": "If you wanna clear your doubts related to lower bound and upper bound do this problem , it helps.\\nmy approach: \\n1. converting the binary tree into a single array , since the binary search tree\\'s inorder traversal is always sorted we can perform binary search on it.\\n2. the query part (i broke the question down into subparts and computed all the queries one by one using a loop.\\n\\n*    calculating the lower of the query:-\\n1. we store the value returned by lower bound rather the index. \\n2. we check if the index returned is within the array , i mean its not out of bound if yes we enter the if condition else we return the last element of the array is the closest to that query will be that element itself.\\n3. inside the if we check if the value at the returned index is equal to the query or not if yes we insert the answer as same, else we decrease the index by one **since in lower bound if the element is not found in the array it returns the next greatest element**\\n4. if the value of the index after computation is less than 0 we simply insert -1.\\n5. else we insert the value at that index.\\n\\n* now for the upper boundry \\n1. we check for the upper bound but if the value itself is present the upper boundry is the same as the query , we check that.\\n2. if the upper bound value is within the array we return that as an answer.\\n3. else its -1 always as it doesnt exist.\\n\\n**The entire catch that i found was there\\'s no inbuilt fucntion that returns the value of the lower boundry of the number in a sorted array so all we had to do is find the lower bound of the array and decrease the value of returned index by one if query not found else return the query itself.**\\n```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int> &arr)\\n    {\\n        if(root==NULL)\\n            return;\\n        else\\n        {\\n            inorder(root->left,arr);\\n            arr.push_back(root->val);\\n            inorder(root->right,arr);\\n        }\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& q) {\\n        vector<int> arr;\\n        inorder(root,arr);\\n        int n = arr.size();\\n        vector<vector<int>> ans;\\n        for(int i =0;i<q.size();i++)\\n        {\\n           \\n            int l = lower_bound(arr.begin(),arr.end(),q[i])-arr.begin();\\n            if(l>=0 && l<n)\\n            {\\n                if(arr[l]!=q[i])\\n                   l-=1;\\n                if(l<0)\\n                    l=-1;\\n                else\\n                   l=arr[l];\\n            }\\n            else\\n            {\\n                l=arr.back();\\n            }\\n            \\n                \\n            int h = upper_bound(arr.begin(),arr.end(),q[i])-arr.begin();\\n            if(l!=-1 && q[i]==l)\\n                h=q[i];\\n            else if(h>=0 && h<n)\\n            {\\n                h=arr[h];\\n            }\\n            else\\n            {\\n                h=-1;\\n            }\\n            ans.push_back({l,h});\\n        }\\n        return ans;\\n    }\\n};\\n```\\nThis probably as not that concise a explanation but hey you can always ask if you got a doubt. \\nThanks for reading it till here if you did.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int> &arr)\\n    {\\n        if(root==NULL)\\n            return;\\n        else\\n        {\\n            inorder(root->left,arr);\\n            arr.push_back(root->val);\\n            inorder(root->right,arr);\\n        }\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& q) {\\n        vector<int> arr;\\n        inorder(root,arr);\\n        int n = arr.size();\\n        vector<vector<int>> ans;\\n        for(int i =0;i<q.size();i++)\\n        {\\n           \\n            int l = lower_bound(arr.begin(),arr.end(),q[i])-arr.begin();\\n            if(l>=0 && l<n)\\n            {\\n                if(arr[l]!=q[i])\\n                   l-=1;\\n                if(l<0)\\n                    l=-1;\\n                else\\n                   l=arr[l];\\n            }\\n            else\\n            {\\n                l=arr.back();\\n            }\\n            \\n                \\n            int h = upper_bound(arr.begin(),arr.end(),q[i])-arr.begin();\\n            if(l!=-1 && q[i]==l)\\n                h=q[i];\\n            else if(h>=0 && h<n)\\n            {\\n                h=arr[h];\\n            }\\n            else\\n            {\\n                h=-1;\\n            }\\n            ans.push_back({l,h});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831758,
                "title": "commented-solution-inorder-traversal-and-lower-bound",
                "content": "# Approach\\nsave all the elements sorted in an array and use lower bound.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int>arr;\\n    void dfs(TreeNode*root)\\n    {\\n        if(root==NULL)\\n            return ;\\n        \\n        dfs(root->left);\\n        arr.push_back(root->val);\\n        dfs(root->right);\\n        return;\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) \\n    {\\n        /* we will use inorder traversal to put all the elements of binary search tree into the array */\\n        dfs(root);  \\n\\n        vector<vector<int>>ans;\\n        // return ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int ind=lower_bound(begin(arr),end(arr),queries[i])-begin(arr);// will get the index of element greater than or equal to query\\n            vector<int>ansq(2,0);\\n            \\n            /* To find the smallest value greater than query */\\n            ansq[1]=(ind==arr.size())?-1:arr[ind]; \\n            \\n            /* To find the largest value greater than query */\\n            if(ind<arr.size() and arr[ind]==queries[i]) ansq[0]=arr[ind];  \\n            else if(ind == 0) ansq[0]=-1;\\n            else  ansq[0]=arr[--ind]; /* since for this case the arr[ind] will be greater than one  */\\n            ans.push_back(ansq);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int>arr;\\n    void dfs(TreeNode*root)\\n    {\\n        if(root==NULL)\\n            return ;\\n        \\n        dfs(root->left);\\n        arr.push_back(root->val);\\n        dfs(root->right);\\n        return;\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) \\n    {\\n        /* we will use inorder traversal to put all the elements of binary search tree into the array */\\n        dfs(root);  \\n\\n        vector<vector<int>>ans;\\n        // return ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int ind=lower_bound(begin(arr),end(arr),queries[i])-begin(arr);// will get the index of element greater than or equal to query\\n            vector<int>ansq(2,0);\\n            \\n            /* To find the smallest value greater than query */\\n            ansq[1]=(ind==arr.size())?-1:arr[ind]; \\n            \\n            /* To find the largest value greater than query */\\n            if(ind<arr.size() and arr[ind]==queries[i]) ansq[0]=arr[ind];  \\n            else if(ind == 0) ansq[0]=-1;\\n            else  ansq[0]=arr[--ind]; /* since for this case the arr[ind] will be greater than one  */\\n            ans.push_back(ansq);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833324,
                "title": "c-solution-in-order-traversal-binary-search-explanation",
                "content": "As the tree given to us is a Binary Search tree, we can do a inorder traversal and get that in an array/vector. And this will be sorted, as as it\\'s sorted we can apply Binary Search in that array.\\nRules:-\\n1) If the query is present in the array, we simple put the query value in the \"ans\" vector, as it\\'ll be both min(i) and max(i).\\n2) If it\\'s not present:-\\n\\t* We\\'d need the min(i), so to get that we take out the lower bound element and lower bound will give us the smallest that is greater than query[i], so we put array[lb - 1] into our answer.\\n\\t* We\\'d need the max(i), so we simply can take the upper bound element.\\n\\t\\nNow if lb <= 0 || lb > help.size() we need to return -1 as then min(i) will not be possible.\\nSimilarly. if ub < 0 || ub >= help.size() we also return -1.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void inorder(vector<int> &help, TreeNode *root) {\\n        if(root == NULL) return;\\n        inorder(help, root->left);\\n        help.push_back(root->val);\\n        inorder(help, root->right);\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int> help;\\n        inorder(help, root);\\n        vector<vector<int>> ans;\\n        for(int i = 0; i < queries.size(); i++) {\\n            int lb = lower_bound(help.begin(), help.end(), queries[i]) - help.begin();\\n            int ub = upper_bound(help.begin(), help.end(), queries[i]) - help.begin();\\n            vector<int> temp;\\n            if(binary_search(help.begin(), help.end(), queries[i])) {\\n                temp.push_back(queries[i]);\\n                temp.push_back(queries[i]);\\n            } else {\\n                if(lb <= 0 || lb > help.size()) temp.push_back(-1);\\n                else temp.push_back(help[lb - 1]);\\n                if(ub < 0 || ub >= help.size()) temp.push_back(-1);\\n                else temp.push_back(help[ub]);\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nTime Complexity:- O(n) + O(queries * log(queries)\\nSpace Complexity:- O(n).\\n\\nHope you liked the solution :D.\\nPlease do upvote!. <3.",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void inorder(vector<int> &help, TreeNode *root) {\\n        if(root == NULL) return;\\n        inorder(help, root->left);\\n        help.push_back(root->val);\\n        inorder(help, root->right);\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int> help;\\n        inorder(help, root);\\n        vector<vector<int>> ans;\\n        for(int i = 0; i < queries.size(); i++) {\\n            int lb = lower_bound(help.begin(), help.end(), queries[i]) - help.begin();\\n            int ub = upper_bound(help.begin(), help.end(), queries[i]) - help.begin();\\n            vector<int> temp;\\n            if(binary_search(help.begin(), help.end(), queries[i])) {\\n                temp.push_back(queries[i]);\\n                temp.push_back(queries[i]);\\n            } else {\\n                if(lb <= 0 || lb > help.size()) temp.push_back(-1);\\n                else temp.push_back(help[lb - 1]);\\n                if(ub < 0 || ub >= help.size()) temp.push_back(-1);\\n                else temp.push_back(help[ub]);\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831805,
                "title": "any-reason-why-recursive-search-results-into-tle",
                "content": "This solution is not passing...\\nI think without using recursion it will work as some solutions pointed out\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        def searchMin(node, val):\\n            if not node: return -1\\n            if node.val == val: return val\\n            if node.val > val:\\n                return searchMin(node.left, val)\\n            else:\\n                return max(node.val, searchMin(node.right, val))\\n            \\n        def searchMax(node, val):\\n            if not node: return -1\\n            if node.val == val: return val\\n            if node.val < val:\\n                return searchMax(node.right, val)\\n            else:\\n                res = searchMax(node.left, val)\\n                return node.val if res == -1 else res\\n            \\n        answer = []\\n        for val in queries:\\n            answer.append([searchMin(root, val), searchMax(root, val)])\\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        def searchMin(node, val):\\n            if not node: return -1\\n            if node.val == val: return val\\n            if node.val > val:\\n                return searchMin(node.left, val)\\n            else:\\n                return max(node.val, searchMin(node.right, val))\\n            \\n        def searchMax(node, val):\\n            if not node: return -1\\n            if node.val == val: return val\\n            if node.val < val:\\n                return searchMax(node.right, val)\\n            else:\\n                res = searchMax(node.left, val)\\n                return node.val if res == -1 else res\\n            \\n        answer = []\\n        for val in queries:\\n            answer.append([searchMin(root, val), searchMax(root, val)])\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831740,
                "title": "c-binary-search-solution-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode *root, vector<int> &nums){\\n        if(!root) return;\\n        inorder(root->left, nums);\\n        nums.push_back(root->val);\\n        inorder(root->right, nums);\\n    }\\n    int findMin(vector<int> &nums, int q){\\n        int l=0, h=nums.size()-1;\\n        int ans = -1;\\n        while(l<=h){\\n            int m = l+(h-l)/2;\\n            if(nums[m]<=q){\\n                if(nums[m]==q){\\n                    return q;\\n                }\\n                ans = nums[m];\\n                l = m+1;\\n            }else{\\n                h=m-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int findMax(vector<int> &nums, int q){\\n        int l=0, h=nums.size()-1;\\n        int ans = -1;\\n        while(l<=h){\\n            int m = l+(h-l)/2;\\n            if(nums[m]>=q){\\n                if(nums[m]==q){\\n                    return q;\\n                }\\n                ans = nums[m];\\n                h = m-1;\\n            }else{\\n                l=m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& q) {\\n        vector<int> nums;\\n        inorder(root, nums);\\n        vector<vector<int>>ans;\\n        for(int i=0; i<q.size(); i++){\\n            int mini = findMin(nums, q[i]);\\n            int maxi = findMax(nums, q[i]);\\n            ans.push_back({mini, maxi});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode *root, vector<int> &nums){\\n        if(!root) return;\\n        inorder(root->left, nums);\\n        nums.push_back(root->val);\\n        inorder(root->right, nums);\\n    }\\n    int findMin(vector<int> &nums, int q){\\n        int l=0, h=nums.size()-1;\\n        int ans = -1;\\n        while(l<=h){\\n            int m = l+(h-l)/2;\\n            if(nums[m]<=q){\\n                if(nums[m]==q){\\n                    return q;\\n                }\\n                ans = nums[m];\\n                l = m+1;\\n            }else{\\n                h=m-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int findMax(vector<int> &nums, int q){\\n        int l=0, h=nums.size()-1;\\n        int ans = -1;\\n        while(l<=h){\\n            int m = l+(h-l)/2;\\n            if(nums[m]>=q){\\n                if(nums[m]==q){\\n                    return q;\\n                }\\n                ans = nums[m];\\n                h = m-1;\\n            }else{\\n                l=m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& q) {\\n        vector<int> nums;\\n        inorder(root, nums);\\n        vector<vector<int>>ans;\\n        for(int i=0; i<q.size(); i++){\\n            int mini = findMin(nums, q[i]);\\n            int maxi = findMax(nums, q[i]);\\n            ans.push_back({mini, maxi});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831719,
                "title": "arraylist-tree-traversal-java-solution",
                "content": "```\\n  List<List<Integer>>send=new ArrayList<>();\\n        TreeNode backup=root;\\n        for(int q:queries){\\n            root=backup;\\n             List<Integer> lls=new ArrayList<>();\\n            int max=-1,min=-1;\\n            while(root!=null){\\n                if(root.val==q){\\n                    min=q;\\n                    max=q;\\n                    break;\\n                }\\n                else if(root.val>q){ // changing the max until we get the root value equal to queries value if root value does not exist it will result in closest bigger value to queries value\\n                    max=root.val;\\n                    root=root.left;\\n                }\\n                else{   // changing the min until we get the root value equal to queries value if root value does not exist it will result in closest smaller value to queries value\\n                    min=root.val;\\n                    root=root.right;\\n                }\\n            }\\n                lls.add(min);\\n                lls.add(max);\\n                send.add(new ArrayList<>(lls));\\n        }\\n        return send;",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\n  List<List<Integer>>send=new ArrayList<>();\\n        TreeNode backup=root;\\n        for(int q:queries){\\n            root=backup;\\n             List<Integer> lls=new ArrayList<>();\\n            int max=-1,min=-1;\\n            while(root!=null){\\n                if(root.val==q){\\n                    min=q;\\n                    max=q;\\n                    break;\\n                }\\n                else if(root.val>q){ // changing the max until we get the root value equal to queries value if root value does not exist it will result in closest bigger value to queries value\\n                    max=root.val;\\n                    root=root.left;\\n                }\\n                else{   // changing the min until we get the root value equal to queries value if root value does not exist it will result in closest smaller value to queries value\\n                    min=root.val;\\n                    root=root.right;\\n                }\\n            }\\n                lls.add(min);\\n                lls.add(max);\\n                send.add(new ArrayList<>(lls));\\n        }\\n        return send;",
                "codeTag": "Unknown"
            },
            {
                "id": 2979515,
                "title": "c-time-o-logn-binary-search-tree-closest-nodes-queries-in-a-binary-search-tree",
                "content": "\\n# Approach\\n## ****Implement inorder traversal for containing values in sorted manner and then finding min and max values for each query through binary search.****\\n\\n# Complexity\\n- Time complexity:\\n**O(logN) for each query**\\n\\n- Space complexity:\\n**O(m) where m is the number of nodes in tree which will be used by sorted vector.**\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& q) \\n    {\\n         vector<vector<int>> v;\\n        TreeNode* t=root;\\n        vector<int> arr;\\n        int key;\\n        stack<TreeNode*> s;\\n        //iterative inorder traversal\\n        while(1)\\n        {\\n            if(t)\\n            {\\n                s.push(t);\\n                t=t->left;\\n            }\\n            else{\\n                if(s.empty())break;\\n                t=s.top();\\n                s.pop();\\n                arr.push_back(t->val);\\n                t=t->right;\\n            }\\n        }\\n        //looping for entire query\\n        for(int i=0;i<q.size();i++)\\n        {\\n            int min=-1,max=-1;\\n            vector<int> a;\\n            key=q[i];\\n            int l=0,h=arr.size()-1;\\n            int m=(l+h)/2;\\n            //implementing binary search\\n            while(l<=h)\\n            {\\n                if(arr[m]==key)\\n                {\\n                    min=arr[m];\\n                    max=arr[m];\\n                    break;\\n                }\\n\\n                if(arr[m]>key)\\n                {\\n                    max=arr[m];\\n                    h=m-1;\\n                }\\n                else\\n                {\\n                    min=arr[m];\\n                    l=m+1;\\n                }\\n                m=(l+h)/2;\\n            }\\n            //pushing the values in 1d array\\n            a.push_back(min);\\n            a.push_back(max);\\n            //pushing the values of 1d vector-a into 2d vector:v\\n            v.push_back(a);\\n        } \\n        return v; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& q) \\n    {\\n         vector<vector<int>> v;\\n        TreeNode* t=root;\\n        vector<int> arr;\\n        int key;\\n        stack<TreeNode*> s;\\n        //iterative inorder traversal\\n        while(1)\\n        {\\n            if(t)\\n            {\\n                s.push(t);\\n                t=t->left;\\n            }\\n            else{\\n                if(s.empty())break;\\n                t=s.top();\\n                s.pop();\\n                arr.push_back(t->val);\\n                t=t->right;\\n            }\\n        }\\n        //looping for entire query\\n        for(int i=0;i<q.size();i++)\\n        {\\n            int min=-1,max=-1;\\n            vector<int> a;\\n            key=q[i];\\n            int l=0,h=arr.size()-1;\\n            int m=(l+h)/2;\\n            //implementing binary search\\n            while(l<=h)\\n            {\\n                if(arr[m]==key)\\n                {\\n                    min=arr[m];\\n                    max=arr[m];\\n                    break;\\n                }\\n\\n                if(arr[m]>key)\\n                {\\n                    max=arr[m];\\n                    h=m-1;\\n                }\\n                else\\n                {\\n                    min=arr[m];\\n                    l=m+1;\\n                }\\n                m=(l+h)/2;\\n            }\\n            //pushing the values in 1d array\\n            a.push_back(min);\\n            a.push_back(max);\\n            //pushing the values of 1d vector-a into 2d vector:v\\n            v.push_back(a);\\n        } \\n        return v; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835174,
                "title": "python-3-14-lines-dfs-w-example-t-m-1140ms-15-4mb",
                "content": "class Solution:\\n    def closestNodes(self, root: TreeNode, queries: List[int]) -> List[List[int]]:\\n\\n                                                                #    Ex:   queries = [16,2,1,5]\\n        d, ans = [], []                                         #   \\n                                                                #            __6__\\n        def dfs(node):                                          #           /     \\\\\\n            if not node: return                                 #          3       13___\\n                                                                #         / \\\\     /     \\\\\\n            dfs(node.left )                                     #        2   4   9      _15\\n            d.append(node.val)                                  #                     /\\n            dfs(node.right)                                     #                    14\\n            \\n\\n        dfs(root)                                               #   d = [2, 3, 4, 6, 9,13,14,15]\\n                                                                #  idx:  0  1  2  3  4  5  6  7 \\n        for q in queries:                                       #\\n            idx = bisect_left(d,q)                              #     q    idx    ans\\n                                                                #    \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013\\n            if idx == len(d): ans.append([d[-1]   ,-1    ])     #    16     8    [15,-1]  <--  idx == 8\\n            elif d[idx] == q: ans.append([d[idx]  ,d[idx]])     #     2     0    [ 2, 2]  <-- d[0] == 2\\n            elif    idx == 0: ans.append([-1      ,d[0]  ])     #     1     0    [-1, 2]  <--  idx == 0\\n            else            : ans.append([d[idx-1],d[idx]])     #     5     3    [ 4, 6]  <-- else [d[2],d[3]] \\n\\n        return ans                                              #  return [[15,-1],[2,2],[-1,2],[4,6]]\\n\\nhttps://leetcode.com/submissions/detail/847100436/\\n\\nI could be wrong, but I think it\\'s O(N) / O(N), worst case.",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "class Solution:\\n    def closestNodes(self, root: TreeNode, queries: List[int]) -> List[List[int]]:\\n\\n                                                                #    Ex:   queries = [16,2,1,5]\\n        d, ans = [], []                                         #   \\n                                                                #            __6__\\n        def dfs(node):                                          #           /     \\\\\\n            if not node: return                                 #          3       13___\\n                                                                #         / \\\\     /     \\\\\\n            dfs(node.left )                                     #        2   4   9      _15\\n            d.append(node.val)                                  #                     /\\n            dfs(node.right)                                     #                    14\\n            \\n\\n        dfs(root)                                               #   d = [2, 3, 4, 6, 9,13,14,15]\\n                                                                #  idx:  0  1  2  3  4  5  6  7 \\n        for q in queries:                                       #\\n            idx = bisect_left(d,q)                              #     q    idx    ans\\n                                                                #    \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013\\n            if idx == len(d): ans.append([d[-1]   ,-1    ])     #    16     8    [15,-1]  <--  idx == 8\\n            elif d[idx] == q: ans.append([d[idx]  ,d[idx]])     #     2     0    [ 2, 2]  <-- d[0] == 2\\n            elif    idx == 0: ans.append([-1      ,d[0]  ])     #     1     0    [-1, 2]  <--  idx == 0\\n            else            : ans.append([d[idx-1],d[idx]])     #     5     3    [ 4, 6]  <-- else [d[2],d[3]] \\n\\n        return ans                                              #  return [[15,-1],[2,2],[-1,2],[4,6]]\\n\\nhttps://leetcode.com/submissions/detail/847100436/\\n\\nI could be wrong, but I think it\\'s O(N) / O(N), worst case.",
                "codeTag": "Java"
            },
            {
                "id": 2832192,
                "title": "java-clear-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI tried to use DFS to traverse down the BST to find the smaller and larger value, but there are cases with imbalanced tree and gave TLE. \\n\\nThen, I tried an ArrayList to store the inorder TreeNode value and use bineary search, and it worked out.\\n\\n\\n# Complexity\\n- Time complexity: klogn\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> listinorder = new ArrayList<>();\\n        inorder(root, listinorder);\\n        for (int target : queries) { \\n            List<Integer> cur = binarysearch(target, listinorder);\\n            res.add(cur);\\n        }\\n        return res;\\n    } \\n    private void inorder(TreeNode node, List<Integer> listinorder) {\\n        if (node == null) {\\n            return;\\n        }\\n        inorder(node.left, listinorder);\\n        listinorder.add(node.val);\\n        inorder(node.right, listinorder);\\n    }\\n    private List<Integer> binarysearch(int target, List<Integer> list) {\\n        int left = 0;\\n        int right = list.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (list.get(mid) == target) {\\n                return List.of(target, target);\\n            } else if (list.get(mid) > target) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        int smallres = right == -1 ? -1 : list.get(right); \\n        int largeres = left == list.size() ? -1 : list.get(left); \\n        return List.of(smallres, largeres);\\n    }    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> listinorder = new ArrayList<>();\\n        inorder(root, listinorder);\\n        for (int target : queries) { \\n            List<Integer> cur = binarysearch(target, listinorder);\\n            res.add(cur);\\n        }\\n        return res;\\n    } \\n    private void inorder(TreeNode node, List<Integer> listinorder) {\\n        if (node == null) {\\n            return;\\n        }\\n        inorder(node.left, listinorder);\\n        listinorder.add(node.val);\\n        inorder(node.right, listinorder);\\n    }\\n    private List<Integer> binarysearch(int target, List<Integer> list) {\\n        int left = 0;\\n        int right = list.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (list.get(mid) == target) {\\n                return List.of(target, target);\\n            } else if (list.get(mid) > target) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        int smallres = right == -1 ? -1 : list.get(right); \\n        int largeres = left == list.size() ? -1 : list.get(left); \\n        return List.of(smallres, largeres);\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831982,
                "title": "c-iterative-short-quick-code",
                "content": "> Leetcode OJ is strict on TC for this question for some reason. \\n\\n**Iterative Solution** TC: O(M LogN)\\n```cpp\\nvector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n    vector<vector<int>> res;\\n    for(int q: queries){\\n        TreeNode* node = root;\\n        int mini = -1, maxi = -1;\\n        while(node){\\n            if(q == node->val){\\n                mini = maxi = node->val;\\n                break;\\n            }\\n            else if(q < node->val){\\n                maxi = node->val;\\n                node = node->left;\\n            }\\n            else if(q > node->val){\\n                mini = node->val;\\n                node = node->right;\\n            }\\n        }\\n        res.push_back({mini, maxi});\\n    }\\n    return res;\\n}\\n```\\n**Upvote if it helps :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n    vector<vector<int>> res;\\n    for(int q: queries){\\n        TreeNode* node = root;\\n        int mini = -1, maxi = -1;\\n        while(node){\\n            if(q == node->val){\\n                mini = maxi = node->val;\\n                break;\\n            }\\n            else if(q < node->val){\\n                maxi = node->val;\\n                node = node->left;\\n            }\\n            else if(q > node->val){\\n                mini = node->val;\\n                node = node->right;\\n            }\\n        }\\n        res.push_back({mini, maxi});\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2831977,
                "title": "simple-java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n) for inorder traversal + O(n log n) for sorting + O(k * log n) where k is for iterating queries list and log n is for searching element in the inorder traversal list \\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> q) {\\n        List<List<Integer>> nm=new ArrayList<>();\\n        List<Integer> kk=new ArrayList<>();\\n        task(root,kk);\\n        Collections.sort(kk);\\n        for(int i=0;i<q.size();i++)\\n        {\\n            int ele=q.get(i),s=-1,p=-1;\\n            int l=0,h=kk.size()-1;\\n            while(l<=h)\\n            {\\n                int mid=(l+h)/2;\\n                if(kk.get(mid)==ele) \\n                {\\n                    s=ele;\\n                    break;\\n                }\\n                else if(kk.get(mid)<ele) \\n                {\\n                    s=kk.get(mid);\\n                    l=mid+1;\\n                }\\n                else\\n                {\\n                    h=mid-1;\\n                }\\n            }\\n            l=0;\\n            h=kk.size()-1;\\n            while(l<=h)\\n            {\\n                int mid=(l+h)/2;\\n                if(kk.get(mid)==ele) \\n                {\\n                    p=ele;\\n                    break;\\n                }\\n                else if(kk.get(mid)>ele) \\n                {\\n                    p=kk.get(mid);\\n                    h=mid-1;\\n                }\\n                else\\n                {\\n                    l=mid+1;\\n                }\\n            }\\n            List<Integer> f=new ArrayList<>();\\n            f.add(s);\\n            f.add(p);\\n            nm.add(new ArrayList<>(f));\\n        }\\n        return nm;\\n    }\\n    void task(TreeNode root, List<Integer> nm)\\n    {\\n        if(root==null)\\n            return;\\n        task(root.left,nm);\\n        nm.add(root.val);\\n        task(root.right,nm);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> q) {\\n        List<List<Integer>> nm=new ArrayList<>();\\n        List<Integer> kk=new ArrayList<>();\\n        task(root,kk);\\n        Collections.sort(kk);\\n        for(int i=0;i<q.size();i++)\\n        {\\n            int ele=q.get(i),s=-1,p=-1;\\n            int l=0,h=kk.size()-1;\\n            while(l<=h)\\n            {\\n                int mid=(l+h)/2;\\n                if(kk.get(mid)==ele) \\n                {\\n                    s=ele;\\n                    break;\\n                }\\n                else if(kk.get(mid)<ele) \\n                {\\n                    s=kk.get(mid);\\n                    l=mid+1;\\n                }\\n                else\\n                {\\n                    h=mid-1;\\n                }\\n            }\\n            l=0;\\n            h=kk.size()-1;\\n            while(l<=h)\\n            {\\n                int mid=(l+h)/2;\\n                if(kk.get(mid)==ele) \\n                {\\n                    p=ele;\\n                    break;\\n                }\\n                else if(kk.get(mid)>ele) \\n                {\\n                    p=kk.get(mid);\\n                    h=mid-1;\\n                }\\n                else\\n                {\\n                    l=mid+1;\\n                }\\n            }\\n            List<Integer> f=new ArrayList<>();\\n            f.add(s);\\n            f.add(p);\\n            nm.add(new ArrayList<>(f));\\n        }\\n        return nm;\\n    }\\n    void task(TreeNode root, List<Integer> nm)\\n    {\\n        if(root==null)\\n            return;\\n        task(root.left,nm);\\n        nm.add(root.val);\\n        task(root.right,nm);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831761,
                "title": "c-solution-predecessor-successor",
                "content": "\\t/**\\n\\t * Definition for a binary tree node.\\n\\t * struct TreeNode {\\n\\t *     int val;\\n\\t *     TreeNode *left;\\n\\t *     TreeNode *right;\\n\\t *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n\\t *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n\\t *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n\\t * };\\n\\t */\\n\\t#define Node TreeNode\\n\\t#define data val\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid findPreSuc(Node* root, Node*& pre, Node*& suc, int key)\\n\\t\\t{\\n\\t\\t\\tif(root == NULL)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif(root->data == key)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsuc = root;\\n\\t\\t\\t\\tpre = root;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse if(root->data > key)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsuc = root;\\n\\t\\t\\t\\tfindPreSuc(root->left,pre,suc,key);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tpre = root;\\n\\t\\t\\t\\tfindPreSuc(root->right,pre,suc,key);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvector<vector<int>> closestNodes(Node* root, vector<int>& q) {\\n\\t\\t\\tvector<vector<int>> ans;\\n\\t\\t\\tint n = q.size();\\n\\t\\t\\tfor(int i = 0; i < n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tNode* pre = NULL;\\n\\t\\t\\t\\tNode* suc = NULL;\\n\\t\\t\\t\\tfindPreSuc(root,pre,suc,q[i]);\\n\\t\\t\\t\\tvector<int> temp;\\n\\t\\t\\t\\tif(pre)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp.push_back(pre->data);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp.push_back(-1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(suc)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp.push_back(suc->data);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp.push_back(-1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans.push_back(temp);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\t\\n\\t# upvote, if this helps u...",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid findPreSuc(Node* root, Node*& pre, Node*& suc, int key)\\n\\t\\t{\\n\\t\\t\\tif(root == NULL)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2831701,
                "title": "c-inorder-traversal-and-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int lowerBound(vector<int> &arr,int num){\\n        int s=0,e=arr.size()-1;\\n        while(s<=e){\\n            int mid = s + (e-s)/2;\\n            if(arr[mid]<=num){\\n                s=mid+1;\\n            }else{\\n                e=mid-1;\\n            }\\n        }\\n        return e;\\n    }\\n    int upperBound(vector<int> &arr,int num){\\n        int s=0,e=arr.size()-1;\\n        while(s<=e){\\n            int mid = s + (e-s)/2;\\n            if(arr[mid]>=num){\\n                e=mid-1;\\n            }else{\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n    void inorderedTraversal(TreeNode *root,vector<int> &arr){\\n        if(!root) return;\\n        inorderedTraversal(root->left,arr);\\n        arr.push_back(root->val);\\n        inorderedTraversal(root->right,arr);\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int> arr;\\n        // finding inordered traversal\\n        inorderedTraversal(root,arr);\\n        vector<vector<int>> ans;\\n        // processing queries\\n        for(int i=0;i<queries.size();i++){\\n            int x = lowerBound(arr,queries[i]);\\n            int y = upperBound(arr,queries[i]);\\n            if(x>=0 && x<arr.size() && arr[x]<=queries[i]) x = arr[x];\\n            else x = -1;\\n            if(y>=0 && y<arr.size() && arr[y]>=queries[i]) y = arr[y];\\n            else y = -1;\\n            // cout<<x<<\" \"<<y<<\"\\\\n\";\\n            ans.push_back({x,y});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lowerBound(vector<int> &arr,int num){\\n        int s=0,e=arr.size()-1;\\n        while(s<=e){\\n            int mid = s + (e-s)/2;\\n            if(arr[mid]<=num){\\n                s=mid+1;\\n            }else{\\n                e=mid-1;\\n            }\\n        }\\n        return e;\\n    }\\n    int upperBound(vector<int> &arr,int num){\\n        int s=0,e=arr.size()-1;\\n        while(s<=e){\\n            int mid = s + (e-s)/2;\\n            if(arr[mid]>=num){\\n                e=mid-1;\\n            }else{\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n    void inorderedTraversal(TreeNode *root,vector<int> &arr){\\n        if(!root) return;\\n        inorderedTraversal(root->left,arr);\\n        arr.push_back(root->val);\\n        inorderedTraversal(root->right,arr);\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int> arr;\\n        // finding inordered traversal\\n        inorderedTraversal(root,arr);\\n        vector<vector<int>> ans;\\n        // processing queries\\n        for(int i=0;i<queries.size();i++){\\n            int x = lowerBound(arr,queries[i]);\\n            int y = upperBound(arr,queries[i]);\\n            if(x>=0 && x<arr.size() && arr[x]<=queries[i]) x = arr[x];\\n            else x = -1;\\n            if(y>=0 && y<arr.size() && arr[y]>=queries[i]) y = arr[y];\\n            else y = -1;\\n            // cout<<x<<\" \"<<y<<\"\\\\n\";\\n            ans.push_back({x,y});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2832367,
                "title": "binary-search-along-with-inorder-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are given a binary search tree that means the inorder traversal of the bst would give us a sorted array and we find ceil and floor using binary search\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst of all we need to find the inorder traversal of the tree and save it in a list and then define a function in which we perform the binary search. Take two variables ceil and floor assigning them to \\'-1\\' inititally and as we perform binary search moving left and right pointers we also change the value of ceil and floor and if the value is in the list then we return a list of the same element containing two times else we return the list containing floor and ceil i.e. [floor,ceil].\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity for finding the inorder for a bst with recursion is O(n).\\nThe time complexity for the binary search function is O(logn).\\nHence the total time complexity is O(n+logn) which equals to O(n) which is a pretty decent algorithmic time complexity.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe returned list is however not considered.We used a list to store the inorder traversal hence the space complexity is O(n).\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        lst=[]\\n        def inorder(root):\\n            if root!=None:\\n                inorder(root.left)\\n                lst.append(root.val)\\n                inorder(root.right)\\n        inorder(root)\\n        def getceil(nums,n):\\n            left=0\\n            right=len(nums)-1\\n            ceil=-1\\n            floor=-1\\n            while left<=right:\\n                mid=(left+right)//2\\n                if nums[mid]==n:\\n                    return [nums[mid],nums[mid]]\\n                elif n<nums[mid]:\\n                    ceil=nums[mid]\\n                    right=mid-1\\n                else:\\n                    left=mid+1\\n                    floor=nums[mid]\\n            return [floor,ceil]\\n        return [getceil(lst,i) for i in queries]\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Sorting"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        lst=[]\\n        def inorder(root):\\n            if root!=None:\\n                inorder(root.left)\\n                lst.append(root.val)\\n                inorder(root.right)\\n        inorder(root)\\n        def getceil(nums,n):\\n            left=0\\n            right=len(nums)-1\\n            ceil=-1\\n            floor=-1\\n            while left<=right:\\n                mid=(left+right)//2\\n                if nums[mid]==n:\\n                    return [nums[mid],nums[mid]]\\n                elif n<nums[mid]:\\n                    ceil=nums[mid]\\n                    right=mid-1\\n                else:\\n                    left=mid+1\\n                    floor=nums[mid]\\n            return [floor,ceil]\\n        return [getceil(lst,i) for i in queries]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831953,
                "title": "simple-approach-beginner-friendly-solution",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    void printInorder(TreeNode* node)\\n    {\\n        if (node == NULL)\\n            return;\\n        printInorder(node->left);\\n        v.push_back(node->val);\\n        printInorder(node->right);\\n    }\\nvector<int> binarySearch(int x, int low, int high) {\\n    int mini = -1, maxi = -1;\\n  while (low <= high) {\\n    int mid = low + (high - low) / 2;\\n\\n    if (v[mid] == x)\\n      return {v[mid], v[mid]};\\n\\n    if (v[mid] < x){\\n      low = mid + 1;\\n      mini = v[mid];\\n    }\\n    else{\\n      high = mid - 1;\\n      maxi = v[mid];\\n    }\\n  }\\n\\n  return {mini, maxi};\\n}\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& q) {\\n        printInorder(root);\\n        vector<vector<int>> ans;\\n        for(int i=0; i<q.size(); i++){\\n            ans.push_back(binarySearch(q[i], 0, v.size()-1));\\n        }\\n        return ans;\\n    }\\n};\\n```\\nCode block\\n```\\n// Another Solution : Using Two function\\n\\nclass Solution {\\npublic:\\n    vector<int> arr;\\n    void inorder(TreeNode* root) {\\n        if(!root) \\n            return;\\n        inorder(root->left);\\n        arr.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    int lower(int val) {\\n        int i = 0, j = arr.size()-1, ans = -1;\\n        while(i <= j) {\\n            int m = i + ((j-i) >> 1);\\n            if(arr[m] <= val) {\\n                ans = m;\\n                i = m+1;\\n            } else {\\n                \\n                j = m-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int upper(int val) {\\n        int i = 0, j = arr.size()-1, ans = -1;\\n        while(i <= j) {\\n            int m = i + ((j-i) >> 1);\\n            if(arr[m] >= val) {\\n                ans = m;\\n                j = m-1;\\n            } else {\\n                i = m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        inorder(root);\\n        vector<vector<int>> ans;\\n        for(int &qry : queries) {\\n            int x = lower(qry), y = upper(qry);\\n            if(x != -1)\\n                x = arr[x];\\n            if(y != -1)\\n                y = arr[y];\\n            ans.push_back({x, y});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Binary Search Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    void printInorder(TreeNode* node)\\n    {\\n        if (node == NULL)\\n            return;\\n        printInorder(node->left);\\n        v.push_back(node->val);\\n        printInorder(node->right);\\n    }\\nvector<int> binarySearch(int x, int low, int high) {\\n    int mini = -1, maxi = -1;\\n  while (low <= high) {\\n    int mid = low + (high - low) / 2;\\n\\n    if (v[mid] == x)\\n      return {v[mid], v[mid]};\\n\\n    if (v[mid] < x){\\n      low = mid + 1;\\n      mini = v[mid];\\n    }\\n    else{\\n      high = mid - 1;\\n      maxi = v[mid];\\n    }\\n  }\\n\\n  return {mini, maxi};\\n}\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& q) {\\n        printInorder(root);\\n        vector<vector<int>> ans;\\n        for(int i=0; i<q.size(); i++){\\n            ans.push_back(binarySearch(q[i], 0, v.size()-1));\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n// Another Solution : Using Two function\\n\\nclass Solution {\\npublic:\\n    vector<int> arr;\\n    void inorder(TreeNode* root) {\\n        if(!root) \\n            return;\\n        inorder(root->left);\\n        arr.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    int lower(int val) {\\n        int i = 0, j = arr.size()-1, ans = -1;\\n        while(i <= j) {\\n            int m = i + ((j-i) >> 1);\\n            if(arr[m] <= val) {\\n                ans = m;\\n                i = m+1;\\n            } else {\\n                \\n                j = m-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int upper(int val) {\\n        int i = 0, j = arr.size()-1, ans = -1;\\n        while(i <= j) {\\n            int m = i + ((j-i) >> 1);\\n            if(arr[m] >= val) {\\n                ans = m;\\n                j = m-1;\\n            } else {\\n                i = m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        inorder(root);\\n        vector<vector<int>> ans;\\n        for(int &qry : queries) {\\n            int x = lower(qry), y = upper(qry);\\n            if(x != -1)\\n                x = arr[x];\\n            if(y != -1)\\n                y = arr[y];\\n            ans.push_back({x, y});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831935,
                "title": "without-converting-to-array-c-solution",
                "content": "class Solution {\\npublic:\\n    \\n    void closest(TreeNode* root,int index, int &ans1,int &ans2)\\n    {\\n        if(!root)\\n            return;\\n        \\n        \\n        if(root->val<index)\\n        {\\n            ans1 = root->val;\\n            closest(root->right,index,ans1,ans2);\\n        }\\n        else if(root->val>index)\\n        {\\n            ans2 = root->val;\\n            closest(root->left,index,ans1,ans2);\\n        }\\n        else \\n        {\\n            ans1 = root->val;\\n            ans2 = root->val;\\n            return;\\n        }\\n       \\n        return;\\n    }\\n    \\n\\n    \\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        \\n        vector<vector<int>> res;\\n        \\n        for(int i = 0; i< queries.size();i++)\\n        {\\n            vector<int> ans;\\n            ans.push_back(INT_MIN);\\n            ans.push_back(INT_MAX);\\n            closest(root,queries[i],ans[0],ans[1]);\\n            ans[0] = (ans[0]==INT_MIN)?-1:ans[0];\\n            ans[1] = (ans[1] == INT_MAX)?-1:ans[1];\\n            res.push_back(ans);\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    void closest(TreeNode* root,int index, int &ans1,int &ans2)\\n    {\\n        if(!root)\\n            return;\\n        \\n        \\n        if(root->val<index)\\n        {\\n            ans1 = root->val;\\n            closest(root->right,index,ans1,ans2);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2831793,
                "title": "python-sorted-array-binary-search",
                "content": "```\\n\\t\\tA = []\\n        \\n        def inorder(head):\\n            if head is None:\\n                return \\n            inorder(head.left)\\n            A.append(head.val)\\n            inorder(head.right)\\n            \\n        inorder(root)\\n        # print(A)\\n        \\n        n = len(A)\\n        from bisect import bisect_left\\n        res = []\\n        for q in queries:\\n            i = bisect_left(A, q)\\n            # print(A,i,q)\\n            if i == n:\\n                res.append( [ A[i-1] , -1  ]  )\\n            elif A[i] == q:\\n                res.append( [ A[i] , A[i]  ]  )\\n            elif i == 0:\\n                res.append( [ -1 , A[i]  ]  )\\n            \\n            else:\\n                res.append( [ A[i-1] , A[i]  ]  )\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\n\\t\\tA = []\\n        \\n        def inorder(head):\\n            if head is None:\\n                return \\n            inorder(head.left)\\n            A.append(head.val)\\n            inorder(head.right)\\n            \\n        inorder(root)\\n        # print(A)\\n        \\n        n = len(A)\\n        from bisect import bisect_left\\n        res = []\\n        for q in queries:\\n            i = bisect_left(A, q)\\n            # print(A,i,q)\\n            if i == n:\\n                res.append( [ A[i-1] , -1  ]  )\\n            elif A[i] == q:\\n                res.append( [ A[i] , A[i]  ]  )\\n            elif i == 0:\\n                res.append( [ -1 , A[i]  ]  )\\n            \\n            else:\\n                res.append( [ A[i-1] , A[i]  ]  )\\n        return res\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3859097,
                "title": "binary-search-on-traversal",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void dfs(TreeNode* node, vector<int> &ans) {\\n        if(node == NULL) return;\\n        dfs(node->left, ans);\\n        ans.push_back(node->val);\\n        dfs(node->right, ans);\\n    }\\npublic:\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int> ans;\\n        dfs(root, ans);\\n        vector<vector<int>> res;\\n        for(auto q:queries) {\\n            int left_index = lower_bound(ans.begin(), ans.end(), q) - ans.begin();\\n            if(binary_search(ans.begin(), ans.end(), q)) {\\n                res.push_back({q, q});\\n            }\\n            else if(ans[0] > q) {\\n                res.push_back({-1, ans[0]});\\n            }\\n            else if(ans.back() < q) {\\n                res.push_back({ans.back(), -1});\\n            }\\n            else {\\n                res.push_back({ans[left_index-1], ans[left_index]});\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void dfs(TreeNode* node, vector<int> &ans) {\\n        if(node == NULL) return;\\n        dfs(node->left, ans);\\n        ans.push_back(node->val);\\n        dfs(node->right, ans);\\n    }\\npublic:\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int> ans;\\n        dfs(root, ans);\\n        vector<vector<int>> res;\\n        for(auto q:queries) {\\n            int left_index = lower_bound(ans.begin(), ans.end(), q) - ans.begin();\\n            if(binary_search(ans.begin(), ans.end(), q)) {\\n                res.push_back({q, q});\\n            }\\n            else if(ans[0] > q) {\\n                res.push_back({-1, ans[0]});\\n            }\\n            else if(ans.back() < q) {\\n                res.push_back({ans.back(), -1});\\n            }\\n            else {\\n                res.push_back({ans[left_index-1], ans[left_index]});\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357404,
                "title": "python3-dfs-binary-search-slow-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity \\n- Time complexity: O(n log n + q log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        a, res, stack = [], [], [(root)]\\n        while stack:\\n            node = stack.pop()\\n            a.append(node.val)\\n            if node.left: stack.append(node.left)\\n            if node.right: stack.append(node.right)\\n        a.sort()\\n        for q in queries:\\n            mini, maxi, left, right = -1, -1, 0, len(a) - 1\\n            while left <= right:\\n                mid = (left + right) // 2\\n                if a[mid] <= q:\\n                    mini = a[mid]\\n                    left = mid + 1\\n                else: right = mid - 1\\n            left, right = 0, len(a) - 1\\n            while left <= right:\\n                mid = (left + right) // 2\\n                if a[mid] >= q:\\n                    maxi = a[mid]\\n                    right = mid - 1\\n                else: left = mid + 1\\n            res.append([mini, maxi])\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Binary Search",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        a, res, stack = [], [], [(root)]\\n        while stack:\\n            node = stack.pop()\\n            a.append(node.val)\\n            if node.left: stack.append(node.left)\\n            if node.right: stack.append(node.right)\\n        a.sort()\\n        for q in queries:\\n            mini, maxi, left, right = -1, -1, 0, len(a) - 1\\n            while left <= right:\\n                mid = (left + right) // 2\\n                if a[mid] <= q:\\n                    mini = a[mid]\\n                    left = mid + 1\\n                else: right = mid - 1\\n            left, right = 0, len(a) - 1\\n            while left <= right:\\n                mid = (left + right) // 2\\n                if a[mid] >= q:\\n                    maxi = a[mid]\\n                    right = mid - 1\\n                else: left = mid + 1\\n            res.append([mini, maxi])\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2840726,
                "title": "c-two-pointer-approach-time-o-n-mlogm",
                "content": "To convert BST into sort array. And sort queries. \\nThen use two pointer approach to go through these two sorted array.\\nAssume N is the number of nodes of BST, M is the number of queries.\\n\\n```C++\\nclass Solution {\\npublic:\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<vector<int>> ans;\\n        vector<int> A;\\n        A.push_back(INT_MIN);\\n        inorder(root,A);\\n        A.push_back(INT_MAX);\\n        int n = A.size(), m = queries.size();\\n        vector<vector<int>> qs = vector<vector<int>> (m, vector<int>(4,-1));\\n        for(int i = 0; i < queries.size(); i++) { //qs[i][2]:min_i and qs[i][3]:max_i is default value -1\\n            qs[i][0] = queries[i]; //save the value in queries\\n            qs[i][1] = i; //save the original index value in queries\\n        }\\n        //sorting by value of value of queries\\n        sort(qs.begin(), qs.end(), [](auto &lhs, auto &rhs){return lhs[0] < rhs[0];});\\n        //two-pointer here to find out every min_i and max_i for each query. \\n        int Ai = 0, Qi =0; //Ai is index of A, Qi is index of qs\\n        while(Ai < n && Qi < m) {\\n            if(qs[Qi][0] == A[Ai]){\\n                qs[Qi][2] = qs[Qi][3] = qs[Qi][0];\\n                Qi++;\\n            } else if(qs[Qi][0] > A[Ai]) {\\n                Ai++;\\n            } else { //case (qs[Qi][0]<  A[Ai]) \\n                if(Ai-1>0) qs[Qi][2] = A[Ai-1]; //save min_i\\n                if(Ai<n-1) qs[Qi][3] = A[Ai]; // save max_i\\n                Qi++;\\n            }           \\n        }\\n        //sorting back to original order, the same as to the queries. \\n        sort(qs.begin(), qs.end(), [](auto &lhs, auto&rhs){return lhs[1] < rhs[1];});\\n        //And then make the answer from the result of qs\\n        for(auto &v: qs)  ans.push_back({v[2], v[3]});\\n\\n        return ans;\\n    }\\n    \\n    void inorder(TreeNode* root, vector<int>& res) {\\n        if(root==nullptr) return;\\n        inorder(root->left, res);\\n        res.push_back(root->val);\\n        inorder(root->right, res);\\n    }  \\n};\\n```\\n\\nTime Complexity :\\nInorder traversal of BST to make array A -> O(N)\\nsort queries and make it into qs ->O(MlogM)\\nUse two-pointer to go through these two sorted array, A and qs, make answer -> O(N+M) \\n\\nSo,  the total Time complexity is O(N + MlogM) \\n\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<vector<int>> ans;\\n        vector<int> A;\\n        A.push_back(INT_MIN);\\n        inorder(root,A);\\n        A.push_back(INT_MAX);\\n        int n = A.size(), m = queries.size();\\n        vector<vector<int>> qs = vector<vector<int>> (m, vector<int>(4,-1));\\n        for(int i = 0; i < queries.size(); i++) { //qs[i][2]:min_i and qs[i][3]:max_i is default value -1\\n            qs[i][0] = queries[i]; //save the value in queries\\n            qs[i][1] = i; //save the original index value in queries\\n        }\\n        //sorting by value of value of queries\\n        sort(qs.begin(), qs.end(), [](auto &lhs, auto &rhs){return lhs[0] < rhs[0];});\\n        //two-pointer here to find out every min_i and max_i for each query. \\n        int Ai = 0, Qi =0; //Ai is index of A, Qi is index of qs\\n        while(Ai < n && Qi < m) {\\n            if(qs[Qi][0] == A[Ai]){\\n                qs[Qi][2] = qs[Qi][3] = qs[Qi][0];\\n                Qi++;\\n            } else if(qs[Qi][0] > A[Ai]) {\\n                Ai++;\\n            } else { //case (qs[Qi][0]<  A[Ai]) \\n                if(Ai-1>0) qs[Qi][2] = A[Ai-1]; //save min_i\\n                if(Ai<n-1) qs[Qi][3] = A[Ai]; // save max_i\\n                Qi++;\\n            }           \\n        }\\n        //sorting back to original order, the same as to the queries. \\n        sort(qs.begin(), qs.end(), [](auto &lhs, auto&rhs){return lhs[1] < rhs[1];});\\n        //And then make the answer from the result of qs\\n        for(auto &v: qs)  ans.push_back({v[2], v[3]});\\n\\n        return ans;\\n    }\\n    \\n    void inorder(TreeNode* root, vector<int>& res) {\\n        if(root==nullptr) return;\\n        inorder(root->left, res);\\n        res.push_back(root->val);\\n        inorder(root->right, res);\\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837144,
                "title": "binary-search-queries",
                "content": "# Intuition\\nExtract all values from the tree into a vector and sort it to run quries using binary search.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing Depth-First Search to extract all values from the tree into a vector `ord`.\\nAfter Soring `ord`.\\nWe use binary search to search ceil and floor for the queires and add the result to `answer`.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O((n + q)log n)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(n)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> ord;\\n    \\n    void dfs(TreeNode* root){\\n        if(root == nullptr)\\n            return;\\n        dfs(root->left);\\n        ord.push_back(root->val);\\n        dfs(root->right);\\n    }\\n    \\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        dfs(root);\\n        \\n        sort(ord.begin(),ord.end());\\n        vector<vector<int> > answer;\\n        \\n        int n = ord.size(), q = queries.size(), l, r, ans, ans1;\\n        \\n        for(int i = 0; i < q; i++) {\\n            l = 0, r = n - 1, ans = -1, ans1 = -1;\\n            while(l <= r){\\n                int mid = (l + r) / 2;\\n                if(ord[mid] <= queries[i]) {\\n                    ans = ord[mid];\\n                    l = mid + 1;\\n                }\\n                else\\n                    r = mid - 1;\\n            }\\n            \\n            l = 0,r = n - 1;\\n            while(l <= r){\\n                int mid = (l + r) / 2;\\n                if(ord[mid] >= queries[i]) {\\n                    ans1 = ord[mid];\\n                    r = mid - 1;\\n                }\\n                else\\n                    l = mid + 1;\\n                \\n            }\\n            answer.push_back({ans, ans1});\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Tree",
                    "Depth-First Search",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> ord;\\n    \\n    void dfs(TreeNode* root){\\n        if(root == nullptr)\\n            return;\\n        dfs(root->left);\\n        ord.push_back(root->val);\\n        dfs(root->right);\\n    }\\n    \\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        dfs(root);\\n        \\n        sort(ord.begin(),ord.end());\\n        vector<vector<int> > answer;\\n        \\n        int n = ord.size(), q = queries.size(), l, r, ans, ans1;\\n        \\n        for(int i = 0; i < q; i++) {\\n            l = 0, r = n - 1, ans = -1, ans1 = -1;\\n            while(l <= r){\\n                int mid = (l + r) / 2;\\n                if(ord[mid] <= queries[i]) {\\n                    ans = ord[mid];\\n                    l = mid + 1;\\n                }\\n                else\\n                    r = mid - 1;\\n            }\\n            \\n            l = 0,r = n - 1;\\n            while(l <= r){\\n                int mid = (l + r) / 2;\\n                if(ord[mid] >= queries[i]) {\\n                    ans1 = ord[mid];\\n                    r = mid - 1;\\n                }\\n                else\\n                    l = mid + 1;\\n                \\n            }\\n            answer.push_back({ans, ans1});\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834022,
                "title": "c-binary-search-tree-morris-preorder-traversal-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\t/**\\n\\t * Definition for a binary tree node.\\n\\t * struct TreeNode {\\n\\t *     int val;\\n\\t *     TreeNode *left;\\n\\t *     TreeNode *right;\\n\\t *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n\\t *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n\\t *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n\\t * };\\n\\t */\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint mini(TreeNode* root, int t, vector<int>& v){\\n\\t\\t\\tint res=-1;\\n\\t\\t\\tint i=0, j=v.size()-1;\\n\\t\\t\\twhile(i<=j){\\n\\t\\t\\t\\tint mid=i+(j-i)/2;\\n\\t\\t\\t\\tif(v[mid]==t){res=v[mid]; break;}\\n\\t\\t\\t\\telse if(v[mid]>t){j=mid-1;}\\n\\t\\t\\t\\telse{res=v[mid]; i=mid+1;}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t\\tint maxi(TreeNode* root, int t, vector<int>& v){\\n\\t\\t\\tint res=-1;\\n\\t\\t\\tint i=0, j=v.size()-1;\\n\\t\\t\\twhile(i<=j){\\n\\t\\t\\t\\tint mid=i+(j-i)/2;\\n\\t\\t\\t\\tif(v[mid]==t){res=v[mid]; break;}\\n\\t\\t\\t\\telse if(v[mid]>t){res=v[mid];  j=mid-1;}\\n\\t\\t\\t\\telse{i=mid+1;}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t\\tvector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n\\t\\t\\tvector<vector<int>>ans;\\n\\t\\t\\tTreeNode* rt=root;\\n\\t\\t\\tvector<int>v;\\n\\t\\t\\twhile(rt){\\n\\t\\t\\t\\tif(!rt->left){\\n\\t\\t\\t\\t\\tv.push_back(rt->val);\\n\\t\\t\\t\\t\\trt=rt->right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tTreeNode* r=rt->left;\\n\\t\\t\\t\\t\\twhile(r->right && r->right!=rt){\\n\\t\\t\\t\\t\\t\\tr=r->right;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(!r->right){\\n\\t\\t\\t\\t\\t\\tr->right=rt;\\n\\t\\t\\t\\t\\t\\trt=rt->left;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tr->right=NULL;\\n\\t\\t\\t\\t\\t\\tv.push_back(rt->val);\\n\\t\\t\\t\\t\\t\\trt=rt->right;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0; i<queries.size(); i++){\\n\\t\\t\\t\\tint a=mini(root, queries[i], v), b=maxi(root, queries[i], v);\\n\\t\\t\\t\\tans.push_back({a, b});\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint mini(TreeNode* root, int t, vector<int>& v){\\n\\t\\t\\tint res=-1;\\n\\t\\t\\tint i=0, j=v.size()-1;\\n\\t\\t\\twhile(i<=j){\\n\\t\\t\\t\\tint mid=i+(j-i)/2;\\n\\t\\t\\t\\tif(v[mid]==t){res=v[mid]; break;}",
                "codeTag": "Java"
            },
            {
                "id": 2832737,
                "title": "inorder-collect-one-binary-search-per-each-query",
                "content": "# Code\\n```\\nvar closestNodes = function(root, queries) {\\n    const values = [];\\n    const result = new Array(queries.length);\\n    let index;\\n\\n    const inorder = node => {\\n        if (node === null) return;\\n\\n        inorder(node.left);\\n        values.push(node.val);\\n        inorder(node.right);\\n    };\\n\\n    inorder(root);\\n    \\n    const lastIndex = values.length - 1;\\n\\n    const bs = val => {\\n        let left = 0;\\n        let right = lastIndex;\\n        let mid;\\n\\n        while (left <= right) {\\n            mid = (left + right) >> 1;\\n            if (values[mid] === val) return mid;\\n            else if (values[mid] < val) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n\\n        return left;\\n    };\\n\\n    for (let i = 0; i < queries.length; ++i) {\\n        index = bs(queries[i]);\\n        if (values[index] === queries[i]) result[i] = [ values[index], values[index] ];\\n        else {\\n            result[i] = [ index <= 0 ? -1 : values[index - 1], index > lastIndex ? -1 : values[index] ];\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar closestNodes = function(root, queries) {\\n    const values = [];\\n    const result = new Array(queries.length);\\n    let index;\\n\\n    const inorder = node => {\\n        if (node === null) return;\\n\\n        inorder(node.left);\\n        values.push(node.val);\\n        inorder(node.right);\\n    };\\n\\n    inorder(root);\\n    \\n    const lastIndex = values.length - 1;\\n\\n    const bs = val => {\\n        let left = 0;\\n        let right = lastIndex;\\n        let mid;\\n\\n        while (left <= right) {\\n            mid = (left + right) >> 1;\\n            if (values[mid] === val) return mid;\\n            else if (values[mid] < val) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n\\n        return left;\\n    };\\n\\n    for (let i = 0; i < queries.length; ++i) {\\n        index = bs(queries[i]);\\n        if (values[index] === queries[i]) result[i] = [ values[index], values[index] ];\\n        else {\\n            result[i] = [ index <= 0 ? -1 : values[index - 1], index > lastIndex ? -1 : values[index] ];\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2832687,
                "title": "inorder-bst-traversal-binary-search-java",
                "content": "# Inorder BST Traversal + Binary Search\\n\\n**n = number of nodes in the BST\\nk = size of queries list**\\n\\n1. Since we have already have BST as input, we can easily convert it to sorted list/array \\n\\tTime Complexity - O(n), Space Complexity - O(n) for creating a new list *sortedList* of size n )\\n\\n2. Then for each query, we can use binary search to find the index where the query should be inserted, and we call this index as *insertionIndex*. We also set two local variable min and max with -1.\\nTime Complexity - O(log n)\\n\\n3.  If insertion index is in the range [0,n) and the element at insertion index is equal to query we are looking for, *then we set min and max as query itself*.\\n\\n4. Else,\\n* We know that min element should be at the index just before insertionIndex (i.e insertionIndex-1), if this (insertionIndex-1) is >= 0, *then we set min value with sortedList.get(insertionIndex-1)*.\\n* We know that max element should be just at insertionIndex, if this (insertionIndex) is less than n, *then we set max value to sortedList.get(insertionIndex).*\\n\\n5. Now we add min and max in the final result list.\\n\\n**Complexity:**\\n\\nTime - O(n) + O(k * log n) \\nSpace - O(n)\\n\\n**Code:**\\n\\n```\\nclass Solution {\\n\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        \\n        List<Integer> sortedList = new ArrayList<>();\\n\\t\\t\\n\\t\\t// inorder traversal of BST\\n        sortedListFromBST(root, sortedList);\\n        \\n        int n = sortedList.size();\\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n       \\n        for(int query: queries){\\n            \\n            int insertionIndex = binarySearch(sortedList, query);\\n            \\n            int min = -1;\\n            int max = -1;\\n\\n            if(insertionIndex<n && sortedList.get(insertionIndex) == query){\\n                min = query;\\n                max = query;\\n            }\\n            else{\\n                if(insertionIndex-1>=0){\\n                    min = sortedList.get(insertionIndex-1);\\n                }\\n                \\n                if(insertionIndex<n){\\n                    max = sortedList.get(insertionIndex);\\n                }\\n            }\\n            result.add(Arrays.asList(min, max));\\n        }\\n        return result;\\n    }\\n    \\n    int binarySearch(List<Integer> list, int query){\\n        int left = 0;\\n        int right = list.size()-1;\\n        while(left<=right){\\n            int mid = left + (right-left)/2;\\n            if(list.get(mid)==query){\\n                return mid;\\n            }else if(list.get(mid)>query){\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n        }\\n        return left;\\n    }\\n    \\n    void sortedListFromBST(TreeNode root, List<Integer> sortedTreeList){\\n        \\n        if(root==null){\\n            return;\\n        }\\n        \\n        sortedListFromBST(root.left, sortedTreeList);\\n        sortedTreeList.add(root.val);\\n        sortedListFromBST(root.right, sortedTreeList);\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        \\n        List<Integer> sortedList = new ArrayList<>();\\n\\t\\t\\n\\t\\t// inorder traversal of BST\\n        sortedListFromBST(root, sortedList);\\n        \\n        int n = sortedList.size();\\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n       \\n        for(int query: queries){\\n            \\n            int insertionIndex = binarySearch(sortedList, query);\\n            \\n            int min = -1;\\n            int max = -1;\\n\\n            if(insertionIndex<n && sortedList.get(insertionIndex) == query){\\n                min = query;\\n                max = query;\\n            }\\n            else{\\n                if(insertionIndex-1>=0){\\n                    min = sortedList.get(insertionIndex-1);\\n                }\\n                \\n                if(insertionIndex<n){\\n                    max = sortedList.get(insertionIndex);\\n                }\\n            }\\n            result.add(Arrays.asList(min, max));\\n        }\\n        return result;\\n    }\\n    \\n    int binarySearch(List<Integer> list, int query){\\n        int left = 0;\\n        int right = list.size()-1;\\n        while(left<=right){\\n            int mid = left + (right-left)/2;\\n            if(list.get(mid)==query){\\n                return mid;\\n            }else if(list.get(mid)>query){\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n        }\\n        return left;\\n    }\\n    \\n    void sortedListFromBST(TreeNode root, List<Integer> sortedTreeList){\\n        \\n        if(root==null){\\n            return;\\n        }\\n        \\n        sortedListFromBST(root.left, sortedTreeList);\\n        sortedTreeList.add(root.val);\\n        sortedListFromBST(root.right, sortedTreeList);\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832172,
                "title": "c-purely-using-search-bst-easypizy",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    \\n    vector<int> search(TreeNode* p, int val){\\n        TreeNode* root = p;\\n        int minv = INT_MIN;\\n        int maxv = INT_MAX;\\n        \\n        while(root){\\n            if(root->val > val){\\n                maxv = min(maxv, root->val);\\n                root = root->left;\\n            }else if(root->val < val){\\n                minv = max(minv, root->val);\\n                root = root->right;\\n            }else{\\n                return {root->val, root->val};\\n            }\\n        }\\n        \\n        if(minv == INT_MIN) minv = -1;\\n        if(maxv == INT_MAX) maxv = -1;\\n        \\n        return {minv, maxv};\\n    }\\npublic:\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& que) {\\n        vector<vector<int>> ans;\\n        \\n        for(int i=0; i<que.size(); i++){\\n            ans.push_back(search(root, que[i]));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    \\n    vector<int> search(TreeNode* p, int val){\\n        TreeNode* root = p;\\n        int minv = INT_MIN;\\n        int maxv = INT_MAX;\\n        \\n        while(root){\\n            if(root->val > val){\\n                maxv = min(maxv, root->val);\\n                root = root->left;\\n            }else if(root->val < val){\\n                minv = max(minv, root->val);\\n                root = root->right;\\n            }else{\\n                return {root->val, root->val};\\n            }\\n        }\\n        \\n        if(minv == INT_MIN) minv = -1;\\n        if(maxv == INT_MAX) maxv = -1;\\n        \\n        return {minv, maxv};\\n    }\\npublic:\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& que) {\\n        vector<vector<int>> ans;\\n        \\n        for(int i=0; i<que.size(); i++){\\n            ans.push_back(search(root, que[i]));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832001,
                "title": "java-two-solutions-balance-input-or-treeset",
                "content": "My first idea is to simply implement `floor` and `ceiling` functions by traversing the given `TreeNode root`.\\n\\n``` java\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> ret = new ArrayList<>();\\n        for (int n : queries) {\\n            ret.add(List.<Integer>of(floor(root, n), ceiling(root, n)));\\n        }\\n        return ret;\\n    }\\n\\n    private int floor(TreeNode root, int n) {\\n        if (root == null) {\\n            return -1;\\n        } else if (root.val == n) {\\n            return n;\\n        } else if (root.val < n) {\\n            int rightFloor = floor(root.right, n);\\n            return rightFloor == -1 ? root.val : rightFloor;\\n        } else {\\n            return floor(root.left, n);\\n        }\\n    }\\n\\n    private int ceiling(TreeNode root, int n) {\\n        if (root == null) {\\n            return -1;\\n        } else if (root.val == n) {\\n            return n;\\n        } else if (root.val < n) {\\n            return ceiling(root.right, n);\\n        } else {\\n            int leftCeiling = ceiling(root.left, n);\\n            return leftCeiling == -1 ? root.val : leftCeiling;\\n        }\\n    }\\n}\\n```\\n\\nHowever, the input `TreeNode root` can be very unbalanced in some tests and thus leads to TLE, so we need to balance the input first. It actually involves another question: [1382. Balance a Binary Search Tree](https://leetcode.com/problems/balance-a-binary-search-tree/).\\n\\nAn alternative solution is to rebuild the input as a `TreeSet`, which is self-balancing.\\n\\n``` java\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> ret = new ArrayList<>();\\n        if (root == null) {\\n            for (int i = 1; i <= queries.size(); i++) {\\n                ret.add(List.<Integer>of(-1, -1));\\n            }\\n            return ret;\\n        }\\n        TreeSet<Integer> tree = new TreeSet<>();\\n        Queue<TreeNode> queue = new ArrayDeque<>();\\n        queue.add(root);\\n        while (!queue.isEmpty()) {\\n            TreeNode node = queue.poll();\\n            tree.add(node.val);\\n            if (node.left != null) {\\n                queue.add(node.left);\\n            }\\n            if (node.right != null) {\\n                queue.add(node.right);\\n            }\\n        }\\n        for (int n : queries) {\\n            Integer floor = tree.floor(n);\\n            Integer ceiling = tree.ceiling(n);\\n            ret.add(List.<Integer>of(floor == null ? -1 : floor, ceiling == null ? -1 : ceiling));\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Search Tree",
                    "Ordered Set"
                ],
                "code": "``` java\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> ret = new ArrayList<>();\\n        for (int n : queries) {\\n            ret.add(List.<Integer>of(floor(root, n), ceiling(root, n)));\\n        }\\n        return ret;\\n    }\\n\\n    private int floor(TreeNode root, int n) {\\n        if (root == null) {\\n            return -1;\\n        } else if (root.val == n) {\\n            return n;\\n        } else if (root.val < n) {\\n            int rightFloor = floor(root.right, n);\\n            return rightFloor == -1 ? root.val : rightFloor;\\n        } else {\\n            return floor(root.left, n);\\n        }\\n    }\\n\\n    private int ceiling(TreeNode root, int n) {\\n        if (root == null) {\\n            return -1;\\n        } else if (root.val == n) {\\n            return n;\\n        } else if (root.val < n) {\\n            return ceiling(root.right, n);\\n        } else {\\n            int leftCeiling = ceiling(root.left, n);\\n            return leftCeiling == -1 ? root.val : leftCeiling;\\n        }\\n    }\\n}\\n```\n``` java\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> ret = new ArrayList<>();\\n        if (root == null) {\\n            for (int i = 1; i <= queries.size(); i++) {\\n                ret.add(List.<Integer>of(-1, -1));\\n            }\\n            return ret;\\n        }\\n        TreeSet<Integer> tree = new TreeSet<>();\\n        Queue<TreeNode> queue = new ArrayDeque<>();\\n        queue.add(root);\\n        while (!queue.isEmpty()) {\\n            TreeNode node = queue.poll();\\n            tree.add(node.val);\\n            if (node.left != null) {\\n                queue.add(node.left);\\n            }\\n            if (node.right != null) {\\n                queue.add(node.right);\\n            }\\n        }\\n        for (int n : queries) {\\n            Integer floor = tree.floor(n);\\n            Integer ceiling = tree.ceiling(n);\\n            ret.add(List.<Integer>of(floor == null ? -1 : floor, ceiling == null ? -1 : ceiling));\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831909,
                "title": "simple-python-code",
                "content": "\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        \\n        \\n        array = []\\n        def helper(root):\\n            if root :\\n                helper(root.left)\\n                array.append(root.val)\\n                helper(root.right)\\n                \\n        helper(root)\\n\\n        result = []\\n        for query in queries:\\n            place  = bisect.bisect_left(array, query)\\n            \\n            if 0 <= place< len(array) and array[place]==query:\\n                result.append([query, query])\\n            else:\\n                answer = [-1, -1]\\n                if place > 0:\\n                    answer[0] = array[place-1]\\n                if place < len(array):\\n                    answer[1] = array[place]\\n\\n                result.append(answer)\\n            \\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        \\n        \\n        array = []\\n        def helper(root):\\n            if root :\\n                helper(root.left)\\n                array.append(root.val)\\n                helper(root.right)\\n                \\n        helper(root)\\n\\n        result = []\\n        for query in queries:\\n            place  = bisect.bisect_left(array, query)\\n            \\n            if 0 <= place< len(array) and array[place]==query:\\n                result.append([query, query])\\n            else:\\n                answer = [-1, -1]\\n                if place > 0:\\n                    answer[0] = array[place-1]\\n                if place < len(array):\\n                    answer[1] = array[place]\\n\\n                result.append(answer)\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831863,
                "title": "c-binary-search",
                "content": "```\\npublic class Solution {\\n    public IList<IList<int>> ClosestNodes(TreeNode root, IList<int> queries) {\\n        List<IList<int>> res = new();\\n        List<int> list = new();\\n        populate(root, list);\\n        foreach(int q in queries)\\n            res.Add(new List<int>() { findMin(list,q), findMax(list,q) });\\n        return res;\\n    }\\n    private void populate(TreeNode root, List<int> list){     \\n        if(root == null) return;\\n        populate(root.left, list);\\n        list.Add(root.val);\\n        populate(root.right, list);\\n    }\\n    private int findMin(List<int> list, int q){\\n        //largest value in the tree that is smaller than or equal to q\\n        int lo = 0, hi = list.Count-1;\\n        while(lo < hi){\\n            int mid = lo+(hi-lo)/2+1;\\n            if(list[mid] <= q){\\n                lo = mid;\\n            } else\\n                hi = mid-1;\\n        }\\n        return list[lo] > q ? -1 : list[lo];\\n    }\\n    private int findMax(List<int> list, int q){\\n        //smallest value in the tree that is greater than or equal to q\\n        int lo = 0, hi = list.Count-1;\\n        while(lo < hi){\\n            int mid = lo+(hi-lo)/2;\\n            if(list[mid] >= q){\\n                hi = mid;\\n            } else\\n                lo = mid+1;\\n        }\\n        return list[hi] < q ? -1 : list[hi];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> ClosestNodes(TreeNode root, IList<int> queries) {\\n        List<IList<int>> res = new();\\n        List<int> list = new();\\n        populate(root, list);\\n        foreach(int q in queries)\\n            res.Add(new List<int>() { findMin(list,q), findMax(list,q) });\\n        return res;\\n    }\\n    private void populate(TreeNode root, List<int> list){     \\n        if(root == null) return;\\n        populate(root.left, list);\\n        list.Add(root.val);\\n        populate(root.right, list);\\n    }\\n    private int findMin(List<int> list, int q){\\n        //largest value in the tree that is smaller than or equal to q\\n        int lo = 0, hi = list.Count-1;\\n        while(lo < hi){\\n            int mid = lo+(hi-lo)/2+1;\\n            if(list[mid] <= q){\\n                lo = mid;\\n            } else\\n                hi = mid-1;\\n        }\\n        return list[lo] > q ? -1 : list[lo];\\n    }\\n    private int findMax(List<int> list, int q){\\n        //smallest value in the tree that is greater than or equal to q\\n        int lo = 0, hi = list.Count-1;\\n        while(lo < hi){\\n            int mid = lo+(hi-lo)/2;\\n            if(list[mid] >= q){\\n                hi = mid;\\n            } else\\n                lo = mid+1;\\n        }\\n        return list[hi] < q ? -1 : list[hi];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831856,
                "title": "python-simple-python-solution-using-binary-search",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 3715 ms, faster than 28.57% of Python3 online submissions for Closest Nodes Queries in a Binary Search Tree.\\n# Memory Usage: 154.6 MB, less than 14.29% of Python3 online submissions for Closest Nodes Queries in a Binary Search Tree.\\n\\n\\tclass Solution:\\n\\t\\tdef closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n\\n\\t\\t\\tarray = []\\n\\n\\t\\t\\tdef PrintTree(node):\\n\\t\\t\\t\\tif node != None:\\n\\t\\t\\t\\t\\tPrintTree(node.left)\\n\\t\\t\\t\\t\\tarray.append(node.val)\\n\\t\\t\\t\\t\\tPrintTree(node.right)\\n\\n\\t\\t\\tPrintTree(root)\\n\\n\\t\\t\\tresult = []\\n\\n\\t\\t\\tfor query in queries:\\n\\t\\t\\t\\tleft, right = 0, len(array) - 1\\n\\n\\t\\t\\t\\twhile right >= left:\\n\\t\\t\\t\\t\\tmid = (right + left) // 2\\n\\n\\t\\t\\t\\t\\tif array[mid] == query:\\n\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\t\\telif array[mid] > query:\\n\\t\\t\\t\\t\\t\\tright = mid - 1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tleft = mid + 1\\n\\n\\t\\t\\t\\tif array[mid] == query:\\n\\t\\t\\t\\t\\tresult.append([array[mid], array[mid]])\\n\\n\\t\\t\\t\\telif array[mid] > query:\\n\\t\\t\\t\\t\\tif (mid - 1) >= 0:\\n\\t\\t\\t\\t\\t\\tresult.append([array[mid - 1], array[mid]])\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tresult.append([-1, array[mid]])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif (mid + 1) < len(array):\\n\\t\\t\\t\\t\\t\\tresult.append([array[mid], array[mid + 1]])\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tresult.append([array[mid], -1])\\n\\n\\t\\t\\treturn result\\n\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 3715 ms, faster than 28.57% of Python3 online submissions for Closest Nodes Queries in a Binary Search Tree.\\n# Memory Usage: 154.6 MB, less than 14.29% of Python3 online submissions for Closest Nodes Queries in a Binary Search Tree.\\n\\n\\tclass Solution:\\n\\t\\tdef closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n\\n\\t\\t\\tarray = []\\n\\n\\t\\t\\tdef PrintTree(node):\\n\\t\\t\\t\\tif node != None:\\n\\t\\t\\t\\t\\tPrintTree(node.left)\\n\\t\\t\\t\\t\\tarray.append(node.val)\\n\\t\\t\\t\\t\\tPrintTree(node.right)\\n\\n\\t\\t\\tPrintTree(root)\\n\\n\\t\\t\\tresult = []\\n\\n\\t\\t\\tfor query in queries:\\n\\t\\t\\t\\tleft, right = 0, len(array) - 1\\n\\n\\t\\t\\t\\twhile right >= left:\\n\\t\\t\\t\\t\\tmid = (right + left) // 2\\n\\n\\t\\t\\t\\t\\tif array[mid] == query:\\n\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\t\\telif array[mid] > query:\\n\\t\\t\\t\\t\\t\\tright = mid - 1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tleft = mid + 1\\n\\n\\t\\t\\t\\tif array[mid] == query:\\n\\t\\t\\t\\t\\tresult.append([array[mid], array[mid]])\\n\\n\\t\\t\\t\\telif array[mid] > query:\\n\\t\\t\\t\\t\\tif (mid - 1) >= 0:\\n\\t\\t\\t\\t\\t\\tresult.append([array[mid - 1], array[mid]])\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tresult.append([-1, array[mid]])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif (mid + 1) < len(array):\\n\\t\\t\\t\\t\\t\\tresult.append([array[mid], array[mid + 1]])\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tresult.append([array[mid], -1])\\n\\n\\t\\t\\treturn result\\n\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 2831844,
                "title": "python-runtime-beats-100-python-soln",
                "content": "# Approach\\n- We can first store all the node values in an array to make searching part easy that will take O(n) time we can use inorder traversal so we don\\'t have to sort the array.\\n- Now for each query we can use binary search for closest smaller element and closest greater element that will take O(logn) time.\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        nums = []\\n        def inorder(root):\\n            if root:\\n                inorder(root.left)\\n                nums.append(root.val)\\n                inorder(root.right)\\n        inorder(root)\\n        ans = []\\n        l = len(nums)\\n        \\n        def binary_search(nums, x):\\n            left, right = 0, l-1\\n            a = -1\\n            b = -1\\n            \\n            while left <= right:\\n                mid = (left + right) // 2\\n                \\n                if x==nums[mid]:\\n                    return [x, x]\\n                \\n                elif nums[mid]<x:\\n                    a = nums[mid]\\n                    left = mid+1\\n                \\n                else:\\n                    right = mid-1\\n                    \\n            \\n            left, right = 0, l-1\\n            b = -1\\n                \\n            while left <= right:\\n                mid = (left + right) // 2\\n                \\n                if nums[mid]>x:\\n                    b = nums[mid]\\n                    right = mid-1\\n                \\n                else:\\n                    left = mid+1\\n                    \\n            return [a, b]\\n                    \\n    \\n        for target in queries:\\n            ans.append(binary_search(nums, target))\\n            \\n        return ans\\n        \\n```\\n**Upvote the post if you find it helpful.\\nHappy coding.**",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        nums = []\\n        def inorder(root):\\n            if root:\\n                inorder(root.left)\\n                nums.append(root.val)\\n                inorder(root.right)\\n        inorder(root)\\n        ans = []\\n        l = len(nums)\\n        \\n        def binary_search(nums, x):\\n            left, right = 0, l-1\\n            a = -1\\n            b = -1\\n            \\n            while left <= right:\\n                mid = (left + right) // 2\\n                \\n                if x==nums[mid]:\\n                    return [x, x]\\n                \\n                elif nums[mid]<x:\\n                    a = nums[mid]\\n                    left = mid+1\\n                \\n                else:\\n                    right = mid-1\\n                    \\n            \\n            left, right = 0, l-1\\n            b = -1\\n                \\n            while left <= right:\\n                mid = (left + right) // 2\\n                \\n                if nums[mid]>x:\\n                    b = nums[mid]\\n                    right = mid-1\\n                \\n                else:\\n                    left = mid+1\\n                    \\n            return [a, b]\\n                    \\n    \\n        for target in queries:\\n            ans.append(binary_search(nums, target))\\n            \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831784,
                "title": "java-simple-and-easy-approach-o-nlog-m",
                "content": "```\\n//Given queries.length == n\\n//let Nnumber of node in BST is m\\n//TC : O(n * log(m))\\nclass Solution {\\n    List<List<Integer>> res; //result arrayList\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        res = new ArrayList<>();\\n        for(int i = 0; i < queries.size(); ++i){\\n            int val = queries.get(i);\\n            floorCeilBSTHelper(root, val, Integer.MIN_VALUE, Integer.MAX_VALUE);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    //Iterative approach to find ceil and floor of val\\n    public void floorCeilBSTHelper(TreeNode root, int key, int floor, int ceil){ //TC : O(log(m))\\n        while (root != null) {\\n            if(root.val == key) {\\n                ceil = root.val;\\n                floor = root.val;\\n                break;\\n            }\\n \\n            if (key > root.val) {\\n                floor = root.val;\\n                root = root.right;\\n            }else {\\n                ceil = root.val;\\n                root = root.left;\\n            }\\n        }\\n        \\n        List<Integer> part = new ArrayList<>();\\n        if(floor != Integer.MIN_VALUE && ceil != Integer.MAX_VALUE){\\n            part.add(floor);\\n            part.add(ceil);\\n        }else if(floor != Integer.MIN_VALUE){\\n            part.add(floor);\\n            part.add(-1);\\n        }else{\\n            part.add(-1);\\n            part.add(ceil);\\n        }\\n        res.add(part);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "```\\n//Given queries.length == n\\n//let Nnumber of node in BST is m\\n//TC : O(n * log(m))\\nclass Solution {\\n    List<List<Integer>> res; //result arrayList\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        res = new ArrayList<>();\\n        for(int i = 0; i < queries.size(); ++i){\\n            int val = queries.get(i);\\n            floorCeilBSTHelper(root, val, Integer.MIN_VALUE, Integer.MAX_VALUE);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    //Iterative approach to find ceil and floor of val\\n    public void floorCeilBSTHelper(TreeNode root, int key, int floor, int ceil){ //TC : O(log(m))\\n        while (root != null) {\\n            if(root.val == key) {\\n                ceil = root.val;\\n                floor = root.val;\\n                break;\\n            }\\n \\n            if (key > root.val) {\\n                floor = root.val;\\n                root = root.right;\\n            }else {\\n                ceil = root.val;\\n                root = root.left;\\n            }\\n        }\\n        \\n        List<Integer> part = new ArrayList<>();\\n        if(floor != Integer.MIN_VALUE && ceil != Integer.MAX_VALUE){\\n            part.add(floor);\\n            part.add(ceil);\\n        }else if(floor != Integer.MIN_VALUE){\\n            part.add(floor);\\n            part.add(-1);\\n        }else{\\n            part.add(-1);\\n            part.add(ceil);\\n        }\\n        res.add(part);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831673,
                "title": "c-easy-binary-search-solution",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***<br>\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    int find1(vector<int>&a,int el){\\n        int start=0;\\n        int end=a.size()-1;\\n        int mid=(start+(end-start))/2;\\n        int ans=-1;\\n        \\n        while(start<=end){\\n            \\n            if(a[mid]==el)  {\\n                \\n               return a[mid];\\n            }\\n            else if(el>a[mid]){\\n                \\n                start=mid+1;\\n            }else{\\n                ans=a[mid];\\n                end=mid-1;\\n                \\n            }\\n            mid=start+(end-start)/2;\\n        }\\n        return ans;\\n    }\\n    int find2(vector<int>&a,int el){\\n        int start=0;\\n        int end=a.size()-1;\\n        int mid=start+(end-start)/2;\\n        int ans=-1;\\n        while(start<=end){\\n            \\n            \\n            if(a[mid]==el) return a[mid];\\n            else if(el>a[mid]){\\n                \\n                ans=a[mid];\\n                start=mid+1;\\n            }else{\\n                \\n                end=mid-1;\\n            }\\n            \\n            mid=start+(end-start)/2;\\n        }\\n       \\n        return ans;\\n    }\\npublic:\\n    void solve(vector<int>&ans,TreeNode* root){\\n        if(root==NULL) return;\\n        solve(ans,root->left);\\n        ans.push_back(root->val);\\n        solve(ans,root->right);\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int>ans;\\n        solve(ans,root);\\n        vector<vector<int>>closest;\\n        int mini=-1;\\n        int maxi=-1;\\n//         for(auto i :ans){\\n//             cout<<i<<\" \";\\n            \\n//         }\\n//         cout<<endl;\\n        for(int i=0;i<queries.size();i++){\\n            int el=queries[i];\\n            // cout<<find2(ans,el)<<\" \"<<find1(ans,el)<<endl;\\n            mini=find2(ans,el);\\n            maxi=find1(ans,el);\\n            closest.push_back({mini,maxi});\\n                \\n        }\\n        return closest;\\n    }\\n};\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***<br>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Search Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    int find1(vector<int>&a,int el){\\n        int start=0;\\n        int end=a.size()-1;\\n        int mid=(start+(end-start))/2;\\n        int ans=-1;\\n        \\n        while(start<=end){\\n            \\n            if(a[mid]==el)  {\\n                \\n               return a[mid];\\n            }\\n            else if(el>a[mid]){\\n                \\n                start=mid+1;\\n            }else{\\n                ans=a[mid];\\n                end=mid-1;\\n                \\n            }\\n            mid=start+(end-start)/2;\\n        }\\n        return ans;\\n    }\\n    int find2(vector<int>&a,int el){\\n        int start=0;\\n        int end=a.size()-1;\\n        int mid=start+(end-start)/2;\\n        int ans=-1;\\n        while(start<=end){\\n            \\n            \\n            if(a[mid]==el) return a[mid];\\n            else if(el>a[mid]){\\n                \\n                ans=a[mid];\\n                start=mid+1;\\n            }else{\\n                \\n                end=mid-1;\\n            }\\n            \\n            mid=start+(end-start)/2;\\n        }\\n       \\n        return ans;\\n    }\\npublic:\\n    void solve(vector<int>&ans,TreeNode* root){\\n        if(root==NULL) return;\\n        solve(ans,root->left);\\n        ans.push_back(root->val);\\n        solve(ans,root->right);\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int>ans;\\n        solve(ans,root);\\n        vector<vector<int>>closest;\\n        int mini=-1;\\n        int maxi=-1;\\n//         for(auto i :ans){\\n//             cout<<i<<\" \";\\n            \\n//         }\\n//         cout<<endl;\\n        for(int i=0;i<queries.size();i++){\\n            int el=queries[i];\\n            // cout<<find2(ans,el)<<\" \"<<find1(ans,el)<<endl;\\n            mini=find2(ans,el);\\n            maxi=find1(ans,el);\\n            closest.push_back({mini,maxi});\\n                \\n        }\\n        return closest;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4068648,
                "title": "easy-to-understand-beats-100-upvote-hashset",
                "content": "# Problem Description\\n\\nYou are given a binary search tree (BST) with distinct values and a list of integers `queries`. Your task is to find the two closest nodes in the BST to each integer in `queries` and return their values in a list. If there are multiple valid answers, return any of them.\\n\\n# Intuition\\n\\nThe problem involves finding the two closest nodes in a binary search tree to a given target value. The intuition here is to perform a pre-order traversal of the BST to create a sorted set of node values. Then, for each query, use the floor and ceiling functions of the sorted set to find the closest nodes.\\n\\n# Approach\\n\\nTo efficiently solve this problem, we can follow this approach:\\n1. Define a helper function `preorder` that performs a pre-order traversal of the BST and adds each node\\'s value to a `TreeSet` called `set`. This set will store the sorted values of the BST.\\n2. Initialize an empty list `result` to store the results for each query.\\n3. Use the `preorder` function to populate `set` with the sorted values of the BST.\\n4. For each target value in the `queries` list:\\n   - Initialize an empty list `closestNode` to store the values of the two closest nodes.\\n   - Use the `floor` method of `set` to find the largest value in the BST that is less than or equal to the target. If such a value exists, add it to `closestNode`; otherwise, add -1 to indicate no closest value.\\n   - Use the `ceiling` method of `set` to find the smallest value in the BST that is greater than or equal to the target. If such a value exists, add it to `closestNode`; otherwise, add -1 to indicate no closest value.\\n   - Add `closestNode` to the `result` list.\\n5. After processing all queries, return the `result` list containing the closest nodes for each query.\\n\\n# Complexity Analysis\\n\\n- Time complexity: O(n + k * log(n)), where `n` is the number of nodes in the BST, and `k` is the number of queries. We perform a pre-order traversal to create the sorted set (`O(n)`) and process each query (`O(k * log(n))`).\\n- Space complexity: O(n), as we use a `TreeSet` to store the values of the BST, which has a space complexity of O(n).\\n\\nThis efficient approach ensures that we find the closest nodes in the BST for each query.\\n\\nShare this clever solution with your fellow LeetCode enthusiasts and help them navigate the intricacies of BST traversal and set operations. Happy coding!\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    static TreeSet<Integer> preorder(TreeNode root,TreeSet<Integer> set){\\n        if(root == null) return set;\\n        set  = preorder(root.left, set);\\n        set.add(root.val);\\n        set  = preorder(root.right, set);\\n        return set;\\n    }\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n    List<List<Integer>> result = new ArrayList<>();\\n    TreeSet<Integer> set = new TreeSet<>();\\n  \\n    set = preorder(root, set);\\n    for (int target : queries) {\\n        List<Integer> closestNode = new ArrayList<>();\\n        if(set.floor(target)!=null){\\n                closestNode.add(set.floor(target));\\n        }\\n        else{\\n                closestNode.add(-1);\\n        }\\n        \\n        if(set.ceiling(target)!=null){\\n                closestNode.add(set.ceiling(target));\\n        }\\n        else{\\n                closestNode.add(-1);\\n        }\\n        result.add(closestNode);\\n    }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    static TreeSet<Integer> preorder(TreeNode root,TreeSet<Integer> set){\\n        if(root == null) return set;\\n        set  = preorder(root.left, set);\\n        set.add(root.val);\\n        set  = preorder(root.right, set);\\n        return set;\\n    }\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n    List<List<Integer>> result = new ArrayList<>();\\n    TreeSet<Integer> set = new TreeSet<>();\\n  \\n    set = preorder(root, set);\\n    for (int target : queries) {\\n        List<Integer> closestNode = new ArrayList<>();\\n        if(set.floor(target)!=null){\\n                closestNode.add(set.floor(target));\\n        }\\n        else{\\n                closestNode.add(-1);\\n        }\\n        \\n        if(set.ceiling(target)!=null){\\n                closestNode.add(set.ceiling(target));\\n        }\\n        else{\\n                closestNode.add(-1);\\n        }\\n        result.add(closestNode);\\n    }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923116,
                "title": "python-solution-beats-98-iterative-inorder-bisect",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given tree is a BST so traversing it in inorder will give sorted list of node values. and then searching for result.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Traverse tree in inorder and store values in a List(iterative for space complexity optimisation)\\n2. use bisect_left() function in bisect class to find the possible position of element in list.\\n3. add conditionals as per question requirement (Look at the code)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        stack, nodes = [], []\\n        def inorder(root):\\n            cur = root\\n            while cur or stack:\\n                while cur:\\n                    stack.append(cur)\\n                    cur = cur.left\\n                cur = stack.pop()\\n                nodes.append(cur.val)\\n                cur = cur.right\\n        inorder(root)\\n\\n        res = []\\n        for q in queries:\\n            idx = bisect.bisect_left(nodes, q)\\n            if 0 <= idx < len(nodes) and nodes[idx] == q:\\n                res.append([q,q])\\n            else:\\n                if idx > 0 and idx < len(nodes):\\n                    res.append([nodes[idx-1], nodes[idx]])\\n                elif idx <= 0:\\n                    res.append([-1, nodes[idx]])\\n                elif idx >= len(nodes):\\n                    res.append([nodes[idx-1], -1])\\n        return res \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        stack, nodes = [], []\\n        def inorder(root):\\n            cur = root\\n            while cur or stack:\\n                while cur:\\n                    stack.append(cur)\\n                    cur = cur.left\\n                cur = stack.pop()\\n                nodes.append(cur.val)\\n                cur = cur.right\\n        inorder(root)\\n\\n        res = []\\n        for q in queries:\\n            idx = bisect.bisect_left(nodes, q)\\n            if 0 <= idx < len(nodes) and nodes[idx] == q:\\n                res.append([q,q])\\n            else:\\n                if idx > 0 and idx < len(nodes):\\n                    res.append([nodes[idx-1], nodes[idx]])\\n                elif idx <= 0:\\n                    res.append([-1, nodes[idx]])\\n                elif idx >= len(nodes):\\n                    res.append([nodes[idx-1], -1])\\n        return res \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556738,
                "title": "c-easiest-lower-bound-only-inorder-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    void inorder(TreeNode* root , vector<int>& nums)\\n    {\\n        if(!root) return;\\n        \\n        inorder(root->left,nums);\\n        nums.push_back(root->val);\\n        inorder(root->right,nums);\\n    }   \\n    \\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int>nums;\\n        inorder(root,nums);\\n        \\n        vector<vector<int>>ans;\\n        int q=queries.size();\\n        for(int i=0; i<q ;i++)\\n        {\\n            int val = queries[i];\\n            int lb = lower_bound(nums.begin(),nums.end(),val) - nums.begin();\\n            int mini=-1, maxi=-1;\\n            \\n            if(lb == nums.size())\\n                mini=nums[lb-1];\\n            else\\n            {\\n                if(nums[lb] == val)\\n                {\\n                    mini=val;\\n                    maxi=val;\\n                }\\n                else\\n                {\\n                    if(lb>0) mini=nums[lb-1];\\n                    maxi = nums[lb];\\n                }\\n            }\\n            ans.push_back({mini,maxi});\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    void inorder(TreeNode* root , vector<int>& nums)\\n    {\\n        if(!root) return;\\n        \\n        inorder(root->left,nums);\\n        nums.push_back(root->val);\\n        inorder(root->right,nums);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3391606,
                "title": "neat-and-clean-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N)+q*O(log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int>in;\\n    void fun(TreeNode *root)\\n    {\\n        if(!root) return ;\\n        fun(root->left);\\n        in.push_back(root->val);\\n        fun(root->right);\\n    }\\n    void low(int &x,int k)\\n    {\\n        int l=0;\\n        int h=in.size()-1;\\n        while(h>=l)\\n        {\\n            int m=l+(h-l)/2;\\n            if(in[m]>k) h=m-1;\\n            else \\n            {\\n                x=in[m];\\n                l=m+1;\\n            }\\n        }\\n    }\\n     void upp(int &x,int k)\\n    {\\n        int l=0;\\n        int h=in.size()-1;\\n        while(h>=l)\\n        {\\n            int m=l+(h-l)/2;\\n            if(in[m]<k) l=m+1;\\n            else \\n            {\\n                x=in[m];\\n                h=m-1;\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        \\n        fun(root);\\n        vector<vector<int>> v;\\n        for(auto q:queries)\\n        {\\n            int x=-1;\\n            int y=-1;\\n            low(x,q);\\n            upp(y,q);\\n            v.push_back({x,y});\\n            \\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Binary Search Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int>in;\\n    void fun(TreeNode *root)\\n    {\\n        if(!root) return ;\\n        fun(root->left);\\n        in.push_back(root->val);\\n        fun(root->right);\\n    }\\n    void low(int &x,int k)\\n    {\\n        int l=0;\\n        int h=in.size()-1;\\n        while(h>=l)\\n        {\\n            int m=l+(h-l)/2;\\n            if(in[m]>k) h=m-1;\\n            else \\n            {\\n                x=in[m];\\n                l=m+1;\\n            }\\n        }\\n    }\\n     void upp(int &x,int k)\\n    {\\n        int l=0;\\n        int h=in.size()-1;\\n        while(h>=l)\\n        {\\n            int m=l+(h-l)/2;\\n            if(in[m]<k) l=m+1;\\n            else \\n            {\\n                x=in[m];\\n                h=m-1;\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        \\n        fun(root);\\n        vector<vector<int>> v;\\n        for(auto q:queries)\\n        {\\n            int x=-1;\\n            int y=-1;\\n            low(x,q);\\n            upp(y,q);\\n            v.push_back({x,y});\\n            \\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365884,
                "title": "closest-nodes-o-n-javascript-memory-25-45-meaningful-vars",
                "content": "```\\nvar inOrderTraversal = function (root, arr = []) {\\n  if (!root) {\\n    return\\n  }\\n  inOrderTraversal(root.left, arr)\\n  if (root.val) {\\n    arr.push(root.val)\\n  }\\n  inOrderTraversal(root.right, arr)\\n  return arr\\n}\\n\\nvar closestNodes = function (root, queries) {\\n  const output = {}\\n  const sortedTreeElements = inOrderTraversal(root)\\n  let sortedTreeElementsIndex = 0\\n  let sortedQueriesIndex = 0\\n\\n  const bucketSort = (function () {\\n    const maxNumber = Math.max(...queries)\\n    const arr = new Array(maxNumber)\\n    for (let index = 0; index < queries.length; index++) {\\n      if (arr[queries[index]] === undefined) {\\n        arr[queries[index]] = 0\\n      }\\n      arr[queries[index]] += 1\\n      console.log(arr[queries[index]])\\n    }\\n    let sortedArray = []\\n    for (let index = 0; index < arr.length; index++) {\\n      for (let indexTemp = 0; indexTemp < arr[index]; indexTemp++) {\\n        sortedArray.push(index)\\n      }\\n    }\\n    return sortedArray\\n  })()\\n  let lastElementOfSortedArray = -1\\n  while (bucketSort[sortedQueriesIndex] !== undefined) {\\n    const sortedQueriesElement = bucketSort[sortedQueriesIndex]\\n    const sortedTreeElement = sortedTreeElements[sortedTreeElementsIndex]\\n\\n    if (sortedTreeElement === undefined) {\\n      output[bucketSort[sortedQueriesIndex++]] = [\\n        lastElementOfSortedArray,\\n        -1,\\n      ]\\n      continue\\n    }\\n    if (output[bucketSort[sortedQueriesIndex]] === undefined) {\\n      output[bucketSort[sortedQueriesIndex]] = [lastElementOfSortedArray, -1]\\n    }\\n    if (sortedQueriesElement === sortedTreeElement) {\\n      output[bucketSort[sortedQueriesIndex]] = [\\n        sortedTreeElement,\\n        sortedTreeElement,\\n      ]\\n      sortedQueriesIndex++\\n    } else if (sortedQueriesElement < sortedTreeElement) {\\n      output[bucketSort[sortedQueriesIndex]][1] = sortedTreeElement\\n      sortedQueriesIndex++\\n    } else if (sortedQueriesElement > sortedTreeElement) {\\n      output[bucketSort[sortedQueriesIndex]][0] = sortedTreeElement\\n      lastElementOfSortedArray = sortedTreeElement\\n      sortedTreeElementsIndex++\\n    }\\n  }\\n  const finalOutput = []\\n  for (const iterator of queries) {\\n    finalOutput.push(output[iterator])\\n  }\\n  return finalOutput\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar inOrderTraversal = function (root, arr = []) {\\n  if (!root) {\\n    return\\n  }\\n  inOrderTraversal(root.left, arr)\\n  if (root.val) {\\n    arr.push(root.val)\\n  }\\n  inOrderTraversal(root.right, arr)\\n  return arr\\n}\\n\\nvar closestNodes = function (root, queries) {\\n  const output = {}\\n  const sortedTreeElements = inOrderTraversal(root)\\n  let sortedTreeElementsIndex = 0\\n  let sortedQueriesIndex = 0\\n\\n  const bucketSort = (function () {\\n    const maxNumber = Math.max(...queries)\\n    const arr = new Array(maxNumber)\\n    for (let index = 0; index < queries.length; index++) {\\n      if (arr[queries[index]] === undefined) {\\n        arr[queries[index]] = 0\\n      }\\n      arr[queries[index]] += 1\\n      console.log(arr[queries[index]])\\n    }\\n    let sortedArray = []\\n    for (let index = 0; index < arr.length; index++) {\\n      for (let indexTemp = 0; indexTemp < arr[index]; indexTemp++) {\\n        sortedArray.push(index)\\n      }\\n    }\\n    return sortedArray\\n  })()\\n  let lastElementOfSortedArray = -1\\n  while (bucketSort[sortedQueriesIndex] !== undefined) {\\n    const sortedQueriesElement = bucketSort[sortedQueriesIndex]\\n    const sortedTreeElement = sortedTreeElements[sortedTreeElementsIndex]\\n\\n    if (sortedTreeElement === undefined) {\\n      output[bucketSort[sortedQueriesIndex++]] = [\\n        lastElementOfSortedArray,\\n        -1,\\n      ]\\n      continue\\n    }\\n    if (output[bucketSort[sortedQueriesIndex]] === undefined) {\\n      output[bucketSort[sortedQueriesIndex]] = [lastElementOfSortedArray, -1]\\n    }\\n    if (sortedQueriesElement === sortedTreeElement) {\\n      output[bucketSort[sortedQueriesIndex]] = [\\n        sortedTreeElement,\\n        sortedTreeElement,\\n      ]\\n      sortedQueriesIndex++\\n    } else if (sortedQueriesElement < sortedTreeElement) {\\n      output[bucketSort[sortedQueriesIndex]][1] = sortedTreeElement\\n      sortedQueriesIndex++\\n    } else if (sortedQueriesElement > sortedTreeElement) {\\n      output[bucketSort[sortedQueriesIndex]][0] = sortedTreeElement\\n      lastElementOfSortedArray = sortedTreeElement\\n      sortedTreeElementsIndex++\\n    }\\n  }\\n  const finalOutput = []\\n  for (const iterator of queries) {\\n    finalOutput.push(output[iterator])\\n  }\\n  return finalOutput\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3042770,
                "title": "o-n-time-if-tree-is-unbalanced-o-k-space",
                "content": "# Approach\\nSort the query array and get rid of duplicates.\\nWe can now do a depth-first search, and using a binary search on an array of sorted queries, we can determine a subarray of queries whose limits (smaller and bigger node values) can be found in the subtree (left or right).\\nPut results in a map and then restore original queries order accoring original queris array.\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n)$$ if tree is unbalanced where k is a queries size, n is number of nodes in the tree. \\nWhy? because on every tree level we do (j * log k/(2 pow j)) binary searches. But we are not able to do more then k log k searches in total. We skip search step, or we divide search are in two smaller groups. If tree is unbalanced and n is much bigger then klogk, then overall complexity is O(n). In other case is n is small and k is much bigger, then time coplexity is klogk.\\n\\nPlease, correct me if i\\'m mistaken.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(k)$$ where k is a queries size\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    Map<Integer, List<Integer>> resultMap = new HashMap<>();\\n\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        var queriesCopy = new ArrayList<>(new HashSet<>(queries));\\n        var result = new ArrayList<List<Integer>>();\\n        Collections.sort(queriesCopy);\\n        findNode(root, queriesCopy, Integer.MIN_VALUE, Integer.MAX_VALUE, 0, queriesCopy.size() - 1);\\n        for (Integer query : queries) {\\n            result.add(resultMap.get(query));\\n        }\\n        return result;\\n    }\\n\\n    private void findNode(TreeNode node, List<Integer> queries, int min, int max, int left, int right) {\\n        if (left > right) return;\\n        if (node == null) {\\n            if (min == Integer.MIN_VALUE) min = -1;\\n            if (max == Integer.MAX_VALUE) max = -1;\\n            var res = List.of(min, max);\\n            for (int i = left; i <= right; i++) {\\n                resultMap.put(queries.get(i), res);\\n            }\\n            return;\\n        }\\n        int searchIndex = binarySearch(queries, node.val, left, right);\\n        if (searchIndex == left - 1) {\\n            findNode(node.right, queries, node.val, max, left, right);\\n            return;\\n        }\\n        if (searchIndex == right + 1) {\\n            findNode(node.left, queries, min, node.val, left, right);\\n            return;\\n        }\\n        var searchIndexValue = queries.get(searchIndex);\\n        if (searchIndexValue != node.val) {\\n            findNode(node.left, queries, min, node.val, left, searchIndex - 1);\\n            findNode(node.right, queries, node.val, max, searchIndex, right);\\n        } else {\\n            resultMap.put(searchIndexValue, List.of(node.val, node.val));\\n            findNode(node.left, queries, min, node.val, left, searchIndex - 1);\\n            findNode(node.right, queries, node.val, max, searchIndex + 1, right);\\n        }\\n    }\\n\\n    private int binarySearch(List<Integer> list, int target, int l, int r) {\\n        if (target < list.get(l)) {\\n            return l - 1;\\n        }\\n        if (target > list.get(r)) {\\n            return r + 1;\\n        }\\n        while (l < r) {\\n            int m = l + (r - l) / 2;\\n            if (list.get(m) >= target) {\\n                r = m;\\n            } else {\\n                l = m + 1;\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Binary Search",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    Map<Integer, List<Integer>> resultMap = new HashMap<>();\\n\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        var queriesCopy = new ArrayList<>(new HashSet<>(queries));\\n        var result = new ArrayList<List<Integer>>();\\n        Collections.sort(queriesCopy);\\n        findNode(root, queriesCopy, Integer.MIN_VALUE, Integer.MAX_VALUE, 0, queriesCopy.size() - 1);\\n        for (Integer query : queries) {\\n            result.add(resultMap.get(query));\\n        }\\n        return result;\\n    }\\n\\n    private void findNode(TreeNode node, List<Integer> queries, int min, int max, int left, int right) {\\n        if (left > right) return;\\n        if (node == null) {\\n            if (min == Integer.MIN_VALUE) min = -1;\\n            if (max == Integer.MAX_VALUE) max = -1;\\n            var res = List.of(min, max);\\n            for (int i = left; i <= right; i++) {\\n                resultMap.put(queries.get(i), res);\\n            }\\n            return;\\n        }\\n        int searchIndex = binarySearch(queries, node.val, left, right);\\n        if (searchIndex == left - 1) {\\n            findNode(node.right, queries, node.val, max, left, right);\\n            return;\\n        }\\n        if (searchIndex == right + 1) {\\n            findNode(node.left, queries, min, node.val, left, right);\\n            return;\\n        }\\n        var searchIndexValue = queries.get(searchIndex);\\n        if (searchIndexValue != node.val) {\\n            findNode(node.left, queries, min, node.val, left, searchIndex - 1);\\n            findNode(node.right, queries, node.val, max, searchIndex, right);\\n        } else {\\n            resultMap.put(searchIndexValue, List.of(node.val, node.val));\\n            findNode(node.left, queries, min, node.val, left, searchIndex - 1);\\n            findNode(node.right, queries, node.val, max, searchIndex + 1, right);\\n        }\\n    }\\n\\n    private int binarySearch(List<Integer> list, int target, int l, int r) {\\n        if (target < list.get(l)) {\\n            return l - 1;\\n        }\\n        if (target > list.get(r)) {\\n            return r + 1;\\n        }\\n        while (l < r) {\\n            int m = l + (r - l) / 2;\\n            if (list.get(m) >= target) {\\n                r = m;\\n            } else {\\n                l = m + 1;\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2896781,
                "title": "cpp-must-see-inorder-binary-search",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\t//this vector<int> will contain the sorted order || inorder of the bst\\n\\tvector<int>v;\\n\\tvector<vector<int>>ans;\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) \\n\\t{\\n         //first we will find the inorder of the bst that will be sorted only\\n         inorder(root);\\n\\n         for(int i=0;i<queries.size();i++)\\n         {\\n         \\tint target = queries[i];\\n         \\t\\n         \\tint start = 0;\\n         \\tint end = v.size()-1;\\n         \\tbool found = false;\\n         \\t\\n         \\twhile(start <= end)\\n         \\t{\\n         \\t   int mid = (start + end) / 2;\\t\\n         \\t   \\n         \\t   if(v[mid] == target)\\n         \\t   {\\n         \\t   \\t ans.push_back({target,target});\\n         \\t   \\t found = true;\\n                 break;\\n               }\\n               else if(target > v[mid])\\n               {\\n               \\t  //target must lie in the right hand side of the mid\\n               \\t  start = mid+1;\\n\\t\\t\\t   }\\n\\t\\t\\t   else if(target < v[mid])\\n\\t\\t\\t   {\\n  \\t              end = mid-1;\\n\\t\\t\\t   }\\n            }\\n            if(found == false)\\n            {\\n            \\t//start must be poiintng to the bigger element of the query\\n            \\tvector<int>temp;\\n            \\tif(end >= 0)\\n            \\t{\\n            \\t\\ttemp.push_back(v[end]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp.push_back(-1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n            \\tif(start < v.size())\\n            \\t{\\n            \\t     temp.push_back(v[start]);\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t temp.push_back(-1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans.push_back(temp);\\n\\t\\t\\t}\\n\\t\\t }\\n         return ans;\\n    }\\n    //inorder is left root and right\\n    void inorder(TreeNode* root)\\n    {\\n    \\tif(root == NULL)\\n    \\treturn;\\n    \\t\\n    \\tinorder(root->left);\\n    \\tv.push_back(root->val);\\n    \\tinorder(root->right);\\n\\t}\\n    // 1 2 4 6 9 13 14 15 \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\t//this vector<int> will contain the sorted order || inorder of the bst\\n\\tvector<int>v;\\n\\tvector<vector<int>>ans;\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) \\n\\t{\\n         //first we will find the inorder of the bst that will be sorted only\\n         inorder(root);\\n\\n         for(int i=0;i<queries.size();i++)\\n         {\\n         \\tint target = queries[i];\\n         \\t\\n         \\tint start = 0;\\n         \\tint end = v.size()-1;\\n         \\tbool found = false;\\n         \\t\\n         \\twhile(start <= end)\\n         \\t{\\n         \\t   int mid = (start + end) / 2;\\t\\n         \\t   \\n         \\t   if(v[mid] == target)\\n         \\t   {\\n         \\t   \\t ans.push_back({target,target});\\n         \\t   \\t found = true;\\n                 break;\\n               }\\n               else if(target > v[mid])\\n               {\\n               \\t  //target must lie in the right hand side of the mid\\n               \\t  start = mid+1;\\n\\t\\t\\t   }\\n\\t\\t\\t   else if(target < v[mid])\\n\\t\\t\\t   {\\n  \\t              end = mid-1;\\n\\t\\t\\t   }\\n            }\\n            if(found == false)\\n            {\\n            \\t//start must be poiintng to the bigger element of the query\\n            \\tvector<int>temp;\\n            \\tif(end >= 0)\\n            \\t{\\n            \\t\\ttemp.push_back(v[end]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp.push_back(-1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n            \\tif(start < v.size())\\n            \\t{\\n            \\t     temp.push_back(v[start]);\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t temp.push_back(-1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans.push_back(temp);\\n\\t\\t\\t}\\n\\t\\t }\\n         return ans;\\n    }\\n    //inorder is left root and right\\n    void inorder(TreeNode* root)\\n    {\\n    \\tif(root == NULL)\\n    \\treturn;\\n    \\t\\n    \\tinorder(root->left);\\n    \\tv.push_back(root->val);\\n    \\tinorder(root->right);\\n\\t}\\n    // 1 2 4 6 9 13 14 15 \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2836960,
                "title": "c-solution-in-order-traversal-binary-search-100-faster-solution",
                "content": "![image](https://assets.leetcode.com/users/images/2005225a-14ac-43ad-b273-d2b2536b5150_1669053876.925698.png)\\n\\n**We are given binary search tree, so we will do inorder traversal to get sorted array.\\nThen we will use binary search to get min and max for each query**\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,vector<ll>&in){\\n        if(root==NULL){\\n            return;\\n        }\\n        inorder(root->left,in);\\n        in.push_back(root->val);\\n        inorder(root->right,in);\\n    }\\n    \\n    int findminn(vector<ll>&in,ll num){\\n        ll i=0,j=in.size()-1;\\n        ll ans=-1;\\n        while(i<=j){\\n            ll m=i+((j-i)>>1);\\n            if(in[m]>num){\\n                j=m-1;\\n            }\\n            else if(in[m]==num){\\n                return in[m];\\n            }\\n            else{\\n                ans=in[m];\\n                i=m+1;\\n            }\\n        }\\n        return ans; \\n    } \\n    \\n    int findmaxx(vector<ll>&in,ll num){\\n        ll i=0, j=in.size()-1;\\n        int ans=-1;\\n        while(i<=j){\\n            ll m=i+((j-i)>>1);\\n            if(in[m]<num){\\n                i=m+1;\\n            }\\n            else if(in[m]==num){\\n                return in[m];\\n            }\\n            else{\\n                ans=in[m];\\n                j=m-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<ll>in;\\n        inorder(root,in);\\n        vector<vector<int>> ans;\\n        for(ll i=0;i<queries.size();i++){\\n            int minn=findminn(in,queries[i]);\\n            int maxx=findmaxx(in,queries[i]);\\n            ans.push_back({minn,maxx});            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,vector<ll>&in){\\n        if(root==NULL){\\n            return;\\n        }\\n        inorder(root->left,in);\\n        in.push_back(root->val);\\n        inorder(root->right,in);\\n    }\\n    \\n    int findminn(vector<ll>&in,ll num){\\n        ll i=0,j=in.size()-1;\\n        ll ans=-1;\\n        while(i<=j){\\n            ll m=i+((j-i)>>1);\\n            if(in[m]>num){\\n                j=m-1;\\n            }\\n            else if(in[m]==num){\\n                return in[m];\\n            }\\n            else{\\n                ans=in[m];\\n                i=m+1;\\n            }\\n        }\\n        return ans; \\n    } \\n    \\n    int findmaxx(vector<ll>&in,ll num){\\n        ll i=0, j=in.size()-1;\\n        int ans=-1;\\n        while(i<=j){\\n            ll m=i+((j-i)>>1);\\n            if(in[m]<num){\\n                i=m+1;\\n            }\\n            else if(in[m]==num){\\n                return in[m];\\n            }\\n            else{\\n                ans=in[m];\\n                j=m-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<ll>in;\\n        inorder(root,in);\\n        vector<vector<int>> ans;\\n        for(ll i=0;i<queries.size();i++){\\n            int minn=findminn(in,queries[i]);\\n            int maxx=findmaxx(in,queries[i]);\\n            ans.push_back({minn,maxx});            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2836397,
                "title": "why-tle-came-fixed-clean-code-with-explaination-tree-is-not-balanced",
                "content": "\\n**Approach 1**\\n* See once we see this ques the thing kicks to our mind is lowerbound and upperbound.\\n* But its bit tricky and confusing\\n* lower_bound(k) gives immediate next ele>=k\\n* upper_bound(k) gives immediate next ele > k\\n* QUES Asks:\\n\\t* Mini = Largest Ele <= k that is immediate next ele <= k. (NOT LOWER BOUND)\\n\\t* Maxi = Smallest Ele >= k that is immediate next ele >= k (NOT UPPPER BOUND)\\n* So how to solve?\\n\\t\\t* First of all if u find the query ele q in the inorder list\\n\\t\\t* then q is the mini and maxi\\n\\t\\t* When NOT Found\\n\\t\\t* Mini is prev to LOWER BOUND. HOW?\\n\\t\\t* Lower bound gives ele immediate > or = to k\\n\\t\\t* eg: 1 4 5 6 9 9. k=4 it gives 4, k=7 it gives 1st 9. But we need 6.\\n\\t\\t* That is nothing but the prev. SIMPLE Obeservation.\\n\\t\\t* so do LOWERBOUND and do --.\\n\\t\\t* Maxi is IMMEDIATE GUY > = K\\n\\t\\t* Upperbound gives IMMEDIATE GUY > k, as we checked for =to already. ITS PERFECT.\\n\\t\\t* Maxi = Upperbound when ele not found.\\n\\nTHATS it. Problem is DONE. \\n**Time and Space:**\\n1. time = O(q* logN) + O(N) = **O(N)** Asymptotically  As Log N to do lower, upper bounds and bin search for every query, then N is for that inorder we did.\\n2. space = O(N) = inorder array created extra\\n\\n**CODE:**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void inorder(vector<int>&inord, TreeNode* root){\\n        if(root == NULL){\\n            return;\\n        }\\n        inorder(inord, root->left);\\n        inord.push_back(root->val);\\n        inorder(inord, root->right);\\n    }\\n    \\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        \\n        vector<vector<int>> ans;\\n        //BST Inorder - sorted array\\n        vector<int> inord;\\n        inorder(inord, root);\\n        int N = inord.size();\\n        \\n        for(int q : queries){\\n            int mini, maxi;\\n            mini = maxi = -1;\\n            if(binary_search(inord.begin(), inord.end(), q)){\\n                maxi = mini = q;\\n            }\\n            else{\\n                if(q >= inord[0]){\\n                    mini = lower_bound(inord.begin(), inord.end(), q) - inord.begin();\\n                    mini--;\\n                    if(mini>=0) mini = inord[mini];\\n                }\\n                if(q < inord[N-1]){\\n                    maxi = upper_bound(inord.begin(), inord.end(), q) - inord.begin();\\n                    maxi = inord[maxi];\\n                }\\n            }\\n            \\n            ans.push_back({mini,maxi});\\n        }\\n        \\n       return ans;\\n    }\\n};\\n```\\n\\n**Approach2:**\\n**Thinking that we can optimize further more, i thought why are  we wasting that extra O(N) Space for the array. Lets use BST itself to find element in O(h)**\\n```\\n/*\\nTime is O(q*LogN ) what u think\\nO(q*N) what it is\\nSpace O(1)\\n*/\\n\\nclass Solution {\\npublic:\\n    \\n    int mini(TreeNode* root, int K){\\n        //largest ele <= K\\n        int ans = -1;\\n        \\n        while(root!=NULL){\\n            \\n            if(root->val == K){\\n                ans = K;\\n                break;\\n            }\\n            else if(root->val > K){\\n                //search for smaller guy\\n                root = root->left;\\n            }\\n            else{\\n                //serach for larger guy\\n                ans = root->val; // possible ans\\n                //still we continue as we check\\n                //is there a larger small val\\n                root = root->right;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int maxi(TreeNode* root, int K){\\n        //smallest ele >= K\\n        int ans = -1;\\n        \\n        while(root!=NULL){\\n            \\n            if(root->val == K){\\n                ans = K;\\n                break;\\n            }\\n            else if(root->val > K){\\n                //search for smaller guy\\n                ans = root->val; // possible ans\\n                //still we continue as we check\\n                //is there a smaller greater val\\n                root = root->left;\\n            }\\n            else{\\n                //serach for larger guy\\n                root = root->right;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    \\n    \\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        \\n        vector<vector<int>> ans;\\n        \\n        for(int q : queries){\\n            int mi = mini(root,q);\\n            int ma = maxi(root,q);\\n            \\n            ans.push_back({mi,ma});\\n        }\\n        \\n       return ans;\\n    }\\n};\\n```\\n\\n* It gives TLE bcoz, there is a testcase https://leetcode.com/submissions/detail/847739544/testcase/\\n* This gives us TLE\\n* Now how u will ask - O(h) is the BST Time complexity\\n* No where in the ques it is mentioned that the BST is balanced.\\n* The tree can be skewed also, means all nodes are in right or left only.\\n* So finding element directly in the BST now becomes O(N) at worst.\\n* So overall TC O(q*N)\\n* Whereas if u do inorder and then do lower and upper bound then\\n* TC O(N) + O(q*logN)\\n* q can go at max N\\n* So this is O(N^2) the old one is O(NLogN)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void inorder(vector<int>&inord, TreeNode* root){\\n        if(root == NULL){\\n            return;\\n        }\\n        inorder(inord, root->left);\\n        inord.push_back(root->val);\\n        inorder(inord, root->right);\\n    }\\n    \\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        \\n        vector<vector<int>> ans;\\n        //BST Inorder - sorted array\\n        vector<int> inord;\\n        inorder(inord, root);\\n        int N = inord.size();\\n        \\n        for(int q : queries){\\n            int mini, maxi;\\n            mini = maxi = -1;\\n            if(binary_search(inord.begin(), inord.end(), q)){\\n                maxi = mini = q;\\n            }\\n            else{\\n                if(q >= inord[0]){\\n                    mini = lower_bound(inord.begin(), inord.end(), q) - inord.begin();\\n                    mini--;\\n                    if(mini>=0) mini = inord[mini];\\n                }\\n                if(q < inord[N-1]){\\n                    maxi = upper_bound(inord.begin(), inord.end(), q) - inord.begin();\\n                    maxi = inord[maxi];\\n                }\\n            }\\n            \\n            ans.push_back({mini,maxi});\\n        }\\n        \\n       return ans;\\n    }\\n};\\n```\n```\\n/*\\nTime is O(q*LogN ) what u think\\nO(q*N) what it is\\nSpace O(1)\\n*/\\n\\nclass Solution {\\npublic:\\n    \\n    int mini(TreeNode* root, int K){\\n        //largest ele <= K\\n        int ans = -1;\\n        \\n        while(root!=NULL){\\n            \\n            if(root->val == K){\\n                ans = K;\\n                break;\\n            }\\n            else if(root->val > K){\\n                //search for smaller guy\\n                root = root->left;\\n            }\\n            else{\\n                //serach for larger guy\\n                ans = root->val; // possible ans\\n                //still we continue as we check\\n                //is there a larger small val\\n                root = root->right;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int maxi(TreeNode* root, int K){\\n        //smallest ele >= K\\n        int ans = -1;\\n        \\n        while(root!=NULL){\\n            \\n            if(root->val == K){\\n                ans = K;\\n                break;\\n            }\\n            else if(root->val > K){\\n                //search for smaller guy\\n                ans = root->val; // possible ans\\n                //still we continue as we check\\n                //is there a smaller greater val\\n                root = root->left;\\n            }\\n            else{\\n                //serach for larger guy\\n                root = root->right;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    \\n    \\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        \\n        vector<vector<int>> ans;\\n        \\n        for(int q : queries){\\n            int mi = mini(root,q);\\n            int ma = maxi(root,q);\\n            \\n            ans.push_back({mi,ma});\\n        }\\n        \\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833928,
                "title": "easy-c-solution-binary-search-implemented",
                "content": "Here is my C++ solution :-\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n \\nclass Solution {\\npublic:\\n        void dfs(TreeNode* root, vector<int>& bv){\\n            if (root==NULL)return;\\n            if (root->left)dfs(root->left,bv);\\n            bv.push_back(root->val);\\n            if (root->right)dfs(root->right,bv);\\n        }\\n\\t\\t\\n        int min1(vector<int>& bv, int val){\\n            int ans= -1;\\n            int i=0; int j= bv.size()-1;\\n            while (i<=j){\\n                int mid= i+ (j-i)/2;\\n                if (val== bv[mid])return val;\\n                if (val> bv[mid]){\\n                    ans= bv[mid];\\n                    i= mid+1;\\n                }\\n                else j= mid-1;\\n            }\\n            return ans;\\n        }\\n\\t\\t\\n    int max1(vector<int>& bv,int val){\\n        int ans= -1;\\n        int i=0; int j= bv.size()-1;\\n        while (i<=j){\\n            int mid= i+ (j-i)/2;\\n            if (val== bv[mid])return val;\\n            if (val < bv[mid]){\\n                ans= bv[mid];\\n                j= mid-1;\\n            }\\n            else i= mid+1;\\n        }\\n        return ans;\\n    }\\n\\t\\n        vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int> bv;\\n        vector<vector<int>> ans;\\n        //dfs se sorted list banate hai.\\n        dfs(root,bv);\\n        for (auto q: queries){\\n            int lb= min1(bv,q);\\n            int ub= max1(bv,q);\\n            ans.push_back({lb,ub});\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n \\nclass Solution {\\npublic:\\n        void dfs(TreeNode* root, vector<int>& bv){\\n            if (root==NULL)return;\\n            if (root->left)dfs(root->left,bv);\\n            bv.push_back(root->val);\\n            if (root->right)dfs(root->right,bv);\\n        }\\n\\t\\t\\n        int min1(vector<int>& bv, int val){\\n            int ans= -1;\\n            int i=0; int j= bv.size()-1;\\n            while (i<=j){\\n                int mid= i+ (j-i)/2;\\n                if (val== bv[mid])return val;\\n                if (val> bv[mid]){\\n                    ans= bv[mid];\\n                    i= mid+1;\\n                }\\n                else j= mid-1;\\n            }\\n            return ans;\\n        }\\n\\t\\t\\n    int max1(vector<int>& bv,int val){\\n        int ans= -1;\\n        int i=0; int j= bv.size()-1;\\n        while (i<=j){\\n            int mid= i+ (j-i)/2;\\n            if (val== bv[mid])return val;\\n            if (val < bv[mid]){\\n                ans= bv[mid];\\n                j= mid-1;\\n            }\\n            else i= mid+1;\\n        }\\n        return ans;\\n    }\\n\\t\\n        vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int> bv;\\n        vector<vector<int>> ans;\\n        //dfs se sorted list banate hai.\\n        dfs(root,bv);\\n        for (auto q: queries){\\n            int lb= min1(bv,q);\\n            int ub= max1(bv,q);\\n            ans.push_back({lb,ub});\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833927,
                "title": "easy-c-solution-binary-search-o-nlogn",
                "content": "\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        set<int>s;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int l=q.size(),i;\\n            for(i=0;i<l;i++){\\n                s.insert(q.front()->val);\\n                if(q.front()->left)\\n                    q.push(q.front()->left);\\n                if(q.front()->right)\\n                    q.push(q.front()->right);\\n                q.pop();\\n            }\\n        }\\n        int n=queries.size(),a,b;\\n        vector<vector<int>>ans;\\n        for(int i=0;i<n;i++){\\n            a=b=-1;\\n            auto it=s.lower_bound(queries[i]);\\n            if(it!=s.end())\\n                b=*it;\\n            if(*it==queries[i]) a=*it;\\n            else if(it!=s.begin()) it--,a=*it;\\n            ans.push_back({a,b});\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        set<int>s;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int l=q.size(),i;\\n            for(i=0;i<l;i++){\\n                s.insert(q.front()->val);\\n                if(q.front()->left)\\n                    q.push(q.front()->left);\\n                if(q.front()->right)\\n                    q.push(q.front()->right);\\n                q.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2833550,
                "title": "easy-solution-using-c-ceil-floor",
                "content": "```\\n  vector<int> helper(TreeNode* root,int key){\\n        TreeNode* curr=root;\\n        TreeNode* mini=NULL;\\n        TreeNode* maxi=NULL;\\n        vector<int>vt;\\n        while(curr){\\n            if(curr->val==key){\\n                mini=curr;\\n                maxi=curr;\\n                break;\\n            }\\n            else if(curr->val<key){\\n                mini=curr;\\n                curr=curr->right;\\n            }\\n            else{\\n                maxi=curr;\\n                curr=curr->left;\\n            }\\n        }\\n        //vt.push_back({mini,maxi});\\n        vt.push_back(mini!=NULL?mini->val:-1);\\n         vt.push_back(maxi!=NULL?maxi->val:-1);\\n        return vt;\\n    }\\npublic:\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n      vector<vector<int>>vt;\\n        int n=queries.size();\\n        for(int i=0;i<n;i++){\\n           vt.push_back(helper(root,queries[i]));\\n        }\\n        return vt;\\n    }",
                "solutionTags": [],
                "code": "```\\n  vector<int> helper(TreeNode* root,int key){\\n        TreeNode* curr=root;\\n        TreeNode* mini=NULL;\\n        TreeNode* maxi=NULL;\\n        vector<int>vt;\\n        while(curr){\\n            if(curr->val==key){\\n                mini=curr;\\n                maxi=curr;\\n                break;\\n            }\\n            else if(curr->val<key){\\n                mini=curr;\\n                curr=curr->right;\\n            }\\n            else{\\n                maxi=curr;\\n                curr=curr->left;\\n            }\\n        }\\n        //vt.push_back({mini,maxi});\\n        vt.push_back(mini!=NULL?mini->val:-1);\\n         vt.push_back(maxi!=NULL?maxi->val:-1);\\n        return vt;\\n    }\\npublic:\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n      vector<vector<int>>vt;\\n        int n=queries.size();\\n        for(int i=0;i<n;i++){\\n           vt.push_back(helper(root,queries[i]));\\n        }\\n        return vt;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2832910,
                "title": "easy-c-solution-binary-search-lower-bound",
                "content": "Here is my C++ Solution :-\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n        void dfs(TreeNode* root, vector<int>& bv){\\n            if (root==NULL)return;\\n            if (root->left)dfs(root->left,bv);\\n            bv.push_back(root->val);\\n            if (root->right)dfs(root->right,bv);\\n        }\\n        vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int> bv;\\n        vector<vector<int>> ans;\\n        //dfs se sorted list banate hai.\\n        dfs(root,bv);\\n        // sorted list se upper lower bound find karte ahi.\\n        for (auto q: queries){\\n            int lb= lower_bound(bv.begin(),bv.end(),q)-bv.begin();\\n            if (lb== bv.size())lb= bv[bv.size()-1];\\n            else{\\n                if (bv[lb]!=q){\\n                    if (lb!=0)\\n                    lb= bv[lb-1];\\n                    else lb= -1;\\n                }\\n                else lb= bv[lb];\\n            }\\n            \\n            int ub= lower_bound(bv.begin(),bv.end(),q)-bv.begin();\\n            if (ub==bv.size())ub= -1;\\n            else {\\n                ub= bv[ub];\\n            }\\n            ans.push_back({lb,ub});\\n        }\\n            \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n        void dfs(TreeNode* root, vector<int>& bv){\\n            if (root==NULL)return;\\n            if (root->left)dfs(root->left,bv);\\n            bv.push_back(root->val);\\n            if (root->right)dfs(root->right,bv);\\n        }\\n        vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int> bv;\\n        vector<vector<int>> ans;\\n        //dfs se sorted list banate hai.\\n        dfs(root,bv);\\n        // sorted list se upper lower bound find karte ahi.\\n        for (auto q: queries){\\n            int lb= lower_bound(bv.begin(),bv.end(),q)-bv.begin();\\n            if (lb== bv.size())lb= bv[bv.size()-1];\\n            else{\\n                if (bv[lb]!=q){\\n                    if (lb!=0)\\n                    lb= bv[lb-1];\\n                    else lb= -1;\\n                }\\n                else lb= bv[lb];\\n            }\\n            \\n            int ub= lower_bound(bv.begin(),bv.end(),q)-bv.begin();\\n            if (ub==bv.size())ub= -1;\\n            else {\\n                ub= bv[ub];\\n            }\\n            ans.push_back({lb,ub});\\n        }\\n            \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832305,
                "title": "very-easy-c-binary-search-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> arr;\\n    void traverse(TreeNode* root){\\n        if (root==NULL) return;\\n        traverse (root->left);\\n        arr.push_back(root->val); \\n        traverse(root->right); \\n        }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<vector<int>> ans;\\n        traverse (root);\\n        for ( auto i : queries) {\\n            long long left =0; \\n           long long right = arr.size()-1; \\n            long long m=-1;\\n            while ( left<=right) {\\n               long long mid = (left+(right-left)/2);\\n                \\n                if (arr[mid] == i) {\\n                  m=mid;  \\n                  break;\\n                  \\n                }\\n                if (arr[mid] < i) {\\n                    m= mid;\\n                    left = mid +1;\\n                }\\n                else {\\n                    right = mid-1; \\n                }\\n            }\\n            \\n            if (m!=-1 && arr[m] ==i) {\\n               ans.push_back({i,i});\\n            }\\n            else {\\n                \\n                if ( m== -1) {\\n                  ans.push_back({-1,arr[0]});\\n                }\\n                else if(m ==arr.size()-1) {\\n                   ans.push_back({arr[m],-1});\\n                }\\n                else {\\n                   ans.push_back({arr[m],arr[m+1]});\\n                }\\n                \\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> arr;\\n    void traverse(TreeNode* root){\\n        if (root==NULL) return;\\n        traverse (root->left);\\n        arr.push_back(root->val); \\n        traverse(root->right); \\n        }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<vector<int>> ans;\\n        traverse (root);\\n        for ( auto i : queries) {\\n            long long left =0; \\n           long long right = arr.size()-1; \\n            long long m=-1;\\n            while ( left<=right) {\\n               long long mid = (left+(right-left)/2);\\n                \\n                if (arr[mid] == i) {\\n                  m=mid;  \\n                  break;\\n                  \\n                }\\n                if (arr[mid] < i) {\\n                    m= mid;\\n                    left = mid +1;\\n                }\\n                else {\\n                    right = mid-1; \\n                }\\n            }\\n            \\n            if (m!=-1 && arr[m] ==i) {\\n               ans.push_back({i,i});\\n            }\\n            else {\\n                \\n                if ( m== -1) {\\n                  ans.push_back({-1,arr[0]});\\n                }\\n                else if(m ==arr.size()-1) {\\n                   ans.push_back({arr[m],-1});\\n                }\\n                else {\\n                   ans.push_back({arr[m],arr[m+1]});\\n                }\\n                \\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832154,
                "title": "javascript-o-nlogn-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number[]} queries\\n * @return {number[][]}\\n */\\n\\n\\nvar closestNodes = function(root, queries) {\\n    const res = []\\n    const queue = [root]\\n    const treeArr = []\\n    \\n\\t//  convert tree into a sorted array with every node value\\n\\t// O(N)\\n    while(queue.length) {\\n        const node = queue.shift()\\n        treeArr.push(node.val)\\n        if (node.left) queue.push(node.left)\\n        if (node.right) queue.push(node.right)\\n    }\\n    treeArr.sort((a, b) => a - b)\\n\\t\\n    // find the min and max value of a single query using binary search\\n\\t// O(logN)\\n    const search = (query) => {\\n        let min = -Infinity\\n        let max = Infinity\\n        let l = 0\\n        let r = treeArr.length - 1\\n        while(l <= r) {\\n            const mid = Math.floor((l+r)/2)\\n            \\n            if (query > treeArr[mid]) {\\n                min = treeArr[mid]\\n                l = mid + 1\\n            } else if (query < treeArr[mid]) {\\n                max = treeArr[mid]\\n                r = mid - 1\\n            } else {\\n                min = max = treeArr[mid]\\n                break\\n            }\\n        }\\n        \\n        res.push([min === -Infinity ? -1 : min, max === Infinity ? -1 : max])\\n    }\\n    \\n    for(let q of queries) {\\n        search(q)\\n    }\\n    \\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number[]} queries\\n * @return {number[][]}\\n */\\n\\n\\nvar closestNodes = function(root, queries) {\\n    const res = []\\n    const queue = [root]\\n    const treeArr = []\\n    \\n\\t//  convert tree into a sorted array with every node value\\n\\t// O(N)\\n    while(queue.length) {\\n        const node = queue.shift()\\n        treeArr.push(node.val)\\n        if (node.left) queue.push(node.left)\\n        if (node.right) queue.push(node.right)\\n    }\\n    treeArr.sort((a, b) => a - b)\\n\\t\\n    // find the min and max value of a single query using binary search\\n\\t// O(logN)\\n    const search = (query) => {\\n        let min = -Infinity\\n        let max = Infinity\\n        let l = 0\\n        let r = treeArr.length - 1\\n        while(l <= r) {\\n            const mid = Math.floor((l+r)/2)\\n            \\n            if (query > treeArr[mid]) {\\n                min = treeArr[mid]\\n                l = mid + 1\\n            } else if (query < treeArr[mid]) {\\n                max = treeArr[mid]\\n                r = mid - 1\\n            } else {\\n                min = max = treeArr[mid]\\n                break\\n            }\\n        }\\n        \\n        res.push([min === -Infinity ? -1 : min, max === Infinity ? -1 : max])\\n    }\\n    \\n    for(let q of queries) {\\n        search(q)\\n    }\\n    \\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2832110,
                "title": "simple-binary-search-approach",
                "content": "# Approach\\n1. Make sorted array from Binary Search Tree using inorder traverse\\n2. Iterate through queries and use Binary Searh to find min and max \\n\\n# Complexity\\n- Time complexity: $$O(n log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- O(n) $$ -->\\n\\n\\n\\n# Code\\n```\\nvar findMin = (arr, target) => {\\n  let lo = 0\\n  let hi = arr.length - 1\\n  let ans = -1\\n\\n  while (lo <= hi) {\\n    const mid = Math.floor((lo+hi) / 2)\\n    if (arr[mid] === target) return arr[mid]\\n    if (arr[mid] < target) {\\n      ans = arr[mid]\\n      lo = mid + 1\\n    } else {\\n      hi = mid -1\\n    }\\n  }\\n  return ans\\n}\\n\\nvar findMax = (arr, target) => {\\n  let lo = 0\\n  let hi = arr.length - 1\\n  let ans = -1\\n\\n  while (lo <= hi) {\\n    const mid = Math.floor((lo+hi)/2)\\n    if (arr[mid] === target) return arr[mid]\\n    if (arr[mid] < target) {\\n      lo=mid+1\\n    } else {\\n      hi = mid-1\\n      ans = arr[mid]\\n    }\\n  }\\n\\n  return ans\\n}\\n\\nvar closestNodes = function(root, queries) {\\n  const arr = []\\n\\n  // Make sorted array from BST, because BST is not completed\\n  const traverse = (node) => {\\n    if (!node) {\\n        return null\\n    }\\n\\n    dfs(node.left)\\n    arr.push(node.val)\\n    dfs(node.right)\\n  }\\n\\n  traverse(root)\\n\\n  const ans = []\\n  for (let i = 0; i < queries.length; i++) {\\n    const target = queries[i]\\n    // Find min value using Binary Sarch\\n    const min = arr[0] > target ? -1 : findMin(arr, target)\\n    // Find max value using Binary Search\\n    const max = arr[arr.length-1] < target ? -1 : findMax(arr, target)\\n    ans.push([min, max])\\n  }\\n\\n  return ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\nvar findMin = (arr, target) => {\\n  let lo = 0\\n  let hi = arr.length - 1\\n  let ans = -1\\n\\n  while (lo <= hi) {\\n    const mid = Math.floor((lo+hi) / 2)\\n    if (arr[mid] === target) return arr[mid]\\n    if (arr[mid] < target) {\\n      ans = arr[mid]\\n      lo = mid + 1\\n    } else {\\n      hi = mid -1\\n    }\\n  }\\n  return ans\\n}\\n\\nvar findMax = (arr, target) => {\\n  let lo = 0\\n  let hi = arr.length - 1\\n  let ans = -1\\n\\n  while (lo <= hi) {\\n    const mid = Math.floor((lo+hi)/2)\\n    if (arr[mid] === target) return arr[mid]\\n    if (arr[mid] < target) {\\n      lo=mid+1\\n    } else {\\n      hi = mid-1\\n      ans = arr[mid]\\n    }\\n  }\\n\\n  return ans\\n}\\n\\nvar closestNodes = function(root, queries) {\\n  const arr = []\\n\\n  // Make sorted array from BST, because BST is not completed\\n  const traverse = (node) => {\\n    if (!node) {\\n        return null\\n    }\\n\\n    dfs(node.left)\\n    arr.push(node.val)\\n    dfs(node.right)\\n  }\\n\\n  traverse(root)\\n\\n  const ans = []\\n  for (let i = 0; i < queries.length; i++) {\\n    const target = queries[i]\\n    // Find min value using Binary Sarch\\n    const min = arr[0] > target ? -1 : findMin(arr, target)\\n    // Find max value using Binary Search\\n    const max = arr[arr.length-1] < target ? -1 : findMax(arr, target)\\n    ans.push([min, max])\\n  }\\n\\n  return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2832086,
                "title": "simple-c-store-inorder-traversal-then-apply-binary-search",
                "content": "```\\n void inorder(TreeNode* root, vector<int>&in){\\n        if(!root) return;\\n        \\n        inorder(root->left,in);\\n        in.push_back(root->val);\\n        inorder(root->right,in);\\n    }\\n\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<vector<int>>ans;\\n\\t\\t\\n\\t\\t//store inorder traversal in a vector -> gives values in a sorted order\\n          vector<int>in;\\n         inorder(root,in);\\n        \\n        //now we can apply binary search to find ceil and floor for each query\\n        for(auto q : queries){\\n           \\n            auto it = lower_bound(begin(in),end(in),q);\\n\\t\\t\\t//if q exists in tree then ceil=floor=q\\n            if(it!=in.end() && *it==q) \\n                ans.push_back(vector<int>{q,q});\\n            \\n\\t\\t\\t//else *it gives ceil and *prev(it) gives floor if they are in bounds\\n            else{\\n                int c = (it==in.end()) ? -1 : *it;\\n                int f = (it==in.begin()) ? -1 : *prev(it);\\n                ans.push_back(vector<int>{f,c});\\n            }\\n        }\\n        \\n        return ans;\\n\\n//TC- O(NlogN) , SC- O(N)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n void inorder(TreeNode* root, vector<int>&in){\\n        if(!root) return;\\n        \\n        inorder(root->left,in);\\n        in.push_back(root->val);\\n        inorder(root->right,in);\\n    }\\n\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<vector<int>>ans;\\n\\t\\t\\n\\t\\t//store inorder traversal in a vector -> gives values in a sorted order\\n          vector<int>in;\\n         inorder(root,in);\\n        \\n        //now we can apply binary search to find ceil and floor for each query\\n        for(auto q : queries){\\n           \\n            auto it = lower_bound(begin(in),end(in),q);\\n\\t\\t\\t//if q exists in tree then ceil=floor=q\\n            if(it!=in.end() && *it==q) \\n                ans.push_back(vector<int>{q,q});\\n            \\n\\t\\t\\t//else *it gives ceil and *prev(it) gives floor if they are in bounds\\n            else{\\n                int c = (it==in.end()) ? -1 : *it;\\n                int f = (it==in.begin()) ? -1 : *prev(it);\\n                ans.push_back(vector<int>{f,c});\\n            }\\n        }\\n        \\n        return ans;\\n\\n//TC- O(NlogN) , SC- O(N)",
                "codeTag": "Unknown"
            },
            {
                "id": 2832073,
                "title": "simple-cpp-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsimple requirement of this que is to calculate predecessor and successor of every query.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor every element in queries find predecessor(<=queries[i]) and  successor(>=queries[i]).\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(n*h)**\\nn->number of queries\\nh->height of bst.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(1)**\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> prede(TreeNode* root,int key){\\n        int pre=-1;\\n        int suc=-1;\\n        while(root){\\n            if(root->val < key){\\n               pre=root->val;\\n                root=root->right;\\n            }else if(root->val==key){\\n                return {key,key};\\n            }else{\\n                suc=root->val;\\n                root=root->left;\\n            }\\n        }\\n        return {pre,suc};\\n    }\\n    \\n    \\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<vector<int>>ans;\\n        int n=queries.size();\\n        for(int i=0;i<n;i++){\\n            int key=queries[i];\\n            \\n            ans.push_back(prede(root,key));            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> prede(TreeNode* root,int key){\\n        int pre=-1;\\n        int suc=-1;\\n        while(root){\\n            if(root->val < key){\\n               pre=root->val;\\n                root=root->right;\\n            }else if(root->val==key){\\n                return {key,key};\\n            }else{\\n                suc=root->val;\\n                root=root->left;\\n            }\\n        }\\n        return {pre,suc};\\n    }\\n    \\n    \\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<vector<int>>ans;\\n        int n=queries.size();\\n        for(int i=0;i<n;i++){\\n            int key=queries[i];\\n            \\n            ans.push_back(prede(root,key));            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832066,
                "title": "c-dfs-without-inorder-traversal",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, const int v,\\n             int& mini, int& maxi) {\\n      if (!root) {\\n        return;\\n      }\\n      if (v == root->val) {\\n        mini = v; maxi = v;\\n        return;\\n      }\\n      if (v < root->val) {\\n        maxi = root->val;\\n        dfs(root->left, v, mini, maxi);\\n      } else {\\n        mini = root->val;\\n        dfs(root->right, v, mini, maxi);\\n      }\\n    }\\n  \\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<vector<int>> ret;\\n        for (auto q : queries) {\\n          int mini = INT_MIN, maxi = INT_MAX;\\n          dfs(root, q, mini, maxi);\\n          if (mini == INT_MIN) mini = -1;\\n          if (maxi == INT_MAX) maxi = -1;\\n          ret.push_back({mini, maxi});\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, const int v,\\n             int& mini, int& maxi) {\\n      if (!root) {\\n        return;\\n      }\\n      if (v == root->val) {\\n        mini = v; maxi = v;\\n        return;\\n      }\\n      if (v < root->val) {\\n        maxi = root->val;\\n        dfs(root->left, v, mini, maxi);\\n      } else {\\n        mini = root->val;\\n        dfs(root->right, v, mini, maxi);\\n      }\\n    }\\n  \\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<vector<int>> ret;\\n        for (auto q : queries) {\\n          int mini = INT_MIN, maxi = INT_MAX;\\n          dfs(root, q, mini, maxi);\\n          if (mini == INT_MIN) mini = -1;\\n          if (maxi == INT_MAX) maxi = -1;\\n          ret.push_back({mini, maxi});\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832039,
                "title": "binary-search-approach-in-python",
                "content": "```\\ndef closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        # get sorted array from binary tree\\n        def traverse(root, arr):\\n            if not root:\\n                return\\n            traverse(root.left, arr)\\n            arr.append(root.val)\\n            traverse(root.right, arr)\\n            \\n        arr = []\\n        traverse(root, arr)\\n        \\n        def bin_search(val, low, high):\\n            mid = (high - low) // 2 + low\\n            \\n            if low > high:\\n                # return high as it is the lower bound for val\\n                return high\\n            \\n            if arr[mid] == val:\\n                return mid\\n            \\n            if arr[mid] < val:\\n                return bin_search(val, mid + 1, high)\\n            \\n            return bin_search(val, low, mid - 1)\\n        \\n        res = []\\n        n = len(arr)\\n        \\n        for val in queries:\\n            idx = bin_search(val, 0, n - 1)\\n            if val == arr[idx]:\\n                res.append([val, val])\\n            else:\\n                if idx == -1:\\n                    # the val is lower than the lowest value in array, hence -1\\n                    res.append([-1, arr[idx + 1]])\\n                elif idx + 1 < n:\\n                    # idx is lower bound of val and idx + 1 will be higher bound of val\\n                    res.append([arr[idx], arr[idx + 1]])\\n                else:\\n                    # the val is higher than the highest value in array, hence -1\\n                    res.append([arr[idx], -1])\\n                    \\n        return res\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\ndef closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        # get sorted array from binary tree\\n        def traverse(root, arr):\\n            if not root:\\n                return\\n            traverse(root.left, arr)\\n            arr.append(root.val)\\n            traverse(root.right, arr)\\n            \\n        arr = []\\n        traverse(root, arr)\\n        \\n        def bin_search(val, low, high):\\n            mid = (high - low) // 2 + low\\n            \\n            if low > high:\\n                # return high as it is the lower bound for val\\n                return high\\n            \\n            if arr[mid] == val:\\n                return mid\\n            \\n            if arr[mid] < val:\\n                return bin_search(val, mid + 1, high)\\n            \\n            return bin_search(val, low, mid - 1)\\n        \\n        res = []\\n        n = len(arr)\\n        \\n        for val in queries:\\n            idx = bin_search(val, 0, n - 1)\\n            if val == arr[idx]:\\n                res.append([val, val])\\n            else:\\n                if idx == -1:\\n                    # the val is lower than the lowest value in array, hence -1\\n                    res.append([-1, arr[idx + 1]])\\n                elif idx + 1 < n:\\n                    # idx is lower bound of val and idx + 1 will be higher bound of val\\n                    res.append([arr[idx], arr[idx + 1]])\\n                else:\\n                    # the val is higher than the highest value in array, hence -1\\n                    res.append([arr[idx], -1])\\n                    \\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2832024,
                "title": "unbalanced-bst-inorder-traversal-binary-search",
                "content": "The tree might be unbalanced\\n\\nInorder traversal to get sorted array\\nBinary search to find lowest and highest\\n\\nAnother way is to recreate BST that\\'s balanced, and then do the searches.\\n\\nTime: complexity is O(nlogn)\\nSpace complexity is O(n)\\n\\n```\\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        \\n        nums = []\\n        def inorder(node):\\n            if node:\\n                inorder(node.left)\\n                nums.append(node.val)\\n                inorder(node.right)\\n        inorder(root)        \\n        \\n        n = len(nums)\\n        \\n        ans = []\\n        for target in queries:\\n            ans.append([-1, -1])\\n            \\n            l, r = 0, n-1\\n            while l <= r:\\n                mid = l + (r - l)//2\\n                \\n                if nums[mid] == target:\\n                    ans[-1] = [target, target]\\n                    break\\n                elif nums[mid] > target:\\n                    ans[-1][1] = nums[mid]\\n                    r = mid -1\\n                else:\\n                    ans[-1][0] = nums[mid]\\n                    l = mid + 1\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        \\n        nums = []\\n        def inorder(node):\\n            if node:\\n                inorder(node.left)\\n                nums.append(node.val)\\n                inorder(node.right)\\n        inorder(root)        \\n        \\n        n = len(nums)\\n        \\n        ans = []\\n        for target in queries:\\n            ans.append([-1, -1])\\n            \\n            l, r = 0, n-1\\n            while l <= r:\\n                mid = l + (r - l)//2\\n                \\n                if nums[mid] == target:\\n                    ans[-1] = [target, target]\\n                    break\\n                elif nums[mid] > target:\\n                    ans[-1][1] = nums[mid]\\n                    r = mid -1\\n                else:\\n                    ans[-1][0] = nums[mid]\\n                    l = mid + 1\\n            \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2831920,
                "title": "easy-c-inorder-traversal-concise-explained",
                "content": "This first given hint is Tree is BST - and in BST we can find any element is O(logn) Time.\\nIf we do inorder Traversal of any BST then it will automatically store all the elements in sorted order.\\n*In given example :*\\n![image](https://assets.leetcode.com/users/images/4c59b2a2-bdb4-47b6-8ada-f509815c76f0_1668917891.3860877.png)\\n Inorder Traversal of BST will be  : [ 1, 2, 4 , 6, 9, 13, 14, 15]\\n Now the problem boils down to  find:\\n*  mini - largest value in the array that is smaller than or equal to queries[i]. If a such value does not exist, add -1 instead.\\n*  maxi - smallest value in the array that is greater than or equal to queries[i]. If a such value does not exist, add -1 instead.\\n\\nWe can find both of the above in O(logn) Time using binary search.\\n\\n**CODE:**\\n```\\nclass Solution {\\npublic:\\n\\tvector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n\\t\\tvector<int>inorder; //  for storing inorder traversal of BST\\n\\t\\tvector<vector<int>>ans;\\n\\t\\tif (!root) return ans;\\n\\t\\tdfs(root, inorder); // Do the inorder traversal\\n\\t\\tint n = inorder.size();\\n\\t\\tfor (int q : queries) {\\n\\t\\t\\tint mn = -1, mx = -1;\\n\\t\\t\\t// find the mini\\n\\t\\t\\tint idx = lower_bound(inorder.begin(), inorder.end(), q) - inorder.begin();\\n\\t\\t\\tif ((idx >= 0 && idx < n) && inorder[idx] <= q) mn = q;\\n\\t\\t\\telse if ((idx - 1 >= 0) && (idx - 1 < n)) mn = inorder[idx - 1];\\n\\t\\t\\t// find the maxi\\n\\t\\t\\tidx = upper_bound(inorder.begin(), inorder.end(), q) - inorder.begin();\\n\\t\\t\\tif (((idx - 1 >= 0) && (idx - 1 < n) && inorder[idx - 1] >= q)) mx = inorder[idx - 1];\\n\\t\\t\\telse if (idx < n) mx = inorder[idx];\\n\\t\\t\\tans.push_back({mn, mx});\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\nprivate:\\n\\tvoid dfs(TreeNode *root, vector<int>&inorder) {\\n\\t\\tstack<TreeNode*> st;\\n\\t\\tTreeNode* node = root;\\n\\t\\twhile (true) {\\n\\t\\t\\tif (node != NULL) {\\n\\t\\t\\t\\tst.push(node);\\n\\t\\t\\t\\tnode = node->left;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif (st.empty() == true) break;\\n\\t\\t\\t\\tnode = st.top();\\n\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\tinorder.push_back(node->val);\\n\\t\\t\\t\\tnode = node->right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n```\\n",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n\\t\\tvector<int>inorder; //  for storing inorder traversal of BST\\n\\t\\tvector<vector<int>>ans;\\n\\t\\tif (!root) return ans;\\n\\t\\tdfs(root, inorder); // Do the inorder traversal\\n\\t\\tint n = inorder.size();\\n\\t\\tfor (int q : queries) {\\n\\t\\t\\tint mn = -1, mx = -1;\\n\\t\\t\\t// find the mini\\n\\t\\t\\tint idx = lower_bound(inorder.begin(), inorder.end(), q) - inorder.begin();\\n\\t\\t\\tif ((idx >= 0 && idx < n) && inorder[idx] <= q) mn = q;\\n\\t\\t\\telse if ((idx - 1 >= 0) && (idx - 1 < n)) mn = inorder[idx - 1];\\n\\t\\t\\t// find the maxi\\n\\t\\t\\tidx = upper_bound(inorder.begin(), inorder.end(), q) - inorder.begin();\\n\\t\\t\\tif (((idx - 1 >= 0) && (idx - 1 < n) && inorder[idx - 1] >= q)) mx = inorder[idx - 1];\\n\\t\\t\\telse if (idx < n) mx = inorder[idx];\\n\\t\\t\\tans.push_back({mn, mx});\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\nprivate:\\n\\tvoid dfs(TreeNode *root, vector<int>&inorder) {\\n\\t\\tstack<TreeNode*> st;\\n\\t\\tTreeNode* node = root;\\n\\t\\twhile (true) {\\n\\t\\t\\tif (node != NULL) {\\n\\t\\t\\t\\tst.push(node);\\n\\t\\t\\t\\tnode = node->left;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif (st.empty() == true) break;\\n\\t\\t\\t\\tnode = st.top();\\n\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\tinorder.push_back(node->val);\\n\\t\\t\\t\\tnode = node->right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831918,
                "title": "java-3-solutions-binary-search-treeset-explained",
                "content": "### **Please Upvote** :D\\n**`Important property:`** `Inorder traversal of a BST gets us a sorted sequence.`\\n##### 1. BFS + Binary Search:\\nHere, a **BFS** has been done to get all the node values in the tree. \\nBinary search has been applied on the list of tree values (sorted) to get **floor** and **ceiling**.\\n```\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<Integer> list = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode node = root;\\n\\n        while (true) {\\n            if (node != null) {\\n                stack.push(node);\\n                node = node.left;\\n            }\\n            else {\\n                if (stack.isEmpty()) break;\\n                node = stack.pop();\\n                list.add(node.val);\\n                node = node.right;\\n            }\\n        }\\n\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        for (int n : queries) {\\n            ans.add(getFloorCeil(list, n));\\n        }\\n\\n        return ans;\\n    }\\n\\n    public List<Integer> getFloorCeil(List<Integer> nums, int target) {\\n        int lo = 0, hi = nums.size() - 1;\\n        int floor = -1, ceil = -1;\\n\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            int midEle = nums.get(mid);\\n\\n            if (midEle == target) {\\n                return Arrays.asList(midEle, midEle) ;\\n            }\\n            else if (target < midEle) {\\n                ceil = midEle;\\n                hi = mid - 1;\\n            }\\n            else {\\n                floor = midEle;\\n                lo = mid + 1;\\n            }\\n        }\\n\\n        return Arrays.asList(floor, ceil);\\n    }\\n}\\n\\n// TC: O(n) + O(m * logn))\\n// n -> number of nodes in binary tree\\n// m -> length of queries\\n\\n// SC: O(n + m)\\n```\\n##### 2. DFS + Binary Search:\\nHere, an **Inorder Traversal (DFS)** has been done to get all the node values in the tree. \\nBinary search has been applied on the list of tree values (sorted) to get **floor** and **ceiling**.\\n```\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<Integer> list = new ArrayList<>();\\n        inorder(list, root);\\n\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        for (int n : queries) {\\n            ans.add(getFloorCeil(list, n));\\n        }\\n\\n        return ans;\\n    }\\n\\n    public List<Integer> getFloorCeil(List<Integer> nums, int target) {\\n        int lo = 0, hi = nums.size() - 1;\\n        int floor = -1, ceil = -1;\\n\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n\\n            if (nums.get(mid) == target) {\\n                return Arrays.asList(target, target) ;\\n            }\\n            else if (target < nums.get(mid)) {\\n                ceil = nums.get(mid);\\n                hi = mid - 1;\\n            }\\n            else {\\n                floor = nums.get(mid);\\n                lo = mid + 1;\\n            }\\n        }\\n\\n        return Arrays.asList(floor, ceil);\\n    }\\n\\n    public void inorder(List<Integer> list, TreeNode root){\\n        if(root == null) return;\\n        inorder(list, root.left);\\n        list.add(root.val);\\n        inorder(list, root.right);\\n    }\\n}\\n\\n// TC: O(n) + O(m * logn))\\n// n -> number of nodes in binary tree\\n// m -> length of queries\\n\\n// SC: O(n + m)\\n```\\n\\n##### 3. Using TreeSet:\\nHere, an Inorder traversal (DFS) has been done to get all the node values in the tree and store them in a **TreeSet**. BFS can also be done instead of DFS, it hardly matters.\\n\\nA TreeSet automatically sorts the sequence in `O(logn)` time with each addition that takes place.\\nHowever, the property mentioned at the beginning is not being taken advantage of.\\n\\nThe built-in methods `floor()` and `ceiling()` saves our time of writing the code for Binary Search but costs us runtime.\\n\\nThe methods `floor()` and `ceiling()` gets us the **floor** and **ceiling** values respectively in another `O(logn)` time each.\\n```\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        TreeSet<Integer> set = new TreeSet<>();\\n\\n        inorder(set,root);\\n\\n        for (int n : queries) {\\n            int floor = set.floor(n) == null ? -1 : set.floor(n);\\n            int ceil = set.ceiling(n) == null ? - 1: set.ceiling(n);\\n            ans.add(Arrays.asList(floor, ceil));\\n        }\\n\\n        return ans;\\n    }\\n\\n    public void inorder(TreeSet set,TreeNode root){\\n        if(root == null) return;\\n        inorder(set,root.left);\\n        set.add(root.val);\\n        inorder(set,root.right);\\n    }\\n}\\n\\n// TC: O(n * logn) + O(m * logn) => O((n + m) * logn))\\n// SC: O(n + m)\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<Integer> list = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode node = root;\\n\\n        while (true) {\\n            if (node != null) {\\n                stack.push(node);\\n                node = node.left;\\n            }\\n            else {\\n                if (stack.isEmpty()) break;\\n                node = stack.pop();\\n                list.add(node.val);\\n                node = node.right;\\n            }\\n        }\\n\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        for (int n : queries) {\\n            ans.add(getFloorCeil(list, n));\\n        }\\n\\n        return ans;\\n    }\\n\\n    public List<Integer> getFloorCeil(List<Integer> nums, int target) {\\n        int lo = 0, hi = nums.size() - 1;\\n        int floor = -1, ceil = -1;\\n\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            int midEle = nums.get(mid);\\n\\n            if (midEle == target) {\\n                return Arrays.asList(midEle, midEle) ;\\n            }\\n            else if (target < midEle) {\\n                ceil = midEle;\\n                hi = mid - 1;\\n            }\\n            else {\\n                floor = midEle;\\n                lo = mid + 1;\\n            }\\n        }\\n\\n        return Arrays.asList(floor, ceil);\\n    }\\n}\\n\\n// TC: O(n) + O(m * logn))\\n// n -> number of nodes in binary tree\\n// m -> length of queries\\n\\n// SC: O(n + m)\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<Integer> list = new ArrayList<>();\\n        inorder(list, root);\\n\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        for (int n : queries) {\\n            ans.add(getFloorCeil(list, n));\\n        }\\n\\n        return ans;\\n    }\\n\\n    public List<Integer> getFloorCeil(List<Integer> nums, int target) {\\n        int lo = 0, hi = nums.size() - 1;\\n        int floor = -1, ceil = -1;\\n\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n\\n            if (nums.get(mid) == target) {\\n                return Arrays.asList(target, target) ;\\n            }\\n            else if (target < nums.get(mid)) {\\n                ceil = nums.get(mid);\\n                hi = mid - 1;\\n            }\\n            else {\\n                floor = nums.get(mid);\\n                lo = mid + 1;\\n            }\\n        }\\n\\n        return Arrays.asList(floor, ceil);\\n    }\\n\\n    public void inorder(List<Integer> list, TreeNode root){\\n        if(root == null) return;\\n        inorder(list, root.left);\\n        list.add(root.val);\\n        inorder(list, root.right);\\n    }\\n}\\n\\n// TC: O(n) + O(m * logn))\\n// n -> number of nodes in binary tree\\n// m -> length of queries\\n\\n// SC: O(n + m)\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        TreeSet<Integer> set = new TreeSet<>();\\n\\n        inorder(set,root);\\n\\n        for (int n : queries) {\\n            int floor = set.floor(n) == null ? -1 : set.floor(n);\\n            int ceil = set.ceiling(n) == null ? - 1: set.ceiling(n);\\n            ans.add(Arrays.asList(floor, ceil));\\n        }\\n\\n        return ans;\\n    }\\n\\n    public void inorder(TreeSet set,TreeNode root){\\n        if(root == null) return;\\n        inorder(set,root.left);\\n        set.add(root.val);\\n        inorder(set,root.right);\\n    }\\n}\\n\\n// TC: O(n * logn) + O(m * logn) => O((n + m) * logn))\\n// SC: O(n + m)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831861,
                "title": "c-solution-easy-to-understand",
                "content": "```\\n\\n\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        \\n        vector<vector<int>>ans ;\\n        for(auto q:queries){\\n            \\n            TreeNode* t = root;\\n            int min = INT_MIN, max = INT_MAX;\\n            \\n            while(t!=NULL){\\n                \\n                int val = t->val;\\n                \\n                if(val == q){\\n                    min = val;\\n                    max = val;\\n                    break;\\n                }\\n                \\n                if(val < q){\\n                    if(val >= min)\\n                        min = val;\\n                    t = t->right;\\n                }\\n                \\n                \\n                if(val > q){\\n                    if(val <= max)\\n                        max = val;\\n                    t = t->left;\\n                }   \\n            }\\n            \\n            if(min == INT_MIN)\\n                min = -1;\\n            \\n            if(max == INT_MAX)\\n                max = -1;\\n            ans.push_back({min,max});\\n            \\n        }\\n        \\n        return ans;\\n    }\\n\\t",
                "solutionTags": [
                    "Binary Search",
                    "Binary Search Tree"
                ],
                "code": "```\\n\\n\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        \\n        vector<vector<int>>ans ;\\n        for(auto q:queries){\\n            \\n            TreeNode* t = root;\\n            int min = INT_MIN, max = INT_MAX;\\n            \\n            while(t!=NULL){\\n                \\n                int val = t->val;\\n                \\n                if(val == q){\\n                    min = val;\\n                    max = val;\\n                    break;\\n                }\\n                \\n                if(val < q){\\n                    if(val >= min)\\n                        min = val;\\n                    t = t->right;\\n                }\\n                \\n                \\n                if(val > q){\\n                    if(val <= max)\\n                        max = val;\\n                    t = t->left;\\n                }   \\n            }\\n            \\n            if(min == INT_MIN)\\n                min = -1;\\n            \\n            if(max == INT_MAX)\\n                max = -1;\\n            ans.push_back({min,max});\\n            \\n        }\\n        \\n        return ans;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2831842,
                "title": "python-tle",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n    \\n        \\n        sol=[]\\n        mapper={}\\n        for query in queries:\\n            if(root==None):\\n                sol.append([-1,-1])\\n                \\n            elif(query in mapper):\\n                sol.append(mapper[query])\\n            else:    \\n                temp=[]\\n                temp.append(self.search_left(root,query,-1))\\n                temp.append(self.search_right(root,query,-1))\\n                mapper[query]=temp\\n                sol.append(temp)\\n        return sol    \\n        \\n    def search_left(self,root,val,prev):\\n        \\n        if(root==None):\\n            return prev\\n        \\n        if(root.val==val):\\n            return val\\n        if(val<root.val):\\n            return self.search_left(root.left,val,prev)\\n        \\n        if(val>root.val):\\n            return self.search_left(root.right,val,root.val)\\n        \\n    def search_right(self,root,val,prev):\\n        \\n        if(root==None):\\n            return prev\\n        \\n        if(root.val==val):\\n            return val\\n        if(val<root.val):\\n            return self.search_right(root.left,val,root.val)\\n        \\n        if(val>root.val):\\n            return self.search_right(root.right,val,prev)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n    \\n        \\n        sol=[]\\n        mapper={}\\n        for query in queries:\\n            if(root==None):\\n                sol.append([-1,-1])\\n                \\n            elif(query in mapper):\\n                sol.append(mapper[query])\\n            else:    \\n                temp=[]\\n                temp.append(self.search_left(root,query,-1))\\n                temp.append(self.search_right(root,query,-1))\\n                mapper[query]=temp\\n                sol.append(temp)\\n        return sol    \\n        \\n    def search_left(self,root,val,prev):\\n        \\n        if(root==None):\\n            return prev\\n        \\n        if(root.val==val):\\n            return val\\n        if(val<root.val):\\n            return self.search_left(root.left,val,prev)\\n        \\n        if(val>root.val):\\n            return self.search_left(root.right,val,root.val)\\n        \\n    def search_right(self,root,val,prev):\\n        \\n        if(root==None):\\n            return prev\\n        \\n        if(root.val==val):\\n            return val\\n        if(val<root.val):\\n            return self.search_right(root.left,val,root.val)\\n        \\n        if(val>root.val):\\n            return self.search_right(root.right,val,prev)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831822,
                "title": "c-inorder-traversal-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int mini(vector<int>& nums, int a)\\n    {\\n        int low = 0, high = size(nums)-1;\\n        int res = -1;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            if(nums[mid] <= a)\\n            {\\n                res = mid;\\n                low = mid+1;\\n            }\\n            else high = mid-1;\\n        }\\n        return res == -1 ? res : nums[res];\\n    }\\n    int maxi(vector<int>& nums, int a)\\n    {\\n        int low = 0, high = size(nums)-1;\\n        int res = -1;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            if(nums[mid] >= a)\\n            {\\n                res = mid;\\n                high = mid-1;\\n            }\\n            else low = mid+1;\\n        }\\n        return res == -1 ? res : nums[res];\\n    }\\n    void trav(TreeNode* root, vector<int>& pre)\\n    {\\n        if(!root)return;\\n        trav(root->left,pre);\\n        pre.push_back(root->val);\\n        trav(root->right,pre);\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& q)\\n    {\\n        vector<int> pre;\\n        trav(root,pre);\\n        vector<vector<int>> res;\\n        for(int i = 0; i < size(q); i++)\\n        {\\n            vector<int> ans;\\n            ans.push_back(mini(pre,q[i]));\\n            ans.push_back(maxi(pre,q[i]));\\n            res.push_back(ans);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mini(vector<int>& nums, int a)\\n    {\\n        int low = 0, high = size(nums)-1;\\n        int res = -1;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            if(nums[mid] <= a)\\n            {\\n                res = mid;\\n                low = mid+1;\\n            }\\n            else high = mid-1;\\n        }\\n        return res == -1 ? res : nums[res];\\n    }\\n    int maxi(vector<int>& nums, int a)\\n    {\\n        int low = 0, high = size(nums)-1;\\n        int res = -1;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            if(nums[mid] >= a)\\n            {\\n                res = mid;\\n                high = mid-1;\\n            }\\n            else low = mid+1;\\n        }\\n        return res == -1 ? res : nums[res];\\n    }\\n    void trav(TreeNode* root, vector<int>& pre)\\n    {\\n        if(!root)return;\\n        trav(root->left,pre);\\n        pre.push_back(root->val);\\n        trav(root->right,pre);\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& q)\\n    {\\n        vector<int> pre;\\n        trav(root,pre);\\n        vector<vector<int>> res;\\n        for(int i = 0; i < size(q); i++)\\n        {\\n            vector<int> ans;\\n            ans.push_back(mini(pre,q[i]));\\n            ans.push_back(maxi(pre,q[i]));\\n            res.push_back(ans);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831821,
                "title": "python-sortedlist",
                "content": "# Intuition\\nSadly, the tree is unbalanced. Can\\'t do bineary search directly.\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        ans = []\\n        shortcut = SortedList()\\n        todo = []\\n        todo.append(root)\\n        while(todo):\\n            top = todo.pop()\\n            shortcut.add(top.val)\\n            if top.left:\\n                todo.append(top.left)\\n            if top.right:\\n                todo.append(top.right)\\n        for i in range(len(queries)):\\n            if queries[i] in shortcut:\\n                ans.append([queries[i], queries[i]])\\n                continue\\n            idx = shortcut.bisect_left(queries[i])\\n            if idx == 0:\\n                ans.append([-1, shortcut[0]])\\n            elif idx == len(shortcut):\\n                ans.append([shortcut[-1],-1])\\n            else:\\n                ans.append([shortcut[idx-1], shortcut[idx]])\\n        return ans\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        ans = []\\n        shortcut = SortedList()\\n        todo = []\\n        todo.append(root)\\n        while(todo):\\n            top = todo.pop()\\n            shortcut.add(top.val)\\n            if top.left:\\n                todo.append(top.left)\\n            if top.right:\\n                todo.append(top.right)\\n        for i in range(len(queries)):\\n            if queries[i] in shortcut:\\n                ans.append([queries[i], queries[i]])\\n                continue\\n            idx = shortcut.bisect_left(queries[i])\\n            if idx == 0:\\n                ans.append([-1, shortcut[0]])\\n            elif idx == len(shortcut):\\n                ans.append([shortcut[-1],-1])\\n            else:\\n                ans.append([shortcut[idx-1], shortcut[idx]])\\n        return ans\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831816,
                "title": "easy-solution-python-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven a BST.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Use Inorder traversal to get the node values as Sorted array.\\n2. Create a set of the Array.\\n3. Create ans array to store result of each query.\\n4. Iterate through the queries array.\\n5. For each element, check if it is in the set.\\n6. If not in the set, use Binary search to get the (mini and maxi).\\n7. I used bisect methods to find (mini and maxi).\\n8. Return the 2-d ans array.\\n\\n\\nHope it was clear. Thank you!\\n\\n# Complexity\\n- Time complexity: O(n) + O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorder(self, root):\\n        if root:\\n            self.inorder(root.left)\\n            self.A.append(root.val)\\n            self.inorder(root.right)\\n            \\n    \\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        self.A = []\\n\\n        self.inorder(root)\\n        \\n        net = set(self.A)\\n        \\n        # print(self.A)\\n        ans = []\\n        \\n        for q in queries:\\n            if q in net:\\n                k = [q, q]\\n                ans.append(k)\\n            else:\\n                i = bisect.bisect_right(self.A, q)\\n                maxi, mini = -1, -1\\n                if i < len(self.A):\\n                    maxi = self.A[i]\\n                \\n                j = bisect.bisect_left(self.A, q)\\n                if j > 0:\\n                    mini = self.A[j - 1]\\n\\n                ans.append([mini, maxi])\\n        \\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Search Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorder(self, root):\\n        if root:\\n            self.inorder(root.left)\\n            self.A.append(root.val)\\n            self.inorder(root.right)\\n            \\n    \\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        self.A = []\\n\\n        self.inorder(root)\\n        \\n        net = set(self.A)\\n        \\n        # print(self.A)\\n        ans = []\\n        \\n        for q in queries:\\n            if q in net:\\n                k = [q, q]\\n                ans.append(k)\\n            else:\\n                i = bisect.bisect_right(self.A, q)\\n                maxi, mini = -1, -1\\n                if i < len(self.A):\\n                    maxi = self.A[i]\\n                \\n                j = bisect.bisect_left(self.A, q)\\n                if j > 0:\\n                    mini = self.A[j - 1]\\n\\n                ans.append([mini, maxi])\\n        \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831814,
                "title": "javascript-dfs-binary-search-597ms",
                "content": "```\\n////////////////////////// Template ////////////////////////////\\nfunction Bisect() {\\n    return { insort_right, insort_left, bisect_left, bisect_right }\\n    function insort_right(a, x, lo = 0, hi = null) {\\n        lo = bisect_right(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_right(a, x, lo = 0, hi = null) { // > upper_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] > x ? hi = mid : lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    function insort_left(a, x, lo = 0, hi = null) {\\n        lo = bisect_left(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_left(a, x, lo = 0, hi = null) { // >= lower_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] < x ? lo = mid + 1 : hi = mid;\\n        }\\n        return lo;\\n    }\\n}\\n//////////////////////////////////////////////////////////////\\n\\nconst closestNodes = (root, queries) => {\\n    inorderTraversal(root);\\n    d.sort((x, y) => x - y);\\n    let maxD = d[d.length - 1], minD = d[0], res = [], bi = new Bisect();\\n    for (const x of queries) {\\n        if (x > maxD) {\\n            res.push([maxD, -1]);\\n        } else if (x < minD) {\\n            res.push([-1, minD]);\\n        } else {\\n            let r = bi.bisect_left(d, x), l = d[r] == x ? r : r - 1;\\n            res.push([d[l], d[r]]);\\n        }\\n    }\\n    return res;\\n};\\n\\nlet d;\\nconst inorderTraversal = (root) => {\\n    d = [];\\n    dfs(root);\\n    return d;\\n};\\n\\nconst dfs = (node) => {\\n   if (!node) return;\\n   dfs(node.left);\\n   d.push(node.val);\\n   dfs(node.right);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Depth-First Search"
                ],
                "code": "```\\n////////////////////////// Template ////////////////////////////\\nfunction Bisect() {\\n    return { insort_right, insort_left, bisect_left, bisect_right }\\n    function insort_right(a, x, lo = 0, hi = null) {\\n        lo = bisect_right(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_right(a, x, lo = 0, hi = null) { // > upper_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] > x ? hi = mid : lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    function insort_left(a, x, lo = 0, hi = null) {\\n        lo = bisect_left(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_left(a, x, lo = 0, hi = null) { // >= lower_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] < x ? lo = mid + 1 : hi = mid;\\n        }\\n        return lo;\\n    }\\n}\\n//////////////////////////////////////////////////////////////\\n\\nconst closestNodes = (root, queries) => {\\n    inorderTraversal(root);\\n    d.sort((x, y) => x - y);\\n    let maxD = d[d.length - 1], minD = d[0], res = [], bi = new Bisect();\\n    for (const x of queries) {\\n        if (x > maxD) {\\n            res.push([maxD, -1]);\\n        } else if (x < minD) {\\n            res.push([-1, minD]);\\n        } else {\\n            let r = bi.bisect_left(d, x), l = d[r] == x ? r : r - 1;\\n            res.push([d[l], d[r]]);\\n        }\\n    }\\n    return res;\\n};\\n\\nlet d;\\nconst inorderTraversal = (root) => {\\n    d = [];\\n    dfs(root);\\n    return d;\\n};\\n\\nconst dfs = (node) => {\\n   if (!node) return;\\n   dfs(node.left);\\n   d.push(node.val);\\n   dfs(node.right);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2831775,
                "title": "c-code-set-faster-than-100",
                "content": "***If you find this helpful, Please Upvote \\uD83D\\uDD3C\\nThank You !***\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    void inOrder(TreeNode* root, set<int>& ts) {\\n        if(root==NULL) return;\\n        \\n        if(root->left) inOrder(root->left, ts);\\n        ts.insert(root->val);\\n        if(root->right) inOrder(root->right, ts);\\n    }\\n    \\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        \\n        set<int> ts;\\n        inOrder(root, ts);\\n        vector<vector<int>> ans;\\n        \\n        for(int i=0; i<queries.size(); i++) {\\n            \\n            auto pos = ts.find(queries[i]);\\n            if(pos != ts.end()) {\\n                ans.push_back({queries[i], queries[i]});\\n            }\\n            else { \\n                int num1;\\n                int num2;\\n                \\n                auto smaller = ts.lower_bound(queries[i]);\\n                if (smaller == ts.begin()) {\\n                    num1 = -1;\\n                }\\n                else {\\n                    num1 = *(--smaller);\\n                }\\n                \\n                auto greater = ts.upper_bound(queries[i]);\\n                if (greater == ts.end()) {\\n                    num2 = -1;\\n                }\\n                else {\\n                    num2 = *greater;\\n                }\\n                    \\n                ans.push_back({num1, num2});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    void inOrder(TreeNode* root, set<int>& ts) {\\n        if(root==NULL) return;\\n        \\n        if(root->left) inOrder(root->left, ts);\\n        ts.insert(root->val);\\n        if(root->right) inOrder(root->right, ts);\\n    }\\n    \\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        \\n        set<int> ts;\\n        inOrder(root, ts);\\n        vector<vector<int>> ans;\\n        \\n        for(int i=0; i<queries.size(); i++) {\\n            \\n            auto pos = ts.find(queries[i]);\\n            if(pos != ts.end()) {\\n                ans.push_back({queries[i], queries[i]});\\n            }\\n            else { \\n                int num1;\\n                int num2;\\n                \\n                auto smaller = ts.lower_bound(queries[i]);\\n                if (smaller == ts.begin()) {\\n                    num1 = -1;\\n                }\\n                else {\\n                    num1 = *(--smaller);\\n                }\\n                \\n                auto greater = ts.upper_bound(queries[i]);\\n                if (greater == ts.end()) {\\n                    num2 = -1;\\n                }\\n                else {\\n                    num2 = *greater;\\n                }\\n                    \\n                ans.push_back({num1, num2});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831774,
                "title": "java-treeset-solution",
                "content": "# Approach\\nWe use the treeset functions to find the next greater and smallest in the bst.\\n\\nThe **lower()** method of TreeSet class in Java is used to return the greatest element in this set which is strictly less than the given element. If no such element exists in this TreeSet collection then this method returns a NULL.\\n\\nThe **higher()** method of TreeSet class in Java is used to return the least element in this set which is strictly greater than the given element ele. If no such element is there then this method returns NULL. \\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        int max = -1;\\n        int min = -1;\\n        TreeSet<Integer> set = new TreeSet<>();\\n        inorder(root, set);\\n        int idx = 0;\\n        for(int q : queries){\\n            ArrayList<Integer> base = new ArrayList<>();\\n            if(set.contains(q)){\\n                min = q;\\n                max = q;\\n            }\\n            else{\\n                Integer high = set.higher(q);\\n                if(high == null){\\n                    max = -1;\\n                } else{\\n                    max = high;\\n                }\\n                Integer low = set.lower(q);\\n                if(low == null){\\n                    min = -1;\\n                } else{\\n                    min = low;\\n                }\\n            }\\n            base.add(min);\\n            base.add(max);\\n            list.add(base);\\n        }\\n        return list;\\n    }\\n    public void inorder(TreeNode root, TreeSet<Integer> set){\\n        if(root == null){\\n            return;\\n        }\\n        inorder(root.left, set);\\n        set.add(root.val);\\n        inorder(root.right, set);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        int max = -1;\\n        int min = -1;\\n        TreeSet<Integer> set = new TreeSet<>();\\n        inorder(root, set);\\n        int idx = 0;\\n        for(int q : queries){\\n            ArrayList<Integer> base = new ArrayList<>();\\n            if(set.contains(q)){\\n                min = q;\\n                max = q;\\n            }\\n            else{\\n                Integer high = set.higher(q);\\n                if(high == null){\\n                    max = -1;\\n                } else{\\n                    max = high;\\n                }\\n                Integer low = set.lower(q);\\n                if(low == null){\\n                    min = -1;\\n                } else{\\n                    min = low;\\n                }\\n            }\\n            base.add(min);\\n            base.add(max);\\n            list.add(base);\\n        }\\n        return list;\\n    }\\n    public void inorder(TreeNode root, TreeSet<Integer> set){\\n        if(root == null){\\n            return;\\n        }\\n        inorder(root.left, set);\\n        set.add(root.val);\\n        inorder(root.right, set);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831766,
                "title": "java-simple-solution-using-ceil-and-floor-in-bst",
                "content": "```\\nclass Solution {\\n    int floor;\\n    int ceil;\\n\\n    public void floorCeilBSTHelper(TreeNode root, int key) {\\n        while (root != null) {\\n            if (root.val == key) {\\n                ceil = root.val;\\n                floor = root.val;\\n                return;\\n            }\\n\\n            if (key > root.val) {\\n                floor = root.val;\\n                root = root.right;\\n            } else {\\n                ceil = root.val;\\n                root = root.left;\\n            }\\n        }\\n        return;\\n    }\\n\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        for (int val : queries) {\\n            floor = -1;\\n            ceil = -1;\\n            List<Integer> list = new ArrayList<>();\\n            floorCeilBSTHelper(root, val);\\n            list.add(floor);\\n            list.add(ceil);\\n            ans.add(list);\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int floor;\\n    int ceil;\\n\\n    public void floorCeilBSTHelper(TreeNode root, int key) {\\n        while (root != null) {\\n            if (root.val == key) {\\n                ceil = root.val;\\n                floor = root.val;\\n                return;\\n            }\\n\\n            if (key > root.val) {\\n                floor = root.val;\\n                root = root.right;\\n            } else {\\n                ceil = root.val;\\n                root = root.left;\\n            }\\n        }\\n        return;\\n    }\\n\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        for (int val : queries) {\\n            floor = -1;\\n            ceil = -1;\\n            List<Integer> list = new ArrayList<>();\\n            floorCeilBSTHelper(root, val);\\n            list.add(floor);\\n            list.add(ceil);\\n            ans.add(list);\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831765,
                "title": "c-binary-search",
                "content": "```\\n    List<int> sortedValues;\\n    public IList<IList<int>> ClosestNodes(TreeNode root, IList<int> queries)\\n    {\\n        sortedValues = new List<int>();\\n        ReadNodeValues(root);\\n        int nodeCount = sortedValues.Count;\\n        int lowest = sortedValues[0];\\n        int highest = sortedValues[nodeCount-1];\\n\\n        IList<IList<int>> result = new List<IList<int>>();\\n        foreach (int query in queries)\\n        {\\n            int index = sortedValues.BinarySearch(query);\\n            if (index >= 0)\\n                result.Add(new int[] { sortedValues[index], sortedValues[index] });\\n            else\\n            {\\n                index = ~index;\\n                int min = -1;\\n                int max = -1;\\n\\n                if (query < highest)\\n                    max = sortedValues[index];\\n                if (query > lowest)\\n                    min = sortedValues[index-1];\\n                result.Add(new int[] { min, max });\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public void ReadNodeValues(TreeNode root) \\n    {\\n        if (root == null)\\n            return;\\n        ReadNodeValues(root.left);\\n        sortedValues.Add(root.val);\\n        ReadNodeValues(root.right);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    List<int> sortedValues;\\n    public IList<IList<int>> ClosestNodes(TreeNode root, IList<int> queries)\\n    {\\n        sortedValues = new List<int>();\\n        ReadNodeValues(root);\\n        int nodeCount = sortedValues.Count;\\n        int lowest = sortedValues[0];\\n        int highest = sortedValues[nodeCount-1];\\n\\n        IList<IList<int>> result = new List<IList<int>>();\\n        foreach (int query in queries)\\n        {\\n            int index = sortedValues.BinarySearch(query);\\n            if (index >= 0)\\n                result.Add(new int[] { sortedValues[index], sortedValues[index] });\\n            else\\n            {\\n                index = ~index;\\n                int min = -1;\\n                int max = -1;\\n\\n                if (query < highest)\\n                    max = sortedValues[index];\\n                if (query > lowest)\\n                    min = sortedValues[index-1];\\n                result.Add(new int[] { min, max });\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public void ReadNodeValues(TreeNode root) \\n    {\\n        if (root == null)\\n            return;\\n        ReadNodeValues(root.left);\\n        sortedValues.Add(root.val);\\n        ReadNodeValues(root.right);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2831760,
                "title": "python-binary-search",
                "content": "#### Intuition\\n\\n1. get value in order\\n2. binary search\\n\\nO(n + len(queries) * 2logn)\\n```python\\nclass Solution:\\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        # Input: root = [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries = [2,5,16]\\n        # Output: [[2,2],[4,6],[15,-1]]\\n        values = []\\n        def dfs(root):\\n            if not root: return\\n            \\n            dfs(root.left)\\n            values.append(root.val)\\n            dfs(root.right)\\n        dfs(root)\\n\\n        n = len(values)\\n        res = []\\n        for q in queries:\\n            tmp = []\\n            l, r = 0 , n-1\\n            while l < r:\\n                mid = r - (r-l)//2\\n                if values[mid] > q:\\n                    r = mid-1\\n                else:\\n                    l = mid\\n            tmp.append(values[l] if values[l] <= q else -1)\\n            \\n            l, r = 0 , n-1\\n            while l < r:\\n                mid = l + (r-l)//2\\n                if values[mid] < q:\\n                    l = mid+1\\n                else:\\n                    r = mid\\n            tmp.append(values[l] if values[l] >= q else -1)\\n            res.append(tmp)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```python\\nclass Solution:\\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        # Input: root = [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries = [2,5,16]\\n        # Output: [[2,2],[4,6],[15,-1]]\\n        values = []\\n        def dfs(root):\\n            if not root: return\\n            \\n            dfs(root.left)\\n            values.append(root.val)\\n            dfs(root.right)\\n        dfs(root)\\n\\n        n = len(values)\\n        res = []\\n        for q in queries:\\n            tmp = []\\n            l, r = 0 , n-1\\n            while l < r:\\n                mid = r - (r-l)//2\\n                if values[mid] > q:\\n                    r = mid-1\\n                else:\\n                    l = mid\\n            tmp.append(values[l] if values[l] <= q else -1)\\n            \\n            l, r = 0 , n-1\\n            while l < r:\\n                mid = l + (r-l)//2\\n                if values[mid] < q:\\n                    l = mid+1\\n                else:\\n                    r = mid\\n            tmp.append(values[l] if values[l] >= q else -1)\\n            res.append(tmp)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831753,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> list = new ArrayList<>();\\n        inorder(root, list);\\n        for(int q : queries) {\\n            int left = 0;\\n            int right = list.size()-1;\\n            int minInd = -1;\\n            while(left <= right) {\\n                int mid = (left + right) / 2;\\n                if(list.get(mid) == q) {\\n                    minInd = mid;\\n                    break;\\n                }\\n                if(list.get(mid) < q) {\\n                    minInd = mid;\\n                    left = mid + 1;\\n                } else {\\n                    right = mid - 1;\\n                }\\n            }\\n            \\n            int min = -1;\\n            if(minInd != -1) min = list.get(minInd);\\n            \\n            int max = -1;\\n            if(minInd == -1) max = list.get(0);\\n            else if(list.get(minInd) == q) max = list.get(minInd);\\n            else if(minInd < list.size()-1) max = list.get(minInd+1);\\n            \\n            res.add(List.of(min, max));\\n        }\\n        \\n        return res;\\n    }\\n    \\n    void inorder(TreeNode root, List<Integer> list) {\\n        if(root == null) return;\\n        inorder(root.left, list);\\n        list.add(root.val);\\n        inorder(root.right, list);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> list = new ArrayList<>();\\n        inorder(root, list);\\n        for(int q : queries) {\\n            int left = 0;\\n            int right = list.size()-1;\\n            int minInd = -1;\\n            while(left <= right) {\\n                int mid = (left + right) / 2;\\n                if(list.get(mid) == q) {\\n                    minInd = mid;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2831751,
                "title": "easy-efficient-clean-code",
                "content": "// An alternative and possibly nicer approach would be to balance the given BST for guranteed O(log n) calls\\n```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\n#define pb push_back\\npublic:\\nvoid getV(TreeNode*nd, vi(TreeNode*)&v){\\n    if(!nd){\\n        return;\\n    }\\n    getV(nd->left, v);\\n    v.pb(nd);\\n    getV(nd->right, v);\\n}\\nint getMax(const vi(TreeNode*)&v, ll it){ // B.S. to get max number not greater than given node\\n    ll l=0, r=v.size()-1, ans=-1;\\n    while(l<=r){\\n        ll m=l+((r-l)>>1);\\n        if(v[m]->val==it){\\n            return it;\\n        }\\n        if(v[m]->val>it){\\n            r=m-1;\\n        }\\n        else{\\n            ans=v[m]->val, l=m+1;\\n        }\\n    }\\n    return ans;\\n}\\nint getMin(const vi(TreeNode*)&v, ll it){ // B.S. to get min number not smaller than given node\\n    ll l=0, r=v.size()-1, ans=-1;\\n    while(l<=r){\\n        ll m=l+((r-l)>>1);\\n        if(v[m]->val==it){\\n            return it;\\n        }\\n        if(v[m]->val<it){\\n            l=m+1;\\n        }\\n        else{\\n            ans=v[m]->val, r=m-1;\\n        }\\n    }\\n    return ans;\\n}\\nvector<vector<int>> closestNodes(TreeNode* root, vector<int>&q) {\\n    vi(TreeNode*)v;\\n    getV(root, v); // form a sorted array of BST elements\\n    ll n=q.size();\\n    vi(vi(int))ans(n);\\n    for(ll i=0;i<n;++i){\\n        ans[i]={getMax(v, q[i]), getMin(v, q[i])};\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\n#define pb push_back\\npublic:\\nvoid getV(TreeNode*nd, vi(TreeNode*)&v){\\n    if(!nd){\\n        return;\\n    }\\n    getV(nd->left, v);\\n    v.pb(nd);\\n    getV(nd->right, v);\\n}\\nint getMax(const vi(TreeNode*)&v, ll it){ // B.S. to get max number not greater than given node\\n    ll l=0, r=v.size()-1, ans=-1;\\n    while(l<=r){\\n        ll m=l+((r-l)>>1);\\n        if(v[m]->val==it){\\n            return it;\\n        }\\n        if(v[m]->val>it){\\n            r=m-1;\\n        }\\n        else{\\n            ans=v[m]->val, l=m+1;\\n        }\\n    }\\n    return ans;\\n}\\nint getMin(const vi(TreeNode*)&v, ll it){ // B.S. to get min number not smaller than given node\\n    ll l=0, r=v.size()-1, ans=-1;\\n    while(l<=r){\\n        ll m=l+((r-l)>>1);\\n        if(v[m]->val==it){\\n            return it;\\n        }\\n        if(v[m]->val<it){\\n            l=m+1;\\n        }\\n        else{\\n            ans=v[m]->val, r=m-1;\\n        }\\n    }\\n    return ans;\\n}\\nvector<vector<int>> closestNodes(TreeNode* root, vector<int>&q) {\\n    vi(TreeNode*)v;\\n    getV(root, v); // form a sorted array of BST elements\\n    ll n=q.size();\\n    vi(vi(int))ans(n);\\n    for(ll i=0;i<n;++i){\\n        ans[i]={getMax(v, q[i]), getMin(v, q[i])};\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831750,
                "title": "javascript-very-simple-binary-search",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number[]} queries\\n * @return {number[][]}\\n */\\nvar closestNodes = function(root, queries) {\\n    let arr = [];\\n    let ans = [];\\n    \\n\\t// Inorder traversal to get value in sorted order\\n    function solve(root) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        solve(root.left);\\n        arr.push(root.val);\\n        solve(root.right);\\n    }\\n    \\n    solve(root);\\n    \\n    let left = 0, right = arr.length-1;\\n    for (let q of queries) {    \\n        let first = searchFirst(left, right, q); // lower bound\\n        \\n        if (arr[first] == q) {\\n            ans.push([q, q]);\\n        } else {\\n            let last = searchLast(left, right, q); // upper bound\\n            \\n            if (first == -1 && last == -1) {\\n                ans.push([-1, - 1]);\\n            }\\n            else if (first == -1) {\\n                ans.push([-1, arr[last]]);\\n            }\\n            else if (last == -1) {\\n                ans.push([arr[first], -1]);\\n            }\\n            else {\\n                ans.push([arr[first], arr[last]]);\\n            }\\n        }\\n    }\\n    \\n    return ans;\\n    \\n    \\n    function searchFirst(left, right, target) {\\n        let result = -1;\\n        while (left <= right) {\\n            let mid = parseInt((left + right)/2);\\n        \\n            \\n            if (arr[mid] <= target) {\\n                result = mid;\\n                left = mid + 1;\\n            }\\n            else if (arr[mid] > target) {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    function searchLast(left, right, target) {\\n        let result = -1;\\n        while (left <= right) {\\n            let mid = parseInt((left + right)/2);\\n        \\n            \\n            if (arr[mid] < target) {\\n                left = mid + 1;\\n            }\\n            else if (arr[mid] >= target) {\\n                result = mid;\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number[]} queries\\n * @return {number[][]}\\n */\\nvar closestNodes = function(root, queries) {\\n    let arr = [];\\n    let ans = [];\\n    \\n\\t// Inorder traversal to get value in sorted order\\n    function solve(root) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        solve(root.left);\\n        arr.push(root.val);\\n        solve(root.right);\\n    }\\n    \\n    solve(root);\\n    \\n    let left = 0, right = arr.length-1;\\n    for (let q of queries) {    \\n        let first = searchFirst(left, right, q); // lower bound\\n        \\n        if (arr[first] == q) {\\n            ans.push([q, q]);\\n        } else {\\n            let last = searchLast(left, right, q); // upper bound\\n            \\n            if (first == -1 && last == -1) {\\n                ans.push([-1, - 1]);\\n            }\\n            else if (first == -1) {\\n                ans.push([-1, arr[last]]);\\n            }\\n            else if (last == -1) {\\n                ans.push([arr[first], -1]);\\n            }\\n            else {\\n                ans.push([arr[first], arr[last]]);\\n            }\\n        }\\n    }\\n    \\n    return ans;\\n    \\n    \\n    function searchFirst(left, right, target) {\\n        let result = -1;\\n        while (left <= right) {\\n            let mid = parseInt((left + right)/2);\\n        \\n            \\n            if (arr[mid] <= target) {\\n                result = mid;\\n                left = mid + 1;\\n            }\\n            else if (arr[mid] > target) {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    function searchLast(left, right, target) {\\n        let result = -1;\\n        while (left <= right) {\\n            let mid = parseInt((left + right)/2);\\n        \\n            \\n            if (arr[mid] < target) {\\n                left = mid + 1;\\n            }\\n            else if (arr[mid] >= target) {\\n                result = mid;\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2831742,
                "title": "not-worked",
                "content": "NlogN Solution is not worked giving TLE \\nDon\\'t know Why!!",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2831730,
                "title": "java-easy-to-understand-treeset-solution-explanation-with-comments",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        \\n        // first create a tree set and add all node values to this set\\n        TreeSet<Integer> set = new TreeSet<>();\\n        \\n        // perform any tree traversal \\n        inOrder(root,set);\\n        \\n        // create a result array\\n        List<List<Integer>> result = new ArrayList<>(queries.size());\\n        \\n        // go through each query\\n        for(int i=0;i<queries.size();i++){\\n            \\n            result.add(new ArrayList<>());\\n            int largest = -1;\\n            \\n            if(set.floor(queries.get(i))!=null){\\n                largest = set.floor(queries.get(i));\\n            }\\n            \\n            int smallest = -1;\\n            if(set.ceiling(queries.get(i))!=null){\\n                smallest = set.ceiling(queries.get(i));\\n            }\\n            \\n            result.get(result.size()-1).add(largest);\\n            result.get(result.size()-1).add(smallest);\\n        }\\n        return result;\\n\\n    }\\n\\n    private void inOrder(TreeNode root, TreeSet set){\\n        if(root==null){\\n            return;\\n        }\\n        inOrder(root.left, set);\\n        set.add(root.val);\\n        inOrder(root.right, set);\\n        return;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        \\n        // first create a tree set and add all node values to this set\\n        TreeSet<Integer> set = new TreeSet<>();\\n        \\n        // perform any tree traversal \\n        inOrder(root,set);\\n        \\n        // create a result array\\n        List<List<Integer>> result = new ArrayList<>(queries.size());\\n        \\n        // go through each query\\n        for(int i=0;i<queries.size();i++){\\n            \\n            result.add(new ArrayList<>());\\n            int largest = -1;\\n            \\n            if(set.floor(queries.get(i))!=null){\\n                largest = set.floor(queries.get(i));\\n            }\\n            \\n            int smallest = -1;\\n            if(set.ceiling(queries.get(i))!=null){\\n                smallest = set.ceiling(queries.get(i));\\n            }\\n            \\n            result.get(result.size()-1).add(largest);\\n            result.get(result.size()-1).add(smallest);\\n        }\\n        return result;\\n\\n    }\\n\\n    private void inOrder(TreeNode root, TreeSet set){\\n        if(root==null){\\n            return;\\n        }\\n        inOrder(root.left, set);\\n        set.add(root.val);\\n        inOrder(root.right, set);\\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831721,
                "title": "c-search-binary-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        \\n        vector<vector<int>> res;\\n        for (auto x : queries) {\\n            int lb = -1, hb = -1;\\n            TreeNode* cur = root;\\n            while (cur) {\\n                if (cur->val == x) { lb=hb=x; break; }\\n                else if (cur->val <= x) { lb=cur->val; cur=cur->right; }\\n                else if (cur->val >= x) { hb=cur->val; cur=cur->left; }\\n            }\\n            res.push_back({lb, hb});\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        \\n        vector<vector<int>> res;\\n        for (auto x : queries) {\\n            int lb = -1, hb = -1;\\n            TreeNode* cur = root;\\n            while (cur) {\\n                if (cur->val == x) { lb=hb=x; break; }\\n                else if (cur->val <= x) { lb=cur->val; cur=cur->right; }\\n                else if (cur->val >= x) { hb=cur->val; cur=cur->left; }\\n            }\\n            res.push_back({lb, hb});\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831715,
                "title": "my-weird-binary-search-solution",
                "content": "# Overview\\nappending an inorder traversal node values to an array from a BST tree will give you a sorted list in ascending order which you can use for a binary search.\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        output = []\\n        inorder = []\\n        \\n        def dfs(node):\\n            if not node:\\n                return\\n            \\n            dfs(node.left)\\n            inorder.append(node.val)\\n            dfs(node.right)\\n            \\n        dfs(root)\\n        for q in queries:\\n            smaller, greater = -1, -1\\n            l, r = 0, len(inorder)\\n            while l < r:\\n                m = l + (r - l) // 2\\n                if inorder[m] >= q:\\n                    r = m\\n                else:\\n                    l = m + 1\\n                    \\n            greater = inorder[l] if l < len(inorder) else -1\\n            if l == len(inorder):\\n                smaller = inorder[-1]\\n            elif inorder[l] == q:\\n                smaller = q\\n            elif l - 1 >= 0 and inorder[l - 1] < q:\\n                smaller = inorder[l - 1]\\n            \\n            output.append([smaller, greater])\\n        \\n        \\n        return output\\n            \\n            \\n            \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        output = []\\n        inorder = []\\n        \\n        def dfs(node):\\n            if not node:\\n                return\\n            \\n            dfs(node.left)\\n            inorder.append(node.val)\\n            dfs(node.right)\\n            \\n        dfs(root)\\n        for q in queries:\\n            smaller, greater = -1, -1\\n            l, r = 0, len(inorder)\\n            while l < r:\\n                m = l + (r - l) // 2\\n                if inorder[m] >= q:\\n                    r = m\\n                else:\\n                    l = m + 1\\n                    \\n            greater = inorder[l] if l < len(inorder) else -1\\n            if l == len(inorder):\\n                smaller = inorder[-1]\\n            elif inorder[l] == q:\\n                smaller = q\\n            elif l - 1 >= 0 and inorder[l - 1] < q:\\n                smaller = inorder[l - 1]\\n            \\n            output.append([smaller, greater])\\n        \\n        \\n        return output\\n            \\n            \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831712,
                "title": "c-binary-search-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void floorCeilBSTHelper(TreeNode* root, int key, int& floor,\\n                        int& ceil){\\n \\n    while (root) {\\n \\n        if (root->val == key) {\\n            ceil = root->val;\\n            floor = root->val;\\n            return;\\n        }\\n \\n        if (key > root->val) {\\n            floor = root->val;\\n            root = root->right;\\n        }\\n        else {\\n            ceil = root->val;\\n            root = root->left;\\n        }\\n    }\\n    return;\\n}\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<vector<int>>ans;\\n  \\n        for(int i=0;i<queries.size();i++){\\n            int ans1=-1,ans2=-1;\\n            floorCeilBSTHelper(root,queries[i],ans1,ans2);\\n            ans.push_back({ans1,ans2});\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void floorCeilBSTHelper(TreeNode* root, int key, int& floor,\\n                        int& ceil){\\n \\n    while (root) {\\n \\n        if (root->val == key) {\\n            ceil = root->val;\\n            floor = root->val;\\n            return;\\n        }\\n \\n        if (key > root->val) {\\n            floor = root->val;\\n            root = root->right;\\n        }\\n        else {\\n            ceil = root->val;\\n            root = root->left;\\n        }\\n    }\\n    return;\\n}\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<vector<int>>ans;\\n  \\n        for(int i=0;i<queries.size();i++){\\n            int ans1=-1,ans2=-1;\\n            floorCeilBSTHelper(root,queries[i],ans1,ans2);\\n            ans.push_back({ans1,ans2});\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831697,
                "title": "easy-binary-search-upper-bound-lower-bound",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& arr,int num){\\n    int ans = -1, start = 0,end = arr.size()-1;\\n    \\n    while(start <= end){\\n        int mid =  ((end-start)/2) + start;\\n        if(arr[mid] <= num){\\n            ans = arr[mid], start = mid+1;\\n        } else   end = mid-1;\\n    }\\n    return ans;\\n}\\n\\n    int findMax(vector<int>& arr,int num){\\n        int ans = -1;\\n        int start = 0;\\n        int end = arr.size()-1;\\n\\n        while(start <= end){\\n            int mid =  ((end-start)/2) + start;\\n\\n            if(arr[mid] >= num){\\n                ans = arr[mid], end = mid-1;\\n            } else    start = mid+1;\\n        }\\n        return ans;\\n    }\\n    \\n   \\n    void inorder(TreeNode* root,vector<int>&res){\\n        if(!root) return;\\n        inorder(root->left,res);\\n        res.push_back(root->val);\\n        inorder(root->right,res);\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<vector<int>>ans;\\n        vector<int>res;\\n        inorder(root,res);\\n        \\n        for(auto q:queries){\\n            ans.push_back({findMin(res, q),findMax(res,q)});\\n        }\\n        return ans;\\n   }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& arr,int num){\\n    int ans = -1, start = 0,end = arr.size()-1;\\n    \\n    while(start <= end){\\n        int mid =  ((end-start)/2) + start;\\n        if(arr[mid] <= num){\\n            ans = arr[mid], start = mid+1;\\n        } else   end = mid-1;\\n    }\\n    return ans;\\n}\\n\\n    int findMax(vector<int>& arr,int num){\\n        int ans = -1;\\n        int start = 0;\\n        int end = arr.size()-1;\\n\\n        while(start <= end){\\n            int mid =  ((end-start)/2) + start;\\n\\n            if(arr[mid] >= num){\\n                ans = arr[mid], end = mid-1;\\n            } else    start = mid+1;\\n        }\\n        return ans;\\n    }\\n    \\n   \\n    void inorder(TreeNode* root,vector<int>&res){\\n        if(!root) return;\\n        inorder(root->left,res);\\n        res.push_back(root->val);\\n        inorder(root->right,res);\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<vector<int>>ans;\\n        vector<int>res;\\n        inorder(root,res);\\n        \\n        for(auto q:queries){\\n            ans.push_back({findMin(res, q),findMax(res,q)});\\n        }\\n        return ans;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831695,
                "title": "bst-to-array-two-pointers-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector< vector<int> > ans(queries.size());\\n        vector< pair<int, int> > nq;\\n        for(int i=0;i<queries.size();i++) {\\n            pair<int,int> temp = {queries[i], i};\\n            nq.push_back(temp);\\n        }\\n        vector<int> arr;\\n        \\n        bstToArray(arr, root);\\n        sort(nq.begin(),nq.end());\\n        sort(arr.begin(), arr.end());\\n        \\n        \\n        int i=0, j=0;\\n        while(i<arr.size() && j<nq.size()) {\\n            cout<<nq[j].first<<\" \";\\n            if(nq[j].first == arr[i]) {\\n                ans[nq[j].second].push_back(arr[i]);\\n                ans[nq[j].second].push_back(arr[i]);\\n                j++;\\n            } else if(nq[j].first > arr[i]) {\\n                i++;\\n            } else {\\n                if(i>0) {\\n                    ans[nq[j].second].push_back(arr[i-1]);\\n                    ans[nq[j].second].push_back(arr[i]);\\n                } else{\\n                    ans[nq[j].second].push_back(-1);\\n                    ans[nq[j].second].push_back(arr[i]);\\n                }\\n                j++;\\n            }\\n            \\n            \\n        }\\n        while(j<nq.size()) {\\n                ans[nq[j].second].push_back(arr.back());\\n                ans[nq[j].second].push_back(-1);\\n                j++;\\n            }\\n\\n        return ans;\\n        \\n    }\\n    \\n    void bstToArray(vector<int> &arr,TreeNode* root){\\n        if(root == nullptr)return;\\n        arr.push_back(root->val);\\n        bstToArray(arr, root->left);\\n        bstToArray(arr, root->right);\\n    }\\n    \\n  \\n};\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Binary Search Tree",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector< vector<int> > ans(queries.size());\\n        vector< pair<int, int> > nq;\\n        for(int i=0;i<queries.size();i++) {\\n            pair<int,int> temp = {queries[i], i};\\n            nq.push_back(temp);\\n        }\\n        vector<int> arr;\\n        \\n        bstToArray(arr, root);\\n        sort(nq.begin(),nq.end());\\n        sort(arr.begin(), arr.end());\\n        \\n        \\n        int i=0, j=0;\\n        while(i<arr.size() && j<nq.size()) {\\n            cout<<nq[j].first<<\" \";\\n            if(nq[j].first == arr[i]) {\\n                ans[nq[j].second].push_back(arr[i]);\\n                ans[nq[j].second].push_back(arr[i]);\\n                j++;\\n            } else if(nq[j].first > arr[i]) {\\n                i++;\\n            } else {\\n                if(i>0) {\\n                    ans[nq[j].second].push_back(arr[i-1]);\\n                    ans[nq[j].second].push_back(arr[i]);\\n                } else{\\n                    ans[nq[j].second].push_back(-1);\\n                    ans[nq[j].second].push_back(arr[i]);\\n                }\\n                j++;\\n            }\\n            \\n            \\n        }\\n        while(j<nq.size()) {\\n                ans[nq[j].second].push_back(arr.back());\\n                ans[nq[j].second].push_back(-1);\\n                j++;\\n            }\\n\\n        return ans;\\n        \\n    }\\n    \\n    void bstToArray(vector<int> &arr,TreeNode* root){\\n        if(root == nullptr)return;\\n        arr.push_back(root->val);\\n        bstToArray(arr, root->left);\\n        bstToArray(arr, root->right);\\n    }\\n    \\n  \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2831681,
                "title": "java-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n        public List<List<Integer>> closestNodes(TreeNode root, List<Integer> q) {\\n        TreeSet<Integer> al = new TreeSet<>();\\n        inorder(root,al);\\n        List<List<Integer>> ans = new ArrayList<>();\\n        int low = al.first();\\n        int high = al.last();\\n        for(int i : q){\\n            int one = -1;\\n            if(i >= low){\\n                one = al.floor(i);\\n            }\\n            int two = -1;\\n            if(i <= high){\\n                two = al.ceiling(i);\\n            }\\n            ArrayList<Integer> a1 = new ArrayList<>();\\n            a1.add(one);a1.add(two);\\n            ans.add(a1);\\n        }\\n        return ans;\\n    }\\n    public void inorder(TreeNode root,TreeSet<Integer> al){\\n        if(root != null){\\n            inorder(root.left,al);\\n            al.add(root.val);\\n            inorder(root.right,al);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n        public List<List<Integer>> closestNodes(TreeNode root, List<Integer> q) {\\n        TreeSet<Integer> al = new TreeSet<>();\\n        inorder(root,al);\\n        List<List<Integer>> ans = new ArrayList<>();\\n        int low = al.first();\\n        int high = al.last();\\n        for(int i : q){\\n            int one = -1;\\n            if(i >= low){\\n                one = al.floor(i);\\n            }\\n            int two = -1;\\n            if(i <= high){\\n                two = al.ceiling(i);\\n            }\\n            ArrayList<Integer> a1 = new ArrayList<>();\\n            a1.add(one);a1.add(two);\\n            ans.add(a1);\\n        }\\n        return ans;\\n    }\\n    public void inorder(TreeNode root,TreeSet<Integer> al){\\n        if(root != null){\\n            inorder(root.left,al);\\n            al.add(root.val);\\n            inorder(root.right,al);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831672,
                "title": "java-treeset-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        TreeSet<Integer> treeSet = new TreeSet<>();\\n        convertTreeToSet(root, treeSet);\\n        List<List<Integer>> result = new ArrayList<>();\\n        for (int query : queries) {\\n            List<Integer> queryResult = new ArrayList<>();\\n            Integer floorValue = treeSet.floor(query);\\n            Integer ceilingValue = treeSet.ceiling(query);\\n            queryResult.add(floorValue != null ? floorValue : -1);\\n            queryResult.add(ceilingValue != null ? ceilingValue : -1);\\n            result.add(queryResult);\\n        }\\n        return result;\\n    }\\n    public void convertTreeToSet(TreeNode root, TreeSet<Integer> treeSet) {\\n        if (root == null) {\\n            return;\\n        }\\n        treeSet.add(root.val);\\n        convertTreeToSet(root.left, treeSet);\\n        convertTreeToSet(root.right, treeSet);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        TreeSet<Integer> treeSet = new TreeSet<>();\\n        convertTreeToSet(root, treeSet);\\n        List<List<Integer>> result = new ArrayList<>();\\n        for (int query : queries) {\\n            List<Integer> queryResult = new ArrayList<>();\\n            Integer floorValue = treeSet.floor(query);\\n            Integer ceilingValue = treeSet.ceiling(query);\\n            queryResult.add(floorValue != null ? floorValue : -1);\\n            queryResult.add(ceilingValue != null ? ceilingValue : -1);\\n            result.add(queryResult);\\n        }\\n        return result;\\n    }\\n    public void convertTreeToSet(TreeNode root, TreeSet<Integer> treeSet) {\\n        if (root == null) {\\n            return;\\n        }\\n        treeSet.add(root.val);\\n        convertTreeToSet(root.left, treeSet);\\n        convertTreeToSet(root.right, treeSet);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831659,
                "title": "c-inorder-tree-binary-search-lower-bound",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int>&ans){\\n        if(root){\\n            inorder(root->left, ans);\\n            ans.push_back(root->val);\\n            inorder(root->right, ans);\\n        }\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int>tmp;\\n        inorder(root,tmp);\\n        vector<vector<int>>ans;\\n        for(auto q: queries){\\n            int l=lower_bound(tmp.begin(), tmp.end(), q)-tmp.begin();\\n            if(l>=0 && l<=tmp.size()-1){\\n                if(tmp[l]==q) ans.push_back({tmp[l], tmp[l]});\\n                else if(l>0 && tmp[l-1]<q && tmp[l]>q) ans.push_back({tmp[l-1], tmp[l]});\\n                else ans.push_back({-1, tmp[l]});\\n            }\\n            else ans.push_back({tmp[l-1], -1});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int>&ans){\\n        if(root){\\n            inorder(root->left, ans);\\n            ans.push_back(root->val);\\n            inorder(root->right, ans);\\n        }\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int>tmp;\\n        inorder(root,tmp);\\n        vector<vector<int>>ans;\\n        for(auto q: queries){\\n            int l=lower_bound(tmp.begin(), tmp.end(), q)-tmp.begin();\\n            if(l>=0 && l<=tmp.size()-1){\\n                if(tmp[l]==q) ans.push_back({tmp[l], tmp[l]});\\n                else if(l>0 && tmp[l-1]<q && tmp[l]>q) ans.push_back({tmp[l-1], tmp[l]});\\n                else ans.push_back({-1, tmp[l]});\\n            }\\n            else ans.push_back({tmp[l-1], -1});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831658,
                "title": "degenerate",
                "content": "Did anyone else forget to account for degenerate BSTs in their time complexity analysis? O(n log(n)) isn\\'t guaranteed right off the bat...\\n![image](https://assets.leetcode.com/users/images/57d5597c-cfe8-444e-a387-a713a0478108_1668915925.2175505.png)\\n",
                "solutionTags": [],
                "code": "Did anyone else forget to account for degenerate BSTs in their time complexity analysis? O(n log(n)) isn\\'t guaranteed right off the bat...\\n![image](https://assets.leetcode.com/users/images/57d5597c-cfe8-444e-a387-a713a0478108_1668915925.2175505.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 4099129,
                "title": "inorder-traversal-binary-search-game-over-explained",
                "content": "# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    //standard function for storing in-order traversal in a vector\\n    void getInorder(TreeNode* root, vector<int>& inorder)\\n    {\\n        if(root == NULL) return;\\n        getInorder(root->left,inorder);\\n        inorder.push_back(root->val);\\n        getInorder(root->right,inorder);\\n    }\\npublic:\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int> inorder;\\n        vector<vector<int>> ans;\\n        getInorder(root,inorder); //store the inorder traversal in a vector\\n        int n = inorder.size();\\n\\n        for(auto q : queries)\\n        {\\n            if(q < inorder[0]) { //if it is the smaller than the smallest number present in BST\\n              ans.push_back({-1,inorder[0]});\\n            }\\n            else if(q > inorder[n-1]) { //if it is larger than the largest number present in BST\\n              ans.push_back({inorder[n-1],-1});\\n            }\\n            else \\n            {\\n               int i = lower_bound(inorder.begin(),inorder.end(),q) - inorder.begin();\\n                if(inorder[i] == q) //if exact number if found\\n                  ans.push_back({q,q}); //then, push the number itself twice\\n                else\\n                  ans.push_back({inorder[i-1],inorder[i]});\\n            }   //otherwise, push one smaller and one larger number\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    //standard function for storing in-order traversal in a vector\\n    void getInorder(TreeNode* root, vector<int>& inorder)\\n    {\\n        if(root == NULL) return;\\n        getInorder(root->left,inorder);\\n        inorder.push_back(root->val);\\n        getInorder(root->right,inorder);\\n    }\\npublic:\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int> inorder;\\n        vector<vector<int>> ans;\\n        getInorder(root,inorder); //store the inorder traversal in a vector\\n        int n = inorder.size();\\n\\n        for(auto q : queries)\\n        {\\n            if(q < inorder[0]) { //if it is the smaller than the smallest number present in BST\\n              ans.push_back({-1,inorder[0]});\\n            }\\n            else if(q > inorder[n-1]) { //if it is larger than the largest number present in BST\\n              ans.push_back({inorder[n-1],-1});\\n            }\\n            else \\n            {\\n               int i = lower_bound(inorder.begin(),inorder.end(),q) - inorder.begin();\\n                if(inorder[i] == q) //if exact number if found\\n                  ans.push_back({q,q}); //then, push the number itself twice\\n                else\\n                  ans.push_back({inorder[i-1],inorder[i]});\\n            }   //otherwise, push one smaller and one larger number\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045259,
                "title": "better-than-100-o-1-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(no of queries*log(no of nodes))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<Integer> ordered = new ArrayList<>();\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        inOrder(root);\\n        List<List<Integer>> res = new ArrayList<>();\\n        int n = ordered.size()-1;\\n        for(int query: queries){\\n            if(query<ordered.get(0)){\\n               res.add(List.of(-1,ordered.get(0))); \\n            }else if(query>ordered.get(n)){\\n\\n               res.add(List.of(ordered.get(n),-1)); \\n            }else{ \\n               int index= binarySearch(ordered,0,n,n/2,query);\\n               if(index==-1){\\n                res.add(List.of(query,query));\\n                }else{\\n                 res.add(List.of(ordered.get(index-1),ordered.get(index)));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    public void inOrder(TreeNode root){\\n        if(root==null) return;\\n        inOrder(root.left);\\n        ordered.add(root.val);\\n        inOrder(root.right);\\n    }\\n    public int binarySearch(List<Integer> ordered, int start , int end , int mid, int num){\\n        if(ordered.get(mid)==num) return -1;\\n        if(start>=end) return start;\\n        if(ordered.get(mid)>num){\\n            end = mid;\\n            mid=start+(end-start)/2;\\n          return   binarySearch(ordered,start,end,mid,num);\\n        }else{\\n            start = mid+1;\\n            mid=start+(end-start)/2;\\n           return  binarySearch(ordered,start,end,mid,num);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<Integer> ordered = new ArrayList<>();\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        inOrder(root);\\n        List<List<Integer>> res = new ArrayList<>();\\n        int n = ordered.size()-1;\\n        for(int query: queries){\\n            if(query<ordered.get(0)){\\n               res.add(List.of(-1,ordered.get(0))); \\n            }else if(query>ordered.get(n)){\\n\\n               res.add(List.of(ordered.get(n),-1)); \\n            }else{ \\n               int index= binarySearch(ordered,0,n,n/2,query);\\n               if(index==-1){\\n                res.add(List.of(query,query));\\n                }else{\\n                 res.add(List.of(ordered.get(index-1),ordered.get(index)));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    public void inOrder(TreeNode root){\\n        if(root==null) return;\\n        inOrder(root.left);\\n        ordered.add(root.val);\\n        inOrder(root.right);\\n    }\\n    public int binarySearch(List<Integer> ordered, int start , int end , int mid, int num){\\n        if(ordered.get(mid)==num) return -1;\\n        if(start>=end) return start;\\n        if(ordered.get(mid)>num){\\n            end = mid;\\n            mid=start+(end-start)/2;\\n          return   binarySearch(ordered,start,end,mid,num);\\n        }else{\\n            start = mid+1;\\n            mid=start+(end-start)/2;\\n           return  binarySearch(ordered,start,end,mid,num);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010633,
                "title": "c-easy-solution-inorder-traversal-lower-bound",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void cal(TreeNode* root , vector<int>&inorder)\\n    {\\n        \\n        if(root==NULL)\\n            return ;  \\n        \\n        cal(root->left , inorder );\\n          inorder.push_back(root->val) ;\\n        cal(root->right , inorder );\\n\\n        \\n    }\\n    \\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n    \\n        vector<vector<int>> ans ;\\n        vector<int>inorder ; \\n        \\n        cal(root  , inorder ) ;\\n        \\n        for(auto it: queries )\\n        {\\n            \\n            int ind = lower_bound(begin(inorder) , end(inorder) , it )-inorder.begin() ; \\n            \\n            if(ind==0)\\n            {\\n                 if(inorder[0]==it)\\n                 {\\n                     ans.push_back({it, it }) ;\\n                 }\\n                else if(inorder[0]>it)\\n                {\\n                     ans.push_back({-1 , inorder[0] }) ;\\n                }\\n            }\\n            else if(ind==inorder.size())\\n            {\\n             \\n                     ans.push_back({inorder[ind-1] , -1 }) ;\\n            }\\n            else\\n            {\\n                 if(inorder[ind]==it)\\n                 {\\n                     ans.push_back({it, it }) ;\\n                 }\\n                else if(inorder[ind]>it)\\n                {\\n                     ans.push_back({inorder[ind-1] , inorder[ind] }) ;\\n                }\\n            }\\n            \\n        }\\n       return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void cal(TreeNode* root , vector<int>&inorder)\\n    {\\n        \\n        if(root==NULL)\\n            return ;  \\n        \\n        cal(root->left , inorder );\\n          inorder.push_back(root->val) ;\\n        cal(root->right , inorder );\\n\\n        \\n    }\\n    \\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n    \\n        vector<vector<int>> ans ;\\n        vector<int>inorder ; \\n        \\n        cal(root  , inorder ) ;\\n        \\n        for(auto it: queries )\\n        {\\n            \\n            int ind = lower_bound(begin(inorder) , end(inorder) , it )-inorder.begin() ; \\n            \\n            if(ind==0)\\n            {\\n                 if(inorder[0]==it)\\n                 {\\n                     ans.push_back({it, it }) ;\\n                 }\\n                else if(inorder[0]>it)\\n                {\\n                     ans.push_back({-1 , inorder[0] }) ;\\n                }\\n            }\\n            else if(ind==inorder.size())\\n            {\\n             \\n                     ans.push_back({inorder[ind-1] , -1 }) ;\\n            }\\n            else\\n            {\\n                 if(inorder[ind]==it)\\n                 {\\n                     ans.push_back({it, it }) ;\\n                 }\\n                else if(inorder[ind]>it)\\n                {\\n                     ans.push_back({inorder[ind-1] , inorder[ind] }) ;\\n                }\\n            }\\n            \\n        }\\n       return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993628,
                "title": "simple-c-code-self-explainatory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(nlogN)\\n\\n- Space complexity:\\n- O(N)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int>inorder;\\n    void in(TreeNode* root){\\n        if(!root) return;\\n\\n        in(root->left);\\n        inorder.push_back(root->val);\\n        in(root->right);\\n    }\\n    vector<int>solve(int k){\\n        int mn=-1,mx=-1;\\n\\n        int i=lower_bound(inorder.begin(),inorder.end(),k)-inorder.begin();\\n\\n        if(i>0 and i<inorder.size()){\\n            if(inorder[i]==k) return {inorder[i],inorder[i]};\\n\\n            else return {inorder[i-1],inorder[i]};\\n        }\\n        if(i==0){\\n            if(inorder[i]==k) return {inorder[i],inorder[i]};\\n            else return {-1,inorder[i]};\\n        }\\n        if(i==inorder.size()){\\n            return {inorder[i-1],-1};\\n        }\\n        return {-1,-1};\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        inorder.clear();\\n        in(root);\\n\\n        for(auto i:inorder) cout<<i<<\" \";\\n\\n        vector<vector<int>>ans;\\n\\n        for(auto i:queries){\\n            ans.push_back(solve(i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int>inorder;\\n    void in(TreeNode* root){\\n        if(!root) return;\\n\\n        in(root->left);\\n        inorder.push_back(root->val);\\n        in(root->right);\\n    }\\n    vector<int>solve(int k){\\n        int mn=-1,mx=-1;\\n\\n        int i=lower_bound(inorder.begin(),inorder.end(),k)-inorder.begin();\\n\\n        if(i>0 and i<inorder.size()){\\n            if(inorder[i]==k) return {inorder[i],inorder[i]};\\n\\n            else return {inorder[i-1],inorder[i]};\\n        }\\n        if(i==0){\\n            if(inorder[i]==k) return {inorder[i],inorder[i]};\\n            else return {-1,inorder[i]};\\n        }\\n        if(i==inorder.size()){\\n            return {inorder[i-1],-1};\\n        }\\n        return {-1,-1};\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        inorder.clear();\\n        in(root);\\n\\n        for(auto i:inorder) cout<<i<<\" \";\\n\\n        vector<vector<int>>ans;\\n\\n        for(auto i:queries){\\n            ans.push_back(solve(i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3991223,
                "title": "simple-bs-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->  \\n    O(N LOG N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,vector<int>& sorted) {\\n        if(root == NULL)\\n            return;\\n\\n        inorder(root->left,sorted);\\n        sorted.push_back(root->val);\\n        inorder(root->right,sorted);\\n    }\\n\\n    int lower(vector<int>& sorted,int query) {\\n        int ans = -1;\\n        int low = 0;\\n        int high = sorted.size()-1;\\n\\n        while(low <= high) {\\n            int mid = low + (high-low)/2;\\n\\n            if(sorted[mid] <= query) {\\n                ans = max(ans,sorted[mid]);\\n                low = mid+1;\\n            } \\n            else {\\n                high = mid-1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    int upper(vector<int>& sorted,int query) {\\n        int ans = INT_MAX;\\n        int low = 0;\\n        int high = sorted.size()-1;\\n\\n        while(low <= high) {\\n            int mid = low + (high-low)/2;\\n\\n            if(sorted[mid] >= query) {\\n                ans = min(ans,sorted[mid]);\\n                high = mid-1;\\n            }\\n            else {\\n                low = mid+1;\\n            }\\n        }\\n\\n        if(ans == INT_MAX)\\n            return -1;\\n\\n        return ans;\\n    }\\n\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int> sorted;\\n\\n        inorder(root,sorted);\\n\\n        int n = queries.size();\\n        vector<vector<int>> ans(n,vector<int>(2));\\n\\n        for(int i=0;i<n;i++) {\\n            int query = queries[i];\\n\\n            int min = lower(sorted,query);\\n            int max = upper(sorted,query);\\n\\n            ans[i][0] = min;\\n            ans[i][1] = max;\\n        }\\n\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,vector<int>& sorted) {\\n        if(root == NULL)\\n            return;\\n\\n        inorder(root->left,sorted);\\n        sorted.push_back(root->val);\\n        inorder(root->right,sorted);\\n    }\\n\\n    int lower(vector<int>& sorted,int query) {\\n        int ans = -1;\\n        int low = 0;\\n        int high = sorted.size()-1;\\n\\n        while(low <= high) {\\n            int mid = low + (high-low)/2;\\n\\n            if(sorted[mid] <= query) {\\n                ans = max(ans,sorted[mid]);\\n                low = mid+1;\\n            } \\n            else {\\n                high = mid-1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    int upper(vector<int>& sorted,int query) {\\n        int ans = INT_MAX;\\n        int low = 0;\\n        int high = sorted.size()-1;\\n\\n        while(low <= high) {\\n            int mid = low + (high-low)/2;\\n\\n            if(sorted[mid] >= query) {\\n                ans = min(ans,sorted[mid]);\\n                high = mid-1;\\n            }\\n            else {\\n                low = mid+1;\\n            }\\n        }\\n\\n        if(ans == INT_MAX)\\n            return -1;\\n\\n        return ans;\\n    }\\n\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int> sorted;\\n\\n        inorder(root,sorted);\\n\\n        int n = queries.size();\\n        vector<vector<int>> ans(n,vector<int>(2));\\n\\n        for(int i=0;i<n;i++) {\\n            int query = queries[i];\\n\\n            int min = lower(sorted,query);\\n            int max = upper(sorted,query);\\n\\n            ans[i][0] = min;\\n            ans[i][1] = max;\\n        }\\n\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987539,
                "title": "java-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<Integer> list ; //inorder\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        list = new ArrayList<>() ;\\n        List<List<Integer>> answer = new ArrayList<>() ;\\n        inorder(root);\\n        for(int q : queries){\\n            List<Integer> l = new ArrayList<>() ;\\n            l.add(findSmaller(list,q));\\n            l.add(findGreater(list,q));\\n            answer.add(l);\\n        }\\n        return answer ;\\n    }\\n    public int findSmaller(List<Integer> list , int val){\\n        int smaller = -1 ;\\n        int lptr=0 , rptr=list.size()-1 ;\\n        while(lptr<=rptr){\\n            int mid = lptr+(rptr-lptr)/2;\\n            if(list.get(mid)<=val){\\n                smaller = list.get(mid);\\n                lptr=mid+1;\\n            }\\n            else{\\n                rptr=mid-1;\\n            }\\n        }\\n        return smaller ;\\n    }\\n    public int findGreater(List<Integer> list , int val){\\n        int larger = -1 ;\\n        int lptr=0 , rptr=list.size()-1 ;\\n        while(lptr<=rptr){\\n            int mid = lptr+(rptr-lptr)/2;\\n            if(list.get(mid)>=val){\\n                larger = list.get(mid);\\n                rptr = mid-1 ;\\n            }\\n            else{\\n                lptr = mid+1 ;\\n            }\\n        }\\n        return larger ;\\n    }\\n    public void inorder(TreeNode node){\\n        if(node == null)\\n            return ;\\n        //left node right\\n        inorder(node.left);\\n        list.add(node.val);\\n        inorder(node.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<Integer> list ; //inorder\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        list = new ArrayList<>() ;\\n        List<List<Integer>> answer = new ArrayList<>() ;\\n        inorder(root);\\n        for(int q : queries){\\n            List<Integer> l = new ArrayList<>() ;\\n            l.add(findSmaller(list,q));\\n            l.add(findGreater(list,q));\\n            answer.add(l);\\n        }\\n        return answer ;\\n    }\\n    public int findSmaller(List<Integer> list , int val){\\n        int smaller = -1 ;\\n        int lptr=0 , rptr=list.size()-1 ;\\n        while(lptr<=rptr){\\n            int mid = lptr+(rptr-lptr)/2;\\n            if(list.get(mid)<=val){\\n                smaller = list.get(mid);\\n                lptr=mid+1;\\n            }\\n            else{\\n                rptr=mid-1;\\n            }\\n        }\\n        return smaller ;\\n    }\\n    public int findGreater(List<Integer> list , int val){\\n        int larger = -1 ;\\n        int lptr=0 , rptr=list.size()-1 ;\\n        while(lptr<=rptr){\\n            int mid = lptr+(rptr-lptr)/2;\\n            if(list.get(mid)>=val){\\n                larger = list.get(mid);\\n                rptr = mid-1 ;\\n            }\\n            else{\\n                lptr = mid+1 ;\\n            }\\n        }\\n        return larger ;\\n    }\\n    public void inorder(TreeNode node){\\n        if(node == null)\\n            return ;\\n        //left node right\\n        inorder(node.left);\\n        list.add(node.val);\\n        inorder(node.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977358,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n  public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n    var list = new ArrayList<Integer>();\\n    var result = new ArrayList<List<Integer>>();\\n    traverseTheTree(root, list);\\n    Collections.sort(list);\\n        System.out.println(list);\\n    for (int i = 0; i < queries.size(); i++) {\\n      var query = queries.get(i);\\n      var index = Collections.binarySearch(list, query);\\n      if (index < 0) {\\n        var min = ((1 + Collections.binarySearch(list, query)) * -1) - 1;\\n        var max = ((1 + Collections.binarySearch(list, query)) * -1);\\n        var minVal = 0;\\n        var maxVal = 0;\\n\\n        if (min < 0) {\\n          minVal = -1;\\n        } else {\\n          minVal = list.get(min);\\n        }\\n        if (max >= list.size()) {\\n          maxVal = -1;\\n        } else {\\n\\n          maxVal = list.get(max);\\n        }\\n\\n        result.add(List.of(minVal, maxVal));\\n      }else{\\n        result.add(List.of(list.get(index), list.get(index)));\\n      }\\n    }\\n    return result;\\n  }\\n\\n  private void traverseTheTree(TreeNode root, List<Integer> list) {\\n    if (root.left != null) {\\n      traverseTheTree(root.left, list);\\n    }\\n    list.add(root.val);\\n    if (root.right != null) {\\n      traverseTheTree(root.right, list);\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n  public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n    var list = new ArrayList<Integer>();\\n    var result = new ArrayList<List<Integer>>();\\n    traverseTheTree(root, list);\\n    Collections.sort(list);\\n        System.out.println(list);\\n    for (int i = 0; i < queries.size(); i++) {\\n      var query = queries.get(i);\\n      var index = Collections.binarySearch(list, query);\\n      if (index < 0) {\\n        var min = ((1 + Collections.binarySearch(list, query)) * -1) - 1;\\n        var max = ((1 + Collections.binarySearch(list, query)) * -1);\\n        var minVal = 0;\\n        var maxVal = 0;\\n\\n        if (min < 0) {\\n          minVal = -1;\\n        } else {\\n          minVal = list.get(min);\\n        }\\n        if (max >= list.size()) {\\n          maxVal = -1;\\n        } else {\\n\\n          maxVal = list.get(max);\\n        }\\n\\n        result.add(List.of(minVal, maxVal));\\n      }else{\\n        result.add(List.of(list.get(index), list.get(index)));\\n      }\\n    }\\n    return result;\\n  }\\n\\n  private void traverseTheTree(TreeNode root, List<Integer> list) {\\n    if (root.left != null) {\\n      traverseTheTree(root.left, list);\\n    }\\n    list.add(root.val);\\n    if (root.right != null) {\\n      traverseTheTree(root.right, list);\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910400,
                "title": "separate-fxn-for-dfs-and-bst",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, vector<int>& v){\\n        if(root==NULL) return;\\n        if(root->left!=NULL)dfs(root->left,v);\\n        v.push_back(root->val);\\n        if(root->right!=NULL)dfs(root->right,v);\\n    }\\n    void bst(vector<int>& v,int val,vector<int>& a){\\n        int l=0,r=v.size()-1;\\n        while(r>=l){\\n            int mid=l+(r-l)/2;\\n            if(v[mid]==val){\\n                a[1]=v[mid];\\n                a[0]=v[mid];\\n                break;\\n            }\\n            else if(v[mid]>val){\\n                a[1]=v[mid];\\n                r=mid-1;\\n            }\\n            else if(v[mid]<val){\\n                a[0]=v[mid];\\n                l=mid+1;\\n            }\\n        \\n        }\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n    vector<int>v;\\n    dfs(root,v);\\n    \\n    vector<vector<int>> ans;\\n    for(auto x:queries){\\n        vector<int>a(2,-1);\\n        bst(v,x,a);\\n        ans.push_back(a);\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, vector<int>& v){\\n        if(root==NULL) return;\\n        if(root->left!=NULL)dfs(root->left,v);\\n        v.push_back(root->val);\\n        if(root->right!=NULL)dfs(root->right,v);\\n    }\\n    void bst(vector<int>& v,int val,vector<int>& a){\\n        int l=0,r=v.size()-1;\\n        while(r>=l){\\n            int mid=l+(r-l)/2;\\n            if(v[mid]==val){\\n                a[1]=v[mid];\\n                a[0]=v[mid];\\n                break;\\n            }\\n            else if(v[mid]>val){\\n                a[1]=v[mid];\\n                r=mid-1;\\n            }\\n            else if(v[mid]<val){\\n                a[0]=v[mid];\\n                l=mid+1;\\n            }\\n        \\n        }\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n    vector<int>v;\\n    dfs(root,v);\\n    \\n    vector<vector<int>> ans;\\n    for(auto x:queries){\\n        vector<int>a(2,-1);\\n        bst(v,x,a);\\n        ans.push_back(a);\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888231,
                "title": "convert-to-array-and-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nElegant and direct traversal of a tree gets TLE due to unbalanced inputs, hence this\\n\\n# Complexity\\n- Time complexity: $$O(N + Q*log(N))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nfn dfs(root: Option<&Rc<RefCell<TreeNode>>>, out: &mut Vec<i32>) {\\n    if let Some(root) = root {\\n        let root = root.borrow();\\n        dfs(root.left.as_ref(), out);\\n        out.push(root.val);\\n        dfs(root.right.as_ref(), out);\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn closest_nodes(root: Option<Rc<RefCell<TreeNode>>>, queries: Vec<i32>) -> Vec<Vec<i32>> {\\n        let mut sorted = Vec::new();\\n        dfs(root.as_ref(), &mut sorted);\\n\\n        queries.into_iter().map(|q| {\\n            match sorted.binary_search(&q) {\\n                Ok(i) => vec![q, q],\\n                Err(i) => vec![*sorted.get(i - 1).unwrap_or(&-1), *sorted.get(i).unwrap_or(&-1)]\\n            }\\n        }).collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nfn dfs(root: Option<&Rc<RefCell<TreeNode>>>, out: &mut Vec<i32>) {\\n    if let Some(root) = root {\\n        let root = root.borrow();\\n        dfs(root.left.as_ref(), out);\\n        out.push(root.val);\\n        dfs(root.right.as_ref(), out);\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn closest_nodes(root: Option<Rc<RefCell<TreeNode>>>, queries: Vec<i32>) -> Vec<Vec<i32>> {\\n        let mut sorted = Vec::new();\\n        dfs(root.as_ref(), &mut sorted);\\n\\n        queries.into_iter().map(|q| {\\n            match sorted.binary_search(&q) {\\n                Ok(i) => vec![q, q],\\n                Err(i) => vec![*sorted.get(i - 1).unwrap_or(&-1), *sorted.get(i).unwrap_or(&-1)]\\n            }\\n        }).collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3862999,
                "title": "need-of-balancing-read-this",
                "content": "The thing is that the worst case time complexity of searching in Binary search Tree is O(N) and it happens when the tree is skewed.\\nSo we can not directly apply searching on the tree. \\n\\nThe first thing that we will have to do is to balance the given Binary Search Tree . Beacuse After Balancing the time complexity of searching is going to remain logN even in worst case and then we can simply perform the necessary searching over this .\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void Inorder(TreeNode* root, vector<int>& sorted) {\\n        \\n        if(!root) return;\\n\\n        Inorder(root->left, sorted);\\n        sorted.push_back(root->val);\\n        Inorder(root->right, sorted);\\n    }\\n\\n    TreeNode* Balance_Tree(vector<int> &sorted, int left, int right) {\\n\\n       \\n        if(left > right) return NULL;\\n\\n        int mid = left + (right - left)/2 ;\\n\\n        TreeNode* node = new TreeNode(sorted[mid]);\\n        \\n        node->left = Balance_Tree(sorted, left, mid - 1);\\n        node->right = Balance_Tree(sorted, mid + 1, right);\\n\\n        return node;\\n\\n    }\\n\\n        void Smallest_mini(TreeNode* root, int query, int& mini) {\\n\\n        TreeNode* node = root;\\n\\n        while(node != NULL) {\\n            \\n            if(node -> val == query) {\\n                mini = query;\\n                break;\\n            } else {\\n                if(node -> val < query) {\\n                    mini = max(mini, node -> val);\\n                    node = node -> right;\\n                } else {\\n                    node = node -> left;\\n                }\\n            }\\n        }\\n\\n    }\\n \\n     void Largest_maxi(TreeNode* root, int query, int& maxi) {\\n\\n        TreeNode* node = root;\\n\\n        while(node != NULL) {\\n            \\n            if(node -> val == query) {\\n                maxi = query;\\n                break;\\n            } else {\\n                if(node -> val > query) {\\n                    maxi = min(maxi, node -> val);\\n                    node = node -> left;\\n                } else {\\n                    node = node -> right;\\n                }\\n            }\\n        }\\n\\n    }\\n \\n \\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n\\n        vector<int>sorted;\\n        \\n        Inorder(root, sorted);\\n\\n        root = Balance_Tree(sorted, 0, sorted.size() - 1);\\n\\n\\n        int n = queries.size();\\n        \\n        vector<vector<int>>ans;\\n\\n        for(int i = 0; i < n; i++ ) {\\n            \\n            int mini = -1;\\n            int maxi = 10000000;\\n            Smallest_mini(root, queries[i], mini);\\n\\n            Largest_maxi(root, queries[i], maxi);\\n            \\n            if(maxi == 10000000) maxi = -1;\\n\\n            ans.push_back({mini, maxi});\\n\\n        }\\n\\n        return ans;\\n\\n\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void Inorder(TreeNode* root, vector<int>& sorted) {\\n        \\n        if(!root) return;\\n\\n        Inorder(root->left, sorted);\\n        sorted.push_back(root->val);\\n        Inorder(root->right, sorted);\\n    }\\n\\n    TreeNode* Balance_Tree(vector<int> &sorted, int left, int right) {\\n\\n       \\n        if(left > right) return NULL;\\n\\n        int mid = left + (right - left)/2 ;\\n\\n        TreeNode* node = new TreeNode(sorted[mid]);\\n        \\n        node->left = Balance_Tree(sorted, left, mid - 1);\\n        node->right = Balance_Tree(sorted, mid + 1, right);\\n\\n        return node;\\n\\n    }\\n\\n        void Smallest_mini(TreeNode* root, int query, int& mini) {\\n\\n        TreeNode* node = root;\\n\\n        while(node != NULL) {\\n            \\n            if(node -> val == query) {\\n                mini = query;\\n                break;\\n            } else {\\n                if(node -> val < query) {\\n                    mini = max(mini, node -> val);\\n                    node = node -> right;\\n                } else {\\n                    node = node -> left;\\n                }\\n            }\\n        }\\n\\n    }\\n \\n     void Largest_maxi(TreeNode* root, int query, int& maxi) {\\n\\n        TreeNode* node = root;\\n\\n        while(node != NULL) {\\n            \\n            if(node -> val == query) {\\n                maxi = query;\\n                break;\\n            } else {\\n                if(node -> val > query) {\\n                    maxi = min(maxi, node -> val);\\n                    node = node -> left;\\n                } else {\\n                    node = node -> right;\\n                }\\n            }\\n        }\\n\\n    }\\n \\n \\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n\\n        vector<int>sorted;\\n        \\n        Inorder(root, sorted);\\n\\n        root = Balance_Tree(sorted, 0, sorted.size() - 1);\\n\\n\\n        int n = queries.size();\\n        \\n        vector<vector<int>>ans;\\n\\n        for(int i = 0; i < n; i++ ) {\\n            \\n            int mini = -1;\\n            int maxi = 10000000;\\n            Smallest_mini(root, queries[i], mini);\\n\\n            Largest_maxi(root, queries[i], maxi);\\n            \\n            if(maxi == 10000000) maxi = -1;\\n\\n            ans.push_back({mini, maxi});\\n\\n        }\\n\\n        return ans;\\n\\n\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826017,
                "title": "inorder-traversal-binary-search-faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThink of the ordered structure of binary search tree and the type of queries\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the closestNodes function is O(n log n + q log n), where n is the number of nodes in the tree and q is the number of queries. This is because we first perform an inorder traversal of the tree to create the inorder vector, which takes O(n) time. Then, for each query, we perform a binary search on the inorder vector, which takes O(log n) time. Therefore, the total time complexity is O(n log n + q log n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the closestNodes function is O(n + q), where n is the number of nodes in the tree and q is the number of queries. This is because we create a vector<int> to store the inorder traversal of the tree, which takes O(n) space. We also create a vector<vector<int>> to store the answer for each query, which takes O(q) space. Therefore, the total space complexity is O(n + q).\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    void inorderTraversal(TreeNode* root, vector<int>& inorder) {\\n        if (root == nullptr) {\\n            return;\\n        }\\n        inorderTraversal(root->left, inorder);\\n        inorder.push_back(root->val);\\n        inorderTraversal(root->right, inorder);\\n    }\\npublic:\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int> inorder;\\n        vector<vector<int>> answer(queries.size(), vector<int> (2, -1));\\n        inorderTraversal(root, inorder);\\n        for(int i=0;i<queries.size();i++){\\n            int min = -1;\\n            int max = -1;\\n            int left = 0;\\n            int right = inorder.size() - 1;\\n            while(left <= right){\\n                int mid = left + (right - left) / 2;\\n                if(inorder[mid] == queries[i]){\\n                    answer[i][0] = inorder[mid];\\n                    answer[i][1] = inorder[mid];\\n                    break;\\n                }\\n                else if(inorder[mid] < queries[i]){\\n                    min = inorder[mid];\\n                    left = mid + 1;\\n                }\\n                else{\\n                    max = inorder[mid];\\n                    right = mid - 1;\\n                }\\n            }\\n            if(answer[i][0] == -1 && min != -1){\\n                answer[i][0] = min;\\n            }\\n            if(answer[i][1] == -1 && max != -1){\\n                answer[i][1] = max;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    void inorderTraversal(TreeNode* root, vector<int>& inorder) {\\n        if (root == nullptr) {\\n            return;\\n        }\\n        inorderTraversal(root->left, inorder);\\n        inorder.push_back(root->val);\\n        inorderTraversal(root->right, inorder);\\n    }\\npublic:\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int> inorder;\\n        vector<vector<int>> answer(queries.size(), vector<int> (2, -1));\\n        inorderTraversal(root, inorder);\\n        for(int i=0;i<queries.size();i++){\\n            int min = -1;\\n            int max = -1;\\n            int left = 0;\\n            int right = inorder.size() - 1;\\n            while(left <= right){\\n                int mid = left + (right - left) / 2;\\n                if(inorder[mid] == queries[i]){\\n                    answer[i][0] = inorder[mid];\\n                    answer[i][1] = inorder[mid];\\n                    break;\\n                }\\n                else if(inorder[mid] < queries[i]){\\n                    min = inorder[mid];\\n                    left = mid + 1;\\n                }\\n                else{\\n                    max = inorder[mid];\\n                    right = mid - 1;\\n                }\\n            }\\n            if(answer[i][0] == -1 && min != -1){\\n                answer[i][0] = min;\\n            }\\n            if(answer[i][1] == -1 && max != -1){\\n                answer[i][1] = max;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825298,
                "title": "inorder-lower-bound-100-time-complexity-for-beginners",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    void help(TreeNode*root,vector<int>&inorder){\\n        if(!root)   return ;\\n        help(root->left,inorder);\\n        inorder.push_back(root->val);\\n        help(root->right,inorder);\\n        return ;\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int> inorder;\\n        help(root,inorder);\\n        vector<vector<int>> ans;\\n        for(auto q:queries){\\n            auto it=lower_bound(inorder.begin(),inorder.end(),q);\\n            if(it!=inorder.end() && *it==q){\\n                ans.push_back({q,q});\\n            }\\n            else{\\n                int maxi=(it==inorder.end())?-1:*it;\\n                int mini;\\n                if(it==inorder.begin()) mini=-1;\\n                else{\\n                    it--;\\n                    mini=*it;\\n                }\\n                ans.push_back({mini,maxi});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    void help(TreeNode*root,vector<int>&inorder){\\n        if(!root)   return ;\\n        help(root->left,inorder);\\n        inorder.push_back(root->val);\\n        help(root->right,inorder);\\n        return ;\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int> inorder;\\n        help(root,inorder);\\n        vector<vector<int>> ans;\\n        for(auto q:queries){\\n            auto it=lower_bound(inorder.begin(),inorder.end(),q);\\n            if(it!=inorder.end() && *it==q){\\n                ans.push_back({q,q});\\n            }\\n            else{\\n                int maxi=(it==inorder.end())?-1:*it;\\n                int mini;\\n                if(it==inorder.begin()) mini=-1;\\n                else{\\n                    it--;\\n                    mini=*it;\\n                }\\n                ans.push_back({mini,maxi});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732429,
                "title": "simple-c-solution-dfs-sorting-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvoid order(TreeNode *root,vector<int>&cont){\\nif(root==NULL)return;\\ncont.push_back(root->val);\\norder(root->left,cont);\\norder(root->right,cont);\\n}\\nint big(int left,int right,int k,vector<int>&cont){\\nint ind=-1;\\nwhile(left<=right){\\n    int mid=(left+right)/2;\\n    if(cont[mid]>=k){\\n        ind=mid;\\n        right=mid-1;\\n    }\\n    else if(cont[mid]<k){\\n        left=mid+1;\\n    }\\n}\\nreturn ind;\\n}\\nint small(int left,int right,int k,vector<int>&cont){\\nint ind=-1;\\nwhile(left<=right){\\n    int mid=(left+right)/2;\\n    if(cont[mid]<=k){\\n        ind=mid;\\n        left=mid+1;\\n    }\\n    else if(cont[mid]>k){\\n        right=mid-1;\\n    }\\n}\\nreturn ind;\\n}\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int>cont;\\n        order(root,cont);\\n        sort(cont.begin(),cont.end());\\n        vector<vector<int>>answer;\\n        for(int i=0;i<queries.size();i++){\\n            vector<int>curr;\\n            int sm=small(0,cont.size()-1,queries[i],cont);\\n            int bg=big(0,cont.size()-1,queries[i],cont);\\n            if(sm!=-1)curr.push_back(cont[sm]);\\n            else curr.push_back(-1);\\n            if(bg!=-1)curr.push_back(cont[bg]);\\n            else curr.push_back(-1);\\n            answer.push_back(curr);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Depth-First Search",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvoid order(TreeNode *root,vector<int>&cont){\\nif(root==NULL)return;\\ncont.push_back(root->val);\\norder(root->left,cont);\\norder(root->right,cont);\\n}\\nint big(int left,int right,int k,vector<int>&cont){\\nint ind=-1;\\nwhile(left<=right){\\n    int mid=(left+right)/2;\\n    if(cont[mid]>=k){\\n        ind=mid;\\n        right=mid-1;\\n    }\\n    else if(cont[mid]<k){\\n        left=mid+1;\\n    }\\n}\\nreturn ind;\\n}\\nint small(int left,int right,int k,vector<int>&cont){\\nint ind=-1;\\nwhile(left<=right){\\n    int mid=(left+right)/2;\\n    if(cont[mid]<=k){\\n        ind=mid;\\n        left=mid+1;\\n    }\\n    else if(cont[mid]>k){\\n        right=mid-1;\\n    }\\n}\\nreturn ind;\\n}\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int>cont;\\n        order(root,cont);\\n        sort(cont.begin(),cont.end());\\n        vector<vector<int>>answer;\\n        for(int i=0;i<queries.size();i++){\\n            vector<int>curr;\\n            int sm=small(0,cont.size()-1,queries[i],cont);\\n            int bg=big(0,cont.size()-1,queries[i],cont);\\n            if(sm!=-1)curr.push_back(cont[sm]);\\n            else curr.push_back(-1);\\n            if(bg!=-1)curr.push_back(cont[bg]);\\n            else curr.push_back(-1);\\n            answer.push_back(curr);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699189,
                "title": "morris-inorder-binary-serach-o-nlogn-simple-approach",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    vector<int> getTupleIndex(vector<int> &inorder, int num) {\\n        int l = 0, h = inorder.size() - 1;\\n        while(l <= h) {\\n            int mid = (l + h) / 2;\\n            if(inorder[mid] == num) return { num, num };\\n            else if(inorder[mid] < num) l = mid + 1;\\n            else h = mid - 1;\\n        }\\n        vector<int> res(2, -1);\\n        int maxLen = inorder.size() - 1;\\n        if(h < maxLen) res[1] = inorder[h + 1];\\n        if(h >= 0) res[0] = inorder[h];\\n        return res;\\n    }\\npublic:\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int> inorder;\\n        \\n        TreeNode *curr = root;\\n        \\n        while(curr) {\\n            if(!curr -> left) {\\n                inorder.push_back(curr -> val);\\n                curr = curr -> right;\\n            } else {\\n                TreeNode *prev = curr -> left;\\n                \\n                while(prev -> right && prev -> right != curr) prev = prev -> right;\\n                if(prev -> right == NULL) {\\n                    prev -> right = curr;\\n                    curr = curr -> left;\\n                } else {\\n                    prev -> right = NULL;\\n                    inorder.push_back(curr -> val);\\n                    curr = curr -> right;\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        for(auto &num:queries) {\\n            ans.push_back(getTupleIndex(inorder, num));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    vector<int> getTupleIndex(vector<int> &inorder, int num) {\\n        int l = 0, h = inorder.size() - 1;\\n        while(l <= h) {\\n            int mid = (l + h) / 2;\\n            if(inorder[mid] == num) return { num, num };\\n            else if(inorder[mid] < num) l = mid + 1;\\n            else h = mid - 1;\\n        }\\n        vector<int> res(2, -1);\\n        int maxLen = inorder.size() - 1;\\n        if(h < maxLen) res[1] = inorder[h + 1];\\n        if(h >= 0) res[0] = inorder[h];\\n        return res;\\n    }\\npublic:\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int> inorder;\\n        \\n        TreeNode *curr = root;\\n        \\n        while(curr) {\\n            if(!curr -> left) {\\n                inorder.push_back(curr -> val);\\n                curr = curr -> right;\\n            } else {\\n                TreeNode *prev = curr -> left;\\n                \\n                while(prev -> right && prev -> right != curr) prev = prev -> right;\\n                if(prev -> right == NULL) {\\n                    prev -> right = curr;\\n                    curr = curr -> left;\\n                } else {\\n                    prev -> right = NULL;\\n                    inorder.push_back(curr -> val);\\n                    curr = curr -> right;\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        for(auto &num:queries) {\\n            ans.push_back(getTupleIndex(inorder, num));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695126,
                "title": "binary-search-inorder-traversal",
                "content": "-> Using binary search and inorder traversal\\n-> Time= O(nlog(n))\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\nvector<int>inorder;\\n      \\n      void solve(TreeNode* root)\\n      {\\n          if(root==NULL) return;\\n          if(root->left) solve(root->left);\\n          inorder.push_back(root->val);\\n          if(root->right) solve(root->right);\\n      }\\n      \\n     vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        solve(root);\\nvector<vector<int>>ans;\\nint n=queries.size();\\nint i=0;\\n        while(n--)\\n        {\\n          int z=queries[i++];\\n          int a=-1,b=-1;\\n          auto p=lower_bound(inorder.begin(),inorder.end(),z)-inorder.begin();\\n          \\nif(p<inorder.size() && inorder[p]==z) a=z;\\nelse\\n{\\n    if(p>0)\\n    a=inorder[p-1];\\n}\\n\\nauto q=lower_bound(inorder.begin(),inorder.end(),z)-inorder.begin();\\n        \\nif(p<inorder.size() && inorder[p]==z) b=z;\\nelse\\n{\\n    if(p<inorder.size())\\n    b=inorder[p];\\n}  \\nans.push_back({a,b});\\n}\\n    return ans;\\n    inorder.clear();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\nvector<int>inorder;\\n      \\n      void solve(TreeNode* root)\\n      {\\n          if(root==NULL) return;\\n          if(root->left) solve(root->left);\\n          inorder.push_back(root->val);\\n          if(root->right) solve(root->right);\\n      }\\n      \\n     vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        solve(root);\\nvector<vector<int>>ans;\\nint n=queries.size();\\nint i=0;\\n        while(n--)\\n        {\\n          int z=queries[i++];\\n          int a=-1,b=-1;\\n          auto p=lower_bound(inorder.begin(),inorder.end(),z)-inorder.begin();\\n          \\nif(p<inorder.size() && inorder[p]==z) a=z;\\nelse\\n{\\n    if(p>0)\\n    a=inorder[p-1];\\n}\\n\\nauto q=lower_bound(inorder.begin(),inorder.end(),z)-inorder.begin();\\n        \\nif(p<inorder.size() && inorder[p]==z) b=z;\\nelse\\n{\\n    if(p<inorder.size())\\n    b=inorder[p];\\n}  \\nans.push_back({a,b});\\n}\\n    return ans;\\n    inorder.clear();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691585,
                "title": "easy-java-solution-inorder-traversal-binary-search",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<Integer> inorder = new ArrayList<>();\\n\\n        in(root, inorder);\\n        Collections.sort(inorder);\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        for(int i = 0; i < queries.size(); i++){\\n            int element = queries.get(i);\\n            int min = -1;\\n            int max = -1;\\n            int l = 0;\\n            int h = inorder.size() - 1;\\n\\n            while(l <= h){\\n                int m = (l+h)/2;\\n\\n                if(inorder.get(m) == element){\\n                    min = element;\\n                    break;\\n                }\\n                else if(inorder.get(m) < element){\\n                    min = inorder.get(m); \\n                    l = m+1;\\n                }\\n                else{\\n                    h = m - 1;\\n                }\\n            }\\n\\n            l = 0;\\n            h = inorder.size() - 1;\\n\\n            while(l <= h){\\n                int m = (l+h)/2;\\n\\n                if(inorder.get(m) == element){\\n                    max = element;\\n                    break;\\n                }\\n                else if(inorder.get(m) > element){\\n                    max = inorder.get(m); \\n                    h = m - 1;\\n                }\\n                else{\\n                    l = m + 1;\\n                }\\n            }\\n            List<Integer> temp = new ArrayList<>();\\n            temp.add(min);\\n            temp.add(max);\\n            ans.add(temp);\\n        }\\n\\n        return ans;\\n    }\\n\\n    void in(TreeNode root, List<Integer> inorder){\\n        if(root == null) return;\\n\\n        in(root.left, inorder);\\n        inorder.add(root.val);\\n        in(root.right, inorder);\\n    }\\n\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<Integer> inorder = new ArrayList<>();\\n\\n        in(root, inorder);\\n        Collections.sort(inorder);\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        for(int i = 0; i < queries.size(); i++){\\n            int element = queries.get(i);\\n            int min = -1;\\n            int max = -1;\\n            int l = 0;\\n            int h = inorder.size() - 1;\\n\\n            while(l <= h){\\n                int m = (l+h)/2;\\n\\n                if(inorder.get(m) == element){\\n                    min = element;\\n                    break;\\n                }\\n                else if(inorder.get(m) < element){\\n                    min = inorder.get(m); \\n                    l = m+1;\\n                }\\n                else{\\n                    h = m - 1;\\n                }\\n            }\\n\\n            l = 0;\\n            h = inorder.size() - 1;\\n\\n            while(l <= h){\\n                int m = (l+h)/2;\\n\\n                if(inorder.get(m) == element){\\n                    max = element;\\n                    break;\\n                }\\n                else if(inorder.get(m) > element){\\n                    max = inorder.get(m); \\n                    h = m - 1;\\n                }\\n                else{\\n                    l = m + 1;\\n                }\\n            }\\n            List<Integer> temp = new ArrayList<>();\\n            temp.add(min);\\n            temp.add(max);\\n            ans.add(temp);\\n        }\\n\\n        return ans;\\n    }\\n\\n    void in(TreeNode root, List<Integer> inorder){\\n        if(root == null) return;\\n\\n        in(root.left, inorder);\\n        inorder.add(root.val);\\n        in(root.right, inorder);\\n    }\\n\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689881,
                "title": "c-simple-solution-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        \\n        vector<vector<int>> v;\\n        set<int> st;\\n        helper(root, st);\\n\\n        for(auto &i : queries)\\n        {\\n            auto it = st.lower_bound(i);\\n\\n            if(it == st.end())\\n                v.push_back({st.size() ? *(--it) : -1, -1});\\n            else if(*it == i)\\n                v.push_back({i, i});\\n            else if(it == st.begin())\\n                v.push_back({-1, *it});\\n            else\\n            {\\n                int tmp = *it;\\n                v.push_back({*(--it), tmp});\\n            }\\n        }\\n\\n        return v;\\n    }\\n\\n    void helper(TreeNode *root, set<int> &st)\\n    {\\n        if(!root)\\n            return;\\n\\n        st.insert(root->val);\\n        helper(root->left, st);\\n        helper(root->right, st);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree",
                    "Ordered Set"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        \\n        vector<vector<int>> v;\\n        set<int> st;\\n        helper(root, st);\\n\\n        for(auto &i : queries)\\n        {\\n            auto it = st.lower_bound(i);\\n\\n            if(it == st.end())\\n                v.push_back({st.size() ? *(--it) : -1, -1});\\n            else if(*it == i)\\n                v.push_back({i, i});\\n            else if(it == st.begin())\\n                v.push_back({-1, *it});\\n            else\\n            {\\n                int tmp = *it;\\n                v.push_back({*(--it), tmp});\\n            }\\n        }\\n\\n        return v;\\n    }\\n\\n    void helper(TreeNode *root, set<int> &st)\\n    {\\n        if(!root)\\n            return;\\n\\n        st.insert(root->val);\\n        helper(root->left, st);\\n        helper(root->right, st);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683812,
                "title": "c-inorder-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> a;\\n    void inorder(TreeNode* root){\\n        if(!root) return ;\\n        inorder(root->left);\\n        a.push_back(root->val);\\n        inorder(root->right);\\n        return ;\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& q) {\\n    inorder(root);\\n    vector<vector<int>> ans;\\n    sort(a.begin(),a.end());\\n    for(int i=0;i<q.size();i++){\\n        int p=q[i];\\n        if(p>a[a.size()-1])\\n        {\\n            ans.push_back({a[a.size()-1],-1});\\n            continue;\\n        }\\n        auto it=lower_bound(a.begin(),a.end(),p);\\n        int r=a[it-a.begin()],ind=it-a.begin();\\n        if(r==p){\\n            ans.push_back({r,r});\\n        } else {\\n            if(ind==0){\\n                ans.push_back({-1,r});\\n                continue;\\n            }\\n            ans.push_back({a[ind-1],r});\\n        }\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> a;\\n    void inorder(TreeNode* root){\\n        if(!root) return ;\\n        inorder(root->left);\\n        a.push_back(root->val);\\n        inorder(root->right);\\n        return ;\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& q) {\\n    inorder(root);\\n    vector<vector<int>> ans;\\n    sort(a.begin(),a.end());\\n    for(int i=0;i<q.size();i++){\\n        int p=q[i];\\n        if(p>a[a.size()-1])\\n        {\\n            ans.push_back({a[a.size()-1],-1});\\n            continue;\\n        }\\n        auto it=lower_bound(a.begin(),a.end(),p);\\n        int r=a[it-a.begin()],ind=it-a.begin();\\n        if(r==p){\\n            ans.push_back({r,r});\\n        } else {\\n            if(ind==0){\\n                ans.push_back({-1,r});\\n                continue;\\n            }\\n            ans.push_back({a[ind-1],r});\\n        }\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647343,
                "title": "swift-dfs-binary-search-solution",
                "content": "# Intuition\\nPerform binary search on the inorder DFS values.\\n\\nThere are two cases that can happen.  The tree contains `queries[i]` or it doesn\\'t. Append `[queries[i], queries[i]]` to the result if it does.  The greatest number less than or equal to itself is itself.  The lowest number greater than or equal to itself is itself.\\n\\nIf the tree does not contain `queries[i]`, `[minI, maxI]` = binary search index range `[right, left]`.  This is because the smallest value greater than `queries[i]` will be `mid + 1`.  The greatest value less than `queries[i]` will be `mid - 1`.\\n\\nExample:\\n\\n```\\nquery: 5\\n     r l\\n[1,3,4,6,7]\\n 0 1 2 3 4 \\n```\\nAfter the binary search ends the, `l` and `r` indices indicate where the search ended.\\n\\nExample when indices are out of bounds:\\n```\\nQuery: 4\\nr l\\n [5,6,7,8,9]\\n\\nQuery: 10\\n          r l\\n [5,6,7,8,9]\\n```\\n\\nIf `l` or `r` indices are outside of the value array\\'s indices we can assume the number does not exist and we append `-1` to the result.\\n\\n\\n```\\nclass Solution {\\n    func dfs(_ root: TreeNode?, _ arr: inout [Int]) {\\n        guard let root = root else {\\n            return\\n        }\\n\\n        dfs(root.left, &arr)\\n        arr.append(root.val)\\n        dfs(root.right, &arr)\\n    }\\n\\n    func closestNodes(_ root: TreeNode?, _ queries: [Int]) -> [[Int]] {\\n        var store = [Int](), res = [[Int]]()\\n        dfs(root, &store)\\n\\n        for query in queries {\\n            var l = 0, r = store.count - 1\\n            while l <= r {\\n                let mid = (l + r) / 2\\n                let val = store[mid]\\n                if query == val {\\n                    l = mid\\n                    r = mid\\n                    break\\n                }\\n\\n                if query > val  {\\n                    l = mid + 1\\n                } else {\\n                    r = mid - 1\\n                }\\n            }\\n\\n            if l == r {\\n                res.append([query, query])\\n            } else {\\n                res.append([store.indices.contains(r) ? store[r] : -1, store.indices.contains(l) ? store[l] : -1])\\n            }\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nquery: 5\\n     r l\\n[1,3,4,6,7]\\n 0 1 2 3 4 \\n```\n```\\nQuery: 4\\nr l\\n [5,6,7,8,9]\\n\\nQuery: 10\\n          r l\\n [5,6,7,8,9]\\n```\n```\\nclass Solution {\\n    func dfs(_ root: TreeNode?, _ arr: inout [Int]) {\\n        guard let root = root else {\\n            return\\n        }\\n\\n        dfs(root.left, &arr)\\n        arr.append(root.val)\\n        dfs(root.right, &arr)\\n    }\\n\\n    func closestNodes(_ root: TreeNode?, _ queries: [Int]) -> [[Int]] {\\n        var store = [Int](), res = [[Int]]()\\n        dfs(root, &store)\\n\\n        for query in queries {\\n            var l = 0, r = store.count - 1\\n            while l <= r {\\n                let mid = (l + r) / 2\\n                let val = store[mid]\\n                if query == val {\\n                    l = mid\\n                    r = mid\\n                    break\\n                }\\n\\n                if query > val  {\\n                    l = mid + 1\\n                } else {\\n                    r = mid - 1\\n                }\\n            }\\n\\n            if l == r {\\n                res.append([query, query])\\n            } else {\\n                res.append([store.indices.contains(r) ? store[r] : -1, store.indices.contains(l) ? store[l] : -1])\\n            }\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599095,
                "title": "easy-solution-with-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPerform an inorder traversal of the BST to obtain a sorted list of node values. Store this list in the vector v.\\nFor each query value temp in the queries vector, find the closest nodes to temp in the BST.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse the lower_bound function to find the iterator it pointing to the first element in v that is not less than temp.\\nIf it is not equal to v.end(), check if the value at it is equal to temp. If yes, then temp is present in the BST, and both temp values are added to the answer vector for the current query.\\nIf it is not equal to v.begin(), decrement it and add the value at it to the answer vector. Then increment it and add its value to the answer vector.\\nIf it is equal to v.begin(), temp is smaller than all elements in v, so add -1 as the first element in the answer vector and add the value at it as the second element.\\nIf it is equal to v.end(), temp is larger than all elements in v. Decrement it and add its value as the first element in the answer vector, and add -1 as the second element.\\nRepeat steps 4-7 for all queries and store the answer vectors in the ans vector.\\nFinally, return the ans vector containing the answers for all queries.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->The time complexity of this solution is O(n + q*log(n)), where n is the number of nodes in the BST and q is the number of queries. The inorder traversal takes O(n) time, and for each query, the lower_bound operation takes O(log(n)) time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->The space complexity is O(n), where n is the number of nodes in the BST. The vector v stores the inorder traversal, which requires O(n) space.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n  const int ZERO = [](){\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return 0;\\n}();\\nclass Solution {\\n    vector<int>v;\\npublic:\\n   void travers(TreeNode* root){\\n       if(root==NULL) return;\\n       travers(root->left);\\n       v.push_back(root->val);\\n       travers(root->right);\\n   }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        travers(root);\\n        vector<vector<int>>ans(queries.size());\\n        for(int i=0;i<queries.size();i++){\\n              int temp=queries[i];\\n              auto it=lower_bound(v.begin(),v.end(),temp);\\n              if(it!=v.end()){\\n                  if(*it==temp){\\n                      ans[i].push_back(temp); ans[i].push_back(temp); \\n                  }\\n                  else if(it!=v.begin()){\\n                  it--;  ans[i].push_back(*it);  it++;  ans[i].push_back(*it);\\n                  }\\n                  else{\\n                      ans[i].push_back(-1);  ans[i].push_back(*it);\\n                  }\\n              }\\n              else{\\n                  it--;\\n                    ans[i].push_back(*it); ans[i].push_back(-1);\\n              }\\n        }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n  const int ZERO = [](){\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return 0;\\n}();\\nclass Solution {\\n    vector<int>v;\\npublic:\\n   void travers(TreeNode* root){\\n       if(root==NULL) return;\\n       travers(root->left);\\n       v.push_back(root->val);\\n       travers(root->right);\\n   }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        travers(root);\\n        vector<vector<int>>ans(queries.size());\\n        for(int i=0;i<queries.size();i++){\\n              int temp=queries[i];\\n              auto it=lower_bound(v.begin(),v.end(),temp);\\n              if(it!=v.end()){\\n                  if(*it==temp){\\n                      ans[i].push_back(temp); ans[i].push_back(temp); \\n                  }\\n                  else if(it!=v.begin()){\\n                  it--;  ans[i].push_back(*it);  it++;  ans[i].push_back(*it);\\n                  }\\n                  else{\\n                      ans[i].push_back(-1);  ans[i].push_back(*it);\\n                  }\\n              }\\n              else{\\n                  it--;\\n                    ans[i].push_back(*it); ans[i].push_back(-1);\\n              }\\n        }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591006,
                "title": "simple-c-inorder-traversal-binary-search-approach",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,vector<int>&a){\\n        if(root==NULL){\\n            return;\\n        }\\n      inorder(root->left,a);\\n      a.push_back(root->val);\\n      inorder(root->right,a);\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<vector<int>>ans;\\n       \\n        vector<int>a;\\n        inorder(root,a);\\n        for(int i=0;i<queries.size();i++){\\n            int ele=queries[i];\\n            int s=0;\\n            int e=a.size()-1;\\n            int l=0;\\n            int r=0;\\n             vector<int>subans;\\n            while(s<=e){\\n                int mid=s+(e-s)/2;\\n                if(a[mid]==ele){\\n                    l=ele;\\n                    r=ele;\\n                    break;\\n                }\\n               else if(a[mid]>ele){\\n                   if(mid==0){\\n                       l=-1;\\n                   }\\n                   else{\\n                        l=a[mid-1];\\n                   }\\n                   r=a[mid];\\n                   e=mid-1;\\n               }\\n               else if(a[mid]<ele){\\n                    l=a[mid];\\n                   if(mid==a.size()-1){\\n                       r=-1;\\n                   }\\n                   else{\\n                        r=a[mid+1];\\n                   }\\n                   s=mid+1;\\n               }\\n            }\\n         subans.push_back(l);\\n         subans.push_back(r);\\n         ans.push_back(subans);\\n         \\n        }\\n    return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,vector<int>&a){\\n        if(root==NULL){\\n            return;\\n        }\\n      inorder(root->left,a);\\n      a.push_back(root->val);\\n      inorder(root->right,a);\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<vector<int>>ans;\\n       \\n        vector<int>a;\\n        inorder(root,a);\\n        for(int i=0;i<queries.size();i++){\\n            int ele=queries[i];\\n            int s=0;\\n            int e=a.size()-1;\\n            int l=0;\\n            int r=0;\\n             vector<int>subans;\\n            while(s<=e){\\n                int mid=s+(e-s)/2;\\n                if(a[mid]==ele){\\n                    l=ele;\\n                    r=ele;\\n                    break;\\n                }\\n               else if(a[mid]>ele){\\n                   if(mid==0){\\n                       l=-1;\\n                   }\\n                   else{\\n                        l=a[mid-1];\\n                   }\\n                   r=a[mid];\\n                   e=mid-1;\\n               }\\n               else if(a[mid]<ele){\\n                    l=a[mid];\\n                   if(mid==a.size()-1){\\n                       r=-1;\\n                   }\\n                   else{\\n                        r=a[mid+1];\\n                   }\\n                   s=mid+1;\\n               }\\n            }\\n         subans.push_back(l);\\n         subans.push_back(r);\\n         ans.push_back(subans);\\n         \\n        }\\n    return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576688,
                "title": "easy-and-concise-solution-beats-100-other-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI attempted to do this by just utilizing the BST. However, I got Time limited exceeded. So instead, I converted the BST into a sorted array using inorder then iterate the queries while using binarySearch on the sorted array to retrieve the closest values. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Convert the BST into a sorted array utilziing inorder\\n2. Iterate through queries and Binary Search the target to retrieve the closest values. \\n3. Before appending the values in the result [[Int]], check if the closestValues still equals to Int.min/max. If so, then set it to -1 (*This could possibly be improved by simply handling this within the binarySearch method*)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime is O(nlogn) due to sorting the array in linear time, then utilizing Binary Search where N is the number of nodes in the tree.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace is O(N) due to space of the array which has the number of nodes from the tree. \\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func closestNodes(_ root: TreeNode?, _ queries: [Int]) -> [[Int]] {\\n        var result = [[Int]]()\\n        var sorted = [Int]()\\n        func inorder(_ node: TreeNode?) { \\n            guard let node = node else { return }\\n            inorder(node.left)\\n            sorted.append(node.val)\\n            inorder(node.right)\\n        }\\n\\n        inorder(root)\\n\\n        func binarySearch(_ arr: [Int], _ target: Int) -> (Int, Int) { \\n            var closestValue = (Int.min, Int.max) \\n            var left = 0, right = arr.count - 1\\n            while left <= right { \\n                let mid = left + (right - left) / 2\\n                if arr[mid] == target { \\n                    return (target, target)\\n                } else if arr[mid] > target { \\n                    closestValue.1 = min(closestValue.1, arr[mid])\\n                    right = mid - 1\\n                } else { \\n                    closestValue.0 = max(closestValue.0, arr[mid])\\n                    left = mid + 1\\n                }\\n            }\\n            return closestValue\\n        }\\n\\n        for query in queries { \\n            var value = binarySearch(sorted, query)\\n            if value.0 == Int.min { value.0 = -1 }\\n            if value.1 == Int.max { value.1 = -1 }\\n            result.append([value.0, value.1])\\n        }\\n        return result\\n    } \\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Binary Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func closestNodes(_ root: TreeNode?, _ queries: [Int]) -> [[Int]] {\\n        var result = [[Int]]()\\n        var sorted = [Int]()\\n        func inorder(_ node: TreeNode?) { \\n            guard let node = node else { return }\\n            inorder(node.left)\\n            sorted.append(node.val)\\n            inorder(node.right)\\n        }\\n\\n        inorder(root)\\n\\n        func binarySearch(_ arr: [Int], _ target: Int) -> (Int, Int) { \\n            var closestValue = (Int.min, Int.max) \\n            var left = 0, right = arr.count - 1\\n            while left <= right { \\n                let mid = left + (right - left) / 2\\n                if arr[mid] == target { \\n                    return (target, target)\\n                } else if arr[mid] > target { \\n                    closestValue.1 = min(closestValue.1, arr[mid])\\n                    right = mid - 1\\n                } else { \\n                    closestValue.0 = max(closestValue.0, arr[mid])\\n                    left = mid + 1\\n                }\\n            }\\n            return closestValue\\n        }\\n\\n        for query in queries { \\n            var value = binarySearch(sorted, query)\\n            if value.0 == Int.min { value.0 = -1 }\\n            if value.1 == Int.max { value.1 = -1 }\\n            result.append([value.0, value.1])\\n        }\\n        return result\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567734,
                "title": "easy-simple-and-fastest-way-in-c",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    vector<int> treeData;\\n    void treeRead(TreeNode* root) {\\n        if(!root) return;\\n\\n        treeRead(root->left);\\n        treeData.push_back(root->val);\\n        treeRead(root->right);\\n    }\\n\\n    static bool compare(pair<int,int>& p1, pair<int,int>& p2) {\\n        return p1.first < p2.first;\\n    }\\n\\npublic:\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<vector<int>> res(queries.size(), vector<int>(2, 0));\\n        vector<pair<int,int>> query;\\n        \\n        treeRead(root);\\n\\n        for(int i=0; i<queries.size(); i++) {\\n            query.push_back({queries[i], i});\\n        }\\n\\n       sort(query.begin(), query.end(), compare);\\n\\n        int j=0;\\n        for(int i=0; i<query.size(); i++) {\\n            int value = query[i].first;\\n            int left=-1, right=-1;\\n\\n            while(j < treeData.size()) {\\n                if(treeData[j] == value) {\\n                    left = treeData[j];\\n                    right = treeData[j];\\n                    break;\\n                }\\n                else if(treeData[j] < value) {\\n                    left = treeData[j];\\n                    if(j+1>=treeData.size()) break;\\n                }\\n                else {\\n                    if(j-1 >= 0) \\n                        left = treeData[j-1];\\n                    right = treeData[j];\\n                    break;\\n                }\\n                j++;\\n            }\\n            res[query[i].second][0] = left;\\n            res[query[i].second][1] = right;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    vector<int> treeData;\\n    void treeRead(TreeNode* root) {\\n        if(!root) return;\\n\\n        treeRead(root->left);\\n        treeData.push_back(root->val);\\n        treeRead(root->right);\\n    }\\n\\n    static bool compare(pair<int,int>& p1, pair<int,int>& p2) {\\n        return p1.first < p2.first;\\n    }\\n\\npublic:\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<vector<int>> res(queries.size(), vector<int>(2, 0));\\n        vector<pair<int,int>> query;\\n        \\n        treeRead(root);\\n\\n        for(int i=0; i<queries.size(); i++) {\\n            query.push_back({queries[i], i});\\n        }\\n\\n       sort(query.begin(), query.end(), compare);\\n\\n        int j=0;\\n        for(int i=0; i<query.size(); i++) {\\n            int value = query[i].first;\\n            int left=-1, right=-1;\\n\\n            while(j < treeData.size()) {\\n                if(treeData[j] == value) {\\n                    left = treeData[j];\\n                    right = treeData[j];\\n                    break;\\n                }\\n                else if(treeData[j] < value) {\\n                    left = treeData[j];\\n                    if(j+1>=treeData.size()) break;\\n                }\\n                else {\\n                    if(j-1 >= 0) \\n                        left = treeData[j-1];\\n                    right = treeData[j];\\n                    break;\\n                }\\n                j++;\\n            }\\n            res[query[i].second][0] = left;\\n            res[query[i].second][1] = right;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561780,
                "title": "inorder-traversal-c-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#define ll long long\\nclass Solution {\\npublic:\\n    void inorder(TreeNode *root, vector<ll> &in) {\\n        if(root) {\\n            inorder(root->left, in);\\n            in.push_back(root->val);\\n            inorder(root->right, in);\\n        }\\n    }\\n\\n    int findMax(vector<ll> &in, ll target) {\\n        ll i = 0, j = in.size() - 1;\\n        ll ans = -1;\\n\\n        while(i <= j) {\\n            ll mid = (j + i) >> 1;\\n\\n            if(in[mid] == target) return target;\\n            else if(target > in[mid]) ans = in[mid], i = mid + 1;\\n            else j = mid - 1;\\n        }\\n\\n        return (int) ans;\\n    }\\n\\n    int findMin(vector<ll> &in, ll target) {\\n        ll i = 0, j = in.size() - 1;\\n        ll ans = -1;\\n\\n        while(i <= j) {\\n            ll mid = (j + i) >> 1;\\n\\n            if(in[mid] == target) return target;\\n            else if(target > in[mid]) i = mid + 1;\\n            else ans = in[mid], j = mid - 1;\\n        }\\n\\n        return (int) ans;\\n    }\\n\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<vector<int>> res;\\n        vector<ll> in;\\n\\n        inorder(root, in);\\n\\n        for(auto val: queries) {\\n            TreeNode *curr = root;\\n            int maxi = findMax(in, val);\\n            int mini = findMin(in, val);\\n            res.push_back({maxi, mini});\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#define ll long long\\nclass Solution {\\npublic:\\n    void inorder(TreeNode *root, vector<ll> &in) {\\n        if(root) {\\n            inorder(root->left, in);\\n            in.push_back(root->val);\\n            inorder(root->right, in);\\n        }\\n    }\\n\\n    int findMax(vector<ll> &in, ll target) {\\n        ll i = 0, j = in.size() - 1;\\n        ll ans = -1;\\n\\n        while(i <= j) {\\n            ll mid = (j + i) >> 1;\\n\\n            if(in[mid] == target) return target;\\n            else if(target > in[mid]) ans = in[mid], i = mid + 1;\\n            else j = mid - 1;\\n        }\\n\\n        return (int) ans;\\n    }\\n\\n    int findMin(vector<ll> &in, ll target) {\\n        ll i = 0, j = in.size() - 1;\\n        ll ans = -1;\\n\\n        while(i <= j) {\\n            ll mid = (j + i) >> 1;\\n\\n            if(in[mid] == target) return target;\\n            else if(target > in[mid]) i = mid + 1;\\n            else ans = in[mid], j = mid - 1;\\n        }\\n\\n        return (int) ans;\\n    }\\n\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<vector<int>> res;\\n        vector<ll> in;\\n\\n        inorder(root, in);\\n\\n        for(auto val: queries) {\\n            TreeNode *curr = root;\\n            int maxi = findMax(in, val);\\n            int mini = findMin(in, val);\\n            res.push_back({maxi, mini});\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555921,
                "title": "python-inorder-traversal-binary-search",
                "content": "# Intuition\\n- We create an array using inorder traversal.\\n- Now the array is sorted, so we use Binary Search to find the numbers greater than or equal to and less than or equal to a certain number.\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        ar = []\\n        def inorder(node):\\n            nonlocal ar\\n            if not node:\\n                return\\n            inorder(node.left)\\n            ar.append(node.val)\\n            inorder(node.right)\\n        inorder(root)\\n        def greater(num):\\n            lo = 0\\n            hi = len(ar)-1\\n            ans = -1\\n            while lo <= hi:\\n                mid = (lo+hi)//2\\n                if ar[mid] >= num:\\n                    ans = ar[mid]\\n                    hi = mid-1\\n                else:\\n                    lo = mid + 1\\n            return ans \\n        def smaller(num):\\n            lo = 0\\n            hi = len(ar)-1\\n            ans = -1\\n            while lo <= hi:\\n                mid = (lo+hi)//2\\n                if ar[mid] <= num:\\n                    ans = ar[mid]\\n                    lo = mid+1\\n                else:\\n                    hi = mid -1\\n            return ans \\n        ret = []\\n        for query in queries:\\n            ret.append([smaller(query), greater(query)])\\n        return ret\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        ar = []\\n        def inorder(node):\\n            nonlocal ar\\n            if not node:\\n                return\\n            inorder(node.left)\\n            ar.append(node.val)\\n            inorder(node.right)\\n        inorder(root)\\n        def greater(num):\\n            lo = 0\\n            hi = len(ar)-1\\n            ans = -1\\n            while lo <= hi:\\n                mid = (lo+hi)//2\\n                if ar[mid] >= num:\\n                    ans = ar[mid]\\n                    hi = mid-1\\n                else:\\n                    lo = mid + 1\\n            return ans \\n        def smaller(num):\\n            lo = 0\\n            hi = len(ar)-1\\n            ans = -1\\n            while lo <= hi:\\n                mid = (lo+hi)//2\\n                if ar[mid] <= num:\\n                    ans = ar[mid]\\n                    lo = mid+1\\n                else:\\n                    hi = mid -1\\n            return ans \\n        ret = []\\n        for query in queries:\\n            ret.append([smaller(query), greater(query)])\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521356,
                "title": "the-tree-might-not-be-balanced-convert-to-sorted-array-in-o-n-and-do-o-lon-n-queries-with-bisect",
                "content": "# Code\\n```\\ndef find_le(a, x):\\n    \\'Find rightmost value less than or equal to x\\'\\n    i = bisect_right(a, x)\\n    if i:\\n        return a[i-1]\\n    return -1\\n\\ndef find_ge(a, x):\\n    \\'Find leftmost item greater than or equal to x\\'\\n    i = bisect_left(a, x)\\n    if i != len(a):\\n        return a[i]\\n    #raise ValueError\\n    return -1\\n\\nclass Solution:\\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        arr = []\\n        def dfs(node):\\n            if not node:\\n                return\\n            dfs(node.left)\\n            arr.append(node.val)\\n            dfs(node.right)\\n        dfs(root)\\n        return [[find_le(arr, q), find_ge(arr, q)] for q in queries]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef find_le(a, x):\\n    \\'Find rightmost value less than or equal to x\\'\\n    i = bisect_right(a, x)\\n    if i:\\n        return a[i-1]\\n    return -1\\n\\ndef find_ge(a, x):\\n    \\'Find leftmost item greater than or equal to x\\'\\n    i = bisect_left(a, x)\\n    if i != len(a):\\n        return a[i]\\n    #raise ValueError\\n    return -1\\n\\nclass Solution:\\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        arr = []\\n        def dfs(node):\\n            if not node:\\n                return\\n            dfs(node.left)\\n            arr.append(node.val)\\n            dfs(node.right)\\n        dfs(root)\\n        return [[find_le(arr, q), find_ge(arr, q)] for q in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481841,
                "title": "simple-java-solution-using-binary-search-and-inorder-traversal",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> l = new ArrayList<>();\\n    public List<List<Integer>> answer = new ArrayList<>();\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        getNodes(root);\\n        for(int q:queries){\\n            List<Integer> sl = new ArrayList<>();\\n            int index = Collections.binarySearch(l,q);\\n            if(index>=0){\\n                sl.add(l.get(index));\\n                sl.add(l.get(index));\\n                answer.add(sl);\\n            }\\n            else{\\n                index = Math.abs(index+1);\\n                int min = -1,max = -1;\\n                if(index-1>=0) min = l.get(index-1);\\n                if(index<l.size()) max = l.get(index);\\n                sl.add(min);\\n                sl.add(max);\\n                answer.add(sl);\\n            }\\n        }\\n        return answer;\\n    }\\n    public void getNodes(TreeNode root){\\n        if(root!=null){\\n            getNodes(root.left);\\n            l.add(root.val);\\n            getNodes(root.right);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> l = new ArrayList<>();\\n    public List<List<Integer>> answer = new ArrayList<>();\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        getNodes(root);\\n        for(int q:queries){\\n            List<Integer> sl = new ArrayList<>();\\n            int index = Collections.binarySearch(l,q);\\n            if(index>=0){\\n                sl.add(l.get(index));\\n                sl.add(l.get(index));\\n                answer.add(sl);\\n            }\\n            else{\\n                index = Math.abs(index+1);\\n                int min = -1,max = -1;\\n                if(index-1>=0) min = l.get(index-1);\\n                if(index<l.size()) max = l.get(index);\\n                sl.add(min);\\n                sl.add(max);\\n                answer.add(sl);\\n            }\\n        }\\n        return answer;\\n    }\\n    public void getNodes(TreeNode root){\\n        if(root!=null){\\n            getNodes(root.left);\\n            l.add(root.val);\\n            getNodes(root.right);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458479,
                "title": "c-inorder-traversal-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ninorder traversal of BST will give you elements in sorted order \\nThen by applying binary search for each query we can get the min no and max no required for each query\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS + binary search\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)+O(qlog(n))\\nq-> no of queries\\nn->no of nodes\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) + O(q)\\n\\n**PLS UPVOTE IF IT HELPED**\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvoid dfs(TreeNode* root,vector<int>& arr){\\n    if(root==nullptr) return;\\n    dfs(root->left,arr);\\n    arr.push_back(root->val);\\n    dfs(root->right,arr);\\n}\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int> arr;\\n        dfs(root,arr);\\n        vector<vector<int>> ans(queries.size());\\n        int n=arr.size();\\n        for(int i=0;i<queries.size();i++){\\n            vector<int> vec({-1,-1});\\n            int x=lower_bound(arr.begin(),arr.end(),queries[i]+1)-arr.begin();\\n            if(arr[0]<=queries[i]) vec[0]=arr[x-1];\\n            if(arr.back()>=queries[i]) vec[1]=(x>0 && arr[x-1]==queries[i])?(arr[x-1]):arr[x];\\n            ans[i]=(vec);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvoid dfs(TreeNode* root,vector<int>& arr){\\n    if(root==nullptr) return;\\n    dfs(root->left,arr);\\n    arr.push_back(root->val);\\n    dfs(root->right,arr);\\n}\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int> arr;\\n        dfs(root,arr);\\n        vector<vector<int>> ans(queries.size());\\n        int n=arr.size();\\n        for(int i=0;i<queries.size();i++){\\n            vector<int> vec({-1,-1});\\n            int x=lower_bound(arr.begin(),arr.end(),queries[i]+1)-arr.begin();\\n            if(arr[0]<=queries[i]) vec[0]=arr[x-1];\\n            if(arr.back()>=queries[i]) vec[1]=(x>0 && arr[x-1]==queries[i])?(arr[x-1]):arr[x];\\n            ans[i]=(vec);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430913,
                "title": "yippeeee-solution-beats-100-using-binary-search-awesome-feeling",
                "content": "Using inorder first find increasing order of numbers as it is BST. After that we use binary search for comparsion. That\\'s it. Enjoy, do comment if not understandable. The solution beats 100% other solutions.\\n\\n# please upvote it\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number[]} queries\\n * @return {number[][]}\\n */\\n\\n\\nvar closestNodes = function(root, queries) {\\n    let result = [];\\n    \\n    var inorder = function(r) {\\n        if(!r) return null;\\n        inorder(r.left);\\n        result.push(r.val);\\n        inorder(r.right);\\n    }\\n\\n    inorder(root);\\n\\n    let ans = [];\\n\\n    var binary = function(q) {\\n        let left = 0, right = result.length - 1;\\n\\n        while(left <= right) {\\n            let mid = (left + right) >>> 1;\\n\\n            if(result[mid] == q) {\\n                return [result[mid], result[mid]];\\n            } else if (result[mid] > q) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return [result[right] || -1, result[left] || -1];\\n    }\\n\\n    for(let query of queries) {\\n        ans.push(binary(query));      \\n    }\\n\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number[]} queries\\n * @return {number[][]}\\n */\\n\\n\\nvar closestNodes = function(root, queries) {\\n    let result = [];\\n    \\n    var inorder = function(r) {\\n        if(!r) return null;\\n        inorder(r.left);\\n        result.push(r.val);\\n        inorder(r.right);\\n    }\\n\\n    inorder(root);\\n\\n    let ans = [];\\n\\n    var binary = function(q) {\\n        let left = 0, right = result.length - 1;\\n\\n        while(left <= right) {\\n            let mid = (left + right) >>> 1;\\n\\n            if(result[mid] == q) {\\n                return [result[mid], result[mid]];\\n            } else if (result[mid] > q) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return [result[right] || -1, result[left] || -1];\\n    }\\n\\n    for(let query of queries) {\\n        ans.push(binary(query));      \\n    }\\n\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3360523,
                "title": "c-binary-search-solution",
                "content": "```\\npublic class Solution\\n{\\n    public IList<IList<int>> ClosestNodes(TreeNode root, IList<int> queries)\\n    {\\n        var values = new List<int>();\\n        CollectValues(root, values);\\n\\n        var answers = new List<IList<int>>();\\n        foreach (var query in queries)\\n        {\\n            var answer = GetAnswer(query, values);\\n            answers.Add(answer);\\n        }\\n\\n        return answers;\\n    }\\n\\n    private IList<int> GetAnswer(int query, List<int> values)\\n    {\\n        var n = values.Count;\\n        return values.BinarySearch(query) switch\\n        {\\n            var i when  i >= 0 => new [] { values[i],      values[i]  },\\n            var i when ~i == 0 => new [] { -1,             values[0]  },\\n            var i when ~i == n => new [] { values[^1],     -1         },\\n            var i when  i <  0 => new [] { values[~i - 1], values[~i] },\\n        };\\n    }\\n\\n    private void CollectValues(TreeNode node, List<int> values)\\n    {\\n        if (node != null)\\n        {\\n            CollectValues(node.left, values);\\n            values.Add(node.val);\\n            CollectValues(node.right, values);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public IList<IList<int>> ClosestNodes(TreeNode root, IList<int> queries)\\n    {\\n        var values = new List<int>();\\n        CollectValues(root, values);\\n\\n        var answers = new List<IList<int>>();\\n        foreach (var query in queries)\\n        {\\n            var answer = GetAnswer(query, values);\\n            answers.Add(answer);\\n        }\\n\\n        return answers;\\n    }\\n\\n    private IList<int> GetAnswer(int query, List<int> values)\\n    {\\n        var n = values.Count;\\n        return values.BinarySearch(query) switch\\n        {\\n            var i when  i >= 0 => new [] { values[i],      values[i]  },\\n            var i when ~i == 0 => new [] { -1,             values[0]  },\\n            var i when ~i == n => new [] { values[^1],     -1         },\\n            var i when  i <  0 => new [] { values[~i - 1], values[~i] },\\n        };\\n    }\\n\\n    private void CollectValues(TreeNode node, List<int> values)\\n    {\\n        if (node != null)\\n        {\\n            CollectValues(node.left, values);\\n            values.Add(node.val);\\n            CollectValues(node.right, values);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359557,
                "title": "c-dfs-binary-search-faster-easy-to-understand",
                "content": "* ***Using Binary Search***\\n\\n* ***Time Complexity :- O(NlogN)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    // dfs for finding inorder traversal of binary search tree\\n    \\n    void dfs(TreeNode* root, vector<int>& arr)\\n    {\\n        // base case\\n        \\n        if(root == NULL)\\n        {\\n            return;\\n        }\\n        \\n        // call left subtree\\n        \\n        dfs(root -> left, arr);\\n        \\n        // push the val into arr\\n        \\n        arr.push_back(root -> val);\\n        \\n        // call to right subtree\\n        \\n        dfs(root -> right, arr);\\n    }\\n    \\n    // function for finding minimum\\n    \\n    int find_min(vector<int>& arr, int target)\\n    {\\n        int n = arr.size();\\n        \\n        // apply binary search\\n        \\n        int low = 0;\\n        \\n        int high = n - 1;\\n        \\n        int ans = -1;\\n        \\n        while(low <= high)\\n        {\\n            int mid = (low + high) / 2;\\n            \\n            if(arr[mid] <= target)\\n            {\\n                ans = arr[mid];\\n                \\n                low = mid + 1;\\n            }\\n            else\\n            {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    // function for finding maximum\\n    \\n    int find_max(vector<int>& arr, int target)\\n    {\\n        int n = arr.size();\\n        \\n        // apply binary tree\\n        \\n        int low = 0;\\n        \\n        int high = n - 1;\\n        \\n        int ans = -1;\\n        \\n        while(low <= high)\\n        {\\n            int mid = (low + high) / 2;\\n            \\n            if(arr[mid] >= target)\\n            {\\n                ans = arr[mid];\\n                \\n                high = mid - 1;\\n            }\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n        \\n    \\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        \\n        vector<int> arr;\\n        \\n        // call for dfs\\n        \\n        dfs(root, arr);\\n        \\n        int n = queries.size();\\n        \\n        // find the res for each queries\\n        \\n        vector<vector<int>> res(n);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int mini = find_min(arr, queries[i]);\\n            \\n            int maxi = find_max(arr, queries[i]);\\n            \\n            res[i] = {mini, maxi};\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    // dfs for finding inorder traversal of binary search tree\\n    \\n    void dfs(TreeNode* root, vector<int>& arr)\\n    {\\n        // base case\\n        \\n        if(root == NULL)\\n        {\\n            return;\\n        }\\n        \\n        // call left subtree\\n        \\n        dfs(root -> left, arr);\\n        \\n        // push the val into arr\\n        \\n        arr.push_back(root -> val);\\n        \\n        // call to right subtree\\n        \\n        dfs(root -> right, arr);\\n    }\\n    \\n    // function for finding minimum\\n    \\n    int find_min(vector<int>& arr, int target)\\n    {\\n        int n = arr.size();\\n        \\n        // apply binary search\\n        \\n        int low = 0;\\n        \\n        int high = n - 1;\\n        \\n        int ans = -1;\\n        \\n        while(low <= high)\\n        {\\n            int mid = (low + high) / 2;\\n            \\n            if(arr[mid] <= target)\\n            {\\n                ans = arr[mid];\\n                \\n                low = mid + 1;\\n            }\\n            else\\n            {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    // function for finding maximum\\n    \\n    int find_max(vector<int>& arr, int target)\\n    {\\n        int n = arr.size();\\n        \\n        // apply binary tree\\n        \\n        int low = 0;\\n        \\n        int high = n - 1;\\n        \\n        int ans = -1;\\n        \\n        while(low <= high)\\n        {\\n            int mid = (low + high) / 2;\\n            \\n            if(arr[mid] >= target)\\n            {\\n                ans = arr[mid];\\n                \\n                high = mid - 1;\\n            }\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n        \\n    \\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        \\n        vector<int> arr;\\n        \\n        // call for dfs\\n        \\n        dfs(root, arr);\\n        \\n        int n = queries.size();\\n        \\n        // find the res for each queries\\n        \\n        vector<vector<int>> res(n);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int mini = find_min(arr, queries[i]);\\n            \\n            int maxi = find_max(arr, queries[i]);\\n            \\n            res[i] = {mini, maxi};\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353921,
                "title": "using-sortedset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public IList<IList<int>> ClosestNodes(TreeNode root, IList<int> queries) {\\n        SortedSet<int> sorted = new();\\n        toSorted(root);\\n        var result=new List<IList<int>>();\\n        foreach(var item in queries){\\n            var cur=new List<int>();\\n            var min=sorted.GetViewBetween(int.MinValue, item)?.Max??0;\\n            var max=sorted.GetViewBetween(item,int.MaxValue)?.Min??0;\\n            cur.Add(min>0?min:-1);\\n            cur.Add(max>0?max:-1);\\n            result.Add(cur);\\n        }\\n        return result;\\n\\n        void toSorted(TreeNode root){\\n            if(root==null) return;\\n            sorted.Add(root.val);\\n            toSorted(root.left);\\n            toSorted(root.right);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public IList<IList<int>> ClosestNodes(TreeNode root, IList<int> queries) {\\n        SortedSet<int> sorted = new();\\n        toSorted(root);\\n        var result=new List<IList<int>>();\\n        foreach(var item in queries){\\n            var cur=new List<int>();\\n            var min=sorted.GetViewBetween(int.MinValue, item)?.Max??0;\\n            var max=sorted.GetViewBetween(item,int.MaxValue)?.Min??0;\\n            cur.Add(min>0?min:-1);\\n            cur.Add(max>0?max:-1);\\n            result.Add(cur);\\n        }\\n        return result;\\n\\n        void toSorted(TreeNode root){\\n            if(root==null) return;\\n            sorted.Add(root.val);\\n            toSorted(root.left);\\n            toSorted(root.right);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335322,
                "title": "c-inorder-traversal-binary-search",
                "content": "\\n# Approach\\nStore Inorder traversal of given BST.Traverse through all the queries and calculate LowerBound for each query using which we can find min and max values easily.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void traverse(TreeNode* root,vector <int> &arr){\\n        if(root==NULL)return;\\n        traverse(root->left,arr);\\n        arr.push_back(root->val);\\n        traverse(root->right,arr);\\n        return;\\n    }\\n    int lowerBound(vector <int> &arr,int s,int e,int x){\\n        int ans=-1;\\n        while(s <= e){\\n            int mid=(s+e)/2;\\n            if(arr[mid]<x){\\n                s=mid+1;\\n            }\\n            else{\\n                ans=mid;\\n                e=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector <int> arr;\\n        traverse(root,arr);\\n        vector <vector<int>> ans;\\n        int n=arr.size();\\n        for(int i=0;i<queries.size();i++){\\n            vector <int> temp(2,-1);\\n            int k=lowerBound(arr,0,n-1,queries[i]);\\n            if(k==-1){\\n                temp[0]=arr[n-1];\\n            }\\n            else if(arr[k]==queries[i]){\\n                temp[0]=queries[i];\\n                temp[1]=queries[i];\\n            }\\n            else{\\n                temp[1]=arr[k];\\n                if(k != 0){\\n                    temp[0]=arr[k-1];\\n                }\\n            }\\n            ans.push_back(temp);\\n        }\\n        // for(int i=0;i<ans.size();i++){\\n        //     cout<<ans[i][0]<<\" \"<<ans[i][1]<<\"\\\\n\";\\n        // }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void traverse(TreeNode* root,vector <int> &arr){\\n        if(root==NULL)return;\\n        traverse(root->left,arr);\\n        arr.push_back(root->val);\\n        traverse(root->right,arr);\\n        return;\\n    }\\n    int lowerBound(vector <int> &arr,int s,int e,int x){\\n        int ans=-1;\\n        while(s <= e){\\n            int mid=(s+e)/2;\\n            if(arr[mid]<x){\\n                s=mid+1;\\n            }\\n            else{\\n                ans=mid;\\n                e=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector <int> arr;\\n        traverse(root,arr);\\n        vector <vector<int>> ans;\\n        int n=arr.size();\\n        for(int i=0;i<queries.size();i++){\\n            vector <int> temp(2,-1);\\n            int k=lowerBound(arr,0,n-1,queries[i]);\\n            if(k==-1){\\n                temp[0]=arr[n-1];\\n            }\\n            else if(arr[k]==queries[i]){\\n                temp[0]=queries[i];\\n                temp[1]=queries[i];\\n            }\\n            else{\\n                temp[1]=arr[k];\\n                if(k != 0){\\n                    temp[0]=arr[k-1];\\n                }\\n            }\\n            ans.push_back(temp);\\n        }\\n        // for(int i=0;i<ans.size();i++){\\n        //     cout<<ans[i][0]<<\" \"<<ans[i][1]<<\"\\\\n\";\\n        // }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3322935,
                "title": "c-inorder-traversal-binary-search",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n + Qlogn)$$ (with n being the total number of nodes and Q being the number of queries)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void inOrder(vector<int>& orderedQueries, TreeNode* curr) {\\n        if (!curr) return;\\n        inOrder(orderedQueries, curr->left);\\n        orderedQueries.push_back(curr->val);\\n        inOrder(orderedQueries, curr->right);\\n    }\\n\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int> orderedQueries;\\n        inOrder(orderedQueries, root);\\n        vector<vector<int>> res;\\n        for (int i = 0; i < queries.size(); ++ i) {\\n            res.push_back({-1, -1});\\n            int l = 0, r = orderedQueries.size() - 1, mid = l;\\n            while (l + 1 < r) {\\n                mid = (l + r) / 2;\\n                if (orderedQueries[mid] <= queries[i]) l = mid;\\n                else r = mid - 1;\\n            }\\n            if (orderedQueries[r] < queries[i]) {\\n                res[i][0] = orderedQueries[r];\\n                if (r + 1 < orderedQueries.size()) res[i][1] = orderedQueries[r + 1];\\n            } \\n            else if (orderedQueries[r] == queries[i]) res[i][0] = res[i][1] = orderedQueries[r];\\n            else if (orderedQueries[l] < queries[i]) {\\n                res[i][0] = orderedQueries[l];\\n                res[i][1] = orderedQueries[r];\\n            } \\n            else if (orderedQueries[l] == queries[i]) res[i][0] = res[i][1] = orderedQueries[l];\\n            else res[i][1] = orderedQueries[l];\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inOrder(vector<int>& orderedQueries, TreeNode* curr) {\\n        if (!curr) return;\\n        inOrder(orderedQueries, curr->left);\\n        orderedQueries.push_back(curr->val);\\n        inOrder(orderedQueries, curr->right);\\n    }\\n\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int> orderedQueries;\\n        inOrder(orderedQueries, root);\\n        vector<vector<int>> res;\\n        for (int i = 0; i < queries.size(); ++ i) {\\n            res.push_back({-1, -1});\\n            int l = 0, r = orderedQueries.size() - 1, mid = l;\\n            while (l + 1 < r) {\\n                mid = (l + r) / 2;\\n                if (orderedQueries[mid] <= queries[i]) l = mid;\\n                else r = mid - 1;\\n            }\\n            if (orderedQueries[r] < queries[i]) {\\n                res[i][0] = orderedQueries[r];\\n                if (r + 1 < orderedQueries.size()) res[i][1] = orderedQueries[r + 1];\\n            } \\n            else if (orderedQueries[r] == queries[i]) res[i][0] = res[i][1] = orderedQueries[r];\\n            else if (orderedQueries[l] < queries[i]) {\\n                res[i][0] = orderedQueries[l];\\n                res[i][1] = orderedQueries[r];\\n            } \\n            else if (orderedQueries[l] == queries[i]) res[i][0] = res[i][1] = orderedQueries[l];\\n            else res[i][1] = orderedQueries[l];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306955,
                "title": "c-sober-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void in(vector<int>& inorder , TreeNode* root)\\n    {\\n        if(root==NULL)\\n        return ;\\n\\n        in(inorder , root->left);\\n        inorder.push_back(root->val);\\n        in(inorder , root->right);\\n\\n\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& q) {\\n        \\n        vector<int> inorder;\\n        in(inorder , root);\\n\\n        vector<vector<int>> v;\\n\\n        for(int i=0;i<q.size();i++)\\n        {\\n            cout<<\"hello\"<<endl;\\n            vector<int> ans;\\n            int x = lower_bound(inorder.begin() , inorder.end() , q[i])- inorder.begin();\\n            int y = upper_bound(inorder.begin() , inorder.end() , q[i])- inorder.begin();\\n    \\n            if(x!=y)\\n            {\\n                ans.push_back(inorder[x]);\\n                ans.push_back(inorder[x]);\\n\\n                v.push_back(ans);\\n            }\\n            else\\n            {\\n                if(x==0 && y==0)\\n                {\\n                    ans.push_back(-1);\\n                    ans.push_back(inorder[y]);\\n                     v.push_back(ans);\\n\\n                }\\n                else if(x== inorder.size() && y == inorder.size())\\n                {\\n                    ans.push_back(inorder[inorder.size()-1]);\\n                    ans.push_back(-1);\\n                     v.push_back(ans);\\n                }\\n                else\\n                {\\n                    ans.push_back(inorder[x-1]);\\n                    ans.push_back(inorder[y]);\\n\\n                     v.push_back(ans);\\n                }\\n            }\\n\\n\\n            \\n            \\n        }\\n\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void in(vector<int>& inorder , TreeNode* root)\\n    {\\n        if(root==NULL)\\n        return ;\\n\\n        in(inorder , root->left);\\n        inorder.push_back(root->val);\\n        in(inorder , root->right);\\n\\n\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& q) {\\n        \\n        vector<int> inorder;\\n        in(inorder , root);\\n\\n        vector<vector<int>> v;\\n\\n        for(int i=0;i<q.size();i++)\\n        {\\n            cout<<\"hello\"<<endl;\\n            vector<int> ans;\\n            int x = lower_bound(inorder.begin() , inorder.end() , q[i])- inorder.begin();\\n            int y = upper_bound(inorder.begin() , inorder.end() , q[i])- inorder.begin();\\n    \\n            if(x!=y)\\n            {\\n                ans.push_back(inorder[x]);\\n                ans.push_back(inorder[x]);\\n\\n                v.push_back(ans);\\n            }\\n            else\\n            {\\n                if(x==0 && y==0)\\n                {\\n                    ans.push_back(-1);\\n                    ans.push_back(inorder[y]);\\n                     v.push_back(ans);\\n\\n                }\\n                else if(x== inorder.size() && y == inorder.size())\\n                {\\n                    ans.push_back(inorder[inorder.size()-1]);\\n                    ans.push_back(-1);\\n                     v.push_back(ans);\\n                }\\n                else\\n                {\\n                    ans.push_back(inorder[x-1]);\\n                    ans.push_back(inorder[y]);\\n\\n                     v.push_back(ans);\\n                }\\n            }\\n\\n\\n            \\n            \\n        }\\n\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3288279,
                "title": "python3-inorder-traversal",
                "content": "\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def closestNodes(self, root: Optional[TreeNode], q: List[int]) -> List[List[int]]:\\n        lst=[]\\n        res=[]\\n\\n        def rec(root):\\n            if not root:\\n                return \\n\\n            rec(root.left)\\n            lst.append(root.val)\\n            rec(root.right)\\n\\n        rec(root)\\n        \\n        for i in q:\\n            a=bisect_left(lst,i)\\n\\n            if a<len(lst) and lst[a]==i:\\n                res.append([i,i])\\n                continue\\n\\n            s=[]\\n            if a-1>-1:\\n                s.append(lst[a-1])\\n\\n            else:\\n                s.append(-1)\\n\\n            if a<len(lst):\\n                s.append(lst[a])\\n\\n            else:\\n                s.append(-1)\\n\\n            res.append(list(s))\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def closestNodes(self, root: Optional[TreeNode], q: List[int]) -> List[List[int]]:\\n        lst=[]\\n        res=[]\\n\\n        def rec(root):\\n            if not root:\\n                return \\n\\n            rec(root.left)\\n            lst.append(root.val)\\n            rec(root.right)\\n\\n        rec(root)\\n        \\n        for i in q:\\n            a=bisect_left(lst,i)\\n\\n            if a<len(lst) and lst[a]==i:\\n                res.append([i,i])\\n                continue\\n\\n            s=[]\\n            if a-1>-1:\\n                s.append(lst[a-1])\\n\\n            else:\\n                s.append(-1)\\n\\n            if a<len(lst):\\n                s.append(lst[a])\\n\\n            else:\\n                s.append(-1)\\n\\n            res.append(list(s))\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253899,
                "title": "binary-search-through-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* Clear binary search problem\\n* It\\'s possible to solve it by browsing the tree directly, but I find the array solution way more understandable\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* We convert the tree using inorder traversal\\n* Then first we check edge cases: what happens if the query is outside of the range, or at the range.\\n* So we mark left and right, and move them until we find the query, or until query si right in between left and right\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n + q * log(n)), where q is a size of a queries, and n is a number of nodes. O(n) for transformation of node to a list, and O(q * log(n)) for traversal per query\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        List<Integer> nodes = new ArrayList<>();\\n        inorder(root, nodes); \\n        for (int query : queries) {\\n           result.add(findClosest(query, nodes));\\n        }\\n        return result;\\n    }\\n\\n    private List<Integer> findClosest(int query, List<Integer> nodes) {\\n        List<Integer> result = new ArrayList<>();\\n        if (query < nodes.get(0)) {\\n            result.add(-1);\\n            result.add(nodes.get(0));\\n            return result;\\n        }\\n        if (query > nodes.get(nodes.size() - 1)) {\\n            result.add(nodes.get(nodes.size() - 1));\\n            result.add(-1);\\n            return result;\\n        }\\n        if (query == nodes.get(0) || query == nodes.get(nodes.size() - 1)) {\\n            result.add(query);\\n            result.add(query);\\n            return result;\\n        }\\n        int left = 0;\\n        int right = nodes.size() - 1;\\n        while (right - left > 1) {\\n            int middle = (right + left) / 2;\\n            int middleVal = nodes.get(middle);\\n            if (middleVal == query) {\\n                result.add(query);\\n                result.add(query);\\n                return result;    \\n            } else if (middleVal < query) {\\n                left = middle;\\n            } else {\\n                right = middle;\\n            }\\n        }\\n        result.add(nodes.get(left));\\n        result.add(nodes.get(right));\\n        return result;\\n    }\\n\\n    private void inorder(TreeNode node, List<Integer> result) {\\n        if (node == null) {\\n            return;\\n        }\\n        inorder(node.left, result);\\n        result.add(node.val);\\n        inorder(node.right, result);\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        List<Integer> nodes = new ArrayList<>();\\n        inorder(root, nodes); \\n        for (int query : queries) {\\n           result.add(findClosest(query, nodes));\\n        }\\n        return result;\\n    }\\n\\n    private List<Integer> findClosest(int query, List<Integer> nodes) {\\n        List<Integer> result = new ArrayList<>();\\n        if (query < nodes.get(0)) {\\n            result.add(-1);\\n            result.add(nodes.get(0));\\n            return result;\\n        }\\n        if (query > nodes.get(nodes.size() - 1)) {\\n            result.add(nodes.get(nodes.size() - 1));\\n            result.add(-1);\\n            return result;\\n        }\\n        if (query == nodes.get(0) || query == nodes.get(nodes.size() - 1)) {\\n            result.add(query);\\n            result.add(query);\\n            return result;\\n        }\\n        int left = 0;\\n        int right = nodes.size() - 1;\\n        while (right - left > 1) {\\n            int middle = (right + left) / 2;\\n            int middleVal = nodes.get(middle);\\n            if (middleVal == query) {\\n                result.add(query);\\n                result.add(query);\\n                return result;    \\n            } else if (middleVal < query) {\\n                left = middle;\\n            } else {\\n                right = middle;\\n            }\\n        }\\n        result.add(nodes.get(left));\\n        result.add(nodes.get(right));\\n        return result;\\n    }\\n\\n    private void inorder(TreeNode node, List<Integer> result) {\\n        if (node == null) {\\n            return;\\n        }\\n        inorder(node.left, result);\\n        result.add(node.val);\\n        inorder(node.right, result);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250198,
                "title": "c",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<vector<int>>ret ;\\n        vector<int>sortArr ;\\n        inorder(root, sortArr) ;\\n        for(auto& q : queries)\\n        {\\n            auto iter = lower_bound(sortArr.begin(), sortArr.end(), q) ;\\n            if(iter != sortArr.end() && *iter == q)\\n                ret.push_back({q, q}) ;\\n            else{\\n                if(iter == sortArr.begin())\\n                    ret.push_back({-1, *iter}) ;   \\n                else if(iter == sortArr.end())\\n                    ret.push_back({*prev(iter) , -1}) ;\\n                else\\n                   ret.push_back({*prev(iter) , *iter}) ; \\n            }\\n        }\\n        return ret ;\\n    }\\nprivate:\\n    void inorder(TreeNode* root, vector<int>&sortArr){\\n        if(!root)\\n            return ;\\n        inorder(root->left, sortArr) ;\\n        sortArr.push_back(root->val) ;\\n        inorder(root->right, sortArr) ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<vector<int>>ret ;\\n        vector<int>sortArr ;\\n        inorder(root, sortArr) ;\\n        for(auto& q : queries)\\n        {\\n            auto iter = lower_bound(sortArr.begin(), sortArr.end(), q) ;\\n            if(iter != sortArr.end() && *iter == q)\\n                ret.push_back({q, q}) ;\\n            else{\\n                if(iter == sortArr.begin())\\n                    ret.push_back({-1, *iter}) ;   \\n                else if(iter == sortArr.end())\\n                    ret.push_back({*prev(iter) , -1}) ;\\n                else\\n                   ret.push_back({*prev(iter) , *iter}) ; \\n            }\\n        }\\n        return ret ;\\n    }\\nprivate:\\n    void inorder(TreeNode* root, vector<int>&sortArr){\\n        if(!root)\\n            return ;\\n        inorder(root->left, sortArr) ;\\n        sortArr.push_back(root->val) ;\\n        inorder(root->right, sortArr) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247376,
                "title": "rust-solution",
                "content": "# Code\\n```\\nuse std::collections::*;\\ntype Target = i32;\\ntype UseValue = i32;\\nfn lower_bound(arr: &Vec<Target>, x: &UseValue) -> usize {\\n  let mut low = 0;\\n  let mut high = arr.len();\\n  while low != high {\\n    let mid = (low + high) / 2;\\n    match arr[mid].cmp(x) {\\n      std::cmp::Ordering::Less => {\\n        low = mid + 1;\\n      }\\n      std::cmp::Ordering::Equal | std::cmp::Ordering::Greater => {\\n        high = mid;\\n      }\\n    }\\n  }\\n  low\\n}\\n\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn closest_nodes(root: Option<Rc<RefCell<TreeNode>>>, queries: Vec<i32>) -> Vec<Vec<i32>> {\\n      let n = queries.len();\\n      let mut result = vec![vec![-1,-1];n];\\n      if let Some(node) = root {\\n        let mut helper = Helper { set: HashSet::new() };\\n        helper.dfs(&node);\\n        let mut arr = helper.set.into_iter().collect::<Vec<i32>>();\\n        arr.sort();\\n        let m = arr.len();\\n        for i in 0..n {          \\n          let target = queries[i];\\n          let ti = lower_bound(&arr, &target);\\n          let mut min = -1;\\n          let mut max = 1_000_000_000;\\n          for i in ti.saturating_sub(2)..m.min(ti+2) {\\n            let v = arr[i];\\n            if v <= target {\\n              min = min.max(v);\\n            }\\n            if v >= target {\\n              max = max.min(v);\\n            }\\n          }\\n\\n          if max == 1_000_000_000 {\\n            result[i] = vec![min,-1];\\n          } else {\\n            result[i] = vec![min, max];\\n          }\\n        }\\n      }\\n      result\\n    }\\n}\\nstruct Helper {\\n  set: HashSet<i32>\\n}\\nimpl Helper {\\n  fn dfs(&mut self, node:&Rc<RefCell<TreeNode>>) {\\n    self.set.insert(node.borrow().val);\\n    if let Some(left) = &node.borrow().left {\\n      self.dfs(&left);\\n    }\\n    if let Some(right) = &node.borrow().right {\\n      self.dfs(&right);\\n    }\\n  }  \\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::*;\\ntype Target = i32;\\ntype UseValue = i32;\\nfn lower_bound(arr: &Vec<Target>, x: &UseValue) -> usize {\\n  let mut low = 0;\\n  let mut high = arr.len();\\n  while low != high {\\n    let mid = (low + high) / 2;\\n    match arr[mid].cmp(x) {\\n      std::cmp::Ordering::Less => {\\n        low = mid + 1;\\n      }\\n      std::cmp::Ordering::Equal | std::cmp::Ordering::Greater => {\\n        high = mid;\\n      }\\n    }\\n  }\\n  low\\n}\\n\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn closest_nodes(root: Option<Rc<RefCell<TreeNode>>>, queries: Vec<i32>) -> Vec<Vec<i32>> {\\n      let n = queries.len();\\n      let mut result = vec![vec![-1,-1];n];\\n      if let Some(node) = root {\\n        let mut helper = Helper { set: HashSet::new() };\\n        helper.dfs(&node);\\n        let mut arr = helper.set.into_iter().collect::<Vec<i32>>();\\n        arr.sort();\\n        let m = arr.len();\\n        for i in 0..n {          \\n          let target = queries[i];\\n          let ti = lower_bound(&arr, &target);\\n          let mut min = -1;\\n          let mut max = 1_000_000_000;\\n          for i in ti.saturating_sub(2)..m.min(ti+2) {\\n            let v = arr[i];\\n            if v <= target {\\n              min = min.max(v);\\n            }\\n            if v >= target {\\n              max = max.min(v);\\n            }\\n          }\\n\\n          if max == 1_000_000_000 {\\n            result[i] = vec![min,-1];\\n          } else {\\n            result[i] = vec![min, max];\\n          }\\n        }\\n      }\\n      result\\n    }\\n}\\nstruct Helper {\\n  set: HashSet<i32>\\n}\\nimpl Helper {\\n  fn dfs(&mut self, node:&Rc<RefCell<TreeNode>>) {\\n    self.set.insert(node.borrow().val);\\n    if let Some(left) = &node.borrow().left {\\n      self.dfs(&left);\\n    }\\n    if let Some(right) = &node.borrow().right {\\n      self.dfs(&right);\\n    }\\n  }  \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3243280,
                "title": "brute-force-binary-search-inorder-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, vector<int>& tree)\\n    {\\n        if(!root) return;\\n        solve(root->left,tree);\\n        tree.push_back(root->val);\\n        solve(root->right,tree);\\n    }\\n\\n    void binarySearch(vector<int>& tree,int val,vector<vector<int>>& ans)\\n    {\\n        int s=0;\\n        int e=tree.size()-1;\\n        int l=e;\\n        vector<int> res;\\n        int mid;\\n\\n        while(e>=s)\\n        {\\n            mid = s+(e-s)/2;\\n            if(tree[mid]==val)\\n            {\\n                res.push_back(val);\\n                res.push_back(val);\\n                ans.push_back(res);\\n                return;\\n            }\\n            else if(tree[mid]>val)\\n               e = mid-1;\\n            else s=mid+1;\\n        }\\n        if(mid==0){\\n            if(tree[mid]<val)\\n             res.push_back(tree[mid]);\\n            else\\n             res.push_back(-1);\\n        }\\n        else if(tree[mid]>val)\\n            res.push_back(tree[mid-1]);\\n        else\\n            res.push_back(tree[mid]);\\n            \\n        if(mid==l){\\n            if(tree[mid]>val)\\n             res.push_back(tree[mid]);\\n            else\\n             res.push_back(-1);\\n        }\\n        else if(tree[mid]<val)\\n            res.push_back(tree[mid+1]);\\n        else res.push_back(tree[mid]);\\n\\n        ans.push_back(res);\\n\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n\\n        vector<vector<int>> ans;\\n        vector<int> tree;\\n        if(!root) return ans;\\n        solve(root,tree);\\n        for(auto x:tree)\\n          cout<<x<<\" \";\\n        \\n        for(int i=0; i<queries.size(); i++)\\n        {\\n            binarySearch(tree,queries[i],ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, vector<int>& tree)\\n    {\\n        if(!root) return;\\n        solve(root->left,tree);\\n        tree.push_back(root->val);\\n        solve(root->right,tree);\\n    }\\n\\n    void binarySearch(vector<int>& tree,int val,vector<vector<int>>& ans)\\n    {\\n        int s=0;\\n        int e=tree.size()-1;\\n        int l=e;\\n        vector<int> res;\\n        int mid;\\n\\n        while(e>=s)\\n        {\\n            mid = s+(e-s)/2;\\n            if(tree[mid]==val)\\n            {\\n                res.push_back(val);\\n                res.push_back(val);\\n                ans.push_back(res);\\n                return;\\n            }\\n            else if(tree[mid]>val)\\n               e = mid-1;\\n            else s=mid+1;\\n        }\\n        if(mid==0){\\n            if(tree[mid]<val)\\n             res.push_back(tree[mid]);\\n            else\\n             res.push_back(-1);\\n        }\\n        else if(tree[mid]>val)\\n            res.push_back(tree[mid-1]);\\n        else\\n            res.push_back(tree[mid]);\\n            \\n        if(mid==l){\\n            if(tree[mid]>val)\\n             res.push_back(tree[mid]);\\n            else\\n             res.push_back(-1);\\n        }\\n        else if(tree[mid]<val)\\n            res.push_back(tree[mid+1]);\\n        else res.push_back(tree[mid]);\\n\\n        ans.push_back(res);\\n\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n\\n        vector<vector<int>> ans;\\n        vector<int> tree;\\n        if(!root) return ans;\\n        solve(root,tree);\\n        for(auto x:tree)\\n          cout<<x<<\" \";\\n        \\n        for(int i=0; i<queries.size(); i++)\\n        {\\n            binarySearch(tree,queries[i],ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3228433,
                "title": "swift-solution",
                "content": "# Explanation\\n1. Traverse the tree in-order (left, root, right) to get a sorted array of values, sorted\\n2. For each query, search for the target in the sorted array, and return the closest value to the left and the closest value to the right of the target. If there is no value to the left or the right, return -1\\n3. To search for the closest value to the left of the target, use binary search to find the closest value that is less than or equal to the target\\n4. To search for the closest value to the right of the target, use binary search to find the closest value that is greater than or equal to the target\\n5. Return the list of closest values to the left and the right of the target for each query \\n\\n# Complexity\\n- Time complexity: O(nlogn), where n is the number of nodes in the BST\\n- Space complexity: O(n), where n is the number of nodes in the BST \\n\\n# Code\\n```\\nclass Solution {\\n    func closestNodes(_ root: TreeNode?, _ queries: [Int]) -> [[Int]] {\\n        var list = [[Int]]()\\n        let sorted = traverse(root)\\n        for q in queries {\\n            list.append([search1(sorted, q), search2(sorted, q)])\\n        }\\n        return list\\n    }\\n    private func traverse(_ root: TreeNode?) -> [Int] {\\n        var list = [Int]()\\n        var st = [TreeNode]()\\n        var cur = root\\n        while cur != nil || !st.isEmpty {\\n            if cur != nil {\\n                st.append(cur!)\\n                cur = cur!.left\\n            } else {\\n                cur = st.popLast()\\n                list.append(cur!.val)\\n                cur = cur!.right\\n            }\\n        }\\n        return list\\n    }\\n    private func search1(_ sorted: [Int], _ target: Int) -> Int {\\n        var l = 0\\n        var r = sorted.count - 1\\n        while l < r - 1 {\\n            let mid = l + (r - l) / 2\\n            let midVal = sorted[mid]\\n            if midVal == target {\\n                return midVal\\n            } else if midVal >= target {\\n                r = mid - 1\\n            } else {\\n                l = mid\\n            }\\n        }\\n        if sorted[r] <= target {\\n            return sorted[r]\\n        } else if sorted[l] <= target {\\n            return sorted[l]\\n        } else {\\n            return -1\\n        }\\n    }\\n    private func search2(_ sorted: [Int], _ target: Int) -> Int {\\n        var l = 0\\n        var r = sorted.count - 1\\n        while l < r - 1 {\\n            let mid = l + (r - l) / 2\\n            let midVal = sorted[mid]\\n            if midVal == target {\\n                return midVal\\n            } else if midVal <= target {\\n                l = mid + 1\\n            } else {\\n                r = mid\\n            }\\n        }\\n        if sorted[l] >= target {\\n            return sorted[l]\\n        } else if sorted[r] >= target {\\n            return sorted[r]\\n        } else {\\n            return -1\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func closestNodes(_ root: TreeNode?, _ queries: [Int]) -> [[Int]] {\\n        var list = [[Int]]()\\n        let sorted = traverse(root)\\n        for q in queries {\\n            list.append([search1(sorted, q), search2(sorted, q)])\\n        }\\n        return list\\n    }\\n    private func traverse(_ root: TreeNode?) -> [Int] {\\n        var list = [Int]()\\n        var st = [TreeNode]()\\n        var cur = root\\n        while cur != nil || !st.isEmpty {\\n            if cur != nil {\\n                st.append(cur!)\\n                cur = cur!.left\\n            } else {\\n                cur = st.popLast()\\n                list.append(cur!.val)\\n                cur = cur!.right\\n            }\\n        }\\n        return list\\n    }\\n    private func search1(_ sorted: [Int], _ target: Int) -> Int {\\n        var l = 0\\n        var r = sorted.count - 1\\n        while l < r - 1 {\\n            let mid = l + (r - l) / 2\\n            let midVal = sorted[mid]\\n            if midVal == target {\\n                return midVal\\n            } else if midVal >= target {\\n                r = mid - 1\\n            } else {\\n                l = mid\\n            }\\n        }\\n        if sorted[r] <= target {\\n            return sorted[r]\\n        } else if sorted[l] <= target {\\n            return sorted[l]\\n        } else {\\n            return -1\\n        }\\n    }\\n    private func search2(_ sorted: [Int], _ target: Int) -> Int {\\n        var l = 0\\n        var r = sorted.count - 1\\n        while l < r - 1 {\\n            let mid = l + (r - l) / 2\\n            let midVal = sorted[mid]\\n            if midVal == target {\\n                return midVal\\n            } else if midVal <= target {\\n                l = mid + 1\\n            } else {\\n                r = mid\\n            }\\n        }\\n        if sorted[l] >= target {\\n            return sorted[l]\\n        } else if sorted[r] >= target {\\n            return sorted[r]\\n        } else {\\n            return -1\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227394,
                "title": "c-solution-using-inorder-traversal-and-binary-search-algorithm",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    void getInorderTraversal(TreeNode* root, vector<int>& inorder) {\\n        \\n        // Base Case\\n        if(root == NULL) {\\n            return;\\n        }\\n        \\n        // Recursive Case\\n        getInorderTraversal(root->left, inorder);\\n        inorder.push_back(root->val);\\n        getInorderTraversal(root->right, inorder);\\n        return;\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int>inorder;\\n        \\n        // Getting the inorder traversal. Which will be a sorted array of all the elements in the given tree.\\n        getInorderTraversal(root, inorder);\\n        vector<vector<int>>ans;\\n        \\n        // Applying binary search algorithm to get the smaller and larger element for every queries element.\\n        for(int i = 0; i < queries.size(); i++) {\\n            int idx = lower_bound(inorder.begin(), inorder.end(), queries[i]) - inorder.begin();\\n            if(idx >= inorder.size()) {\\n                ans.push_back({inorder[idx - 1], -1});\\n            }\\n            else if(inorder[idx] > queries[i]) {\\n                if(idx != 0) {\\n                    ans.push_back({inorder[idx - 1], inorder[idx]});\\n                }\\n                else {\\n                    ans.push_back({-1, inorder[idx]});\\n                }\\n            }\\n            else {\\n                ans.push_back({inorder[idx], inorder[idx]});   \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Search Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    void getInorderTraversal(TreeNode* root, vector<int>& inorder) {\\n        \\n        // Base Case\\n        if(root == NULL) {\\n            return;\\n        }\\n        \\n        // Recursive Case\\n        getInorderTraversal(root->left, inorder);\\n        inorder.push_back(root->val);\\n        getInorderTraversal(root->right, inorder);\\n        return;\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int>inorder;\\n        \\n        // Getting the inorder traversal. Which will be a sorted array of all the elements in the given tree.\\n        getInorderTraversal(root, inorder);\\n        vector<vector<int>>ans;\\n        \\n        // Applying binary search algorithm to get the smaller and larger element for every queries element.\\n        for(int i = 0; i < queries.size(); i++) {\\n            int idx = lower_bound(inorder.begin(), inorder.end(), queries[i]) - inorder.begin();\\n            if(idx >= inorder.size()) {\\n                ans.push_back({inorder[idx - 1], -1});\\n            }\\n            else if(inorder[idx] > queries[i]) {\\n                if(idx != 0) {\\n                    ans.push_back({inorder[idx - 1], inorder[idx]});\\n                }\\n                else {\\n                    ans.push_back({-1, inorder[idx]});\\n                }\\n            }\\n            else {\\n                ans.push_back({inorder[idx], inorder[idx]});   \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223750,
                "title": "what-a-shame",
                "content": "# What a shame\\n\\n\\nIt\\'s a shame that LeetCode banned this very elegant solution which finds floor(x) and ceil(x) in a single pass. \\n\\nIt\\'s a shame that for a BST tree problem you have to convert the tree to an array and use binary search (or TreeSet equivalent etc) to pass the properly designed test case 34/35 favoring array. Solutions for BST that use binary search on BST is baned. \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<vector<int>> res;\\n        res.reserve(queries.size());\\n        for (auto q : queries) {\\n            res.push_back(floor_ceil(root, q));\\n        }\\n        return res;\\n    }\\n\\nprivate:\\n    vector<int> floor_ceil(TreeNode* root, int q) {\\n        int floor = -1, ceil = -1;\\n        while (root) {\\n            if (root->val < q) {\\n                floor = root->val;\\n                root = root->right;\\n            } else if (root->val > q) {\\n                ceil = root->val;\\n                root = root->left;\\n            } else {\\n                return {q, q};\\n            }\\n        }\\n        return {floor, ceil};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<vector<int>> res;\\n        res.reserve(queries.size());\\n        for (auto q : queries) {\\n            res.push_back(floor_ceil(root, q));\\n        }\\n        return res;\\n    }\\n\\nprivate:\\n    vector<int> floor_ceil(TreeNode* root, int q) {\\n        int floor = -1, ceil = -1;\\n        while (root) {\\n            if (root->val < q) {\\n                floor = root->val;\\n                root = root->right;\\n            } else if (root->val > q) {\\n                ceil = root->val;\\n                root = root->left;\\n            } else {\\n                return {q, q};\\n            }\\n        }\\n        return {floor, ceil};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3215969,
                "title": "binary-search-tree-dfs-to-find-the-inorder-traversal-lower-bound-and-upper-bound",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> dfs;\\n    void f(TreeNode* root){\\n        if(root==NULL){\\n            return;\\n        }\\n        f(root->left);\\n        dfs.push_back(root->val);\\n        f(root->right);\\n    }\\n    int lower(int k){\\n        int low=0;\\n        int high=dfs.size()-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(dfs[mid]>k){\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return high;\\n    }\\n    int higher(int k){\\n        int low=0;\\n        int high=dfs.size()-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(dfs[mid]<k){\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return low;\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        f(root);\\n        vector<vector<int>> ans;\\n        for(auto it:queries){\\n            int mini=lower(it);\\n            int maxi=higher(it);\\n            ans.push_back({(mini>=0 and mini<dfs.size())?dfs[mini]:-1, (maxi>=0 and maxi<dfs.size())?dfs[maxi]:-1});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dfs;\\n    void f(TreeNode* root){\\n        if(root==NULL){\\n            return;\\n        }\\n        f(root->left);\\n        dfs.push_back(root->val);\\n        f(root->right);\\n    }\\n    int lower(int k){\\n        int low=0;\\n        int high=dfs.size()-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(dfs[mid]>k){\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return high;\\n    }\\n    int higher(int k){\\n        int low=0;\\n        int high=dfs.size()-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(dfs[mid]<k){\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return low;\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        f(root);\\n        vector<vector<int>> ans;\\n        for(auto it:queries){\\n            int mini=lower(it);\\n            int maxi=higher(it);\\n            ans.push_back({(mini>=0 and mini<dfs.size())?dfs[mini]:-1, (maxi>=0 and maxi<dfs.size())?dfs[maxi]:-1});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197911,
                "title": "c-binary-search",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void inorder(vector<int> &nums, TreeNode* root) {\\n        if(!root) return;\\n        inorder(nums, root -> left);\\n        nums.push_back(root -> val);\\n        inorder(nums, root -> right);\\n    }\\npublic:\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<vector<int>> ans;\\n        vector<int> nums;\\n        inorder(nums, root);\\n        for(int query: queries) {\\n            auto iter = upper_bound(nums.begin(), nums.end(), query);\\n            int l = iter == nums.begin()? -1: nums[prev(iter) - nums.begin()]; \\n            int h = iter == nums.end()? -1: nums[iter - nums.begin()];\\n            h = l == query? l: h;\\n            ans.push_back({l, h});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void inorder(vector<int> &nums, TreeNode* root) {\\n        if(!root) return;\\n        inorder(nums, root -> left);\\n        nums.push_back(root -> val);\\n        inorder(nums, root -> right);\\n    }\\npublic:\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<vector<int>> ans;\\n        vector<int> nums;\\n        inorder(nums, root);\\n        for(int query: queries) {\\n            auto iter = upper_bound(nums.begin(), nums.end(), query);\\n            int l = iter == nums.begin()? -1: nums[prev(iter) - nums.begin()]; \\n            int h = iter == nums.end()? -1: nums[iter - nums.begin()];\\n            h = l == query? l: h;\\n            ans.push_back({l, h});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197138,
                "title": "easiest-solution-with-proper-breakdown-into-different-functions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def closestNodes(self, root, queries):\\n        \"\"\"\\n        :type root: Optional[TreeNode]\\n        :type queries: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def binarySearch(query,values):\\n            low = 0\\n            high = len(values) - 1\\n            if query > values[-1]:\\n                return [values[-1],-1]\\n            if query < values[0]:\\n                return [-1,values[0]]\\n            while low <= high:\\n                middle = low + (high - low) // 2\\n                if values[middle] == query:\\n                    return [values[middle],values[middle]]\\n                elif values[middle] < query:\\n                    low = middle + 1\\n                else:\\n                    high = middle - 1\\n            return [values[high],values[low]]\\n        \\n        def inOrderTraverse(root,output):\\n            if root.left:\\n                inOrderTraverse(root.left,output)\\n            output.append(root.val)\\n            if root.right:\\n                inOrderTraverse(root.right,output)\\n        \\n        if not root:\\n            return\\n        output = []\\n        inOrderTraverse(root,output)\\n        real_output = []\\n        for i in queries:\\n            real_output.append(binarySearch(i,output))\\n        return real_output\\n        \\n    \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def closestNodes(self, root, queries):\\n        \"\"\"\\n        :type root: Optional[TreeNode]\\n        :type queries: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def binarySearch(query,values):\\n            low = 0\\n            high = len(values) - 1\\n            if query > values[-1]:\\n                return [values[-1],-1]\\n            if query < values[0]:\\n                return [-1,values[0]]\\n            while low <= high:\\n                middle = low + (high - low) // 2\\n                if values[middle] == query:\\n                    return [values[middle],values[middle]]\\n                elif values[middle] < query:\\n                    low = middle + 1\\n                else:\\n                    high = middle - 1\\n            return [values[high],values[low]]\\n        \\n        def inOrderTraverse(root,output):\\n            if root.left:\\n                inOrderTraverse(root.left,output)\\n            output.append(root.val)\\n            if root.right:\\n                inOrderTraverse(root.right,output)\\n        \\n        if not root:\\n            return\\n        output = []\\n        inOrderTraverse(root,output)\\n        real_output = []\\n        for i in queries:\\n            real_output.append(binarySearch(i,output))\\n        return real_output\\n        \\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195716,
                "title": "c-easy-2pointers",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<vector<int>> ans;\\n        vector<int> A;\\n        A.push_back(INT_MIN);\\n        inorder(root,A);\\n        A.push_back(INT_MAX);\\n        int n = A.size(), m = queries.size();\\n        vector<vector<int>> qs = vector<vector<int>> (m, vector<int>(4,-1));\\n        for(int i = 0; i < queries.size(); i++) { \\n            qs[i][0] = queries[i]; \\n            qs[i][1] = i; \\n        }\\n      \\n        sort(qs.begin(), qs.end(), [](auto &lhs, auto &rhs){return lhs[0] < rhs[0];});\\n         \\n        int Ai = 0, Qi =0; \\n        while(Ai < n && Qi < m) {\\n            if(qs[Qi][0] == A[Ai]){\\n                qs[Qi][2] = qs[Qi][3] = qs[Qi][0];\\n                Qi++;\\n            } else if(qs[Qi][0] > A[Ai]) {\\n                Ai++;\\n            } else { \\n                if(Ai-1>0) qs[Qi][2] = A[Ai-1]; \\n                if(Ai<n-1) qs[Qi][3] = A[Ai]; \\n                Qi++;\\n            }           \\n        }\\n        sort(qs.begin(), qs.end(), [](auto &lhs, auto&rhs){return lhs[1] < rhs[1];});\\n        for(auto &v: qs)  ans.push_back({v[2], v[3]});\\n\\n        return ans;\\n    }\\n    \\n    void inorder(TreeNode* root, vector<int>& res) {\\n        if(root==nullptr) return;\\n        inorder(root->left, res);\\n        res.push_back(root->val);\\n        inorder(root->right, res);\\n    }  \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<vector<int>> ans;\\n        vector<int> A;\\n        A.push_back(INT_MIN);\\n        inorder(root,A);\\n        A.push_back(INT_MAX);\\n        int n = A.size(), m = queries.size();\\n        vector<vector<int>> qs = vector<vector<int>> (m, vector<int>(4,-1));\\n        for(int i = 0; i < queries.size(); i++) { \\n            qs[i][0] = queries[i]; \\n            qs[i][1] = i; \\n        }\\n      \\n        sort(qs.begin(), qs.end(), [](auto &lhs, auto &rhs){return lhs[0] < rhs[0];});\\n         \\n        int Ai = 0, Qi =0; \\n        while(Ai < n && Qi < m) {\\n            if(qs[Qi][0] == A[Ai]){\\n                qs[Qi][2] = qs[Qi][3] = qs[Qi][0];\\n                Qi++;\\n            } else if(qs[Qi][0] > A[Ai]) {\\n                Ai++;\\n            } else { \\n                if(Ai-1>0) qs[Qi][2] = A[Ai-1]; \\n                if(Ai<n-1) qs[Qi][3] = A[Ai]; \\n                Qi++;\\n            }           \\n        }\\n        sort(qs.begin(), qs.end(), [](auto &lhs, auto&rhs){return lhs[1] < rhs[1];});\\n        for(auto &v: qs)  ans.push_back({v[2], v[3]});\\n\\n        return ans;\\n    }\\n    \\n    void inorder(TreeNode* root, vector<int>& res) {\\n        if(root==nullptr) return;\\n        inorder(root->left, res);\\n        res.push_back(root->val);\\n        inorder(root->right, res);\\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194849,
                "title": "c-inorder-traversal-beginner-friendly-stl",
                "content": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int> &vec){\\n        if(root==nullptr){\\n            return;\\n        }\\n        inorder(root->left,vec);\\n        vec.push_back(root->val);\\n        inorder(root->right,vec);\\n    }\\n    \\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int> vec;\\n        inorder(root,vec);\\n        int N=vec.size();\\n        \\n        vector<vector<int>> res;\\n        for(auto q: queries){\\n            int index=lower_bound(vec.begin(),vec.end(),q)-vec.begin();\\n            if(index!=N && vec[index]==q){\\n                res.push_back({vec[index],vec[index]});\\n            }\\n            else{\\n\\t\\t\\t\\t /* Lower Bound returns an index value either equal to target or greater than\\n\\t\\t\\t\\t target. If ended up in else, this means index value for sure greater than target.\\n\\t\\t\\t\\t Checking, if index==0, then obviously, nothing exists before it, then this means \\n\\t\\t\\t\\t left does not exist or -1. And for right, if it is not at index N, then you got a\\n\\t\\t\\t\\t value, since its greater than target anyways */\\n                int lr=index==0 ? -1 : vec[index-1];\\n                int hr=index==N ? -1 : vec[index];\\n                res.push_back({lr,hr});\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int> &vec){\\n        if(root==nullptr){\\n            return;\\n        }\\n        inorder(root->left,vec);\\n        vec.push_back(root->val);\\n        inorder(root->right,vec);\\n    }\\n    \\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int> vec;\\n        inorder(root,vec);\\n        int N=vec.size();\\n        \\n        vector<vector<int>> res;\\n        for(auto q: queries){\\n            int index=lower_bound(vec.begin(),vec.end(),q)-vec.begin();\\n            if(index!=N && vec[index]==q){\\n                res.push_back({vec[index],vec[index]});\\n            }\\n            else{\\n\\t\\t\\t\\t /* Lower Bound returns an index value either equal to target or greater than\\n\\t\\t\\t\\t target. If ended up in else, this means index value for sure greater than target.\\n\\t\\t\\t\\t Checking, if index==0, then obviously, nothing exists before it, then this means \\n\\t\\t\\t\\t left does not exist or -1. And for right, if it is not at index N, then you got a\\n\\t\\t\\t\\t value, since its greater than target anyways */\\n                int lr=index==0 ? -1 : vec[index-1];\\n                int hr=index==N ? -1 : vec[index];\\n                res.push_back({lr,hr});\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3153320,
                "title": "java-inorder-traversal-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSorted --> Inorder Traverse;\\ngetClosest --> Binary Search;\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ni. Get the inorder traversal of the tree;\\nii. Get the \"last occurrence of smaller or equal\" as lower, \"first occurrence of larger or equal\" as higher;\\niii. add(Arrays.asList(lower, higher)) to result;\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NLOGN)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> sorted = traverse(root);\\n        for (int q : queries) {\\n            list.add(Arrays.asList(search1(sorted, q), search2(sorted, q)));\\n        }\\n        return list;\\n    }\\n    private List<Integer> traverse(TreeNode root) { // Iterative inorder traversal\\n        List<Integer> list = new ArrayList<>();\\n        Deque<TreeNode> st = new ArrayDeque<>();\\n        TreeNode cur = root;\\n        while (cur != null || !st.isEmpty()) {\\n            if (cur != null) {\\n                st.offerFirst(cur);\\n                cur = cur.left;\\n            } else {\\n                cur = st.pollFirst();\\n                list.add(cur.val);\\n                cur = cur.right;\\n            }\\n        }\\n        return list;\\n    }\\n    private int search1(List<Integer> sorted, int target) { // last occurrence of smaller or equal\\n        int l = 0, r = sorted.size() - 1;\\n        while (l < r - 1) {\\n            int mid = l + (r - l) / 2, midVal = sorted.get(mid);\\n            if (midVal == target) return midVal;\\n            else if (midVal >= target) r = mid - 1;\\n            else l = mid;\\n        }\\n        if (sorted.get(r) <= target) return sorted.get(r);\\n        else if (sorted.get(l) <= target) return sorted.get(l);\\n        else return -1;\\n    }\\n    private int search2(List<Integer> sorted, int target) { // first occurrence of larger or equal\\n        int l = 0, r = sorted.size() - 1;\\n        while (l < r - 1) {\\n            int mid = l + (r - l) / 2, midVal = sorted.get(mid);\\n            if (midVal == target) return midVal;\\n            else if (midVal <= target) l = mid + 1;\\n            else r = mid;\\n        }\\n        if (sorted.get(l) >= target) return sorted.get(l);\\n        else if (sorted.get(r) >= target) return sorted.get(r);\\n        else return -1;\\n    }\\n}\\n/*\\n    Another solution that did not pass the last test case because of its worst case of TC O(N^2), despite its average case of TC O(N*HEIGHT) and its SC O(1)\\n\\n    class Solution {\\n        public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n            List<List<Integer>> list = new ArrayList<>();\\n            for (int q : queries) {\\n                list.add(get(root, q));\\n            }\\n            return list;\\n        }   \\n        private List<Integer> get(TreeNode root, int target) {\\n            int low = Integer.MIN_VALUE, high = Integer.MAX_VALUE;\\n            TreeNode cur = root;\\n            while (cur != null) {\\n                if (cur.val == target) {\\n                    return Arrays.asList(target, target);\\n                } else if (cur.val > target) {\\n                    high = Math.min(high, cur.val);\\n                    cur = cur.left;\\n                } else {\\n                    low = Math.max(low, cur.val);\\n                    cur = cur.right;\\n                }\\n            }\\n            low = low == Integer.MIN_VALUE ? -1 : low;\\n            high = high == Integer.MAX_VALUE ? -1 : high;\\n            return Arrays.asList(low, high);\\n        }\\n    }\\n*/\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> sorted = traverse(root);\\n        for (int q : queries) {\\n            list.add(Arrays.asList(search1(sorted, q), search2(sorted, q)));\\n        }\\n        return list;\\n    }\\n    private List<Integer> traverse(TreeNode root) { // Iterative inorder traversal\\n        List<Integer> list = new ArrayList<>();\\n        Deque<TreeNode> st = new ArrayDeque<>();\\n        TreeNode cur = root;\\n        while (cur != null || !st.isEmpty()) {\\n            if (cur != null) {\\n                st.offerFirst(cur);\\n                cur = cur.left;\\n            } else {\\n                cur = st.pollFirst();\\n                list.add(cur.val);\\n                cur = cur.right;\\n            }\\n        }\\n        return list;\\n    }\\n    private int search1(List<Integer> sorted, int target) { // last occurrence of smaller or equal\\n        int l = 0, r = sorted.size() - 1;\\n        while (l < r - 1) {\\n            int mid = l + (r - l) / 2, midVal = sorted.get(mid);\\n            if (midVal == target) return midVal;\\n            else if (midVal >= target) r = mid - 1;\\n            else l = mid;\\n        }\\n        if (sorted.get(r) <= target) return sorted.get(r);\\n        else if (sorted.get(l) <= target) return sorted.get(l);\\n        else return -1;\\n    }\\n    private int search2(List<Integer> sorted, int target) { // first occurrence of larger or equal\\n        int l = 0, r = sorted.size() - 1;\\n        while (l < r - 1) {\\n            int mid = l + (r - l) / 2, midVal = sorted.get(mid);\\n            if (midVal == target) return midVal;\\n            else if (midVal <= target) l = mid + 1;\\n            else r = mid;\\n        }\\n        if (sorted.get(l) >= target) return sorted.get(l);\\n        else if (sorted.get(r) >= target) return sorted.get(r);\\n        else return -1;\\n    }\\n}\\n/*\\n    Another solution that did not pass the last test case because of its worst case of TC O(N^2), despite its average case of TC O(N*HEIGHT) and its SC O(1)\\n\\n    class Solution {\\n        public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n            List<List<Integer>> list = new ArrayList<>();\\n            for (int q : queries) {\\n                list.add(get(root, q));\\n            }\\n            return list;\\n        }   \\n        private List<Integer> get(TreeNode root, int target) {\\n            int low = Integer.MIN_VALUE, high = Integer.MAX_VALUE;\\n            TreeNode cur = root;\\n            while (cur != null) {\\n                if (cur.val == target) {\\n                    return Arrays.asList(target, target);\\n                } else if (cur.val > target) {\\n                    high = Math.min(high, cur.val);\\n                    cur = cur.left;\\n                } else {\\n                    low = Math.max(low, cur.val);\\n                    cur = cur.right;\\n                }\\n            }\\n            low = low == Integer.MIN_VALUE ? -1 : low;\\n            high = high == Integer.MAX_VALUE ? -1 : high;\\n            return Arrays.asList(low, high);\\n        }\\n    }\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131195,
                "title": "c-solution-inorder-traversal-and-binary-search",
                "content": "# Intuition\\nAs the question itself states that we have to search for the  largest value in the tree that is smaller than or equal to a given query and the smallest value in the tree that is greater than or equal to the given query. The first thing that comes to mind is that it is given that the tree is a Binary Search Tree, so the inorder traversal can given us the nodes in sorted order and then we can apply our search function. Now ofcourse, if we check on the Brute Force we can do the linear Search which will give us the time complexity of O(k*n); where k is the size of the queries array and n is the size of the array wherein we are storing the nodes after doing inorder traversal.\\n\\n# Approach\\nNow to improve the time complexity of linear search the best thing we can do is to do Binary Search on the node array. \\nStep 1. Do Inorder Traversal on the BST and store the values of the nodes in an array.\\nStep 2. Take two variables lb (to store the lower bound i.e. largest value in the tree that is smaller than or equal to a given query) and ub (to store upper bound i.e. the smallest value in the tree that is greater than or equal to the given query) and initialize them as INT_MIN and INT_MAX respectively.\\nStep 3. Now, start the Binary Search. Every time, you encounter a number greater than or equal to the given query decrement \\'hi\\' to mid-1 and upgrade ub to the minimum between it\\'s current value and the value which is currently being checked upon!\\nStep 4. Similarly, Every time you encounter a number less than or equal to the given query increment \\'lo\\' to mid+1 and upgrade lb to the maximum between it\\'s current value and the value which is currently being checked upon!\\nStep 5. Continue till the loop breaks!\\n\\n# Complexity\\n- Time complexity: O(k*log n)\\n\\n- Space complexity: O(n) (to store the values of nodes after the inorder traversal)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    void inorder(TreeNode* root){\\n        if(root){\\n            inorder(root->left);\\n            v.push_back(root->val);\\n            inorder(root->right);\\n        }\\n    } \\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        inorder(root);\\n        vector<vector<int>> ans;\\n        int n= queries.size();\\n        for(int i=0;i<n;i++){\\n            int numToFind= queries[i];\\n            int lo=0, hi=v.size()-1;\\n            int lb= INT_MIN, ub= INT_MAX;\\n            while(lo<=hi){\\n                int mid= lo+(hi-lo)/2;\\n                if(v[mid]==numToFind){\\n                    lb= ub= numToFind;\\n                    break;\\n                }\\n                else if(v[mid]>numToFind){\\n                    ub= min(ub, v[mid]);\\n                    hi= mid-1;\\n                }\\n                else{\\n                    lb= max(lb, v[mid]);\\n                    lo= mid+1;\\n                }\\n            }\\n            if(lb==INT_MIN) { lb=-1; }\\n            if(ub==INT_MAX) { ub=-1; }\\n            ans.push_back({lb,ub});\\n        }    \\n        return ans;\\n    }\\n};\\n```\\n\\nKindly Upvote!!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    void inorder(TreeNode* root){\\n        if(root){\\n            inorder(root->left);\\n            v.push_back(root->val);\\n            inorder(root->right);\\n        }\\n    } \\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        inorder(root);\\n        vector<vector<int>> ans;\\n        int n= queries.size();\\n        for(int i=0;i<n;i++){\\n            int numToFind= queries[i];\\n            int lo=0, hi=v.size()-1;\\n            int lb= INT_MIN, ub= INT_MAX;\\n            while(lo<=hi){\\n                int mid= lo+(hi-lo)/2;\\n                if(v[mid]==numToFind){\\n                    lb= ub= numToFind;\\n                    break;\\n                }\\n                else if(v[mid]>numToFind){\\n                    ub= min(ub, v[mid]);\\n                    hi= mid-1;\\n                }\\n                else{\\n                    lb= max(lb, v[mid]);\\n                    lo= mid+1;\\n                }\\n            }\\n            if(lb==INT_MIN) { lb=-1; }\\n            if(ub==INT_MAX) { ub=-1; }\\n            ans.push_back({lb,ub});\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117816,
                "title": "java-easy-understanding",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<Integer> list;\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        list = new ArrayList<>();\\n        doInorder(root);\\n        //do binary search\\n        List<List<Integer>> res = new ArrayList<>();\\n        for(Integer query : queries) {\\n            List<Integer> ans = new ArrayList<>();\\n            ans.add(getMin(list,0,list.size()-1,query));\\n            ans.add(getMax(list,0,list.size()-1,query));\\n            res.add(ans);\\n        }\\n        \\n        return res;\\n        \\n    }\\n    \\n    public int getMin(List<Integer> list,int low,int high,int val){\\n        int min = -1;\\n        while(low<=high){\\n            int mid = low + (high - low)/2;\\n            if(list.get(mid) == val){\\n                return list.get(mid);\\n            }else if(list.get(mid) > val){\\n                high = mid -1;\\n            }else{\\n                min = list.get(mid);\\n                low = mid + 1;\\n            }\\n            \\n        }\\n        return min;\\n    }\\n    \\n    public int getMax(List<Integer> list,int low,int high,int val){\\n        int max = -1;\\n        while(low<=high){\\n            int mid = low + (high - low)/2;\\n            if(list.get(mid) == val){\\n                return list.get(mid);\\n            }else if(list.get(mid) > val){\\n                max = list.get(mid);\\n                high = mid -1;\\n            }else{\\n                low = mid + 1;\\n            }\\n            \\n        }\\n        return max;\\n    }\\n    \\n    public void doInorder(TreeNode root){\\n        if(root == null){\\n            return;\\n        }\\n        doInorder(root.left);\\n        list.add(root.val);\\n        doInorder(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<Integer> list;\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        list = new ArrayList<>();\\n        doInorder(root);\\n        //do binary search\\n        List<List<Integer>> res = new ArrayList<>();\\n        for(Integer query : queries) {\\n            List<Integer> ans = new ArrayList<>();\\n            ans.add(getMin(list,0,list.size()-1,query));\\n            ans.add(getMax(list,0,list.size()-1,query));\\n            res.add(ans);\\n        }\\n        \\n        return res;\\n        \\n    }\\n    \\n    public int getMin(List<Integer> list,int low,int high,int val){\\n        int min = -1;\\n        while(low<=high){\\n            int mid = low + (high - low)/2;\\n            if(list.get(mid) == val){\\n                return list.get(mid);\\n            }else if(list.get(mid) > val){\\n                high = mid -1;\\n            }else{\\n                min = list.get(mid);\\n                low = mid + 1;\\n            }\\n            \\n        }\\n        return min;\\n    }\\n    \\n    public int getMax(List<Integer> list,int low,int high,int val){\\n        int max = -1;\\n        while(low<=high){\\n            int mid = low + (high - low)/2;\\n            if(list.get(mid) == val){\\n                return list.get(mid);\\n            }else if(list.get(mid) > val){\\n                max = list.get(mid);\\n                high = mid -1;\\n            }else{\\n                low = mid + 1;\\n            }\\n            \\n        }\\n        return max;\\n    }\\n    \\n    public void doInorder(TreeNode root){\\n        if(root == null){\\n            return;\\n        }\\n        doInorder(root.left);\\n        list.add(root.val);\\n        doInorder(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104660,
                "title": "c-clean-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:vector<int> v;\\n     void t(TreeNode* r)\\n     {\\n         if(!r)\\n         return ;\\n         v.push_back(r->val);\\n         t(r->right);\\n         t(r->left);\\n     }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        t(root);\\n        sort(v.begin(),v.end());\\n        vector<vector<int>> ans;\\n        for(auto i : queries)\\n        {\\n            vector<int> a;\\n            int s=0,e=v.size()-1;int l=INT_MIN;\\n            while(s<=e)\\n            {\\n                int m=(s+e)/2;\\n                  if(v[m]<=i)\\n                  {\\n                      s=m+1;\\n                      l=v[m];\\n                  }\\n                  else\\n                  e=m-1;\\n            };\\n            if(l==INT_MIN)\\n            a.push_back(-1);\\n            else\\n            a.push_back(l);\\n            l=INT_MAX;\\n            s=0,e=v.size()-1;\\n            \\n             while(s<=e)\\n            {\\n                int m=(s+e)/2;\\n                  if(v[m]>=i)\\n                  {\\n                      e=m-1;\\n                      l=v[m];\\n                  }\\n                  else\\n                  s=m+1;\\n            };\\n            if(l==INT_MAX)\\n            a.push_back(-1);\\n            else\\n            a.push_back(l);\\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:vector<int> v;\\n     void t(TreeNode* r)\\n     {\\n         if(!r)\\n         return ;\\n         v.push_back(r->val);\\n         t(r->right);\\n         t(r->left);\\n     }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        t(root);\\n        sort(v.begin(),v.end());\\n        vector<vector<int>> ans;\\n        for(auto i : queries)\\n        {\\n            vector<int> a;\\n            int s=0,e=v.size()-1;int l=INT_MIN;\\n            while(s<=e)\\n            {\\n                int m=(s+e)/2;\\n                  if(v[m]<=i)\\n                  {\\n                      s=m+1;\\n                      l=v[m];\\n                  }\\n                  else\\n                  e=m-1;\\n            };\\n            if(l==INT_MIN)\\n            a.push_back(-1);\\n            else\\n            a.push_back(l);\\n            l=INT_MAX;\\n            s=0,e=v.size()-1;\\n            \\n             while(s<=e)\\n            {\\n                int m=(s+e)/2;\\n                  if(v[m]>=i)\\n                  {\\n                      e=m-1;\\n                      l=v[m];\\n                  }\\n                  else\\n                  s=m+1;\\n            };\\n            if(l==INT_MAX)\\n            a.push_back(-1);\\n            else\\n            a.push_back(l);\\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050082,
                "title": "python-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    def inorder(self,root,nums):\\n        \\n        if(root):\\n            \\n            self.inorder(root.left,nums)\\n            \\n            nums.append(root.val)\\n            \\n            self.inorder(root.right,nums)\\n        \\n        \\n            \\n            \\n    def helper(self,nums,val):\\n        \\n        l = 0 \\n        r = len(nums) - 1 \\n        ans1 = -1\\n        while(l <= r):\\n            \\n            mid = l + (r-l)//2\\n            \\n            if(nums[mid] <= val):\\n                \\n                ans1 = nums[mid]\\n                \\n                l = mid + 1 \\n            \\n            else:\\n                \\n                r = mid - 1 \\n        \\n        \\n        l = 0 \\n        r = len(nums) - 1 \\n        ans2 = -1\\n        \\n        while(l <= r):\\n            \\n            mid = l + (r- l)//2\\n            \\n            if(nums[mid] >= val):\\n                \\n                ans2 = nums[mid]\\n                \\n                r = mid - 1 \\n            \\n            else:\\n                \\n                l = mid + 1 \\n        \\n        \\n        return [ans1,ans2]\\n                \\n                \\n                \\n                \\n        \\n    \\n    def closestNodes(self, root: Optional[TreeNode], q: List[int]) -> List[List[int]]:\\n        \\n        nums = []\\n        \\n        self.inorder(root,nums)\\n        ans = []\\n        \\n        for i in q:\\n            \\n            ans.append(self.helper(nums,i))\\n        \\n        return ans\\n            \\n            \\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    def inorder(self,root,nums):\\n        \\n        if(root):\\n            \\n            self.inorder(root.left,nums)\\n            \\n            nums.append(root.val)\\n            \\n            self.inorder(root.right,nums)\\n        \\n        \\n            \\n            \\n    def helper(self,nums,val):\\n        \\n        l = 0 \\n        r = len(nums) - 1 \\n        ans1 = -1\\n        while(l <= r):\\n            \\n            mid = l + (r-l)//2\\n            \\n            if(nums[mid] <= val):\\n                \\n                ans1 = nums[mid]\\n                \\n                l = mid + 1 \\n            \\n            else:\\n                \\n                r = mid - 1 \\n        \\n        \\n        l = 0 \\n        r = len(nums) - 1 \\n        ans2 = -1\\n        \\n        while(l <= r):\\n            \\n            mid = l + (r- l)//2\\n            \\n            if(nums[mid] >= val):\\n                \\n                ans2 = nums[mid]\\n                \\n                r = mid - 1 \\n            \\n            else:\\n                \\n                l = mid + 1 \\n        \\n        \\n        return [ans1,ans2]\\n                \\n                \\n                \\n                \\n        \\n    \\n    def closestNodes(self, root: Optional[TreeNode], q: List[int]) -> List[List[int]]:\\n        \\n        nums = []\\n        \\n        self.inorder(root,nums)\\n        ans = []\\n        \\n        for i in q:\\n            \\n            ans.append(self.helper(nums,i))\\n        \\n        return ans\\n            \\n            \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3024324,
                "title": "java-solution-tc-o-m-n-log-m-sc-o-m-m-is-total-nodes-in-bst-n-is-query-length",
                "content": "# Intuition\\n    Please refer the comment in the code section\\n\\n# Approach\\n    Please refer the comment in the code section\\n\\n# Complexity\\n- Time complexity:\\n- O(m + n * log m), m is total nodes in BST, n is query length\\n\\n- Space complexity:\\n    - O(m), m is total nodes in BST\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    /** \\n        This problem has been asked in below companies:\\n        Google\\n    */\\n\\n    /** \\n        The idea is for each query value, search in the Tree.\\n        Search:\\n            for min, we need to find max value less than or equal the query value\\n            for max, we need to find min value greater than or equal the query value\\n\\n            1. first we check the node val is equl to the query value, if yes we can just simply return the val\\n            2. if node value is greater than the query value, then we can say we have find the max value till now, \\n                so we dont need to go to right of the node, but we need to go to left, \\n                becuase we need to find smallest max so it could be the case that we still can find a value \\n                which is greater than query value but smaller than previous max value\\n\\n            3. if the node value is smaller than query value then we have find the min value till now.\\n                so we dont need to go to left, we can go to right because we need to find grater min so it could be\\n                the case that we still can find a value which is smaller than query value but greater than previous min value\\n\\n            so Initially we will send min as Integer MIN and max as Integer MAX. when we reach to the null, \\n            we will check min is still Integer MIN, if yes then we will consider -1, otherwise consider min\\n            same we will check max is still Integer MAX, if yes then we will consider -1, otherwise consider max\\n\\n\\n            Now query.length == n, and lest say total nodes in BST is m, so in average case time complexity will be \\n            O(n * log m), but in worst case it can go to O(n * m) when the BST will be skewed. searching will be m from log m.\\n\\n            so if we want to make sure that every time we need to log m, then we can create a sorted array from the BST\\n            and then we can do binary search on it. in that way it will be always log m. but space complexity will be O(m) for the array\\n            Now it is BST, we know that if we do inorder traversal we will get elements in sorted (ASC). for inorder traversal if we consider\\n            Recursion stack space then average case it will be log m, but in worst case it will be m\\n\\n            Time complexity: O(m + n * log m)\\n            Space complexity: O(m)\\n\\n    */\\n\\n\\n\\n\\n    /** \\n        Time complexity: O(m + n * log m)\\n        Space complexity: O(m)\\n    */\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        List<Integer> inorder = new ArrayList<>();\\n        inorderTraversal(root, inorder);\\n\\n        for(Integer q : queries) {\\n\\n            result.add(binarySearch(inorder, q));\\n\\n            /*\\n            List<Integer> minMax = new ArrayList<>(2);\\n            minMax.add(minLargestValue(root, q, Integer.MIN_VALUE));\\n            minMax.add(maxSmallestValue(root, q, Integer.MAX_VALUE));\\n            result.add(minMax);\\n            */\\n\\n            // result.add(minAndMaxValue(root, q, Integer.MIN_VALUE, Integer.MAX_VALUE));\\n        }\\n\\n        return result;\\n    }\\n\\n    /** \\n        Time complexity: O(log m)\\n        Space complexity: O(1)\\n    */\\n    private List<Integer> binarySearch(List<Integer> inorder, int val) {\\n        int low = 0;\\n        int high = inorder.size() - 1;\\n\\n        List<Integer> minMax = new ArrayList<>(2);\\n        minMax.add(-1);\\n        minMax.add(-1);\\n\\n        while(low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if(inorder.get(mid) == val) {\\n                minMax.set(0, val);\\n                minMax.set(1, val);\\n                break;\\n            }\\n\\n            else if(inorder.get(mid) > val) {\\n                high = mid - 1;\\n                minMax.set(1, inorder.get(mid));\\n            }\\n\\n            else {\\n                low = mid + 1;\\n                minMax.set(0, inorder.get(mid));\\n            }\\n        }\\n\\n        return minMax;\\n    }\\n\\n\\n    /** \\n        Time complexity: O(log m) in average case, O(m) in worst case\\n        Space complexity: O(log m) in average case, O(m) in worst case\\n    */\\n    private void inorderTraversal(TreeNode root, List<Integer> inorder) {\\n        if(root == null) return;\\n        inorderTraversal(root.left, inorder);\\n        inorder.add(root.val);\\n        inorderTraversal(root.right, inorder);\\n    }\\n\\n\\n\\n\\n    /** \\n        find the maximum smallest value and minimum largest value in one pass\\n        Time complexity: O(log m) in average case, O(m) in worst case\\n        Space complexity: O(log m) in average case, O(m) in worst case\\n    */\\n    private List<Integer> minAndMaxValue(TreeNode root, int num, int min, int max) {\\n        if(root == null) {\\n            List<Integer> minMax = new ArrayList<>(2);\\n            minMax.add(min == Integer.MIN_VALUE ? -1 : min);\\n            minMax.add(max == Integer.MAX_VALUE ? -1 : max);\\n\\n            return minMax;\\n        }\\n\\n        if(root.val == num) {\\n            List<Integer> minMax = new ArrayList<>(2);\\n            minMax.add(num);\\n            minMax.add(num);\\n\\n            return minMax;\\n        }\\n\\n        else if(root.val > num) {\\n            return minAndMaxValue(root.left, num, min, Math.min(root.val, max));\\n        }\\n\\n        else {\\n            return minAndMaxValue(root.right, num, Math.max(root.val, min), max);\\n        }\\n    }\\n\\n\\n\\n    /** \\n        find the minimum largest value\\n        Time complexity: O(log m) in average case, O(m) in worst case\\n        Space complexity: O(log m) in average case, O(m) in worst case\\n    */\\n    private int minLargestValue(TreeNode root, int num, int min) {\\n        if(root == null) {\\n            return min == Integer.MIN_VALUE ? -1 : min;\\n        }\\n\\n        if(root.val == num) return num;\\n\\n        else if(root.val > num) {\\n            return minLargestValue(root.left, num, min);\\n        }\\n\\n        else {\\n            return minLargestValue(root.right, num, Math.max(root.val, min));\\n        }\\n    }\\n\\n\\n    /** \\n        find the maximum smallest value\\n        Time complexity: O(log m) in average case, O(m) in worst case\\n        Space complexity: O(log m) in average case, O(m) in worst case\\n    */\\n    private int maxSmallestValue(TreeNode root, int num, int max) {\\n        if(root == null) {\\n            return max == Integer.MAX_VALUE ? -1 : max;   \\n        }\\n\\n        if(root.val == num) return num;\\n\\n        else if(root.val > num) {\\n            return maxSmallestValue(root.left, num, Math.min(root.val, max));\\n        }\\n\\n        else {\\n            return maxSmallestValue(root.right, num, max);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    /** \\n        This problem has been asked in below companies:\\n        Google\\n    */\\n\\n    /** \\n        The idea is for each query value, search in the Tree.\\n        Search:\\n            for min, we need to find max value less than or equal the query value\\n            for max, we need to find min value greater than or equal the query value\\n\\n            1. first we check the node val is equl to the query value, if yes we can just simply return the val\\n            2. if node value is greater than the query value, then we can say we have find the max value till now, \\n                so we dont need to go to right of the node, but we need to go to left, \\n                becuase we need to find smallest max so it could be the case that we still can find a value \\n                which is greater than query value but smaller than previous max value\\n\\n            3. if the node value is smaller than query value then we have find the min value till now.\\n                so we dont need to go to left, we can go to right because we need to find grater min so it could be\\n                the case that we still can find a value which is smaller than query value but greater than previous min value\\n\\n            so Initially we will send min as Integer MIN and max as Integer MAX. when we reach to the null, \\n            we will check min is still Integer MIN, if yes then we will consider -1, otherwise consider min\\n            same we will check max is still Integer MAX, if yes then we will consider -1, otherwise consider max\\n\\n\\n            Now query.length == n, and lest say total nodes in BST is m, so in average case time complexity will be \\n            O(n * log m), but in worst case it can go to O(n * m) when the BST will be skewed. searching will be m from log m.\\n\\n            so if we want to make sure that every time we need to log m, then we can create a sorted array from the BST\\n            and then we can do binary search on it. in that way it will be always log m. but space complexity will be O(m) for the array\\n            Now it is BST, we know that if we do inorder traversal we will get elements in sorted (ASC). for inorder traversal if we consider\\n            Recursion stack space then average case it will be log m, but in worst case it will be m\\n\\n            Time complexity: O(m + n * log m)\\n            Space complexity: O(m)\\n\\n    */\\n\\n\\n\\n\\n    /** \\n        Time complexity: O(m + n * log m)\\n        Space complexity: O(m)\\n    */\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        List<Integer> inorder = new ArrayList<>();\\n        inorderTraversal(root, inorder);\\n\\n        for(Integer q : queries) {\\n\\n            result.add(binarySearch(inorder, q));\\n\\n            /*\\n            List<Integer> minMax = new ArrayList<>(2);\\n            minMax.add(minLargestValue(root, q, Integer.MIN_VALUE));\\n            minMax.add(maxSmallestValue(root, q, Integer.MAX_VALUE));\\n            result.add(minMax);\\n            */\\n\\n            // result.add(minAndMaxValue(root, q, Integer.MIN_VALUE, Integer.MAX_VALUE));\\n        }\\n\\n        return result;\\n    }\\n\\n    /** \\n        Time complexity: O(log m)\\n        Space complexity: O(1)\\n    */\\n    private List<Integer> binarySearch(List<Integer> inorder, int val) {\\n        int low = 0;\\n        int high = inorder.size() - 1;\\n\\n        List<Integer> minMax = new ArrayList<>(2);\\n        minMax.add(-1);\\n        minMax.add(-1);\\n\\n        while(low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if(inorder.get(mid) == val) {\\n                minMax.set(0, val);\\n                minMax.set(1, val);\\n                break;\\n            }\\n\\n            else if(inorder.get(mid) > val) {\\n                high = mid - 1;\\n                minMax.set(1, inorder.get(mid));\\n            }\\n\\n            else {\\n                low = mid + 1;\\n                minMax.set(0, inorder.get(mid));\\n            }\\n        }\\n\\n        return minMax;\\n    }\\n\\n\\n    /** \\n        Time complexity: O(log m) in average case, O(m) in worst case\\n        Space complexity: O(log m) in average case, O(m) in worst case\\n    */\\n    private void inorderTraversal(TreeNode root, List<Integer> inorder) {\\n        if(root == null) return;\\n        inorderTraversal(root.left, inorder);\\n        inorder.add(root.val);\\n        inorderTraversal(root.right, inorder);\\n    }\\n\\n\\n\\n\\n    /** \\n        find the maximum smallest value and minimum largest value in one pass\\n        Time complexity: O(log m) in average case, O(m) in worst case\\n        Space complexity: O(log m) in average case, O(m) in worst case\\n    */\\n    private List<Integer> minAndMaxValue(TreeNode root, int num, int min, int max) {\\n        if(root == null) {\\n            List<Integer> minMax = new ArrayList<>(2);\\n            minMax.add(min == Integer.MIN_VALUE ? -1 : min);\\n            minMax.add(max == Integer.MAX_VALUE ? -1 : max);\\n\\n            return minMax;\\n        }\\n\\n        if(root.val == num) {\\n            List<Integer> minMax = new ArrayList<>(2);\\n            minMax.add(num);\\n            minMax.add(num);\\n\\n            return minMax;\\n        }\\n\\n        else if(root.val > num) {\\n            return minAndMaxValue(root.left, num, min, Math.min(root.val, max));\\n        }\\n\\n        else {\\n            return minAndMaxValue(root.right, num, Math.max(root.val, min), max);\\n        }\\n    }\\n\\n\\n\\n    /** \\n        find the minimum largest value\\n        Time complexity: O(log m) in average case, O(m) in worst case\\n        Space complexity: O(log m) in average case, O(m) in worst case\\n    */\\n    private int minLargestValue(TreeNode root, int num, int min) {\\n        if(root == null) {\\n            return min == Integer.MIN_VALUE ? -1 : min;\\n        }\\n\\n        if(root.val == num) return num;\\n\\n        else if(root.val > num) {\\n            return minLargestValue(root.left, num, min);\\n        }\\n\\n        else {\\n            return minLargestValue(root.right, num, Math.max(root.val, min));\\n        }\\n    }\\n\\n\\n    /** \\n        find the maximum smallest value\\n        Time complexity: O(log m) in average case, O(m) in worst case\\n        Space complexity: O(log m) in average case, O(m) in worst case\\n    */\\n    private int maxSmallestValue(TreeNode root, int num, int max) {\\n        if(root == null) {\\n            return max == Integer.MAX_VALUE ? -1 : max;   \\n        }\\n\\n        if(root.val == num) return num;\\n\\n        else if(root.val > num) {\\n            return maxSmallestValue(root.left, num, Math.min(root.val, max));\\n        }\\n\\n        else {\\n            return maxSmallestValue(root.right, num, max);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019687,
                "title": "javascript-inorder-traversal-binary-search",
                "content": "# Approach\\n- Inorder terversal to form numbers array in non-decreasing order\\n- Binary search lower bound\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n- Space complexity: $$O(n)$$\\n# Code\\n```\\nvar closestNodes = function(root, queries) {\\n    const numbers = [];\\n\\n    (function dfs (node) {\\n        node && (dfs(node.left), numbers.push(node.val), dfs(node.right))\\n    })(root)\\n\\n    const binarySearch = (target) => {\\n        let l = -1, r = numbers.length - 1;\\n        while (l < r) {\\n            const mid = (l + r + 1) >> 1;\\n            numbers[mid] <= target ? l = mid : r = mid - 1;\\n        }\\n        return l;\\n    };\\n\\n    return queries.map((query) => {\\n        const minIndex = binarySearch(query);\\n        const minNumber = numbers[minIndex] ?? -1;\\n        const maxNumber = numbers[minIndex] == query ? query : (numbers[minIndex + 1] ?? -1);\\n        return [minNumber, maxNumber];\\n    })\\n};\\n```\\n**TLE when binary tree is skewed**\\n- Worst case time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n)$$\\n```\\nvar closestNodes = function(root, queries) {\\n    const findMin = (node, query, min) => {\\n        if (!node) return min;\\n        return node.val == query \\n            ? query \\n            : node.val > query \\n            ? findMin(node.left, query, min)\\n            : findMin(node.right, query, node.val);\\n    };\\n\\n    const findMax = (node, query, max) => {\\n        if (!node) return max;\\n        return node.val == query \\n            ? query\\n            : node.val > query\\n            ? findMax(node.left, query, node.val)\\n            : findMax(node.right, query, max);\\n    };\\n\\n    return queries.map((query) => [findMin(root, query, -1), findMax(root, query, -1)])\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Depth-First Search"
                ],
                "code": "```\\nvar closestNodes = function(root, queries) {\\n    const numbers = [];\\n\\n    (function dfs (node) {\\n        node && (dfs(node.left), numbers.push(node.val), dfs(node.right))\\n    })(root)\\n\\n    const binarySearch = (target) => {\\n        let l = -1, r = numbers.length - 1;\\n        while (l < r) {\\n            const mid = (l + r + 1) >> 1;\\n            numbers[mid] <= target ? l = mid : r = mid - 1;\\n        }\\n        return l;\\n    };\\n\\n    return queries.map((query) => {\\n        const minIndex = binarySearch(query);\\n        const minNumber = numbers[minIndex] ?? -1;\\n        const maxNumber = numbers[minIndex] == query ? query : (numbers[minIndex + 1] ?? -1);\\n        return [minNumber, maxNumber];\\n    })\\n};\\n```\n```\\nvar closestNodes = function(root, queries) {\\n    const findMin = (node, query, min) => {\\n        if (!node) return min;\\n        return node.val == query \\n            ? query \\n            : node.val > query \\n            ? findMin(node.left, query, min)\\n            : findMin(node.right, query, node.val);\\n    };\\n\\n    const findMax = (node, query, max) => {\\n        if (!node) return max;\\n        return node.val == query \\n            ? query\\n            : node.val > query\\n            ? findMax(node.left, query, node.val)\\n            : findMax(node.right, query, max);\\n    };\\n\\n    return queries.map((query) => [findMin(root, query, -1), findMax(root, query, -1)])\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2984137,
                "title": "c-simple-solution-using-lower-bound-inorder-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst find the inorder traversal and then use the lower_bound() to find the min and max of the queries. \\n- If the lower_bound() is equal to query[i], then set max and min to query[i].\\n- If the lower_bound is pointing to first element,\\n    - set the min_l as -1.\\n    - set the max_l as lower_bound value.\\n- Otherwise\\n    - set the min_l as previous value of lower_bound.\\n    - If the lower_bound is pointing to end(), set the max_l as -1. Otherwise set it to the lower_bound().\\n\\n# Complexity\\n- Time complexity:\\nO(n + mlog(n)), where n is the number of nodes and m is the no of queries.\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int> &vec) {\\n        if (!root) return;\\n        inorder(root->left, vec);\\n        vec.push_back(root->val);\\n        inorder(root->right, vec);\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int> vec;\\n        inorder(root,vec);\\n        vector<vector<int>> ans;\\n        int min_l, max_l;\\n        for(int i=0;i<queries.size();i++){\\n            auto it = lower_bound(vec.begin(), vec.end(), queries[i]);\\n            if (it != vec.end() && *it == queries[i]) {\\n                min_l = *it;\\n                max_l = *it;\\n            }\\n            else {\\n                if (it == vec.begin()) {\\n                    min_l = -1;\\n                    max_l = *it;\\n                }\\n                else {\\n                    min_l = *(it-1);\\n                    max_l = (it == vec.end()) ? -1: *it;\\n                }\\n            }\\n            ans.push_back({min_l,max_l});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int> &vec) {\\n        if (!root) return;\\n        inorder(root->left, vec);\\n        vec.push_back(root->val);\\n        inorder(root->right, vec);\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int> vec;\\n        inorder(root,vec);\\n        vector<vector<int>> ans;\\n        int min_l, max_l;\\n        for(int i=0;i<queries.size();i++){\\n            auto it = lower_bound(vec.begin(), vec.end(), queries[i]);\\n            if (it != vec.end() && *it == queries[i]) {\\n                min_l = *it;\\n                max_l = *it;\\n            }\\n            else {\\n                if (it == vec.begin()) {\\n                    min_l = -1;\\n                    max_l = *it;\\n                }\\n                else {\\n                    min_l = *(it-1);\\n                    max_l = (it == vec.end()) ? -1: *it;\\n                }\\n            }\\n            ans.push_back({min_l,max_l});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974229,
                "title": "python-easy-to-read-and-understand-bst",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorder(self, node):\\n        if not node:\\n            return []\\n        return self.inorder(node.left) + [node.val] + self.inorder(node.right)\\n    \\n    def reach(self, node, prev, target, path):\\n        if not node:\\n            if path == \\'l\\':\\n                self.res.append([self.d[prev.val][0], prev.val])\\n            elif path == \\'r\\':\\n                self.res.append([prev.val, self.d[prev.val][1]])\\n            return\\n        if target < node.val:\\n            self.reach(node.left, node, target, \\'l\\')\\n        else:\\n            self.reach(node.right, node, target, \\'r\\')\\n    \\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        nums = self.inorder(root)\\n        n = len(nums)\\n        self.d = collections.defaultdict(list)\\n        for i, num in enumerate(nums):\\n            if i == 0:\\n                self.d[num].append(-1)\\n                self.d[num].append(nums[i+1])\\n            elif i == n-1:\\n                self.d[num].append(nums[i-1])\\n                self.d[num].append(-1)\\n            else:\\n                self.d[num].append(nums[i-1])\\n                self.d[num].append(nums[i+1])\\n        #print(d.items())\\n        \\n        self.res = []\\n        for q in queries:\\n            if q in self.d:\\n                self.res.append([q, q])\\n            else:\\n                self.reach(root, None, q, \\'\\')\\n        \\n        return self.res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorder(self, node):\\n        if not node:\\n            return []\\n        return self.inorder(node.left) + [node.val] + self.inorder(node.right)\\n    \\n    def reach(self, node, prev, target, path):\\n        if not node:\\n            if path == \\'l\\':\\n                self.res.append([self.d[prev.val][0], prev.val])\\n            elif path == \\'r\\':\\n                self.res.append([prev.val, self.d[prev.val][1]])\\n            return\\n        if target < node.val:\\n            self.reach(node.left, node, target, \\'l\\')\\n        else:\\n            self.reach(node.right, node, target, \\'r\\')\\n    \\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        nums = self.inorder(root)\\n        n = len(nums)\\n        self.d = collections.defaultdict(list)\\n        for i, num in enumerate(nums):\\n            if i == 0:\\n                self.d[num].append(-1)\\n                self.d[num].append(nums[i+1])\\n            elif i == n-1:\\n                self.d[num].append(nums[i-1])\\n                self.d[num].append(-1)\\n            else:\\n                self.d[num].append(nums[i-1])\\n                self.d[num].append(nums[i+1])\\n        #print(d.items())\\n        \\n        self.res = []\\n        for q in queries:\\n            if q in self.d:\\n                self.res.append([q, q])\\n            else:\\n                self.reach(root, None, q, \\'\\')\\n        \\n        return self.res",
                "codeTag": "Java"
            },
            {
                "id": 2944967,
                "title": "c-simple-and-easy-o-n-log-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N Log(N) )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>v;\\n    void inorder(TreeNode* root){\\n        if(root==NULL) return;\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    int bs_min(int a){\\n        int start=0, end=v.size()-1;\\n        int ans=-1;\\n        while(start<=end){\\n            int mid=start + (end-start)/2;\\n            if(v[mid]<=a){\\n                ans=v[mid];\\n                start=mid+1;\\n            }\\n            else if(v[mid]> a){\\n                end=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int bs_max(int a){\\n        int start=0, end=v.size()-1;\\n        int ans=-1;\\n        while(start<=end){\\n            int mid=start + (end-start)/2;\\n            if(v[mid]>=a){\\n                ans=v[mid];\\n                end=mid-1;\\n            }\\n            else if(v[mid]< a){\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        inorder(root);   //O(N)\\n        vector<vector<int>>ans;\\n        for(auto &i: queries){  //O(n(log(n))\\n            int min=-1,max=-1;\\n            min=bs_min(i);\\n            max=bs_max(i);\\n            vector<int>temp;\\n            temp.push_back(min);\\n            temp.push_back(max);\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>v;\\n    void inorder(TreeNode* root){\\n        if(root==NULL) return;\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    int bs_min(int a){\\n        int start=0, end=v.size()-1;\\n        int ans=-1;\\n        while(start<=end){\\n            int mid=start + (end-start)/2;\\n            if(v[mid]<=a){\\n                ans=v[mid];\\n                start=mid+1;\\n            }\\n            else if(v[mid]> a){\\n                end=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int bs_max(int a){\\n        int start=0, end=v.size()-1;\\n        int ans=-1;\\n        while(start<=end){\\n            int mid=start + (end-start)/2;\\n            if(v[mid]>=a){\\n                ans=v[mid];\\n                end=mid-1;\\n            }\\n            else if(v[mid]< a){\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        inorder(root);   //O(N)\\n        vector<vector<int>>ans;\\n        for(auto &i: queries){  //O(n(log(n))\\n            int min=-1,max=-1;\\n            min=bs_min(i);\\n            max=bs_max(i);\\n            vector<int>temp;\\n            temp.push_back(min);\\n            temp.push_back(max);\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943109,
                "title": "solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDo the inorder traversal of binary search tree to create an array of node values sorted in ascending order. Now simply apply the binary search over the array for each query where ( if value is found , it will be in \\'m\\') otherwise ( \\'e\\' part contains the largest number smaller than query and \\'b\\' part contains the smallest number larger than query). \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWrite function for inorder traversal. Now iterate the queries array and apply binary search over each query to find the answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) + O(n*log(n)) = O(n*log(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void inorder(TreeNode*root,vector<int>&v)\\n    {\\n        if(root==NULL)\\n            return;\\n        inorder(root->left,v);\\n        v.push_back(root->val);\\n        inorder(root->right,v);\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<vector<int>>ans;\\n        vector<int>v;\\n        inorder(root,v);\\n        int b,e,m;\\n        for(auto it:queries)\\n        {\\n            b=0;\\n            e=v.size()-1;\\n            while(b<=e)\\n            {\\n                m=(b+e)/2;\\n                if(v[m]==it)\\n                    break;\\n                if(v[m]>it)\\n                    e=m-1;\\n                else\\n                    b=m+1;\\n            }\\n            if(v[m]==it) \\n            {\\n                ans.push_back({it,it});\\n            }\\n            else\\n            {\\n                ans.push_back({(e>=0 && e<v.size())?v[e]:-1,(b>=0 && b<v.size())?v[b]:-1});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void inorder(TreeNode*root,vector<int>&v)\\n    {\\n        if(root==NULL)\\n            return;\\n        inorder(root->left,v);\\n        v.push_back(root->val);\\n        inorder(root->right,v);\\n    }\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<vector<int>>ans;\\n        vector<int>v;\\n        inorder(root,v);\\n        int b,e,m;\\n        for(auto it:queries)\\n        {\\n            b=0;\\n            e=v.size()-1;\\n            while(b<=e)\\n            {\\n                m=(b+e)/2;\\n                if(v[m]==it)\\n                    break;\\n                if(v[m]>it)\\n                    e=m-1;\\n                else\\n                    b=m+1;\\n            }\\n            if(v[m]==it) \\n            {\\n                ans.push_back({it,it});\\n            }\\n            else\\n            {\\n                ans.push_back({(e>=0 && e<v.size())?v[e]:-1,(b>=0 && b<v.size())?v[b]:-1});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2935083,
                "title": "treeset-and-inorder",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) for inorder\\nO(NlogN) for treeset retrieval\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    TreeSet<Integer> ts = new TreeSet<>();\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        \\n        dfs(root);\\n        List<List<Integer>> resp = new ArrayList<>();\\n        for(int i : queries) {\\n            List<Integer> temp = new ArrayList<>();\\n            Integer c = ts.ceiling(i);\\n            Integer f = ts.floor(i);\\n            temp.add(f==null ? -1 : f);\\n            temp.add(c==null ? -1 : c);\\n            resp.add(temp);\\n        }\\n        return resp;\\n    }\\n\\n    private void dfs(TreeNode root) {\\n        if(null==root) {\\n            return;\\n        }\\n\\n        ts.add(root.val);\\n        dfs(root.left);\\n        dfs(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    TreeSet<Integer> ts = new TreeSet<>();\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        \\n        dfs(root);\\n        List<List<Integer>> resp = new ArrayList<>();\\n        for(int i : queries) {\\n            List<Integer> temp = new ArrayList<>();\\n            Integer c = ts.ceiling(i);\\n            Integer f = ts.floor(i);\\n            temp.add(f==null ? -1 : f);\\n            temp.add(c==null ? -1 : c);\\n            resp.add(temp);\\n        }\\n        return resp;\\n    }\\n\\n    private void dfs(TreeNode root) {\\n        if(null==root) {\\n            return;\\n        }\\n\\n        ts.add(root.val);\\n        dfs(root.left);\\n        dfs(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2934094,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn closest_nodes(root: Option<Rc<RefCell<TreeNode>>>, queries: Vec<i32>) -> Vec<Vec<i32>> {\\n        fn helper(node: Option<&Rc<RefCell<TreeNode>>>, res: &mut Vec<i32>) {\\n            if let Some(n) = node {\\n                let node = n.borrow();\\n                helper(node.left.as_ref(), res);\\n                res.push(node.val);\\n                helper(node.right.as_ref(), res);\\n            }\\n        }\\n\\n        let mut sorted = vec![];\\n        helper(root.as_ref(), &mut sorted);\\n        let mut res = vec![];\\n        for query in queries {\\n            let r = sorted.binary_search(&query);\\n            match r {\\n                Ok(i) => {\\n                    res.push(vec![sorted[i], sorted[i]]);\\n                }\\n                Err(i) => {\\n                    if i == 0 {\\n                        res.push(vec![-1, sorted[i]]);\\n                    } else if i == sorted.len() {\\n                        res.push(vec![sorted[i - 1], -1]);\\n                    } else {\\n                        res.push(vec![sorted[i - 1], sorted[i]]);\\n                    }\\n                }\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn closest_nodes(root: Option<Rc<RefCell<TreeNode>>>, queries: Vec<i32>) -> Vec<Vec<i32>> {\\n        fn helper(node: Option<&Rc<RefCell<TreeNode>>>, res: &mut Vec<i32>) {\\n            if let Some(n) = node {\\n                let node = n.borrow();\\n                helper(node.left.as_ref(), res);\\n                res.push(node.val);\\n                helper(node.right.as_ref(), res);\\n            }\\n        }\\n\\n        let mut sorted = vec![];\\n        helper(root.as_ref(), &mut sorted);\\n        let mut res = vec![];\\n        for query in queries {\\n            let r = sorted.binary_search(&query);\\n            match r {\\n                Ok(i) => {\\n                    res.push(vec![sorted[i], sorted[i]]);\\n                }\\n                Err(i) => {\\n                    if i == 0 {\\n                        res.push(vec![-1, sorted[i]]);\\n                    } else if i == sorted.len() {\\n                        res.push(vec![sorted[i - 1], -1]);\\n                    } else {\\n                        res.push(vec![sorted[i - 1], sorted[i]]);\\n                    }\\n                }\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1690156,
                "content": [
                    {
                        "username": "dudulichen11",
                        "content": "can anyone help me understand why this preprocessing step results in TLE. This is pretty similar to other accepted answers. Don't really understand since in any case this is O(N) step, which is less compared to the total TC: O(NlogN)...\n``\ndef tree_to_list(root):\n\n            if not root:\n\n                return []\n\n            return tree_to_list(root.left) + [root.val] + tree_to_list(root.right)\narr = tree_to_list(root)\n\n\n``\n"
                    },
                    {
                        "username": "dudulichen11",
                        "content": "[@miraj2399](/miraj2399) Oh, yes. That totally makes sense now. I spent 40 mins on this issue during the contest. Really appreciate your explanation!"
                    },
                    {
                        "username": "yzhao156",
                        "content": "```\nlst = []\ndef dfs(root):\n            if not root:\n                return \n            dfs(root.left)\n            lst.append(root.val)\n            dfs(root.right)\ndfs(root)\nprint(root)\n\n```"
                    },
                    {
                        "username": "miraj2399",
                        "content": "I had the same issue. My code was even shorter(Pythonic) lol!\n```\ndef dfs(root):\n     return dfs(root.left)+[root.val]+dfs(root.right) if root!=None else []\n\n```\nBut from a quick google search, it is apparent that, append function take amortized O(1) time where adding two list with size m and n takes O(m+n) time.\nSo, for this problem appending would make the complexity O(N) where adding list will make it O(N**2)"
                    },
                    {
                        "username": "david6p2",
                        "content": "really silly that you have to balance the tree for this to work"
                    },
                    {
                        "username": "okwxmsz",
                        "content": "Tip: BST could be not balanced"
                    },
                    {
                        "username": "Mirror0227",
                        "content": "Thought for TLE: the input binary tree is not balanced. In some extremely unbalanced case it will become O(n) search (n: total node in the tree).\\n2 way to aviod TLE:\\n- balance it\\n- convert it to array and use binary search on array."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Again,I got accepted with relatively fine runtime in C++ but TLE in Python3.OJ should be consistent between languages.Please fix it"
                    },
                    {
                        "username": "m1nsk",
                        "content": "Correct me if im wrong, but i think that i found O(N) solution in worst case for unbalanced tree.\n\nNo need to traverse the tree and put values to array to do a binary search, no need for TreeSet structure.\n\nhttps://leetcode.com/problems/closest-nodes-queries-in-a-binary-search-tree/solutions/3042770/onlog-k-time-ok-constant-space-no-need-for-additional-n-size-array-and-full-tree-traversal/"
                    },
                    {
                        "username": "harshit_bangar",
                        "content": "My solution is timing out - I am converting it into a sorted array through ignorer traversal  and then finding the value smaller, and larger.\\n ```/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<Integer> inorder = inorder(root);\\n        List<List<Integer>> result = new ArrayList<>(queries.size());\\n        for(int query: queries) {\\n            result.add(findSmallestOrLargest(inorder, query));\\n        }\\n        return result;\\n    }\\n\\n    private List<Integer> findSmallestOrLargest(List<Integer> inorder, int query) {\\n        int start = 0, end = inorder.size()-1;\\n        int smallest = -1, largest = -1;\\n        while(start<=end) {\\n            int mid = (start+end)/2;\\n            if(inorder.get(mid)<query) {\\n                smallest = inorder.get(mid);\\n                start = mid+1;\\n            } else if(inorder.get(mid)>query) {\\n                end = mid-1;\\n                largest = inorder.get(mid);\\n            } else {\\n                return Arrays.asList(query, query);\\n            }\\n        }\\n        return Arrays.asList(smallest, largest);\\n    }\\n\\n    private List<Integer> inorder(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        if(root.left != null) {\\n            result.addAll(inorder(root.left));\\n        }\\n        result.add(root.val);\\n        if(root.right != null) {\\n            result.addAll(inorder(root.right));\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "alpha211",
                        "content": "Can I traverse the tree and put node value into a list and then run binary search?"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "DEFINITELY"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "If you are wondering why the search on Tree directly with recursive DFS is giving you TLE , it is because testcases have the worst case which go to the depth of like 10^5 so that would make 10^5 call stack too."
                    },
                    {
                        "username": "skyhuangxy",
                        "content": "My dfs Solution for this problem. The Time Complexity should be O(k*logn), but it gives TLE\\n\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> res; = new ArrayList<>();\\n        for (int target : queries) { \\n            List<Integer> path = new ArrayList<>();\\n            int smallOrequal = dfssmall(root, target);\\n            int largeOrequal = dfslarge(root, target);\\n            path.add(smallOrequal);\\n            path.add(largeOrequal);\\n            res.add(path);\\n        }\\n        return res;\\n    }\\n    private int dfssmall(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val > target) {\\n            return dfssmall(node.left, target);\\n        }\\n        int next = dfssmall(node.right, target);\\n        return next == -1 ? node.val : next;\\n    }\\n    private int dfslarge(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val < target) {\\n            return dfslarge(node.right, target);\\n        }\\n\\n        int next = dfslarge(node.left, target);\\n        return next == -1 ? node.val : next;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1690137,
                "content": [
                    {
                        "username": "dudulichen11",
                        "content": "can anyone help me understand why this preprocessing step results in TLE. This is pretty similar to other accepted answers. Don't really understand since in any case this is O(N) step, which is less compared to the total TC: O(NlogN)...\n``\ndef tree_to_list(root):\n\n            if not root:\n\n                return []\n\n            return tree_to_list(root.left) + [root.val] + tree_to_list(root.right)\narr = tree_to_list(root)\n\n\n``\n"
                    },
                    {
                        "username": "dudulichen11",
                        "content": "[@miraj2399](/miraj2399) Oh, yes. That totally makes sense now. I spent 40 mins on this issue during the contest. Really appreciate your explanation!"
                    },
                    {
                        "username": "yzhao156",
                        "content": "```\nlst = []\ndef dfs(root):\n            if not root:\n                return \n            dfs(root.left)\n            lst.append(root.val)\n            dfs(root.right)\ndfs(root)\nprint(root)\n\n```"
                    },
                    {
                        "username": "miraj2399",
                        "content": "I had the same issue. My code was even shorter(Pythonic) lol!\n```\ndef dfs(root):\n     return dfs(root.left)+[root.val]+dfs(root.right) if root!=None else []\n\n```\nBut from a quick google search, it is apparent that, append function take amortized O(1) time where adding two list with size m and n takes O(m+n) time.\nSo, for this problem appending would make the complexity O(N) where adding list will make it O(N**2)"
                    },
                    {
                        "username": "david6p2",
                        "content": "really silly that you have to balance the tree for this to work"
                    },
                    {
                        "username": "okwxmsz",
                        "content": "Tip: BST could be not balanced"
                    },
                    {
                        "username": "Mirror0227",
                        "content": "Thought for TLE: the input binary tree is not balanced. In some extremely unbalanced case it will become O(n) search (n: total node in the tree).\\n2 way to aviod TLE:\\n- balance it\\n- convert it to array and use binary search on array."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Again,I got accepted with relatively fine runtime in C++ but TLE in Python3.OJ should be consistent between languages.Please fix it"
                    },
                    {
                        "username": "m1nsk",
                        "content": "Correct me if im wrong, but i think that i found O(N) solution in worst case for unbalanced tree.\n\nNo need to traverse the tree and put values to array to do a binary search, no need for TreeSet structure.\n\nhttps://leetcode.com/problems/closest-nodes-queries-in-a-binary-search-tree/solutions/3042770/onlog-k-time-ok-constant-space-no-need-for-additional-n-size-array-and-full-tree-traversal/"
                    },
                    {
                        "username": "harshit_bangar",
                        "content": "My solution is timing out - I am converting it into a sorted array through ignorer traversal  and then finding the value smaller, and larger.\\n ```/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<Integer> inorder = inorder(root);\\n        List<List<Integer>> result = new ArrayList<>(queries.size());\\n        for(int query: queries) {\\n            result.add(findSmallestOrLargest(inorder, query));\\n        }\\n        return result;\\n    }\\n\\n    private List<Integer> findSmallestOrLargest(List<Integer> inorder, int query) {\\n        int start = 0, end = inorder.size()-1;\\n        int smallest = -1, largest = -1;\\n        while(start<=end) {\\n            int mid = (start+end)/2;\\n            if(inorder.get(mid)<query) {\\n                smallest = inorder.get(mid);\\n                start = mid+1;\\n            } else if(inorder.get(mid)>query) {\\n                end = mid-1;\\n                largest = inorder.get(mid);\\n            } else {\\n                return Arrays.asList(query, query);\\n            }\\n        }\\n        return Arrays.asList(smallest, largest);\\n    }\\n\\n    private List<Integer> inorder(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        if(root.left != null) {\\n            result.addAll(inorder(root.left));\\n        }\\n        result.add(root.val);\\n        if(root.right != null) {\\n            result.addAll(inorder(root.right));\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "alpha211",
                        "content": "Can I traverse the tree and put node value into a list and then run binary search?"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "DEFINITELY"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "If you are wondering why the search on Tree directly with recursive DFS is giving you TLE , it is because testcases have the worst case which go to the depth of like 10^5 so that would make 10^5 call stack too."
                    },
                    {
                        "username": "skyhuangxy",
                        "content": "My dfs Solution for this problem. The Time Complexity should be O(k*logn), but it gives TLE\\n\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> res; = new ArrayList<>();\\n        for (int target : queries) { \\n            List<Integer> path = new ArrayList<>();\\n            int smallOrequal = dfssmall(root, target);\\n            int largeOrequal = dfslarge(root, target);\\n            path.add(smallOrequal);\\n            path.add(largeOrequal);\\n            res.add(path);\\n        }\\n        return res;\\n    }\\n    private int dfssmall(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val > target) {\\n            return dfssmall(node.left, target);\\n        }\\n        int next = dfssmall(node.right, target);\\n        return next == -1 ? node.val : next;\\n    }\\n    private int dfslarge(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val < target) {\\n            return dfslarge(node.right, target);\\n        }\\n\\n        int next = dfslarge(node.left, target);\\n        return next == -1 ? node.val : next;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1690181,
                "content": [
                    {
                        "username": "dudulichen11",
                        "content": "can anyone help me understand why this preprocessing step results in TLE. This is pretty similar to other accepted answers. Don't really understand since in any case this is O(N) step, which is less compared to the total TC: O(NlogN)...\n``\ndef tree_to_list(root):\n\n            if not root:\n\n                return []\n\n            return tree_to_list(root.left) + [root.val] + tree_to_list(root.right)\narr = tree_to_list(root)\n\n\n``\n"
                    },
                    {
                        "username": "dudulichen11",
                        "content": "[@miraj2399](/miraj2399) Oh, yes. That totally makes sense now. I spent 40 mins on this issue during the contest. Really appreciate your explanation!"
                    },
                    {
                        "username": "yzhao156",
                        "content": "```\nlst = []\ndef dfs(root):\n            if not root:\n                return \n            dfs(root.left)\n            lst.append(root.val)\n            dfs(root.right)\ndfs(root)\nprint(root)\n\n```"
                    },
                    {
                        "username": "miraj2399",
                        "content": "I had the same issue. My code was even shorter(Pythonic) lol!\n```\ndef dfs(root):\n     return dfs(root.left)+[root.val]+dfs(root.right) if root!=None else []\n\n```\nBut from a quick google search, it is apparent that, append function take amortized O(1) time where adding two list with size m and n takes O(m+n) time.\nSo, for this problem appending would make the complexity O(N) where adding list will make it O(N**2)"
                    },
                    {
                        "username": "david6p2",
                        "content": "really silly that you have to balance the tree for this to work"
                    },
                    {
                        "username": "okwxmsz",
                        "content": "Tip: BST could be not balanced"
                    },
                    {
                        "username": "Mirror0227",
                        "content": "Thought for TLE: the input binary tree is not balanced. In some extremely unbalanced case it will become O(n) search (n: total node in the tree).\\n2 way to aviod TLE:\\n- balance it\\n- convert it to array and use binary search on array."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Again,I got accepted with relatively fine runtime in C++ but TLE in Python3.OJ should be consistent between languages.Please fix it"
                    },
                    {
                        "username": "m1nsk",
                        "content": "Correct me if im wrong, but i think that i found O(N) solution in worst case for unbalanced tree.\n\nNo need to traverse the tree and put values to array to do a binary search, no need for TreeSet structure.\n\nhttps://leetcode.com/problems/closest-nodes-queries-in-a-binary-search-tree/solutions/3042770/onlog-k-time-ok-constant-space-no-need-for-additional-n-size-array-and-full-tree-traversal/"
                    },
                    {
                        "username": "harshit_bangar",
                        "content": "My solution is timing out - I am converting it into a sorted array through ignorer traversal  and then finding the value smaller, and larger.\\n ```/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<Integer> inorder = inorder(root);\\n        List<List<Integer>> result = new ArrayList<>(queries.size());\\n        for(int query: queries) {\\n            result.add(findSmallestOrLargest(inorder, query));\\n        }\\n        return result;\\n    }\\n\\n    private List<Integer> findSmallestOrLargest(List<Integer> inorder, int query) {\\n        int start = 0, end = inorder.size()-1;\\n        int smallest = -1, largest = -1;\\n        while(start<=end) {\\n            int mid = (start+end)/2;\\n            if(inorder.get(mid)<query) {\\n                smallest = inorder.get(mid);\\n                start = mid+1;\\n            } else if(inorder.get(mid)>query) {\\n                end = mid-1;\\n                largest = inorder.get(mid);\\n            } else {\\n                return Arrays.asList(query, query);\\n            }\\n        }\\n        return Arrays.asList(smallest, largest);\\n    }\\n\\n    private List<Integer> inorder(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        if(root.left != null) {\\n            result.addAll(inorder(root.left));\\n        }\\n        result.add(root.val);\\n        if(root.right != null) {\\n            result.addAll(inorder(root.right));\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "alpha211",
                        "content": "Can I traverse the tree and put node value into a list and then run binary search?"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "DEFINITELY"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "If you are wondering why the search on Tree directly with recursive DFS is giving you TLE , it is because testcases have the worst case which go to the depth of like 10^5 so that would make 10^5 call stack too."
                    },
                    {
                        "username": "skyhuangxy",
                        "content": "My dfs Solution for this problem. The Time Complexity should be O(k*logn), but it gives TLE\\n\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> res; = new ArrayList<>();\\n        for (int target : queries) { \\n            List<Integer> path = new ArrayList<>();\\n            int smallOrequal = dfssmall(root, target);\\n            int largeOrequal = dfslarge(root, target);\\n            path.add(smallOrequal);\\n            path.add(largeOrequal);\\n            res.add(path);\\n        }\\n        return res;\\n    }\\n    private int dfssmall(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val > target) {\\n            return dfssmall(node.left, target);\\n        }\\n        int next = dfssmall(node.right, target);\\n        return next == -1 ? node.val : next;\\n    }\\n    private int dfslarge(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val < target) {\\n            return dfslarge(node.right, target);\\n        }\\n\\n        int next = dfslarge(node.left, target);\\n        return next == -1 ? node.val : next;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1690095,
                "content": [
                    {
                        "username": "dudulichen11",
                        "content": "can anyone help me understand why this preprocessing step results in TLE. This is pretty similar to other accepted answers. Don't really understand since in any case this is O(N) step, which is less compared to the total TC: O(NlogN)...\n``\ndef tree_to_list(root):\n\n            if not root:\n\n                return []\n\n            return tree_to_list(root.left) + [root.val] + tree_to_list(root.right)\narr = tree_to_list(root)\n\n\n``\n"
                    },
                    {
                        "username": "dudulichen11",
                        "content": "[@miraj2399](/miraj2399) Oh, yes. That totally makes sense now. I spent 40 mins on this issue during the contest. Really appreciate your explanation!"
                    },
                    {
                        "username": "yzhao156",
                        "content": "```\nlst = []\ndef dfs(root):\n            if not root:\n                return \n            dfs(root.left)\n            lst.append(root.val)\n            dfs(root.right)\ndfs(root)\nprint(root)\n\n```"
                    },
                    {
                        "username": "miraj2399",
                        "content": "I had the same issue. My code was even shorter(Pythonic) lol!\n```\ndef dfs(root):\n     return dfs(root.left)+[root.val]+dfs(root.right) if root!=None else []\n\n```\nBut from a quick google search, it is apparent that, append function take amortized O(1) time where adding two list with size m and n takes O(m+n) time.\nSo, for this problem appending would make the complexity O(N) where adding list will make it O(N**2)"
                    },
                    {
                        "username": "david6p2",
                        "content": "really silly that you have to balance the tree for this to work"
                    },
                    {
                        "username": "okwxmsz",
                        "content": "Tip: BST could be not balanced"
                    },
                    {
                        "username": "Mirror0227",
                        "content": "Thought for TLE: the input binary tree is not balanced. In some extremely unbalanced case it will become O(n) search (n: total node in the tree).\\n2 way to aviod TLE:\\n- balance it\\n- convert it to array and use binary search on array."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Again,I got accepted with relatively fine runtime in C++ but TLE in Python3.OJ should be consistent between languages.Please fix it"
                    },
                    {
                        "username": "m1nsk",
                        "content": "Correct me if im wrong, but i think that i found O(N) solution in worst case for unbalanced tree.\n\nNo need to traverse the tree and put values to array to do a binary search, no need for TreeSet structure.\n\nhttps://leetcode.com/problems/closest-nodes-queries-in-a-binary-search-tree/solutions/3042770/onlog-k-time-ok-constant-space-no-need-for-additional-n-size-array-and-full-tree-traversal/"
                    },
                    {
                        "username": "harshit_bangar",
                        "content": "My solution is timing out - I am converting it into a sorted array through ignorer traversal  and then finding the value smaller, and larger.\\n ```/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<Integer> inorder = inorder(root);\\n        List<List<Integer>> result = new ArrayList<>(queries.size());\\n        for(int query: queries) {\\n            result.add(findSmallestOrLargest(inorder, query));\\n        }\\n        return result;\\n    }\\n\\n    private List<Integer> findSmallestOrLargest(List<Integer> inorder, int query) {\\n        int start = 0, end = inorder.size()-1;\\n        int smallest = -1, largest = -1;\\n        while(start<=end) {\\n            int mid = (start+end)/2;\\n            if(inorder.get(mid)<query) {\\n                smallest = inorder.get(mid);\\n                start = mid+1;\\n            } else if(inorder.get(mid)>query) {\\n                end = mid-1;\\n                largest = inorder.get(mid);\\n            } else {\\n                return Arrays.asList(query, query);\\n            }\\n        }\\n        return Arrays.asList(smallest, largest);\\n    }\\n\\n    private List<Integer> inorder(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        if(root.left != null) {\\n            result.addAll(inorder(root.left));\\n        }\\n        result.add(root.val);\\n        if(root.right != null) {\\n            result.addAll(inorder(root.right));\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "alpha211",
                        "content": "Can I traverse the tree and put node value into a list and then run binary search?"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "DEFINITELY"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "If you are wondering why the search on Tree directly with recursive DFS is giving you TLE , it is because testcases have the worst case which go to the depth of like 10^5 so that would make 10^5 call stack too."
                    },
                    {
                        "username": "skyhuangxy",
                        "content": "My dfs Solution for this problem. The Time Complexity should be O(k*logn), but it gives TLE\\n\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> res; = new ArrayList<>();\\n        for (int target : queries) { \\n            List<Integer> path = new ArrayList<>();\\n            int smallOrequal = dfssmall(root, target);\\n            int largeOrequal = dfslarge(root, target);\\n            path.add(smallOrequal);\\n            path.add(largeOrequal);\\n            res.add(path);\\n        }\\n        return res;\\n    }\\n    private int dfssmall(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val > target) {\\n            return dfssmall(node.left, target);\\n        }\\n        int next = dfssmall(node.right, target);\\n        return next == -1 ? node.val : next;\\n    }\\n    private int dfslarge(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val < target) {\\n            return dfslarge(node.right, target);\\n        }\\n\\n        int next = dfslarge(node.left, target);\\n        return next == -1 ? node.val : next;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1955338,
                "content": [
                    {
                        "username": "dudulichen11",
                        "content": "can anyone help me understand why this preprocessing step results in TLE. This is pretty similar to other accepted answers. Don't really understand since in any case this is O(N) step, which is less compared to the total TC: O(NlogN)...\n``\ndef tree_to_list(root):\n\n            if not root:\n\n                return []\n\n            return tree_to_list(root.left) + [root.val] + tree_to_list(root.right)\narr = tree_to_list(root)\n\n\n``\n"
                    },
                    {
                        "username": "dudulichen11",
                        "content": "[@miraj2399](/miraj2399) Oh, yes. That totally makes sense now. I spent 40 mins on this issue during the contest. Really appreciate your explanation!"
                    },
                    {
                        "username": "yzhao156",
                        "content": "```\nlst = []\ndef dfs(root):\n            if not root:\n                return \n            dfs(root.left)\n            lst.append(root.val)\n            dfs(root.right)\ndfs(root)\nprint(root)\n\n```"
                    },
                    {
                        "username": "miraj2399",
                        "content": "I had the same issue. My code was even shorter(Pythonic) lol!\n```\ndef dfs(root):\n     return dfs(root.left)+[root.val]+dfs(root.right) if root!=None else []\n\n```\nBut from a quick google search, it is apparent that, append function take amortized O(1) time where adding two list with size m and n takes O(m+n) time.\nSo, for this problem appending would make the complexity O(N) where adding list will make it O(N**2)"
                    },
                    {
                        "username": "david6p2",
                        "content": "really silly that you have to balance the tree for this to work"
                    },
                    {
                        "username": "okwxmsz",
                        "content": "Tip: BST could be not balanced"
                    },
                    {
                        "username": "Mirror0227",
                        "content": "Thought for TLE: the input binary tree is not balanced. In some extremely unbalanced case it will become O(n) search (n: total node in the tree).\\n2 way to aviod TLE:\\n- balance it\\n- convert it to array and use binary search on array."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Again,I got accepted with relatively fine runtime in C++ but TLE in Python3.OJ should be consistent between languages.Please fix it"
                    },
                    {
                        "username": "m1nsk",
                        "content": "Correct me if im wrong, but i think that i found O(N) solution in worst case for unbalanced tree.\n\nNo need to traverse the tree and put values to array to do a binary search, no need for TreeSet structure.\n\nhttps://leetcode.com/problems/closest-nodes-queries-in-a-binary-search-tree/solutions/3042770/onlog-k-time-ok-constant-space-no-need-for-additional-n-size-array-and-full-tree-traversal/"
                    },
                    {
                        "username": "harshit_bangar",
                        "content": "My solution is timing out - I am converting it into a sorted array through ignorer traversal  and then finding the value smaller, and larger.\\n ```/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<Integer> inorder = inorder(root);\\n        List<List<Integer>> result = new ArrayList<>(queries.size());\\n        for(int query: queries) {\\n            result.add(findSmallestOrLargest(inorder, query));\\n        }\\n        return result;\\n    }\\n\\n    private List<Integer> findSmallestOrLargest(List<Integer> inorder, int query) {\\n        int start = 0, end = inorder.size()-1;\\n        int smallest = -1, largest = -1;\\n        while(start<=end) {\\n            int mid = (start+end)/2;\\n            if(inorder.get(mid)<query) {\\n                smallest = inorder.get(mid);\\n                start = mid+1;\\n            } else if(inorder.get(mid)>query) {\\n                end = mid-1;\\n                largest = inorder.get(mid);\\n            } else {\\n                return Arrays.asList(query, query);\\n            }\\n        }\\n        return Arrays.asList(smallest, largest);\\n    }\\n\\n    private List<Integer> inorder(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        if(root.left != null) {\\n            result.addAll(inorder(root.left));\\n        }\\n        result.add(root.val);\\n        if(root.right != null) {\\n            result.addAll(inorder(root.right));\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "alpha211",
                        "content": "Can I traverse the tree and put node value into a list and then run binary search?"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "DEFINITELY"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "If you are wondering why the search on Tree directly with recursive DFS is giving you TLE , it is because testcases have the worst case which go to the depth of like 10^5 so that would make 10^5 call stack too."
                    },
                    {
                        "username": "skyhuangxy",
                        "content": "My dfs Solution for this problem. The Time Complexity should be O(k*logn), but it gives TLE\\n\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> res; = new ArrayList<>();\\n        for (int target : queries) { \\n            List<Integer> path = new ArrayList<>();\\n            int smallOrequal = dfssmall(root, target);\\n            int largeOrequal = dfslarge(root, target);\\n            path.add(smallOrequal);\\n            path.add(largeOrequal);\\n            res.add(path);\\n        }\\n        return res;\\n    }\\n    private int dfssmall(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val > target) {\\n            return dfssmall(node.left, target);\\n        }\\n        int next = dfssmall(node.right, target);\\n        return next == -1 ? node.val : next;\\n    }\\n    private int dfslarge(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val < target) {\\n            return dfslarge(node.right, target);\\n        }\\n\\n        int next = dfslarge(node.left, target);\\n        return next == -1 ? node.val : next;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1754923,
                "content": [
                    {
                        "username": "dudulichen11",
                        "content": "can anyone help me understand why this preprocessing step results in TLE. This is pretty similar to other accepted answers. Don't really understand since in any case this is O(N) step, which is less compared to the total TC: O(NlogN)...\n``\ndef tree_to_list(root):\n\n            if not root:\n\n                return []\n\n            return tree_to_list(root.left) + [root.val] + tree_to_list(root.right)\narr = tree_to_list(root)\n\n\n``\n"
                    },
                    {
                        "username": "dudulichen11",
                        "content": "[@miraj2399](/miraj2399) Oh, yes. That totally makes sense now. I spent 40 mins on this issue during the contest. Really appreciate your explanation!"
                    },
                    {
                        "username": "yzhao156",
                        "content": "```\nlst = []\ndef dfs(root):\n            if not root:\n                return \n            dfs(root.left)\n            lst.append(root.val)\n            dfs(root.right)\ndfs(root)\nprint(root)\n\n```"
                    },
                    {
                        "username": "miraj2399",
                        "content": "I had the same issue. My code was even shorter(Pythonic) lol!\n```\ndef dfs(root):\n     return dfs(root.left)+[root.val]+dfs(root.right) if root!=None else []\n\n```\nBut from a quick google search, it is apparent that, append function take amortized O(1) time where adding two list with size m and n takes O(m+n) time.\nSo, for this problem appending would make the complexity O(N) where adding list will make it O(N**2)"
                    },
                    {
                        "username": "david6p2",
                        "content": "really silly that you have to balance the tree for this to work"
                    },
                    {
                        "username": "okwxmsz",
                        "content": "Tip: BST could be not balanced"
                    },
                    {
                        "username": "Mirror0227",
                        "content": "Thought for TLE: the input binary tree is not balanced. In some extremely unbalanced case it will become O(n) search (n: total node in the tree).\\n2 way to aviod TLE:\\n- balance it\\n- convert it to array and use binary search on array."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Again,I got accepted with relatively fine runtime in C++ but TLE in Python3.OJ should be consistent between languages.Please fix it"
                    },
                    {
                        "username": "m1nsk",
                        "content": "Correct me if im wrong, but i think that i found O(N) solution in worst case for unbalanced tree.\n\nNo need to traverse the tree and put values to array to do a binary search, no need for TreeSet structure.\n\nhttps://leetcode.com/problems/closest-nodes-queries-in-a-binary-search-tree/solutions/3042770/onlog-k-time-ok-constant-space-no-need-for-additional-n-size-array-and-full-tree-traversal/"
                    },
                    {
                        "username": "harshit_bangar",
                        "content": "My solution is timing out - I am converting it into a sorted array through ignorer traversal  and then finding the value smaller, and larger.\\n ```/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<Integer> inorder = inorder(root);\\n        List<List<Integer>> result = new ArrayList<>(queries.size());\\n        for(int query: queries) {\\n            result.add(findSmallestOrLargest(inorder, query));\\n        }\\n        return result;\\n    }\\n\\n    private List<Integer> findSmallestOrLargest(List<Integer> inorder, int query) {\\n        int start = 0, end = inorder.size()-1;\\n        int smallest = -1, largest = -1;\\n        while(start<=end) {\\n            int mid = (start+end)/2;\\n            if(inorder.get(mid)<query) {\\n                smallest = inorder.get(mid);\\n                start = mid+1;\\n            } else if(inorder.get(mid)>query) {\\n                end = mid-1;\\n                largest = inorder.get(mid);\\n            } else {\\n                return Arrays.asList(query, query);\\n            }\\n        }\\n        return Arrays.asList(smallest, largest);\\n    }\\n\\n    private List<Integer> inorder(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        if(root.left != null) {\\n            result.addAll(inorder(root.left));\\n        }\\n        result.add(root.val);\\n        if(root.right != null) {\\n            result.addAll(inorder(root.right));\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "alpha211",
                        "content": "Can I traverse the tree and put node value into a list and then run binary search?"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "DEFINITELY"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "If you are wondering why the search on Tree directly with recursive DFS is giving you TLE , it is because testcases have the worst case which go to the depth of like 10^5 so that would make 10^5 call stack too."
                    },
                    {
                        "username": "skyhuangxy",
                        "content": "My dfs Solution for this problem. The Time Complexity should be O(k*logn), but it gives TLE\\n\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> res; = new ArrayList<>();\\n        for (int target : queries) { \\n            List<Integer> path = new ArrayList<>();\\n            int smallOrequal = dfssmall(root, target);\\n            int largeOrequal = dfslarge(root, target);\\n            path.add(smallOrequal);\\n            path.add(largeOrequal);\\n            res.add(path);\\n        }\\n        return res;\\n    }\\n    private int dfssmall(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val > target) {\\n            return dfssmall(node.left, target);\\n        }\\n        int next = dfssmall(node.right, target);\\n        return next == -1 ? node.val : next;\\n    }\\n    private int dfslarge(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val < target) {\\n            return dfslarge(node.right, target);\\n        }\\n\\n        int next = dfslarge(node.left, target);\\n        return next == -1 ? node.val : next;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1748491,
                "content": [
                    {
                        "username": "dudulichen11",
                        "content": "can anyone help me understand why this preprocessing step results in TLE. This is pretty similar to other accepted answers. Don't really understand since in any case this is O(N) step, which is less compared to the total TC: O(NlogN)...\n``\ndef tree_to_list(root):\n\n            if not root:\n\n                return []\n\n            return tree_to_list(root.left) + [root.val] + tree_to_list(root.right)\narr = tree_to_list(root)\n\n\n``\n"
                    },
                    {
                        "username": "dudulichen11",
                        "content": "[@miraj2399](/miraj2399) Oh, yes. That totally makes sense now. I spent 40 mins on this issue during the contest. Really appreciate your explanation!"
                    },
                    {
                        "username": "yzhao156",
                        "content": "```\nlst = []\ndef dfs(root):\n            if not root:\n                return \n            dfs(root.left)\n            lst.append(root.val)\n            dfs(root.right)\ndfs(root)\nprint(root)\n\n```"
                    },
                    {
                        "username": "miraj2399",
                        "content": "I had the same issue. My code was even shorter(Pythonic) lol!\n```\ndef dfs(root):\n     return dfs(root.left)+[root.val]+dfs(root.right) if root!=None else []\n\n```\nBut from a quick google search, it is apparent that, append function take amortized O(1) time where adding two list with size m and n takes O(m+n) time.\nSo, for this problem appending would make the complexity O(N) where adding list will make it O(N**2)"
                    },
                    {
                        "username": "david6p2",
                        "content": "really silly that you have to balance the tree for this to work"
                    },
                    {
                        "username": "okwxmsz",
                        "content": "Tip: BST could be not balanced"
                    },
                    {
                        "username": "Mirror0227",
                        "content": "Thought for TLE: the input binary tree is not balanced. In some extremely unbalanced case it will become O(n) search (n: total node in the tree).\\n2 way to aviod TLE:\\n- balance it\\n- convert it to array and use binary search on array."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Again,I got accepted with relatively fine runtime in C++ but TLE in Python3.OJ should be consistent between languages.Please fix it"
                    },
                    {
                        "username": "m1nsk",
                        "content": "Correct me if im wrong, but i think that i found O(N) solution in worst case for unbalanced tree.\n\nNo need to traverse the tree and put values to array to do a binary search, no need for TreeSet structure.\n\nhttps://leetcode.com/problems/closest-nodes-queries-in-a-binary-search-tree/solutions/3042770/onlog-k-time-ok-constant-space-no-need-for-additional-n-size-array-and-full-tree-traversal/"
                    },
                    {
                        "username": "harshit_bangar",
                        "content": "My solution is timing out - I am converting it into a sorted array through ignorer traversal  and then finding the value smaller, and larger.\\n ```/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<Integer> inorder = inorder(root);\\n        List<List<Integer>> result = new ArrayList<>(queries.size());\\n        for(int query: queries) {\\n            result.add(findSmallestOrLargest(inorder, query));\\n        }\\n        return result;\\n    }\\n\\n    private List<Integer> findSmallestOrLargest(List<Integer> inorder, int query) {\\n        int start = 0, end = inorder.size()-1;\\n        int smallest = -1, largest = -1;\\n        while(start<=end) {\\n            int mid = (start+end)/2;\\n            if(inorder.get(mid)<query) {\\n                smallest = inorder.get(mid);\\n                start = mid+1;\\n            } else if(inorder.get(mid)>query) {\\n                end = mid-1;\\n                largest = inorder.get(mid);\\n            } else {\\n                return Arrays.asList(query, query);\\n            }\\n        }\\n        return Arrays.asList(smallest, largest);\\n    }\\n\\n    private List<Integer> inorder(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        if(root.left != null) {\\n            result.addAll(inorder(root.left));\\n        }\\n        result.add(root.val);\\n        if(root.right != null) {\\n            result.addAll(inorder(root.right));\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "alpha211",
                        "content": "Can I traverse the tree and put node value into a list and then run binary search?"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "DEFINITELY"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "If you are wondering why the search on Tree directly with recursive DFS is giving you TLE , it is because testcases have the worst case which go to the depth of like 10^5 so that would make 10^5 call stack too."
                    },
                    {
                        "username": "skyhuangxy",
                        "content": "My dfs Solution for this problem. The Time Complexity should be O(k*logn), but it gives TLE\\n\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> res; = new ArrayList<>();\\n        for (int target : queries) { \\n            List<Integer> path = new ArrayList<>();\\n            int smallOrequal = dfssmall(root, target);\\n            int largeOrequal = dfslarge(root, target);\\n            path.add(smallOrequal);\\n            path.add(largeOrequal);\\n            res.add(path);\\n        }\\n        return res;\\n    }\\n    private int dfssmall(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val > target) {\\n            return dfssmall(node.left, target);\\n        }\\n        int next = dfssmall(node.right, target);\\n        return next == -1 ? node.val : next;\\n    }\\n    private int dfslarge(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val < target) {\\n            return dfslarge(node.right, target);\\n        }\\n\\n        int next = dfslarge(node.left, target);\\n        return next == -1 ? node.val : next;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1733386,
                "content": [
                    {
                        "username": "dudulichen11",
                        "content": "can anyone help me understand why this preprocessing step results in TLE. This is pretty similar to other accepted answers. Don't really understand since in any case this is O(N) step, which is less compared to the total TC: O(NlogN)...\n``\ndef tree_to_list(root):\n\n            if not root:\n\n                return []\n\n            return tree_to_list(root.left) + [root.val] + tree_to_list(root.right)\narr = tree_to_list(root)\n\n\n``\n"
                    },
                    {
                        "username": "dudulichen11",
                        "content": "[@miraj2399](/miraj2399) Oh, yes. That totally makes sense now. I spent 40 mins on this issue during the contest. Really appreciate your explanation!"
                    },
                    {
                        "username": "yzhao156",
                        "content": "```\nlst = []\ndef dfs(root):\n            if not root:\n                return \n            dfs(root.left)\n            lst.append(root.val)\n            dfs(root.right)\ndfs(root)\nprint(root)\n\n```"
                    },
                    {
                        "username": "miraj2399",
                        "content": "I had the same issue. My code was even shorter(Pythonic) lol!\n```\ndef dfs(root):\n     return dfs(root.left)+[root.val]+dfs(root.right) if root!=None else []\n\n```\nBut from a quick google search, it is apparent that, append function take amortized O(1) time where adding two list with size m and n takes O(m+n) time.\nSo, for this problem appending would make the complexity O(N) where adding list will make it O(N**2)"
                    },
                    {
                        "username": "david6p2",
                        "content": "really silly that you have to balance the tree for this to work"
                    },
                    {
                        "username": "okwxmsz",
                        "content": "Tip: BST could be not balanced"
                    },
                    {
                        "username": "Mirror0227",
                        "content": "Thought for TLE: the input binary tree is not balanced. In some extremely unbalanced case it will become O(n) search (n: total node in the tree).\\n2 way to aviod TLE:\\n- balance it\\n- convert it to array and use binary search on array."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Again,I got accepted with relatively fine runtime in C++ but TLE in Python3.OJ should be consistent between languages.Please fix it"
                    },
                    {
                        "username": "m1nsk",
                        "content": "Correct me if im wrong, but i think that i found O(N) solution in worst case for unbalanced tree.\n\nNo need to traverse the tree and put values to array to do a binary search, no need for TreeSet structure.\n\nhttps://leetcode.com/problems/closest-nodes-queries-in-a-binary-search-tree/solutions/3042770/onlog-k-time-ok-constant-space-no-need-for-additional-n-size-array-and-full-tree-traversal/"
                    },
                    {
                        "username": "harshit_bangar",
                        "content": "My solution is timing out - I am converting it into a sorted array through ignorer traversal  and then finding the value smaller, and larger.\\n ```/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<Integer> inorder = inorder(root);\\n        List<List<Integer>> result = new ArrayList<>(queries.size());\\n        for(int query: queries) {\\n            result.add(findSmallestOrLargest(inorder, query));\\n        }\\n        return result;\\n    }\\n\\n    private List<Integer> findSmallestOrLargest(List<Integer> inorder, int query) {\\n        int start = 0, end = inorder.size()-1;\\n        int smallest = -1, largest = -1;\\n        while(start<=end) {\\n            int mid = (start+end)/2;\\n            if(inorder.get(mid)<query) {\\n                smallest = inorder.get(mid);\\n                start = mid+1;\\n            } else if(inorder.get(mid)>query) {\\n                end = mid-1;\\n                largest = inorder.get(mid);\\n            } else {\\n                return Arrays.asList(query, query);\\n            }\\n        }\\n        return Arrays.asList(smallest, largest);\\n    }\\n\\n    private List<Integer> inorder(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        if(root.left != null) {\\n            result.addAll(inorder(root.left));\\n        }\\n        result.add(root.val);\\n        if(root.right != null) {\\n            result.addAll(inorder(root.right));\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "alpha211",
                        "content": "Can I traverse the tree and put node value into a list and then run binary search?"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "DEFINITELY"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "If you are wondering why the search on Tree directly with recursive DFS is giving you TLE , it is because testcases have the worst case which go to the depth of like 10^5 so that would make 10^5 call stack too."
                    },
                    {
                        "username": "skyhuangxy",
                        "content": "My dfs Solution for this problem. The Time Complexity should be O(k*logn), but it gives TLE\\n\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> res; = new ArrayList<>();\\n        for (int target : queries) { \\n            List<Integer> path = new ArrayList<>();\\n            int smallOrequal = dfssmall(root, target);\\n            int largeOrequal = dfslarge(root, target);\\n            path.add(smallOrequal);\\n            path.add(largeOrequal);\\n            res.add(path);\\n        }\\n        return res;\\n    }\\n    private int dfssmall(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val > target) {\\n            return dfssmall(node.left, target);\\n        }\\n        int next = dfssmall(node.right, target);\\n        return next == -1 ? node.val : next;\\n    }\\n    private int dfslarge(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val < target) {\\n            return dfslarge(node.right, target);\\n        }\\n\\n        int next = dfslarge(node.left, target);\\n        return next == -1 ? node.val : next;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1690367,
                "content": [
                    {
                        "username": "dudulichen11",
                        "content": "can anyone help me understand why this preprocessing step results in TLE. This is pretty similar to other accepted answers. Don't really understand since in any case this is O(N) step, which is less compared to the total TC: O(NlogN)...\n``\ndef tree_to_list(root):\n\n            if not root:\n\n                return []\n\n            return tree_to_list(root.left) + [root.val] + tree_to_list(root.right)\narr = tree_to_list(root)\n\n\n``\n"
                    },
                    {
                        "username": "dudulichen11",
                        "content": "[@miraj2399](/miraj2399) Oh, yes. That totally makes sense now. I spent 40 mins on this issue during the contest. Really appreciate your explanation!"
                    },
                    {
                        "username": "yzhao156",
                        "content": "```\nlst = []\ndef dfs(root):\n            if not root:\n                return \n            dfs(root.left)\n            lst.append(root.val)\n            dfs(root.right)\ndfs(root)\nprint(root)\n\n```"
                    },
                    {
                        "username": "miraj2399",
                        "content": "I had the same issue. My code was even shorter(Pythonic) lol!\n```\ndef dfs(root):\n     return dfs(root.left)+[root.val]+dfs(root.right) if root!=None else []\n\n```\nBut from a quick google search, it is apparent that, append function take amortized O(1) time where adding two list with size m and n takes O(m+n) time.\nSo, for this problem appending would make the complexity O(N) where adding list will make it O(N**2)"
                    },
                    {
                        "username": "david6p2",
                        "content": "really silly that you have to balance the tree for this to work"
                    },
                    {
                        "username": "okwxmsz",
                        "content": "Tip: BST could be not balanced"
                    },
                    {
                        "username": "Mirror0227",
                        "content": "Thought for TLE: the input binary tree is not balanced. In some extremely unbalanced case it will become O(n) search (n: total node in the tree).\\n2 way to aviod TLE:\\n- balance it\\n- convert it to array and use binary search on array."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Again,I got accepted with relatively fine runtime in C++ but TLE in Python3.OJ should be consistent between languages.Please fix it"
                    },
                    {
                        "username": "m1nsk",
                        "content": "Correct me if im wrong, but i think that i found O(N) solution in worst case for unbalanced tree.\n\nNo need to traverse the tree and put values to array to do a binary search, no need for TreeSet structure.\n\nhttps://leetcode.com/problems/closest-nodes-queries-in-a-binary-search-tree/solutions/3042770/onlog-k-time-ok-constant-space-no-need-for-additional-n-size-array-and-full-tree-traversal/"
                    },
                    {
                        "username": "harshit_bangar",
                        "content": "My solution is timing out - I am converting it into a sorted array through ignorer traversal  and then finding the value smaller, and larger.\\n ```/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<Integer> inorder = inorder(root);\\n        List<List<Integer>> result = new ArrayList<>(queries.size());\\n        for(int query: queries) {\\n            result.add(findSmallestOrLargest(inorder, query));\\n        }\\n        return result;\\n    }\\n\\n    private List<Integer> findSmallestOrLargest(List<Integer> inorder, int query) {\\n        int start = 0, end = inorder.size()-1;\\n        int smallest = -1, largest = -1;\\n        while(start<=end) {\\n            int mid = (start+end)/2;\\n            if(inorder.get(mid)<query) {\\n                smallest = inorder.get(mid);\\n                start = mid+1;\\n            } else if(inorder.get(mid)>query) {\\n                end = mid-1;\\n                largest = inorder.get(mid);\\n            } else {\\n                return Arrays.asList(query, query);\\n            }\\n        }\\n        return Arrays.asList(smallest, largest);\\n    }\\n\\n    private List<Integer> inorder(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        if(root.left != null) {\\n            result.addAll(inorder(root.left));\\n        }\\n        result.add(root.val);\\n        if(root.right != null) {\\n            result.addAll(inorder(root.right));\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "alpha211",
                        "content": "Can I traverse the tree and put node value into a list and then run binary search?"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "DEFINITELY"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "If you are wondering why the search on Tree directly with recursive DFS is giving you TLE , it is because testcases have the worst case which go to the depth of like 10^5 so that would make 10^5 call stack too."
                    },
                    {
                        "username": "skyhuangxy",
                        "content": "My dfs Solution for this problem. The Time Complexity should be O(k*logn), but it gives TLE\\n\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> res; = new ArrayList<>();\\n        for (int target : queries) { \\n            List<Integer> path = new ArrayList<>();\\n            int smallOrequal = dfssmall(root, target);\\n            int largeOrequal = dfslarge(root, target);\\n            path.add(smallOrequal);\\n            path.add(largeOrequal);\\n            res.add(path);\\n        }\\n        return res;\\n    }\\n    private int dfssmall(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val > target) {\\n            return dfssmall(node.left, target);\\n        }\\n        int next = dfssmall(node.right, target);\\n        return next == -1 ? node.val : next;\\n    }\\n    private int dfslarge(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val < target) {\\n            return dfslarge(node.right, target);\\n        }\\n\\n        int next = dfslarge(node.left, target);\\n        return next == -1 ? node.val : next;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1690281,
                "content": [
                    {
                        "username": "dudulichen11",
                        "content": "can anyone help me understand why this preprocessing step results in TLE. This is pretty similar to other accepted answers. Don't really understand since in any case this is O(N) step, which is less compared to the total TC: O(NlogN)...\n``\ndef tree_to_list(root):\n\n            if not root:\n\n                return []\n\n            return tree_to_list(root.left) + [root.val] + tree_to_list(root.right)\narr = tree_to_list(root)\n\n\n``\n"
                    },
                    {
                        "username": "dudulichen11",
                        "content": "[@miraj2399](/miraj2399) Oh, yes. That totally makes sense now. I spent 40 mins on this issue during the contest. Really appreciate your explanation!"
                    },
                    {
                        "username": "yzhao156",
                        "content": "```\nlst = []\ndef dfs(root):\n            if not root:\n                return \n            dfs(root.left)\n            lst.append(root.val)\n            dfs(root.right)\ndfs(root)\nprint(root)\n\n```"
                    },
                    {
                        "username": "miraj2399",
                        "content": "I had the same issue. My code was even shorter(Pythonic) lol!\n```\ndef dfs(root):\n     return dfs(root.left)+[root.val]+dfs(root.right) if root!=None else []\n\n```\nBut from a quick google search, it is apparent that, append function take amortized O(1) time where adding two list with size m and n takes O(m+n) time.\nSo, for this problem appending would make the complexity O(N) where adding list will make it O(N**2)"
                    },
                    {
                        "username": "david6p2",
                        "content": "really silly that you have to balance the tree for this to work"
                    },
                    {
                        "username": "okwxmsz",
                        "content": "Tip: BST could be not balanced"
                    },
                    {
                        "username": "Mirror0227",
                        "content": "Thought for TLE: the input binary tree is not balanced. In some extremely unbalanced case it will become O(n) search (n: total node in the tree).\\n2 way to aviod TLE:\\n- balance it\\n- convert it to array and use binary search on array."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Again,I got accepted with relatively fine runtime in C++ but TLE in Python3.OJ should be consistent between languages.Please fix it"
                    },
                    {
                        "username": "m1nsk",
                        "content": "Correct me if im wrong, but i think that i found O(N) solution in worst case for unbalanced tree.\n\nNo need to traverse the tree and put values to array to do a binary search, no need for TreeSet structure.\n\nhttps://leetcode.com/problems/closest-nodes-queries-in-a-binary-search-tree/solutions/3042770/onlog-k-time-ok-constant-space-no-need-for-additional-n-size-array-and-full-tree-traversal/"
                    },
                    {
                        "username": "harshit_bangar",
                        "content": "My solution is timing out - I am converting it into a sorted array through ignorer traversal  and then finding the value smaller, and larger.\\n ```/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<Integer> inorder = inorder(root);\\n        List<List<Integer>> result = new ArrayList<>(queries.size());\\n        for(int query: queries) {\\n            result.add(findSmallestOrLargest(inorder, query));\\n        }\\n        return result;\\n    }\\n\\n    private List<Integer> findSmallestOrLargest(List<Integer> inorder, int query) {\\n        int start = 0, end = inorder.size()-1;\\n        int smallest = -1, largest = -1;\\n        while(start<=end) {\\n            int mid = (start+end)/2;\\n            if(inorder.get(mid)<query) {\\n                smallest = inorder.get(mid);\\n                start = mid+1;\\n            } else if(inorder.get(mid)>query) {\\n                end = mid-1;\\n                largest = inorder.get(mid);\\n            } else {\\n                return Arrays.asList(query, query);\\n            }\\n        }\\n        return Arrays.asList(smallest, largest);\\n    }\\n\\n    private List<Integer> inorder(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        if(root.left != null) {\\n            result.addAll(inorder(root.left));\\n        }\\n        result.add(root.val);\\n        if(root.right != null) {\\n            result.addAll(inorder(root.right));\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "alpha211",
                        "content": "Can I traverse the tree and put node value into a list and then run binary search?"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "DEFINITELY"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "If you are wondering why the search on Tree directly with recursive DFS is giving you TLE , it is because testcases have the worst case which go to the depth of like 10^5 so that would make 10^5 call stack too."
                    },
                    {
                        "username": "skyhuangxy",
                        "content": "My dfs Solution for this problem. The Time Complexity should be O(k*logn), but it gives TLE\\n\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> res; = new ArrayList<>();\\n        for (int target : queries) { \\n            List<Integer> path = new ArrayList<>();\\n            int smallOrequal = dfssmall(root, target);\\n            int largeOrequal = dfslarge(root, target);\\n            path.add(smallOrequal);\\n            path.add(largeOrequal);\\n            res.add(path);\\n        }\\n        return res;\\n    }\\n    private int dfssmall(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val > target) {\\n            return dfssmall(node.left, target);\\n        }\\n        int next = dfssmall(node.right, target);\\n        return next == -1 ? node.val : next;\\n    }\\n    private int dfslarge(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val < target) {\\n            return dfslarge(node.right, target);\\n        }\\n\\n        int next = dfslarge(node.left, target);\\n        return next == -1 ? node.val : next;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1690156,
                "content": [
                    {
                        "username": "dudulichen11",
                        "content": "can anyone help me understand why this preprocessing step results in TLE. This is pretty similar to other accepted answers. Don't really understand since in any case this is O(N) step, which is less compared to the total TC: O(NlogN)...\n``\ndef tree_to_list(root):\n\n            if not root:\n\n                return []\n\n            return tree_to_list(root.left) + [root.val] + tree_to_list(root.right)\narr = tree_to_list(root)\n\n\n``\n"
                    },
                    {
                        "username": "dudulichen11",
                        "content": "[@miraj2399](/miraj2399) Oh, yes. That totally makes sense now. I spent 40 mins on this issue during the contest. Really appreciate your explanation!"
                    },
                    {
                        "username": "yzhao156",
                        "content": "```\nlst = []\ndef dfs(root):\n            if not root:\n                return \n            dfs(root.left)\n            lst.append(root.val)\n            dfs(root.right)\ndfs(root)\nprint(root)\n\n```"
                    },
                    {
                        "username": "miraj2399",
                        "content": "I had the same issue. My code was even shorter(Pythonic) lol!\n```\ndef dfs(root):\n     return dfs(root.left)+[root.val]+dfs(root.right) if root!=None else []\n\n```\nBut from a quick google search, it is apparent that, append function take amortized O(1) time where adding two list with size m and n takes O(m+n) time.\nSo, for this problem appending would make the complexity O(N) where adding list will make it O(N**2)"
                    },
                    {
                        "username": "david6p2",
                        "content": "really silly that you have to balance the tree for this to work"
                    },
                    {
                        "username": "okwxmsz",
                        "content": "Tip: BST could be not balanced"
                    },
                    {
                        "username": "Mirror0227",
                        "content": "Thought for TLE: the input binary tree is not balanced. In some extremely unbalanced case it will become O(n) search (n: total node in the tree).\\n2 way to aviod TLE:\\n- balance it\\n- convert it to array and use binary search on array."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Again,I got accepted with relatively fine runtime in C++ but TLE in Python3.OJ should be consistent between languages.Please fix it"
                    },
                    {
                        "username": "m1nsk",
                        "content": "Correct me if im wrong, but i think that i found O(N) solution in worst case for unbalanced tree.\n\nNo need to traverse the tree and put values to array to do a binary search, no need for TreeSet structure.\n\nhttps://leetcode.com/problems/closest-nodes-queries-in-a-binary-search-tree/solutions/3042770/onlog-k-time-ok-constant-space-no-need-for-additional-n-size-array-and-full-tree-traversal/"
                    },
                    {
                        "username": "harshit_bangar",
                        "content": "My solution is timing out - I am converting it into a sorted array through ignorer traversal  and then finding the value smaller, and larger.\\n ```/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<Integer> inorder = inorder(root);\\n        List<List<Integer>> result = new ArrayList<>(queries.size());\\n        for(int query: queries) {\\n            result.add(findSmallestOrLargest(inorder, query));\\n        }\\n        return result;\\n    }\\n\\n    private List<Integer> findSmallestOrLargest(List<Integer> inorder, int query) {\\n        int start = 0, end = inorder.size()-1;\\n        int smallest = -1, largest = -1;\\n        while(start<=end) {\\n            int mid = (start+end)/2;\\n            if(inorder.get(mid)<query) {\\n                smallest = inorder.get(mid);\\n                start = mid+1;\\n            } else if(inorder.get(mid)>query) {\\n                end = mid-1;\\n                largest = inorder.get(mid);\\n            } else {\\n                return Arrays.asList(query, query);\\n            }\\n        }\\n        return Arrays.asList(smallest, largest);\\n    }\\n\\n    private List<Integer> inorder(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        if(root.left != null) {\\n            result.addAll(inorder(root.left));\\n        }\\n        result.add(root.val);\\n        if(root.right != null) {\\n            result.addAll(inorder(root.right));\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "alpha211",
                        "content": "Can I traverse the tree and put node value into a list and then run binary search?"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "DEFINITELY"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "If you are wondering why the search on Tree directly with recursive DFS is giving you TLE , it is because testcases have the worst case which go to the depth of like 10^5 so that would make 10^5 call stack too."
                    },
                    {
                        "username": "skyhuangxy",
                        "content": "My dfs Solution for this problem. The Time Complexity should be O(k*logn), but it gives TLE\\n\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> res; = new ArrayList<>();\\n        for (int target : queries) { \\n            List<Integer> path = new ArrayList<>();\\n            int smallOrequal = dfssmall(root, target);\\n            int largeOrequal = dfslarge(root, target);\\n            path.add(smallOrequal);\\n            path.add(largeOrequal);\\n            res.add(path);\\n        }\\n        return res;\\n    }\\n    private int dfssmall(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val > target) {\\n            return dfssmall(node.left, target);\\n        }\\n        int next = dfssmall(node.right, target);\\n        return next == -1 ? node.val : next;\\n    }\\n    private int dfslarge(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val < target) {\\n            return dfslarge(node.right, target);\\n        }\\n\\n        int next = dfslarge(node.left, target);\\n        return next == -1 ? node.val : next;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1690137,
                "content": [
                    {
                        "username": "dudulichen11",
                        "content": "can anyone help me understand why this preprocessing step results in TLE. This is pretty similar to other accepted answers. Don't really understand since in any case this is O(N) step, which is less compared to the total TC: O(NlogN)...\n``\ndef tree_to_list(root):\n\n            if not root:\n\n                return []\n\n            return tree_to_list(root.left) + [root.val] + tree_to_list(root.right)\narr = tree_to_list(root)\n\n\n``\n"
                    },
                    {
                        "username": "dudulichen11",
                        "content": "[@miraj2399](/miraj2399) Oh, yes. That totally makes sense now. I spent 40 mins on this issue during the contest. Really appreciate your explanation!"
                    },
                    {
                        "username": "yzhao156",
                        "content": "```\nlst = []\ndef dfs(root):\n            if not root:\n                return \n            dfs(root.left)\n            lst.append(root.val)\n            dfs(root.right)\ndfs(root)\nprint(root)\n\n```"
                    },
                    {
                        "username": "miraj2399",
                        "content": "I had the same issue. My code was even shorter(Pythonic) lol!\n```\ndef dfs(root):\n     return dfs(root.left)+[root.val]+dfs(root.right) if root!=None else []\n\n```\nBut from a quick google search, it is apparent that, append function take amortized O(1) time where adding two list with size m and n takes O(m+n) time.\nSo, for this problem appending would make the complexity O(N) where adding list will make it O(N**2)"
                    },
                    {
                        "username": "david6p2",
                        "content": "really silly that you have to balance the tree for this to work"
                    },
                    {
                        "username": "okwxmsz",
                        "content": "Tip: BST could be not balanced"
                    },
                    {
                        "username": "Mirror0227",
                        "content": "Thought for TLE: the input binary tree is not balanced. In some extremely unbalanced case it will become O(n) search (n: total node in the tree).\\n2 way to aviod TLE:\\n- balance it\\n- convert it to array and use binary search on array."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Again,I got accepted with relatively fine runtime in C++ but TLE in Python3.OJ should be consistent between languages.Please fix it"
                    },
                    {
                        "username": "m1nsk",
                        "content": "Correct me if im wrong, but i think that i found O(N) solution in worst case for unbalanced tree.\n\nNo need to traverse the tree and put values to array to do a binary search, no need for TreeSet structure.\n\nhttps://leetcode.com/problems/closest-nodes-queries-in-a-binary-search-tree/solutions/3042770/onlog-k-time-ok-constant-space-no-need-for-additional-n-size-array-and-full-tree-traversal/"
                    },
                    {
                        "username": "harshit_bangar",
                        "content": "My solution is timing out - I am converting it into a sorted array through ignorer traversal  and then finding the value smaller, and larger.\\n ```/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<Integer> inorder = inorder(root);\\n        List<List<Integer>> result = new ArrayList<>(queries.size());\\n        for(int query: queries) {\\n            result.add(findSmallestOrLargest(inorder, query));\\n        }\\n        return result;\\n    }\\n\\n    private List<Integer> findSmallestOrLargest(List<Integer> inorder, int query) {\\n        int start = 0, end = inorder.size()-1;\\n        int smallest = -1, largest = -1;\\n        while(start<=end) {\\n            int mid = (start+end)/2;\\n            if(inorder.get(mid)<query) {\\n                smallest = inorder.get(mid);\\n                start = mid+1;\\n            } else if(inorder.get(mid)>query) {\\n                end = mid-1;\\n                largest = inorder.get(mid);\\n            } else {\\n                return Arrays.asList(query, query);\\n            }\\n        }\\n        return Arrays.asList(smallest, largest);\\n    }\\n\\n    private List<Integer> inorder(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        if(root.left != null) {\\n            result.addAll(inorder(root.left));\\n        }\\n        result.add(root.val);\\n        if(root.right != null) {\\n            result.addAll(inorder(root.right));\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "alpha211",
                        "content": "Can I traverse the tree and put node value into a list and then run binary search?"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "DEFINITELY"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "If you are wondering why the search on Tree directly with recursive DFS is giving you TLE , it is because testcases have the worst case which go to the depth of like 10^5 so that would make 10^5 call stack too."
                    },
                    {
                        "username": "skyhuangxy",
                        "content": "My dfs Solution for this problem. The Time Complexity should be O(k*logn), but it gives TLE\\n\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> res; = new ArrayList<>();\\n        for (int target : queries) { \\n            List<Integer> path = new ArrayList<>();\\n            int smallOrequal = dfssmall(root, target);\\n            int largeOrequal = dfslarge(root, target);\\n            path.add(smallOrequal);\\n            path.add(largeOrequal);\\n            res.add(path);\\n        }\\n        return res;\\n    }\\n    private int dfssmall(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val > target) {\\n            return dfssmall(node.left, target);\\n        }\\n        int next = dfssmall(node.right, target);\\n        return next == -1 ? node.val : next;\\n    }\\n    private int dfslarge(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val < target) {\\n            return dfslarge(node.right, target);\\n        }\\n\\n        int next = dfslarge(node.left, target);\\n        return next == -1 ? node.val : next;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1690181,
                "content": [
                    {
                        "username": "dudulichen11",
                        "content": "can anyone help me understand why this preprocessing step results in TLE. This is pretty similar to other accepted answers. Don't really understand since in any case this is O(N) step, which is less compared to the total TC: O(NlogN)...\n``\ndef tree_to_list(root):\n\n            if not root:\n\n                return []\n\n            return tree_to_list(root.left) + [root.val] + tree_to_list(root.right)\narr = tree_to_list(root)\n\n\n``\n"
                    },
                    {
                        "username": "dudulichen11",
                        "content": "[@miraj2399](/miraj2399) Oh, yes. That totally makes sense now. I spent 40 mins on this issue during the contest. Really appreciate your explanation!"
                    },
                    {
                        "username": "yzhao156",
                        "content": "```\nlst = []\ndef dfs(root):\n            if not root:\n                return \n            dfs(root.left)\n            lst.append(root.val)\n            dfs(root.right)\ndfs(root)\nprint(root)\n\n```"
                    },
                    {
                        "username": "miraj2399",
                        "content": "I had the same issue. My code was even shorter(Pythonic) lol!\n```\ndef dfs(root):\n     return dfs(root.left)+[root.val]+dfs(root.right) if root!=None else []\n\n```\nBut from a quick google search, it is apparent that, append function take amortized O(1) time where adding two list with size m and n takes O(m+n) time.\nSo, for this problem appending would make the complexity O(N) where adding list will make it O(N**2)"
                    },
                    {
                        "username": "david6p2",
                        "content": "really silly that you have to balance the tree for this to work"
                    },
                    {
                        "username": "okwxmsz",
                        "content": "Tip: BST could be not balanced"
                    },
                    {
                        "username": "Mirror0227",
                        "content": "Thought for TLE: the input binary tree is not balanced. In some extremely unbalanced case it will become O(n) search (n: total node in the tree).\\n2 way to aviod TLE:\\n- balance it\\n- convert it to array and use binary search on array."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Again,I got accepted with relatively fine runtime in C++ but TLE in Python3.OJ should be consistent between languages.Please fix it"
                    },
                    {
                        "username": "m1nsk",
                        "content": "Correct me if im wrong, but i think that i found O(N) solution in worst case for unbalanced tree.\n\nNo need to traverse the tree and put values to array to do a binary search, no need for TreeSet structure.\n\nhttps://leetcode.com/problems/closest-nodes-queries-in-a-binary-search-tree/solutions/3042770/onlog-k-time-ok-constant-space-no-need-for-additional-n-size-array-and-full-tree-traversal/"
                    },
                    {
                        "username": "harshit_bangar",
                        "content": "My solution is timing out - I am converting it into a sorted array through ignorer traversal  and then finding the value smaller, and larger.\\n ```/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<Integer> inorder = inorder(root);\\n        List<List<Integer>> result = new ArrayList<>(queries.size());\\n        for(int query: queries) {\\n            result.add(findSmallestOrLargest(inorder, query));\\n        }\\n        return result;\\n    }\\n\\n    private List<Integer> findSmallestOrLargest(List<Integer> inorder, int query) {\\n        int start = 0, end = inorder.size()-1;\\n        int smallest = -1, largest = -1;\\n        while(start<=end) {\\n            int mid = (start+end)/2;\\n            if(inorder.get(mid)<query) {\\n                smallest = inorder.get(mid);\\n                start = mid+1;\\n            } else if(inorder.get(mid)>query) {\\n                end = mid-1;\\n                largest = inorder.get(mid);\\n            } else {\\n                return Arrays.asList(query, query);\\n            }\\n        }\\n        return Arrays.asList(smallest, largest);\\n    }\\n\\n    private List<Integer> inorder(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        if(root.left != null) {\\n            result.addAll(inorder(root.left));\\n        }\\n        result.add(root.val);\\n        if(root.right != null) {\\n            result.addAll(inorder(root.right));\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "alpha211",
                        "content": "Can I traverse the tree and put node value into a list and then run binary search?"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "DEFINITELY"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "If you are wondering why the search on Tree directly with recursive DFS is giving you TLE , it is because testcases have the worst case which go to the depth of like 10^5 so that would make 10^5 call stack too."
                    },
                    {
                        "username": "skyhuangxy",
                        "content": "My dfs Solution for this problem. The Time Complexity should be O(k*logn), but it gives TLE\\n\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> res; = new ArrayList<>();\\n        for (int target : queries) { \\n            List<Integer> path = new ArrayList<>();\\n            int smallOrequal = dfssmall(root, target);\\n            int largeOrequal = dfslarge(root, target);\\n            path.add(smallOrequal);\\n            path.add(largeOrequal);\\n            res.add(path);\\n        }\\n        return res;\\n    }\\n    private int dfssmall(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val > target) {\\n            return dfssmall(node.left, target);\\n        }\\n        int next = dfssmall(node.right, target);\\n        return next == -1 ? node.val : next;\\n    }\\n    private int dfslarge(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val < target) {\\n            return dfslarge(node.right, target);\\n        }\\n\\n        int next = dfslarge(node.left, target);\\n        return next == -1 ? node.val : next;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1690095,
                "content": [
                    {
                        "username": "dudulichen11",
                        "content": "can anyone help me understand why this preprocessing step results in TLE. This is pretty similar to other accepted answers. Don't really understand since in any case this is O(N) step, which is less compared to the total TC: O(NlogN)...\n``\ndef tree_to_list(root):\n\n            if not root:\n\n                return []\n\n            return tree_to_list(root.left) + [root.val] + tree_to_list(root.right)\narr = tree_to_list(root)\n\n\n``\n"
                    },
                    {
                        "username": "dudulichen11",
                        "content": "[@miraj2399](/miraj2399) Oh, yes. That totally makes sense now. I spent 40 mins on this issue during the contest. Really appreciate your explanation!"
                    },
                    {
                        "username": "yzhao156",
                        "content": "```\nlst = []\ndef dfs(root):\n            if not root:\n                return \n            dfs(root.left)\n            lst.append(root.val)\n            dfs(root.right)\ndfs(root)\nprint(root)\n\n```"
                    },
                    {
                        "username": "miraj2399",
                        "content": "I had the same issue. My code was even shorter(Pythonic) lol!\n```\ndef dfs(root):\n     return dfs(root.left)+[root.val]+dfs(root.right) if root!=None else []\n\n```\nBut from a quick google search, it is apparent that, append function take amortized O(1) time where adding two list with size m and n takes O(m+n) time.\nSo, for this problem appending would make the complexity O(N) where adding list will make it O(N**2)"
                    },
                    {
                        "username": "david6p2",
                        "content": "really silly that you have to balance the tree for this to work"
                    },
                    {
                        "username": "okwxmsz",
                        "content": "Tip: BST could be not balanced"
                    },
                    {
                        "username": "Mirror0227",
                        "content": "Thought for TLE: the input binary tree is not balanced. In some extremely unbalanced case it will become O(n) search (n: total node in the tree).\\n2 way to aviod TLE:\\n- balance it\\n- convert it to array and use binary search on array."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Again,I got accepted with relatively fine runtime in C++ but TLE in Python3.OJ should be consistent between languages.Please fix it"
                    },
                    {
                        "username": "m1nsk",
                        "content": "Correct me if im wrong, but i think that i found O(N) solution in worst case for unbalanced tree.\n\nNo need to traverse the tree and put values to array to do a binary search, no need for TreeSet structure.\n\nhttps://leetcode.com/problems/closest-nodes-queries-in-a-binary-search-tree/solutions/3042770/onlog-k-time-ok-constant-space-no-need-for-additional-n-size-array-and-full-tree-traversal/"
                    },
                    {
                        "username": "harshit_bangar",
                        "content": "My solution is timing out - I am converting it into a sorted array through ignorer traversal  and then finding the value smaller, and larger.\\n ```/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<Integer> inorder = inorder(root);\\n        List<List<Integer>> result = new ArrayList<>(queries.size());\\n        for(int query: queries) {\\n            result.add(findSmallestOrLargest(inorder, query));\\n        }\\n        return result;\\n    }\\n\\n    private List<Integer> findSmallestOrLargest(List<Integer> inorder, int query) {\\n        int start = 0, end = inorder.size()-1;\\n        int smallest = -1, largest = -1;\\n        while(start<=end) {\\n            int mid = (start+end)/2;\\n            if(inorder.get(mid)<query) {\\n                smallest = inorder.get(mid);\\n                start = mid+1;\\n            } else if(inorder.get(mid)>query) {\\n                end = mid-1;\\n                largest = inorder.get(mid);\\n            } else {\\n                return Arrays.asList(query, query);\\n            }\\n        }\\n        return Arrays.asList(smallest, largest);\\n    }\\n\\n    private List<Integer> inorder(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        if(root.left != null) {\\n            result.addAll(inorder(root.left));\\n        }\\n        result.add(root.val);\\n        if(root.right != null) {\\n            result.addAll(inorder(root.right));\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "alpha211",
                        "content": "Can I traverse the tree and put node value into a list and then run binary search?"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "DEFINITELY"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "If you are wondering why the search on Tree directly with recursive DFS is giving you TLE , it is because testcases have the worst case which go to the depth of like 10^5 so that would make 10^5 call stack too."
                    },
                    {
                        "username": "skyhuangxy",
                        "content": "My dfs Solution for this problem. The Time Complexity should be O(k*logn), but it gives TLE\\n\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> res; = new ArrayList<>();\\n        for (int target : queries) { \\n            List<Integer> path = new ArrayList<>();\\n            int smallOrequal = dfssmall(root, target);\\n            int largeOrequal = dfslarge(root, target);\\n            path.add(smallOrequal);\\n            path.add(largeOrequal);\\n            res.add(path);\\n        }\\n        return res;\\n    }\\n    private int dfssmall(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val > target) {\\n            return dfssmall(node.left, target);\\n        }\\n        int next = dfssmall(node.right, target);\\n        return next == -1 ? node.val : next;\\n    }\\n    private int dfslarge(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val < target) {\\n            return dfslarge(node.right, target);\\n        }\\n\\n        int next = dfslarge(node.left, target);\\n        return next == -1 ? node.val : next;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1955338,
                "content": [
                    {
                        "username": "dudulichen11",
                        "content": "can anyone help me understand why this preprocessing step results in TLE. This is pretty similar to other accepted answers. Don't really understand since in any case this is O(N) step, which is less compared to the total TC: O(NlogN)...\n``\ndef tree_to_list(root):\n\n            if not root:\n\n                return []\n\n            return tree_to_list(root.left) + [root.val] + tree_to_list(root.right)\narr = tree_to_list(root)\n\n\n``\n"
                    },
                    {
                        "username": "dudulichen11",
                        "content": "[@miraj2399](/miraj2399) Oh, yes. That totally makes sense now. I spent 40 mins on this issue during the contest. Really appreciate your explanation!"
                    },
                    {
                        "username": "yzhao156",
                        "content": "```\nlst = []\ndef dfs(root):\n            if not root:\n                return \n            dfs(root.left)\n            lst.append(root.val)\n            dfs(root.right)\ndfs(root)\nprint(root)\n\n```"
                    },
                    {
                        "username": "miraj2399",
                        "content": "I had the same issue. My code was even shorter(Pythonic) lol!\n```\ndef dfs(root):\n     return dfs(root.left)+[root.val]+dfs(root.right) if root!=None else []\n\n```\nBut from a quick google search, it is apparent that, append function take amortized O(1) time where adding two list with size m and n takes O(m+n) time.\nSo, for this problem appending would make the complexity O(N) where adding list will make it O(N**2)"
                    },
                    {
                        "username": "david6p2",
                        "content": "really silly that you have to balance the tree for this to work"
                    },
                    {
                        "username": "okwxmsz",
                        "content": "Tip: BST could be not balanced"
                    },
                    {
                        "username": "Mirror0227",
                        "content": "Thought for TLE: the input binary tree is not balanced. In some extremely unbalanced case it will become O(n) search (n: total node in the tree).\\n2 way to aviod TLE:\\n- balance it\\n- convert it to array and use binary search on array."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Again,I got accepted with relatively fine runtime in C++ but TLE in Python3.OJ should be consistent between languages.Please fix it"
                    },
                    {
                        "username": "m1nsk",
                        "content": "Correct me if im wrong, but i think that i found O(N) solution in worst case for unbalanced tree.\n\nNo need to traverse the tree and put values to array to do a binary search, no need for TreeSet structure.\n\nhttps://leetcode.com/problems/closest-nodes-queries-in-a-binary-search-tree/solutions/3042770/onlog-k-time-ok-constant-space-no-need-for-additional-n-size-array-and-full-tree-traversal/"
                    },
                    {
                        "username": "harshit_bangar",
                        "content": "My solution is timing out - I am converting it into a sorted array through ignorer traversal  and then finding the value smaller, and larger.\\n ```/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<Integer> inorder = inorder(root);\\n        List<List<Integer>> result = new ArrayList<>(queries.size());\\n        for(int query: queries) {\\n            result.add(findSmallestOrLargest(inorder, query));\\n        }\\n        return result;\\n    }\\n\\n    private List<Integer> findSmallestOrLargest(List<Integer> inorder, int query) {\\n        int start = 0, end = inorder.size()-1;\\n        int smallest = -1, largest = -1;\\n        while(start<=end) {\\n            int mid = (start+end)/2;\\n            if(inorder.get(mid)<query) {\\n                smallest = inorder.get(mid);\\n                start = mid+1;\\n            } else if(inorder.get(mid)>query) {\\n                end = mid-1;\\n                largest = inorder.get(mid);\\n            } else {\\n                return Arrays.asList(query, query);\\n            }\\n        }\\n        return Arrays.asList(smallest, largest);\\n    }\\n\\n    private List<Integer> inorder(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        if(root.left != null) {\\n            result.addAll(inorder(root.left));\\n        }\\n        result.add(root.val);\\n        if(root.right != null) {\\n            result.addAll(inorder(root.right));\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "alpha211",
                        "content": "Can I traverse the tree and put node value into a list and then run binary search?"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "DEFINITELY"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "If you are wondering why the search on Tree directly with recursive DFS is giving you TLE , it is because testcases have the worst case which go to the depth of like 10^5 so that would make 10^5 call stack too."
                    },
                    {
                        "username": "skyhuangxy",
                        "content": "My dfs Solution for this problem. The Time Complexity should be O(k*logn), but it gives TLE\\n\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> res; = new ArrayList<>();\\n        for (int target : queries) { \\n            List<Integer> path = new ArrayList<>();\\n            int smallOrequal = dfssmall(root, target);\\n            int largeOrequal = dfslarge(root, target);\\n            path.add(smallOrequal);\\n            path.add(largeOrequal);\\n            res.add(path);\\n        }\\n        return res;\\n    }\\n    private int dfssmall(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val > target) {\\n            return dfssmall(node.left, target);\\n        }\\n        int next = dfssmall(node.right, target);\\n        return next == -1 ? node.val : next;\\n    }\\n    private int dfslarge(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val < target) {\\n            return dfslarge(node.right, target);\\n        }\\n\\n        int next = dfslarge(node.left, target);\\n        return next == -1 ? node.val : next;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1754923,
                "content": [
                    {
                        "username": "dudulichen11",
                        "content": "can anyone help me understand why this preprocessing step results in TLE. This is pretty similar to other accepted answers. Don't really understand since in any case this is O(N) step, which is less compared to the total TC: O(NlogN)...\n``\ndef tree_to_list(root):\n\n            if not root:\n\n                return []\n\n            return tree_to_list(root.left) + [root.val] + tree_to_list(root.right)\narr = tree_to_list(root)\n\n\n``\n"
                    },
                    {
                        "username": "dudulichen11",
                        "content": "[@miraj2399](/miraj2399) Oh, yes. That totally makes sense now. I spent 40 mins on this issue during the contest. Really appreciate your explanation!"
                    },
                    {
                        "username": "yzhao156",
                        "content": "```\nlst = []\ndef dfs(root):\n            if not root:\n                return \n            dfs(root.left)\n            lst.append(root.val)\n            dfs(root.right)\ndfs(root)\nprint(root)\n\n```"
                    },
                    {
                        "username": "miraj2399",
                        "content": "I had the same issue. My code was even shorter(Pythonic) lol!\n```\ndef dfs(root):\n     return dfs(root.left)+[root.val]+dfs(root.right) if root!=None else []\n\n```\nBut from a quick google search, it is apparent that, append function take amortized O(1) time where adding two list with size m and n takes O(m+n) time.\nSo, for this problem appending would make the complexity O(N) where adding list will make it O(N**2)"
                    },
                    {
                        "username": "david6p2",
                        "content": "really silly that you have to balance the tree for this to work"
                    },
                    {
                        "username": "okwxmsz",
                        "content": "Tip: BST could be not balanced"
                    },
                    {
                        "username": "Mirror0227",
                        "content": "Thought for TLE: the input binary tree is not balanced. In some extremely unbalanced case it will become O(n) search (n: total node in the tree).\\n2 way to aviod TLE:\\n- balance it\\n- convert it to array and use binary search on array."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Again,I got accepted with relatively fine runtime in C++ but TLE in Python3.OJ should be consistent between languages.Please fix it"
                    },
                    {
                        "username": "m1nsk",
                        "content": "Correct me if im wrong, but i think that i found O(N) solution in worst case for unbalanced tree.\n\nNo need to traverse the tree and put values to array to do a binary search, no need for TreeSet structure.\n\nhttps://leetcode.com/problems/closest-nodes-queries-in-a-binary-search-tree/solutions/3042770/onlog-k-time-ok-constant-space-no-need-for-additional-n-size-array-and-full-tree-traversal/"
                    },
                    {
                        "username": "harshit_bangar",
                        "content": "My solution is timing out - I am converting it into a sorted array through ignorer traversal  and then finding the value smaller, and larger.\\n ```/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<Integer> inorder = inorder(root);\\n        List<List<Integer>> result = new ArrayList<>(queries.size());\\n        for(int query: queries) {\\n            result.add(findSmallestOrLargest(inorder, query));\\n        }\\n        return result;\\n    }\\n\\n    private List<Integer> findSmallestOrLargest(List<Integer> inorder, int query) {\\n        int start = 0, end = inorder.size()-1;\\n        int smallest = -1, largest = -1;\\n        while(start<=end) {\\n            int mid = (start+end)/2;\\n            if(inorder.get(mid)<query) {\\n                smallest = inorder.get(mid);\\n                start = mid+1;\\n            } else if(inorder.get(mid)>query) {\\n                end = mid-1;\\n                largest = inorder.get(mid);\\n            } else {\\n                return Arrays.asList(query, query);\\n            }\\n        }\\n        return Arrays.asList(smallest, largest);\\n    }\\n\\n    private List<Integer> inorder(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        if(root.left != null) {\\n            result.addAll(inorder(root.left));\\n        }\\n        result.add(root.val);\\n        if(root.right != null) {\\n            result.addAll(inorder(root.right));\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "alpha211",
                        "content": "Can I traverse the tree and put node value into a list and then run binary search?"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "DEFINITELY"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "If you are wondering why the search on Tree directly with recursive DFS is giving you TLE , it is because testcases have the worst case which go to the depth of like 10^5 so that would make 10^5 call stack too."
                    },
                    {
                        "username": "skyhuangxy",
                        "content": "My dfs Solution for this problem. The Time Complexity should be O(k*logn), but it gives TLE\\n\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> res; = new ArrayList<>();\\n        for (int target : queries) { \\n            List<Integer> path = new ArrayList<>();\\n            int smallOrequal = dfssmall(root, target);\\n            int largeOrequal = dfslarge(root, target);\\n            path.add(smallOrequal);\\n            path.add(largeOrequal);\\n            res.add(path);\\n        }\\n        return res;\\n    }\\n    private int dfssmall(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val > target) {\\n            return dfssmall(node.left, target);\\n        }\\n        int next = dfssmall(node.right, target);\\n        return next == -1 ? node.val : next;\\n    }\\n    private int dfslarge(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val < target) {\\n            return dfslarge(node.right, target);\\n        }\\n\\n        int next = dfslarge(node.left, target);\\n        return next == -1 ? node.val : next;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1748491,
                "content": [
                    {
                        "username": "dudulichen11",
                        "content": "can anyone help me understand why this preprocessing step results in TLE. This is pretty similar to other accepted answers. Don't really understand since in any case this is O(N) step, which is less compared to the total TC: O(NlogN)...\n``\ndef tree_to_list(root):\n\n            if not root:\n\n                return []\n\n            return tree_to_list(root.left) + [root.val] + tree_to_list(root.right)\narr = tree_to_list(root)\n\n\n``\n"
                    },
                    {
                        "username": "dudulichen11",
                        "content": "[@miraj2399](/miraj2399) Oh, yes. That totally makes sense now. I spent 40 mins on this issue during the contest. Really appreciate your explanation!"
                    },
                    {
                        "username": "yzhao156",
                        "content": "```\nlst = []\ndef dfs(root):\n            if not root:\n                return \n            dfs(root.left)\n            lst.append(root.val)\n            dfs(root.right)\ndfs(root)\nprint(root)\n\n```"
                    },
                    {
                        "username": "miraj2399",
                        "content": "I had the same issue. My code was even shorter(Pythonic) lol!\n```\ndef dfs(root):\n     return dfs(root.left)+[root.val]+dfs(root.right) if root!=None else []\n\n```\nBut from a quick google search, it is apparent that, append function take amortized O(1) time where adding two list with size m and n takes O(m+n) time.\nSo, for this problem appending would make the complexity O(N) where adding list will make it O(N**2)"
                    },
                    {
                        "username": "david6p2",
                        "content": "really silly that you have to balance the tree for this to work"
                    },
                    {
                        "username": "okwxmsz",
                        "content": "Tip: BST could be not balanced"
                    },
                    {
                        "username": "Mirror0227",
                        "content": "Thought for TLE: the input binary tree is not balanced. In some extremely unbalanced case it will become O(n) search (n: total node in the tree).\\n2 way to aviod TLE:\\n- balance it\\n- convert it to array and use binary search on array."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Again,I got accepted with relatively fine runtime in C++ but TLE in Python3.OJ should be consistent between languages.Please fix it"
                    },
                    {
                        "username": "m1nsk",
                        "content": "Correct me if im wrong, but i think that i found O(N) solution in worst case for unbalanced tree.\n\nNo need to traverse the tree and put values to array to do a binary search, no need for TreeSet structure.\n\nhttps://leetcode.com/problems/closest-nodes-queries-in-a-binary-search-tree/solutions/3042770/onlog-k-time-ok-constant-space-no-need-for-additional-n-size-array-and-full-tree-traversal/"
                    },
                    {
                        "username": "harshit_bangar",
                        "content": "My solution is timing out - I am converting it into a sorted array through ignorer traversal  and then finding the value smaller, and larger.\\n ```/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<Integer> inorder = inorder(root);\\n        List<List<Integer>> result = new ArrayList<>(queries.size());\\n        for(int query: queries) {\\n            result.add(findSmallestOrLargest(inorder, query));\\n        }\\n        return result;\\n    }\\n\\n    private List<Integer> findSmallestOrLargest(List<Integer> inorder, int query) {\\n        int start = 0, end = inorder.size()-1;\\n        int smallest = -1, largest = -1;\\n        while(start<=end) {\\n            int mid = (start+end)/2;\\n            if(inorder.get(mid)<query) {\\n                smallest = inorder.get(mid);\\n                start = mid+1;\\n            } else if(inorder.get(mid)>query) {\\n                end = mid-1;\\n                largest = inorder.get(mid);\\n            } else {\\n                return Arrays.asList(query, query);\\n            }\\n        }\\n        return Arrays.asList(smallest, largest);\\n    }\\n\\n    private List<Integer> inorder(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        if(root.left != null) {\\n            result.addAll(inorder(root.left));\\n        }\\n        result.add(root.val);\\n        if(root.right != null) {\\n            result.addAll(inorder(root.right));\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "alpha211",
                        "content": "Can I traverse the tree and put node value into a list and then run binary search?"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "DEFINITELY"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "If you are wondering why the search on Tree directly with recursive DFS is giving you TLE , it is because testcases have the worst case which go to the depth of like 10^5 so that would make 10^5 call stack too."
                    },
                    {
                        "username": "skyhuangxy",
                        "content": "My dfs Solution for this problem. The Time Complexity should be O(k*logn), but it gives TLE\\n\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> res; = new ArrayList<>();\\n        for (int target : queries) { \\n            List<Integer> path = new ArrayList<>();\\n            int smallOrequal = dfssmall(root, target);\\n            int largeOrequal = dfslarge(root, target);\\n            path.add(smallOrequal);\\n            path.add(largeOrequal);\\n            res.add(path);\\n        }\\n        return res;\\n    }\\n    private int dfssmall(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val > target) {\\n            return dfssmall(node.left, target);\\n        }\\n        int next = dfssmall(node.right, target);\\n        return next == -1 ? node.val : next;\\n    }\\n    private int dfslarge(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val < target) {\\n            return dfslarge(node.right, target);\\n        }\\n\\n        int next = dfslarge(node.left, target);\\n        return next == -1 ? node.val : next;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1733386,
                "content": [
                    {
                        "username": "dudulichen11",
                        "content": "can anyone help me understand why this preprocessing step results in TLE. This is pretty similar to other accepted answers. Don't really understand since in any case this is O(N) step, which is less compared to the total TC: O(NlogN)...\n``\ndef tree_to_list(root):\n\n            if not root:\n\n                return []\n\n            return tree_to_list(root.left) + [root.val] + tree_to_list(root.right)\narr = tree_to_list(root)\n\n\n``\n"
                    },
                    {
                        "username": "dudulichen11",
                        "content": "[@miraj2399](/miraj2399) Oh, yes. That totally makes sense now. I spent 40 mins on this issue during the contest. Really appreciate your explanation!"
                    },
                    {
                        "username": "yzhao156",
                        "content": "```\nlst = []\ndef dfs(root):\n            if not root:\n                return \n            dfs(root.left)\n            lst.append(root.val)\n            dfs(root.right)\ndfs(root)\nprint(root)\n\n```"
                    },
                    {
                        "username": "miraj2399",
                        "content": "I had the same issue. My code was even shorter(Pythonic) lol!\n```\ndef dfs(root):\n     return dfs(root.left)+[root.val]+dfs(root.right) if root!=None else []\n\n```\nBut from a quick google search, it is apparent that, append function take amortized O(1) time where adding two list with size m and n takes O(m+n) time.\nSo, for this problem appending would make the complexity O(N) where adding list will make it O(N**2)"
                    },
                    {
                        "username": "david6p2",
                        "content": "really silly that you have to balance the tree for this to work"
                    },
                    {
                        "username": "okwxmsz",
                        "content": "Tip: BST could be not balanced"
                    },
                    {
                        "username": "Mirror0227",
                        "content": "Thought for TLE: the input binary tree is not balanced. In some extremely unbalanced case it will become O(n) search (n: total node in the tree).\\n2 way to aviod TLE:\\n- balance it\\n- convert it to array and use binary search on array."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Again,I got accepted with relatively fine runtime in C++ but TLE in Python3.OJ should be consistent between languages.Please fix it"
                    },
                    {
                        "username": "m1nsk",
                        "content": "Correct me if im wrong, but i think that i found O(N) solution in worst case for unbalanced tree.\n\nNo need to traverse the tree and put values to array to do a binary search, no need for TreeSet structure.\n\nhttps://leetcode.com/problems/closest-nodes-queries-in-a-binary-search-tree/solutions/3042770/onlog-k-time-ok-constant-space-no-need-for-additional-n-size-array-and-full-tree-traversal/"
                    },
                    {
                        "username": "harshit_bangar",
                        "content": "My solution is timing out - I am converting it into a sorted array through ignorer traversal  and then finding the value smaller, and larger.\\n ```/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<Integer> inorder = inorder(root);\\n        List<List<Integer>> result = new ArrayList<>(queries.size());\\n        for(int query: queries) {\\n            result.add(findSmallestOrLargest(inorder, query));\\n        }\\n        return result;\\n    }\\n\\n    private List<Integer> findSmallestOrLargest(List<Integer> inorder, int query) {\\n        int start = 0, end = inorder.size()-1;\\n        int smallest = -1, largest = -1;\\n        while(start<=end) {\\n            int mid = (start+end)/2;\\n            if(inorder.get(mid)<query) {\\n                smallest = inorder.get(mid);\\n                start = mid+1;\\n            } else if(inorder.get(mid)>query) {\\n                end = mid-1;\\n                largest = inorder.get(mid);\\n            } else {\\n                return Arrays.asList(query, query);\\n            }\\n        }\\n        return Arrays.asList(smallest, largest);\\n    }\\n\\n    private List<Integer> inorder(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        if(root.left != null) {\\n            result.addAll(inorder(root.left));\\n        }\\n        result.add(root.val);\\n        if(root.right != null) {\\n            result.addAll(inorder(root.right));\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "alpha211",
                        "content": "Can I traverse the tree and put node value into a list and then run binary search?"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "DEFINITELY"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "If you are wondering why the search on Tree directly with recursive DFS is giving you TLE , it is because testcases have the worst case which go to the depth of like 10^5 so that would make 10^5 call stack too."
                    },
                    {
                        "username": "skyhuangxy",
                        "content": "My dfs Solution for this problem. The Time Complexity should be O(k*logn), but it gives TLE\\n\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> res; = new ArrayList<>();\\n        for (int target : queries) { \\n            List<Integer> path = new ArrayList<>();\\n            int smallOrequal = dfssmall(root, target);\\n            int largeOrequal = dfslarge(root, target);\\n            path.add(smallOrequal);\\n            path.add(largeOrequal);\\n            res.add(path);\\n        }\\n        return res;\\n    }\\n    private int dfssmall(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val > target) {\\n            return dfssmall(node.left, target);\\n        }\\n        int next = dfssmall(node.right, target);\\n        return next == -1 ? node.val : next;\\n    }\\n    private int dfslarge(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val < target) {\\n            return dfslarge(node.right, target);\\n        }\\n\\n        int next = dfslarge(node.left, target);\\n        return next == -1 ? node.val : next;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1690367,
                "content": [
                    {
                        "username": "dudulichen11",
                        "content": "can anyone help me understand why this preprocessing step results in TLE. This is pretty similar to other accepted answers. Don't really understand since in any case this is O(N) step, which is less compared to the total TC: O(NlogN)...\n``\ndef tree_to_list(root):\n\n            if not root:\n\n                return []\n\n            return tree_to_list(root.left) + [root.val] + tree_to_list(root.right)\narr = tree_to_list(root)\n\n\n``\n"
                    },
                    {
                        "username": "dudulichen11",
                        "content": "[@miraj2399](/miraj2399) Oh, yes. That totally makes sense now. I spent 40 mins on this issue during the contest. Really appreciate your explanation!"
                    },
                    {
                        "username": "yzhao156",
                        "content": "```\nlst = []\ndef dfs(root):\n            if not root:\n                return \n            dfs(root.left)\n            lst.append(root.val)\n            dfs(root.right)\ndfs(root)\nprint(root)\n\n```"
                    },
                    {
                        "username": "miraj2399",
                        "content": "I had the same issue. My code was even shorter(Pythonic) lol!\n```\ndef dfs(root):\n     return dfs(root.left)+[root.val]+dfs(root.right) if root!=None else []\n\n```\nBut from a quick google search, it is apparent that, append function take amortized O(1) time where adding two list with size m and n takes O(m+n) time.\nSo, for this problem appending would make the complexity O(N) where adding list will make it O(N**2)"
                    },
                    {
                        "username": "david6p2",
                        "content": "really silly that you have to balance the tree for this to work"
                    },
                    {
                        "username": "okwxmsz",
                        "content": "Tip: BST could be not balanced"
                    },
                    {
                        "username": "Mirror0227",
                        "content": "Thought for TLE: the input binary tree is not balanced. In some extremely unbalanced case it will become O(n) search (n: total node in the tree).\\n2 way to aviod TLE:\\n- balance it\\n- convert it to array and use binary search on array."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Again,I got accepted with relatively fine runtime in C++ but TLE in Python3.OJ should be consistent between languages.Please fix it"
                    },
                    {
                        "username": "m1nsk",
                        "content": "Correct me if im wrong, but i think that i found O(N) solution in worst case for unbalanced tree.\n\nNo need to traverse the tree and put values to array to do a binary search, no need for TreeSet structure.\n\nhttps://leetcode.com/problems/closest-nodes-queries-in-a-binary-search-tree/solutions/3042770/onlog-k-time-ok-constant-space-no-need-for-additional-n-size-array-and-full-tree-traversal/"
                    },
                    {
                        "username": "harshit_bangar",
                        "content": "My solution is timing out - I am converting it into a sorted array through ignorer traversal  and then finding the value smaller, and larger.\\n ```/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<Integer> inorder = inorder(root);\\n        List<List<Integer>> result = new ArrayList<>(queries.size());\\n        for(int query: queries) {\\n            result.add(findSmallestOrLargest(inorder, query));\\n        }\\n        return result;\\n    }\\n\\n    private List<Integer> findSmallestOrLargest(List<Integer> inorder, int query) {\\n        int start = 0, end = inorder.size()-1;\\n        int smallest = -1, largest = -1;\\n        while(start<=end) {\\n            int mid = (start+end)/2;\\n            if(inorder.get(mid)<query) {\\n                smallest = inorder.get(mid);\\n                start = mid+1;\\n            } else if(inorder.get(mid)>query) {\\n                end = mid-1;\\n                largest = inorder.get(mid);\\n            } else {\\n                return Arrays.asList(query, query);\\n            }\\n        }\\n        return Arrays.asList(smallest, largest);\\n    }\\n\\n    private List<Integer> inorder(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        if(root.left != null) {\\n            result.addAll(inorder(root.left));\\n        }\\n        result.add(root.val);\\n        if(root.right != null) {\\n            result.addAll(inorder(root.right));\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "alpha211",
                        "content": "Can I traverse the tree and put node value into a list and then run binary search?"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "DEFINITELY"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "If you are wondering why the search on Tree directly with recursive DFS is giving you TLE , it is because testcases have the worst case which go to the depth of like 10^5 so that would make 10^5 call stack too."
                    },
                    {
                        "username": "skyhuangxy",
                        "content": "My dfs Solution for this problem. The Time Complexity should be O(k*logn), but it gives TLE\\n\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> res; = new ArrayList<>();\\n        for (int target : queries) { \\n            List<Integer> path = new ArrayList<>();\\n            int smallOrequal = dfssmall(root, target);\\n            int largeOrequal = dfslarge(root, target);\\n            path.add(smallOrequal);\\n            path.add(largeOrequal);\\n            res.add(path);\\n        }\\n        return res;\\n    }\\n    private int dfssmall(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val > target) {\\n            return dfssmall(node.left, target);\\n        }\\n        int next = dfssmall(node.right, target);\\n        return next == -1 ? node.val : next;\\n    }\\n    private int dfslarge(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val < target) {\\n            return dfslarge(node.right, target);\\n        }\\n\\n        int next = dfslarge(node.left, target);\\n        return next == -1 ? node.val : next;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1690281,
                "content": [
                    {
                        "username": "dudulichen11",
                        "content": "can anyone help me understand why this preprocessing step results in TLE. This is pretty similar to other accepted answers. Don't really understand since in any case this is O(N) step, which is less compared to the total TC: O(NlogN)...\n``\ndef tree_to_list(root):\n\n            if not root:\n\n                return []\n\n            return tree_to_list(root.left) + [root.val] + tree_to_list(root.right)\narr = tree_to_list(root)\n\n\n``\n"
                    },
                    {
                        "username": "dudulichen11",
                        "content": "[@miraj2399](/miraj2399) Oh, yes. That totally makes sense now. I spent 40 mins on this issue during the contest. Really appreciate your explanation!"
                    },
                    {
                        "username": "yzhao156",
                        "content": "```\nlst = []\ndef dfs(root):\n            if not root:\n                return \n            dfs(root.left)\n            lst.append(root.val)\n            dfs(root.right)\ndfs(root)\nprint(root)\n\n```"
                    },
                    {
                        "username": "miraj2399",
                        "content": "I had the same issue. My code was even shorter(Pythonic) lol!\n```\ndef dfs(root):\n     return dfs(root.left)+[root.val]+dfs(root.right) if root!=None else []\n\n```\nBut from a quick google search, it is apparent that, append function take amortized O(1) time where adding two list with size m and n takes O(m+n) time.\nSo, for this problem appending would make the complexity O(N) where adding list will make it O(N**2)"
                    },
                    {
                        "username": "david6p2",
                        "content": "really silly that you have to balance the tree for this to work"
                    },
                    {
                        "username": "okwxmsz",
                        "content": "Tip: BST could be not balanced"
                    },
                    {
                        "username": "Mirror0227",
                        "content": "Thought for TLE: the input binary tree is not balanced. In some extremely unbalanced case it will become O(n) search (n: total node in the tree).\\n2 way to aviod TLE:\\n- balance it\\n- convert it to array and use binary search on array."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Again,I got accepted with relatively fine runtime in C++ but TLE in Python3.OJ should be consistent between languages.Please fix it"
                    },
                    {
                        "username": "m1nsk",
                        "content": "Correct me if im wrong, but i think that i found O(N) solution in worst case for unbalanced tree.\n\nNo need to traverse the tree and put values to array to do a binary search, no need for TreeSet structure.\n\nhttps://leetcode.com/problems/closest-nodes-queries-in-a-binary-search-tree/solutions/3042770/onlog-k-time-ok-constant-space-no-need-for-additional-n-size-array-and-full-tree-traversal/"
                    },
                    {
                        "username": "harshit_bangar",
                        "content": "My solution is timing out - I am converting it into a sorted array through ignorer traversal  and then finding the value smaller, and larger.\\n ```/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<Integer> inorder = inorder(root);\\n        List<List<Integer>> result = new ArrayList<>(queries.size());\\n        for(int query: queries) {\\n            result.add(findSmallestOrLargest(inorder, query));\\n        }\\n        return result;\\n    }\\n\\n    private List<Integer> findSmallestOrLargest(List<Integer> inorder, int query) {\\n        int start = 0, end = inorder.size()-1;\\n        int smallest = -1, largest = -1;\\n        while(start<=end) {\\n            int mid = (start+end)/2;\\n            if(inorder.get(mid)<query) {\\n                smallest = inorder.get(mid);\\n                start = mid+1;\\n            } else if(inorder.get(mid)>query) {\\n                end = mid-1;\\n                largest = inorder.get(mid);\\n            } else {\\n                return Arrays.asList(query, query);\\n            }\\n        }\\n        return Arrays.asList(smallest, largest);\\n    }\\n\\n    private List<Integer> inorder(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        if(root.left != null) {\\n            result.addAll(inorder(root.left));\\n        }\\n        result.add(root.val);\\n        if(root.right != null) {\\n            result.addAll(inorder(root.right));\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "alpha211",
                        "content": "Can I traverse the tree and put node value into a list and then run binary search?"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "DEFINITELY"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "If you are wondering why the search on Tree directly with recursive DFS is giving you TLE , it is because testcases have the worst case which go to the depth of like 10^5 so that would make 10^5 call stack too."
                    },
                    {
                        "username": "skyhuangxy",
                        "content": "My dfs Solution for this problem. The Time Complexity should be O(k*logn), but it gives TLE\\n\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> res; = new ArrayList<>();\\n        for (int target : queries) { \\n            List<Integer> path = new ArrayList<>();\\n            int smallOrequal = dfssmall(root, target);\\n            int largeOrequal = dfslarge(root, target);\\n            path.add(smallOrequal);\\n            path.add(largeOrequal);\\n            res.add(path);\\n        }\\n        return res;\\n    }\\n    private int dfssmall(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val > target) {\\n            return dfssmall(node.left, target);\\n        }\\n        int next = dfssmall(node.right, target);\\n        return next == -1 ? node.val : next;\\n    }\\n    private int dfslarge(TreeNode node, int target) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.val == target) {\\n            return target;\\n        }\\n        if (node.val < target) {\\n            return dfslarge(node.right, target);\\n        }\\n\\n        int next = dfslarge(node.left, target);\\n        return next == -1 ? node.val : next;\\n    }\\n}"
                    }
                ]
            }
        ]
    }
]