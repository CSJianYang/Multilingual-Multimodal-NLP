[
    {
        "title": "Last Person to Fit in the Bus",
        "question_content": "Table: Queue\n\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| person_id   | int     |\n| person_name | varchar |\n| weight      | int     |\n| turn        | int     |\n+-------------+---------+\nperson_id column contains unique values.\nThis table has the information about all people waiting for a bus.\nThe person_id and turn columns will contain all numbers from 1 to n, where n is the number of rows in the table.\nturn determines the order of which the people will board the bus, where turn=1 denotes the first person to board and turn=n denotes the last person to board.\nweight is the weight of the person in kilograms.\n\n&nbsp;\nThere is a queue of people waiting to board a bus. However, the bus has a weight limit of 1000 kilograms, so there may be some people who cannot board.\nWrite a solution to find the person_name of the last person that can fit on the bus without exceeding the weight limit. The test cases are generated such that the first person does not exceed the weight limit.\nThe&nbsp;result format is in the following example.\n&nbsp;\nExample 1:\n\nInput: \nQueue table:\n+-----------+-------------+--------+------+\n| person_id | person_name | weight | turn |\n+-----------+-------------+--------+------+\n| 5         | Alice       | 250    | 1    |\n| 4         | Bob         | 175    | 5    |\n| 3         | Alex        | 350    | 2    |\n| 6         | John Cena   | 400    | 3    |\n| 1         | Winston     | 500    | 6    |\n| 2         | Marie       | 200    | 4    |\n+-----------+-------------+--------+------+\nOutput: \n+-------------+\n| person_name |\n+-------------+\n| John Cena   |\n+-------------+\nExplanation: The folowing table is ordered by the turn for simplicity.\n+------+----+-----------+--------+--------------+\n| Turn | ID | Name      | Weight | Total Weight |\n+------+----+-----------+--------+--------------+\n| 1    | 5  | Alice     | 250    | 250          |\n| 2    | 3  | Alex      | 350    | 600          |\n| 3    | 6  | John Cena | 400    | 1000         | (last person to board)\n| 4    | 2  | Marie     | 200    | 1200         | (cannot board)\n| 5    | 4  | Bob       | 175    | ___          |\n| 6    | 1  | Winston   | 500    | ___          |\n+------+----+-----------+--------+--------------+",
        "solutions": [
            {
                "id": 3634727,
                "title": "best-optimum-solution-with-explanation-using-joins",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\nThe goal is to find the last person who can fit on the bus without exceeding the weight limit. We need to consider the order of people based on their turn and calculate the cumulative weight at each turn to check if it exceeds the weight limit.\\n\\n# Approach\\n1. We join the Queue table with itself, creating combinations of rows where each row is paired with all rows that have a higher or equal turn value.\\n1. We group the rows by turn and calculate the sum of weights for each group.\\n1. Using the HAVING clause, we filter out groups whose sum of weights exceeds the weight limit of 1000.\\n1. We order the results by the sum of weights in descending order, ensuring the last person who can fit is at the top.\\n1. Finally, we limit the result to 1 row since we only need the information of the last person.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this query is dependent on the number of rows in the Queue table. Let\\'s denote this number as \\'n\\'. The join operation has a complexity of $$O(n^2)$$, as it pairs each row with all the rows that have a higher turn. The grouping operation has a complexity of O(n), as it groups the rows by turn. Finally, ordering the result and limiting it to 1 row have a complexity of O(nlogn). Therefore, the overall time complexity is $$O(n^2)$$.\\n\\n- Space complexity:\\nThe space complexity is determined by the memory required to store the rows and the intermediate results of the query. In this case, it is proportional to the number of rows in the Queue table, so the space complexity is $$O(n)$$.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT \\n    q1.person_name\\nFROM Queue q1 JOIN Queue q2 ON q1.turn >= q2.turn\\nGROUP BY q1.turn\\nHAVING SUM(q2.weight) <= 1000\\nORDER BY SUM(q2.weight) DESC\\nLIMIT 1\\n```\\n***Please Upvote my solution, if you find it helpful ;)***\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/f5b76a08-660e-4f26-adab-ecf38d2833c6_1686684410.6196277.jpeg)\\n\\n",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT \\n    q1.person_name\\nFROM Queue q1 JOIN Queue q2 ON q1.turn >= q2.turn\\nGROUP BY q1.turn\\nHAVING SUM(q2.weight) <= 1000\\nORDER BY SUM(q2.weight) DESC\\nLIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 389961,
                "title": "mysql-beat-100-lol-of-course-since-i-m-the-first-one-to-do-this-problem",
                "content": "The steps:\\n(1) Get cumulative sum weight using ```Join``` with condition ```q1.turn >= q2.turn``` and ```Group By q1.turn```  \\n(2) Filter the groups with  cum sum ```<=1000``` \\n(3) Order by cum sum with ```Desc``` order, select the 1st.\\n```\\nSELECT q1.person_name\\nFROM Queue q1 JOIN Queue q2 ON q1.turn >= q2.turn\\nGROUP BY q1.turn\\nHAVING SUM(q2.weight) <= 1000\\nORDER BY SUM(q2.weight) DESC\\nLIMIT 1\\n```",
                "solutionTags": [],
                "code": "```Join```\n```q1.turn >= q2.turn```\n```Group By q1.turn```\n```<=1000```\n```Desc```\n```\\nSELECT q1.person_name\\nFROM Queue q1 JOIN Queue q2 ON q1.turn >= q2.turn\\nGROUP BY q1.turn\\nHAVING SUM(q2.weight) <= 1000\\nORDER BY SUM(q2.weight) DESC\\nLIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 642795,
                "title": "mysql-beat-95-fast-solution-using-window-function",
                "content": "Calculate cumulative sum and order by descending and take first row which is last person in the lift!!\\n\\n```\\nselect person_name from\\n(select person_name, weight, turn, sum(weight) over(order by turn) as cum_sum\\nfrom queue) x\\nwhere cum_sum <= 1000\\norder by turn desc limit 1;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Sliding Window"
                ],
                "code": "```\\nselect person_name from\\n(select person_name, weight, turn, sum(weight) over(order by turn) as cum_sum\\nfrom queue) x\\nwhere cum_sum <= 1000\\norder by turn desc limit 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 432453,
                "title": "ms-sql-solution-based-on-windows-function",
                "content": "select top 1 sub.person_name\\nfrom \\n(select person_name,\\n       SUM(weight) OVER (ORDER BY turn ASC) AS running_total\\nfrom Queue) sub\\nwhere sub.running_total <= 1000\\norder by sub.running_total DESC",
                "solutionTags": [],
                "code": "select top 1 sub.person_name\\nfrom \\n(select person_name,\\n       SUM(weight) OVER (ORDER BY turn ASC) AS running_total\\nfrom Queue) sub\\nwhere sub.running_total <= 1000\\norder by sub.running_total DESC",
                "codeTag": "Unknown"
            },
            {
                "id": 3745761,
                "title": "beat-96-6-mysql-window-sum-solution",
                "content": "# Intuition\\nas described \"Find the maximum number of turns among rows where \\'tot_weight <= 1000\\' \"\\n\\n# Approach\\n### (1) make running sum\\n### (2) find maximum turn where running sum <= 1000\\n\\n# Complexity\\n- Time complexity:\\nO(n), because I did sorting by window function\\n\\n- Space complexity:\\nalso O(n), because of soring that require save intermediate result some where else.(hopfuly in the memory not disk)\\n\\n# Code\\n```\\n# Find the maximum number of turns among rows where \\'tot_weight <= 1000\\'.\\n\\nWITH CTE AS (\\n    SELECT \\n        turn, person_name, weight,\\n        SUM(weight) OVER(ORDER BY turn ASC) AS tot_weight \\n    FROM Queue\\n    ORDER BY turn\\n)\\nSELECT person_name\\nFROM Queue q\\nWHERE q.turn = (SELECT MAX(turn) FROM CTE WHERE tot_weight <= 1000);\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Find the maximum number of turns among rows where \\'tot_weight <= 1000\\'.\\n\\nWITH CTE AS (\\n    SELECT \\n        turn, person_name, weight,\\n        SUM(weight) OVER(ORDER BY turn ASC) AS tot_weight \\n    FROM Queue\\n    ORDER BY turn\\n)\\nSELECT person_name\\nFROM Queue q\\nWHERE q.turn = (SELECT MAX(turn) FROM CTE WHERE tot_weight <= 1000);\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 390243,
                "title": "simple-mysql-solution-beat-100",
                "content": "```\\n# Write your MySQL query statement below\\nSELECT person_name FROM Queue as a\\nWHERE\\n(\\n    SELECT SUM(weight) FROM Queue as b\\n    WHERE b.turn<=a.turn\\n    ORDER By turn\\n)<=1000\\nORDER BY a.turn DESC limit 1;\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT person_name FROM Queue as a\\nWHERE\\n(\\n    SELECT SUM(weight) FROM Queue as b\\n    WHERE b.turn<=a.turn\\n    ORDER By turn\\n)<=1000\\nORDER BY a.turn DESC limit 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 895368,
                "title": "mysql-simple-sum-over",
                "content": "```\\nselect person_name from\\n(select person_name, sum(weight) over(order by turn) as gross_weight from queue) a\\nwhere gross_weight <= 1000\\norder by gross_weight desc limit 1\\n```",
                "solutionTags": [],
                "code": "```\\nselect person_name from\\n(select person_name, sum(weight) over(order by turn) as gross_weight from queue) a\\nwhere gross_weight <= 1000\\norder by gross_weight desc limit 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3883280,
                "title": "no-window-no-limit-only-group-by",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- I want to get sum of all the weights till the ith approach\\n- I can get this by matching row of t turn with all the rows having turn <= t using the following query:\\n    ```sql\\n    SELECT q1.turn, SUM(q2.weight) as weight\\n    FROM Queue q1 JOIN Queue q2\\n    ON q1.turn >= q2.turn -- choose all turn smaller than q1.turn\\n    GROUP BY q1.turn -- to take the sum till smaller turn\\n    ORDER BY q1.turn; -- order by is for better visibility\\n    ```\\n- Now I want to know who is the last person to enter the bus\\n- It would be the person with MAX(weight) <= 1000\\n- So we will only pick the rows with sum <= 1000\\n    ```sql\\n    SELECT q1.turn, SUM(q2.weight) as weight\\n    FROM Queue q1 JOIN Queue q2\\n    ON q1.turn >= q2.turn\\n    GROUP BY q1.turn\\n    HAVING SUM(q2.weight) <= 1000 -- only pick turn having sum <= 1000\\n    ORDER BY q1.turn; -- order by is for better visibility\\n    ```\\n- Now this query gives us the turn with SUM(weight) <= 1000 but we are only concern with the last person so we can find his turn by taking MAX(turn)\\n    ```sql\\n    SELECT MAX(turn) -- selecting the max turn \\n    FROM (\\n        SELECT q1.turn as turn\\n        FROM Queue q1 JOIN Queue q2\\n        ON q1.turn >= q2.turn\\n        GROUP BY q1.turn\\n        HAVING SUM(q2.weight) <= 1000 -- only pick turn having sum <= 1000\\n        ORDER BY q1.turn -- order by is for better visibility\\n    ) as temp;    \\n    ```\\n- Now in the last step we will get the person who has this MAX(turn) which we can simply by matching it will all turns\\n    ```sql\\n    SELECT person_name FROM Queue\\n    WHERE turn = (\\n        SELECT MAX(turn) as turn FROM\\n        (\\n            SELECT q1.turn\\n            FROM Queue q1 JOIN QUEUE q2 \\n            ON q1.turn >= q2.turn\\n            GROUP BY q1.turn\\n            HAVING SUM(q2.weight) <= 1000\\n        ) as table1\\n    );\\n    ```\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT person_name FROM Queue\\nWHERE turn = (\\n    SELECT MAX(turn) as turn FROM\\n    (\\n        SELECT q1.turn\\n        FROM Queue q1 JOIN QUEUE q2 \\n        ON q1.turn >= q2.turn\\n        GROUP BY q1.turn\\n        HAVING SUM(q2.weight) <= 1000\\n    ) as table1\\n);\\n```\\n\\n## HOPE IT HELPED :)",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```sql\\n    SELECT q1.turn, SUM(q2.weight) as weight\\n    FROM Queue q1 JOIN Queue q2\\n    ON q1.turn >= q2.turn -- choose all turn smaller than q1.turn\\n    GROUP BY q1.turn -- to take the sum till smaller turn\\n    ORDER BY q1.turn; -- order by is for better visibility\\n    ```\n```sql\\n    SELECT q1.turn, SUM(q2.weight) as weight\\n    FROM Queue q1 JOIN Queue q2\\n    ON q1.turn >= q2.turn\\n    GROUP BY q1.turn\\n    HAVING SUM(q2.weight) <= 1000 -- only pick turn having sum <= 1000\\n    ORDER BY q1.turn; -- order by is for better visibility\\n    ```\n```sql\\n    SELECT MAX(turn) -- selecting the max turn \\n    FROM (\\n        SELECT q1.turn as turn\\n        FROM Queue q1 JOIN Queue q2\\n        ON q1.turn >= q2.turn\\n        GROUP BY q1.turn\\n        HAVING SUM(q2.weight) <= 1000 -- only pick turn having sum <= 1000\\n        ORDER BY q1.turn -- order by is for better visibility\\n    ) as temp;    \\n    ```\n```sql\\n    SELECT person_name FROM Queue\\n    WHERE turn = (\\n        SELECT MAX(turn) as turn FROM\\n        (\\n            SELECT q1.turn\\n            FROM Queue q1 JOIN QUEUE q2 \\n            ON q1.turn >= q2.turn\\n            GROUP BY q1.turn\\n            HAVING SUM(q2.weight) <= 1000\\n        ) as table1\\n    );\\n    ```\n```\\n# Write your MySQL query statement below\\nSELECT person_name FROM Queue\\nWHERE turn = (\\n    SELECT MAX(turn) as turn FROM\\n    (\\n        SELECT q1.turn\\n        FROM Queue q1 JOIN QUEUE q2 \\n        ON q1.turn >= q2.turn\\n        GROUP BY q1.turn\\n        HAVING SUM(q2.weight) <= 1000\\n    ) as table1\\n);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3549051,
                "title": "2-mysql-solutions-compared-and-explained",
                "content": "# Option 1: Derived table, windown function\\n```\\nselect\\n    person_name\\nfrom    \\n    (\\n        select\\n            *\\n            , sum(weight) over (order by Turn) as total_sum\\n        from queue\\n    ) t -- every derived table must have its own alias\\nwhere total_sum <= 1000\\norder by turn desc\\nlimit 1\\n```\\n\\n- Performance: This option uses a derived table and a window function to calculate the cumulative sum of weights. It then checks if the sum is less than or equal to 1000 and filters the results accordingly. The performance of this option depends on the size of the \"queue\" table and the efficiency of the window function. It\\'s important to have appropriate indexes on the relevant columns to optimize the ordering and window function calculations. Overall, this option can be efficient if the window function is optimized and the size of the \"queue\" table is manageable.\\n- Readability: This option uses a derived table and a window function to express the logic. The derived table provides a clear separation of the steps: calculating the cumulative sum of weights and checking if it\\'s within the desired range. The window function usage is explicit and can be easily understood by developers familiar with window functions.\\n\\n# Option 2: subquery, variable\\n```\\nselect person_name \\nfrom \\n    (\\n        select \\n            person_name, \\n            @total_weight := @total_weight + weight as total_weight \\n        from \\n            Queue,\\n            (select @total_weight := 0) as tmp order by turn\\n            \\n    ) as t -- every derived table must have its own alias\\nwhere total_weight <= 1000 \\norder by total_weight desc limit 1\\n```\\n- Performance: This option uses a subquery and a variable to calculate the cumulative sum of weights. The performance can depend on the size of the \"queue\" table and the efficiency of the subquery and variable assignment. It\\'s important to have appropriate indexes on the relevant columns to optimize the ordering. This option can be efficient if the subquery and variable assignment are optimized and the size of the \"queue\" table is manageable.\\n- Readability: This option uses a subquery and variable assignment to express the logic. The subquery provides a clear separation of the steps: calculating the cumulative sum of weights. However, the usage of variables can make the query slightly more complex to read and understand compared to the previous option.\\n\\n# Summary\\n\\nIn terms of performance, both options can be efficient if they are properly optimized and have appropriate indexes on the relevant columns. The performance can vary depending on the size of the \"queue\" table and the efficiency of the window function, subquery, and variable assignment.\\n\\nIn terms of readability, Option 1 (Derived Table, Window Function) provides a clear and concise expression of the logic using a derived table and window function. The steps are explicit and can be easily understood. Option 2 (Subquery, Variable) is slightly more complex due to the usage of variables, which may require extra effort to understand.\\n\\nConsidering both performance and readability, Option 1 (Derived Table, Window Function) is recommended. It provides a good balance between performance and readability, making it easier to maintain and understand by other developers.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect\\n    person_name\\nfrom    \\n    (\\n        select\\n            *\\n            , sum(weight) over (order by Turn) as total_sum\\n        from queue\\n    ) t -- every derived table must have its own alias\\nwhere total_sum <= 1000\\norder by turn desc\\nlimit 1\\n```\n```\\nselect person_name \\nfrom \\n    (\\n        select \\n            person_name, \\n            @total_weight := @total_weight + weight as total_weight \\n        from \\n            Queue,\\n            (select @total_weight := 0) as tmp order by turn\\n            \\n    ) as t -- every derived table must have its own alias\\nwhere total_weight <= 1000 \\norder by total_weight desc limit 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1119346,
                "title": "easy-cumulative-sum",
                "content": "```\\nwith cs as (\\n  select *,\\n    sum(weight) over(order by turn) as cum_sum\\n  from queue\\n)\\nselect person_name from cs\\nwhere cum_sum = (select max(cum_sum) from cs where cum_sum <= 1000)\\n```",
                "solutionTags": [
                    "MS SQL Server",
                    "Sliding Window"
                ],
                "code": "```\\nwith cs as (\\n  select *,\\n    sum(weight) over(order by turn) as cum_sum\\n  from queue\\n)\\nselect person_name from cs\\nwhere cum_sum = (select max(cum_sum) from cs where cum_sum <= 1000)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 960364,
                "title": "my-sql-95-simple-solution",
                "content": "```\\n\\nselect person_name \\nfrom \\n(\\nselect person_name , sum(weight)over(order by turn ) as cumlative_sum \\nfrom \\nqueue) as t\\nwhere cumlative_sum <=1000\\ngroup by person_name\\norder by cumlative_sum desc limit 1",
                "solutionTags": [],
                "code": "```\\n\\nselect person_name \\nfrom \\n(\\nselect person_name , sum(weight)over(order by turn ) as cumlative_sum \\nfrom \\nqueue) as t\\nwhere cumlative_sum <=1000\\ngroup by person_name\\norder by cumlative_sum desc limit 1",
                "codeTag": "Unknown"
            },
            {
                "id": 1193593,
                "title": "easy-window-function-sql",
                "content": "```\\nselect person_name\\nfrom\\n(\\n    select person_name, \\n    sum(weight) over(order by turn) as cum_weight\\n    from queue\\n) temp\\nwhere cum_weight<=1000\\norder by cum_weight desc\\nlimit 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect person_name\\nfrom\\n(\\n    select person_name, \\n    sum(weight) over(order by turn) as cum_weight\\n    from queue\\n) temp\\nwhere cum_weight<=1000\\norder by cum_weight desc\\nlimit 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 400019,
                "title": "mysql-straightforward-variable-use",
                "content": "```\\nselect\\n    person_name\\nfrom\\n    (select person_name, @a := @a + weight as acc_weight\\n     from queue q, (select @a := 0) var\\n     order by q.turn) res\\nwhere\\n    acc_weight <= 1000\\norder by \\n    acc_weight desc\\nlimit 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect\\n    person_name\\nfrom\\n    (select person_name, @a := @a + weight as acc_weight\\n     from queue q, (select @a := 0) var\\n     order by q.turn) res\\nwhere\\n    acc_weight <= 1000\\norder by \\n    acc_weight desc\\nlimit 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540369,
                "title": "mysql-solution-for-last-person-to-fit-in-the-bus-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given SQL query aims to select the person_name of the last person in a queue whose cumulative weight does not exceed 1000. The Queue table contains person_name and weight columns, and the queue order is determined by the turn column. The query uses a variable (@total_weight) to keep track of the cumulative weight and selects the person_name when the total weight reaches the limit.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The query starts by initializing the variable @total_weight to 0 using (SELECT @total_weight := 0) AS tmp.\\n1. It then selects the person_name and calculates the cumulative weight by adding the weight to @total_weight using @total_weight := @total_weight + weight.\\n1. The subquery result is ordered by the turn column, ensuring that the person_names are processed in the order they appear in the queue.\\n1. The outer query selects the person_name from the subquery result where the total_weight is less than or equal to 1000.\\n1. The result is sorted in descending order of total_weight and limited to one row using ORDER BY total_weight DESC LIMIT 1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the query depends on the number of rows in the Queue table. The query needs to scan the entire table, calculate the cumulative weight using the variable, and sort the result. The time complexity is typically linear, O(n), where n is the number of rows in the Queue table.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the query depends on the number of rows in the Queue table and the space required to store the result set. The space required for storing the result is constant since it only includes one row. The space complexity is typically O(n) due to the scanning of the Queue table and the storage of intermediate variables.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect person_name from \\n(select person_name, @total_weight := @total_weight + weight as total_weight from Queue,\\n(select @total_weight := 0) as tmp order by turn) as t\\nwhere total_weight <= 1000 order by total_weight desc limit 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect person_name from \\n(select person_name, @total_weight := @total_weight + weight as total_weight from Queue,\\n(select @total_weight := 0) as tmp order by turn) as t\\nwhere total_weight <= 1000 order by total_weight desc limit 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3300001,
                "title": "clear-solution-with-window-function-cte-explained",
                "content": "# Intuition\\nGet running sum column to sort the results.\\n\\n# Approach\\nIt\\'s a classic running total/average problem, where we need to find cumulative sum of values.\\n\\n**Step 1**. Find running total for column \"Weight\" \\n\\nThis could be done with window function:\\n\\n```\\nSELECT person_id,\\n       person_name,\\n       weight,\\n       turn,\\n       SUM(Weight) OVER (ORDER BY turn) as running_total \\nFROM Queue\\nORDER BY turn;\\n```\\nThe output:\\n\\n| person_id | person_name | weight | turn | running_total |\\n| --------- | ----------- | ------ | ---- | ------------- |\\n| 5         | Alice       | 250    | 1    | 250           |\\n| 3         | Alex        | 350    | 2    | 600           |\\n| 6         | John Cena   | 400    | 3    | 1000          |\\n| 2         | Marie       | 200    | 4    | 1200          |\\n| 4         | Bob         | 175    | 5    | 1375          |\\n| 1         | Winston     | 500    | 6    | 1875          |\\n\\n\\nAs you can see from values in column \"running_total\", we already have the answer to this problem :)\\n\\n**Step 2.** Filter CTE by condition\\n\\nLet\\'s create CTE and place our first step table into it. From CTE we can select all rows with condition by column \"running_total\", which should be less ot equal to 1000.\\n\\n```\\nWITH total as (\\n    SELECT person_id,\\n           person_name,\\n           weight,\\n           turn,\\n           SUM(Weight) OVER (ORDER BY turn) as running_total \\n    FROM Queue\\n    ORDER BY turn)\\n\\nSELECT *\\nFROM total\\nWHERE running_total <= 1000;\\n```\\nThe output:\\n\\n| person_id | person_name | weight | turn | running_total |\\n| --------- | ----------- | ------ | ---- | ------------- |\\n| 5         | Alice       | 250    | 1    | 250           |\\n| 3         | Alex        | 350    | 2    | 600           |\\n| 6         | John Cena   | 400    | 3    | 1000          |\\n\\n**Step 3**. Get the correct name\\n\\nJust three things left:\\n- select only \"person_name\"\\n- sort results by column \"running_total\" in descending order\\n- limit the output to 1 row.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nWITH total as (\\n    SELECT person_name,\\n           SUM(Weight) OVER (ORDER BY turn) as running_total \\n    FROM Queue\\n    ORDER BY turn)\\n\\nSELECT person_name\\nFROM total\\nWHERE running_total <= 1000\\nORDER BY running_total DESC\\nLIMIT 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT person_id,\\n       person_name,\\n       weight,\\n       turn,\\n       SUM(Weight) OVER (ORDER BY turn) as running_total \\nFROM Queue\\nORDER BY turn;\\n```\n```\\nWITH total as (\\n    SELECT person_id,\\n           person_name,\\n           weight,\\n           turn,\\n           SUM(Weight) OVER (ORDER BY turn) as running_total \\n    FROM Queue\\n    ORDER BY turn)\\n\\nSELECT *\\nFROM total\\nWHERE running_total <= 1000;\\n```\n```\\n# Write your MySQL query statement below\\nWITH total as (\\n    SELECT person_name,\\n           SUM(Weight) OVER (ORDER BY turn) as running_total \\n    FROM Queue\\n    ORDER BY turn)\\n\\nSELECT person_name\\nFROM total\\nWHERE running_total <= 1000\\nORDER BY running_total DESC\\nLIMIT 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 470284,
                "title": "simple-mysql",
                "content": "```\\n\\nselect q1.person_name from Queue as q1\\ninner join\\nQueue as q2\\non q1.turn>=q2.turn\\ngroup by q1.turn\\nhaving sum(q2.weight)<=1000\\norder by sum(q2.weight) desc\\nlimit 1\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nselect q1.person_name from Queue as q1\\ninner join\\nQueue as q2\\non q1.turn>=q2.turn\\ngroup by q1.turn\\nhaving sum(q2.weight)<=1000\\norder by sum(q2.weight) desc\\nlimit 1\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1779382,
                "title": "easy-to-understand",
                "content": "```\\nwith a as (select turn, person_name, weight,\\nsum(weight) over(order by turn) total_weight\\nfrom queue),\\n\\nb as (select turn, person_name, total_weight,\\nlead(total_weight) over(order by turn) lead_total_weight\\nfrom a)\\n\\nselect person_name from b\\nwhere total_weight <= 1000 and (lead_total_weight > 1000 or lead_total_weight is null)\\n# lead_total_weight is null means all people can get board on the bus",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith a as (select turn, person_name, weight,\\nsum(weight) over(order by turn) total_weight\\nfrom queue),\\n\\nb as (select turn, person_name, total_weight,\\nlead(total_weight) over(order by turn) lead_total_weight\\nfrom a)\\n\\nselect person_name from b\\nwhere total_weight <= 1000 and (lead_total_weight > 1000 or lead_total_weight is null)\\n# lead_total_weight is null means all people can get board on the bus",
                "codeTag": "Unknown"
            },
            {
                "id": 1731287,
                "title": "ms-sql-solution-fast",
                "content": "```\\nselect top 1 q.person_name from\\n(select turn, person_name, weight,\\nSUM(weight) OVER(ORDER BY turn asc ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS total_weight\\nfrom Queue) q\\nwhere q.total_weight <=1000 \\norder by total_weight desc\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect top 1 q.person_name from\\n(select turn, person_name, weight,\\nSUM(weight) OVER(ORDER BY turn asc ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS total_weight\\nfrom Queue) q\\nwhere q.total_weight <=1000 \\norder by total_weight desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 498695,
                "title": "super-clean-and-simple-mysql-81",
                "content": "SELECT a.person_name\\nFROM Queue as a\\nWHERE (SELECT SUM(b.weight)\\n      FROM Queue as b\\n      WHERE a.turn >= b.turn) <= 1000\\nORDER BY turn DESC\\nLIMIT 1;",
                "solutionTags": [],
                "code": "SELECT a.person_name\\nFROM Queue as a\\nWHERE (SELECT SUM(b.weight)\\n      FROM Queue as b\\n      WHERE a.turn >= b.turn) <= 1000\\nORDER BY turn DESC\\nLIMIT 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 430073,
                "title": "both-mysql-ms-sql-answers",
                "content": "mysql:\\n\\n```\\nselect\\ntemp.person_name\\nfrom (\\nselect\\nq1.person_name,\\nq1.turn\\nfrom Queue q1\\njoin Queue q2 on q1.turn >= q2.turn\\ngroup by q1.turn\\nhaving sum(q2.weight) <= 1000\\norder by q1.turn desc\\n)temp\\nlimit 1;\\n```\\n\\nms sql:\\n```\\nwith result as (\\nselect\\nperson_name,\\nturn,\\nsum(weight) over (order by turn)  as acc_sum\\nfrom queue\\n)\\nselect top 1\\nperson_name\\nfrom result\\nwhere acc_sum <= 1000\\norder by turn desc;\\n```",
                "solutionTags": [],
                "code": "```\\nselect\\ntemp.person_name\\nfrom (\\nselect\\nq1.person_name,\\nq1.turn\\nfrom Queue q1\\njoin Queue q2 on q1.turn >= q2.turn\\ngroup by q1.turn\\nhaving sum(q2.weight) <= 1000\\norder by q1.turn desc\\n)temp\\nlimit 1;\\n```\n```\\nwith result as (\\nselect\\nperson_name,\\nturn,\\nsum(weight) over (order by turn)  as acc_sum\\nfrom queue\\n)\\nselect top 1\\nperson_name\\nfrom result\\nwhere acc_sum <= 1000\\norder by turn desc;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3882117,
                "title": "easy-oracle-solution",
                "content": "# Code\\n```\\nselect person_name\\nfrom (select person_name, sum(weight) over (order by turn) as sum_weight\\n      from queue\\n      order by sum_weight desc)\\nwhere sum_weight <= 1000\\n  and rownum = 1;\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nselect person_name\\nfrom (select person_name, sum(weight) over (order by turn) as sum_weight\\n      from queue\\n      order by sum_weight desc)\\nwhere sum_weight <= 1000\\n  and rownum = 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3625340,
                "title": "easy-simple-and-effective",
                "content": "**Bold**# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect TOP 1 person_name from (\\nselect * , sum(weight) over (order by Turn) as total_sum from queue) t \\nwhere total_sum <= 1000\\norder by turn DESC\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect TOP 1 person_name from (\\nselect * , sum(weight) over (order by Turn) as total_sum from queue) t \\nwhere total_sum <= 1000\\norder by turn DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3555537,
                "title": "solved-via-windows-functions",
                "content": "# Approach\\r\\nSolved via Windows functions\\r\\n\\r\\n# Code\\r\\n```\\r\\nwith cte1 as\\r\\n(\\r\\n    select *, \\r\\n    -- aggregate weight by over for each row inclusively\\r\\n    sum(weight) over(order by turn rows between unbounded preceding and current row) as floating_sum \\r\\n    from queue \\r\\n), \\r\\ncte2 as\\r\\n(\\r\\n    select \\r\\n        person_name, \\r\\n        floating_sum, \\r\\n        dense_rank() over(order by floating_sum desc) as row_numb -- getting row number\\r\\n    from cte1 \\r\\n    where floating_sum <= 1000\\r\\n)\\r\\n\\r\\nselect top 1 person_name from cte2 \\r\\norder by row_numb asc\\r\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\r\\nwith cte1 as\\r\\n(\\r\\n    select *, \\r\\n    -- aggregate weight by over for each row inclusively\\r\\n    sum(weight) over(order by turn rows between unbounded preceding and current row) as floating_sum \\r\\n    from queue \\r\\n), \\r\\ncte2 as\\r\\n(\\r\\n    select \\r\\n        person_name, \\r\\n        floating_sum, \\r\\n        dense_rank() over(order by floating_sum desc) as row_numb -- getting row number\\r\\n    from cte1 \\r\\n    where floating_sum <= 1000\\r\\n)\\r\\n\\r\\nselect top 1 person_name from cte2 \\r\\norder by row_numb asc\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3431645,
                "title": "solution-with-sum-over-sql-server",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\nWITH CTE AS (\\r\\n    \\r\\n    SELECT\\r\\n        person_name,\\r\\n        SUM(weight) OVER(ORDER BY Turn ASC) TotalW\\r\\n    FROM\\r\\n        Queue\\r\\n)\\r\\n,CTE2 AS (\\r\\n\\r\\n        SELECT\\r\\n            person_name,\\r\\n            TotalW\\r\\n        FROM\\r\\n            CTE\\r\\n        WHERE\\r\\n            TotalW <= 1000\\r\\n)\\r\\nSELECT\\r\\n    TOP 1\\r\\n    person_name\\r\\nFROM\\r\\n    CTE2\\r\\nORDER BY\\r\\n    TotalW DESC\\r\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\nWITH CTE AS (\\r\\n    \\r\\n    SELECT\\r\\n        person_name,\\r\\n        SUM(weight) OVER(ORDER BY Turn ASC) TotalW\\r\\n    FROM\\r\\n        Queue\\r\\n)\\r\\n,CTE2 AS (\\r\\n\\r\\n        SELECT\\r\\n            person_name,\\r\\n            TotalW\\r\\n        FROM\\r\\n            CTE\\r\\n        WHERE\\r\\n            TotalW <= 1000\\r\\n)\\r\\nSELECT\\r\\n    TOP 1\\r\\n    person_name\\r\\nFROM\\r\\n    CTE2\\r\\nORDER BY\\r\\n    TotalW DESC\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2475275,
                "title": "mysql-solution-short-and-very-easy-to-understand",
                "content": "WITH t1 as(SELECT *, SUM(weight) OVER(ORDER BY turn) csum from queue )\\n\\nSELECT person_name from queue WHERE turn=(SELECT MAX(turn) from t1 where csum<=1000)",
                "solutionTags": [],
                "code": "WITH t1 as(SELECT *, SUM(weight) OVER(ORDER BY turn) csum from queue )\\n\\nSELECT person_name from queue WHERE turn=(SELECT MAX(turn) from t1 where csum<=1000)",
                "codeTag": "Unknown"
            },
            {
                "id": 2445237,
                "title": "mysql-three-solutions-self-join-window-function-inner-join-good-luck",
                "content": "```\\n# Write your MySQL query statement below\\n/**\\nOne table: Queue\\n\\nperson_id is the primary key column for Queue table.\\nQueue table has the information about all people waiting for a bus.\\n\\nbus has a weight limit of 1000 kilograms, so there may be some people who cannot board\\n\\nPROBLEM: find the person_name of the last person that can fit on the bus without exceeding the weight limit.\\n\\nSTEPS:\\n    WITH CTE self JOIN find the cumilative sum\\n    WHERE condition\\n*/\\n\\n#Solution 1 using SELF JOIN\\n\\nWITH CTE AS\\n(\\nSELECT\\n    Q1.turn,\\n    Q1.person_id,\\n    Q1.person_name ,\\n    Q1.weight AS Weight,\\n    SUM(Q2.weight) AS TotalWeight\\n    \\nFROM Queue Q1\\nJOIN Queue Q2\\n    ON  Q1.turn >= Q2.turn\\nGROUP BY 1\\nHAVING SUM(Q2.weight) <= 1000\\nORDER BY 1\\n\\n) \\nSELECT \\n    person_name \\nFROM CTE\\nORDER BY TotalWeight DESC\\nLIMIT 1\\n\\n\\n# SOLUTION 2\\n\\n\\nWITH CTE AS\\n(\\nSELECT \\n    person_name,\\n    SUM(weight) OVER(ORDER BY turn ASC) as totalWeight\\nFROM Queue\\nGROUP BY turn\\n),\\n CTE2 AS\\n(\\nSELECT \\n    person_name,totalWeight\\nFROM CTE\\nHAVING totalWeight <= 1000\\nORDER BY totalWeight DESC\\nLIMIT 1\\n)\\nSELECT\\n    person_name\\nFROM CTE2\\n\\n\\n#SOLUTION 3 - Different Style\\n\\nSELECT \\n    A.person_name\\nFROM \\n(\\nSELECT \\n    person_name, turn,\\n    SUM(weight) OVER(ORDER BY turn ASC) as totalWeight\\nFROM Queue\\n) A\\nWHERE totalWeight <= 1000\\nGROUP BY turn\\nORDER BY totalWeight DESC\\n    LIMIT 1\\n\\n```\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n/**\\nOne table: Queue\\n\\nperson_id is the primary key column for Queue table.\\nQueue table has the information about all people waiting for a bus.\\n\\nbus has a weight limit of 1000 kilograms, so there may be some people who cannot board\\n\\nPROBLEM: find the person_name of the last person that can fit on the bus without exceeding the weight limit.\\n\\nSTEPS:\\n    WITH CTE self JOIN find the cumilative sum\\n    WHERE condition\\n*/\\n\\n#Solution 1 using SELF JOIN\\n\\nWITH CTE AS\\n(\\nSELECT\\n    Q1.turn,\\n    Q1.person_id,\\n    Q1.person_name ,\\n    Q1.weight AS Weight,\\n    SUM(Q2.weight) AS TotalWeight\\n    \\nFROM Queue Q1\\nJOIN Queue Q2\\n    ON  Q1.turn >= Q2.turn\\nGROUP BY 1\\nHAVING SUM(Q2.weight) <= 1000\\nORDER BY 1\\n\\n) \\nSELECT \\n    person_name \\nFROM CTE\\nORDER BY TotalWeight DESC\\nLIMIT 1\\n\\n\\n# SOLUTION 2\\n\\n\\nWITH CTE AS\\n(\\nSELECT \\n    person_name,\\n    SUM(weight) OVER(ORDER BY turn ASC) as totalWeight\\nFROM Queue\\nGROUP BY turn\\n),\\n CTE2 AS\\n(\\nSELECT \\n    person_name,totalWeight\\nFROM CTE\\nHAVING totalWeight <= 1000\\nORDER BY totalWeight DESC\\nLIMIT 1\\n)\\nSELECT\\n    person_name\\nFROM CTE2\\n\\n\\n#SOLUTION 3 - Different Style\\n\\nSELECT \\n    A.person_name\\nFROM \\n(\\nSELECT \\n    person_name, turn,\\n    SUM(weight) OVER(ORDER BY turn ASC) as totalWeight\\nFROM Queue\\n) A\\nWHERE totalWeight <= 1000\\nGROUP BY turn\\nORDER BY totalWeight DESC\\n    LIMIT 1\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1534880,
                "title": "ms-sql",
                "content": "#### Question\\n```\\n1204. Last Person to Fit in the Bus\\nMedium\\n\\nSQL Schema\\nTable: Queue\\n\\n+-------------+---------+\\n| Column Name | Type    |\\n+-------------+---------+\\n| person_id   | int     |\\n| person_name | varchar |\\n| weight      | int     |\\n| turn        | int     |\\n+-------------+---------+\\nperson_id is the primary key column for this table.\\nThis table has the information about all people waiting for a bus.\\nThe person_id and turn columns will contain all numbers from 1 to n, where n is the number of rows in the table.\\nturn determines the order of which the people will board the bus, where turn=1 denotes the first person to board and turn=n denotes the last person to board.\\nweight is the weight of the person in kilograms.\\n \\n\\nThere is a queue of people waiting to board a bus. However, the bus has a weight limit of 1000 kilograms, so there may be some people who cannot board.\\n\\nWrite an SQL query to find the person_name of the last person that can fit on the bus without exceeding the weight limit. The testcases are generated such that the first person does not exceed the weight limit.\\n\\nThe query result format is in the following example:\\n\\n \\n\\nQueue table:\\n+-----------+-------------+--------+------+\\n| person_id | person_name | weight | turn |\\n+-----------+-------------+--------+------+\\n| 5         | Alice       | 250    | 1    |\\n| 4         | Bob         | 175    | 5    |\\n| 3         | Alex        | 350    | 2    |\\n| 6         | John Cena   | 400    | 3    |\\n| 1         | Winston     | 500    | 6    |\\n| 2         | Marie       | 200    | 4    |\\n+-----------+-------------+--------+------+\\n\\nResult table\\n+-------------+\\n| person_name |\\n+-------------+\\n| John Cena   |\\n+-------------+\\n\\nThe table is ordered by the turn for simplicity.\\n+------+----+-----------+--------+--------------+\\n| Turn | ID | Name      | Weight | Total Weight |\\n+------+----+-----------+--------+--------------+\\n| 1    | 5  | Alice     | 250    | 250          |\\n| 2    | 3  | Alex      | 350    | 600          |\\n| 3    | 6  | John Cena | 400    | 1000         | (last person to board)\\n| 4    | 2  | Marie     | 200    | 1200         | (cannot board)\\n| 5    | 4  | Bob       | 175    | ___          |\\n| 6    | 1  | Winston   | 500    | ___          |\\n+------+----+-----------+--------+--------------+\\n```\\n\\n#### Answer1\\n```SQL\\nwith a as (select person_name, sum(weight) over (order by turn) wt  from Queue\\n)\\n\\nselect top(1) person_name from a\\nwhere wt <= 1000\\norder by wt desc\\n\\n```\\n\\n#### Answer2\\n```SQL\\nselect top 1 q1.person_name from queue q1 join queue q2 on q1.turn >= q2.turn\\ngroup by q1.person_id, q1.person_name, q1.turn\\nhaving sum(q2.weight) <= 1000\\norder by q1.turn desc\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n1204. Last Person to Fit in the Bus\\nMedium\\n\\nSQL Schema\\nTable: Queue\\n\\n+-------------+---------+\\n| Column Name | Type    |\\n+-------------+---------+\\n| person_id   | int     |\\n| person_name | varchar |\\n| weight      | int     |\\n| turn        | int     |\\n+-------------+---------+\\nperson_id is the primary key column for this table.\\nThis table has the information about all people waiting for a bus.\\nThe person_id and turn columns will contain all numbers from 1 to n, where n is the number of rows in the table.\\nturn determines the order of which the people will board the bus, where turn=1 denotes the first person to board and turn=n denotes the last person to board.\\nweight is the weight of the person in kilograms.\\n \\n\\nThere is a queue of people waiting to board a bus. However, the bus has a weight limit of 1000 kilograms, so there may be some people who cannot board.\\n\\nWrite an SQL query to find the person_name of the last person that can fit on the bus without exceeding the weight limit. The testcases are generated such that the first person does not exceed the weight limit.\\n\\nThe query result format is in the following example:\\n\\n \\n\\nQueue table:\\n+-----------+-------------+--------+------+\\n| person_id | person_name | weight | turn |\\n+-----------+-------------+--------+------+\\n| 5         | Alice       | 250    | 1    |\\n| 4         | Bob         | 175    | 5    |\\n| 3         | Alex        | 350    | 2    |\\n| 6         | John Cena   | 400    | 3    |\\n| 1         | Winston     | 500    | 6    |\\n| 2         | Marie       | 200    | 4    |\\n+-----------+-------------+--------+------+\\n\\nResult table\\n+-------------+\\n| person_name |\\n+-------------+\\n| John Cena   |\\n+-------------+\\n\\nThe table is ordered by the turn for simplicity.\\n+------+----+-----------+--------+--------------+\\n| Turn | ID | Name      | Weight | Total Weight |\\n+------+----+-----------+--------+--------------+\\n| 1    | 5  | Alice     | 250    | 250          |\\n| 2    | 3  | Alex      | 350    | 600          |\\n| 3    | 6  | John Cena | 400    | 1000         | (last person to board)\\n| 4    | 2  | Marie     | 200    | 1200         | (cannot board)\\n| 5    | 4  | Bob       | 175    | ___          |\\n| 6    | 1  | Winston   | 500    | ___          |\\n+------+----+-----------+--------+--------------+\\n```\n```SQL\\nwith a as (select person_name, sum(weight) over (order by turn) wt  from Queue\\n)\\n\\nselect top(1) person_name from a\\nwhere wt <= 1000\\norder by wt desc\\n\\n```\n```SQL\\nselect top 1 q1.person_name from queue q1 join queue q2 on q1.turn >= q2.turn\\ngroup by q1.person_id, q1.person_name, q1.turn\\nhaving sum(q2.weight) <= 1000\\norder by q1.turn desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1431425,
                "title": "no-join-and-no-subquery-mysql-beat-84-with-explanation",
                "content": "\"sum(weight) over ( order by turn asc) <= 1000\"  indicates a group of people who can attend the bus\\n\"sum(weight) over ( order by turn asc)\" provids the accumulate sum of weight ( total weight)\\n\\nThe logic is to select the highest  total weight within the a group of people who can attend the bus.\\n\\n```\\nselect person_name\\nfrom Queue \\norder by sum(weight) over ( order by turn asc) <= 1000  desc, sum(weight) over ( order by turn asc) desc\\nlimit 1\\n```",
                "solutionTags": [],
                "code": "```\\nselect person_name\\nfrom Queue \\norder by sum(weight) over ( order by turn asc) <= 1000  desc, sum(weight) over ( order by turn asc) desc\\nlimit 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1065924,
                "title": "beats-96-simplest-solution",
                "content": "```\\nselect person_name\\nfrom\\n(\\n    select *, sum(weight) over(order by turn) s\\n    from Queue \\n) t\\nwhere s <= 1000\\norder by turn desc\\nLimit 1\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/f8fdd7cd-c180-46a2-a05f-35013d983279_1613345252.496031.png)\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect person_name\\nfrom\\n(\\n    select *, sum(weight) over(order by turn) s\\n    from Queue \\n) t\\nwhere s <= 1000\\norder by turn desc\\nLimit 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 820803,
                "title": "mysql-using-window-function",
                "content": "SELECT person_name FROM\\n\\n(SELECT person_name, SUM(weight) OVER(ORDER BY turn ASC) AS total_weight FROM Queue) t1\\n\\nWHERE t1.total_weight <= 1000\\nORDER BY t1.total_weight DESC LIMIT 1",
                "solutionTags": [],
                "code": "SELECT person_name FROM\\n\\n(SELECT person_name, SUM(weight) OVER(ORDER BY turn ASC) AS total_weight FROM Queue) t1\\n\\nWHERE t1.total_weight <= 1000\\nORDER BY t1.total_weight DESC LIMIT 1",
                "codeTag": "Unknown"
            },
            {
                "id": 398979,
                "title": "easy-understood-and-fast-solution",
                "content": "```\\n# # 1. find the cumulative weight by the turn\\n# turn  person_name  cum_weight\\n# # 2. filter out those cum_weight > 100, and select person_name with max\\n# person_name\\n\\nSELECT table1.person_name\\nFROM\\n    (SELECT q.turn,\\n            q.person_name,\\n           (SELECT SUM(q1.weight) FROM queue q1\\n           WHERE q1.turn <= q.turn) AS cum_weight\\n    FROM queue q) table1\\nWHERE table1.cum_weight <= 1000\\nORDER BY table1.turn DESC\\nLIMIT 1\\n```",
                "solutionTags": [],
                "code": "```\\n# # 1. find the cumulative weight by the turn\\n# turn  person_name  cum_weight\\n# # 2. filter out those cum_weight > 100, and select person_name with max\\n# person_name\\n\\nSELECT table1.person_name\\nFROM\\n    (SELECT q.turn,\\n            q.person_name,\\n           (SELECT SUM(q1.weight) FROM queue q1\\n           WHERE q1.turn <= q.turn) AS cum_weight\\n    FROM queue q) table1\\nWHERE table1.cum_weight <= 1000\\nORDER BY table1.turn DESC\\nLIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3939749,
                "title": "last-person-to-fit-in-bus",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal is to find the last person who can fit on the bus without exceeding the weight limit. We need to consider the order of people based on their turn and calculate the cumulative weight at each turn to check if it exceeds the weight limit.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe join the Queue table with itself, creating combinations of rows where each row is paired with all rows that have a higher or equal turn value.\\nWe group the rows by turn and calculate the sum of weights for each group.\\nUsing the HAVING clause, we filter out groups whose sum of weights exceeds the weight limit of 1000.\\nWe order the results by the sum of weights in descending order, ensuring the last person who can fit is at the top.\\nFinally, we limit the result to 1 row since we only need the information of the last person.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n# Write your MySQL query statement below\\nSELECT \\n    q1.person_name\\nFROM Queue q1 JOIN Queue q2 ON q1.turn >= q2.turn\\nGROUP BY q1.turn\\nHAVING SUM(q2.weight) <= 1000\\nORDER BY SUM(q2.weight) DESC\\nLIMIT 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n# Write your MySQL query statement below\\nSELECT \\n    q1.person_name\\nFROM Queue q1 JOIN Queue q2 ON q1.turn >= q2.turn\\nGROUP BY q1.turn\\nHAVING SUM(q2.weight) <= 1000\\nORDER BY SUM(q2.weight) DESC\\nLIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3616656,
                "title": "easy-mysql-solution-with-explanation-using-derived-table",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The question asks us to retrieve the **name of the last person** that gets on the bus as people are standing in a queue with each having a turn (number) and the **limit of the bus is 1000 kg**.\\n- We retrieve the person_name from a **derived table Q** which sums the weight of the persons as they get in the bus according to their turn.\\n- We then state a condition that the **sum of the weights cannot exceed 1000kg** and then order the people on the bus by their turn and limit the query result to 1 so that we retrieve the name of the last person.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. In the SELECT statement, we retrieve the **person_name**.\\n2. In the FROM statement, we use a derived table Q where **total_weight is written as SUM(weight) OVER(ORDER BY turn)**.\\n3. The **WHERE clause** states a condition that **total_weight<=1000**\\n4. The **ORDER BY clause** orders the query result by **turn in descending order**, meaning the person who entered the bus last will be on top and then limit the result to 1 in order to retrieve the last person_name to enter the bus.\\n\\n# Code\\n```\\n# Write your MySQL solution below\\nSELECT person_name\\nFROM\\n(\\n  SELECT person_name, weight, turn, SUM(weight) OVER(ORDER BY turn) as total_weight FROM Queue\\n) as Q\\nWHERE total_weight<=1000\\nORDER BY turn DESC LIMIT 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL solution below\\nSELECT person_name\\nFROM\\n(\\n  SELECT person_name, weight, turn, SUM(weight) OVER(ORDER BY turn) as total_weight FROM Queue\\n) as Q\\nWHERE total_weight<=1000\\nORDER BY turn DESC LIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3474835,
                "title": "easy-mysql-window-function-running-sum-cte-beats-93",
                "content": "\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nwith cte1 as\\n (select * , sum(weight) over(order by turn Rows between unbounded preceding and current row) as running_sum from queue )\\n , cte2 as\\n (select person_name , running_sum , dense_rank() over(order by running_sum desc) as rn from cte1 \\n where running_sum<=1000\\n )\\n select person_name from cte2 \\n where rn=1;\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nwith cte1 as\\n (select * , sum(weight) over(order by turn Rows between unbounded preceding and current row) as running_sum from queue )\\n , cte2 as\\n (select person_name , running_sum , dense_rank() over(order by running_sum desc) as rn from cte1 \\n where running_sum<=1000\\n )\\n select person_name from cte2 \\n where rn=1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2385263,
                "title": "simple-cte-window-function",
                "content": "with CTE as (select person_name, sum(weight) over(order by turn) as totalweight\\nfrom Queue\\norder by turn asc)\\n\\nselect person_name from CTE\\nwhere totalweight<=1000\\norder by totalweight desc limit 1\\n\\n**#Over() can be used on aggregate functions like count(), sum(), etc...**\\n**(Sum(weight) over(order by  turn) + order by turn asc) create a rolling sum of weight starting from turn 1**\\n**now we filter the total weight <= 1000 to find all person that can board the bus. We then order by weight descending to find the last person **",
                "solutionTags": [],
                "code": "with CTE as (select person_name, sum(weight) over(order by turn) as totalweight\\nfrom Queue\\norder by turn asc)\\n\\nselect person_name from CTE\\nwhere totalweight<=1000\\norder by totalweight desc limit 1\\n\\n**#Over() can be used on aggregate functions like count(), sum(), etc...**\\n**(Sum(weight) over(order by  turn) + order by turn asc) create a rolling sum of weight starting from turn 1**\\n**now we filter the total weight <= 1000 to find all person that can board the bus. We then order by weight descending to find the last person **",
                "codeTag": "Unknown"
            },
            {
                "id": 2264066,
                "title": "beautiful-and-simple",
                "content": "```\\nSELECT person_name\\nFROM \\n    (SELECT person_name, \\n           turn,\\n           SUM(weight) OVER(order by turn) total_weight\\n    FROM queue) sub1\\nWHERE total_weight <= \\'1000\\'\\nORDER BY total_weight DESC\\nLIMIT 1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT person_name\\nFROM \\n    (SELECT person_name, \\n           turn,\\n           SUM(weight) OVER(order by turn) total_weight\\n    FROM queue) sub1\\nWHERE total_weight <= \\'1000\\'\\nORDER BY total_weight DESC\\nLIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2136934,
                "title": "easy-window-function",
                "content": "select person_name from(\\nselect *,\\nsum(weight) over(order by turn) as total from Queue) sq1\\nwhere total<= 1000\\norder by turn desc\\nlimit 1",
                "solutionTags": [],
                "code": "select person_name from(\\nselect *,\\nsum(weight) over(order by turn) as total from Queue) sq1\\nwhere total<= 1000\\norder by turn desc\\nlimit 1",
                "codeTag": "Unknown"
            },
            {
                "id": 2042742,
                "title": "mysql-solution-with-window-function",
                "content": "```\\n-- A two-step approach. \\n-- The first step is to calculate the running total of weight based on the sequence of their arrival\\nWITH cum_weight AS(\\n    SELECT person_name,\\n        SUM(weight) OVER(ORDER BY turn) AS running_total\\n    FROM Queue)\\n\\n-- The second step is to obtain the passenger name, whose calculated running total weight is equal to \\n-- the maximum running total that\\'s below 1000. \\nSELECT person_name\\nFROM cum_weight\\nWHERE running_total = (SELECT MAX(running_total) \\n                       FROM cum_weight \\n                       WHERE running_total <=1000);",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\n-- A two-step approach. \\n-- The first step is to calculate the running total of weight based on the sequence of their arrival\\nWITH cum_weight AS(\\n    SELECT person_name,\\n        SUM(weight) OVER(ORDER BY turn) AS running_total\\n    FROM Queue)\\n\\n-- The second step is to obtain the passenger name, whose calculated running total weight is equal to \\n-- the maximum running total that\\'s below 1000. \\nSELECT person_name\\nFROM cum_weight\\nWHERE running_total = (SELECT MAX(running_total) \\n                       FROM cum_weight \\n                       WHERE running_total <=1000);",
                "codeTag": "Unknown"
            },
            {
                "id": 1713822,
                "title": "fast-window-function",
                "content": "```\\nselect person_name from\\n(select turn, person_id, person_name, sum(weight) over(order by turn) as total from Queue q) t\\nwhere total<=1000\\norder by total desc\\nlimit 1\\n\\n```",
                "solutionTags": [],
                "code": "```\\nselect person_name from\\n(select turn, person_id, person_name, sum(weight) over(order by turn) as total from Queue q) t\\nwhere total<=1000\\norder by total desc\\nlimit 1\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1671548,
                "title": "windows-function",
                "content": "select person_name \\nfrom (\\n    select person_id, person_name, turn, weight, \\n        sum(weight) over(order by turn) as cum_wright\\n    from Queue\\n    order by turn) sub\\nwhere cum_wright <= 1000\\norder by cum_wright desc\\nlimit 1;",
                "solutionTags": [],
                "code": "select person_name \\nfrom (\\n    select person_id, person_name, turn, weight, \\n        sum(weight) over(order by turn) as cum_wright\\n    from Queue\\n    order by turn) sub\\nwhere cum_wright <= 1000\\norder by cum_wright desc\\nlimit 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 1662898,
                "title": "mysql-easy-solution",
                "content": "select person_name from (\\nselect a.person_name, sum(b.weight) \\nfrom Queue a, Queue b\\nwhere b.turn <= a.turn \\ngroup by 1 \\nhaving sum(b.weight) <= 1000\\norder by a.turn desc \\nlimit 1 ) as person",
                "solutionTags": [],
                "code": "select person_name from (\\nselect a.person_name, sum(b.weight) \\nfrom Queue a, Queue b\\nwhere b.turn <= a.turn \\ngroup by 1 \\nhaving sum(b.weight) <= 1000\\norder by a.turn desc \\nlimit 1 ) as person",
                "codeTag": "Unknown"
            },
            {
                "id": 1599256,
                "title": "full-breakdown-solution",
                "content": "Here is a solution that is code formatted, commented, and modular. You can use three backticks to add code blocks.\\n\\nI think many users are focusing on \\'fast\\', instead of discussing human readable and explainable solutions. You\\'ll be interviewed by humans not computers, and you\\'ll need to be able to talk through and explain what your code does.\\n\\nFor those looking to learn; there are separate CTE expressions here, you can look at each in isolation to see how it builds towards the solution. Hope this helps you!\\n\\n```SQL\\n-- Step 1: Use ROWS for a cumulative sum column, ordering by turn\\nWITH cumulative_sum AS (\\n    SELECT\\n        person_id,\\n        person_name,\\n        weight,\\n        turn,\\n        SUM(weight) OVER (\\n            ORDER BY turn\\n            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\\n        ) AS cumulative_weight\\n    FROM Queue\\n)\\n-- Step 2: Filter to 1000 or less cumulative weight, then invert\\n-- the table order and select only one record using LIMIT 1\\nSELECT\\n    person_name\\nFROM cumulative_sum\\nWHERE cumulative_weight <= 1000\\nORDER BY turn DESC\\nLIMIT 1\\n\\n```\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```SQL\\n-- Step 1: Use ROWS for a cumulative sum column, ordering by turn\\nWITH cumulative_sum AS (\\n    SELECT\\n        person_id,\\n        person_name,\\n        weight,\\n        turn,\\n        SUM(weight) OVER (\\n            ORDER BY turn\\n            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\\n        ) AS cumulative_weight\\n    FROM Queue\\n)\\n-- Step 2: Filter to 1000 or less cumulative weight, then invert\\n-- the table order and select only one record using LIMIT 1\\nSELECT\\n    person_name\\nFROM cumulative_sum\\nWHERE cumulative_weight <= 1000\\nORDER BY turn DESC\\nLIMIT 1\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1534397,
                "title": "mysql-clear-simple-solution-faster-than-99-43",
                "content": "WITH CTE AS (\\n    SELECT *, SUM(weight) OVER(ORDER BY Turn) AS Total_Weight\\n    FROM Queue)\\n\\t\\nSELECT person_name\\nFROM CTE\\nWHERE Total_Weight <= 1000\\nORDER BY Total_Weight DESC\\nLIMIT 1",
                "solutionTags": [],
                "code": "WITH CTE AS (\\n    SELECT *, SUM(weight) OVER(ORDER BY Turn) AS Total_Weight\\n    FROM Queue)\\n\\t\\nSELECT person_name\\nFROM CTE\\nWHERE Total_Weight <= 1000\\nORDER BY Total_Weight DESC\\nLIMIT 1",
                "codeTag": "Unknown"
            },
            {
                "id": 1469952,
                "title": "using-window-function",
                "content": "```\\nselect person_name\\nfrom \\n(select person_name,\\nsum(weight) over (order by turn) as total_weight\\nfrom Queue) as w\\nwhere total_weight <= 1000\\norder by total_weight desc limit 1\\n```",
                "solutionTags": [],
                "code": "```\\nselect person_name\\nfrom \\n(select person_name,\\nsum(weight) over (order by turn) as total_weight\\nfrom Queue) as w\\nwhere total_weight <= 1000\\norder by total_weight desc limit 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1386465,
                "title": "simple-mysql-solution",
                "content": "```\\n-- Creat a column \\'total\\' to calculate the running total of the weight.\\nWITH temp AS(\\n    SELECT\\n        *\\n        ,Sum(weight) OVER(ORDER BY turn) as total\\n    FROM\\n        Queue\\n)\\n\\n-- Find the name in last row (name of last person)\\nSELECT\\n    person_name\\nFROM\\n    temp\\nWHERE\\n    total <= 1000\\nORDER BY\\n    total DESC\\nLIMIT 1\\n```",
                "solutionTags": [],
                "code": "```\\n-- Creat a column \\'total\\' to calculate the running total of the weight.\\nWITH temp AS(\\n    SELECT\\n        *\\n        ,Sum(weight) OVER(ORDER BY turn) as total\\n    FROM\\n        Queue\\n)\\n\\n-- Find the name in last row (name of last person)\\nSELECT\\n    person_name\\nFROM\\n    temp\\nWHERE\\n    total <= 1000\\nORDER BY\\n    total DESC\\nLIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1355279,
                "title": "mysql",
                "content": "```\\nselect person_name\\nfrom\\n(select person_id, person_name, turn, sum(weight)over(order by turn) as wt\\nfrom Queue) q\\nwhere wt <= 1000\\norder by turn desc\\nlimit 1\\n",
                "solutionTags": [],
                "code": "```\\nselect person_name\\nfrom\\n(select person_id, person_name, turn, sum(weight)over(order by turn) as wt\\nfrom Queue) q\\nwhere wt <= 1000\\norder by turn desc\\nlimit 1\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1239633,
                "title": "simple-solution-use-window-function",
                "content": "select person_name\\nfrom\\n(select *, sum(weight) over(order by turn) as total_weight\\nfrom Queue) s\\nwhere s.total_weight <= 1000\\norder by total_weight desc\\nlimit 1;",
                "solutionTags": [],
                "code": "select person_name\\nfrom\\n(select *, sum(weight) over(order by turn) as total_weight\\nfrom Queue) s\\nwhere s.total_weight <= 1000\\norder by total_weight desc\\nlimit 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 1198809,
                "title": "mysql",
                "content": "```\\n# running total \\nselect \\n    person_name\\nfrom\\n(\\nselect \\n    *,\\n    sum(weight) over (order by turn) as r_t\\nfrom queue \\n) tmp1\\nwhere r_t <= 1000\\norder by r_t desc\\nlimit 1;\\n",
                "solutionTags": [],
                "code": "```\\n# running total \\nselect \\n    person_name\\nfrom\\n(\\nselect \\n    *,\\n    sum(weight) over (order by turn) as r_t\\nfrom queue \\n) tmp1\\nwhere r_t <= 1000\\norder by r_t desc\\nlimit 1;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1190410,
                "title": "easy-and-simple-solution",
                "content": "```\\nWITH acc_weight AS (\\n    SELECT\\n        person_name,\\n        SUM(weight) OVER(ORDER BY turn) total_weight\\n    FROM queue )\\n\\nSELECT \\n    person_name\\nFROM acc_weight\\nWHERE total_weight <= 1000\\nORDER BY total_weight DESC\\nLIMIT 1\\n```",
                "solutionTags": [],
                "code": "```\\nWITH acc_weight AS (\\n    SELECT\\n        person_name,\\n        SUM(weight) OVER(ORDER BY turn) total_weight\\n    FROM queue )\\n\\nSELECT \\n    person_name\\nFROM acc_weight\\nWHERE total_weight <= 1000\\nORDER BY total_weight DESC\\nLIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1112795,
                "title": "window-function-and-simple-select-statements",
                "content": "```\\nSELECT person_name\\nFROM (\\n    SELECT person_name,\\n        turn,\\n        CASE\\n            WHEN cum_sum > 1000 THEN 1 \\n            ELSE 0\\n            END greater_1000\\n    FROM (\\n        SELECT person_name,\\n            turn,\\n            SUM(weight) OVER (ORDER BY turn) cum_sum\\n        FROM queue\\n        ORDER BY turn\\n        ) a\\n    ) final\\nWHERE greater_1000 = 0\\nORDER BY turn DESC\\nLIMIT 1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT person_name\\nFROM (\\n    SELECT person_name,\\n        turn,\\n        CASE\\n            WHEN cum_sum > 1000 THEN 1 \\n            ELSE 0\\n            END greater_1000\\n    FROM (\\n        SELECT person_name,\\n            turn,\\n            SUM(weight) OVER (ORDER BY turn) cum_sum\\n        FROM queue\\n        ORDER BY turn\\n        ) a\\n    ) final\\nWHERE greater_1000 = 0\\nORDER BY turn DESC\\nLIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1094089,
                "title": "mysql-using-window-function-and-subqueries",
                "content": "```\\nSELECT person_name FROM \\n(\\n    SELECT person_name , SUM(weight) OVER (ORDER BY turn) AS weight\\n    FROM queue\\n)a\\nWHERE weight <= 1000\\nORDER BY weight DESC LIMIT 1\\n\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT person_name FROM \\n(\\n    SELECT person_name , SUM(weight) OVER (ORDER BY turn) AS weight\\n    FROM queue\\n)a\\nWHERE weight <= 1000\\nORDER BY weight DESC LIMIT 1\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1063767,
                "title": "2-ctes-mysql-with-clear-variable-names-and-sum-over",
                "content": "First add a cumulative weight column to the table using a sum() over() clause. \\n\\nSecond, filter the above CTE to only keep rows where the cumulative weight is LTE 1000\\n\\nThird, select from the second CTE and revsere the ordering by turn descending and LIMIT 1. \\n\\n```sql\\nwith cumulative_weights AS (\\n    SELECT q.*, \\n        sum(q.weight) over(order by turn) as cumulative_weight\\n    FROM Queue q\\n)\\n, weights_lte_1000 AS (\\n    SELECT * FROM cumulative_weights \\n    WHERE cumulative_weight <= 1000\\n    ORDER BY turn\\n)\\n\\nSELECT person_name \\nFROM weights_lte_1000\\nORDER BY turn DESC \\nLIMIT 1\\n```",
                "solutionTags": [],
                "code": "```sql\\nwith cumulative_weights AS (\\n    SELECT q.*, \\n        sum(q.weight) over(order by turn) as cumulative_weight\\n    FROM Queue q\\n)\\n, weights_lte_1000 AS (\\n    SELECT * FROM cumulative_weights \\n    WHERE cumulative_weight <= 1000\\n    ORDER BY turn\\n)\\n\\nSELECT person_name \\nFROM weights_lte_1000\\nORDER BY turn DESC \\nLIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1003976,
                "title": "window-function-sum-over",
                "content": "```\\nselect\\n    person_name\\nfrom\\n(\\nselect\\n    person_name,\\n    sum(weight) over(order by turn) cumwgt\\nfrom Queue \\n) t\\nwhere cumwgt <= 1000\\norder by cumwgt desc\\nlimit 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect\\n    person_name\\nfrom\\n(\\nselect\\n    person_name,\\n    sum(weight) over(order by turn) cumwgt\\nfrom Queue \\n) t\\nwhere cumwgt <= 1000\\norder by cumwgt desc\\nlimit 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 982910,
                "title": "no-windows-function-only-cte",
                "content": "```\\nwith weight_CTE as \\n(select person_name, turn, \\n(select sum(weight) from queue where turn <= q.turn) as cum_weight \\nfrom queue q )\\n\\nselect person_name from weight_CTE \\nwhere cum_weight<=1000\\norder by turn desc limit 1;\\n```",
                "solutionTags": [],
                "code": "```\\nwith weight_CTE as \\n(select person_name, turn, \\n(select sum(weight) from queue where turn <= q.turn) as cum_weight \\nfrom queue q )\\n\\nselect person_name from weight_CTE \\nwhere cum_weight<=1000\\norder by turn desc limit 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 905917,
                "title": "using-recursive-cte",
                "content": "\\nwith recursive base as \\n(select person_name,turn, weight from queue where turn = 1\\n union all\\n select b.person_name,b.turn,a.weight+ b.weight \\n from base a\\n join queue b \\n on a.turn + 1 = b.turn\\n)\\nselect person_name from base where weight <= 1000 \\norder by weight desc limit 1",
                "solutionTags": [],
                "code": "\\nwith recursive base as \\n(select person_name,turn, weight from queue where turn = 1\\n union all\\n select b.person_name,b.turn,a.weight+ b.weight \\n from base a\\n join queue b \\n on a.turn + 1 = b.turn\\n)\\nselect person_name from base where weight <= 1000 \\norder by weight desc limit 1",
                "codeTag": "Unknown"
            },
            {
                "id": 858549,
                "title": "simple-ms-sql-solution",
                "content": "```\\nselect\\n    top 1\\n    person_name\\nfrom\\n    (\\n    select\\n        person_name\\n        ,turn\\n        ,sum(weight) over(order by turn asc) as moving_total_weight\\n    from\\n        Queue\\n    ) as a\\nwhere\\n    moving_total_weight <= 1000\\norder by\\n    a.turn desc;\\n```",
                "solutionTags": [],
                "code": "```\\nselect\\n    top 1\\n    person_name\\nfrom\\n    (\\n    select\\n        person_name\\n        ,turn\\n        ,sum(weight) over(order by turn asc) as moving_total_weight\\n    from\\n        Queue\\n    ) as a\\nwhere\\n    moving_total_weight <= 1000\\norder by\\n    a.turn desc;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 840214,
                "title": "mysql-simple-approach-solution-2-liner",
                "content": "Below is the solution using a concept which is generally asked in Amazon i.e. Correlated subquery \\n\\n```select person_name from Queue q1 where 1000 >= (select sum(weight) from Queue q2 where q1.turn >= q2.turn) order by turn desc limit 1 offset 0```",
                "solutionTags": [],
                "code": "```select person_name from Queue q1 where 1000 >= (select sum(weight) from Queue q2 where q1.turn >= q2.turn) order by turn desc limit 1 offset 0```",
                "codeTag": "Unknown"
            },
            {
                "id": 813958,
                "title": "simple-solution-faster-than-90-69-using-last-value-sum-and-limit-1",
                "content": "```\\nselect last_value(person_name) over () as person_name\\nfrom (select person_name, sum(weight) over (order by turn asc)  as cum_sum\\n        from Queue) as t\\nwhere cum_sum <= 1000\\nlimit 1\\n\\n```",
                "solutionTags": [],
                "code": "```\\nselect last_value(person_name) over () as person_name\\nfrom (select person_name, sum(weight) over (order by turn asc)  as cum_sum\\n        from Queue) as t\\nwhere cum_sum <= 1000\\nlimit 1\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 794105,
                "title": "mysql-solution-window-function",
                "content": "```\\n# Write your MySQL query statement below\\n\\nSELECT \\n    temp.person_name\\nFROM \\n(\\nSELECT\\n    person_name,\\n    SUM(weight) OVER (order by turn ASC) AS running_total\\nFROM Queue\\n)temp\\nWHERE temp.running_total <= 1000\\nORDER BY temp.running_total DESC LIMIT 1\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT \\n    temp.person_name\\nFROM \\n(\\nSELECT\\n    person_name,\\n    SUM(weight) OVER (order by turn ASC) AS running_total\\nFROM Queue\\n)temp\\nWHERE temp.running_total <= 1000\\nORDER BY temp.running_total DESC LIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 767711,
                "title": "accumulate-sum-and-limit-1",
                "content": "```SQL\\n\\nselect person_name from (select a.person_name, a.turn, sum(b.weight) accumulate_sum from Queue a \\njoin Queue b on b.turn <= a.turn\\ngroup by person_name, a.turn) a\\nwhere accumulate_sum <= 1000\\norder by turn desc\\nlimit 1\\n",
                "solutionTags": [],
                "code": "```SQL\\n\\nselect person_name from (select a.person_name, a.turn, sum(b.weight) accumulate_sum from Queue a \\njoin Queue b on b.turn <= a.turn\\ngroup by person_name, a.turn) a\\nwhere accumulate_sum <= 1000\\norder by turn desc\\nlimit 1\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 750096,
                "title": "simplest-4-line-solutions",
                "content": "```\\nSELECT person_name \\nFROM (SELECT person_name, SUM(weight) OVER (ORDER BY turn) AS cumulative_weight FROM Queue) qc\\nWHERE cumulative_weight <= 1000\\nORDER BY cumulative_weight DESC LIMIT 1;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT person_name \\nFROM (SELECT person_name, SUM(weight) OVER (ORDER BY turn) AS cumulative_weight FROM Queue) qc\\nWHERE cumulative_weight <= 1000\\nORDER BY cumulative_weight DESC LIMIT 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 730636,
                "title": "3-solutions-self-join-window-function-sub-query",
                "content": "Self join\\n```\\nselect a.person_name\\nfrom queue a\\njoin queue b on a.turn>=b.turn\\ngroup by a.person_id\\nhaving sum(b.weight)<=1000\\norder by a.turn desc\\nlimit 1\\n```\\n\\nWindow function\\n```\\nwith t as\\n    (select *,\\n        sum(weight) over(order by turn) accumu_weight\\n    from queue)\\n\\nselect person_name\\nfrom t\\nwhere accumu_weight <= 1000\\norder by turn desc\\nlimit 1\\n```\\n\\nSub query\\n```\\nselect person_name\\nfrom queue a\\nwhere (\\n    select sum(weight) from queue b\\n    where a.turn>=b.turn\\n)<= 1000\\norder by a.turn desc\\nlimit 1\\n```",
                "solutionTags": [],
                "code": "```\\nselect a.person_name\\nfrom queue a\\njoin queue b on a.turn>=b.turn\\ngroup by a.person_id\\nhaving sum(b.weight)<=1000\\norder by a.turn desc\\nlimit 1\\n```\n```\\nwith t as\\n    (select *,\\n        sum(weight) over(order by turn) accumu_weight\\n    from queue)\\n\\nselect person_name\\nfrom t\\nwhere accumu_weight <= 1000\\norder by turn desc\\nlimit 1\\n```\n```\\nselect person_name\\nfrom queue a\\nwhere (\\n    select sum(weight) from queue b\\n    where a.turn>=b.turn\\n)<= 1000\\norder by a.turn desc\\nlimit 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 696844,
                "title": "mysql-solution-beat-99",
                "content": "```\\n\\nSELECT person_name\\nFROM (SELECT person_name, turn, SUM(weight) OVER (order by turn) as sum_weight FROM Queue) orders\\nWHERE sum_weight <= 1000\\nORDER BY turn DESC\\nLIMIT 1\\n```",
                "solutionTags": [],
                "code": "```\\n\\nSELECT person_name\\nFROM (SELECT person_name, turn, SUM(weight) OVER (order by turn) as sum_weight FROM Queue) orders\\nWHERE sum_weight <= 1000\\nORDER BY turn DESC\\nLIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 652281,
                "title": "faster-than-92-mysql",
                "content": "select person_name\\nfrom\\n(\\nselect \\nperson_name,turn,\\nsum(weight)over(order by turn asc) as total\\nfrom queue\\n    )sub\\nwhere total<=1000\\norder by turn desc\\nlimit 1",
                "solutionTags": [],
                "code": "select person_name\\nfrom\\n(\\nselect \\nperson_name,turn,\\nsum(weight)over(order by turn asc) as total\\nfrom queue\\n    )sub\\nwhere total<=1000\\norder by turn desc\\nlimit 1",
                "codeTag": "Unknown"
            },
            {
                "id": 649086,
                "title": "simple-mysql-beats-90-with-window-function-no-join",
                "content": "```\\nSELECT person_name FROM \\n    (SELECT person_name \\n            ,SUM(weight) over(ORDER BY turn) cum_sum FROM Queue) A\\nWHERE cum_sum <= 1000 \\nORDER BY cum_sum DESC LIMIT 1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT person_name FROM \\n    (SELECT person_name \\n            ,SUM(weight) over(ORDER BY turn) cum_sum FROM Queue) A\\nWHERE cum_sum <= 1000 \\nORDER BY cum_sum DESC LIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 626588,
                "title": "just-1-sum-window-fn-speed-83th-percentile",
                "content": "select top 1 person_name from\\n(select person_name, sum(weight) over (order by turn) as cum_weight from queue) a\\nwhere cum_weight<=1000 order by cum_weight desc",
                "solutionTags": [],
                "code": "select top 1 person_name from\\n(select person_name, sum(weight) over (order by turn) as cum_weight from queue) a\\nwhere cum_weight<=1000 order by cum_weight desc",
                "codeTag": "Unknown"
            },
            {
                "id": 625648,
                "title": "mysql-clear-solution-using-variable",
                "content": "```\\nSELECT person_name FROM\\n(\\n    SELECT person_name, @total_weight := @total_weight + weight total_weight\\n    FROM Queue, (SELECT @total_weight := 0) x\\n    ORDER BY turn\\n) y\\nWHERE total_weight <= 1000\\nORDER BY total_weight DESC LIMIT 1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT person_name FROM\\n(\\n    SELECT person_name, @total_weight := @total_weight + weight total_weight\\n    FROM Queue, (SELECT @total_weight := 0) x\\n    ORDER BY turn\\n) y\\nWHERE total_weight <= 1000\\nORDER BY total_weight DESC LIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 551388,
                "title": "mysql-a-simple-and-fast-solution-using-user-defined-variable-beat-98",
                "content": "```\\nSELECT\\n    person_name\\nFROM\\n    (SELECT\\n        q.person_name,\\n        @cum_weight:= @cum_weight + q.weight cum_weight\\n        FROM\\n        Queue q JOIN (SELECT @cum_weight:= 0) t1\\n    ORDER BY\\n        q.turn) t2\\nWHERE\\n    cum_weight <= 1000\\nORDER BY\\n    cum_weight DESC\\nLIMIT 1;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n    person_name\\nFROM\\n    (SELECT\\n        q.person_name,\\n        @cum_weight:= @cum_weight + q.weight cum_weight\\n        FROM\\n        Queue q JOIN (SELECT @cum_weight:= 0) t1\\n    ORDER BY\\n        q.turn) t2\\nWHERE\\n    cum_weight <= 1000\\nORDER BY\\n    cum_weight DESC\\nLIMIT 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 548042,
                "title": "easy-solution",
                "content": "```\\n\\nselect person_name\\nfrom\\n(\\nselect a.turn, a.person_name, sum(b.weight) as total_weight\\nfrom queue a\\n    join queue b on b.turn <= a.turn\\ngroup by a.turn\\n)o\\nwhere total_weight <= 1000\\norder by total_weight desc\\nlimit 1;\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nselect person_name\\nfrom\\n(\\nselect a.turn, a.person_name, sum(b.weight) as total_weight\\nfrom queue a\\n    join queue b on b.turn <= a.turn\\ngroup by a.turn\\n)o\\nwhere total_weight <= 1000\\norder by total_weight desc\\nlimit 1;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 534809,
                "title": "easy-to-understand",
                "content": "select top 1 person_name from \\n(\\nSELECT Person_name,turn,sum(weight) over(ORDER BY turn ASC) as cummulative_weight \\n    \\nFROM Queue\\n   \\n)x \\n\\n Where cummulative_weight   <= 1000\\norder by turn desc",
                "solutionTags": [],
                "code": "select top 1 person_name from \\n(\\nSELECT Person_name,turn,sum(weight) over(ORDER BY turn ASC) as cummulative_weight \\n    \\nFROM Queue\\n   \\n)x \\n\\n Where cummulative_weight   <= 1000\\norder by turn desc",
                "codeTag": "Unknown"
            },
            {
                "id": 478790,
                "title": "ms-sql-using-running-sum",
                "content": "\\u6211\\u7528\\u7684window function\\u5148\\u6C42\\u4E86running sum \\u7136\\u540E\\u622A\\u53D6\\u51FA\\u5C0F\\u4E8E\\u7B49\\u4E8E1000\\u7684row\\uFF0C\\u7136\\u540E\\u964D\\u5E8F\\u6392\\u5E8F\\u53D6top1\\u3002\\n\\n\\n```\\nselect top 1 person_name from \\n(\\n    select person_name, turn, sum(weight) over (order by turn) as running_total from Queue\\n) as sub \\nwhere sub.running_total <= 1000 \\norder by running_total DESC;\\n```\\n",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect top 1 person_name from \\n(\\n    select person_name, turn, sum(weight) over (order by turn) as running_total from Queue\\n) as sub \\nwhere sub.running_total <= 1000 \\norder by running_total DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 454249,
                "title": "mysql-solution-using-variables",
                "content": "SELECT DISTINCT person_name FROM\\n(\\nSELECT person_id,person_name,turn,\\n@total_weight:=weight+@total_weight AS t,\\n@in_elevator:=CASE WHEN @total_weight>1000 THEN 0 ELSE @in_elevator END AS i\\nFROM (SELECT * FROM Queue ORDER BY turn) AS q,\\n(SELECT @total_weight:=0,@in_elevator:=1) AS u\\n) AS final\\nWHERE i=1\\nORDER BY turn DESC\\nLIMIT 1;",
                "solutionTags": [],
                "code": "SELECT DISTINCT person_name FROM\\n(\\nSELECT person_id,person_name,turn,\\n@total_weight:=weight+@total_weight AS t,\\n@in_elevator:=CASE WHEN @total_weight>1000 THEN 0 ELSE @in_elevator END AS i\\nFROM (SELECT * FROM Queue ORDER BY turn) AS q,\\n(SELECT @total_weight:=0,@in_elevator:=1) AS u\\n) AS final\\nWHERE i=1\\nORDER BY turn DESC\\nLIMIT 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 448818,
                "title": "mssql",
                "content": "SELECT\\nTOP 1 person_name\\nFROM\\n(SELECT\\nperson_name, SUM(weight) OVER(ORDER BY turn ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS wgt\\nFROM Queue) AS sub\\nWHERE sub.wgt <= 1000\\nORDER BY sub.wgt DESC",
                "solutionTags": [],
                "code": "SELECT\\nTOP 1 person_name\\nFROM\\n(SELECT\\nperson_name, SUM(weight) OVER(ORDER BY turn ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS wgt\\nFROM Queue) AS sub\\nWHERE sub.wgt <= 1000\\nORDER BY sub.wgt DESC",
                "codeTag": "Unknown"
            },
            {
                "id": 390350,
                "title": "ms-sql-sum-window-function",
                "content": "```\\nselect top 1 person_name from\\n(select person_name,weight,sum(weight) over(order by turn) as run_weight\\nfrom queue) a\\nwhere run_weight<=1000\\ngroup by person_name\\norder by max(run_weight) desc\\n\\n```",
                "solutionTags": [],
                "code": "```\\nselect top 1 person_name from\\n(select person_name,weight,sum(weight) over(order by turn) as run_weight\\nfrom queue) a\\nwhere run_weight<=1000\\ngroup by person_name\\norder by max(run_weight) desc\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4091613,
                "title": "using-subquery",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith cte as (\\nSELECT\\n        *,\\n        SUM(weight) OVER (ORDER BY turn) AS total_weight\\n    FROM Queue\\n)\\nselect person_name  from cte where total_weight <= 1000 \\norder by total_weight desc limit 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith cte as (\\nSELECT\\n        *,\\n        SUM(weight) OVER (ORDER BY turn) AS total_weight\\n    FROM Queue\\n)\\nselect person_name  from cte where total_weight <= 1000 \\norder by total_weight desc limit 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4090629,
                "title": "easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect person_name from \\n        (select * , sum(Weight) over(order by turn) as cum_weight from Queue) Qu\\n        where cum_weight <= 1000 order by cum_weight desc limit 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect person_name from \\n        (select * , sum(Weight) over(order by turn) as cum_weight from Queue) Qu\\n        where cum_weight <= 1000 order by cum_weight desc limit 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4088132,
                "title": "mysql-solution-with-over-beats-90-61",
                "content": "\\n\\n# Code\\n```\\nSELECT FIRST_VALUE(person_name) OVER (ORDER BY total_weight DESC) as person_name\\nFROM\\n(SELECT person_name, turn, SUM(weight) OVER (ORDER BY turn) as total_weight\\nFROM Queue\\nORDER BY turn) as subset\\nWHERE subset.total_weight <=1000\\nLIMIT 1;\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT FIRST_VALUE(person_name) OVER (ORDER BY total_weight DESC) as person_name\\nFROM\\n(SELECT person_name, turn, SUM(weight) OVER (ORDER BY turn) as total_weight\\nFROM Queue\\nORDER BY turn) as subset\\nWHERE subset.total_weight <=1000\\nLIMIT 1;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4079965,
                "title": "beats-99-of-the-users",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nWITH CTE AS(\\n  SELECT *, SUM(weight) OVER(ORDER BY turn) AS roll_sum\\n  FROM Queue\\n  ORDER BY turn\\n)\\n\\nSELECT person_name \\nFROM CTE\\nWHERE roll_sum <= 1000\\nORDER BY roll_sum DESC\\nLIMIT 1;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nWITH CTE AS(\\n  SELECT *, SUM(weight) OVER(ORDER BY turn) AS roll_sum\\n  FROM Queue\\n  ORDER BY turn\\n)\\n\\nSELECT person_name \\nFROM CTE\\nWHERE roll_sum <= 1000\\nORDER BY roll_sum DESC\\nLIMIT 1;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4075106,
                "title": "pandas-two-lines-of-code-and-one-line-of-code-with-cumsum",
                "content": "# Intuition\\nPandas have few functions that can do cumulative operations: cummin rolling minimum, cummax = rolling maximum, cumprod = cumulative multiplication, and finally cumsum = cumulative sum. Thats exactly what we want. Whats most important - to get it right rows, must be in right order -> that\\'s why first, we have to sort. Then limit the dataframe to maximum of 1000, and return last row name.\\n\\n# Approach\\n1. sort dataframe by \\'turn\\'\\n2. create new columns \\'cumulative_sum\\' with use of `queue[\\'weight\\'].cumsum()`\\n3. limit dataframe to maximum of 1000 \\'cumulative_sum\\'.\\n4. return last rows `person_name`\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef last_passenger(queue: pd.DataFrame) -> pd.DataFrame:\\n    queue = queue.sort_values(\\'turn\\')\\n    return queue.assign(cumulative_sum = queue[\\'weight\\'].cumsum()).query(\"cumulative_sum <= 1000\").tail(1)[[\\'person_name\\']] \\n\\n```\\nAlternatively we can do it all in one line, but it\\'s not recomennded since we have to sort two times in this proces - first to get rows in right order, then to get weight for cumulative_sum in right order\\n\\n```\\nimport pandas as pd\\n\\ndef last_passenger(queue: pd.DataFrame) -> pd.DataFrame:\\n    return queue.sort_values(\\'turn\\').assign(cs = queue.sort_values(\\'turn\\')[\\'weight\\'].cumsum()).query(\"cs <= 1000\").tail(1)[[\\'person_name\\']] \\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef last_passenger(queue: pd.DataFrame) -> pd.DataFrame:\\n    queue = queue.sort_values(\\'turn\\')\\n    return queue.assign(cumulative_sum = queue[\\'weight\\'].cumsum()).query(\"cumulative_sum <= 1000\").tail(1)[[\\'person_name\\']] \\n\\n```\n```\\nimport pandas as pd\\n\\ndef last_passenger(queue: pd.DataFrame) -> pd.DataFrame:\\n    return queue.sort_values(\\'turn\\').assign(cs = queue.sort_values(\\'turn\\')[\\'weight\\'].cumsum()).query(\"cs <= 1000\").tail(1)[[\\'person_name\\']] \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4074787,
                "title": "two-solutions-best-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code1\\n```\\n# Write your MySQL query statement below\\nSELECT person_name FROM Queue\\nWHERE turn = (\\n    SELECT MAX(turn) as turn FROM\\n    (\\n        SELECT q1.turn\\n        FROM Queue q1 JOIN QUEUE q2 \\n        ON q1.turn >= q2.turn\\n        GROUP BY q1.turn\\n        HAVING SUM(q2.weight) <= 1000\\n    ) as table1\\n);\\n```\\n#**Code2**\\n```\\nSELECT \\n    q1.person_name\\nFROM Queue q1 JOIN Queue q2 ON q1.turn >= q2.turn\\nGROUP BY q1.turn\\nHAVING SUM(q2.weight) <= 1000\\nORDER BY SUM(q2.weight) DESC\\nLIMIT 1\\n```\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT person_name FROM Queue\\nWHERE turn = (\\n    SELECT MAX(turn) as turn FROM\\n    (\\n        SELECT q1.turn\\n        FROM Queue q1 JOIN QUEUE q2 \\n        ON q1.turn >= q2.turn\\n        GROUP BY q1.turn\\n        HAVING SUM(q2.weight) <= 1000\\n    ) as table1\\n);\\n```\n```\\nSELECT \\n    q1.person_name\\nFROM Queue q1 JOIN Queue q2 ON q1.turn >= q2.turn\\nGROUP BY q1.turn\\nHAVING SUM(q2.weight) <= 1000\\nORDER BY SUM(q2.weight) DESC\\nLIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4074653,
                "title": "pandas-simple-solution-by-using-algorithm",
                "content": "\\n    import pandas as pd\\n\\n    def last_passenger(queue: pd.DataFrame) -> pd.DataFrame:\\n        queue = queue.sort_values(by = \\'turn\\')\\n        queue.index = [i for i in range(len(queue))]\\n        last_name = \\'\\'\\n        total_weight = 0\\n        for i in range(len(queue[\\'weight\\'])):\\n            if queue[\\'weight\\'][i] + total_weight <= 1000:\\n                last_name = queue.loc[i ,\\'person_name\\']\\n                total_weight += queue.loc[i, \\'weight\\']\\n            else:\\n                return pd.DataFrame({\"person_name\" : [last_name]})\\n        \\n        return pd.DataFrame({\"person_name\" : [last_name]})",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "\\n    import pandas as pd\\n\\n    def last_passenger(queue: pd.DataFrame) -> pd.DataFrame:\\n        queue = queue.sort_values(by = \\'turn\\')\\n        queue.index = [i for i in range(len(queue))]\\n        last_name = \\'\\'\\n        total_weight = 0\\n        for i in range(len(queue[\\'weight\\'])):\\n            if queue[\\'weight\\'][i] + total_weight <= 1000:\\n                last_name = queue.loc[i ,\\'person_name\\']\\n                total_weight += queue.loc[i, \\'weight\\']\\n            else:\\n                return pd.DataFrame({\"person_name\" : [last_name]})\\n        \\n        return pd.DataFrame({\"person_name\" : [last_name]})",
                "codeTag": "Python3"
            },
            {
                "id": 4074473,
                "title": "sql-server-solution-beats-79-62-runtime-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nwith cte as\\n(\\n  select *, sum(Weight) over (order by Turn) as Total_Weight  from Queue\\n)\\nselect top 1 person_name from cte\\nwhere Total_Weight<=1000\\norder by Total_Weight desc\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nwith cte as\\n(\\n  select *, sum(Weight) over (order by Turn) as Total_Weight  from Queue\\n)\\nselect top 1 person_name from cte\\nwhere Total_Weight<=1000\\norder by Total_Weight desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4074190,
                "title": "",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nwith cte as (select coalesce(sum(weight) over (order by turn rows between unbounded preceding and current row)) as weight ,person_name,turn from queue)\\n\\n\\nselect person_name from cte\\nwhere weight<=1000\\norder by turn desc\\nlimit  1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith cte as (select coalesce(sum(weight) over (order by turn rows between unbounded preceding and current row)) as weight ,person_name,turn from queue)\\n\\n\\nselect person_name from cte\\nwhere weight<=1000\\norder by turn desc\\nlimit  1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4072297,
                "title": "mysql-solution-using-sub-queries",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect Q.person_name\\nfrom (\\n    select *,sum(Weight) over (order by turn asc) as total_wt \\n    from Queue\\n) Q\\nwhere total_wt<=1000\\norder by total_wt desc\\nLIMIT 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect Q.person_name\\nfrom (\\n    select *,sum(Weight) over (order by turn asc) as total_wt \\n    from Queue\\n) Q\\nwhere total_wt<=1000\\norder by total_wt desc\\nLIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4069796,
                "title": "easy-to-understand-with-sum-over",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nWITH CTE AS (\\n  SELECT \\n    person_name, \\n    SUM(weight) OVER(ORDER BY turn ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) total_at_turn\\n  FROM Queue\\n)\\nSELECT person_name\\nFROM CTE\\nWHERE total_at_turn <= 1000\\nORDER BY total_at_turn DESC\\nLIMIT 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nWITH CTE AS (\\n  SELECT \\n    person_name, \\n    SUM(weight) OVER(ORDER BY turn ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) total_at_turn\\n  FROM Queue\\n)\\nSELECT person_name\\nFROM CTE\\nWHERE total_at_turn <= 1000\\nORDER BY total_at_turn DESC\\nLIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4065486,
                "title": "pandas-solution-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ni sorted dataframe by turn\\ni created loop going through every row\\nthere i added one by one weight and breaked the loop when sum of weight exceeded 1000\\nthen i stored last person name in an variable and returned it.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef last_passenger(queue: pd.DataFrame) -> pd.DataFrame:\\n        # Sort the DataFrame by \\'turn\\' in ascending order\\n    queue = queue.sort_values(by=\\'turn\\')\\n    \\n    # Initialize variables\\n    cumulative_weight = 0\\n    last_person = None\\n    \\n    # Iterate through the DataFrame\\n    for index, row in queue.iterrows():\\n        print(index,\" ||  \",row)\\n        cumulative_weight += row[\\'weight\\']\\n        print(cumulative_weight,\"  ||  \",row[\\'weight\\'])\\n        if cumulative_weight <= 1000:\\n            last_person = row[\\'person_name\\']\\n        else:\\n            break\\n    \\n    # Create a new DataFrame to hold the result\\n    result_df = pd.DataFrame({\\'person_name\\': [last_person]})\\n    \\n    return result_df\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef last_passenger(queue: pd.DataFrame) -> pd.DataFrame:\\n        # Sort the DataFrame by \\'turn\\' in ascending order\\n    queue = queue.sort_values(by=\\'turn\\')\\n    \\n    # Initialize variables\\n    cumulative_weight = 0\\n    last_person = None\\n    \\n    # Iterate through the DataFrame\\n    for index, row in queue.iterrows():\\n        print(index,\" ||  \",row)\\n        cumulative_weight += row[\\'weight\\']\\n        print(cumulative_weight,\"  ||  \",row[\\'weight\\'])\\n        if cumulative_weight <= 1000:\\n            last_person = row[\\'person_name\\']\\n        else:\\n            break\\n    \\n    # Create a new DataFrame to hold the result\\n    result_df = pd.DataFrame({\\'person_name\\': [last_person]})\\n    \\n    return result_df\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4065349,
                "title": "pandas-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef last_passenger(queue: pd.DataFrame) -> pd.DataFrame:\\n    \\n    sort_queue = queue.sort_values(by=\\'turn\\', ascending=True)\\n    sort_queue[\\'Total Weight\\'] = sort_queue[\\'weight\\'].cumsum()\\n    return sort_queue[sort_queue[\\'Total Weight\\'] <= 1000][[\\'person_name\\']].tail(1)\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef last_passenger(queue: pd.DataFrame) -> pd.DataFrame:\\n    \\n    sort_queue = queue.sort_values(by=\\'turn\\', ascending=True)\\n    sort_queue[\\'Total Weight\\'] = sort_queue[\\'weight\\'].cumsum()\\n    return sort_queue[sort_queue[\\'Total Weight\\'] <= 1000][[\\'person_name\\']].tail(1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4063953,
                "title": "sql-window-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n# Write your MySQL query statement below\\nwith cte as (\\n    select person_name, sum(weight) over (order by turn) as running_total\\n    from queue q\\n)\\nselect person_name from cte\\nwhere running_total <= 1000\\norder by running_total desc\\nlimit 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n# Write your MySQL query statement below\\nwith cte as (\\n    select person_name, sum(weight) over (order by turn) as running_total\\n    from queue q\\n)\\nselect person_name from cte\\nwhere running_total <= 1000\\norder by running_total desc\\nlimit 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4061488,
                "title": "very-easy-mysql-beats-maximum-mysql-solutions",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT person_name FROM\\n(SELECT *, SUM(weight) OVER (ORDER BY turn ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as Total_Weight\\nFROM Queue) as a\\nWHERE total_weight <= 1000\\nORDER BY total_weight DESC\\nLIMIT 1;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT person_name FROM\\n(SELECT *, SUM(weight) OVER (ORDER BY turn ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as Total_Weight\\nFROM Queue) as a\\nWHERE total_weight <= 1000\\nORDER BY total_weight DESC\\nLIMIT 1;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4061462,
                "title": "mysql-solution-using-window-function",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect t.person_name\\nfrom (\\n  select q.person_name, sum(q.weight) over(order by q.turn) as total_weight\\n  from queue q\\n) as t\\nwhere t.total_weight <= 1000\\norder by t.turn desc\\nlimit 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect t.person_name\\nfrom (\\n  select q.person_name, sum(q.weight) over(order by q.turn) as total_weight\\n  from queue q\\n) as t\\nwhere t.total_weight <= 1000\\norder by t.turn desc\\nlimit 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4060339,
                "title": "simple-solution-with-over-without-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT person_name\\nFROM (\\n      SELECT person_name, turn, weight,\\n      SUM(weight) OVER (ORDER BY turn)\\n      AS total_weight\\n      FROM Queue\\n      ORDER BY turn\\n      ) AS subq_1\\nWHERE total_weight <=1000\\nORDER BY turn DESC\\nLIMIT 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT person_name\\nFROM (\\n      SELECT person_name, turn, weight,\\n      SUM(weight) OVER (ORDER BY turn)\\n      AS total_weight\\n      FROM Queue\\n      ORDER BY turn\\n      ) AS subq_1\\nWHERE total_weight <=1000\\nORDER BY turn DESC\\nLIMIT 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057219,
                "title": "mysql-easy-solution-using-join",
                "content": "\\n\\n# Code\\n```\\nSELECT q1.person_name \\nFROM Queue q1 \\nJOIN Queue q2 ON q1.turn >= q2.turn\\nGROUP BY q1.turn\\nHAVING SUM(q2.weight) <= 1000\\nORDER BY SUM(q2.weight) DESC \\nLIMIT 1;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nSELECT q1.person_name \\nFROM Queue q1 \\nJOIN Queue q2 ON q1.turn >= q2.turn\\nGROUP BY q1.turn\\nHAVING SUM(q2.weight) <= 1000\\nORDER BY SUM(q2.weight) DESC \\nLIMIT 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055919,
                "title": "oracle-1027ms-beats-98-21-of-users-with-oracle",
                "content": "\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nselect person_name \\n from\\n(select \\nturn,\\nperson_name, \\nsum(weight ) over(order by turn) as Total_Weight\\nfrom Queue \\norder by turn desc\\n)\\nwhere Total_Weight <=1000\\nand ROWNUM = 1\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect person_name \\n from\\n(select \\nturn,\\nperson_name, \\nsum(weight ) over(order by turn) as Total_Weight\\nfrom Queue \\norder by turn desc\\n)\\nwhere Total_Weight <=1000\\nand ROWNUM = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055553,
                "title": "beats-99-36-performing-running-total-in-ms-sql-server-window-function-and-cte",
                "content": "# Approach\\n## Running Total method\\nA running total or rolling total is the summation of a sequence of numbers which is updated each time a new number is added to the sequence, by adding the value of the new number to the previous running total. \\n\\n# Complexity\\n- Time complexity: 1901ms\\n- Space complexity: 0\\n\\n# Code\\n```\\nwith W_Queue as (\\n    select person_name, sum(weight) over (order by turn) as running_weight from Queue\\n)\\nselect top 1 person_name from W_Queue\\n    where running_weight <= 1000\\n    order by running_weight desc\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nwith W_Queue as (\\n    select person_name, sum(weight) over (order by turn) as running_weight from Queue\\n)\\nselect top 1 person_name from W_Queue\\n    where running_weight <= 1000\\n    order by running_weight desc\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4053627,
                "title": "simple-solution-using-window-function-beats-99-in-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nWITH cte AS\\n(\\nSELECT\\n    *,\\n    SUM(weight) OVER(ORDER BY turn) runn_sum\\nFROM\\n    queue\\nORDER BY turn DESC\\n)\\nSELECT\\n    person_name\\nFROM\\n    cte\\nWHERE\\n    runn_sum <= 1000\\nLIMIT 1\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/a71b7de6-964d-44fd-9d85-ae1c84dc52b6_1694915912.22411.png)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nWITH cte AS\\n(\\nSELECT\\n    *,\\n    SUM(weight) OVER(ORDER BY turn) runn_sum\\nFROM\\n    queue\\nORDER BY turn DESC\\n)\\nSELECT\\n    person_name\\nFROM\\n    cte\\nWHERE\\n    runn_sum <= 1000\\nLIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4051796,
                "title": "solution-with-cte-window-functions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith help as(\\nselect queue.*, \\nsum(weight) over(order by turn) as rollingweight from queue order by turn)\\nselect person_name from help \\nwhere rollingweight <= 1000\\norder by rollingweight desc\\nlimit 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith help as(\\nselect queue.*, \\nsum(weight) over(order by turn) as rollingweight from queue order by turn)\\nselect person_name from help \\nwhere rollingweight <= 1000\\norder by rollingweight desc\\nlimit 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4050021,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith cte as (select person_name ,\\n rank() over(order by tt) as rr\\n from \\n   (select \\n   person_name, \\n   sum(weight) over(order by turn) as tt\\n  from queue) a\\nwhere tt <= 1000) \\nselect person_name from cte where rr = (select max(rr) from cte)\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith cte as (select person_name ,\\n rank() over(order by tt) as rr\\n from \\n   (select \\n   person_name, \\n   sum(weight) over(order by turn) as tt\\n  from queue) a\\nwhere tt <= 1000) \\nselect person_name from cte where rr = (select max(rr) from cte)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4048973,
                "title": "window-function-limit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT person_name \\nFROM\\n(SELECT person_id, \\nperson_name,\\nSUM(weight) OVER (ORDER BY turn) as cumsum\\nFROM Queue) t\\nWHERE cumsum<=1000\\nORDER BY cumsum DESC\\nLIMIT 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT person_name \\nFROM\\n(SELECT person_id, \\nperson_name,\\nSUM(weight) OVER (ORDER BY turn) as cumsum\\nFROM Queue) t\\nWHERE cumsum<=1000\\nORDER BY cumsum DESC\\nLIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4048312,
                "title": "solution-with-variables-and-while-loop",
                "content": "\\n# Code\\n```\\n declare @sum int;\\n\\n declare @cnt int;\\n\\n declare @temp int;\\n\\nselect @sum = sum(weight) from Queue \\n\\nselect @cnt =max(turn) from Queue\\n \\n\\n while  (   @sum > 1000 )\\n\\n    begin\\n   \\n    select @temp = weight from Queue\\n    where turn =@cnt\\n    set @sum = @sum - @temp;\\n    set @cnt = @cnt -1 ;\\n\\n    end;\\n\\n select person_name from  Queue\\n where turn = @cnt\\n\\n\\n \\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n declare @sum int;\\n\\n declare @cnt int;\\n\\n declare @temp int;\\n\\nselect @sum = sum(weight) from Queue \\n\\nselect @cnt =max(turn) from Queue\\n \\n\\n while  (   @sum > 1000 )\\n\\n    begin\\n   \\n    select @temp = weight from Queue\\n    where turn =@cnt\\n    set @sum = @sum - @temp;\\n    set @cnt = @cnt -1 ;\\n\\n    end;\\n\\n select person_name from  Queue\\n where turn = @cnt\\n\\n\\n \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4047219,
                "title": "",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT q1.person_name\\nFROM Queue q1\\n    INNER JOIN Queue q2 ON q1.turn >= q2.turn\\nGROUP BY q1.turn\\nHAVING SUM(q2.weight) <= 1000\\nORDER BY SUM(q2.weight) DESC\\nLIMIT 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT q1.person_name\\nFROM Queue q1\\n    INNER JOIN Queue q2 ON q1.turn >= q2.turn\\nGROUP BY q1.turn\\nHAVING SUM(q2.weight) <= 1000\\nORDER BY SUM(q2.weight) DESC\\nLIMIT 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4046550,
                "title": "mysql-solution",
                "content": "# Code\\n```\\nwith t1 as(\\n    select person_id, person_name, turn, weight,\\n            sum(weight) over(\\n                order by turn\\n                rows unbounded preceding\\n            ) as cumm_sum\\n    from Queue\\n)\\nselect person_name from t1\\nwhere cumm_sum <= 1000\\norder by cumm_sum desc\\nlimit 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith t1 as(\\n    select person_id, person_name, turn, weight,\\n            sum(weight) over(\\n                order by turn\\n                rows unbounded preceding\\n            ) as cumm_sum\\n    from Queue\\n)\\nselect person_name from t1\\nwhere cumm_sum <= 1000\\norder by cumm_sum desc\\nlimit 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4045891,
                "title": "beats-100-speed-and-memory-oracle-rows-unbounded-preceding",
                "content": "# Code\\n```\\n/* Write your PL/SQL query statement below */\\nselect person_name from\\n( \\nselect person_name ,rank() over(order by cum desc) rnk from\\n(\\nselect turn,person_id ,person_name ,weight,sum(weight) OVER (ORDER BY turn ROWS UNBOUNDED PRECEDING) as cum from queue\\n) where cum <=1000\\n) where rnk=1\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect person_name from\\n( \\nselect person_name ,rank() over(order by cum desc) rnk from\\n(\\nselect turn,person_id ,person_name ,weight,sum(weight) OVER (ORDER BY turn ROWS UNBOUNDED PRECEDING) as cum from queue\\n) where cum <=1000\\n) where rnk=1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4045434,
                "title": "not-for-beginners-over-clause",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect person_name from (\\n                select * , sum(weight) over(order by turn) adj from queue\\n                        ) a\\nwhere adj <= 1000\\norder by adj desc\\nlimit 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect person_name from (\\n                select * , sum(weight) over(order by turn) adj from queue\\n                        ) a\\nwhere adj <= 1000\\norder by adj desc\\nlimit 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4044487,
                "title": "super-easy-window-function-offset-and-fetch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nwith cte1 as (\\nSELECT * ,\\nSUM(weight) over (order by turn ASC) as a\\nFROM QUEUE)\\n\\nSelect person_name \\nfrom cte1 \\nwhere a <= 1000 \\norder by turn ASC\\nOFFSET (select count(*) from cte1 where a <= 1000) - 1 ROWS\\nFETCH FIRST 1 row only\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nwith cte1 as (\\nSELECT * ,\\nSUM(weight) over (order by turn ASC) as a\\nFROM QUEUE)\\n\\nSelect person_name \\nfrom cte1 \\nwhere a <= 1000 \\norder by turn ASC\\nOFFSET (select count(*) from cte1 where a <= 1000) - 1 ROWS\\nFETCH FIRST 1 row only\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041725,
                "title": "short-n-simple-mysql-window-func-runtime-beats-78-56",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT t1.person_name \\nFROM (SELECT q.person_name, SUM(q.weight) OVER (ORDER BY q.turn) sum FROM Queue q) t1\\nWHERE t1.sum <= 1000\\nORDER BY t1.sum DESC \\nLIMIT 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT t1.person_name \\nFROM (SELECT q.person_name, SUM(q.weight) OVER (ORDER BY q.turn) sum FROM Queue q) t1\\nWHERE t1.sum <= 1000\\nORDER BY t1.sum DESC \\nLIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041043,
                "title": "easy-quick-soln-with-cte",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith cte as\\n(select *, SUM(weight) OVER (order by Turn) as t\\nfrom Queue)\\n\\nselect person_name\\nfrom cte\\nwhere t<=1000\\norder by t desc\\nlimit 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith cte as\\n(select *, SUM(weight) OVER (order by Turn) as t\\nfrom Queue)\\n\\nselect person_name\\nfrom cte\\nwhere t<=1000\\norder by t desc\\nlimit 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4040944,
                "title": "asked-in-wayfair-interview-using-window-function-to-make-it-simpler",
                "content": "# Code\\n```\\nwith cte as \\n( select * , sum(weight) over(order by turn rows between unbounded preceding and current row) as total_sum\\nfrom Queue )\\n\\nselect person_name\\nfrom cte \\nwhere total_sum <= 1000\\norder by turn desc\\nlimit 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith cte as \\n( select * , sum(weight) over(order by turn rows between unbounded preceding and current row) as total_sum\\nfrom Queue )\\n\\nselect person_name\\nfrom cte \\nwhere total_sum <= 1000\\norder by turn desc\\nlimit 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4038609,
                "title": "video-self-join",
                "content": "# Video\\nhttps://youtu.be/CRx6dGddhwk\\n\\n# Code\\n```\\nselect person_name FROM Queue where turn = (SELECT TOP 1 q1.turn FROM Queue AS q1\\nJOIN Queue AS q2 \\nON q2.turn <= q1.turn\\nGROUP BY q1.turn\\nHAVING SUM(q2.weight) <= 1000\\nORDER BY q1.turn desc);\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect person_name FROM Queue where turn = (SELECT TOP 1 q1.turn FROM Queue AS q1\\nJOIN Queue AS q2 \\nON q2.turn <= q1.turn\\nGROUP BY q1.turn\\nHAVING SUM(q2.weight) <= 1000\\nORDER BY q1.turn desc);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4038387,
                "title": "best-mysql-soltion-beats-99-34",
                "content": "# Approach\\nWindow function sum used in this query. Very simple to understand.\\n\\n```\\nSELECT *, SUM(weight) OVER(ORDER BY turn) as sums\\nFROM QUEUE\\nORDER BY turn\\n```\\nThis part will return the table calculated the weights.\\n![Screenshot from 2023-09-13 11-15-40.png](https://assets.leetcode.com/users/images/787ad51f-1317-48f4-88d9-02b7038b3e59_1694584016.6685116.png)\\n\\nThen its very easy just select the rows under 1000 weights and sort in descending order and just return the name of the top row.\\n\\nHurry its solved!!\\n\\n![Screenshot from 2023-09-13 11-12-19.png](https://assets.leetcode.com/users/images/d5cc5a37-c359-41e6-a125-ae3462481fa3_1694583800.9579566.png)\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT person_name FROM\\n(\\nSELECT *, SUM(weight) OVER(ORDER BY turn) as sums\\nFROM QUEUE \\nORDER BY turn\\n) as t1\\nWHERE sums <= 1000\\nORDER BY sums DESC\\nLIMIT 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT *, SUM(weight) OVER(ORDER BY turn) as sums\\nFROM QUEUE\\nORDER BY turn\\n```\n```\\n# Write your MySQL query statement below\\nSELECT person_name FROM\\n(\\nSELECT *, SUM(weight) OVER(ORDER BY turn) as sums\\nFROM QUEUE \\nORDER BY turn\\n) as t1\\nWHERE sums <= 1000\\nORDER BY sums DESC\\nLIMIT 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4035910,
                "title": "simple",
                "content": "# Intuition\\nKeep things simple as firstly find the output to get on board,then make use of sub query as that will find max weight of person in bus ansd the order it by respective turn.Use where to find the defining case to get and result of Distinction.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT person_name\\nFROM (\\n    SELECT \\n        person_name,\\n        SUM(weight) OVER (ORDER BY turn) AS   total_weight\\n    FROM Queue ORDER BY total_weight DESC\\n    ) \\nWHERE total_weight<=1000 AND rownum =1;\\n\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT person_name\\nFROM (\\n    SELECT \\n        person_name,\\n        SUM(weight) OVER (ORDER BY turn) AS   total_weight\\n    FROM Queue ORDER BY total_weight DESC\\n    ) \\nWHERE total_weight<=1000 AND rownum =1;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4031866,
                "title": "simple-to-understand-windowed-function",
                "content": "### Hello! It\\'s me Bipop from TMNT\\n\\nThis task helps us to know, what is that last lucky dude who can take the bus. Becuse the limit for the passengers is 1000 kilograms on the bus.\\n\\n### First step\\n\\nWe use *WITH cte AS* . There we choose name\\n\\n```\\nWITH cte AS (\\nSELECT \\n  person_name,\\n\\n\\n```\\n\\n\\u0410nd add column with name *total_weight*. \\nIn which we calculate how much weight the bus will carry if this person gets into it. \\n*SUM(weight) OVER(ORDER BY turn) AS total_weight*\\n\\n---\\n\\n\\n\\n\\n```\\nWITH cte AS (\\nSELECT \\n  person_name, SUM(weight) OVER(ORDER BY turn) AS total_weight*\\nFROM \\n    Queue AS a1\\n```\\n\\n\\n**Explanation**: Initially the bus can have 1000 kilograms to carry, becuse no one person in there. \\nThen one human sits in the bus, weight limit decreases  on human weight. \\nSo now in the bus 0 + the weight of the first person who sat in the bus. When second human has sat in the bus, his weight adds to weight there. And on and on unitl the limit weight closes or equals 1000.\\n\\n```\\nSELECT \\n  person_name\\nFROM \\n  cte\\n```\\n\\n### Second step\\n\\n\\n---\\n\\nWhen filter value where *total_weight* + weight of the last person who can sit in bus, but not more than 1000. \\n*WHERE total_weight <= 1000*\\n\\nWe sort values descending method, because we choose all people who already sit in the bus by the queue and anyone adds his weight to the total weight in bus. \\n*ORDER BY total_weight DESC*\\n\\nThen we choose the one name, who sit the last. \\n*LIMIT 1*\\n\\n---\\n```\\nSELECT \\n  person_name\\nFROM \\n  cte\\nWHERE \\n  total_weight <= 1000\\nORDER BY total_weight DESC\\nLIMIT 1\\n```\\n\\n# Code\\n\\n```\\n# Write your MySQL query statement below\\n\\nWITH cte AS (\\nSELECT \\n  person_name, SUM(weight) OVER(ORDER BY turn) AS total_weight\\nFROM \\n  Queue AS a1\\n)\\n\\nSELECT \\n  person_name\\nFROM \\n  cte\\nWHERE \\n  total_weight <= 1000\\nORDER BY total_weight DESC\\nLIMIT 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nWITH cte AS (\\nSELECT \\n  person_name,\\n\\n\\n```\n```\\nWITH cte AS (\\nSELECT \\n  person_name, SUM(weight) OVER(ORDER BY turn) AS total_weight*\\nFROM \\n    Queue AS a1\\n```\n```\\nSELECT \\n  person_name\\nFROM \\n  cte\\n```\n```\\nSELECT \\n  person_name\\nFROM \\n  cte\\nWHERE \\n  total_weight <= 1000\\nORDER BY total_weight DESC\\nLIMIT 1\\n```\n```\\n# Write your MySQL query statement below\\n\\nWITH cte AS (\\nSELECT \\n  person_name, SUM(weight) OVER(ORDER BY turn) AS total_weight\\nFROM \\n  Queue AS a1\\n)\\n\\nSELECT \\n  person_name\\nFROM \\n  cte\\nWHERE \\n  total_weight <= 1000\\nORDER BY total_weight DESC\\nLIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4030749,
                "title": "easy-cte-sum-over",
                "content": "# Code\\n```\\nWITH cte AS(\\n    SELECT *, sum(weight) OVER(ORDER BY turn) AS cumm\\n    FROM Queue\\n)\\nSELECT person_name\\nFROM cte\\nWHERE cumm<=1000\\nORDER BY cumm DESC\\nLIMIT 1;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nWITH cte AS(\\n    SELECT *, sum(weight) OVER(ORDER BY turn) AS cumm\\n    FROM Queue\\n)\\nSELECT person_name\\nFROM cte\\nWHERE cumm<=1000\\nORDER BY cumm DESC\\nLIMIT 1;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4030021,
                "title": "easy-efficient-solutions-2-approaches-beginner-friendly",
                "content": "# Code\\n```\\n--Approach 1 : Using Window function \\nwith cte as (\\nselect person_name, sum(weight) over(order by turn) as total_weight from queue)\\nselect person_name from cte where TOTAL_WEIGHT = (select max(TOTAL_WEIGHT) from cte where total_weight <= 1000 ) \\n\\n--Approach 2 : Using Self Join and Group By\\nwith cte1 as (\\nSELECT q1.turn, q1.person_name\\nFROM Queue q1 JOIN Queue q2 ON q1.turn >= q2.turn\\nGROUP BY q1.turn, q1.person_name\\nHAVING SUM(q2.weight) <= 1000 )\\nselect person_name from cte1 where turn= (select max(turn) from cte1)\\n\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n--Approach 1 : Using Window function \\nwith cte as (\\nselect person_name, sum(weight) over(order by turn) as total_weight from queue)\\nselect person_name from cte where TOTAL_WEIGHT = (select max(TOTAL_WEIGHT) from cte where total_weight <= 1000 ) \\n\\n--Approach 2 : Using Self Join and Group By\\nwith cte1 as (\\nSELECT q1.turn, q1.person_name\\nFROM Queue q1 JOIN Queue q2 ON q1.turn >= q2.turn\\nGROUP BY q1.turn, q1.person_name\\nHAVING SUM(q2.weight) <= 1000 )\\nselect person_name from cte1 where turn= (select max(turn) from cte1)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4026902,
                "title": "easy-to-understand-using-temporary-table",
                "content": "#On A.turn >= B.turn, this type a join is used to calculate the running sum.\\n\\nwith temp AS (\\n  select A.person_name As person_name,A.turn AS turn\\n  from queue AS A\\n  join queue AS B\\n  On A.turn >= B.turn\\n  group by A.turn\\n  having sum(B.weight) <= 1000\\n  order by A.turn\\n)\\nselect person_name\\nfrom temp\\nwhere turn IN\\n(\\n  select max(turn) from temp\\n)\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "#On A.turn >= B.turn, this type a join is used to calculate the running sum.\\n\\nwith temp AS (\\n  select A.person_name As person_name,A.turn AS turn\\n  from queue AS A\\n  join queue AS B\\n  On A.turn >= B.turn\\n  group by A.turn\\n  having sum(B.weight) <= 1000\\n  order by A.turn\\n)\\nselect person_name\\nfrom temp\\nwhere turn IN\\n(\\n  select max(turn) from temp\\n)\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 4025300,
                "title": "ms-sql-solution-using-windows-function-with-rows-between-clause",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nWITH CTE AS\\n(\\n\\tSELECT *, SUM(weight) OVER(ORDER BY turn ASC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS total_weight\\n\\tFROM Queue\\n)\\nSELECT TOP 1 person_name\\nFROM CTE\\nWHERE total_weight <= 1000\\nORDER BY total_weight DESC;\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nWITH CTE AS\\n(\\n\\tSELECT *, SUM(weight) OVER(ORDER BY turn ASC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS total_weight\\n\\tFROM Queue\\n)\\nSELECT TOP 1 person_name\\nFROM CTE\\nWHERE total_weight <= 1000\\nORDER BY total_weight DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4023028,
                "title": "mysql-detailed-explaination-self-join-cte",
                "content": "# Solution 1: Using Common Table Expressions (CTE) with Window Function\\n\\n**Query:**\\n```sql\\nWITH queue AS \\n( \\n   SELECT *, \\n          SUM(weight) OVER previous_rows AS total\\n   FROM Queue\\n   WINDOW previous_rows AS \\n        (ORDER BY turn ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)\\n) \\n\\nSELECT person_name\\nFROM queue\\nWHERE total <= 1000\\nORDER BY total DESC \\nLIMIT 1\\n```\\n\\n**Explanation:**\\n- **Common Table Expression (CTE):** We start by defining a CTE named \"queue.\" The CTE selects all columns from the \"Queue\" table and uses a window function to calculate the cumulative weight (`total`) as people board the bus. The window function sums the weights of previous rows, ordered by the \"turn\" column.\\n\\n- **Main Query:** In the main query, we select the \"person_name\" from the CTE where the cumulative weight (`total`) is less than or equal to 1000 kilograms. We order the results by `total` in descending order and limit the result to one row. This gives us the last person who can board the bus without exceeding the weight limit.\\n\\n**Advantages:**\\n1. **Flexibility:** This approach allows for more complex calculations and analysis if needed in the future.\\n2. **Maintainability:** The CTE structure makes it easier to update or modify the query without affecting the overall code.\\n\\n**Disadvantages:**\\n1. **Performance:** Window functions can be resource-intensive for large datasets, potentially impacting query performance.\\n2. **Complexity:** For those not familiar with window functions, the query might appear complex.\\n\\n# Solution 2: Using Self-Join and Grouping\\n\\n**Query:**\\n```sql\\nSELECT q1.person_name AS person_name\\nFROM Queue AS q1 \\nJOIN Queue AS q2 \\nON q1.turn >= q2.turn\\nGROUP BY q1.turn\\nHAVING SUM(q2.weight) <= 1000\\nORDER BY q1.turn DESC\\nLIMIT 1;\\n```\\n\\n**Explanation:**\\n- **Self-Join and Grouping:** In this solution, we perform a self-join on the \"Queue\" table. We join each row (person) in the table with all previous rows (persons) based on the \"turn\" column. This allows us to calculate the cumulative weight for each person by summing the weights of the previous persons who have boarded the bus.\\n\\n- **Grouping:** We then group the results by \"turn,\" effectively grouping each person with all previous persons they are responsible for. Within each group, we calculate the sum of weights (`SUM(q2.weight)`). This sum represents the total weight of all persons who have boarded the bus up to and including the current person.\\n\\n- **Main Query:** Finally, in the main query, we select the \"person_name\" from the groups where the sum of weights does not exceed 1000 kilograms. We order the results by \"turn\" in descending order to identify the last person who can board the bus within the weight limit.\\n\\n**Advantages:**\\n1. **Performance:** This approach can be more efficient for some database systems, especially for large datasets.\\n2. **Simplicity:** It uses standard SQL constructs like joins and grouping, making it easier to understand for those not familiar with window functions.\\n\\n**Disadvantages:**\\n1. **Limited Flexibility:** This approach may be less flexible if additional calculations or analysis are required in the future.\\n2. **Maintainability:** The query might be more challenging to modify or extend compared to the CTE-based approach.\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```sql\\nWITH queue AS \\n( \\n   SELECT *, \\n          SUM(weight) OVER previous_rows AS total\\n   FROM Queue\\n   WINDOW previous_rows AS \\n        (ORDER BY turn ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)\\n) \\n\\nSELECT person_name\\nFROM queue\\nWHERE total <= 1000\\nORDER BY total DESC \\nLIMIT 1\\n```\n```sql\\nSELECT q1.person_name AS person_name\\nFROM Queue AS q1 \\nJOIN Queue AS q2 \\nON q1.turn >= q2.turn\\nGROUP BY q1.turn\\nHAVING SUM(q2.weight) <= 1000\\nORDER BY q1.turn DESC\\nLIMIT 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4020500,
                "title": "easy-solution",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nwith cte as (\\n    select person_name, sum(weight) over (order by turn) as cumulative_sum\\n    from Queue\\n)\\nselect person_name\\nfrom cte\\nwhere cumulative_sum <= 1000\\norder by cumulative_sum desc\\nlimit 1 \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nwith cte as (\\n    select person_name, sum(weight) over (order by turn) as cumulative_sum\\n    from Queue\\n)\\nselect person_name\\nfrom cte\\nwhere cumulative_sum <= 1000\\norder by cumulative_sum desc\\nlimit 1 \\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4020382,
                "title": "easy-sql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect person_name \\nfrom queue a\\nwhere (select sum(weight) \\n       from queue \\n       where a.turn >= turn\\n       order by turn) <= 1000\\norder by turn desc\\nlimit 1;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect person_name \\nfrom queue a\\nwhere (select sum(weight) \\n       from queue \\n       where a.turn >= turn\\n       order by turn) <= 1000\\norder by turn desc\\nlimit 1;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4014352,
                "title": "running-total-weight-approach-fast-solution",
                "content": "# Approach\\nTo resolve this problem we need, firstly, arrange our queue from firt in line to last. Along with that, we can count running total weight of passengers in the line by the following code:\\n```\\nsum(weight) over(order by turn) as total_weight\\n```\\nThis one adds weight of current passenger in the line to total. It seems logical to order queue in ascending order, but we need descending one for further query. Having that done, we take only part of queue ending with the passenger, who adds to 1000 (or less) kilos and take the last person in line. But as we arranged it in descending order, we need first row from the table:\\n```\\nwhere total_weight<=1000\\nlimit 1\\n```\\n\\n# Complexity\\n- Time complexity: 1761ms\\n\\n- Space complexity: 0.00MB\\n\\n# Code\\n```\\nselect person_name\\nfrom (select\\n        turn,\\n        person_name,\\n        weight,\\n        sum(weight) over(order by turn) as total_weight\\n    from Queue\\n    order by turn desc) t\\nwhere total_weight<=1000\\nlimit 1\\n\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nsum(weight) over(order by turn) as total_weight\\n```\n```\\nwhere total_weight<=1000\\nlimit 1\\n```\n```\\nselect person_name\\nfrom (select\\n        turn,\\n        person_name,\\n        weight,\\n        sum(weight) over(order by turn) as total_weight\\n    from Queue\\n    order by turn desc) t\\nwhere total_weight<=1000\\nlimit 1\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4011815,
                "title": "simple-solution-no-join-no-group-by",
                "content": "# Write your MySQL query statement below\\n```\\nSELECT person_name\\nFROM (\\n\\t\\tSELECT person_name, turn, SUM(weight) OVER(order by turn) AS cumulative_sum\\n\\t\\tfrom Queue\\n\\t\\t) tmp\\nWHERE cumulative_sum<= 1000\\nORDER BY turn DESC\\nLIMIT 1\\n```\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT person_name\\nFROM (\\n\\t\\tSELECT person_name, turn, SUM(weight) OVER(order by turn) AS cumulative_sum\\n\\t\\tfrom Queue\\n\\t\\t) tmp\\nWHERE cumulative_sum<= 1000\\nORDER BY turn DESC\\nLIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4008707,
                "title": "mysql-solution-simple-one-using-cte",
                "content": "# Intuition\\n\\n# Code\\n```\\nwith cte as\\n(\\n\\n    select *,sum(weight) over(order by turn) as r_sum\\n    from queue\\n)\\nselect person_name from cte \\nwhere r_sum <=1000\\norder by r_sum desc\\nlimit 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith cte as\\n(\\n\\n    select *,sum(weight) over(order by turn) as r_sum\\n    from queue\\n)\\nselect person_name from cte \\nwhere r_sum <=1000\\norder by r_sum desc\\nlimit 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4008299,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith updated_table as (select person_name, sum(weight) over(order by turn) as cummulative_weight\\nfrom Queue)\\n\\nselect person_name from updated_table\\nwhere  cummulative_weight<=1000\\norder by cummulative_weight desc \\nlimit 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith updated_table as (select person_name, sum(weight) over(order by turn) as cummulative_weight\\nfrom Queue)\\n\\nselect person_name from updated_table\\nwhere  cummulative_weight<=1000\\norder by cummulative_weight desc \\nlimit 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4005726,
                "title": "beats-95-clear-easy-sql-step-by-step-correct-formatting-comprehensive-explanation",
                "content": "# \\u2757 Upvote \\u2B06 if you found this useful \\u2714\\n![image.png](https://assets.leetcode.com/users/images/2a7fc627-21f6-445d-8aaa-1bdaa50f9c0d_1693922329.1619954.png)\\n\\n# \\uD83D\\uDCA1 Intuition (hint)\\n\\nMore complicated but interesting problem that can be solved using subqueries and window functions with running sums. \\n\\n# \\uD83C\\uDFAF Approach (solution)\\n\\nLets divide the problem into several steps. \\n\\nFirst we will calculate the running sums for each person in the queue order. \\n\\nThe query below selects all person and calculates the sum of weight of all person before in queue (ORDER BY turn ROWS BETWEEN UNBOUNDED PRECEDING) up to the current person (AND CURRENT ROW). Then we ORDER BY running_sum ASCending. \\n```sql\\nSELECT\\n\\tperson_name\\n\\t, SUM(weight) OVER(ORDER BY turn ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS running_sum\\nFROM Queue\\nORDER BY running_sum ASC\\n```\\n\\nThen, using main query based on the subquery above, we SELECT all person WHERE the running_sum is below or equal 1000. \\n```sql\\nSELECT\\n\\tperson_name\\nFROM (\\n...\\n) AS table_with_sums\\nWHERE running_sum <= 1000\\n...\\n```\\n\\nAs the list is sorted by running_sum ascending, the last person in the filtered result will be the one we are looking for. \\n\\nDue to this, we can simply change change the ORDER to DESCending. This way the person we are looking for will be first in order. Then we LIMIT results to one and have our answer.\\n```sql\\n...\\nORDER BY running_sum DESC\\nLIMIT 1\\n```\\n\\n# \\uD83D\\uDCC8 Complexity\\n\\n- \\u23F1 Time complexity:\\nBeats 95% of solutions with MySQL (at the time of submission)\\n\\n- \\uD83D\\uDCBE Space complexity:\\nBeats 100% of solutions with MySQL (space complexity in case of this problem is constant for all solutions)\\n\\n# \\uD83D\\uDD25 Code\\n\\n```sql\\nSELECT\\n\\xA0 person_name\\nFROM (\\n\\xA0 SELECT\\n\\xA0 \\xA0 person_name\\n\\xA0 \\xA0 , SUM(weight) OVER(ORDER BY turn ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS running_sum\\n\\xA0 FROM Queue\\n\\xA0 ORDER BY running_sum ASC\\n) AS table_with_sums\\nWHERE running_sum <= 1000\\nORDER BY running_sum DESC\\nLIMIT 1;\\n```\\n# \\u2757 Upvote \\u2B06 if you found this useful \\u2714",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```sql\\nSELECT\\n\\tperson_name\\n\\t, SUM(weight) OVER(ORDER BY turn ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS running_sum\\nFROM Queue\\nORDER BY running_sum ASC\\n```\n```sql\\nSELECT\\n\\tperson_name\\nFROM (\\n...\\n) AS table_with_sums\\nWHERE running_sum <= 1000\\n...\\n```\n```sql\\n...\\nORDER BY running_sum DESC\\nLIMIT 1\\n```\n```sql\\nSELECT\\n\\xA0 person_name\\nFROM (\\n\\xA0 SELECT\\n\\xA0 \\xA0 person_name\\n\\xA0 \\xA0 , SUM(weight) OVER(ORDER BY turn ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS running_sum\\n\\xA0 FROM Queue\\n\\xA0 ORDER BY running_sum ASC\\n) AS table_with_sums\\nWHERE running_sum <= 1000\\nORDER BY running_sum DESC\\nLIMIT 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4004841,
                "title": "subquery-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect person_name\\nfrom(select *,1000-current_weight as intervals\\nfrom (select *, sum(weight) over(order by turn ASC) as current_weight\\nfrom Queue\\norder by turn ASC) as temp) as temp1\\nwhere intervals>=0 order by intervals ASC\\nlimit 1\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect person_name\\nfrom(select *,1000-current_weight as intervals\\nfrom (select *, sum(weight) over(order by turn ASC) as current_weight\\nfrom Queue\\norder by turn ASC) as temp) as temp1\\nwhere intervals>=0 order by intervals ASC\\nlimit 1\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4004419,
                "title": "cursor",
                "content": "# Code\\n```\\n/* Write your T-SQL query statement below */\\ndeclare c1 cursor\\nfor select person_name, weight \\n    from Queue \\n    order by turn\\nfor read only\\n\\ndeclare @name varchar(50), @wt int\\nopen c1\\ndeclare @last_person_name varchar(50)= null, @total_wt int = 0\\n\\nfetch c1 into @name , @wt\\nwhile @@fetch_status = 0 \\n    begin\\n        if (@total_wt + @wt) <= 1000\\n        begin\\n        set @total_wt = @total_wt+ @wt\\n        set @last_person_name = @name\\n        end\\n        else\\n        begin\\n            break\\n        end\\n    fetch c1 into @name , @wt\\n    end\\nclose c1\\ndeallocate c1\\nselect @last_person_name as person_name \\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\ndeclare c1 cursor\\nfor select person_name, weight \\n    from Queue \\n    order by turn\\nfor read only\\n\\ndeclare @name varchar(50), @wt int\\nopen c1\\ndeclare @last_person_name varchar(50)= null, @total_wt int = 0\\n\\nfetch c1 into @name , @wt\\nwhile @@fetch_status = 0 \\n    begin\\n        if (@total_wt + @wt) <= 1000\\n        begin\\n        set @total_wt = @total_wt+ @wt\\n        set @last_person_name = @name\\n        end\\n        else\\n        begin\\n            break\\n        end\\n    fetch c1 into @name , @wt\\n    end\\nclose c1\\ndeallocate c1\\nselect @last_person_name as person_name \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4002999,
                "title": "optimum-solution-beats-93",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nwith cte_1 as\\n(\\n  Select          person_name, sum(weight) over(order by turn) as Cumulative_Weight\\n  from            Queue\\n)\\nSelect    top 1 person_name\\nfrom      cte_1\\nwhere     Cumulative_weight <= 1000\\norder by  Cumulative_weight desc\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nwith cte_1 as\\n(\\n  Select          person_name, sum(weight) over(order by turn) as Cumulative_Weight\\n  from            Queue\\n)\\nSelect    top 1 person_name\\nfrom      cte_1\\nwhere     Cumulative_weight <= 1000\\norder by  Cumulative_weight desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4002134,
                "title": "using-temp-table-window-function-order-and-limit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nwith t1 as(\\n    select turn, person_id, person_name, sum(weight) over(order by turn) as Total\\n    from Queue\\n    order by turn\\n)\\nselect person_name\\nfrom t1\\nwhere Total <= 1000\\norder by Total desc\\nlimit 1\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith t1 as(\\n    select turn, person_id, person_name, sum(weight) over(order by turn) as Total\\n    from Queue\\n    order by turn\\n)\\nselect person_name\\nfrom t1\\nwhere Total <= 1000\\norder by Total desc\\nlimit 1\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4001420,
                "title": "short-solution",
                "content": "SELECT \\n    person_name\\nFROM Queue q1\\nWHERE (SELECT SUM(weight) FROM Queue q2 WHERE q2.turn <= q1.turn) <= 1000\\nORDER BY turn DESC\\nLIMIT 1;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "SELECT \\n    person_name\\nFROM Queue q1\\nWHERE (SELECT SUM(weight) FROM Queue q2 WHERE q2.turn <= q1.turn) <= 1000\\nORDER BY turn DESC\\nLIMIT 1;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4000511,
                "title": "best-solution-using-window-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nwith CTE as\\n(\\n  SELECT \\n        turn, person_name, weight,\\n        SUM(weight) OVER(ORDER BY turn ASC) AS tot_weight \\n    FROM Queue\\n    ORDER BY turn\\n)\\nSelect person_name\\nfrom CTE \\nwhere turn = (Select max(turn) from CTE where tot_weight<= 1000)\\n\\n  \\n    \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith CTE as\\n(\\n  SELECT \\n        turn, person_name, weight,\\n        SUM(weight) OVER(ORDER BY turn ASC) AS tot_weight \\n    FROM Queue\\n    ORDER BY turn\\n)\\nSelect person_name\\nfrom CTE \\nwhere turn = (Select max(turn) from CTE where tot_weight<= 1000)\\n\\n  \\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3999232,
                "title": "last-person-to-fit-in-the-bus",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT person_name\\nFROM Queue\\nWHERE turn = (SELECT MAX(turn) as turn \\nFROM (SELECT q1.turn\\nFROM Queue q1\\nJOIN Queue q2\\nON q1.turn >=q2.turn\\nGROUP BY q1.turn\\nHAVING SUM(q2.weight) <=1000) AS Queue_tab1);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT person_name\\nFROM Queue\\nWHERE turn = (SELECT MAX(turn) as turn \\nFROM (SELECT q1.turn\\nFROM Queue q1\\nJOIN Queue q2\\nON q1.turn >=q2.turn\\nGROUP BY q1.turn\\nHAVING SUM(q2.weight) <=1000) AS Queue_tab1);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3998602,
                "title": "simple-subquery",
                "content": "# Code\\n```\\nselect person_name\\nfrom (\\n  select person_name, sum(weight) over (order by turn) as total\\n  from queue\\n  order by turn\\n) as temp where total <= 1000\\norder by total desc\\nlimit 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect person_name\\nfrom (\\n  select person_name, sum(weight) over (order by turn) as total\\n  from queue\\n  order by turn\\n) as temp where total <= 1000\\norder by total desc\\nlimit 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3998358,
                "title": "sql-solution-without-using-joins",
                "content": "##  **Please Upvote my solution, if you find it helpful**\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen faced with the problem of finding a person\\'s name associated with a cumulative weight of either exactly 1000 or the nearest weight less than 1000, my initial thought is to leverage SQL window functions to calculate cumulative sums of weights. I would then need to filter and identify the person who meets the weight criteria.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, I would use the following approach:\\n1. Utilize a SQL window function (e.g., SUM() OVER) to calculate the cumulative sum of weights for each row, ordered by the \\'turn\\' column.\\n\\n2. Store the results of the cumulative sum calculation in a Common Table Expression (CTE) for further analysis.\\n\\n3. Filter the CTE data to select rows where the cumulative weight is less than or equal to 1000. This will include both weights exactly at 1000 and those closest to it.\\n\\n4. To ensure we retrieve only one name, order the filtered rows in descending order by the cumulative weight and limit the result to 1 row. This will give us the person name associated with either 1000 or the nearest lower weight.\\n\\n5. The final result would be the person\\'s name who meets the specified weight criteria.\\n\\nThis approach should efficiently identify the person\\'s name based on the given weight constraints.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nwith cte as (SELECT *, SUM(weight) OVER (ORDER BY turn) as w\\nFROM queue\\nORDER BY turn)\\n\\nSELECT person_name\\n  FROM cte\\n  WHERE w <= 1000\\n  ORDER BY w DESC\\n  limit 1\\n\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nwith cte as (SELECT *, SUM(weight) OVER (ORDER BY turn) as w\\nFROM queue\\nORDER BY turn)\\n\\nSELECT person_name\\n  FROM cte\\n  WHERE w <= 1000\\n  ORDER BY w DESC\\n  limit 1\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3997763,
                "title": "simple-subquery-and-window-sum-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect t.person_name from\\n(select person_name, turn, sum(weight) over(order by turn) as cumm_sum from Queue\\norder by turn) t \\nwhere t.cumm_sum<=1000\\norder by t.cumm_sum desc\\nlimit 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect t.person_name from\\n(select person_name, turn, sum(weight) over(order by turn) as cumm_sum from Queue\\norder by turn) t \\nwhere t.cumm_sum<=1000\\norder by t.cumm_sum desc\\nlimit 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3991152,
                "title": "simplest-sql-solution-cte-cumulative-sum-using-window-funtion-where-order-by-limit",
                "content": "\\n# Code\\n```\\n\\n\\n# Write your MySQL query statement below\\nWITH REQ_CTE AS (\\n\\t\\tSELECT *\\n\\t\\t\\t,SUM(weight) OVER (\\n\\t\\t\\t\\tORDER BY turn ASC\\n\\t\\t\\t\\t) AS weight_sum\\n\\t\\tFROM QUEUE\\n\\t\\t)\\n\\nSELECT person_name\\nFROM REQ_CTE\\nWHERE weight_sum <= 1000\\nORDER BY weight_sum DESC LIMIT 1\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n\\n\\n# Write your MySQL query statement below\\nWITH REQ_CTE AS (\\n\\t\\tSELECT *\\n\\t\\t\\t,SUM(weight) OVER (\\n\\t\\t\\t\\tORDER BY turn ASC\\n\\t\\t\\t\\t) AS weight_sum\\n\\t\\tFROM QUEUE\\n\\t\\t)\\n\\nSELECT person_name\\nFROM REQ_CTE\\nWHERE weight_sum <= 1000\\nORDER BY weight_sum DESC LIMIT 1\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3990660,
                "title": "easy-solution",
                "content": "\\n# Code\\n```\\nwith cte as (\\nselect turn, person_name, weight,\\nsum(weight) over (order by turn asc) as cum\\nfrom Queue\\norder by turn\\n)\\n\\nselect \\nperson_name as person_name\\nfrom cte\\nwhere cum <= 1000 \\norder by cum desc\\nlimit 1\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith cte as (\\nselect turn, person_name, weight,\\nsum(weight) over (order by turn asc) as cum\\nfrom Queue\\norder by turn\\n)\\n\\nselect \\nperson_name as person_name\\nfrom cte\\nwhere cum <= 1000 \\norder by cum desc\\nlimit 1\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3990135,
                "title": "beats-94-08-order-by-limit",
                "content": "# Approach\\nFirst calculate the total weight following the ascending turn\\uFF0C then select the one who has the neareast total weight to the limitation(1000) and does not exceed it.  At lase, select the result through LIMIT() function.\\n\\n\\n# Code\\n```\\nSELECT person_name\\nFROM(\\nSELECT *, sum(weight) OVER (ORDER BY turn) as totalweight\\nFROM Queue\\nORDER BY turn\\n) as t\\nWHERE t.totalweight <=1000\\nORDER BY t.totalweight desc\\nLIMIT 1;\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT person_name\\nFROM(\\nSELECT *, sum(weight) OVER (ORDER BY turn) as totalweight\\nFROM Queue\\nORDER BY turn\\n) as t\\nWHERE t.totalweight <=1000\\nORDER BY t.totalweight desc\\nLIMIT 1;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3990133,
                "title": "always-self-join-when-you-need-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT a.person_name\\nFROM Queue a JOIN Queue b\\nON a.turn >= b.turn\\nGROUP BY a.turn \\nHAVING SUM(b.weight) <= 1000 ORDER BY a.turn DESC LIMIT 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT a.person_name\\nFROM Queue a JOIN Queue b\\nON a.turn >= b.turn\\nGROUP BY a.turn \\nHAVING SUM(b.weight) <= 1000 ORDER BY a.turn DESC LIMIT 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3988870,
                "title": "a-simple-mysql-approach-which-incorporates-common-table-expressions",
                "content": "# Approach\\nThe query first creates two subqueries. The first subquery, ```subquery```, calculates the cumulative sum of the weight column in the ```Queue``` table. The query uses a ```CROSS JOIN``` to join the ```Queue``` table with a temporary table called ```init```. The ```init``` table only contains one row, and the value in the ```@cumulative_sum``` column is set to ```0```.\\n\\nThe second subquery, ```subquery2```, selects the maximum turn for each group of rows where the cumulative sum is less than or equal to ```1000```kgs.\\n\\nThe outer query then selects the ```person_name``` column from the ```subquery``` table and joins it with the ```subquery2``` table on the ```turn``` column. This ensures that we only select the person names for the rows where the cumulative sum is less than or equal to ```1000```kgs.\\n\\nThe query is written in a recursive fashion, which means that it calls itself to process the rows in the ```Queue``` table. This is necessary because we need to calculate the cumulative sum for all of the rows in the table.\\n\\nTo summarize, the query first calculates the cumulative sum of the weight column for all of the rows in the ```Queue``` table. Then, it selects the person names for the rows where the cumulative sum is less than or equal to ```1000```kgs.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nWITH subquery AS (\\n    SELECT turn, person_name, weight, (@cumulative_sum := @cumulative_sum + weight) AS cumulative_sum\\n    FROM Queue\\n    CROSS JOIN (SELECT @cumulative_sum := 0) AS init\\n    ORDER BY turn ASC\\n),\\nsubquery2 AS (\\n    SELECT MAX(turn) AS max_turn\\n    FROM subquery\\n    WHERE cumulative_sum <= 1000\\n)\\nSELECT subquery.person_name\\nFROM subquery\\nINNER JOIN subquery2 ON subquery.turn = subquery2.max_turn;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```subquery```\n```Queue```\n```CROSS JOIN```\n```Queue```\n```init```\n```init```\n```@cumulative_sum```\n```0```\n```subquery2```\n```1000```\n```person_name```\n```subquery```\n```subquery2```\n```turn```\n```1000```\n```Queue```\n```Queue```\n```1000```\n```\\n# Write your MySQL query statement below\\nWITH subquery AS (\\n    SELECT turn, person_name, weight, (@cumulative_sum := @cumulative_sum + weight) AS cumulative_sum\\n    FROM Queue\\n    CROSS JOIN (SELECT @cumulative_sum := 0) AS init\\n    ORDER BY turn ASC\\n),\\nsubquery2 AS (\\n    SELECT MAX(turn) AS max_turn\\n    FROM subquery\\n    WHERE cumulative_sum <= 1000\\n)\\nSELECT subquery.person_name\\nFROM subquery\\nINNER JOIN subquery2 ON subquery.turn = subquery2.max_turn;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3987720,
                "title": "nysql-is-so-smart-but-i-am-not",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    I just copy from another solution for my skills check\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    I see problem like using JOIN self and sorting.\\n\\n    it is so, group by turns and sorting it by desc\\n\\n    why desc, so... we need latest person, that is why.\\n\\n    really serious is LIMIT 1; when we use JOIN self we get so many unusable data and yeap just ignore it\\n# Complexity\\n- Time complexity:\\n    Bad\\n- Space complexity:\\n    Bad\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT\\n    q1.person_name\\nFROM Queue as q1\\nJOIN Queue as q2 ON q1.turn >= q2.turn\\nGROUP BY q1.turn\\nHAVING SUM(q2.weight) <= 1000\\nORDER BY SUM(q2.weight) DESC\\nLIMIT 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT\\n    q1.person_name\\nFROM Queue as q1\\nJOIN Queue as q2 ON q1.turn >= q2.turn\\nGROUP BY q1.turn\\nHAVING SUM(q2.weight) <= 1000\\nORDER BY SUM(q2.weight) DESC\\nLIMIT 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3985998,
                "title": "windows-function-runtime-1645ms-beats-79-90-memory-details-0-00mb-beats-100-00",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT\\n      person_name \\nFROM (\\nSELECT\\n      turn,\\n      person_name,\\n      CASE\\n          WHEN SUM(weight) OVER (ORDER BY turn) <= 1000 THEN SUM(weight) OVER (ORDER BY turn) \\n      END AS current_weight\\nFROM  Queue) t\\nWHERE current_weight IS NOT NULL \\nORDER BY current_weight DESC\\nLIMIT 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT\\n      person_name \\nFROM (\\nSELECT\\n      turn,\\n      person_name,\\n      CASE\\n          WHEN SUM(weight) OVER (ORDER BY turn) <= 1000 THEN SUM(weight) OVER (ORDER BY turn) \\n      END AS current_weight\\nFROM  Queue) t\\nWHERE current_weight IS NOT NULL \\nORDER BY current_weight DESC\\nLIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3985025,
                "title": "cumulative-sum-approach-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect person_name from\\n(select *, \\nsum(weight) over (order by turn) as weight_now\\nfrom queue)q\\nwhere weight_now<=1000\\norder by weight_now desc limit 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect person_name from\\n(select *, \\nsum(weight) over (order by turn) as weight_now\\nfrom queue)q\\nwhere weight_now<=1000\\norder by weight_now desc limit 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3984494,
                "title": "mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n select person_name from \\n  (select *, \\n  (select sum(weight) from queue b where b.turn <= a.turn) as w\\n  from queue a\\n  having w <= 1000\\n  order by w desc) x\\nlimit 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n select person_name from \\n  (select *, \\n  (select sum(weight) from queue b where b.turn <= a.turn) as w\\n  from queue a\\n  having w <= 1000\\n  order by w desc) x\\nlimit 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3981697,
                "title": "super-easy-approach",
                "content": "# Intuition\\n![upvote.png](https://assets.leetcode.com/users/images/ca028dd2-4cad-4fc3-b24b-559a1ed53713_1693417731.32547.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\n\\nWITH Temp AS\\n(\\n  SELECT person_name, SUM(weight) OVER (ORDER BY Turn ASC) AS Total\\n  FROM Queue\\n)\\nSELECT Top 1 person_name \\nFROM Temp\\nWHERE Total <= 1000\\nORDER By Total DESC\\n\\n\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\n\\nWITH Temp AS\\n(\\n  SELECT person_name, SUM(weight) OVER (ORDER BY Turn ASC) AS Total\\n  FROM Queue\\n)\\nSELECT Top 1 person_name \\nFROM Temp\\nWHERE Total <= 1000\\nORDER By Total DESC\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3980541,
                "title": "clean-code-with-windows-sum",
                "content": "\\n# Code\\n```\\nSELECT person_name\\nFROM\\n    (SELECT turn,person_name,weight,SUM(weight) OVER(ORDER BY turn) Total\\n    FROM Queue)a\\nWHERE total <= 1000\\nORDER BY total DESC\\nLIMIT 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT person_name\\nFROM\\n    (SELECT turn,person_name,weight,SUM(weight) OVER(ORDER BY turn) Total\\n    FROM Queue)a\\nWHERE total <= 1000\\nORDER BY total DESC\\nLIMIT 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3972053,
                "title": "easy-solution-by-sum-over",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect person_name\\nfrom (select *, sum(weight) over (order by turn) as cm \\n      from queue\\n      ) q\\nwhere cm <= 1000\\norder by cm desc\\nlimit 1\\n;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect person_name\\nfrom (select *, sum(weight) over (order by turn) as cm \\n      from queue\\n      ) q\\nwhere cm <= 1000\\norder by cm desc\\nlimit 1\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3971746,
                "title": "smooth-simple-sql-using-sum-over-turns",
                "content": "# Intuition\\nWe need to find the last person who can fit on the bus without exceeding the weight limit of 1000 kilograms. To do this, we can calculate the cumulative sum of weights for each person in the queue and select the last person whose cumulative weight does not exceed the limit.\\n\\n# Approach\\n1. We will use a subquery named \"weighted_queue\" to calculate the cumulative sum of weights for each person in the queue. This will be achieved by using the SUM window function ordered by the \"turn\" column.\\n2. In the main query, we will select the \"person_name\" from the \"weighted_queue\" subquery where the cumulative weight is less than or equal to 1000.\\n3. We will order the results in descending order of cumulative weight to ensure that we get the heaviest person who can still fit within the weight limit.\\n4. Finally, we will use the LIMIT 1 clause to retrieve only the last person\\'s name who satisfies the weight condition.\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT person_name\\nFROM (\\n    SELECT person_name, \\n           SUM(weight) OVER (ORDER BY turn) AS total_weight\\n    FROM Queue\\n) AS weighted_queue\\nWHERE total_weight <= 1000\\nORDER BY total_weight DESC\\nLIMIT 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT person_name\\nFROM (\\n    SELECT person_name, \\n           SUM(weight) OVER (ORDER BY turn) AS total_weight\\n    FROM Queue\\n) AS weighted_queue\\nWHERE total_weight <= 1000\\nORDER BY total_weight DESC\\nLIMIT 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3969388,
                "title": "easiest-solution",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect person_name\\nfrom \\n(select person_name,weight,sum(weight) over(order by turn ) as running_total\\nfrom queue) as a\\nwhere running_total<=1000\\norder by running_total desc\\nlimit 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect person_name\\nfrom \\n(select person_name,weight,sum(weight) over(order by turn ) as running_total\\nfrom queue) as a\\nwhere running_total<=1000\\norder by running_total desc\\nlimit 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3968093,
                "title": "beats-64-04-of-users-with-mysql",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n# Write your MySQL query statement below\\r\\n\\r\\nSELECT person_name\\r\\nFROM (\\r\\n    SELECT\\r\\n        turn,\\r\\n        person_id,\\r\\n        person_name,\\r\\n        weight,\\r\\n        @total_weight := @total_weight + weight AS TotalWeight\\r\\n    FROM\\r\\n        Queue,\\r\\n        (SELECT @total_weight := 0) AS init\\r\\n    ORDER BY\\r\\n        Turn\\r\\n) AS running_total\\r\\nWHERE TotalWeight <= 1000\\r\\nORDER BY Turn DESC\\r\\nLIMIT 1;\\r\\n\\r\\n\\r\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\r\\n# Write your MySQL query statement below\\r\\n\\r\\nSELECT person_name\\r\\nFROM (\\r\\n    SELECT\\r\\n        turn,\\r\\n        person_id,\\r\\n        person_name,\\r\\n        weight,\\r\\n        @total_weight := @total_weight + weight AS TotalWeight\\r\\n    FROM\\r\\n        Queue,\\r\\n        (SELECT @total_weight := 0) AS init\\r\\n    ORDER BY\\r\\n        Turn\\r\\n) AS running_total\\r\\nWHERE TotalWeight <= 1000\\r\\nORDER BY Turn DESC\\r\\nLIMIT 1;\\r\\n\\r\\n\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3967920,
                "title": "mysql-no-joins",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou need keep a cumulative column that keep track of the weights. Then just filter. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT person_name\\nFROM (\\n  SELECT *, SUM(weight)OVER(ORDER BY turn) AS cumulative_weight\\n  FROM Queue) q1\\nWHERE cumulative_weight<=1000\\nORDER BY cumulative_weight DESC\\nLIMIT 1\\n  \\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT person_name\\nFROM (\\n  SELECT *, SUM(weight)OVER(ORDER BY turn) AS cumulative_weight\\n  FROM Queue) q1\\nWHERE cumulative_weight<=1000\\nORDER BY cumulative_weight DESC\\nLIMIT 1\\n  \\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3967217,
                "title": "running-total-calculation-using-sum-window-function",
                "content": "\\r\\n# Approach\\r\\n\\r\\nThe use of SUM() as a window function lets us deduces which passenger will be able to take the bus. After creating a temporary table with these passenger, ranked inversely in terms of turn number, the person with the first rank is essentially the last passenger being able to take the bus before we go over the weight limit. By filtering the individual with the rank of 1, we select his name.\\r\\n\\r\\n\\r\\n# Code\\r\\n```\\r\\n`WITH last_p AS (\\r\\n    SELECT \\r\\n        turn,\\r\\n        person_id,\\r\\n        person_name,\\r\\n        RANK() OVER (ORDER BY turn DESC) as rnk\\r\\n    FROM (\\r\\n        SELECT\\r\\n            turn,\\r\\n            person_id,\\r\\n            person_name,\\r\\n            weight,\\r\\n            SUM(weight) OVER (ORDER BY turn ASC) as total\\r\\n        FROM Queue\\r\\n        ) temp1\\r\\n    WHERE total <= 1000)\\r\\n\\r\\nSELECT\\r\\n    person_name\\r\\nFROM last_p\\r\\nWHERE rnk = 1`\\r\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\r\\n`WITH last_p AS (\\r\\n    SELECT \\r\\n        turn,\\r\\n        person_id,\\r\\n        person_name,\\r\\n        RANK() OVER (ORDER BY turn DESC) as rnk\\r\\n    FROM (\\r\\n        SELECT\\r\\n            turn,\\r\\n            person_id,\\r\\n            person_name,\\r\\n            weight,\\r\\n            SUM(weight) OVER (ORDER BY turn ASC) as total\\r\\n        FROM Queue\\r\\n        ) temp1\\r\\n    WHERE total <= 1000)\\r\\n\\r\\nSELECT\\r\\n    person_name\\r\\nFROM last_p\\r\\nWHERE rnk = 1`\\r\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1902438,
                "content": [
                    {
                        "username": "vhood",
                        "content": "> weight is the weight of the person in kilograms\nExample: Winston weight 500kg\n\nO_O"
                    },
                    {
                        "username": "saptarshi_99",
                        "content": "That\\'s because Winston is a gorilla disguised as a person. This was a tricky part to catch as no hints were given. I\\'m glad I could catch it."
                    },
                    {
                        "username": "pradhumn_chourey",
                        "content": "thanks"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect top 1 person_name\\nfrom\\n(select person_name,\\n        turn,\\n        sum(weight)over(order by turn) as cum\\nfrom queue) a\\nwhere cum <= 1000\\norder by turn desc\\n\\n\\n2)\\nselect top 1 a.person_name\\nfrom queue a\\nleft join queue b\\non a.turn >= b.turn\\ngroup by a.person_name\\nhaving sum(b.weight) <= 1000\\norder by sum(b.weight) desc"
                    },
                    {
                        "username": "rainversion_3",
                        "content": "the solution with joins was very tricky to understand at first glance"
                    },
                    {
                        "username": "kmp1084",
                        "content": "deep"
                    },
                    {
                        "username": "jerrymrj",
                        "content": "with cte as (SELECT person_name,weight,turn,SUM(weight) over (order by turn) as total from Queue)\\nSELECT person_name  \\nFROM cte \\nwhere total <= 1000\\norder by total DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "Ahsan-Haider",
                        "content": "LIMIT 1 is not working in Oracle, otherwise the code is running well."
                    },
                    {
                        "username": "jagadevappa_patil",
                        "content": "\\nselect person_name\\nfrom (\\nselect person_id,person_name ,weight,sum(weight) over ( order by turn asc ROWS BETWEEN UNBOUNDED PRECEDING and CURRENT ROW ) as C_SUm \\nfrom Queue\\n)x where C_SUM <=1000 \\norder by C_SUM desc limit 1\\n"
                    },
                    {
                        "username": "2019share",
                        "content": "With A as \\n(select *,\\nsum(weight) over (order by turn asc ROWS between unbounded preceding and current row) as running_total,\\nlag(weight,1)over(order by turn asc)as lag\\nFROM Queue),\\nB as (\\nSelect person_name, \\ncase \\nwhen running_total<1000\\n    and  lead(running_total,1)over(order by turn asc) >1000 then 1    \\nwhen running_total = 1000 then 1\\nwhen lead(running_total,1)over(order by turn asc) is null and running_total < 1000 then 1\\nelse 0 end as flag\\nFROM A)\\nselect person_name from B\\nwhere flag = 1"
                    },
                    {
                        "username": "bianjin12345",
                        "content": "\\nselect person_name from queue where turn = \\n(select max(turn)\\n from (SELECT turn, sum(weight) over(order by turn) a from queue)k where  k.a<=1000)"
                    },
                    {
                        "username": "tanayanandanwar",
                        "content": "\\'\\'\\'select person_name\\nfrom queue\\nwhere turn=(select max(turn) from\\n(select case when sum(weight) over (order by turn) <=1000 then turn end as turn\\nfrom queue))\\'\\'\\'"
                    },
                    {
                        "username": "meaganking",
                        "content": "with cte as (SELECT person_name, SUM(weight) OVER (ORDER BY turn ASC) as \\'run\\'\\n            FROM Queue)\\n\\nSELECT top 1 person_name\\nFROM cte\\nWHERE run <=1000\\nORDER BY run DESC;"
                    },
                    {
                        "username": "spookie886",
                        "content": "John Cena??? Really?"
                    }
                ]
            },
            {
                "id": 1570875,
                "content": [
                    {
                        "username": "vhood",
                        "content": "> weight is the weight of the person in kilograms\nExample: Winston weight 500kg\n\nO_O"
                    },
                    {
                        "username": "saptarshi_99",
                        "content": "That\\'s because Winston is a gorilla disguised as a person. This was a tricky part to catch as no hints were given. I\\'m glad I could catch it."
                    },
                    {
                        "username": "pradhumn_chourey",
                        "content": "thanks"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect top 1 person_name\\nfrom\\n(select person_name,\\n        turn,\\n        sum(weight)over(order by turn) as cum\\nfrom queue) a\\nwhere cum <= 1000\\norder by turn desc\\n\\n\\n2)\\nselect top 1 a.person_name\\nfrom queue a\\nleft join queue b\\non a.turn >= b.turn\\ngroup by a.person_name\\nhaving sum(b.weight) <= 1000\\norder by sum(b.weight) desc"
                    },
                    {
                        "username": "rainversion_3",
                        "content": "the solution with joins was very tricky to understand at first glance"
                    },
                    {
                        "username": "kmp1084",
                        "content": "deep"
                    },
                    {
                        "username": "jerrymrj",
                        "content": "with cte as (SELECT person_name,weight,turn,SUM(weight) over (order by turn) as total from Queue)\\nSELECT person_name  \\nFROM cte \\nwhere total <= 1000\\norder by total DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "Ahsan-Haider",
                        "content": "LIMIT 1 is not working in Oracle, otherwise the code is running well."
                    },
                    {
                        "username": "jagadevappa_patil",
                        "content": "\\nselect person_name\\nfrom (\\nselect person_id,person_name ,weight,sum(weight) over ( order by turn asc ROWS BETWEEN UNBOUNDED PRECEDING and CURRENT ROW ) as C_SUm \\nfrom Queue\\n)x where C_SUM <=1000 \\norder by C_SUM desc limit 1\\n"
                    },
                    {
                        "username": "2019share",
                        "content": "With A as \\n(select *,\\nsum(weight) over (order by turn asc ROWS between unbounded preceding and current row) as running_total,\\nlag(weight,1)over(order by turn asc)as lag\\nFROM Queue),\\nB as (\\nSelect person_name, \\ncase \\nwhen running_total<1000\\n    and  lead(running_total,1)over(order by turn asc) >1000 then 1    \\nwhen running_total = 1000 then 1\\nwhen lead(running_total,1)over(order by turn asc) is null and running_total < 1000 then 1\\nelse 0 end as flag\\nFROM A)\\nselect person_name from B\\nwhere flag = 1"
                    },
                    {
                        "username": "bianjin12345",
                        "content": "\\nselect person_name from queue where turn = \\n(select max(turn)\\n from (SELECT turn, sum(weight) over(order by turn) a from queue)k where  k.a<=1000)"
                    },
                    {
                        "username": "tanayanandanwar",
                        "content": "\\'\\'\\'select person_name\\nfrom queue\\nwhere turn=(select max(turn) from\\n(select case when sum(weight) over (order by turn) <=1000 then turn end as turn\\nfrom queue))\\'\\'\\'"
                    },
                    {
                        "username": "meaganking",
                        "content": "with cte as (SELECT person_name, SUM(weight) OVER (ORDER BY turn ASC) as \\'run\\'\\n            FROM Queue)\\n\\nSELECT top 1 person_name\\nFROM cte\\nWHERE run <=1000\\nORDER BY run DESC;"
                    },
                    {
                        "username": "spookie886",
                        "content": "John Cena??? Really?"
                    }
                ]
            },
            {
                "id": 1936240,
                "content": [
                    {
                        "username": "vhood",
                        "content": "> weight is the weight of the person in kilograms\nExample: Winston weight 500kg\n\nO_O"
                    },
                    {
                        "username": "saptarshi_99",
                        "content": "That\\'s because Winston is a gorilla disguised as a person. This was a tricky part to catch as no hints were given. I\\'m glad I could catch it."
                    },
                    {
                        "username": "pradhumn_chourey",
                        "content": "thanks"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect top 1 person_name\\nfrom\\n(select person_name,\\n        turn,\\n        sum(weight)over(order by turn) as cum\\nfrom queue) a\\nwhere cum <= 1000\\norder by turn desc\\n\\n\\n2)\\nselect top 1 a.person_name\\nfrom queue a\\nleft join queue b\\non a.turn >= b.turn\\ngroup by a.person_name\\nhaving sum(b.weight) <= 1000\\norder by sum(b.weight) desc"
                    },
                    {
                        "username": "rainversion_3",
                        "content": "the solution with joins was very tricky to understand at first glance"
                    },
                    {
                        "username": "kmp1084",
                        "content": "deep"
                    },
                    {
                        "username": "jerrymrj",
                        "content": "with cte as (SELECT person_name,weight,turn,SUM(weight) over (order by turn) as total from Queue)\\nSELECT person_name  \\nFROM cte \\nwhere total <= 1000\\norder by total DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "Ahsan-Haider",
                        "content": "LIMIT 1 is not working in Oracle, otherwise the code is running well."
                    },
                    {
                        "username": "jagadevappa_patil",
                        "content": "\\nselect person_name\\nfrom (\\nselect person_id,person_name ,weight,sum(weight) over ( order by turn asc ROWS BETWEEN UNBOUNDED PRECEDING and CURRENT ROW ) as C_SUm \\nfrom Queue\\n)x where C_SUM <=1000 \\norder by C_SUM desc limit 1\\n"
                    },
                    {
                        "username": "2019share",
                        "content": "With A as \\n(select *,\\nsum(weight) over (order by turn asc ROWS between unbounded preceding and current row) as running_total,\\nlag(weight,1)over(order by turn asc)as lag\\nFROM Queue),\\nB as (\\nSelect person_name, \\ncase \\nwhen running_total<1000\\n    and  lead(running_total,1)over(order by turn asc) >1000 then 1    \\nwhen running_total = 1000 then 1\\nwhen lead(running_total,1)over(order by turn asc) is null and running_total < 1000 then 1\\nelse 0 end as flag\\nFROM A)\\nselect person_name from B\\nwhere flag = 1"
                    },
                    {
                        "username": "bianjin12345",
                        "content": "\\nselect person_name from queue where turn = \\n(select max(turn)\\n from (SELECT turn, sum(weight) over(order by turn) a from queue)k where  k.a<=1000)"
                    },
                    {
                        "username": "tanayanandanwar",
                        "content": "\\'\\'\\'select person_name\\nfrom queue\\nwhere turn=(select max(turn) from\\n(select case when sum(weight) over (order by turn) <=1000 then turn end as turn\\nfrom queue))\\'\\'\\'"
                    },
                    {
                        "username": "meaganking",
                        "content": "with cte as (SELECT person_name, SUM(weight) OVER (ORDER BY turn ASC) as \\'run\\'\\n            FROM Queue)\\n\\nSELECT top 1 person_name\\nFROM cte\\nWHERE run <=1000\\nORDER BY run DESC;"
                    },
                    {
                        "username": "spookie886",
                        "content": "John Cena??? Really?"
                    }
                ]
            },
            {
                "id": 1576186,
                "content": [
                    {
                        "username": "vhood",
                        "content": "> weight is the weight of the person in kilograms\nExample: Winston weight 500kg\n\nO_O"
                    },
                    {
                        "username": "saptarshi_99",
                        "content": "That\\'s because Winston is a gorilla disguised as a person. This was a tricky part to catch as no hints were given. I\\'m glad I could catch it."
                    },
                    {
                        "username": "pradhumn_chourey",
                        "content": "thanks"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect top 1 person_name\\nfrom\\n(select person_name,\\n        turn,\\n        sum(weight)over(order by turn) as cum\\nfrom queue) a\\nwhere cum <= 1000\\norder by turn desc\\n\\n\\n2)\\nselect top 1 a.person_name\\nfrom queue a\\nleft join queue b\\non a.turn >= b.turn\\ngroup by a.person_name\\nhaving sum(b.weight) <= 1000\\norder by sum(b.weight) desc"
                    },
                    {
                        "username": "rainversion_3",
                        "content": "the solution with joins was very tricky to understand at first glance"
                    },
                    {
                        "username": "kmp1084",
                        "content": "deep"
                    },
                    {
                        "username": "jerrymrj",
                        "content": "with cte as (SELECT person_name,weight,turn,SUM(weight) over (order by turn) as total from Queue)\\nSELECT person_name  \\nFROM cte \\nwhere total <= 1000\\norder by total DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "Ahsan-Haider",
                        "content": "LIMIT 1 is not working in Oracle, otherwise the code is running well."
                    },
                    {
                        "username": "jagadevappa_patil",
                        "content": "\\nselect person_name\\nfrom (\\nselect person_id,person_name ,weight,sum(weight) over ( order by turn asc ROWS BETWEEN UNBOUNDED PRECEDING and CURRENT ROW ) as C_SUm \\nfrom Queue\\n)x where C_SUM <=1000 \\norder by C_SUM desc limit 1\\n"
                    },
                    {
                        "username": "2019share",
                        "content": "With A as \\n(select *,\\nsum(weight) over (order by turn asc ROWS between unbounded preceding and current row) as running_total,\\nlag(weight,1)over(order by turn asc)as lag\\nFROM Queue),\\nB as (\\nSelect person_name, \\ncase \\nwhen running_total<1000\\n    and  lead(running_total,1)over(order by turn asc) >1000 then 1    \\nwhen running_total = 1000 then 1\\nwhen lead(running_total,1)over(order by turn asc) is null and running_total < 1000 then 1\\nelse 0 end as flag\\nFROM A)\\nselect person_name from B\\nwhere flag = 1"
                    },
                    {
                        "username": "bianjin12345",
                        "content": "\\nselect person_name from queue where turn = \\n(select max(turn)\\n from (SELECT turn, sum(weight) over(order by turn) a from queue)k where  k.a<=1000)"
                    },
                    {
                        "username": "tanayanandanwar",
                        "content": "\\'\\'\\'select person_name\\nfrom queue\\nwhere turn=(select max(turn) from\\n(select case when sum(weight) over (order by turn) <=1000 then turn end as turn\\nfrom queue))\\'\\'\\'"
                    },
                    {
                        "username": "meaganking",
                        "content": "with cte as (SELECT person_name, SUM(weight) OVER (ORDER BY turn ASC) as \\'run\\'\\n            FROM Queue)\\n\\nSELECT top 1 person_name\\nFROM cte\\nWHERE run <=1000\\nORDER BY run DESC;"
                    },
                    {
                        "username": "spookie886",
                        "content": "John Cena??? Really?"
                    }
                ]
            },
            {
                "id": 1574688,
                "content": [
                    {
                        "username": "vhood",
                        "content": "> weight is the weight of the person in kilograms\nExample: Winston weight 500kg\n\nO_O"
                    },
                    {
                        "username": "saptarshi_99",
                        "content": "That\\'s because Winston is a gorilla disguised as a person. This was a tricky part to catch as no hints were given. I\\'m glad I could catch it."
                    },
                    {
                        "username": "pradhumn_chourey",
                        "content": "thanks"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect top 1 person_name\\nfrom\\n(select person_name,\\n        turn,\\n        sum(weight)over(order by turn) as cum\\nfrom queue) a\\nwhere cum <= 1000\\norder by turn desc\\n\\n\\n2)\\nselect top 1 a.person_name\\nfrom queue a\\nleft join queue b\\non a.turn >= b.turn\\ngroup by a.person_name\\nhaving sum(b.weight) <= 1000\\norder by sum(b.weight) desc"
                    },
                    {
                        "username": "rainversion_3",
                        "content": "the solution with joins was very tricky to understand at first glance"
                    },
                    {
                        "username": "kmp1084",
                        "content": "deep"
                    },
                    {
                        "username": "jerrymrj",
                        "content": "with cte as (SELECT person_name,weight,turn,SUM(weight) over (order by turn) as total from Queue)\\nSELECT person_name  \\nFROM cte \\nwhere total <= 1000\\norder by total DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "Ahsan-Haider",
                        "content": "LIMIT 1 is not working in Oracle, otherwise the code is running well."
                    },
                    {
                        "username": "jagadevappa_patil",
                        "content": "\\nselect person_name\\nfrom (\\nselect person_id,person_name ,weight,sum(weight) over ( order by turn asc ROWS BETWEEN UNBOUNDED PRECEDING and CURRENT ROW ) as C_SUm \\nfrom Queue\\n)x where C_SUM <=1000 \\norder by C_SUM desc limit 1\\n"
                    },
                    {
                        "username": "2019share",
                        "content": "With A as \\n(select *,\\nsum(weight) over (order by turn asc ROWS between unbounded preceding and current row) as running_total,\\nlag(weight,1)over(order by turn asc)as lag\\nFROM Queue),\\nB as (\\nSelect person_name, \\ncase \\nwhen running_total<1000\\n    and  lead(running_total,1)over(order by turn asc) >1000 then 1    \\nwhen running_total = 1000 then 1\\nwhen lead(running_total,1)over(order by turn asc) is null and running_total < 1000 then 1\\nelse 0 end as flag\\nFROM A)\\nselect person_name from B\\nwhere flag = 1"
                    },
                    {
                        "username": "bianjin12345",
                        "content": "\\nselect person_name from queue where turn = \\n(select max(turn)\\n from (SELECT turn, sum(weight) over(order by turn) a from queue)k where  k.a<=1000)"
                    },
                    {
                        "username": "tanayanandanwar",
                        "content": "\\'\\'\\'select person_name\\nfrom queue\\nwhere turn=(select max(turn) from\\n(select case when sum(weight) over (order by turn) <=1000 then turn end as turn\\nfrom queue))\\'\\'\\'"
                    },
                    {
                        "username": "meaganking",
                        "content": "with cte as (SELECT person_name, SUM(weight) OVER (ORDER BY turn ASC) as \\'run\\'\\n            FROM Queue)\\n\\nSELECT top 1 person_name\\nFROM cte\\nWHERE run <=1000\\nORDER BY run DESC;"
                    },
                    {
                        "username": "spookie886",
                        "content": "John Cena??? Really?"
                    }
                ]
            },
            {
                "id": 1573119,
                "content": [
                    {
                        "username": "vhood",
                        "content": "> weight is the weight of the person in kilograms\nExample: Winston weight 500kg\n\nO_O"
                    },
                    {
                        "username": "saptarshi_99",
                        "content": "That\\'s because Winston is a gorilla disguised as a person. This was a tricky part to catch as no hints were given. I\\'m glad I could catch it."
                    },
                    {
                        "username": "pradhumn_chourey",
                        "content": "thanks"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect top 1 person_name\\nfrom\\n(select person_name,\\n        turn,\\n        sum(weight)over(order by turn) as cum\\nfrom queue) a\\nwhere cum <= 1000\\norder by turn desc\\n\\n\\n2)\\nselect top 1 a.person_name\\nfrom queue a\\nleft join queue b\\non a.turn >= b.turn\\ngroup by a.person_name\\nhaving sum(b.weight) <= 1000\\norder by sum(b.weight) desc"
                    },
                    {
                        "username": "rainversion_3",
                        "content": "the solution with joins was very tricky to understand at first glance"
                    },
                    {
                        "username": "kmp1084",
                        "content": "deep"
                    },
                    {
                        "username": "jerrymrj",
                        "content": "with cte as (SELECT person_name,weight,turn,SUM(weight) over (order by turn) as total from Queue)\\nSELECT person_name  \\nFROM cte \\nwhere total <= 1000\\norder by total DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "Ahsan-Haider",
                        "content": "LIMIT 1 is not working in Oracle, otherwise the code is running well."
                    },
                    {
                        "username": "jagadevappa_patil",
                        "content": "\\nselect person_name\\nfrom (\\nselect person_id,person_name ,weight,sum(weight) over ( order by turn asc ROWS BETWEEN UNBOUNDED PRECEDING and CURRENT ROW ) as C_SUm \\nfrom Queue\\n)x where C_SUM <=1000 \\norder by C_SUM desc limit 1\\n"
                    },
                    {
                        "username": "2019share",
                        "content": "With A as \\n(select *,\\nsum(weight) over (order by turn asc ROWS between unbounded preceding and current row) as running_total,\\nlag(weight,1)over(order by turn asc)as lag\\nFROM Queue),\\nB as (\\nSelect person_name, \\ncase \\nwhen running_total<1000\\n    and  lead(running_total,1)over(order by turn asc) >1000 then 1    \\nwhen running_total = 1000 then 1\\nwhen lead(running_total,1)over(order by turn asc) is null and running_total < 1000 then 1\\nelse 0 end as flag\\nFROM A)\\nselect person_name from B\\nwhere flag = 1"
                    },
                    {
                        "username": "bianjin12345",
                        "content": "\\nselect person_name from queue where turn = \\n(select max(turn)\\n from (SELECT turn, sum(weight) over(order by turn) a from queue)k where  k.a<=1000)"
                    },
                    {
                        "username": "tanayanandanwar",
                        "content": "\\'\\'\\'select person_name\\nfrom queue\\nwhere turn=(select max(turn) from\\n(select case when sum(weight) over (order by turn) <=1000 then turn end as turn\\nfrom queue))\\'\\'\\'"
                    },
                    {
                        "username": "meaganking",
                        "content": "with cte as (SELECT person_name, SUM(weight) OVER (ORDER BY turn ASC) as \\'run\\'\\n            FROM Queue)\\n\\nSELECT top 1 person_name\\nFROM cte\\nWHERE run <=1000\\nORDER BY run DESC;"
                    },
                    {
                        "username": "spookie886",
                        "content": "John Cena??? Really?"
                    }
                ]
            },
            {
                "id": 1574023,
                "content": [
                    {
                        "username": "vhood",
                        "content": "> weight is the weight of the person in kilograms\nExample: Winston weight 500kg\n\nO_O"
                    },
                    {
                        "username": "saptarshi_99",
                        "content": "That\\'s because Winston is a gorilla disguised as a person. This was a tricky part to catch as no hints were given. I\\'m glad I could catch it."
                    },
                    {
                        "username": "pradhumn_chourey",
                        "content": "thanks"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect top 1 person_name\\nfrom\\n(select person_name,\\n        turn,\\n        sum(weight)over(order by turn) as cum\\nfrom queue) a\\nwhere cum <= 1000\\norder by turn desc\\n\\n\\n2)\\nselect top 1 a.person_name\\nfrom queue a\\nleft join queue b\\non a.turn >= b.turn\\ngroup by a.person_name\\nhaving sum(b.weight) <= 1000\\norder by sum(b.weight) desc"
                    },
                    {
                        "username": "rainversion_3",
                        "content": "the solution with joins was very tricky to understand at first glance"
                    },
                    {
                        "username": "kmp1084",
                        "content": "deep"
                    },
                    {
                        "username": "jerrymrj",
                        "content": "with cte as (SELECT person_name,weight,turn,SUM(weight) over (order by turn) as total from Queue)\\nSELECT person_name  \\nFROM cte \\nwhere total <= 1000\\norder by total DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "Ahsan-Haider",
                        "content": "LIMIT 1 is not working in Oracle, otherwise the code is running well."
                    },
                    {
                        "username": "jagadevappa_patil",
                        "content": "\\nselect person_name\\nfrom (\\nselect person_id,person_name ,weight,sum(weight) over ( order by turn asc ROWS BETWEEN UNBOUNDED PRECEDING and CURRENT ROW ) as C_SUm \\nfrom Queue\\n)x where C_SUM <=1000 \\norder by C_SUM desc limit 1\\n"
                    },
                    {
                        "username": "2019share",
                        "content": "With A as \\n(select *,\\nsum(weight) over (order by turn asc ROWS between unbounded preceding and current row) as running_total,\\nlag(weight,1)over(order by turn asc)as lag\\nFROM Queue),\\nB as (\\nSelect person_name, \\ncase \\nwhen running_total<1000\\n    and  lead(running_total,1)over(order by turn asc) >1000 then 1    \\nwhen running_total = 1000 then 1\\nwhen lead(running_total,1)over(order by turn asc) is null and running_total < 1000 then 1\\nelse 0 end as flag\\nFROM A)\\nselect person_name from B\\nwhere flag = 1"
                    },
                    {
                        "username": "bianjin12345",
                        "content": "\\nselect person_name from queue where turn = \\n(select max(turn)\\n from (SELECT turn, sum(weight) over(order by turn) a from queue)k where  k.a<=1000)"
                    },
                    {
                        "username": "tanayanandanwar",
                        "content": "\\'\\'\\'select person_name\\nfrom queue\\nwhere turn=(select max(turn) from\\n(select case when sum(weight) over (order by turn) <=1000 then turn end as turn\\nfrom queue))\\'\\'\\'"
                    },
                    {
                        "username": "meaganking",
                        "content": "with cte as (SELECT person_name, SUM(weight) OVER (ORDER BY turn ASC) as \\'run\\'\\n            FROM Queue)\\n\\nSELECT top 1 person_name\\nFROM cte\\nWHERE run <=1000\\nORDER BY run DESC;"
                    },
                    {
                        "username": "spookie886",
                        "content": "John Cena??? Really?"
                    }
                ]
            },
            {
                "id": 1573574,
                "content": [
                    {
                        "username": "vhood",
                        "content": "> weight is the weight of the person in kilograms\nExample: Winston weight 500kg\n\nO_O"
                    },
                    {
                        "username": "saptarshi_99",
                        "content": "That\\'s because Winston is a gorilla disguised as a person. This was a tricky part to catch as no hints were given. I\\'m glad I could catch it."
                    },
                    {
                        "username": "pradhumn_chourey",
                        "content": "thanks"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect top 1 person_name\\nfrom\\n(select person_name,\\n        turn,\\n        sum(weight)over(order by turn) as cum\\nfrom queue) a\\nwhere cum <= 1000\\norder by turn desc\\n\\n\\n2)\\nselect top 1 a.person_name\\nfrom queue a\\nleft join queue b\\non a.turn >= b.turn\\ngroup by a.person_name\\nhaving sum(b.weight) <= 1000\\norder by sum(b.weight) desc"
                    },
                    {
                        "username": "rainversion_3",
                        "content": "the solution with joins was very tricky to understand at first glance"
                    },
                    {
                        "username": "kmp1084",
                        "content": "deep"
                    },
                    {
                        "username": "jerrymrj",
                        "content": "with cte as (SELECT person_name,weight,turn,SUM(weight) over (order by turn) as total from Queue)\\nSELECT person_name  \\nFROM cte \\nwhere total <= 1000\\norder by total DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "Ahsan-Haider",
                        "content": "LIMIT 1 is not working in Oracle, otherwise the code is running well."
                    },
                    {
                        "username": "jagadevappa_patil",
                        "content": "\\nselect person_name\\nfrom (\\nselect person_id,person_name ,weight,sum(weight) over ( order by turn asc ROWS BETWEEN UNBOUNDED PRECEDING and CURRENT ROW ) as C_SUm \\nfrom Queue\\n)x where C_SUM <=1000 \\norder by C_SUM desc limit 1\\n"
                    },
                    {
                        "username": "2019share",
                        "content": "With A as \\n(select *,\\nsum(weight) over (order by turn asc ROWS between unbounded preceding and current row) as running_total,\\nlag(weight,1)over(order by turn asc)as lag\\nFROM Queue),\\nB as (\\nSelect person_name, \\ncase \\nwhen running_total<1000\\n    and  lead(running_total,1)over(order by turn asc) >1000 then 1    \\nwhen running_total = 1000 then 1\\nwhen lead(running_total,1)over(order by turn asc) is null and running_total < 1000 then 1\\nelse 0 end as flag\\nFROM A)\\nselect person_name from B\\nwhere flag = 1"
                    },
                    {
                        "username": "bianjin12345",
                        "content": "\\nselect person_name from queue where turn = \\n(select max(turn)\\n from (SELECT turn, sum(weight) over(order by turn) a from queue)k where  k.a<=1000)"
                    },
                    {
                        "username": "tanayanandanwar",
                        "content": "\\'\\'\\'select person_name\\nfrom queue\\nwhere turn=(select max(turn) from\\n(select case when sum(weight) over (order by turn) <=1000 then turn end as turn\\nfrom queue))\\'\\'\\'"
                    },
                    {
                        "username": "meaganking",
                        "content": "with cte as (SELECT person_name, SUM(weight) OVER (ORDER BY turn ASC) as \\'run\\'\\n            FROM Queue)\\n\\nSELECT top 1 person_name\\nFROM cte\\nWHERE run <=1000\\nORDER BY run DESC;"
                    },
                    {
                        "username": "spookie886",
                        "content": "John Cena??? Really?"
                    }
                ]
            },
            {
                "id": 1573447,
                "content": [
                    {
                        "username": "vhood",
                        "content": "> weight is the weight of the person in kilograms\nExample: Winston weight 500kg\n\nO_O"
                    },
                    {
                        "username": "saptarshi_99",
                        "content": "That\\'s because Winston is a gorilla disguised as a person. This was a tricky part to catch as no hints were given. I\\'m glad I could catch it."
                    },
                    {
                        "username": "pradhumn_chourey",
                        "content": "thanks"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect top 1 person_name\\nfrom\\n(select person_name,\\n        turn,\\n        sum(weight)over(order by turn) as cum\\nfrom queue) a\\nwhere cum <= 1000\\norder by turn desc\\n\\n\\n2)\\nselect top 1 a.person_name\\nfrom queue a\\nleft join queue b\\non a.turn >= b.turn\\ngroup by a.person_name\\nhaving sum(b.weight) <= 1000\\norder by sum(b.weight) desc"
                    },
                    {
                        "username": "rainversion_3",
                        "content": "the solution with joins was very tricky to understand at first glance"
                    },
                    {
                        "username": "kmp1084",
                        "content": "deep"
                    },
                    {
                        "username": "jerrymrj",
                        "content": "with cte as (SELECT person_name,weight,turn,SUM(weight) over (order by turn) as total from Queue)\\nSELECT person_name  \\nFROM cte \\nwhere total <= 1000\\norder by total DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "Ahsan-Haider",
                        "content": "LIMIT 1 is not working in Oracle, otherwise the code is running well."
                    },
                    {
                        "username": "jagadevappa_patil",
                        "content": "\\nselect person_name\\nfrom (\\nselect person_id,person_name ,weight,sum(weight) over ( order by turn asc ROWS BETWEEN UNBOUNDED PRECEDING and CURRENT ROW ) as C_SUm \\nfrom Queue\\n)x where C_SUM <=1000 \\norder by C_SUM desc limit 1\\n"
                    },
                    {
                        "username": "2019share",
                        "content": "With A as \\n(select *,\\nsum(weight) over (order by turn asc ROWS between unbounded preceding and current row) as running_total,\\nlag(weight,1)over(order by turn asc)as lag\\nFROM Queue),\\nB as (\\nSelect person_name, \\ncase \\nwhen running_total<1000\\n    and  lead(running_total,1)over(order by turn asc) >1000 then 1    \\nwhen running_total = 1000 then 1\\nwhen lead(running_total,1)over(order by turn asc) is null and running_total < 1000 then 1\\nelse 0 end as flag\\nFROM A)\\nselect person_name from B\\nwhere flag = 1"
                    },
                    {
                        "username": "bianjin12345",
                        "content": "\\nselect person_name from queue where turn = \\n(select max(turn)\\n from (SELECT turn, sum(weight) over(order by turn) a from queue)k where  k.a<=1000)"
                    },
                    {
                        "username": "tanayanandanwar",
                        "content": "\\'\\'\\'select person_name\\nfrom queue\\nwhere turn=(select max(turn) from\\n(select case when sum(weight) over (order by turn) <=1000 then turn end as turn\\nfrom queue))\\'\\'\\'"
                    },
                    {
                        "username": "meaganking",
                        "content": "with cte as (SELECT person_name, SUM(weight) OVER (ORDER BY turn ASC) as \\'run\\'\\n            FROM Queue)\\n\\nSELECT top 1 person_name\\nFROM cte\\nWHERE run <=1000\\nORDER BY run DESC;"
                    },
                    {
                        "username": "spookie886",
                        "content": "John Cena??? Really?"
                    }
                ]
            },
            {
                "id": 2030471,
                "content": [
                    {
                        "username": "vhood",
                        "content": "> weight is the weight of the person in kilograms\nExample: Winston weight 500kg\n\nO_O"
                    },
                    {
                        "username": "saptarshi_99",
                        "content": "That\\'s because Winston is a gorilla disguised as a person. This was a tricky part to catch as no hints were given. I\\'m glad I could catch it."
                    },
                    {
                        "username": "pradhumn_chourey",
                        "content": "thanks"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect top 1 person_name\\nfrom\\n(select person_name,\\n        turn,\\n        sum(weight)over(order by turn) as cum\\nfrom queue) a\\nwhere cum <= 1000\\norder by turn desc\\n\\n\\n2)\\nselect top 1 a.person_name\\nfrom queue a\\nleft join queue b\\non a.turn >= b.turn\\ngroup by a.person_name\\nhaving sum(b.weight) <= 1000\\norder by sum(b.weight) desc"
                    },
                    {
                        "username": "rainversion_3",
                        "content": "the solution with joins was very tricky to understand at first glance"
                    },
                    {
                        "username": "kmp1084",
                        "content": "deep"
                    },
                    {
                        "username": "jerrymrj",
                        "content": "with cte as (SELECT person_name,weight,turn,SUM(weight) over (order by turn) as total from Queue)\\nSELECT person_name  \\nFROM cte \\nwhere total <= 1000\\norder by total DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "Ahsan-Haider",
                        "content": "LIMIT 1 is not working in Oracle, otherwise the code is running well."
                    },
                    {
                        "username": "jagadevappa_patil",
                        "content": "\\nselect person_name\\nfrom (\\nselect person_id,person_name ,weight,sum(weight) over ( order by turn asc ROWS BETWEEN UNBOUNDED PRECEDING and CURRENT ROW ) as C_SUm \\nfrom Queue\\n)x where C_SUM <=1000 \\norder by C_SUM desc limit 1\\n"
                    },
                    {
                        "username": "2019share",
                        "content": "With A as \\n(select *,\\nsum(weight) over (order by turn asc ROWS between unbounded preceding and current row) as running_total,\\nlag(weight,1)over(order by turn asc)as lag\\nFROM Queue),\\nB as (\\nSelect person_name, \\ncase \\nwhen running_total<1000\\n    and  lead(running_total,1)over(order by turn asc) >1000 then 1    \\nwhen running_total = 1000 then 1\\nwhen lead(running_total,1)over(order by turn asc) is null and running_total < 1000 then 1\\nelse 0 end as flag\\nFROM A)\\nselect person_name from B\\nwhere flag = 1"
                    },
                    {
                        "username": "bianjin12345",
                        "content": "\\nselect person_name from queue where turn = \\n(select max(turn)\\n from (SELECT turn, sum(weight) over(order by turn) a from queue)k where  k.a<=1000)"
                    },
                    {
                        "username": "tanayanandanwar",
                        "content": "\\'\\'\\'select person_name\\nfrom queue\\nwhere turn=(select max(turn) from\\n(select case when sum(weight) over (order by turn) <=1000 then turn end as turn\\nfrom queue))\\'\\'\\'"
                    },
                    {
                        "username": "meaganking",
                        "content": "with cte as (SELECT person_name, SUM(weight) OVER (ORDER BY turn ASC) as \\'run\\'\\n            FROM Queue)\\n\\nSELECT top 1 person_name\\nFROM cte\\nWHERE run <=1000\\nORDER BY run DESC;"
                    },
                    {
                        "username": "spookie886",
                        "content": "John Cena??? Really?"
                    }
                ]
            },
            {
                "id": 1902438,
                "content": [
                    {
                        "username": "vhood",
                        "content": "> weight is the weight of the person in kilograms\nExample: Winston weight 500kg\n\nO_O"
                    },
                    {
                        "username": "saptarshi_99",
                        "content": "That\\'s because Winston is a gorilla disguised as a person. This was a tricky part to catch as no hints were given. I\\'m glad I could catch it."
                    },
                    {
                        "username": "pradhumn_chourey",
                        "content": "thanks"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect top 1 person_name\\nfrom\\n(select person_name,\\n        turn,\\n        sum(weight)over(order by turn) as cum\\nfrom queue) a\\nwhere cum <= 1000\\norder by turn desc\\n\\n\\n2)\\nselect top 1 a.person_name\\nfrom queue a\\nleft join queue b\\non a.turn >= b.turn\\ngroup by a.person_name\\nhaving sum(b.weight) <= 1000\\norder by sum(b.weight) desc"
                    },
                    {
                        "username": "rainversion_3",
                        "content": "the solution with joins was very tricky to understand at first glance"
                    },
                    {
                        "username": "kmp1084",
                        "content": "deep"
                    },
                    {
                        "username": "jerrymrj",
                        "content": "with cte as (SELECT person_name,weight,turn,SUM(weight) over (order by turn) as total from Queue)\\nSELECT person_name  \\nFROM cte \\nwhere total <= 1000\\norder by total DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "Ahsan-Haider",
                        "content": "LIMIT 1 is not working in Oracle, otherwise the code is running well."
                    },
                    {
                        "username": "jagadevappa_patil",
                        "content": "\\nselect person_name\\nfrom (\\nselect person_id,person_name ,weight,sum(weight) over ( order by turn asc ROWS BETWEEN UNBOUNDED PRECEDING and CURRENT ROW ) as C_SUm \\nfrom Queue\\n)x where C_SUM <=1000 \\norder by C_SUM desc limit 1\\n"
                    },
                    {
                        "username": "2019share",
                        "content": "With A as \\n(select *,\\nsum(weight) over (order by turn asc ROWS between unbounded preceding and current row) as running_total,\\nlag(weight,1)over(order by turn asc)as lag\\nFROM Queue),\\nB as (\\nSelect person_name, \\ncase \\nwhen running_total<1000\\n    and  lead(running_total,1)over(order by turn asc) >1000 then 1    \\nwhen running_total = 1000 then 1\\nwhen lead(running_total,1)over(order by turn asc) is null and running_total < 1000 then 1\\nelse 0 end as flag\\nFROM A)\\nselect person_name from B\\nwhere flag = 1"
                    },
                    {
                        "username": "bianjin12345",
                        "content": "\\nselect person_name from queue where turn = \\n(select max(turn)\\n from (SELECT turn, sum(weight) over(order by turn) a from queue)k where  k.a<=1000)"
                    },
                    {
                        "username": "tanayanandanwar",
                        "content": "\\'\\'\\'select person_name\\nfrom queue\\nwhere turn=(select max(turn) from\\n(select case when sum(weight) over (order by turn) <=1000 then turn end as turn\\nfrom queue))\\'\\'\\'"
                    },
                    {
                        "username": "meaganking",
                        "content": "with cte as (SELECT person_name, SUM(weight) OVER (ORDER BY turn ASC) as \\'run\\'\\n            FROM Queue)\\n\\nSELECT top 1 person_name\\nFROM cte\\nWHERE run <=1000\\nORDER BY run DESC;"
                    },
                    {
                        "username": "spookie886",
                        "content": "John Cena??? Really?"
                    }
                ]
            },
            {
                "id": 1570875,
                "content": [
                    {
                        "username": "vhood",
                        "content": "> weight is the weight of the person in kilograms\nExample: Winston weight 500kg\n\nO_O"
                    },
                    {
                        "username": "saptarshi_99",
                        "content": "That\\'s because Winston is a gorilla disguised as a person. This was a tricky part to catch as no hints were given. I\\'m glad I could catch it."
                    },
                    {
                        "username": "pradhumn_chourey",
                        "content": "thanks"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect top 1 person_name\\nfrom\\n(select person_name,\\n        turn,\\n        sum(weight)over(order by turn) as cum\\nfrom queue) a\\nwhere cum <= 1000\\norder by turn desc\\n\\n\\n2)\\nselect top 1 a.person_name\\nfrom queue a\\nleft join queue b\\non a.turn >= b.turn\\ngroup by a.person_name\\nhaving sum(b.weight) <= 1000\\norder by sum(b.weight) desc"
                    },
                    {
                        "username": "rainversion_3",
                        "content": "the solution with joins was very tricky to understand at first glance"
                    },
                    {
                        "username": "kmp1084",
                        "content": "deep"
                    },
                    {
                        "username": "jerrymrj",
                        "content": "with cte as (SELECT person_name,weight,turn,SUM(weight) over (order by turn) as total from Queue)\\nSELECT person_name  \\nFROM cte \\nwhere total <= 1000\\norder by total DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "Ahsan-Haider",
                        "content": "LIMIT 1 is not working in Oracle, otherwise the code is running well."
                    },
                    {
                        "username": "jagadevappa_patil",
                        "content": "\\nselect person_name\\nfrom (\\nselect person_id,person_name ,weight,sum(weight) over ( order by turn asc ROWS BETWEEN UNBOUNDED PRECEDING and CURRENT ROW ) as C_SUm \\nfrom Queue\\n)x where C_SUM <=1000 \\norder by C_SUM desc limit 1\\n"
                    },
                    {
                        "username": "2019share",
                        "content": "With A as \\n(select *,\\nsum(weight) over (order by turn asc ROWS between unbounded preceding and current row) as running_total,\\nlag(weight,1)over(order by turn asc)as lag\\nFROM Queue),\\nB as (\\nSelect person_name, \\ncase \\nwhen running_total<1000\\n    and  lead(running_total,1)over(order by turn asc) >1000 then 1    \\nwhen running_total = 1000 then 1\\nwhen lead(running_total,1)over(order by turn asc) is null and running_total < 1000 then 1\\nelse 0 end as flag\\nFROM A)\\nselect person_name from B\\nwhere flag = 1"
                    },
                    {
                        "username": "bianjin12345",
                        "content": "\\nselect person_name from queue where turn = \\n(select max(turn)\\n from (SELECT turn, sum(weight) over(order by turn) a from queue)k where  k.a<=1000)"
                    },
                    {
                        "username": "tanayanandanwar",
                        "content": "\\'\\'\\'select person_name\\nfrom queue\\nwhere turn=(select max(turn) from\\n(select case when sum(weight) over (order by turn) <=1000 then turn end as turn\\nfrom queue))\\'\\'\\'"
                    },
                    {
                        "username": "meaganking",
                        "content": "with cte as (SELECT person_name, SUM(weight) OVER (ORDER BY turn ASC) as \\'run\\'\\n            FROM Queue)\\n\\nSELECT top 1 person_name\\nFROM cte\\nWHERE run <=1000\\nORDER BY run DESC;"
                    },
                    {
                        "username": "spookie886",
                        "content": "John Cena??? Really?"
                    }
                ]
            },
            {
                "id": 1936240,
                "content": [
                    {
                        "username": "vhood",
                        "content": "> weight is the weight of the person in kilograms\nExample: Winston weight 500kg\n\nO_O"
                    },
                    {
                        "username": "saptarshi_99",
                        "content": "That\\'s because Winston is a gorilla disguised as a person. This was a tricky part to catch as no hints were given. I\\'m glad I could catch it."
                    },
                    {
                        "username": "pradhumn_chourey",
                        "content": "thanks"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect top 1 person_name\\nfrom\\n(select person_name,\\n        turn,\\n        sum(weight)over(order by turn) as cum\\nfrom queue) a\\nwhere cum <= 1000\\norder by turn desc\\n\\n\\n2)\\nselect top 1 a.person_name\\nfrom queue a\\nleft join queue b\\non a.turn >= b.turn\\ngroup by a.person_name\\nhaving sum(b.weight) <= 1000\\norder by sum(b.weight) desc"
                    },
                    {
                        "username": "rainversion_3",
                        "content": "the solution with joins was very tricky to understand at first glance"
                    },
                    {
                        "username": "kmp1084",
                        "content": "deep"
                    },
                    {
                        "username": "jerrymrj",
                        "content": "with cte as (SELECT person_name,weight,turn,SUM(weight) over (order by turn) as total from Queue)\\nSELECT person_name  \\nFROM cte \\nwhere total <= 1000\\norder by total DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "Ahsan-Haider",
                        "content": "LIMIT 1 is not working in Oracle, otherwise the code is running well."
                    },
                    {
                        "username": "jagadevappa_patil",
                        "content": "\\nselect person_name\\nfrom (\\nselect person_id,person_name ,weight,sum(weight) over ( order by turn asc ROWS BETWEEN UNBOUNDED PRECEDING and CURRENT ROW ) as C_SUm \\nfrom Queue\\n)x where C_SUM <=1000 \\norder by C_SUM desc limit 1\\n"
                    },
                    {
                        "username": "2019share",
                        "content": "With A as \\n(select *,\\nsum(weight) over (order by turn asc ROWS between unbounded preceding and current row) as running_total,\\nlag(weight,1)over(order by turn asc)as lag\\nFROM Queue),\\nB as (\\nSelect person_name, \\ncase \\nwhen running_total<1000\\n    and  lead(running_total,1)over(order by turn asc) >1000 then 1    \\nwhen running_total = 1000 then 1\\nwhen lead(running_total,1)over(order by turn asc) is null and running_total < 1000 then 1\\nelse 0 end as flag\\nFROM A)\\nselect person_name from B\\nwhere flag = 1"
                    },
                    {
                        "username": "bianjin12345",
                        "content": "\\nselect person_name from queue where turn = \\n(select max(turn)\\n from (SELECT turn, sum(weight) over(order by turn) a from queue)k where  k.a<=1000)"
                    },
                    {
                        "username": "tanayanandanwar",
                        "content": "\\'\\'\\'select person_name\\nfrom queue\\nwhere turn=(select max(turn) from\\n(select case when sum(weight) over (order by turn) <=1000 then turn end as turn\\nfrom queue))\\'\\'\\'"
                    },
                    {
                        "username": "meaganking",
                        "content": "with cte as (SELECT person_name, SUM(weight) OVER (ORDER BY turn ASC) as \\'run\\'\\n            FROM Queue)\\n\\nSELECT top 1 person_name\\nFROM cte\\nWHERE run <=1000\\nORDER BY run DESC;"
                    },
                    {
                        "username": "spookie886",
                        "content": "John Cena??? Really?"
                    }
                ]
            },
            {
                "id": 1576186,
                "content": [
                    {
                        "username": "vhood",
                        "content": "> weight is the weight of the person in kilograms\nExample: Winston weight 500kg\n\nO_O"
                    },
                    {
                        "username": "saptarshi_99",
                        "content": "That\\'s because Winston is a gorilla disguised as a person. This was a tricky part to catch as no hints were given. I\\'m glad I could catch it."
                    },
                    {
                        "username": "pradhumn_chourey",
                        "content": "thanks"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect top 1 person_name\\nfrom\\n(select person_name,\\n        turn,\\n        sum(weight)over(order by turn) as cum\\nfrom queue) a\\nwhere cum <= 1000\\norder by turn desc\\n\\n\\n2)\\nselect top 1 a.person_name\\nfrom queue a\\nleft join queue b\\non a.turn >= b.turn\\ngroup by a.person_name\\nhaving sum(b.weight) <= 1000\\norder by sum(b.weight) desc"
                    },
                    {
                        "username": "rainversion_3",
                        "content": "the solution with joins was very tricky to understand at first glance"
                    },
                    {
                        "username": "kmp1084",
                        "content": "deep"
                    },
                    {
                        "username": "jerrymrj",
                        "content": "with cte as (SELECT person_name,weight,turn,SUM(weight) over (order by turn) as total from Queue)\\nSELECT person_name  \\nFROM cte \\nwhere total <= 1000\\norder by total DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "Ahsan-Haider",
                        "content": "LIMIT 1 is not working in Oracle, otherwise the code is running well."
                    },
                    {
                        "username": "jagadevappa_patil",
                        "content": "\\nselect person_name\\nfrom (\\nselect person_id,person_name ,weight,sum(weight) over ( order by turn asc ROWS BETWEEN UNBOUNDED PRECEDING and CURRENT ROW ) as C_SUm \\nfrom Queue\\n)x where C_SUM <=1000 \\norder by C_SUM desc limit 1\\n"
                    },
                    {
                        "username": "2019share",
                        "content": "With A as \\n(select *,\\nsum(weight) over (order by turn asc ROWS between unbounded preceding and current row) as running_total,\\nlag(weight,1)over(order by turn asc)as lag\\nFROM Queue),\\nB as (\\nSelect person_name, \\ncase \\nwhen running_total<1000\\n    and  lead(running_total,1)over(order by turn asc) >1000 then 1    \\nwhen running_total = 1000 then 1\\nwhen lead(running_total,1)over(order by turn asc) is null and running_total < 1000 then 1\\nelse 0 end as flag\\nFROM A)\\nselect person_name from B\\nwhere flag = 1"
                    },
                    {
                        "username": "bianjin12345",
                        "content": "\\nselect person_name from queue where turn = \\n(select max(turn)\\n from (SELECT turn, sum(weight) over(order by turn) a from queue)k where  k.a<=1000)"
                    },
                    {
                        "username": "tanayanandanwar",
                        "content": "\\'\\'\\'select person_name\\nfrom queue\\nwhere turn=(select max(turn) from\\n(select case when sum(weight) over (order by turn) <=1000 then turn end as turn\\nfrom queue))\\'\\'\\'"
                    },
                    {
                        "username": "meaganking",
                        "content": "with cte as (SELECT person_name, SUM(weight) OVER (ORDER BY turn ASC) as \\'run\\'\\n            FROM Queue)\\n\\nSELECT top 1 person_name\\nFROM cte\\nWHERE run <=1000\\nORDER BY run DESC;"
                    },
                    {
                        "username": "spookie886",
                        "content": "John Cena??? Really?"
                    }
                ]
            },
            {
                "id": 1574688,
                "content": [
                    {
                        "username": "vhood",
                        "content": "> weight is the weight of the person in kilograms\nExample: Winston weight 500kg\n\nO_O"
                    },
                    {
                        "username": "saptarshi_99",
                        "content": "That\\'s because Winston is a gorilla disguised as a person. This was a tricky part to catch as no hints were given. I\\'m glad I could catch it."
                    },
                    {
                        "username": "pradhumn_chourey",
                        "content": "thanks"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect top 1 person_name\\nfrom\\n(select person_name,\\n        turn,\\n        sum(weight)over(order by turn) as cum\\nfrom queue) a\\nwhere cum <= 1000\\norder by turn desc\\n\\n\\n2)\\nselect top 1 a.person_name\\nfrom queue a\\nleft join queue b\\non a.turn >= b.turn\\ngroup by a.person_name\\nhaving sum(b.weight) <= 1000\\norder by sum(b.weight) desc"
                    },
                    {
                        "username": "rainversion_3",
                        "content": "the solution with joins was very tricky to understand at first glance"
                    },
                    {
                        "username": "kmp1084",
                        "content": "deep"
                    },
                    {
                        "username": "jerrymrj",
                        "content": "with cte as (SELECT person_name,weight,turn,SUM(weight) over (order by turn) as total from Queue)\\nSELECT person_name  \\nFROM cte \\nwhere total <= 1000\\norder by total DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "Ahsan-Haider",
                        "content": "LIMIT 1 is not working in Oracle, otherwise the code is running well."
                    },
                    {
                        "username": "jagadevappa_patil",
                        "content": "\\nselect person_name\\nfrom (\\nselect person_id,person_name ,weight,sum(weight) over ( order by turn asc ROWS BETWEEN UNBOUNDED PRECEDING and CURRENT ROW ) as C_SUm \\nfrom Queue\\n)x where C_SUM <=1000 \\norder by C_SUM desc limit 1\\n"
                    },
                    {
                        "username": "2019share",
                        "content": "With A as \\n(select *,\\nsum(weight) over (order by turn asc ROWS between unbounded preceding and current row) as running_total,\\nlag(weight,1)over(order by turn asc)as lag\\nFROM Queue),\\nB as (\\nSelect person_name, \\ncase \\nwhen running_total<1000\\n    and  lead(running_total,1)over(order by turn asc) >1000 then 1    \\nwhen running_total = 1000 then 1\\nwhen lead(running_total,1)over(order by turn asc) is null and running_total < 1000 then 1\\nelse 0 end as flag\\nFROM A)\\nselect person_name from B\\nwhere flag = 1"
                    },
                    {
                        "username": "bianjin12345",
                        "content": "\\nselect person_name from queue where turn = \\n(select max(turn)\\n from (SELECT turn, sum(weight) over(order by turn) a from queue)k where  k.a<=1000)"
                    },
                    {
                        "username": "tanayanandanwar",
                        "content": "\\'\\'\\'select person_name\\nfrom queue\\nwhere turn=(select max(turn) from\\n(select case when sum(weight) over (order by turn) <=1000 then turn end as turn\\nfrom queue))\\'\\'\\'"
                    },
                    {
                        "username": "meaganking",
                        "content": "with cte as (SELECT person_name, SUM(weight) OVER (ORDER BY turn ASC) as \\'run\\'\\n            FROM Queue)\\n\\nSELECT top 1 person_name\\nFROM cte\\nWHERE run <=1000\\nORDER BY run DESC;"
                    },
                    {
                        "username": "spookie886",
                        "content": "John Cena??? Really?"
                    }
                ]
            },
            {
                "id": 1573119,
                "content": [
                    {
                        "username": "vhood",
                        "content": "> weight is the weight of the person in kilograms\nExample: Winston weight 500kg\n\nO_O"
                    },
                    {
                        "username": "saptarshi_99",
                        "content": "That\\'s because Winston is a gorilla disguised as a person. This was a tricky part to catch as no hints were given. I\\'m glad I could catch it."
                    },
                    {
                        "username": "pradhumn_chourey",
                        "content": "thanks"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect top 1 person_name\\nfrom\\n(select person_name,\\n        turn,\\n        sum(weight)over(order by turn) as cum\\nfrom queue) a\\nwhere cum <= 1000\\norder by turn desc\\n\\n\\n2)\\nselect top 1 a.person_name\\nfrom queue a\\nleft join queue b\\non a.turn >= b.turn\\ngroup by a.person_name\\nhaving sum(b.weight) <= 1000\\norder by sum(b.weight) desc"
                    },
                    {
                        "username": "rainversion_3",
                        "content": "the solution with joins was very tricky to understand at first glance"
                    },
                    {
                        "username": "kmp1084",
                        "content": "deep"
                    },
                    {
                        "username": "jerrymrj",
                        "content": "with cte as (SELECT person_name,weight,turn,SUM(weight) over (order by turn) as total from Queue)\\nSELECT person_name  \\nFROM cte \\nwhere total <= 1000\\norder by total DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "Ahsan-Haider",
                        "content": "LIMIT 1 is not working in Oracle, otherwise the code is running well."
                    },
                    {
                        "username": "jagadevappa_patil",
                        "content": "\\nselect person_name\\nfrom (\\nselect person_id,person_name ,weight,sum(weight) over ( order by turn asc ROWS BETWEEN UNBOUNDED PRECEDING and CURRENT ROW ) as C_SUm \\nfrom Queue\\n)x where C_SUM <=1000 \\norder by C_SUM desc limit 1\\n"
                    },
                    {
                        "username": "2019share",
                        "content": "With A as \\n(select *,\\nsum(weight) over (order by turn asc ROWS between unbounded preceding and current row) as running_total,\\nlag(weight,1)over(order by turn asc)as lag\\nFROM Queue),\\nB as (\\nSelect person_name, \\ncase \\nwhen running_total<1000\\n    and  lead(running_total,1)over(order by turn asc) >1000 then 1    \\nwhen running_total = 1000 then 1\\nwhen lead(running_total,1)over(order by turn asc) is null and running_total < 1000 then 1\\nelse 0 end as flag\\nFROM A)\\nselect person_name from B\\nwhere flag = 1"
                    },
                    {
                        "username": "bianjin12345",
                        "content": "\\nselect person_name from queue where turn = \\n(select max(turn)\\n from (SELECT turn, sum(weight) over(order by turn) a from queue)k where  k.a<=1000)"
                    },
                    {
                        "username": "tanayanandanwar",
                        "content": "\\'\\'\\'select person_name\\nfrom queue\\nwhere turn=(select max(turn) from\\n(select case when sum(weight) over (order by turn) <=1000 then turn end as turn\\nfrom queue))\\'\\'\\'"
                    },
                    {
                        "username": "meaganking",
                        "content": "with cte as (SELECT person_name, SUM(weight) OVER (ORDER BY turn ASC) as \\'run\\'\\n            FROM Queue)\\n\\nSELECT top 1 person_name\\nFROM cte\\nWHERE run <=1000\\nORDER BY run DESC;"
                    },
                    {
                        "username": "spookie886",
                        "content": "John Cena??? Really?"
                    }
                ]
            },
            {
                "id": 1574023,
                "content": [
                    {
                        "username": "vhood",
                        "content": "> weight is the weight of the person in kilograms\nExample: Winston weight 500kg\n\nO_O"
                    },
                    {
                        "username": "saptarshi_99",
                        "content": "That\\'s because Winston is a gorilla disguised as a person. This was a tricky part to catch as no hints were given. I\\'m glad I could catch it."
                    },
                    {
                        "username": "pradhumn_chourey",
                        "content": "thanks"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect top 1 person_name\\nfrom\\n(select person_name,\\n        turn,\\n        sum(weight)over(order by turn) as cum\\nfrom queue) a\\nwhere cum <= 1000\\norder by turn desc\\n\\n\\n2)\\nselect top 1 a.person_name\\nfrom queue a\\nleft join queue b\\non a.turn >= b.turn\\ngroup by a.person_name\\nhaving sum(b.weight) <= 1000\\norder by sum(b.weight) desc"
                    },
                    {
                        "username": "rainversion_3",
                        "content": "the solution with joins was very tricky to understand at first glance"
                    },
                    {
                        "username": "kmp1084",
                        "content": "deep"
                    },
                    {
                        "username": "jerrymrj",
                        "content": "with cte as (SELECT person_name,weight,turn,SUM(weight) over (order by turn) as total from Queue)\\nSELECT person_name  \\nFROM cte \\nwhere total <= 1000\\norder by total DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "Ahsan-Haider",
                        "content": "LIMIT 1 is not working in Oracle, otherwise the code is running well."
                    },
                    {
                        "username": "jagadevappa_patil",
                        "content": "\\nselect person_name\\nfrom (\\nselect person_id,person_name ,weight,sum(weight) over ( order by turn asc ROWS BETWEEN UNBOUNDED PRECEDING and CURRENT ROW ) as C_SUm \\nfrom Queue\\n)x where C_SUM <=1000 \\norder by C_SUM desc limit 1\\n"
                    },
                    {
                        "username": "2019share",
                        "content": "With A as \\n(select *,\\nsum(weight) over (order by turn asc ROWS between unbounded preceding and current row) as running_total,\\nlag(weight,1)over(order by turn asc)as lag\\nFROM Queue),\\nB as (\\nSelect person_name, \\ncase \\nwhen running_total<1000\\n    and  lead(running_total,1)over(order by turn asc) >1000 then 1    \\nwhen running_total = 1000 then 1\\nwhen lead(running_total,1)over(order by turn asc) is null and running_total < 1000 then 1\\nelse 0 end as flag\\nFROM A)\\nselect person_name from B\\nwhere flag = 1"
                    },
                    {
                        "username": "bianjin12345",
                        "content": "\\nselect person_name from queue where turn = \\n(select max(turn)\\n from (SELECT turn, sum(weight) over(order by turn) a from queue)k where  k.a<=1000)"
                    },
                    {
                        "username": "tanayanandanwar",
                        "content": "\\'\\'\\'select person_name\\nfrom queue\\nwhere turn=(select max(turn) from\\n(select case when sum(weight) over (order by turn) <=1000 then turn end as turn\\nfrom queue))\\'\\'\\'"
                    },
                    {
                        "username": "meaganking",
                        "content": "with cte as (SELECT person_name, SUM(weight) OVER (ORDER BY turn ASC) as \\'run\\'\\n            FROM Queue)\\n\\nSELECT top 1 person_name\\nFROM cte\\nWHERE run <=1000\\nORDER BY run DESC;"
                    },
                    {
                        "username": "spookie886",
                        "content": "John Cena??? Really?"
                    }
                ]
            },
            {
                "id": 1573574,
                "content": [
                    {
                        "username": "vhood",
                        "content": "> weight is the weight of the person in kilograms\nExample: Winston weight 500kg\n\nO_O"
                    },
                    {
                        "username": "saptarshi_99",
                        "content": "That\\'s because Winston is a gorilla disguised as a person. This was a tricky part to catch as no hints were given. I\\'m glad I could catch it."
                    },
                    {
                        "username": "pradhumn_chourey",
                        "content": "thanks"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect top 1 person_name\\nfrom\\n(select person_name,\\n        turn,\\n        sum(weight)over(order by turn) as cum\\nfrom queue) a\\nwhere cum <= 1000\\norder by turn desc\\n\\n\\n2)\\nselect top 1 a.person_name\\nfrom queue a\\nleft join queue b\\non a.turn >= b.turn\\ngroup by a.person_name\\nhaving sum(b.weight) <= 1000\\norder by sum(b.weight) desc"
                    },
                    {
                        "username": "rainversion_3",
                        "content": "the solution with joins was very tricky to understand at first glance"
                    },
                    {
                        "username": "kmp1084",
                        "content": "deep"
                    },
                    {
                        "username": "jerrymrj",
                        "content": "with cte as (SELECT person_name,weight,turn,SUM(weight) over (order by turn) as total from Queue)\\nSELECT person_name  \\nFROM cte \\nwhere total <= 1000\\norder by total DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "Ahsan-Haider",
                        "content": "LIMIT 1 is not working in Oracle, otherwise the code is running well."
                    },
                    {
                        "username": "jagadevappa_patil",
                        "content": "\\nselect person_name\\nfrom (\\nselect person_id,person_name ,weight,sum(weight) over ( order by turn asc ROWS BETWEEN UNBOUNDED PRECEDING and CURRENT ROW ) as C_SUm \\nfrom Queue\\n)x where C_SUM <=1000 \\norder by C_SUM desc limit 1\\n"
                    },
                    {
                        "username": "2019share",
                        "content": "With A as \\n(select *,\\nsum(weight) over (order by turn asc ROWS between unbounded preceding and current row) as running_total,\\nlag(weight,1)over(order by turn asc)as lag\\nFROM Queue),\\nB as (\\nSelect person_name, \\ncase \\nwhen running_total<1000\\n    and  lead(running_total,1)over(order by turn asc) >1000 then 1    \\nwhen running_total = 1000 then 1\\nwhen lead(running_total,1)over(order by turn asc) is null and running_total < 1000 then 1\\nelse 0 end as flag\\nFROM A)\\nselect person_name from B\\nwhere flag = 1"
                    },
                    {
                        "username": "bianjin12345",
                        "content": "\\nselect person_name from queue where turn = \\n(select max(turn)\\n from (SELECT turn, sum(weight) over(order by turn) a from queue)k where  k.a<=1000)"
                    },
                    {
                        "username": "tanayanandanwar",
                        "content": "\\'\\'\\'select person_name\\nfrom queue\\nwhere turn=(select max(turn) from\\n(select case when sum(weight) over (order by turn) <=1000 then turn end as turn\\nfrom queue))\\'\\'\\'"
                    },
                    {
                        "username": "meaganking",
                        "content": "with cte as (SELECT person_name, SUM(weight) OVER (ORDER BY turn ASC) as \\'run\\'\\n            FROM Queue)\\n\\nSELECT top 1 person_name\\nFROM cte\\nWHERE run <=1000\\nORDER BY run DESC;"
                    },
                    {
                        "username": "spookie886",
                        "content": "John Cena??? Really?"
                    }
                ]
            },
            {
                "id": 1573447,
                "content": [
                    {
                        "username": "vhood",
                        "content": "> weight is the weight of the person in kilograms\nExample: Winston weight 500kg\n\nO_O"
                    },
                    {
                        "username": "saptarshi_99",
                        "content": "That\\'s because Winston is a gorilla disguised as a person. This was a tricky part to catch as no hints were given. I\\'m glad I could catch it."
                    },
                    {
                        "username": "pradhumn_chourey",
                        "content": "thanks"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect top 1 person_name\\nfrom\\n(select person_name,\\n        turn,\\n        sum(weight)over(order by turn) as cum\\nfrom queue) a\\nwhere cum <= 1000\\norder by turn desc\\n\\n\\n2)\\nselect top 1 a.person_name\\nfrom queue a\\nleft join queue b\\non a.turn >= b.turn\\ngroup by a.person_name\\nhaving sum(b.weight) <= 1000\\norder by sum(b.weight) desc"
                    },
                    {
                        "username": "rainversion_3",
                        "content": "the solution with joins was very tricky to understand at first glance"
                    },
                    {
                        "username": "kmp1084",
                        "content": "deep"
                    },
                    {
                        "username": "jerrymrj",
                        "content": "with cte as (SELECT person_name,weight,turn,SUM(weight) over (order by turn) as total from Queue)\\nSELECT person_name  \\nFROM cte \\nwhere total <= 1000\\norder by total DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "Ahsan-Haider",
                        "content": "LIMIT 1 is not working in Oracle, otherwise the code is running well."
                    },
                    {
                        "username": "jagadevappa_patil",
                        "content": "\\nselect person_name\\nfrom (\\nselect person_id,person_name ,weight,sum(weight) over ( order by turn asc ROWS BETWEEN UNBOUNDED PRECEDING and CURRENT ROW ) as C_SUm \\nfrom Queue\\n)x where C_SUM <=1000 \\norder by C_SUM desc limit 1\\n"
                    },
                    {
                        "username": "2019share",
                        "content": "With A as \\n(select *,\\nsum(weight) over (order by turn asc ROWS between unbounded preceding and current row) as running_total,\\nlag(weight,1)over(order by turn asc)as lag\\nFROM Queue),\\nB as (\\nSelect person_name, \\ncase \\nwhen running_total<1000\\n    and  lead(running_total,1)over(order by turn asc) >1000 then 1    \\nwhen running_total = 1000 then 1\\nwhen lead(running_total,1)over(order by turn asc) is null and running_total < 1000 then 1\\nelse 0 end as flag\\nFROM A)\\nselect person_name from B\\nwhere flag = 1"
                    },
                    {
                        "username": "bianjin12345",
                        "content": "\\nselect person_name from queue where turn = \\n(select max(turn)\\n from (SELECT turn, sum(weight) over(order by turn) a from queue)k where  k.a<=1000)"
                    },
                    {
                        "username": "tanayanandanwar",
                        "content": "\\'\\'\\'select person_name\\nfrom queue\\nwhere turn=(select max(turn) from\\n(select case when sum(weight) over (order by turn) <=1000 then turn end as turn\\nfrom queue))\\'\\'\\'"
                    },
                    {
                        "username": "meaganking",
                        "content": "with cte as (SELECT person_name, SUM(weight) OVER (ORDER BY turn ASC) as \\'run\\'\\n            FROM Queue)\\n\\nSELECT top 1 person_name\\nFROM cte\\nWHERE run <=1000\\nORDER BY run DESC;"
                    },
                    {
                        "username": "spookie886",
                        "content": "John Cena??? Really?"
                    }
                ]
            },
            {
                "id": 2030471,
                "content": [
                    {
                        "username": "vhood",
                        "content": "> weight is the weight of the person in kilograms\nExample: Winston weight 500kg\n\nO_O"
                    },
                    {
                        "username": "saptarshi_99",
                        "content": "That\\'s because Winston is a gorilla disguised as a person. This was a tricky part to catch as no hints were given. I\\'m glad I could catch it."
                    },
                    {
                        "username": "pradhumn_chourey",
                        "content": "thanks"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect top 1 person_name\\nfrom\\n(select person_name,\\n        turn,\\n        sum(weight)over(order by turn) as cum\\nfrom queue) a\\nwhere cum <= 1000\\norder by turn desc\\n\\n\\n2)\\nselect top 1 a.person_name\\nfrom queue a\\nleft join queue b\\non a.turn >= b.turn\\ngroup by a.person_name\\nhaving sum(b.weight) <= 1000\\norder by sum(b.weight) desc"
                    },
                    {
                        "username": "rainversion_3",
                        "content": "the solution with joins was very tricky to understand at first glance"
                    },
                    {
                        "username": "kmp1084",
                        "content": "deep"
                    },
                    {
                        "username": "jerrymrj",
                        "content": "with cte as (SELECT person_name,weight,turn,SUM(weight) over (order by turn) as total from Queue)\\nSELECT person_name  \\nFROM cte \\nwhere total <= 1000\\norder by total DESC\\nLIMIT 1;"
                    },
                    {
                        "username": "Ahsan-Haider",
                        "content": "LIMIT 1 is not working in Oracle, otherwise the code is running well."
                    },
                    {
                        "username": "jagadevappa_patil",
                        "content": "\\nselect person_name\\nfrom (\\nselect person_id,person_name ,weight,sum(weight) over ( order by turn asc ROWS BETWEEN UNBOUNDED PRECEDING and CURRENT ROW ) as C_SUm \\nfrom Queue\\n)x where C_SUM <=1000 \\norder by C_SUM desc limit 1\\n"
                    },
                    {
                        "username": "2019share",
                        "content": "With A as \\n(select *,\\nsum(weight) over (order by turn asc ROWS between unbounded preceding and current row) as running_total,\\nlag(weight,1)over(order by turn asc)as lag\\nFROM Queue),\\nB as (\\nSelect person_name, \\ncase \\nwhen running_total<1000\\n    and  lead(running_total,1)over(order by turn asc) >1000 then 1    \\nwhen running_total = 1000 then 1\\nwhen lead(running_total,1)over(order by turn asc) is null and running_total < 1000 then 1\\nelse 0 end as flag\\nFROM A)\\nselect person_name from B\\nwhere flag = 1"
                    },
                    {
                        "username": "bianjin12345",
                        "content": "\\nselect person_name from queue where turn = \\n(select max(turn)\\n from (SELECT turn, sum(weight) over(order by turn) a from queue)k where  k.a<=1000)"
                    },
                    {
                        "username": "tanayanandanwar",
                        "content": "\\'\\'\\'select person_name\\nfrom queue\\nwhere turn=(select max(turn) from\\n(select case when sum(weight) over (order by turn) <=1000 then turn end as turn\\nfrom queue))\\'\\'\\'"
                    },
                    {
                        "username": "meaganking",
                        "content": "with cte as (SELECT person_name, SUM(weight) OVER (ORDER BY turn ASC) as \\'run\\'\\n            FROM Queue)\\n\\nSELECT top 1 person_name\\nFROM cte\\nWHERE run <=1000\\nORDER BY run DESC;"
                    },
                    {
                        "username": "spookie886",
                        "content": "John Cena??? Really?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Monthly Transactions II",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1565876,
                "content": [
                    {
                        "username": "goodfine1210",
                        "content": "{\"headers\":{\"Transactions\":[\"id\",\"country\",\"state\",\"amount\",\"trans_date\"],\"Chargebacks\":[\"trans_id\",\"trans_date\"]},\"rows\":{\"Transactions\":[[101,\"US\",\"approved\",1000,\"2019-05-18\"],[102,\"US\",\"declined\",2000,\"2019-05-19\"],[103,\"US\",\"approved\",3000,\"2019-06-10\"],[104,\"US\",\"declined\",4000,\"2019-06-13\"],[105,\"US\",\"approved\",5000,\"2019-06-15\"]],\"Chargebacks\":[[102,\"2019-05-29\"],[101,\"2019-06-30\"],[105,\"2019-09-18\"]]}}\\n\\n\\nIt seems that \\n[104,\"US\",\"declined\",4000,\"2019-06-13\"] is different from problem statement?\\n"
                    },
                    {
                        "username": "kgopu",
                        "content": "/* Write your PL/SQL query statement below */\\n\\nSELECT \\n month,\\n country,\\n SUM(approved_count) approved_count,\\n SUM(approved_amount) approved_amount,\\n SUM(chargeback_count) chargeback_count,\\n SUM(chargeback_amount) chargeback_amount\\nFROM \\n(\\n-- 1st Union getting only approved transactions using case for fetching counts and amounts and having chargeback columns with 0\\nSELECT * FROM\\n(\\nSELECT substr(trans_date,1,7) month,\\ncountry,\\nSUM(CASE WHEN state=\\'approved\\' THEN 1 ELSE 0 END) approved_count,\\nSUM(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) approved_amount,\\n0 chargeback_count,\\n0 chargeback_amount\\nFROM transactions\\nWHERE 1=1\\nAND state=\\'approved\\'\\nGROUP BY substr(trans_date,1,7),country)\\nUNION ALL\\n-- 2nd Union getting combined amount details and having approved columns with 0\\nSELECT * FROM \\n(\\nSELECT substr(cb.trans_date,1,7) month,\\nt.country,\\n0 approved_count,\\n0 approved_amount,\\ncount(trans_id) chargeback_count,\\nSUM(amount) chargeback_amount\\nFROM transactions t, chargebacks cb\\nWHERE 1=1\\nAND t.id=cb.trans_id\\n-- AND chargeback_count!=0\\nGROUP BY substr(cb.trans_date,1,7),country\\n))\\nGROUP BY month,country"
                    },
                    {
                        "username": "leetcode1002",
                        "content": "with cte as\\n(select c.trans_id as id, t.country, \\'chargeback\\' as state, t.amount, c.trans_date\\nfrom chargebacks c join transactions t\\non c.trans_id = t.id\\nunion \\nselect * from transactions)\\nselect left(trans_date,7) as month, country, \\nsum(case when state = \\'approved\\' then 1 else 0 end) as approved_count,\\nsum(case when state = \\'approved\\' then amount else 0 end)approved_amount,\\nsum(case when state = \\'chargeback\\' then 1 else 0 end) as chargeback_count,\\nsum(case when state = \\'chargeback\\' then amount else 0 end)chargeback_amount\\nfrom cte\\ngroup by left(trans_date,7), country\\nhaving approved_count>0 or approved_amount>0 or chargeback_count>0 or chargeback_amount>0\\norder by left(trans_date,7)"
                    },
                    {
                        "username": "Liloli",
                        "content": "what\\'s the definition of chargeback_amount.\\nHow to calculate this amount? \\nI can\\'t figure it out by reading the tables."
                    },
                    {
                        "username": "Shikha_Verma",
                        "content": "I have a conceptual question:\\nFor transaction with id=105, it took place on 2019-06-15 but chargeback was realised on 2019-09-18, the chargeback would still get counted in 2019-06 not 2019-09.\\nIf that is the case,a left join on transaction with chargeback table and use CASE statements should work.\\nCan anyone help me understand why this is incorrect?\\n"
                    },
                    {
                        "username": "sudhirmalik415",
                        "content": "This question is not right take example of id 104 this is not get counted in chargebacks absolutely ridiculous. "
                    },
                    {
                        "username": "yz541",
                        "content": "With CTE as (\\nselect * from Transactions \\nunion all\\nselect c.trans_id as id, t.country, \\'Chargeback\\' as state, t.amount,c.trans_date from Chargebacks  C left join Transactions T on T.id =c.trans_id )\\n\\nselect * from \\n(\\nselect to_char(trans_date,\\'YYYY-MM\\') as month, country, sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count, sum(case when state = \\'approved\\' then amount else 0 end) as approved_amount, sum(case when state = \\'Chargeback\\' then 1 else 0 end) as chargeback_count, sum(case when state = \\'Chargeback\\' then amount else 0 end) as chargeback_amount\\nfrom CTE \\ngroup by to_char(trans_date,\\'YYYY-MM\\'), country)tmp\\n\\nWHERE approved_count <> 0 OR chargeback_count <>0  -- need to subquery after CTE to care of the case where rows with all zeros\\n\\n"
                    },
                    {
                        "username": "dosjffltmxm",
                        "content": "Hi all, \\n\\nI\\'m having an issue understanding why state=\\'approved\\' should be executed in cte. \\n\\nthanks! \\n\\n================\\n\\nWITH cte AS(\\n    SELECT \\n    id, country,state,amount,DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    FROM Transactions t\\n    WHERE state=\\'approved\\' ** why this is needed? \\n    UNION ALL \\n    SELECT \\n    c.trans_id, t.country, \\'chargebacks\\' as state, t.amount,  DATE_FORMAT(c.trans_date, \\'%Y-%m\\') AS month\\n    FROM Chargebacks c\\n    LEFT JOIN Transactions t\\n    ON t.id = c.trans_id\\n)\\nSELECT \\nmonth, country,\\nsum(CASE WHEN state=\\'approved\\' THEN 1 ELSE 0 END) AS approved_count ,\\nsum(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) AS approved_amount ,\\nsum(CASE WHEN state=\\'chargebacks\\' THEN 1 ELSE 0 END) AS chargeback_count  ,\\nsum(CASE WHEN state=\\'chargebacks\\' THEN amount ELSE 0 END) AS chargeback_amount  \\nFROM cte \\nGROUP BY 1,2\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1569943,
                "content": [
                    {
                        "username": "goodfine1210",
                        "content": "{\"headers\":{\"Transactions\":[\"id\",\"country\",\"state\",\"amount\",\"trans_date\"],\"Chargebacks\":[\"trans_id\",\"trans_date\"]},\"rows\":{\"Transactions\":[[101,\"US\",\"approved\",1000,\"2019-05-18\"],[102,\"US\",\"declined\",2000,\"2019-05-19\"],[103,\"US\",\"approved\",3000,\"2019-06-10\"],[104,\"US\",\"declined\",4000,\"2019-06-13\"],[105,\"US\",\"approved\",5000,\"2019-06-15\"]],\"Chargebacks\":[[102,\"2019-05-29\"],[101,\"2019-06-30\"],[105,\"2019-09-18\"]]}}\\n\\n\\nIt seems that \\n[104,\"US\",\"declined\",4000,\"2019-06-13\"] is different from problem statement?\\n"
                    },
                    {
                        "username": "kgopu",
                        "content": "/* Write your PL/SQL query statement below */\\n\\nSELECT \\n month,\\n country,\\n SUM(approved_count) approved_count,\\n SUM(approved_amount) approved_amount,\\n SUM(chargeback_count) chargeback_count,\\n SUM(chargeback_amount) chargeback_amount\\nFROM \\n(\\n-- 1st Union getting only approved transactions using case for fetching counts and amounts and having chargeback columns with 0\\nSELECT * FROM\\n(\\nSELECT substr(trans_date,1,7) month,\\ncountry,\\nSUM(CASE WHEN state=\\'approved\\' THEN 1 ELSE 0 END) approved_count,\\nSUM(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) approved_amount,\\n0 chargeback_count,\\n0 chargeback_amount\\nFROM transactions\\nWHERE 1=1\\nAND state=\\'approved\\'\\nGROUP BY substr(trans_date,1,7),country)\\nUNION ALL\\n-- 2nd Union getting combined amount details and having approved columns with 0\\nSELECT * FROM \\n(\\nSELECT substr(cb.trans_date,1,7) month,\\nt.country,\\n0 approved_count,\\n0 approved_amount,\\ncount(trans_id) chargeback_count,\\nSUM(amount) chargeback_amount\\nFROM transactions t, chargebacks cb\\nWHERE 1=1\\nAND t.id=cb.trans_id\\n-- AND chargeback_count!=0\\nGROUP BY substr(cb.trans_date,1,7),country\\n))\\nGROUP BY month,country"
                    },
                    {
                        "username": "leetcode1002",
                        "content": "with cte as\\n(select c.trans_id as id, t.country, \\'chargeback\\' as state, t.amount, c.trans_date\\nfrom chargebacks c join transactions t\\non c.trans_id = t.id\\nunion \\nselect * from transactions)\\nselect left(trans_date,7) as month, country, \\nsum(case when state = \\'approved\\' then 1 else 0 end) as approved_count,\\nsum(case when state = \\'approved\\' then amount else 0 end)approved_amount,\\nsum(case when state = \\'chargeback\\' then 1 else 0 end) as chargeback_count,\\nsum(case when state = \\'chargeback\\' then amount else 0 end)chargeback_amount\\nfrom cte\\ngroup by left(trans_date,7), country\\nhaving approved_count>0 or approved_amount>0 or chargeback_count>0 or chargeback_amount>0\\norder by left(trans_date,7)"
                    },
                    {
                        "username": "Liloli",
                        "content": "what\\'s the definition of chargeback_amount.\\nHow to calculate this amount? \\nI can\\'t figure it out by reading the tables."
                    },
                    {
                        "username": "Shikha_Verma",
                        "content": "I have a conceptual question:\\nFor transaction with id=105, it took place on 2019-06-15 but chargeback was realised on 2019-09-18, the chargeback would still get counted in 2019-06 not 2019-09.\\nIf that is the case,a left join on transaction with chargeback table and use CASE statements should work.\\nCan anyone help me understand why this is incorrect?\\n"
                    },
                    {
                        "username": "sudhirmalik415",
                        "content": "This question is not right take example of id 104 this is not get counted in chargebacks absolutely ridiculous. "
                    },
                    {
                        "username": "yz541",
                        "content": "With CTE as (\\nselect * from Transactions \\nunion all\\nselect c.trans_id as id, t.country, \\'Chargeback\\' as state, t.amount,c.trans_date from Chargebacks  C left join Transactions T on T.id =c.trans_id )\\n\\nselect * from \\n(\\nselect to_char(trans_date,\\'YYYY-MM\\') as month, country, sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count, sum(case when state = \\'approved\\' then amount else 0 end) as approved_amount, sum(case when state = \\'Chargeback\\' then 1 else 0 end) as chargeback_count, sum(case when state = \\'Chargeback\\' then amount else 0 end) as chargeback_amount\\nfrom CTE \\ngroup by to_char(trans_date,\\'YYYY-MM\\'), country)tmp\\n\\nWHERE approved_count <> 0 OR chargeback_count <>0  -- need to subquery after CTE to care of the case where rows with all zeros\\n\\n"
                    },
                    {
                        "username": "dosjffltmxm",
                        "content": "Hi all, \\n\\nI\\'m having an issue understanding why state=\\'approved\\' should be executed in cte. \\n\\nthanks! \\n\\n================\\n\\nWITH cte AS(\\n    SELECT \\n    id, country,state,amount,DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    FROM Transactions t\\n    WHERE state=\\'approved\\' ** why this is needed? \\n    UNION ALL \\n    SELECT \\n    c.trans_id, t.country, \\'chargebacks\\' as state, t.amount,  DATE_FORMAT(c.trans_date, \\'%Y-%m\\') AS month\\n    FROM Chargebacks c\\n    LEFT JOIN Transactions t\\n    ON t.id = c.trans_id\\n)\\nSELECT \\nmonth, country,\\nsum(CASE WHEN state=\\'approved\\' THEN 1 ELSE 0 END) AS approved_count ,\\nsum(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) AS approved_amount ,\\nsum(CASE WHEN state=\\'chargebacks\\' THEN 1 ELSE 0 END) AS chargeback_count  ,\\nsum(CASE WHEN state=\\'chargebacks\\' THEN amount ELSE 0 END) AS chargeback_amount  \\nFROM cte \\nGROUP BY 1,2\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1575756,
                "content": [
                    {
                        "username": "goodfine1210",
                        "content": "{\"headers\":{\"Transactions\":[\"id\",\"country\",\"state\",\"amount\",\"trans_date\"],\"Chargebacks\":[\"trans_id\",\"trans_date\"]},\"rows\":{\"Transactions\":[[101,\"US\",\"approved\",1000,\"2019-05-18\"],[102,\"US\",\"declined\",2000,\"2019-05-19\"],[103,\"US\",\"approved\",3000,\"2019-06-10\"],[104,\"US\",\"declined\",4000,\"2019-06-13\"],[105,\"US\",\"approved\",5000,\"2019-06-15\"]],\"Chargebacks\":[[102,\"2019-05-29\"],[101,\"2019-06-30\"],[105,\"2019-09-18\"]]}}\\n\\n\\nIt seems that \\n[104,\"US\",\"declined\",4000,\"2019-06-13\"] is different from problem statement?\\n"
                    },
                    {
                        "username": "kgopu",
                        "content": "/* Write your PL/SQL query statement below */\\n\\nSELECT \\n month,\\n country,\\n SUM(approved_count) approved_count,\\n SUM(approved_amount) approved_amount,\\n SUM(chargeback_count) chargeback_count,\\n SUM(chargeback_amount) chargeback_amount\\nFROM \\n(\\n-- 1st Union getting only approved transactions using case for fetching counts and amounts and having chargeback columns with 0\\nSELECT * FROM\\n(\\nSELECT substr(trans_date,1,7) month,\\ncountry,\\nSUM(CASE WHEN state=\\'approved\\' THEN 1 ELSE 0 END) approved_count,\\nSUM(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) approved_amount,\\n0 chargeback_count,\\n0 chargeback_amount\\nFROM transactions\\nWHERE 1=1\\nAND state=\\'approved\\'\\nGROUP BY substr(trans_date,1,7),country)\\nUNION ALL\\n-- 2nd Union getting combined amount details and having approved columns with 0\\nSELECT * FROM \\n(\\nSELECT substr(cb.trans_date,1,7) month,\\nt.country,\\n0 approved_count,\\n0 approved_amount,\\ncount(trans_id) chargeback_count,\\nSUM(amount) chargeback_amount\\nFROM transactions t, chargebacks cb\\nWHERE 1=1\\nAND t.id=cb.trans_id\\n-- AND chargeback_count!=0\\nGROUP BY substr(cb.trans_date,1,7),country\\n))\\nGROUP BY month,country"
                    },
                    {
                        "username": "leetcode1002",
                        "content": "with cte as\\n(select c.trans_id as id, t.country, \\'chargeback\\' as state, t.amount, c.trans_date\\nfrom chargebacks c join transactions t\\non c.trans_id = t.id\\nunion \\nselect * from transactions)\\nselect left(trans_date,7) as month, country, \\nsum(case when state = \\'approved\\' then 1 else 0 end) as approved_count,\\nsum(case when state = \\'approved\\' then amount else 0 end)approved_amount,\\nsum(case when state = \\'chargeback\\' then 1 else 0 end) as chargeback_count,\\nsum(case when state = \\'chargeback\\' then amount else 0 end)chargeback_amount\\nfrom cte\\ngroup by left(trans_date,7), country\\nhaving approved_count>0 or approved_amount>0 or chargeback_count>0 or chargeback_amount>0\\norder by left(trans_date,7)"
                    },
                    {
                        "username": "Liloli",
                        "content": "what\\'s the definition of chargeback_amount.\\nHow to calculate this amount? \\nI can\\'t figure it out by reading the tables."
                    },
                    {
                        "username": "Shikha_Verma",
                        "content": "I have a conceptual question:\\nFor transaction with id=105, it took place on 2019-06-15 but chargeback was realised on 2019-09-18, the chargeback would still get counted in 2019-06 not 2019-09.\\nIf that is the case,a left join on transaction with chargeback table and use CASE statements should work.\\nCan anyone help me understand why this is incorrect?\\n"
                    },
                    {
                        "username": "sudhirmalik415",
                        "content": "This question is not right take example of id 104 this is not get counted in chargebacks absolutely ridiculous. "
                    },
                    {
                        "username": "yz541",
                        "content": "With CTE as (\\nselect * from Transactions \\nunion all\\nselect c.trans_id as id, t.country, \\'Chargeback\\' as state, t.amount,c.trans_date from Chargebacks  C left join Transactions T on T.id =c.trans_id )\\n\\nselect * from \\n(\\nselect to_char(trans_date,\\'YYYY-MM\\') as month, country, sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count, sum(case when state = \\'approved\\' then amount else 0 end) as approved_amount, sum(case when state = \\'Chargeback\\' then 1 else 0 end) as chargeback_count, sum(case when state = \\'Chargeback\\' then amount else 0 end) as chargeback_amount\\nfrom CTE \\ngroup by to_char(trans_date,\\'YYYY-MM\\'), country)tmp\\n\\nWHERE approved_count <> 0 OR chargeback_count <>0  -- need to subquery after CTE to care of the case where rows with all zeros\\n\\n"
                    },
                    {
                        "username": "dosjffltmxm",
                        "content": "Hi all, \\n\\nI\\'m having an issue understanding why state=\\'approved\\' should be executed in cte. \\n\\nthanks! \\n\\n================\\n\\nWITH cte AS(\\n    SELECT \\n    id, country,state,amount,DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    FROM Transactions t\\n    WHERE state=\\'approved\\' ** why this is needed? \\n    UNION ALL \\n    SELECT \\n    c.trans_id, t.country, \\'chargebacks\\' as state, t.amount,  DATE_FORMAT(c.trans_date, \\'%Y-%m\\') AS month\\n    FROM Chargebacks c\\n    LEFT JOIN Transactions t\\n    ON t.id = c.trans_id\\n)\\nSELECT \\nmonth, country,\\nsum(CASE WHEN state=\\'approved\\' THEN 1 ELSE 0 END) AS approved_count ,\\nsum(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) AS approved_amount ,\\nsum(CASE WHEN state=\\'chargebacks\\' THEN 1 ELSE 0 END) AS chargeback_count  ,\\nsum(CASE WHEN state=\\'chargebacks\\' THEN amount ELSE 0 END) AS chargeback_amount  \\nFROM cte \\nGROUP BY 1,2\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1573049,
                "content": [
                    {
                        "username": "goodfine1210",
                        "content": "{\"headers\":{\"Transactions\":[\"id\",\"country\",\"state\",\"amount\",\"trans_date\"],\"Chargebacks\":[\"trans_id\",\"trans_date\"]},\"rows\":{\"Transactions\":[[101,\"US\",\"approved\",1000,\"2019-05-18\"],[102,\"US\",\"declined\",2000,\"2019-05-19\"],[103,\"US\",\"approved\",3000,\"2019-06-10\"],[104,\"US\",\"declined\",4000,\"2019-06-13\"],[105,\"US\",\"approved\",5000,\"2019-06-15\"]],\"Chargebacks\":[[102,\"2019-05-29\"],[101,\"2019-06-30\"],[105,\"2019-09-18\"]]}}\\n\\n\\nIt seems that \\n[104,\"US\",\"declined\",4000,\"2019-06-13\"] is different from problem statement?\\n"
                    },
                    {
                        "username": "kgopu",
                        "content": "/* Write your PL/SQL query statement below */\\n\\nSELECT \\n month,\\n country,\\n SUM(approved_count) approved_count,\\n SUM(approved_amount) approved_amount,\\n SUM(chargeback_count) chargeback_count,\\n SUM(chargeback_amount) chargeback_amount\\nFROM \\n(\\n-- 1st Union getting only approved transactions using case for fetching counts and amounts and having chargeback columns with 0\\nSELECT * FROM\\n(\\nSELECT substr(trans_date,1,7) month,\\ncountry,\\nSUM(CASE WHEN state=\\'approved\\' THEN 1 ELSE 0 END) approved_count,\\nSUM(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) approved_amount,\\n0 chargeback_count,\\n0 chargeback_amount\\nFROM transactions\\nWHERE 1=1\\nAND state=\\'approved\\'\\nGROUP BY substr(trans_date,1,7),country)\\nUNION ALL\\n-- 2nd Union getting combined amount details and having approved columns with 0\\nSELECT * FROM \\n(\\nSELECT substr(cb.trans_date,1,7) month,\\nt.country,\\n0 approved_count,\\n0 approved_amount,\\ncount(trans_id) chargeback_count,\\nSUM(amount) chargeback_amount\\nFROM transactions t, chargebacks cb\\nWHERE 1=1\\nAND t.id=cb.trans_id\\n-- AND chargeback_count!=0\\nGROUP BY substr(cb.trans_date,1,7),country\\n))\\nGROUP BY month,country"
                    },
                    {
                        "username": "leetcode1002",
                        "content": "with cte as\\n(select c.trans_id as id, t.country, \\'chargeback\\' as state, t.amount, c.trans_date\\nfrom chargebacks c join transactions t\\non c.trans_id = t.id\\nunion \\nselect * from transactions)\\nselect left(trans_date,7) as month, country, \\nsum(case when state = \\'approved\\' then 1 else 0 end) as approved_count,\\nsum(case when state = \\'approved\\' then amount else 0 end)approved_amount,\\nsum(case when state = \\'chargeback\\' then 1 else 0 end) as chargeback_count,\\nsum(case when state = \\'chargeback\\' then amount else 0 end)chargeback_amount\\nfrom cte\\ngroup by left(trans_date,7), country\\nhaving approved_count>0 or approved_amount>0 or chargeback_count>0 or chargeback_amount>0\\norder by left(trans_date,7)"
                    },
                    {
                        "username": "Liloli",
                        "content": "what\\'s the definition of chargeback_amount.\\nHow to calculate this amount? \\nI can\\'t figure it out by reading the tables."
                    },
                    {
                        "username": "Shikha_Verma",
                        "content": "I have a conceptual question:\\nFor transaction with id=105, it took place on 2019-06-15 but chargeback was realised on 2019-09-18, the chargeback would still get counted in 2019-06 not 2019-09.\\nIf that is the case,a left join on transaction with chargeback table and use CASE statements should work.\\nCan anyone help me understand why this is incorrect?\\n"
                    },
                    {
                        "username": "sudhirmalik415",
                        "content": "This question is not right take example of id 104 this is not get counted in chargebacks absolutely ridiculous. "
                    },
                    {
                        "username": "yz541",
                        "content": "With CTE as (\\nselect * from Transactions \\nunion all\\nselect c.trans_id as id, t.country, \\'Chargeback\\' as state, t.amount,c.trans_date from Chargebacks  C left join Transactions T on T.id =c.trans_id )\\n\\nselect * from \\n(\\nselect to_char(trans_date,\\'YYYY-MM\\') as month, country, sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count, sum(case when state = \\'approved\\' then amount else 0 end) as approved_amount, sum(case when state = \\'Chargeback\\' then 1 else 0 end) as chargeback_count, sum(case when state = \\'Chargeback\\' then amount else 0 end) as chargeback_amount\\nfrom CTE \\ngroup by to_char(trans_date,\\'YYYY-MM\\'), country)tmp\\n\\nWHERE approved_count <> 0 OR chargeback_count <>0  -- need to subquery after CTE to care of the case where rows with all zeros\\n\\n"
                    },
                    {
                        "username": "dosjffltmxm",
                        "content": "Hi all, \\n\\nI\\'m having an issue understanding why state=\\'approved\\' should be executed in cte. \\n\\nthanks! \\n\\n================\\n\\nWITH cte AS(\\n    SELECT \\n    id, country,state,amount,DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    FROM Transactions t\\n    WHERE state=\\'approved\\' ** why this is needed? \\n    UNION ALL \\n    SELECT \\n    c.trans_id, t.country, \\'chargebacks\\' as state, t.amount,  DATE_FORMAT(c.trans_date, \\'%Y-%m\\') AS month\\n    FROM Chargebacks c\\n    LEFT JOIN Transactions t\\n    ON t.id = c.trans_id\\n)\\nSELECT \\nmonth, country,\\nsum(CASE WHEN state=\\'approved\\' THEN 1 ELSE 0 END) AS approved_count ,\\nsum(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) AS approved_amount ,\\nsum(CASE WHEN state=\\'chargebacks\\' THEN 1 ELSE 0 END) AS chargeback_count  ,\\nsum(CASE WHEN state=\\'chargebacks\\' THEN amount ELSE 0 END) AS chargeback_amount  \\nFROM cte \\nGROUP BY 1,2\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1662720,
                "content": [
                    {
                        "username": "goodfine1210",
                        "content": "{\"headers\":{\"Transactions\":[\"id\",\"country\",\"state\",\"amount\",\"trans_date\"],\"Chargebacks\":[\"trans_id\",\"trans_date\"]},\"rows\":{\"Transactions\":[[101,\"US\",\"approved\",1000,\"2019-05-18\"],[102,\"US\",\"declined\",2000,\"2019-05-19\"],[103,\"US\",\"approved\",3000,\"2019-06-10\"],[104,\"US\",\"declined\",4000,\"2019-06-13\"],[105,\"US\",\"approved\",5000,\"2019-06-15\"]],\"Chargebacks\":[[102,\"2019-05-29\"],[101,\"2019-06-30\"],[105,\"2019-09-18\"]]}}\\n\\n\\nIt seems that \\n[104,\"US\",\"declined\",4000,\"2019-06-13\"] is different from problem statement?\\n"
                    },
                    {
                        "username": "kgopu",
                        "content": "/* Write your PL/SQL query statement below */\\n\\nSELECT \\n month,\\n country,\\n SUM(approved_count) approved_count,\\n SUM(approved_amount) approved_amount,\\n SUM(chargeback_count) chargeback_count,\\n SUM(chargeback_amount) chargeback_amount\\nFROM \\n(\\n-- 1st Union getting only approved transactions using case for fetching counts and amounts and having chargeback columns with 0\\nSELECT * FROM\\n(\\nSELECT substr(trans_date,1,7) month,\\ncountry,\\nSUM(CASE WHEN state=\\'approved\\' THEN 1 ELSE 0 END) approved_count,\\nSUM(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) approved_amount,\\n0 chargeback_count,\\n0 chargeback_amount\\nFROM transactions\\nWHERE 1=1\\nAND state=\\'approved\\'\\nGROUP BY substr(trans_date,1,7),country)\\nUNION ALL\\n-- 2nd Union getting combined amount details and having approved columns with 0\\nSELECT * FROM \\n(\\nSELECT substr(cb.trans_date,1,7) month,\\nt.country,\\n0 approved_count,\\n0 approved_amount,\\ncount(trans_id) chargeback_count,\\nSUM(amount) chargeback_amount\\nFROM transactions t, chargebacks cb\\nWHERE 1=1\\nAND t.id=cb.trans_id\\n-- AND chargeback_count!=0\\nGROUP BY substr(cb.trans_date,1,7),country\\n))\\nGROUP BY month,country"
                    },
                    {
                        "username": "leetcode1002",
                        "content": "with cte as\\n(select c.trans_id as id, t.country, \\'chargeback\\' as state, t.amount, c.trans_date\\nfrom chargebacks c join transactions t\\non c.trans_id = t.id\\nunion \\nselect * from transactions)\\nselect left(trans_date,7) as month, country, \\nsum(case when state = \\'approved\\' then 1 else 0 end) as approved_count,\\nsum(case when state = \\'approved\\' then amount else 0 end)approved_amount,\\nsum(case when state = \\'chargeback\\' then 1 else 0 end) as chargeback_count,\\nsum(case when state = \\'chargeback\\' then amount else 0 end)chargeback_amount\\nfrom cte\\ngroup by left(trans_date,7), country\\nhaving approved_count>0 or approved_amount>0 or chargeback_count>0 or chargeback_amount>0\\norder by left(trans_date,7)"
                    },
                    {
                        "username": "Liloli",
                        "content": "what\\'s the definition of chargeback_amount.\\nHow to calculate this amount? \\nI can\\'t figure it out by reading the tables."
                    },
                    {
                        "username": "Shikha_Verma",
                        "content": "I have a conceptual question:\\nFor transaction with id=105, it took place on 2019-06-15 but chargeback was realised on 2019-09-18, the chargeback would still get counted in 2019-06 not 2019-09.\\nIf that is the case,a left join on transaction with chargeback table and use CASE statements should work.\\nCan anyone help me understand why this is incorrect?\\n"
                    },
                    {
                        "username": "sudhirmalik415",
                        "content": "This question is not right take example of id 104 this is not get counted in chargebacks absolutely ridiculous. "
                    },
                    {
                        "username": "yz541",
                        "content": "With CTE as (\\nselect * from Transactions \\nunion all\\nselect c.trans_id as id, t.country, \\'Chargeback\\' as state, t.amount,c.trans_date from Chargebacks  C left join Transactions T on T.id =c.trans_id )\\n\\nselect * from \\n(\\nselect to_char(trans_date,\\'YYYY-MM\\') as month, country, sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count, sum(case when state = \\'approved\\' then amount else 0 end) as approved_amount, sum(case when state = \\'Chargeback\\' then 1 else 0 end) as chargeback_count, sum(case when state = \\'Chargeback\\' then amount else 0 end) as chargeback_amount\\nfrom CTE \\ngroup by to_char(trans_date,\\'YYYY-MM\\'), country)tmp\\n\\nWHERE approved_count <> 0 OR chargeback_count <>0  -- need to subquery after CTE to care of the case where rows with all zeros\\n\\n"
                    },
                    {
                        "username": "dosjffltmxm",
                        "content": "Hi all, \\n\\nI\\'m having an issue understanding why state=\\'approved\\' should be executed in cte. \\n\\nthanks! \\n\\n================\\n\\nWITH cte AS(\\n    SELECT \\n    id, country,state,amount,DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    FROM Transactions t\\n    WHERE state=\\'approved\\' ** why this is needed? \\n    UNION ALL \\n    SELECT \\n    c.trans_id, t.country, \\'chargebacks\\' as state, t.amount,  DATE_FORMAT(c.trans_date, \\'%Y-%m\\') AS month\\n    FROM Chargebacks c\\n    LEFT JOIN Transactions t\\n    ON t.id = c.trans_id\\n)\\nSELECT \\nmonth, country,\\nsum(CASE WHEN state=\\'approved\\' THEN 1 ELSE 0 END) AS approved_count ,\\nsum(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) AS approved_amount ,\\nsum(CASE WHEN state=\\'chargebacks\\' THEN 1 ELSE 0 END) AS chargeback_count  ,\\nsum(CASE WHEN state=\\'chargebacks\\' THEN amount ELSE 0 END) AS chargeback_amount  \\nFROM cte \\nGROUP BY 1,2\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1573287,
                "content": [
                    {
                        "username": "goodfine1210",
                        "content": "{\"headers\":{\"Transactions\":[\"id\",\"country\",\"state\",\"amount\",\"trans_date\"],\"Chargebacks\":[\"trans_id\",\"trans_date\"]},\"rows\":{\"Transactions\":[[101,\"US\",\"approved\",1000,\"2019-05-18\"],[102,\"US\",\"declined\",2000,\"2019-05-19\"],[103,\"US\",\"approved\",3000,\"2019-06-10\"],[104,\"US\",\"declined\",4000,\"2019-06-13\"],[105,\"US\",\"approved\",5000,\"2019-06-15\"]],\"Chargebacks\":[[102,\"2019-05-29\"],[101,\"2019-06-30\"],[105,\"2019-09-18\"]]}}\\n\\n\\nIt seems that \\n[104,\"US\",\"declined\",4000,\"2019-06-13\"] is different from problem statement?\\n"
                    },
                    {
                        "username": "kgopu",
                        "content": "/* Write your PL/SQL query statement below */\\n\\nSELECT \\n month,\\n country,\\n SUM(approved_count) approved_count,\\n SUM(approved_amount) approved_amount,\\n SUM(chargeback_count) chargeback_count,\\n SUM(chargeback_amount) chargeback_amount\\nFROM \\n(\\n-- 1st Union getting only approved transactions using case for fetching counts and amounts and having chargeback columns with 0\\nSELECT * FROM\\n(\\nSELECT substr(trans_date,1,7) month,\\ncountry,\\nSUM(CASE WHEN state=\\'approved\\' THEN 1 ELSE 0 END) approved_count,\\nSUM(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) approved_amount,\\n0 chargeback_count,\\n0 chargeback_amount\\nFROM transactions\\nWHERE 1=1\\nAND state=\\'approved\\'\\nGROUP BY substr(trans_date,1,7),country)\\nUNION ALL\\n-- 2nd Union getting combined amount details and having approved columns with 0\\nSELECT * FROM \\n(\\nSELECT substr(cb.trans_date,1,7) month,\\nt.country,\\n0 approved_count,\\n0 approved_amount,\\ncount(trans_id) chargeback_count,\\nSUM(amount) chargeback_amount\\nFROM transactions t, chargebacks cb\\nWHERE 1=1\\nAND t.id=cb.trans_id\\n-- AND chargeback_count!=0\\nGROUP BY substr(cb.trans_date,1,7),country\\n))\\nGROUP BY month,country"
                    },
                    {
                        "username": "leetcode1002",
                        "content": "with cte as\\n(select c.trans_id as id, t.country, \\'chargeback\\' as state, t.amount, c.trans_date\\nfrom chargebacks c join transactions t\\non c.trans_id = t.id\\nunion \\nselect * from transactions)\\nselect left(trans_date,7) as month, country, \\nsum(case when state = \\'approved\\' then 1 else 0 end) as approved_count,\\nsum(case when state = \\'approved\\' then amount else 0 end)approved_amount,\\nsum(case when state = \\'chargeback\\' then 1 else 0 end) as chargeback_count,\\nsum(case when state = \\'chargeback\\' then amount else 0 end)chargeback_amount\\nfrom cte\\ngroup by left(trans_date,7), country\\nhaving approved_count>0 or approved_amount>0 or chargeback_count>0 or chargeback_amount>0\\norder by left(trans_date,7)"
                    },
                    {
                        "username": "Liloli",
                        "content": "what\\'s the definition of chargeback_amount.\\nHow to calculate this amount? \\nI can\\'t figure it out by reading the tables."
                    },
                    {
                        "username": "Shikha_Verma",
                        "content": "I have a conceptual question:\\nFor transaction with id=105, it took place on 2019-06-15 but chargeback was realised on 2019-09-18, the chargeback would still get counted in 2019-06 not 2019-09.\\nIf that is the case,a left join on transaction with chargeback table and use CASE statements should work.\\nCan anyone help me understand why this is incorrect?\\n"
                    },
                    {
                        "username": "sudhirmalik415",
                        "content": "This question is not right take example of id 104 this is not get counted in chargebacks absolutely ridiculous. "
                    },
                    {
                        "username": "yz541",
                        "content": "With CTE as (\\nselect * from Transactions \\nunion all\\nselect c.trans_id as id, t.country, \\'Chargeback\\' as state, t.amount,c.trans_date from Chargebacks  C left join Transactions T on T.id =c.trans_id )\\n\\nselect * from \\n(\\nselect to_char(trans_date,\\'YYYY-MM\\') as month, country, sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count, sum(case when state = \\'approved\\' then amount else 0 end) as approved_amount, sum(case when state = \\'Chargeback\\' then 1 else 0 end) as chargeback_count, sum(case when state = \\'Chargeback\\' then amount else 0 end) as chargeback_amount\\nfrom CTE \\ngroup by to_char(trans_date,\\'YYYY-MM\\'), country)tmp\\n\\nWHERE approved_count <> 0 OR chargeback_count <>0  -- need to subquery after CTE to care of the case where rows with all zeros\\n\\n"
                    },
                    {
                        "username": "dosjffltmxm",
                        "content": "Hi all, \\n\\nI\\'m having an issue understanding why state=\\'approved\\' should be executed in cte. \\n\\nthanks! \\n\\n================\\n\\nWITH cte AS(\\n    SELECT \\n    id, country,state,amount,DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    FROM Transactions t\\n    WHERE state=\\'approved\\' ** why this is needed? \\n    UNION ALL \\n    SELECT \\n    c.trans_id, t.country, \\'chargebacks\\' as state, t.amount,  DATE_FORMAT(c.trans_date, \\'%Y-%m\\') AS month\\n    FROM Chargebacks c\\n    LEFT JOIN Transactions t\\n    ON t.id = c.trans_id\\n)\\nSELECT \\nmonth, country,\\nsum(CASE WHEN state=\\'approved\\' THEN 1 ELSE 0 END) AS approved_count ,\\nsum(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) AS approved_amount ,\\nsum(CASE WHEN state=\\'chargebacks\\' THEN 1 ELSE 0 END) AS chargeback_count  ,\\nsum(CASE WHEN state=\\'chargebacks\\' THEN amount ELSE 0 END) AS chargeback_amount  \\nFROM cte \\nGROUP BY 1,2\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1763385,
                "content": [
                    {
                        "username": "goodfine1210",
                        "content": "{\"headers\":{\"Transactions\":[\"id\",\"country\",\"state\",\"amount\",\"trans_date\"],\"Chargebacks\":[\"trans_id\",\"trans_date\"]},\"rows\":{\"Transactions\":[[101,\"US\",\"approved\",1000,\"2019-05-18\"],[102,\"US\",\"declined\",2000,\"2019-05-19\"],[103,\"US\",\"approved\",3000,\"2019-06-10\"],[104,\"US\",\"declined\",4000,\"2019-06-13\"],[105,\"US\",\"approved\",5000,\"2019-06-15\"]],\"Chargebacks\":[[102,\"2019-05-29\"],[101,\"2019-06-30\"],[105,\"2019-09-18\"]]}}\\n\\n\\nIt seems that \\n[104,\"US\",\"declined\",4000,\"2019-06-13\"] is different from problem statement?\\n"
                    },
                    {
                        "username": "kgopu",
                        "content": "/* Write your PL/SQL query statement below */\\n\\nSELECT \\n month,\\n country,\\n SUM(approved_count) approved_count,\\n SUM(approved_amount) approved_amount,\\n SUM(chargeback_count) chargeback_count,\\n SUM(chargeback_amount) chargeback_amount\\nFROM \\n(\\n-- 1st Union getting only approved transactions using case for fetching counts and amounts and having chargeback columns with 0\\nSELECT * FROM\\n(\\nSELECT substr(trans_date,1,7) month,\\ncountry,\\nSUM(CASE WHEN state=\\'approved\\' THEN 1 ELSE 0 END) approved_count,\\nSUM(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) approved_amount,\\n0 chargeback_count,\\n0 chargeback_amount\\nFROM transactions\\nWHERE 1=1\\nAND state=\\'approved\\'\\nGROUP BY substr(trans_date,1,7),country)\\nUNION ALL\\n-- 2nd Union getting combined amount details and having approved columns with 0\\nSELECT * FROM \\n(\\nSELECT substr(cb.trans_date,1,7) month,\\nt.country,\\n0 approved_count,\\n0 approved_amount,\\ncount(trans_id) chargeback_count,\\nSUM(amount) chargeback_amount\\nFROM transactions t, chargebacks cb\\nWHERE 1=1\\nAND t.id=cb.trans_id\\n-- AND chargeback_count!=0\\nGROUP BY substr(cb.trans_date,1,7),country\\n))\\nGROUP BY month,country"
                    },
                    {
                        "username": "leetcode1002",
                        "content": "with cte as\\n(select c.trans_id as id, t.country, \\'chargeback\\' as state, t.amount, c.trans_date\\nfrom chargebacks c join transactions t\\non c.trans_id = t.id\\nunion \\nselect * from transactions)\\nselect left(trans_date,7) as month, country, \\nsum(case when state = \\'approved\\' then 1 else 0 end) as approved_count,\\nsum(case when state = \\'approved\\' then amount else 0 end)approved_amount,\\nsum(case when state = \\'chargeback\\' then 1 else 0 end) as chargeback_count,\\nsum(case when state = \\'chargeback\\' then amount else 0 end)chargeback_amount\\nfrom cte\\ngroup by left(trans_date,7), country\\nhaving approved_count>0 or approved_amount>0 or chargeback_count>0 or chargeback_amount>0\\norder by left(trans_date,7)"
                    },
                    {
                        "username": "Liloli",
                        "content": "what\\'s the definition of chargeback_amount.\\nHow to calculate this amount? \\nI can\\'t figure it out by reading the tables."
                    },
                    {
                        "username": "Shikha_Verma",
                        "content": "I have a conceptual question:\\nFor transaction with id=105, it took place on 2019-06-15 but chargeback was realised on 2019-09-18, the chargeback would still get counted in 2019-06 not 2019-09.\\nIf that is the case,a left join on transaction with chargeback table and use CASE statements should work.\\nCan anyone help me understand why this is incorrect?\\n"
                    },
                    {
                        "username": "sudhirmalik415",
                        "content": "This question is not right take example of id 104 this is not get counted in chargebacks absolutely ridiculous. "
                    },
                    {
                        "username": "yz541",
                        "content": "With CTE as (\\nselect * from Transactions \\nunion all\\nselect c.trans_id as id, t.country, \\'Chargeback\\' as state, t.amount,c.trans_date from Chargebacks  C left join Transactions T on T.id =c.trans_id )\\n\\nselect * from \\n(\\nselect to_char(trans_date,\\'YYYY-MM\\') as month, country, sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count, sum(case when state = \\'approved\\' then amount else 0 end) as approved_amount, sum(case when state = \\'Chargeback\\' then 1 else 0 end) as chargeback_count, sum(case when state = \\'Chargeback\\' then amount else 0 end) as chargeback_amount\\nfrom CTE \\ngroup by to_char(trans_date,\\'YYYY-MM\\'), country)tmp\\n\\nWHERE approved_count <> 0 OR chargeback_count <>0  -- need to subquery after CTE to care of the case where rows with all zeros\\n\\n"
                    },
                    {
                        "username": "dosjffltmxm",
                        "content": "Hi all, \\n\\nI\\'m having an issue understanding why state=\\'approved\\' should be executed in cte. \\n\\nthanks! \\n\\n================\\n\\nWITH cte AS(\\n    SELECT \\n    id, country,state,amount,DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    FROM Transactions t\\n    WHERE state=\\'approved\\' ** why this is needed? \\n    UNION ALL \\n    SELECT \\n    c.trans_id, t.country, \\'chargebacks\\' as state, t.amount,  DATE_FORMAT(c.trans_date, \\'%Y-%m\\') AS month\\n    FROM Chargebacks c\\n    LEFT JOIN Transactions t\\n    ON t.id = c.trans_id\\n)\\nSELECT \\nmonth, country,\\nsum(CASE WHEN state=\\'approved\\' THEN 1 ELSE 0 END) AS approved_count ,\\nsum(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) AS approved_amount ,\\nsum(CASE WHEN state=\\'chargebacks\\' THEN 1 ELSE 0 END) AS chargeback_count  ,\\nsum(CASE WHEN state=\\'chargebacks\\' THEN amount ELSE 0 END) AS chargeback_amount  \\nFROM cte \\nGROUP BY 1,2\\n\\n\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Design Skiplist",
        "question_content": "<p>Design a <strong>Skiplist</strong> without using any built-in libraries.</p>\n\n<p>A <strong>skiplist</strong> is a data structure that takes <code>O(log(n))</code> time to add, erase and search. Comparing with treap and red-black tree which has the same function and performance, the code length of Skiplist can be comparatively short and the idea behind Skiplists is just simple linked lists.</p>\n\n<p>For example, we have a Skiplist containing <code>[30,40,50,60,70,90]</code> and we want to add <code>80</code> and <code>45</code> into it. The Skiplist works this way:</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/09/27/1506_skiplist.gif\" style=\"width: 500px; height: 173px;\" /><br />\n<small>Artyom Kalinin [CC BY-SA 3.0], via <a href=\"https://commons.wikimedia.org/wiki/File:Skip_list_add_element-en.gif\" target=\"_blank\" title=\"Artyom Kalinin [CC BY-SA 3.0 (https://creativecommons.org/licenses/by-sa/3.0)], via Wikimedia Commons\">Wikimedia Commons</a></small></p>\n\n<p>You can see there are many layers in the Skiplist. Each layer is a sorted linked list. With the help of the top layers, add, erase and search can be faster than <code>O(n)</code>. It can be proven that the average time complexity for each operation is <code>O(log(n))</code> and space complexity is <code>O(n)</code>.</p>\n\n<p>See more about Skiplist: <a href=\"https://en.wikipedia.org/wiki/Skip_list\" target=\"_blank\">https://en.wikipedia.org/wiki/Skip_list</a></p>\n\n<p>Implement the <code>Skiplist</code> class:</p>\n\n<ul>\n\t<li><code>Skiplist()</code> Initializes the object of the skiplist.</li>\n\t<li><code>bool search(int target)</code> Returns <code>true</code> if the integer <code>target</code> exists in the Skiplist or <code>false</code> otherwise.</li>\n\t<li><code>void add(int num)</code> Inserts the value <code>num</code> into the SkipList.</li>\n\t<li><code>bool erase(int num)</code> Removes the value <code>num</code> from the Skiplist and returns <code>true</code>. If <code>num</code> does not exist in the Skiplist, do nothing and return <code>false</code>. If there exist multiple <code>num</code> values, removing any one of them is fine.</li>\n</ul>\n\n<p>Note that duplicates may exist in the Skiplist, your code needs to handle this situation.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;Skiplist&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;search&quot;, &quot;add&quot;, &quot;search&quot;, &quot;erase&quot;, &quot;erase&quot;, &quot;search&quot;]\n[[], [1], [2], [3], [0], [4], [1], [0], [1], [1]]\n<strong>Output</strong>\n[null, null, null, null, false, null, true, false, true, false]\n\n<strong>Explanation</strong>\nSkiplist skiplist = new Skiplist();\nskiplist.add(1);\nskiplist.add(2);\nskiplist.add(3);\nskiplist.search(0); // return False\nskiplist.add(4);\nskiplist.search(1); // return True\nskiplist.erase(0);  // return False, 0 is not in skiplist.\nskiplist.erase(1);  // return True\nskiplist.search(1); // return False, 1 has already been erased.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num, target &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li>At most <code>5 * 10<sup>4</sup></code> calls will be made to <code>search</code>, <code>add</code>, and <code>erase</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 947076,
                "title": "clean-java",
                "content": "```\\nclass Skiplist {\\n    class Node {\\n        int val;\\n        Node next, down;\\n        public Node(int val, Node next, Node down) {\\n            this.val = val;\\n            this.next = next;\\n            this.down = down;\\n        }\\n    }\\n    Node head = new Node(-1, null, null);\\n    Random rand = new Random();\\n    public Skiplist() {\\n        \\n    }\\n    \\n    public boolean search(int target) {\\n        Node cur = head;\\n        while (cur != null) {\\n            while (cur.next != null && cur.next.val < target) {\\n                cur = cur.next;\\n            }\\n            if (cur.next != null && cur.next.val == target) return true;\\n            cur = cur.down;\\n        }\\n        return false;\\n    }\\n    \\n    public void add(int num) {\\n        Stack<Node> stack = new Stack<>();\\n        Node cur = head;\\n        while (cur != null) {\\n            while (cur.next != null && cur.next.val < num) {\\n                cur = cur.next;\\n            }\\n            stack.push(cur);\\n            cur = cur.down;\\n        }\\n        boolean insert = true;\\n        Node down = null;\\n        while (insert && !stack.isEmpty()) {\\n            cur = stack.pop();\\n            cur.next = new Node(num, cur.next, down);\\n            down = cur.next;\\n            insert = rand.nextDouble() < 0.5;\\n        }\\n        if (insert) head = new Node(-1, null, head);\\n    }\\n    \\n    public boolean erase(int num) {\\n        Node cur = head;\\n        boolean found = false;\\n        while (cur != null) {\\n            while (cur.next != null && cur.next.val < num) {\\n                cur = cur.next;\\n            }\\n            if (cur.next != null && cur.next.val == num) {\\n                found = true;\\n                cur.next = cur.next.next;\\n            }\\n            cur = cur.down;\\n        }\\n        return found;\\n    }\\n}\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist obj = new Skiplist();\\n * boolean param_1 = obj.search(target);\\n * obj.add(num);\\n * boolean param_3 = obj.erase(num);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Skiplist {\\n    class Node {\\n        int val;\\n        Node next, down;\\n        public Node(int val, Node next, Node down) {\\n            this.val = val;\\n            this.next = next;\\n            this.down = down;\\n        }\\n    }\\n    Node head = new Node(-1, null, null);\\n    Random rand = new Random();\\n    public Skiplist() {\\n        \\n    }\\n    \\n    public boolean search(int target) {\\n        Node cur = head;\\n        while (cur != null) {\\n            while (cur.next != null && cur.next.val < target) {\\n                cur = cur.next;\\n            }\\n            if (cur.next != null && cur.next.val == target) return true;\\n            cur = cur.down;\\n        }\\n        return false;\\n    }\\n    \\n    public void add(int num) {\\n        Stack<Node> stack = new Stack<>();\\n        Node cur = head;\\n        while (cur != null) {\\n            while (cur.next != null && cur.next.val < num) {\\n                cur = cur.next;\\n            }\\n            stack.push(cur);\\n            cur = cur.down;\\n        }\\n        boolean insert = true;\\n        Node down = null;\\n        while (insert && !stack.isEmpty()) {\\n            cur = stack.pop();\\n            cur.next = new Node(num, cur.next, down);\\n            down = cur.next;\\n            insert = rand.nextDouble() < 0.5;\\n        }\\n        if (insert) head = new Node(-1, null, head);\\n    }\\n    \\n    public boolean erase(int num) {\\n        Node cur = head;\\n        boolean found = false;\\n        while (cur != null) {\\n            while (cur.next != null && cur.next.val < num) {\\n                cur = cur.next;\\n            }\\n            if (cur.next != null && cur.next.val == num) {\\n                found = true;\\n                cur.next = cur.next.next;\\n            }\\n            cur = cur.down;\\n        }\\n        return found;\\n    }\\n}\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist obj = new Skiplist();\\n * boolean param_1 = obj.search(target);\\n * obj.add(num);\\n * boolean param_3 = obj.erase(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393713,
                "title": "python-1-node-per-value-and-100",
                "content": "Each node has a list `node.levels` of forward pointers.  `Skiplist._iter(num)` iterates over the node prior to `num` for each level.  After this setup, everything is easy.\\n\\n```python\\nclass Node:\\n    __slots__ = \\'val\\', \\'levels\\'\\n    def __init__(self, val, levels):\\n        self.val = val\\n        self.levels = [None] * levels\\n\\nclass Skiplist(object):\\n    def __init__(self):\\n        self.head = Node(-1, 16) \\n    \\n    def _iter(self, num):\\n        cur = self.head\\n        for level in range(15, -1, -1):\\n            while True:\\n                future = cur.levels[level]\\n                if future and future.val < num:\\n                    cur = future\\n                else:\\n                    break\\n            yield cur, level\\n\\n    def search(self, target):\\n        for prev, level in self._iter(target):\\n            pass\\n        cur = prev.levels[0]\\n        return cur and cur.val == target\\n\\n    def add(self, num):\\n        nodelvls = min(16, 1 + int(math.log2(1.0 / random.random())))\\n        node = Node(num, nodelvls)\\n        \\n        for cur, level in self._iter(num):\\n            if level < nodelvls:\\n                future = cur.levels[level]\\n                cur.levels[level] = node\\n                node.levels[level] = future\\n\\n    def erase(self, num):\\n        ans = False\\n        for cur, level in self._iter(num):\\n            future = cur.levels[level]\\n            if future and future.val == num:\\n                ans = True\\n                cur.levels[level] = future.levels[level]\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Node:\\n    __slots__ = \\'val\\', \\'levels\\'\\n    def __init__(self, val, levels):\\n        self.val = val\\n        self.levels = [None] * levels\\n\\nclass Skiplist(object):\\n    def __init__(self):\\n        self.head = Node(-1, 16) \\n    \\n    def _iter(self, num):\\n        cur = self.head\\n        for level in range(15, -1, -1):\\n            while True:\\n                future = cur.levels[level]\\n                if future and future.val < num:\\n                    cur = future\\n                else:\\n                    break\\n            yield cur, level\\n\\n    def search(self, target):\\n        for prev, level in self._iter(target):\\n            pass\\n        cur = prev.levels[0]\\n        return cur and cur.val == target\\n\\n    def add(self, num):\\n        nodelvls = min(16, 1 + int(math.log2(1.0 / random.random())))\\n        node = Node(num, nodelvls)\\n        \\n        for cur, level in self._iter(num):\\n            if level < nodelvls:\\n                future = cur.levels[level]\\n                cur.levels[level] = node\\n                node.levels[level] = future\\n\\n    def erase(self, num):\\n        ans = False\\n        for cur, level in self._iter(num):\\n            future = cur.levels[level]\\n            if future and future.val == num:\\n                ans = True\\n                cur.levels[level] = future.levels[level]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400028,
                "title": "c-skiplist-2-pointer-for-each-node-64ms",
                "content": "In this implement, each node contains 2 pointer.The right pointer point to the node in the same level but bigger than this. And the down pointer point to the node in the next level with the same value.\\n\\nThis implement is similiar with singly linked list, so it\\'s much simple than others implement.\\n\\nI think there should be some implement using less memary (less than two pointer for each value). Anyone can tell me how to do it?\\n\\n```\\nstruct Node {\\n    Node *right, *down;\\n    int val;\\n    Node(Node *right, Node *down, int val): right(right), down(down), val(val) {}\\n};\\n\\nclass Skiplist {\\n    Node* head;\\n    \\npublic:\\n    Skiplist(): { head = new Node(NULL, NULL, 0); }\\n    \\n    bool search(int num) {\\n        Node *p = head;\\n        while(p) {\\n            while(p->right and p->right->val < num) p = p->right;\\n            if(!p->right or p->right->val > num) p = p->down;\\n            else return true;\\n        }\\n        return false;\\n    }\\n    \\n    void add(int num) {\\n        insertPoints.clear();\\n        Node *p = head;\\n        while(p) {\\n            while(p->right and p->right->val < num) p = p->right;\\n            insertPoints.push_back(p);\\n            p = p->down;\\n        }\\n        \\n        Node* downNode = NULL;\\n        bool insertUp = true;\\n        while(insertUp and insertPoints.size()) {\\n            Node *ins = insertPoints.back();\\n            insertPoints.pop_back();\\n            \\n            ins->right = new Node(ins->right, downNode, num);\\n            downNode = ins->right;\\n            \\n            insertUp = (rand() & 1) == 0;\\n        }\\n        if(insertUp) {\\n            head = new Node(new Node(NULL, downNode, num), head, 0);\\n        }\\n    }\\n    vector<Node*> insertPoints;\\n    \\n    bool erase(int num) {\\n        Node *p = head;\\n        bool seen = false;\\n        while(p) {\\n            while(p->right and p->right->val < num) p = p->right;\\n            if(!p->right or p->right->val > num) p = p->down;\\n            else {\\n                seen = true;\\n                p->right = p->right->right;\\n                p = p->down;\\n            }\\n        }\\n        return seen;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Node {\\n    Node *right, *down;\\n    int val;\\n    Node(Node *right, Node *down, int val): right(right), down(down), val(val) {}\\n};\\n\\nclass Skiplist {\\n    Node* head;\\n    \\npublic:\\n    Skiplist(): { head = new Node(NULL, NULL, 0); }\\n    \\n    bool search(int num) {\\n        Node *p = head;\\n        while(p) {\\n            while(p->right and p->right->val < num) p = p->right;\\n            if(!p->right or p->right->val > num) p = p->down;\\n            else return true;\\n        }\\n        return false;\\n    }\\n    \\n    void add(int num) {\\n        insertPoints.clear();\\n        Node *p = head;\\n        while(p) {\\n            while(p->right and p->right->val < num) p = p->right;\\n            insertPoints.push_back(p);\\n            p = p->down;\\n        }\\n        \\n        Node* downNode = NULL;\\n        bool insertUp = true;\\n        while(insertUp and insertPoints.size()) {\\n            Node *ins = insertPoints.back();\\n            insertPoints.pop_back();\\n            \\n            ins->right = new Node(ins->right, downNode, num);\\n            downNode = ins->right;\\n            \\n            insertUp = (rand() & 1) == 0;\\n        }\\n        if(insertUp) {\\n            head = new Node(new Node(NULL, downNode, num), head, 0);\\n        }\\n    }\\n    vector<Node*> insertPoints;\\n    \\n    bool erase(int num) {\\n        Node *p = head;\\n        bool seen = false;\\n        while(p) {\\n            while(p->right and p->right->val < num) p = p->right;\\n            if(!p->right or p->right->val > num) p = p->down;\\n            else {\\n                seen = true;\\n                p->right = p->right->right;\\n                p = p->down;\\n            }\\n        }\\n        return seen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393499,
                "title": "java-solution-beats-100",
                "content": "# 1206. Design Skiplist\\n\\n<!-- TOC -->\\n\\n- [1206. Design Skiplist](#1206-design-skiplist)\\n    - [Description](#description)\\n    - [Intuition](#intuition)\\n    - [Solution](#solution)\\n    - [Reference](#reference)\\n\\n<!-- /TOC -->\\n\\n## Description\\n\\n[Description](https://leetcode.com/problems/design-skiplist/)\\n\\n## Intuition\\n\\nI heard this data structure back in 2015/2016 when I was taking 15213, but I never implemented one due to my misunderstanding of the course policy.\\n\\nI implemented this solution based on the first 15 minutes of [YouTube Video](https://www.youtube.com/watch?v=7pWkspmYUVo&t=1617s), which means I cannot guarantee the `search`, `add` and `remove` is the exact same with this video.\\n\\n## Solution\\n\\n```java\\n  // Sentinel\\n  //          \\\\\\n  // level 3: -Inf ----------------------------> 4\\n  // level 2: -Inf ------------> 2 ------------> 4\\n  // level 1: -Inf ----> 1 ----> 2 ------------> 4\\n  // level 0: -Inf ----> 1 ----> 2 ----> 3 ----> 4 : this level is the most concrete level\\n  private static final double DEFAULT_PROB = 0.5;\\n  private final Random rand = new Random();\\n  private final List<Node> sentinels = new ArrayList<>();\\n\\n  {\\n    sentinels.add(new Node(Integer.MIN_VALUE));\\n  }\\n\\n  public boolean search(int target) {\\n    Node smallerOrEquals = getSmallerOrEquals(target);\\n    return smallerOrEquals.val == target;\\n  }\\n\\n  public void add(int num) {\\n    Node cur = getSmallerOrEquals(num);\\n    // cur \\u6700\\u4E0B\\u5C42\\uFF0C\\u6BD4\\u4ED6\\u5C0F\\u6216\\u8005\\u7B49\\u4E8E num\\n    final Node toInsert = new Node(num);\\n    append(cur, toInsert);\\n    // populate the level\\n    populateLevelUp(toInsert);\\n  }\\n\\n  private void populateLevelUp(final Node toInsert) {\\n    Node curPrev = toInsert.left, cur = toInsert;\\n\\n    while (flipCoin()) {\\n      while (curPrev.left != null && curPrev.up == null) {\\n        curPrev = curPrev.left;\\n      }\\n      if (curPrev.up == null) {\\n        final Node newSentinel = new Node(Integer.MIN_VALUE);\\n        curPrev.up = newSentinel;\\n        newSentinel.down = curPrev;\\n        sentinels.add(curPrev.up);\\n      }\\n      curPrev = curPrev.up;\\n      final Node newNode = new Node(toInsert.val);\\n      cur.up = newNode;\\n      newNode.down = cur;\\n      cur = cur.up;\\n      curPrev.right = cur;\\n      cur.left = curPrev;\\n    }\\n  }\\n\\n  private void append(Node prev, Node cur) {\\n    final Node next = prev.right;\\n    prev.right = cur;\\n    cur.left = prev;\\n    if (next != null) {\\n      next.left = cur;\\n      cur.right = next;\\n    }\\n  }\\n\\n  public boolean erase(int num) {\\n    final Node toRemove = getSmallerOrEquals(num);\\n    if (toRemove.val != num) {\\n      return false;\\n    }\\n    Node cur = toRemove;\\n    while (cur != null) {\\n      final Node prev = cur.left, next = cur.right;\\n      prev.right = next;\\n      if (next != null) {\\n        next.left = prev;\\n      }\\n      cur = cur.up;\\n    }\\n    return true;\\n  }\\n\\n  private Node getSmallerOrEquals(final int target) {\\n    Node cur = getSentinel();\\n    while (cur != null) {\\n      if (cur.right == null || cur.right.val > target) {\\n        if (cur.down == null) break;\\n        cur = cur.down;\\n      } else {\\n        cur = cur.right;\\n      }\\n    }\\n    return cur;\\n  }\\n\\n  private boolean flipCoin() {\\n    return rand.nextDouble() < DEFAULT_PROB;\\n  }\\n\\n  private Node getSentinel() {\\n    return sentinels.get(sentinels.size() - 1);\\n  }\\n\\n  public String toString() {\\n    Node node = sentinels.get(0);\\n    final StringBuilder sb = new StringBuilder();\\n    while (node != null) {\\n      Node itr = node;\\n      while (itr != null) {\\n        sb.append(itr.val).append(\",\");\\n        itr = itr.up;\\n      }\\n      sb.append(\"\\\\n\");\\n      node = node.right;\\n    }\\n    return sb.toString();\\n  }\\n\\n  private static final class Node {\\n    private final int val;\\n    private Node left, right, up, down;\\n\\n    private Node(int val) {\\n      this.val = val;\\n    }\\n  }\\n```\\n\\n## Reference\\n\\n- [YouTube Video](https://www.youtube.com/watch?v=7pWkspmYUVo&t=1617s)\\n",
                "solutionTags": [],
                "code": "```java\\n  // Sentinel\\n  //          \\\\\\n  // level 3: -Inf ----------------------------> 4\\n  // level 2: -Inf ------------> 2 ------------> 4\\n  // level 1: -Inf ----> 1 ----> 2 ------------> 4\\n  // level 0: -Inf ----> 1 ----> 2 ----> 3 ----> 4 : this level is the most concrete level\\n  private static final double DEFAULT_PROB = 0.5;\\n  private final Random rand = new Random();\\n  private final List<Node> sentinels = new ArrayList<>();\\n\\n  {\\n    sentinels.add(new Node(Integer.MIN_VALUE));\\n  }\\n\\n  public boolean search(int target) {\\n    Node smallerOrEquals = getSmallerOrEquals(target);\\n    return smallerOrEquals.val == target;\\n  }\\n\\n  public void add(int num) {\\n    Node cur = getSmallerOrEquals(num);\\n    // cur \\u6700\\u4E0B\\u5C42\\uFF0C\\u6BD4\\u4ED6\\u5C0F\\u6216\\u8005\\u7B49\\u4E8E num\\n    final Node toInsert = new Node(num);\\n    append(cur, toInsert);\\n    // populate the level\\n    populateLevelUp(toInsert);\\n  }\\n\\n  private void populateLevelUp(final Node toInsert) {\\n    Node curPrev = toInsert.left, cur = toInsert;\\n\\n    while (flipCoin()) {\\n      while (curPrev.left != null && curPrev.up == null) {\\n        curPrev = curPrev.left;\\n      }\\n      if (curPrev.up == null) {\\n        final Node newSentinel = new Node(Integer.MIN_VALUE);\\n        curPrev.up = newSentinel;\\n        newSentinel.down = curPrev;\\n        sentinels.add(curPrev.up);\\n      }\\n      curPrev = curPrev.up;\\n      final Node newNode = new Node(toInsert.val);\\n      cur.up = newNode;\\n      newNode.down = cur;\\n      cur = cur.up;\\n      curPrev.right = cur;\\n      cur.left = curPrev;\\n    }\\n  }\\n\\n  private void append(Node prev, Node cur) {\\n    final Node next = prev.right;\\n    prev.right = cur;\\n    cur.left = prev;\\n    if (next != null) {\\n      next.left = cur;\\n      cur.right = next;\\n    }\\n  }\\n\\n  public boolean erase(int num) {\\n    final Node toRemove = getSmallerOrEquals(num);\\n    if (toRemove.val != num) {\\n      return false;\\n    }\\n    Node cur = toRemove;\\n    while (cur != null) {\\n      final Node prev = cur.left, next = cur.right;\\n      prev.right = next;\\n      if (next != null) {\\n        next.left = prev;\\n      }\\n      cur = cur.up;\\n    }\\n    return true;\\n  }\\n\\n  private Node getSmallerOrEquals(final int target) {\\n    Node cur = getSentinel();\\n    while (cur != null) {\\n      if (cur.right == null || cur.right.val > target) {\\n        if (cur.down == null) break;\\n        cur = cur.down;\\n      } else {\\n        cur = cur.right;\\n      }\\n    }\\n    return cur;\\n  }\\n\\n  private boolean flipCoin() {\\n    return rand.nextDouble() < DEFAULT_PROB;\\n  }\\n\\n  private Node getSentinel() {\\n    return sentinels.get(sentinels.size() - 1);\\n  }\\n\\n  public String toString() {\\n    Node node = sentinels.get(0);\\n    final StringBuilder sb = new StringBuilder();\\n    while (node != null) {\\n      Node itr = node;\\n      while (itr != null) {\\n        sb.append(itr.val).append(\",\");\\n        itr = itr.up;\\n      }\\n      sb.append(\"\\\\n\");\\n      node = node.right;\\n    }\\n    return sb.toString();\\n  }\\n\\n  private static final class Node {\\n    private final int val;\\n    private Node left, right, up, down;\\n\\n    private Node(int val) {\\n      this.val = val;\\n    }\\n  }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 441212,
                "title": "short-java-solution-average-90-in-time-and-100-in-memory",
                "content": "### Key ideas\\n\\nThe purpose of coin toss is to ensure that each node at current level will be duplicated to its upper level with a probability of 0.5, so the number of nodes at the upper level is roughly half of the current level.\\n\\nSo in the extreme case, SkipList is equivalent to a balanced binary search tree.\\n\\nThe solution below is modified based on the video from https://leetcode.com/problems/design-skiplist/discuss/393499/Java-Solution-beats-100 and [opendatastructures](https://opendatastructures.org/ods-java/4_2_SkiplistSSet_Efficient_.html) ([pdf]( https://opendatastructures.org/versions/edition-0.1d/ods-java.pdf))\\n\\n\\nThe example illustrations below are from opendatastructures.org and meant for SkiplistSSet, which does not contain duplicates.\\n\\n### Tricks used\\n* Assume max height is 33\\n* We use number of trailing 0s of a random Integer to simulate the coin toss process to determine the height for a newly inserted node: ```Integer.numberOfTrailingZeros(rand.nextInt())```\\n\\n\\n\\n### case: Initial skiplist\\n![image](https://assets.leetcode.com/users/oldsui/image_1575162896.png)\\n\\n\\n### case: Search for 4\\n![image](https://assets.leetcode.com/users/oldsui/image_1575163040.png)\\n\\nreturn its predecessor (similar to prev of linked list problems)\\n```\\ncur = sentinel.top\\nwhile (cur != null) \\n    if (cur.next.val >= target)   #overshoot\\n\\t    cur goes down\\n\\telse \\n\\t    cur goes right\\n```\\n\\n### case: Add a number 3.5\\n![image](https://assets.leetcode.com/users/oldsui/image_1575163112.png)\\n\\nGrow node for 3.5 using coin toss process.\\n\\n### case: Remove a number 3\\n![image](https://assets.leetcode.com/users/oldsui/image_1575163191.png)\\n\\n\\n\\n\\n\\n\\n\\n```\\nclass Skiplist {\\n\\n    static class Node {\\n        int val;\\n        int count; // to handle duplicates\\n        int h; // highest level: [0,32]\\n        Node[] next;\\n        public Node(int a, int b) {\\n            val = a; h = b; count = 1;\\n            next = new Node[33];\\n        }\\n    }\\n\\n    Node sentinel = new Node(Integer.MIN_VALUE, 32);\\n    int topLevel = 0;\\n    Node[] stack = new Node[33];  // to keep track of search path\\n    Random rand = new Random();\\n\\n    public Skiplist() {\\n    }\\n\\n    // find the predecessor\\n    private Node findPred(int num) {\\n        Node cur = sentinel;\\n        for (int r = topLevel; r >= 0; r--) {\\n            while (cur.next[r] != null && cur.next[r].val < num)  cur = cur.next[r];\\n            stack[r] = cur;\\n        }\\n        return cur;\\n    }\\n\\n    public boolean search(int target) {\\n        Node pred = findPred(target);\\n        return pred.next[0] != null && pred.next[0].val == target;\\n    }\\n\\n    public void add(int num) {\\n        Node pred = findPred(num);\\n        if (pred.next[0] != null && pred.next[0].val == num) {\\n            pred.next[0].count++;\\n            return;\\n        }\\n        Node w = new Node(num, pickHeight());\\n        while (topLevel < w.h) stack[++topLevel] = sentinel;\\n        for (int i = 0; i <= w.h; i++) {\\n            w.next[i] = stack[i].next[i];\\n            stack[i].next[i] = w;\\n        }\\n    }\\n\\n    public boolean erase(int num) {\\n        Node pred = findPred(num);\\n        if (pred.next[0] == null || pred.next[0].val != num) return false;\\n        boolean noNeedToRemove = --pred.next[0].count != 0;\\n        if (noNeedToRemove) return true;\\n        for (int r = topLevel; r >= 0; r--) {\\n            Node cur = stack[r];\\n            if (cur.next[r] != null && cur.next[r].val == num) cur.next[r] = cur.next[r].next[r];\\n            if (cur == sentinel && cur.next[r] == null) topLevel--;\\n        }\\n        return true;\\n    }\\n\\n    // number of trailing 0s of a random Integer: [0, 32]\\n    private int pickHeight() {\\n        return Integer.numberOfTrailingZeros(rand.nextInt());\\n    }\\n}\\n```\\n\\n\\n**Skiplist for Sorted Set** (for reference):\\n\\n```\\nclass Skiplist {\\n\\n    static class Node {\\n        int val, top;\\n        Node[] next;\\n        public Node(int a, int b) {\\n            val = a; top = b; next = new Node[33];\\n        }\\n    }\\n    static Random rand = new Random();\\n\\n    Node sentinel = new Node(Integer.MIN_VALUE, 32);\\n    int topLevel = 0;\\n    Node[] stack = new Node[33];\\n\\n    private Node findPred(int num) {\\n        Node cur = sentinel;\\n        for (int r = topLevel; r >= 0; r--) {\\n            while (cur.next[r] != null && cur.next[r].val < num) cur = cur.next[r];\\n            stack[r] = cur;\\n        }\\n        return cur;\\n    }\\n\\n    public boolean search(int target) {\\n        Node pred = findPred(target);\\n        return pred.next[0] != null && pred.next[0].val == target;\\n    }\\n\\n    private int pickHeight() {\\n        return Integer.numberOfTrailingZeros(rand.nextInt());\\n    }\\n\\n    public void add(int num) {\\n        if (search(num)) return;\\n        Node w = new Node(num, pickHeight());\\n        while (topLevel < w.top) stack[++topLevel] = sentinel;\\n        for (int i = 0; i <= w.top; i++) {\\n            w.next[i] = stack[i].next[i];\\n            stack[i].next[i] = w;\\n        }\\n    }\\n\\n    public boolean erase(int num) {\\n        if (!search(num)) return false;\\n        for (int r = topLevel; r >= 0; r--) {\\n            if (stack[r].next[r] != null && stack[r].next[r].val == num) \\n                stack[r].next[r] = stack[r].next[r].next[r];\\n            if (stack[r] == sentinel && stack[r].next[r] == null) \\n                topLevel--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Integer.numberOfTrailingZeros(rand.nextInt())```\n```\\ncur = sentinel.top\\nwhile (cur != null) \\n    if (cur.next.val >= target)   #overshoot\\n\\t    cur goes down\\n\\telse \\n\\t    cur goes right\\n```\n```\\nclass Skiplist {\\n\\n    static class Node {\\n        int val;\\n        int count; // to handle duplicates\\n        int h; // highest level: [0,32]\\n        Node[] next;\\n        public Node(int a, int b) {\\n            val = a; h = b; count = 1;\\n            next = new Node[33];\\n        }\\n    }\\n\\n    Node sentinel = new Node(Integer.MIN_VALUE, 32);\\n    int topLevel = 0;\\n    Node[] stack = new Node[33];  // to keep track of search path\\n    Random rand = new Random();\\n\\n    public Skiplist() {\\n    }\\n\\n    // find the predecessor\\n    private Node findPred(int num) {\\n        Node cur = sentinel;\\n        for (int r = topLevel; r >= 0; r--) {\\n            while (cur.next[r] != null && cur.next[r].val < num)  cur = cur.next[r];\\n            stack[r] = cur;\\n        }\\n        return cur;\\n    }\\n\\n    public boolean search(int target) {\\n        Node pred = findPred(target);\\n        return pred.next[0] != null && pred.next[0].val == target;\\n    }\\n\\n    public void add(int num) {\\n        Node pred = findPred(num);\\n        if (pred.next[0] != null && pred.next[0].val == num) {\\n            pred.next[0].count++;\\n            return;\\n        }\\n        Node w = new Node(num, pickHeight());\\n        while (topLevel < w.h) stack[++topLevel] = sentinel;\\n        for (int i = 0; i <= w.h; i++) {\\n            w.next[i] = stack[i].next[i];\\n            stack[i].next[i] = w;\\n        }\\n    }\\n\\n    public boolean erase(int num) {\\n        Node pred = findPred(num);\\n        if (pred.next[0] == null || pred.next[0].val != num) return false;\\n        boolean noNeedToRemove = --pred.next[0].count != 0;\\n        if (noNeedToRemove) return true;\\n        for (int r = topLevel; r >= 0; r--) {\\n            Node cur = stack[r];\\n            if (cur.next[r] != null && cur.next[r].val == num) cur.next[r] = cur.next[r].next[r];\\n            if (cur == sentinel && cur.next[r] == null) topLevel--;\\n        }\\n        return true;\\n    }\\n\\n    // number of trailing 0s of a random Integer: [0, 32]\\n    private int pickHeight() {\\n        return Integer.numberOfTrailingZeros(rand.nextInt());\\n    }\\n}\\n```\n```\\nclass Skiplist {\\n\\n    static class Node {\\n        int val, top;\\n        Node[] next;\\n        public Node(int a, int b) {\\n            val = a; top = b; next = new Node[33];\\n        }\\n    }\\n    static Random rand = new Random();\\n\\n    Node sentinel = new Node(Integer.MIN_VALUE, 32);\\n    int topLevel = 0;\\n    Node[] stack = new Node[33];\\n\\n    private Node findPred(int num) {\\n        Node cur = sentinel;\\n        for (int r = topLevel; r >= 0; r--) {\\n            while (cur.next[r] != null && cur.next[r].val < num) cur = cur.next[r];\\n            stack[r] = cur;\\n        }\\n        return cur;\\n    }\\n\\n    public boolean search(int target) {\\n        Node pred = findPred(target);\\n        return pred.next[0] != null && pred.next[0].val == target;\\n    }\\n\\n    private int pickHeight() {\\n        return Integer.numberOfTrailingZeros(rand.nextInt());\\n    }\\n\\n    public void add(int num) {\\n        if (search(num)) return;\\n        Node w = new Node(num, pickHeight());\\n        while (topLevel < w.top) stack[++topLevel] = sentinel;\\n        for (int i = 0; i <= w.top; i++) {\\n            w.next[i] = stack[i].next[i];\\n            stack[i].next[i] = w;\\n        }\\n    }\\n\\n    public boolean erase(int num) {\\n        if (!search(num)) return false;\\n        for (int r = topLevel; r >= 0; r--) {\\n            if (stack[r].next[r] != null && stack[r].next[r].val == num) \\n                stack[r].next[r] = stack[r].next[r].next[r];\\n            if (stack[r] == sentinel && stack[r].next[r] == null) \\n                topLevel--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394679,
                "title": "python-the-down-pointer-of-each-node-must-point-to-node-of-same-value-in-the-next-level",
                "content": "Each node has 2 pointers: \"next\" targets to the next node in the same level, \"down\" targets the \"next\" level node. \"down\" pointer must alwasy target node of the same value in the next level.\\n1. Initialize an array of levels, each level contain a first node of value -math.inf.\\nBe careful that these nodes should be initialized with their \"down\" pointer targeting to the next level -math.inf node.\\n2. Write a function to find the biggest node that is smaller than search target in all levels. If there is an exact match to the target, we still find its previous node. This is because erase operation requires previous node, rather than the exact matched node.\\n3. If you add a node in a level, all levels after that also need to be added, and nodes\\' \"down\" pointer must target to their next level counterpart. Levels before this level can be ignored. \\n4. If you erase a node, erase all such node in all levels.\\n\\n```\\nclass Node:\\n    def __init__(self,val):\\n        self.val=val\\n        self.next=None\\n        self.down=None\\n\\nclass Skiplist:\\n    def __init__(self):\\n        self.levels=[]\\n        prev=None\\n        for i in range(16):\\n            node=Node(-math.inf)\\n            self.levels.append(node)\\n            if prev:\\n                prev.down=node\\n            prev=node\\n\\t\\t\\t\\n    def _iter(self,val):\\n        res=[]\\n        l=self.levels[0]\\n        while l:\\n            while l.next and l.next.val<val:\\n                l=l.next\\n            res.append(l)\\n            l=l.down\\n        return res\\n\\t\\t\\n    def search(self, target: int) -> bool:\\n        last=self._iter(target)[-1]\\n        return last.next and last.next.val==target\\n\\t\\t\\n    def add(self, num: int) -> None:\\n        res=self._iter(num)\\n        prev=None\\n        for i in range(len(res)-1,-1,-1):\\n            node=Node(num)\\n            node.next,node.down=res[i].next,prev\\n            res[i].next=node\\n            prev=node\\n            rand=random.random()\\n            if rand>0.5:\\n                break\\n\\t\\t\\t\\t\\n    def erase(self, num: int) -> bool:\\n        found=False\\n        res=self._iter(num)\\n        for i in range(len(res)):\\n            if res[i].next and res[i].next.val==num:\\n                res[i].next=res[i].next.next\\n                found=True\\n        return found\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node:\\n    def __init__(self,val):\\n        self.val=val\\n        self.next=None\\n        self.down=None\\n\\nclass Skiplist:\\n    def __init__(self):\\n        self.levels=[]\\n        prev=None\\n        for i in range(16):\\n            node=Node(-math.inf)\\n            self.levels.append(node)\\n            if prev:\\n                prev.down=node\\n            prev=node\\n\\t\\t\\t\\n    def _iter(self,val):\\n        res=[]\\n        l=self.levels[0]\\n        while l:\\n            while l.next and l.next.val<val:\\n                l=l.next\\n            res.append(l)\\n            l=l.down\\n        return res\\n\\t\\t\\n    def search(self, target: int) -> bool:\\n        last=self._iter(target)[-1]\\n        return last.next and last.next.val==target\\n\\t\\t\\n    def add(self, num: int) -> None:\\n        res=self._iter(num)\\n        prev=None\\n        for i in range(len(res)-1,-1,-1):\\n            node=Node(num)\\n            node.next,node.down=res[i].next,prev\\n            res[i].next=node\\n            prev=node\\n            rand=random.random()\\n            if rand>0.5:\\n                break\\n\\t\\t\\t\\t\\n    def erase(self, num: int) -> bool:\\n        found=False\\n        res=self._iter(num)\\n        for i in range(len(res)):\\n            if res[i].next and res[i].next.val==num:\\n                res[i].next=res[i].next.next\\n                found=True\\n        return found\\n```",
                "codeTag": "Java"
            },
            {
                "id": 740881,
                "title": "c-clean-and-simple-solution-from-leveldb",
                "content": "Borrow idea from leveldb: https://github.com/google/leveldb/blob/master/db/skiplist.h#L42\\nThe key idea is to let the level distribution satisfy the Geometric distribution.\\nmore detail please see the article: https://www.qtmuniao.com/2020/07/03/leveldb-data-structures-skip-list/#more\\n\\n\\n```c++\\nclass Skiplist {\\nprivate:\\n    const int kMaxHeight = 8;\\n    \\n    struct Node {\\n        int val;\\n        int height;\\n        Node** next;\\n        \\n        Node(int v, int h) {\\n            val = v;\\n            height = h;\\n            next = new Node*[h];\\n            while (--h >= 0) next[h] = nullptr;\\n        }\\n        \\n        ~Node() {\\n           delete [] next;\\n        }\\n    };\\n    \\n    int getRandomHeight() {\\n        int h = 1;\\n        while (h < kMaxHeight && rand() % 4 == 1) ++h;\\n        \\n        return h;\\n    }\\n    \\n    \\n    Node* findGreaterOrEqual(int target, Node** prev) {\\n        Node* it = head;\\n        int level = kMaxHeight-1;\\n        while (true) {\\n            Node* next = it->next[level];\\n            if (next && next->val < target) {\\n                it = next;\\n            } else {\\n                if (prev)  prev[level] = it;\\n                \\n                if (level == 0) {\\n                    return next;\\n                } else {\\n                    --level;\\n                }\\n            }\\n        }\\n    }\\n    \\n    \\n    Node* head;\\npublic:\\n    Skiplist() {\\n        head = new Node(0, kMaxHeight);\\n    }\\n    \\n    bool search(int target) {\\n        Node* node = findGreaterOrEqual(target, nullptr);\\n        return node != nullptr && node->val == target;\\n    }\\n    \\n    void add(int num) {\\n        Node* prev[kMaxHeight];\\n        findGreaterOrEqual(num, prev);\\n        \\n        Node* node = new Node(num, getRandomHeight());  \\n        for (int i = 0; i < node->height; ++i) {\\n            node->next[i] = prev[i]->next[i];\\n            prev[i]->next[i] = node;\\n        }\\n    }\\n    \\n    bool erase(int num) {\\n        Node* prev[kMaxHeight];\\n        Node* to_del = findGreaterOrEqual(num, prev);\\n        if (to_del == nullptr || to_del->val != num) {\\n            return false;\\n        }\\n        \\n        for (int i = 0; i < to_del->height; ++i) {\\n            prev[i]->next[i] = to_del->next[i];\\n        }\\n        \\n        delete to_del;\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Skiplist {\\nprivate:\\n    const int kMaxHeight = 8;\\n    \\n    struct Node {\\n        int val;\\n        int height;\\n        Node** next;\\n        \\n        Node(int v, int h) {\\n            val = v;\\n            height = h;\\n            next = new Node*[h];\\n            while (--h >= 0) next[h] = nullptr;\\n        }\\n        \\n        ~Node() {\\n           delete [] next;\\n        }\\n    };\\n    \\n    int getRandomHeight() {\\n        int h = 1;\\n        while (h < kMaxHeight && rand() % 4 == 1) ++h;\\n        \\n        return h;\\n    }\\n    \\n    \\n    Node* findGreaterOrEqual(int target, Node** prev) {\\n        Node* it = head;\\n        int level = kMaxHeight-1;\\n        while (true) {\\n            Node* next = it->next[level];\\n            if (next && next->val < target) {\\n                it = next;\\n            } else {\\n                if (prev)  prev[level] = it;\\n                \\n                if (level == 0) {\\n                    return next;\\n                } else {\\n                    --level;\\n                }\\n            }\\n        }\\n    }\\n    \\n    \\n    Node* head;\\npublic:\\n    Skiplist() {\\n        head = new Node(0, kMaxHeight);\\n    }\\n    \\n    bool search(int target) {\\n        Node* node = findGreaterOrEqual(target, nullptr);\\n        return node != nullptr && node->val == target;\\n    }\\n    \\n    void add(int num) {\\n        Node* prev[kMaxHeight];\\n        findGreaterOrEqual(num, prev);\\n        \\n        Node* node = new Node(num, getRandomHeight());  \\n        for (int i = 0; i < node->height; ++i) {\\n            node->next[i] = prev[i]->next[i];\\n            prev[i]->next[i] = node;\\n        }\\n    }\\n    \\n    bool erase(int num) {\\n        Node* prev[kMaxHeight];\\n        Node* to_del = findGreaterOrEqual(num, prev);\\n        if (to_del == nullptr || to_del->val != num) {\\n            return false;\\n        }\\n        \\n        for (int i = 0; i < to_del->height; ++i) {\\n            prev[i]->next[i] = to_del->next[i];\\n        }\\n        \\n        delete to_del;\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1082053,
                "title": "simple-solution-with-dynamic-levels-references",
                "content": "Info that helped me to solve this problem:\\n- https://leetcode.com/problems/design-skiplist/discuss/698146/Things-that-helped-me-solve-this-problem\\n- https://cw.fel.cvut.cz/old/_media/courses/a4b36acm/maraton2015skiplist.pdf\\n- https://cglab.ca/~morin/teaching/5408/refs/p90b.pdf\\n\\nFollowing implementation is pretty straightforward. It is possible to cut lines amount here and there but I left it this way so it would be easier to quickly understand how it works.\\n\\n```\\nimport random\\n\\n\\nclass ListNode:\\n    __slots__ = (\\'val\\', \\'next\\', \\'down\\')\\n\\n    def __init__(self, val):\\n        self.val = val\\n        self.next = None\\n        self.down = None\\n\\n\\nclass Skiplist:\\n    def __init__(self):\\n        # sentinel nodes to keep code simple\\n        node = ListNode(float(\\'-inf\\'))\\n        node.next = ListNode(float(\\'inf\\'))\\n        self.levels = [node]\\n\\n    def search(self, target: int) -> bool:\\n        level = self.levels[-1]\\n        while level:\\n            node = level\\n            while node.next.val < target:\\n                node = node.next\\n            if node.next.val == target:\\n                return True\\n            level = node.down\\n        return False\\n\\n    def add(self, num: int) -> None:\\n        stack = []\\n        level = self.levels[-1]\\n        while level:\\n            node = level\\n            while node.next.val < num:\\n                node = node.next\\n            stack.append(node)\\n            level = node.down\\n\\n        heads = True\\n        down = None\\n        while stack and heads:\\n            prev = stack.pop()\\n            node = ListNode(num)\\n            node.next = prev.next\\n            node.down = down\\n            prev.next = node\\n            down = node\\n            # flip a coin to stop or continue with the next level\\n            heads = random.randint(0, 1)\\n\\n        # add a new level if we got to the top with heads\\n        if not stack and heads:\\n            node = ListNode(float(\\'-inf\\'))\\n            node.next = ListNode(num)\\n            node.down = self.levels[-1]\\n            node.next.next = ListNode(float(\\'inf\\'))\\n            node.next.down = down\\n            self.levels.append(node)\\n\\n    def erase(self, num: int) -> bool:\\n        stack = []\\n        level = self.levels[-1]\\n        while level:\\n            node = level\\n            while node.next.val < num:\\n                node = node.next\\n            if node.next.val == num:\\n                stack.append(node)\\n            level = node.down\\n\\n        if not stack:\\n            return False\\n\\n        for node in stack:\\n            node.next = node.next.next\\n\\n        # remove the top level if it\\'s empty\\n        while len(self.levels) > 1 and self.levels[-1].next.next is None:\\n            self.levels.pop()\\n\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport random\\n\\n\\nclass ListNode:\\n    __slots__ = (\\'val\\', \\'next\\', \\'down\\')\\n\\n    def __init__(self, val):\\n        self.val = val\\n        self.next = None\\n        self.down = None\\n\\n\\nclass Skiplist:\\n    def __init__(self):\\n        # sentinel nodes to keep code simple\\n        node = ListNode(float(\\'-inf\\'))\\n        node.next = ListNode(float(\\'inf\\'))\\n        self.levels = [node]\\n\\n    def search(self, target: int) -> bool:\\n        level = self.levels[-1]\\n        while level:\\n            node = level\\n            while node.next.val < target:\\n                node = node.next\\n            if node.next.val == target:\\n                return True\\n            level = node.down\\n        return False\\n\\n    def add(self, num: int) -> None:\\n        stack = []\\n        level = self.levels[-1]\\n        while level:\\n            node = level\\n            while node.next.val < num:\\n                node = node.next\\n            stack.append(node)\\n            level = node.down\\n\\n        heads = True\\n        down = None\\n        while stack and heads:\\n            prev = stack.pop()\\n            node = ListNode(num)\\n            node.next = prev.next\\n            node.down = down\\n            prev.next = node\\n            down = node\\n            # flip a coin to stop or continue with the next level\\n            heads = random.randint(0, 1)\\n\\n        # add a new level if we got to the top with heads\\n        if not stack and heads:\\n            node = ListNode(float(\\'-inf\\'))\\n            node.next = ListNode(num)\\n            node.down = self.levels[-1]\\n            node.next.next = ListNode(float(\\'inf\\'))\\n            node.next.down = down\\n            self.levels.append(node)\\n\\n    def erase(self, num: int) -> bool:\\n        stack = []\\n        level = self.levels[-1]\\n        while level:\\n            node = level\\n            while node.next.val < num:\\n                node = node.next\\n            if node.next.val == num:\\n                stack.append(node)\\n            level = node.down\\n\\n        if not stack:\\n            return False\\n\\n        for node in stack:\\n            node.next = node.next.next\\n\\n        # remove the top level if it\\'s empty\\n        while len(self.levels) > 1 and self.levels[-1].next.next is None:\\n            self.levels.pop()\\n\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393458,
                "title": "python-implementation-with-2-pointers",
                "content": "Takes around 300 ms, based on the MIT lecture at https://www.youtube.com/watch?v=2g9OSRKJuzM\\n```\\nclass Node(object):\\n    \\n    def __init__(self, val):\\n        self.val = val\\n        self.next = None\\n        self.down = None\\n\\nclass Skiplist(object):\\n\\n    def __init__(self):\\n        self.S = [Node(None)]\\n\\n    def search(self, target):\\n        \"\"\"\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        curr = self.S[-1]\\n        while curr is not None:\\n            # Move right as far as possible without overshooting in the current level \\n            while (curr.next is not None) and (curr.next.val <= target):\\n                if curr.next.val == target:\\n                    # If target found in some (potentially intermediate) level, exit immediately\\n                    return True\\n                curr = curr.next\\n            # Traversed current level as far as possible without finding target\\n            # Move one level down to expand search\\n            curr = curr.down\\n        # Traversed till the end without finding the target, return False\\n        return False\\n\\n    def add(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: None\\n        \"\"\"\\n        # Start at the lowest level and keep flipping coins to decide whether\\n        # to insert an entry for the given value at the next higher level as well.\\n        k = 1\\n        p = random.choice([0, 1])\\n        while (p == 1) and (k < len(self.S)):\\n            k += 1\\n            p = random.choice([0, 1])\\n        if k == len(self.S):\\n            # If an entry will be inserted at the highest level, expand the number of levels.\\n            nr = Node(None)\\n            nr.down = self.S[-1]\\n            self.S.append(nr)\\n        curr = self.S[-1]\\n        kc = len(self.S)\\n        par = None\\n        while curr is not None:\\n            # Traverse to the right in the current level as far as possible without overshooting.\\n            while (curr.next is not None) and (curr.next.val <= num):\\n                curr = curr.next\\n            if kc <= k:\\n                # An entry for the new value needs to be inserted in the current level.\\n                # This entry should be inserted just after the point where rightward traversal stopped.\\n                nn = Node(num)\\n                nn.next = curr.next\\n                curr.next = nn\\n                # Update the downward link for the new entry inserted in the previous level.\\n                if par is not None:\\n                    par.down = nn\\n                par = nn\\n            # Current level done, keep going down.\\n            curr = curr.down\\n            kc -= 1\\n\\n    def erase(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: bool\\n        \"\"\"\\n        curr = self.S[-1]\\n        res = False\\n        while curr is not None:\\n            # Traverse to the right in the current level as far as possible without overshooting.\\n            while (curr.next is not None) and (curr.next.val <= num):\\n                if curr.next.val == num:\\n                    # Target value found inside the next node in the current level.\\n                    # Delete the next node, and since we\\'re done with the current level now,\\n                    # break out of the loop and move on to the next level downwards.\\n                    res = True\\n                    curr.next = curr.next.next\\n                    break\\n                else:\\n                    curr = curr.next\\n            # Go one level down and repeat the process.\\n            curr = curr.down\\n        # Trim the levels if multiple levels can be found towards the top which have only the dummy terminal entry.\\n        # Leave only one of them.\\n        while len(self.S) >= 2:\\n            cand = self.S[-2]\\n            if cand.next is None:\\n                self.S.pop()\\n            else:\\n                break\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node(object):\\n    \\n    def __init__(self, val):\\n        self.val = val\\n        self.next = None\\n        self.down = None\\n\\nclass Skiplist(object):\\n\\n    def __init__(self):\\n        self.S = [Node(None)]\\n\\n    def search(self, target):\\n        \"\"\"\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        curr = self.S[-1]\\n        while curr is not None:\\n            # Move right as far as possible without overshooting in the current level \\n            while (curr.next is not None) and (curr.next.val <= target):\\n                if curr.next.val == target:\\n                    # If target found in some (potentially intermediate) level, exit immediately\\n                    return True\\n                curr = curr.next\\n            # Traversed current level as far as possible without finding target\\n            # Move one level down to expand search\\n            curr = curr.down\\n        # Traversed till the end without finding the target, return False\\n        return False\\n\\n    def add(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: None\\n        \"\"\"\\n        # Start at the lowest level and keep flipping coins to decide whether\\n        # to insert an entry for the given value at the next higher level as well.\\n        k = 1\\n        p = random.choice([0, 1])\\n        while (p == 1) and (k < len(self.S)):\\n            k += 1\\n            p = random.choice([0, 1])\\n        if k == len(self.S):\\n            # If an entry will be inserted at the highest level, expand the number of levels.\\n            nr = Node(None)\\n            nr.down = self.S[-1]\\n            self.S.append(nr)\\n        curr = self.S[-1]\\n        kc = len(self.S)\\n        par = None\\n        while curr is not None:\\n            # Traverse to the right in the current level as far as possible without overshooting.\\n            while (curr.next is not None) and (curr.next.val <= num):\\n                curr = curr.next\\n            if kc <= k:\\n                # An entry for the new value needs to be inserted in the current level.\\n                # This entry should be inserted just after the point where rightward traversal stopped.\\n                nn = Node(num)\\n                nn.next = curr.next\\n                curr.next = nn\\n                # Update the downward link for the new entry inserted in the previous level.\\n                if par is not None:\\n                    par.down = nn\\n                par = nn\\n            # Current level done, keep going down.\\n            curr = curr.down\\n            kc -= 1\\n\\n    def erase(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: bool\\n        \"\"\"\\n        curr = self.S[-1]\\n        res = False\\n        while curr is not None:\\n            # Traverse to the right in the current level as far as possible without overshooting.\\n            while (curr.next is not None) and (curr.next.val <= num):\\n                if curr.next.val == num:\\n                    # Target value found inside the next node in the current level.\\n                    # Delete the next node, and since we\\'re done with the current level now,\\n                    # break out of the loop and move on to the next level downwards.\\n                    res = True\\n                    curr.next = curr.next.next\\n                    break\\n                else:\\n                    curr = curr.next\\n            # Go one level down and repeat the process.\\n            curr = curr.down\\n        # Trim the levels if multiple levels can be found towards the top which have only the dummy terminal entry.\\n        # Leave only one of them.\\n        while len(self.S) >= 2:\\n            cand = self.S[-2]\\n            if cand.next is None:\\n                self.S.pop()\\n            else:\\n                break\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1221253,
                "title": "standard-skip-list-implementation-original-research-paper-based",
                "content": "There have been many implementations in discussion. However, some major deviations from standard probabilistic skip lists in those solutions include\\n1. Deterministically deciding level instead of nondeterministically\\n2. Maintenance of multiple nodes for each level of the same search key\\n3. Maintenance of multiple nodes for each appearance of the same search key\\n\\nI implemented a standard version of skip list based on [Skip Lists: A Probabilistic Alternative to Balanced Trees](https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf) by William Pugh, adopting the technique of *fix the dice* in the paper as well. There is no manual memory deallocation in Java, so I omitted the `free(x)` statement. C++ users should feel free to release the unused memory.\\n\\n```java\\nclass Skiplist {\\n    static final int MAX_LEVEL = 16;\\n    static final double P = 0.5;\\n    static final Node sentinel = new Node(0, Integer.MAX_VALUE);\\n    \\n    static class Node {\\n        Node[] forward; // 0-indexed level-wise pointer array\\n        int key;\\n        int value;\\n        \\n        Node(int level, int key) {\\n            forward = new Node[level];\\n            this.key = key;\\n            this.value = 1;\\n        }\\n    }\\n    \\n    Node header;\\n    int listLevel;\\n\\n    public Skiplist() {\\n        header = new Node(MAX_LEVEL, -1);\\n        Arrays.fill(header.forward, sentinel);\\n        listLevel = 1;\\n    }\\n    \\n    public boolean search(int target) {\\n        Node cur = header;\\n        for (int i = listLevel - 1; i >= 0; --i) {\\n            while (cur.forward[i].key < target) {\\n                cur = cur.forward[i];\\n            }\\n        }\\n        return cur.forward[0].key == target;\\n    }\\n    \\n    public void add(int num) {\\n        Node[] update = getPredecessors(num);\\n        Node cur = update[0].forward[0];\\n        \\n        if (cur.key == num) {\\n            ++cur.value;\\n        } else {\\n            int level = randomLevel();\\n            if (level > listLevel) {\\n                for (int i = listLevel; i < level; ++i) {\\n                    update[i] = header;\\n                }\\n                listLevel = level;\\n            }\\n            cur = new Node(level, num);\\n            for (int i = 0; i < level; ++i) {\\n                cur.forward[i] = update[i].forward[i];\\n                update[i].forward[i] = cur;\\n            }\\n        }\\n    }\\n    \\n    public boolean erase(int num) {\\n        Node[] update = getPredecessors(num);\\n        Node cur = update[0].forward[0];\\n        if (cur.key != num) {\\n            return false;\\n        } else {\\n            if (cur.value > 1) {\\n                --cur.value;\\n            } else {\\n                for (int i = 0; i < listLevel; ++i) {\\n                    if (update[i].forward[i] != cur) {\\n                        break;\\n                    }\\n                    update[i].forward[i] = cur.forward[i];\\n                }\\n                while (listLevel > 1 && header.forward[listLevel - 1] == sentinel) {\\n                    --listLevel;\\n                }\\n            }\\n            return true;\\n        }\\n    }\\n    \\n    private Node[] getPredecessors(int target) {\\n        Node[] update = new Node[MAX_LEVEL];\\n        Node cur = header;\\n        for (int i = listLevel - 1; i >= 0; --i) {\\n            while (cur.forward[i].key < target) {\\n                cur = cur.forward[i];\\n            }\\n            update[i] = cur;\\n        }\\n        return update;\\n    }\\n    \\n    private int randomLevel() {\\n        int level = 1;\\n        while (Math.random() < P && level < Math.min(MAX_LEVEL, listLevel + 1)) {\\n            ++level;\\n        }\\n        return level;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Skiplist {\\n    static final int MAX_LEVEL = 16;\\n    static final double P = 0.5;\\n    static final Node sentinel = new Node(0, Integer.MAX_VALUE);\\n    \\n    static class Node {\\n        Node[] forward; // 0-indexed level-wise pointer array\\n        int key;\\n        int value;\\n        \\n        Node(int level, int key) {\\n            forward = new Node[level];\\n            this.key = key;\\n            this.value = 1;\\n        }\\n    }\\n    \\n    Node header;\\n    int listLevel;\\n\\n    public Skiplist() {\\n        header = new Node(MAX_LEVEL, -1);\\n        Arrays.fill(header.forward, sentinel);\\n        listLevel = 1;\\n    }\\n    \\n    public boolean search(int target) {\\n        Node cur = header;\\n        for (int i = listLevel - 1; i >= 0; --i) {\\n            while (cur.forward[i].key < target) {\\n                cur = cur.forward[i];\\n            }\\n        }\\n        return cur.forward[0].key == target;\\n    }\\n    \\n    public void add(int num) {\\n        Node[] update = getPredecessors(num);\\n        Node cur = update[0].forward[0];\\n        \\n        if (cur.key == num) {\\n            ++cur.value;\\n        } else {\\n            int level = randomLevel();\\n            if (level > listLevel) {\\n                for (int i = listLevel; i < level; ++i) {\\n                    update[i] = header;\\n                }\\n                listLevel = level;\\n            }\\n            cur = new Node(level, num);\\n            for (int i = 0; i < level; ++i) {\\n                cur.forward[i] = update[i].forward[i];\\n                update[i].forward[i] = cur;\\n            }\\n        }\\n    }\\n    \\n    public boolean erase(int num) {\\n        Node[] update = getPredecessors(num);\\n        Node cur = update[0].forward[0];\\n        if (cur.key != num) {\\n            return false;\\n        } else {\\n            if (cur.value > 1) {\\n                --cur.value;\\n            } else {\\n                for (int i = 0; i < listLevel; ++i) {\\n                    if (update[i].forward[i] != cur) {\\n                        break;\\n                    }\\n                    update[i].forward[i] = cur.forward[i];\\n                }\\n                while (listLevel > 1 && header.forward[listLevel - 1] == sentinel) {\\n                    --listLevel;\\n                }\\n            }\\n            return true;\\n        }\\n    }\\n    \\n    private Node[] getPredecessors(int target) {\\n        Node[] update = new Node[MAX_LEVEL];\\n        Node cur = header;\\n        for (int i = listLevel - 1; i >= 0; --i) {\\n            while (cur.forward[i].key < target) {\\n                cur = cur.forward[i];\\n            }\\n            update[i] = cur;\\n        }\\n        return update;\\n    }\\n    \\n    private int randomLevel() {\\n        int level = 1;\\n        while (Math.random() < P && level < Math.min(MAX_LEVEL, listLevel + 1)) {\\n            ++level;\\n        }\\n        return level;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1257963,
                "title": "python3-skiplist",
                "content": "\\n```\\nclass ListNode: \\n    def __init__(self, val, cnt=1, next=None, down=None): \\n        self.val = val\\n        self.cnt = cnt\\n        self.next = next\\n        self.down = down\\n\\n        \\nclass Skiplist:\\n\\n    def __init__(self):\\n        self.head = ListNode(-inf)\\n        self.p = 1/4 \\n            \\n    def search(self, target: int) -> bool:\\n        node = self.head \\n        while node and node.val < target: \\n            if node.next and node.next.val <= target: node = node.next \\n            else: node = node.down \\n        return node\\n\\n    def add(self, num: int) -> None:\\n        node = self.head \\n        stack = []\\n        while node and node.val < num: \\n            if node.next and node.next.val <= num: node = node.next \\n            else: \\n                stack.append(node)\\n                node = node.down\\n        if node: \\n            while node: \\n                node.cnt += 1\\n                node = node.down \\n        else: \\n            prev = None\\n            while True: \\n                if stack: \\n                    node = stack.pop()\\n                    node.next = prev = ListNode(num, down=prev, next=node.next)\\n                else: \\n                    self.head = ListNode(-inf, down=self.head)\\n                    self.head.next = prev = ListNode(num, down=prev)\\n                if random.random() >= self.p: break \\n\\n    def erase(self, num: int) -> bool:\\n        node = self.head \\n        stack = []\\n        ans = False\\n        while node: \\n            if node.next and node.next.val < num: node = node.next\\n            else: \\n                stack.append(node)\\n                node = node.down \\n        while stack: \\n            node = stack.pop()\\n            if node.next and node.next.val == num: \\n                ans = True\\n                if node.next.cnt > 1: node.next.cnt -= 1\\n                else: node.next = node.next.next \\n            else: break \\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass ListNode: \\n    def __init__(self, val, cnt=1, next=None, down=None): \\n        self.val = val\\n        self.cnt = cnt\\n        self.next = next\\n        self.down = down\\n\\n        \\nclass Skiplist:\\n\\n    def __init__(self):\\n        self.head = ListNode(-inf)\\n        self.p = 1/4 \\n            \\n    def search(self, target: int) -> bool:\\n        node = self.head \\n        while node and node.val < target: \\n            if node.next and node.next.val <= target: node = node.next \\n            else: node = node.down \\n        return node\\n\\n    def add(self, num: int) -> None:\\n        node = self.head \\n        stack = []\\n        while node and node.val < num: \\n            if node.next and node.next.val <= num: node = node.next \\n            else: \\n                stack.append(node)\\n                node = node.down\\n        if node: \\n            while node: \\n                node.cnt += 1\\n                node = node.down \\n        else: \\n            prev = None\\n            while True: \\n                if stack: \\n                    node = stack.pop()\\n                    node.next = prev = ListNode(num, down=prev, next=node.next)\\n                else: \\n                    self.head = ListNode(-inf, down=self.head)\\n                    self.head.next = prev = ListNode(num, down=prev)\\n                if random.random() >= self.p: break \\n\\n    def erase(self, num: int) -> bool:\\n        node = self.head \\n        stack = []\\n        ans = False\\n        while node: \\n            if node.next and node.next.val < num: node = node.next\\n            else: \\n                stack.append(node)\\n                node = node.down \\n        while stack: \\n            node = stack.pop()\\n            if node.next and node.next.val == num: \\n                ans = True\\n                if node.next.cnt > 1: node.next.cnt -= 1\\n                else: node.next = node.next.next \\n            else: break \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 647742,
                "title": "java-solution-with-comments",
                "content": "\\'\\'\\'\\nclass Skiplist {\\n\\n    //Node class which has val, left, right, up and down pointer\\n    class Node{\\n        int val;\\n        Node left, right, up, down;\\n        Node(int val){\\n            this.val = val;\\n        }\\n    }\\n    //List of sentinels for different stages of skiplist\\n    List<Node> sentinels;\\n    Random random;\\n\\n    public Skiplist() {\\n        sentinels = new ArrayList<>();\\n        //sentinel is initialized with integer min value\\n        sentinels.add(new Node(Integer.MIN_VALUE));\\n        random = new Random();\\n    }\\n    \\n    public boolean search(int target) {\\n        //get the top sentinel\\n        Node start = sentinels.get(sentinels.size() -1);\\n        Node previous = getPreviousNode(start, target);\\n        //if value is not in right, we don\\'t find that value in skiplist\\n        if(previous.right!= null && previous.right.val == target)\\n            return true;\\n        return false;\\n    }\\n    \\n    /**\\n    gets the previous node which is less than equal to the node we are searching\\n    */\\n    private Node getPreviousNode(Node start, int num){\\n        if(start.right == null || start.right.val >= num){\\n            if(start.down == null){\\n                return start;\\n            }else{\\n                start = start.down;\\n            }\\n        }else{\\n            start = start.right;\\n        }\\n        return getPreviousNode(start, num);\\n    }\\n    \\n    public void add(int num) {\\n        Node start = sentinels.get(sentinels.size()-1);\\n        Node previous = getPreviousNode(start, num);\\n        //set the new node\\n        Node right = previous.right;\\n        Node curr = new Node(num);\\n        previous.right = curr;\\n        curr.left = previous;\\n        curr.right = right;\\n        if(right != null)\\n            right.left = curr;\\n        percolateUpAdd(curr);\\n    }\\n    /**\\n    get coinflip boolean \\n    */\\n    private boolean coinFlip(){\\n        int val = random.nextInt(2);\\n        return val%2==0;\\n    }\\n    /**\\n      we pass the add to top layers in skiplist if coinFlip returns true\\n    */\\n    private void percolateUpAdd(Node curr){\\n        if(coinFlip()){\\n            Node prev = curr.left;\\n            //find the prev in up layer\\n            while(prev != null && prev.up == null){\\n                prev = prev.left;\\n            }\\n            if(prev != null){\\n                 //if we find previous\\n                Node newPrev = prev.up;\\n                Node newCurr = new Node(curr.val);\\n                Node right = newPrev.right;\\n                newPrev.right = newCurr;\\n                newCurr.left = newPrev;\\n                newCurr.down = curr;\\n                curr.up = newCurr;\\n                newCurr.right = right;\\n                if(right != null){\\n                    right.left = newCurr;\\n                }\\n                //again check and add in upper layer\\n                percolateUpAdd(newCurr);\\n            }else{\\n                // if its a newly created layer add the sentinel\\n                Node newCurr = new Node(curr.val);\\n                Node newSentinel = new Node(Integer.MIN_VALUE);\\n                newCurr.right = null;\\n                newCurr.down = curr;\\n                curr.up = newCurr;\\n                newSentinel.right = newCurr;\\n                newCurr.left = newSentinel;\\n                Node oldSentinel = sentinels.get(sentinels.size()-1);\\n                oldSentinel.up = newSentinel;\\n                newSentinel.down = oldSentinel;\\n                sentinels.add(newSentinel);\\n            }\\n        }\\n    }\\n    /**\\n      delete the node if it exists in upper layer\\n    */\\n    private void percolateUpDelete(Node curr){\\n        if(curr.up != null){\\n            Node newCurr = curr.up;\\n            curr.up = null;\\n            newCurr.down = null;\\n            Node prev = newCurr.left;\\n            Node right = newCurr.right;\\n            prev.right = right;\\n            if(right != null)\\n                right.left = prev;\\n            newCurr.left = null;\\n            newCurr.right = null;\\n            if(prev.val == Integer.MIN_VALUE){\\n                //check if the sentinel in this layer is only pointing to the deleted node and it is not the last sentinel\\n                if(prev.right == null && prev.up == null && sentinels.size() > 1){\\n                    prev.down = null;\\n                    sentinels.remove(sentinels.size()-1);\\n                    sentinels.get(sentinels.size()-1).up = null;\\n                }\\n            }\\n            percolateUpDelete(newCurr);\\n        }\\n    }\\n    public boolean erase(int num) {\\n        Node start = sentinels.get(sentinels.size()-1);\\n        Node previous = getPreviousNode(start, num);\\n        if(previous.right == null || previous.right.val != num)\\n            return false;\\n        Node curr = previous.right;\\n        previous.right = curr.right;\\n        curr.left = null;\\n        curr.right = null;\\n        if(curr.right != null){\\n            curr.right.left = previous;\\n        }\\n        percolateUpDelete(curr);\\n        return true;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nclass Skiplist {\\n\\n    //Node class which has val, left, right, up and down pointer\\n    class Node{\\n        int val;\\n        Node left, right, up, down;\\n        Node(int val){\\n            this.val = val;\\n        }\\n    }\\n    //List of sentinels for different stages of skiplist\\n    List<Node> sentinels;\\n    Random random;\\n\\n    public Skiplist() {\\n        sentinels = new ArrayList<>();\\n        //sentinel is initialized with integer min value\\n        sentinels.add(new Node(Integer.MIN_VALUE));\\n        random = new Random();\\n    }\\n    \\n    public boolean search(int target) {\\n        //get the top sentinel\\n        Node start = sentinels.get(sentinels.size() -1);\\n        Node previous = getPreviousNode(start, target);\\n        //if value is not in right, we don\\'t find that value in skiplist\\n        if(previous.right!= null && previous.right.val == target)\\n            return true;\\n        return false;\\n    }\\n    \\n    /**\\n    gets the previous node which is less than equal to the node we are searching\\n    */\\n    private Node getPreviousNode(Node start, int num){\\n        if(start.right == null || start.right.val >= num){\\n            if(start.down == null){\\n                return start;\\n            }else{\\n                start = start.down;\\n            }\\n        }else{\\n            start = start.right;\\n        }\\n        return getPreviousNode(start, num);\\n    }\\n    \\n    public void add(int num) {\\n        Node start = sentinels.get(sentinels.size()-1);\\n        Node previous = getPreviousNode(start, num);\\n        //set the new node\\n        Node right = previous.right;\\n        Node curr = new Node(num);\\n        previous.right = curr;\\n        curr.left = previous;\\n        curr.right = right;\\n        if(right != null)\\n            right.left = curr;\\n        percolateUpAdd(curr);\\n    }\\n    /**\\n    get coinflip boolean \\n    */\\n    private boolean coinFlip(){\\n        int val = random.nextInt(2);\\n        return val%2==0;\\n    }\\n    /**\\n      we pass the add to top layers in skiplist if coinFlip returns true\\n    */\\n    private void percolateUpAdd(Node curr){\\n        if(coinFlip()){\\n            Node prev = curr.left;\\n            //find the prev in up layer\\n            while(prev != null && prev.up == null){\\n                prev = prev.left;\\n            }\\n            if(prev != null){\\n                 //if we find previous\\n                Node newPrev = prev.up;\\n                Node newCurr = new Node(curr.val);\\n                Node right = newPrev.right;\\n                newPrev.right = newCurr;\\n                newCurr.left = newPrev;\\n                newCurr.down = curr;\\n                curr.up = newCurr;\\n                newCurr.right = right;\\n                if(right != null){\\n                    right.left = newCurr;\\n                }\\n                //again check and add in upper layer\\n                percolateUpAdd(newCurr);\\n            }else{\\n                // if its a newly created layer add the sentinel\\n                Node newCurr = new Node(curr.val);\\n                Node newSentinel = new Node(Integer.MIN_VALUE);\\n                newCurr.right = null;\\n                newCurr.down = curr;\\n                curr.up = newCurr;\\n                newSentinel.right = newCurr;\\n                newCurr.left = newSentinel;\\n                Node oldSentinel = sentinels.get(sentinels.size()-1);\\n                oldSentinel.up = newSentinel;\\n                newSentinel.down = oldSentinel;\\n                sentinels.add(newSentinel);\\n            }\\n        }\\n    }\\n    /**\\n      delete the node if it exists in upper layer\\n    */\\n    private void percolateUpDelete(Node curr){\\n        if(curr.up != null){\\n            Node newCurr = curr.up;\\n            curr.up = null;\\n            newCurr.down = null;\\n            Node prev = newCurr.left;\\n            Node right = newCurr.right;\\n            prev.right = right;\\n            if(right != null)\\n                right.left = prev;\\n            newCurr.left = null;\\n            newCurr.right = null;\\n            if(prev.val == Integer.MIN_VALUE){\\n                //check if the sentinel in this layer is only pointing to the deleted node and it is not the last sentinel\\n                if(prev.right == null && prev.up == null && sentinels.size() > 1){\\n                    prev.down = null;\\n                    sentinels.remove(sentinels.size()-1);\\n                    sentinels.get(sentinels.size()-1).up = null;\\n                }\\n            }\\n            percolateUpDelete(newCurr);\\n        }\\n    }\\n    public boolean erase(int num) {\\n        Node start = sentinels.get(sentinels.size()-1);\\n        Node previous = getPreviousNode(start, num);\\n        if(previous.right == null || previous.right.val != num)\\n            return false;\\n        Node curr = previous.right;\\n        previous.right = curr.right;\\n        curr.left = null;\\n        curr.right = null;\\n        if(curr.right != null){\\n            curr.right.left = previous;\\n        }\\n        percolateUpDelete(curr);\\n        return true;\\n    }\\n}\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 1573487,
                "title": "clean-python",
                "content": "```\\nimport random\\n\\nclass Node:\\n    def __init__(self, val = -1, right = None, bottom = None):\\n        self.val = val\\n        self.right = right\\n        self.bottom = bottom\\n\\nclass Skiplist:\\n    def __init__(self):\\n        self.head = Node()\\n\\n    def flip_coin(self):\\n        return random.randrange(0, 2)\\n\\n    def search(self, target: int) -> bool:\\n        node = self.head\\n\\n        while node:\\n            while node.right and target > node.right.val:\\n                node = node.right\\n            if node.right and target == node.right.val:\\n                return True\\n            node = node.bottom\\n\\n        return False\\n\\n    def add(self, num: int) -> None:\\n        node = self.head\\n        record_levels = []\\n\\n        while node:\\n            while node.right and num > node.right.val:\\n                node = node.right\\n\\n            record_levels.append(node)\\n            node = node.bottom\\n\\n        new_node = None\\n\\n        while not new_node or self.flip_coin():\\n            if len(record_levels) == 0:\\n                self.head = Node(-1, None, self.head)\\n                prev_level = self.head\\n            else:\\n                prev_level = record_levels.pop()\\n            new_node = Node(num, prev_level.right, new_node)\\n            prev_level.right = new_node\\n\\n    def erase(self, num: int) -> bool:\\n        node = self.head\\n        boolean = False\\n\\n        while node:\\n            while node.right and num > node.right.val:\\n                node = node.right\\n\\n            if node.right and num == node.right.val:\\n                node.right = node.right.right\\n                boolean = True\\n            node = node.bottom\\n\\n        return boolean\\n```",
                "solutionTags": [],
                "code": "```\\nimport random\\n\\nclass Node:\\n    def __init__(self, val = -1, right = None, bottom = None):\\n        self.val = val\\n        self.right = right\\n        self.bottom = bottom\\n\\nclass Skiplist:\\n    def __init__(self):\\n        self.head = Node()\\n\\n    def flip_coin(self):\\n        return random.randrange(0, 2)\\n\\n    def search(self, target: int) -> bool:\\n        node = self.head\\n\\n        while node:\\n            while node.right and target > node.right.val:\\n                node = node.right\\n            if node.right and target == node.right.val:\\n                return True\\n            node = node.bottom\\n\\n        return False\\n\\n    def add(self, num: int) -> None:\\n        node = self.head\\n        record_levels = []\\n\\n        while node:\\n            while node.right and num > node.right.val:\\n                node = node.right\\n\\n            record_levels.append(node)\\n            node = node.bottom\\n\\n        new_node = None\\n\\n        while not new_node or self.flip_coin():\\n            if len(record_levels) == 0:\\n                self.head = Node(-1, None, self.head)\\n                prev_level = self.head\\n            else:\\n                prev_level = record_levels.pop()\\n            new_node = Node(num, prev_level.right, new_node)\\n            prev_level.right = new_node\\n\\n    def erase(self, num: int) -> bool:\\n        node = self.head\\n        boolean = False\\n\\n        while node:\\n            while node.right and num > node.right.val:\\n                node = node.right\\n\\n            if node.right and num == node.right.val:\\n                node.right = node.right.right\\n                boolean = True\\n            node = node.bottom\\n\\n        return boolean\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500036,
                "title": "python-nodes-with-two-pointers",
                "content": "1. for people living in cities like NYC, think about express trains, the top layer has the fewer stops (the optimal implementation probably has that top layer with 0 stops - 1 fake one)\\n2. going from a to b, aka from -inf to some value val, take an express train from start and make sure to switch to a more local train when needed \\n3. tried as many layers as possible from 4 to 100 , test cases behave best around 30\\n4. I always start at the top layer for adds, erase and lookup \\n5. maintain all these linked lists\\n\\n```\\na ------------------------------------>d ---------> f\\na ---------------------> c ----------->d ---------> f\\na --------> b ---------> c ----------->d ---->e---> f\\n```\\nan/the optimal way to get from a to e is to take the first(top) layer from a to d, then transfer to the bottom bottom one to get there\\n\\nas long as that structure is maintained, it yields correct answers\\n\\nwhen adding add to the bottom layer then flip a coin with proability (1/number of layers) to decide whether to build that same stop on the layer on top\\n\\nabout duplicates, remove the first occurence\\n\\n\\n```\\nclass Node(object): \\n    def __init__(self,val): self.val,self.next, self.down = val, None, None\\n        \\nclass Skiplist(object):\\n    def __init__(self, levels = 30):\\n        self.heads = [Node(-float(\\'inf\\')) for _ in range(levels)]\\n        for c,n in zip(self.heads, self.heads[1:]): c.down = n\\n                    \\n    def search(self, target):\\n        cur = self.heads[0]\\n        while(cur):\\n            if cur.next is None or cur.val < target <= cur.next.val:\\n                if cur.next and target == cur.next.val: return True\\n                cur = cur.down\\n            else: cur = cur.next\\n        return False\\n\\n    def add(self, num):\\n        stack,cur,prev = collections.deque([]),self.heads[0], None\\n        while(cur):\\n            if cur.next is None or cur.val < num  <= cur.next.val:\\n                stack.append(cur)\\n                cur = cur.down\\n            else: cur = cur.next\\n        while(stack):\\n            cur = stack.pop()\\n            node = Node(num)\\n            node.next,cur.next = cur.next, node\\n            if prev: node.down = prev\\n            prev = node\\n            if random.randint(0,len(self.heads)-1) < len(self.heads) -1 : break\\n \\n    def erase(self, num):\\n        b,cur = False,self.heads[0]\\n        while(cur):\\n            if cur.next is None or cur.val < num <= cur.next.val:\\n                if cur.next and cur.next.val == num:  b,cur.next = True,cur.next.next\\n                cur = cur.down\\n            else: cur = cur.next   \\n        return b\\n```",
                "solutionTags": [],
                "code": "```\\na ------------------------------------>d ---------> f\\na ---------------------> c ----------->d ---------> f\\na --------> b ---------> c ----------->d ---->e---> f\\n```\n```\\nclass Node(object): \\n    def __init__(self,val): self.val,self.next, self.down = val, None, None\\n        \\nclass Skiplist(object):\\n    def __init__(self, levels = 30):\\n        self.heads = [Node(-float(\\'inf\\')) for _ in range(levels)]\\n        for c,n in zip(self.heads, self.heads[1:]): c.down = n\\n                    \\n    def search(self, target):\\n        cur = self.heads[0]\\n        while(cur):\\n            if cur.next is None or cur.val < target <= cur.next.val:\\n                if cur.next and target == cur.next.val: return True\\n                cur = cur.down\\n            else: cur = cur.next\\n        return False\\n\\n    def add(self, num):\\n        stack,cur,prev = collections.deque([]),self.heads[0], None\\n        while(cur):\\n            if cur.next is None or cur.val < num  <= cur.next.val:\\n                stack.append(cur)\\n                cur = cur.down\\n            else: cur = cur.next\\n        while(stack):\\n            cur = stack.pop()\\n            node = Node(num)\\n            node.next,cur.next = cur.next, node\\n            if prev: node.down = prev\\n            prev = node\\n            if random.randint(0,len(self.heads)-1) < len(self.heads) -1 : break\\n \\n    def erase(self, num):\\n        b,cur = False,self.heads[0]\\n        while(cur):\\n            if cur.next is None or cur.val < num <= cur.next.val:\\n                if cur.next and cur.next.val == num:  b,cur.next = True,cur.next.next\\n                cur = cur.down\\n            else: cur = cur.next   \\n        return b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1972915,
                "title": "c-solution-o-1",
                "content": "```\\nclass Skiplist {\\npublic:\\n    vector<int>m;\\n    Skiplist() {\\n        m=vector<int>(20001,0);\\n    }\\n    \\n    bool search(int target) {\\n        return m[target]!=0;\\n    }\\n    \\n    void add(int num) {\\n        m[num]++;\\n    }\\n    \\n    bool erase(int num) {\\n        if(m[num]>0)\\n            m[num]--;\\n        else\\n            return false;\\n        return true;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Skiplist {\\npublic:\\n    vector<int>m;\\n    Skiplist() {\\n        m=vector<int>(20001,0);\\n    }\\n    \\n    bool search(int target) {\\n        return m[target]!=0;\\n    }\\n    \\n    void add(int num) {\\n        m[num]++;\\n    }\\n    \\n    bool erase(int num) {\\n        if(m[num]>0)\\n            m[num]--;\\n        else\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 962539,
                "title": "c-solution",
                "content": "I watched this video to implement the skiplist\\nhttps://www.youtube.com/watch?v=7pWkspmYUVo&t=1160s&ab_channel=COMP2402Fall2016\\n\\n\\n```\\npublic class Skiplist {\\n    Node head;\\n    Random random;\\n    public Skiplist() {\\n        this.head=new Node(-1,null,null);\\n        this.random=new Random();\\n    }\\n    \\n    public bool Search(int target) {\\n        Node current=this.head;\\n        while(current!=null){\\n            while(current.Next!=null && current.Next.Value<target){\\n                current=current.Next;\\n            }\\n            if(current.Next!=null && current.Next.Value==target)\\n                return true;\\n            current=current.Down;\\n        }\\n        return false;\\n    }\\n    \\n    public void Add(int num) {\\n        Stack<Node> stack=new Stack<Node>();\\n        Node current=this.head;\\n        while(current!=null){\\n            while(current.Next!=null && current.Next.Value<num){\\n                current=current.Next;\\n            }\\n            stack.Push(current);\\n            current=current.Down;\\n        }\\n        bool isInsert=true;\\n        Node down=null;\\n        while(isInsert && stack.Count>0){\\n            current=stack.Pop();\\n            current.Next=new Node(num,current.Next,down);\\n            down=current.Next;\\n            isInsert=random.NextDouble()<0.5;\\n        }\\n        if(isInsert)\\n            head=new Node(-1,null,head);\\n    }\\n    \\n    public bool Erase(int num) {\\n        Node current=this.head;\\n        bool found=false;\\n        while(current!=null){\\n            while(current.Next!=null && current.Next.Value<num){\\n                current=current.Next;\\n            }\\n            if(current.Next!=null && current.Next.Value==num){\\n                found=true;\\n                current.Next=current.Next.Next;\\n            }\\n            current=current.Down;\\n        }\\n        return found;\\n        \\n    }\\n}\\nclass Node{\\n    public int Value;\\n    public Node Next;\\n    public Node Down;\\n    public Node(){\\n        \\n    }\\n    public Node(int val,Node next,Node down){\\n        this.Value=val;\\n        this.Next=next;\\n        this.Down=down;\\n    }\\n    \\n}\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist obj = new Skiplist();\\n * bool param_1 = obj.Search(target);\\n * obj.Add(num);\\n * bool param_3 = obj.Erase(num);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Skiplist {\\n    Node head;\\n    Random random;\\n    public Skiplist() {\\n        this.head=new Node(-1,null,null);\\n        this.random=new Random();\\n    }\\n    \\n    public bool Search(int target) {\\n        Node current=this.head;\\n        while(current!=null){\\n            while(current.Next!=null && current.Next.Value<target){\\n                current=current.Next;\\n            }\\n            if(current.Next!=null && current.Next.Value==target)\\n                return true;\\n            current=current.Down;\\n        }\\n        return false;\\n    }\\n    \\n    public void Add(int num) {\\n        Stack<Node> stack=new Stack<Node>();\\n        Node current=this.head;\\n        while(current!=null){\\n            while(current.Next!=null && current.Next.Value<num){\\n                current=current.Next;\\n            }\\n            stack.Push(current);\\n            current=current.Down;\\n        }\\n        bool isInsert=true;\\n        Node down=null;\\n        while(isInsert && stack.Count>0){\\n            current=stack.Pop();\\n            current.Next=new Node(num,current.Next,down);\\n            down=current.Next;\\n            isInsert=random.NextDouble()<0.5;\\n        }\\n        if(isInsert)\\n            head=new Node(-1,null,head);\\n    }\\n    \\n    public bool Erase(int num) {\\n        Node current=this.head;\\n        bool found=false;\\n        while(current!=null){\\n            while(current.Next!=null && current.Next.Value<num){\\n                current=current.Next;\\n            }\\n            if(current.Next!=null && current.Next.Value==num){\\n                found=true;\\n                current.Next=current.Next.Next;\\n            }\\n            current=current.Down;\\n        }\\n        return found;\\n        \\n    }\\n}\\nclass Node{\\n    public int Value;\\n    public Node Next;\\n    public Node Down;\\n    public Node(){\\n        \\n    }\\n    public Node(int val,Node next,Node down){\\n        this.Value=val;\\n        this.Next=next;\\n        this.Down=down;\\n    }\\n    \\n}\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist obj = new Skiplist();\\n * bool param_1 = obj.Search(target);\\n * obj.Add(num);\\n * bool param_3 = obj.Erase(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393686,
                "title": "c-top-down-search-insert-erase-bottom-up-randomly-generate-inner-node",
                "content": "```\\n    class Skiplist {\\n        struct Node {\\n            int val;\\n            Node* next{ NULL };\\n            Node* pre{ NULL };\\n            Node* down{ NULL };\\n            Node(int val = 0) {\\n                this->val = val;\\n            }\\n        };\\n\\n        Node* heads{ NULL };\\n        int layers = 0;\\n\\n    public:\\n        Skiplist() {\\n            srand(time(NULL));\\n        }\\n\\n        bool search(int target) {\\n            if (heads == NULL) return false;\\n            auto p = heads; // top down\\n            while (p) {\\n                while (p->next && p->next->val < target) p = p->next;\\n                if (p->next && p->next->val == target) return true;\\n                p = p->down;\\n            }\\n            return false;\\n        }\\n\\n        void add(int num) {\\n            Node* p = heads;\\n            vector<Node*> path(layers, NULL);\\n            for (int i = layers - 1; i >= 0; i--) {\\n                while (p->next && p->next->val < num) {\\n                    p = p->next;\\n                }\\n                path[i] = p;\\n                p = p->down;\\n            }\\n\\n            for (int i = 0; i <= path.size(); i++) { // bottom up\\n                p = new Node(num);\\n                if (i == path.size()) {\\n                    Node* last = heads;\\n                    heads = new Node();\\n                    heads->down = last;\\n                    heads->next = p;\\n                    p->pre = heads;\\n                    layers++;\\n                }\\n                else {\\n                    p->next = path[i]->next;\\n                    p->pre = path[i];\\n                    path[i]->next = p;\\n                    if (p->next) p->next->pre = p;\\n                }\\n                if (i) {\\n                    p->down = path[i - 1]->next;\\n                }\\n                if (rand() % 2) {\\n                    break;\\n                }\\n\\n            }\\n        }\\n\\n        bool erase(int num) {\\n            auto p = heads;\\n            for (int i = layers - 1; i >= 0; i--) {\\n                while (p->next && p->next->val < num) p = p->next;\\n                if (p->next && p->next->val == num) {\\n                    p = p->next;\\n                    while (p) {\\n                        p->pre->next = p->next;\\n                        if (p->next) p->next->pre = p->pre;\\n                        p = p->down;\\n                    }\\n\\t\\t\\t\\t\\twhile(heads && heads->next == NULL) {\\n                        heads = heads -> down;\\n                        layers--;\\n                    }\\n                    return true;\\n                }\\n                else {\\n                    p = p->down;\\n                    if (p == NULL) return false;\\n                }\\n            }\\n            return false;\\n        }\\n    };\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    class Skiplist {\\n        struct Node {\\n            int val;\\n            Node* next{ NULL };\\n            Node* pre{ NULL };\\n            Node* down{ NULL };\\n            Node(int val = 0) {\\n                this->val = val;\\n            }\\n        };\\n\\n        Node* heads{ NULL };\\n        int layers = 0;\\n\\n    public:\\n        Skiplist() {\\n            srand(time(NULL));\\n        }\\n\\n        bool search(int target) {\\n            if (heads == NULL) return false;\\n            auto p = heads; // top down\\n            while (p) {\\n                while (p->next && p->next->val < target) p = p->next;\\n                if (p->next && p->next->val == target) return true;\\n                p = p->down;\\n            }\\n            return false;\\n        }\\n\\n        void add(int num) {\\n            Node* p = heads;\\n            vector<Node*> path(layers, NULL);\\n            for (int i = layers - 1; i >= 0; i--) {\\n                while (p->next && p->next->val < num) {\\n                    p = p->next;\\n                }\\n                path[i] = p;\\n                p = p->down;\\n            }\\n\\n            for (int i = 0; i <= path.size(); i++) { // bottom up\\n                p = new Node(num);\\n                if (i == path.size()) {\\n                    Node* last = heads;\\n                    heads = new Node();\\n                    heads->down = last;\\n                    heads->next = p;\\n                    p->pre = heads;\\n                    layers++;\\n                }\\n                else {\\n                    p->next = path[i]->next;\\n                    p->pre = path[i];\\n                    path[i]->next = p;\\n                    if (p->next) p->next->pre = p;\\n                }\\n                if (i) {\\n                    p->down = path[i - 1]->next;\\n                }\\n                if (rand() % 2) {\\n                    break;\\n                }\\n\\n            }\\n        }\\n\\n        bool erase(int num) {\\n            auto p = heads;\\n            for (int i = layers - 1; i >= 0; i--) {\\n                while (p->next && p->next->val < num) p = p->next;\\n                if (p->next && p->next->val == num) {\\n                    p = p->next;\\n                    while (p) {\\n                        p->pre->next = p->next;\\n                        if (p->next) p->next->pre = p->pre;\\n                        p = p->down;\\n                    }\\n\\t\\t\\t\\t\\twhile(heads && heads->next == NULL) {\\n                        heads = heads -> down;\\n                        layers--;\\n                    }\\n                    return true;\\n                }\\n                else {\\n                    p = p->down;\\n                    if (p == NULL) return false;\\n                }\\n            }\\n            return false;\\n        }\\n    };\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2317411,
                "title": "beats-100-other-solutions",
                "content": "```\\nclass Skiplist:\\n\\n    def __init__(self):\\n        self.hashmap = defaultdict(int)\\n        \\n    def search(self, target: int) -> bool:\\n        return self.hashmap[target] != 0\\n        \\n    def add(self, num: int) -> None:\\n        self.hashmap[num] += 1\\n        \\n    def erase(self, num: int) -> bool:\\n        if not self.search(num):\\n            return False\\n        \\n        self.hashmap[num] -= 1\\n        return True\\n        \\n\\n\\n# Your Skiplist object will be instantiated and called as such:\\n# obj = Skiplist()\\n# param_1 = obj.search(target)\\n# obj.add(num)\\n# param_3 = obj.erase(num)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Skiplist:\\n\\n    def __init__(self):\\n        self.hashmap = defaultdict(int)\\n        \\n    def search(self, target: int) -> bool:\\n        return self.hashmap[target] != 0\\n        \\n    def add(self, num: int) -> None:\\n        self.hashmap[num] += 1\\n        \\n    def erase(self, num: int) -> bool:\\n        if not self.search(num):\\n            return False\\n        \\n        self.hashmap[num] -= 1\\n        return True\\n        \\n\\n\\n# Your Skiplist object will be instantiated and called as such:\\n# obj = Skiplist()\\n# param_1 = obj.search(target)\\n# obj.add(num)\\n# param_3 = obj.erase(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267475,
                "title": "easy-c-hashmap-solution",
                "content": "```\\nclass Skiplist {\\npublic:\\n    map<int,int>s;\\n    Skiplist() {\\n        \\n    }\\n    \\n    bool search(int target) {\\n        if(s.find(target)!=s.end())\\n            return true;\\n        else \\n            return false;\\n    }\\n    \\n    void add(int num) {\\n        s[num]++;\\n    }\\n    \\n    bool erase(int num) {\\n        if(s.find(num)==s.end())\\n            return false;\\n        else{\\n            s[num]--;\\n            if(s[num]==0)\\n                s.erase(num);\\n            return true;\\n        }\\n    }\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Skiplist {\\npublic:\\n    map<int,int>s;\\n    Skiplist() {\\n        \\n    }\\n    \\n    bool search(int target) {\\n        if(s.find(target)!=s.end())\\n            return true;\\n        else \\n            return false;\\n    }\\n    \\n    void add(int num) {\\n        s[num]++;\\n    }\\n    \\n    bool erase(int num) {\\n        if(s.find(num)==s.end())\\n            return false;\\n        else{\\n            s[num]--;\\n            if(s[num]==0)\\n                s.erase(num);\\n            return true;\\n        }\\n    }\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2184955,
                "title": "python-pointers",
                "content": "I took a long time and I tried to understand from user\\'s code and explanation but failed to do that for the past 2 weeks.\\nSo, read yuanzhi247012, awice, ye15 ... no progress, but after visiting MIT lecture (1+ hr long but it deserves it I think, thanks je390)\\n\\nI implemented my version but started from je390 after getting the concept from MIT lecture.\\nhttps://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2015/lecture-videos/lecture-7-randomization-skip-lists/\\n\\nI tried to leave a comments as many thing as I can but please let me know if you need any more help. I\\'m happy to help with you all.\\nAlso, if you found any flaws, please let me know this. I always appreciate it.\\n\\n```\\nimport random, math\\nclass Node(object): \\n    def __init__(self,val): \\n        # each node needs val, next, down\\n        # initial value of next, down are None, None\\n        self.val,self.next, self.down = val, None, None\\n        \\nclass Skiplist(object):\\n    def __init__(self, levels = 30):\\n        \\'\\'\\'\\n        1. For sentinel putpose, prepare head and tail\\n        2. for tail, since it\\'s role is little different from head. So just prepare one tail\\n            instead of head that should be the same number as the number of level\\n        3. count: number of nodes at the lowest level\\n        \\'\\'\\'\\n        \\n        self.head = Node(-float(\\'inf\\'))\\n        self.globaltail = Node(float(\\'inf\\'))\\n        self.count = 0\\n        \\n        # two things to do\\n        # 1. prepare head at all levels\\n        # 2. prepare tail and it can be one rather than every level (nevertheless strange drawing)\\n        curr = self.head\\n        curr.next = self.globaltail\\n        for _ in range(levels - 1):\\n            curr.down = Node(-float(\\'inf\\'))\\n            curr = curr.down\\n            curr.next = self.globaltail\\n        # from this construction, there will be self.levels number of head\\n        # and level top head --> level top-1 head --> level top-2 head --- ... ---> level 1 head\\n        \\n        # and after that, self.head points to the head at the top level\\n            \\n    def search(self, target):\\n        \\'\\'\\'\\n        1. Start from self.head (head at the top level)\\n        2. traverse until curr: Why?\\n        2-1. if curr == target, return True. Otherwise, it\\'s destiny is either next or down\\n        \\'\\'\\'\\n        curr = self.head\\n        while curr:\\n            if curr.val == target:\\n                return True\\n            else:\\n                if curr.next.val <= target:\\n                    curr = curr.next\\n                else:\\n                    curr = curr.down\\n        return False\\n                \\n\\n    def add(self, num):\\n        \\'\\'\\'\\n        At the upper level, go next until curr meets curr.next.val is greater than num\\n        So, it should be curr ---- num ---- curr.next if another condition (probability) meets\\n        Probability should be handled after traversing all level, so prepare stack to store curr\\n        \\'\\'\\'\\n        \\n        stack = []\\n        curr = self.head\\n        \\n        while curr:\\n            if num  <= curr.next.val:\\n                stack.append(curr)\\n                curr = curr.down\\n            else: \\n                curr = curr.next\\n        \\n        \\'\\'\\'\\n        prev is to point curr.down pointer to be after add\\n        numNextLevel is to calculate probability upper level at each level\\n        From MIT lecture, it seems the most optimal number of nodes at level is sqrt(level-1)\\n        Then the upper probability to insert node at the level is \\n        (calculated max num of node at the level ) / (original total num of node, self.count)\\n        \\'\\'\\'\\n        prev = None\\n        numNextLevel = math.sqrt(self.count)\\n        while(stack):\\n            curr = stack.pop()\\n            # curr is the node at the lowest level first\\n            node = Node(num)\\n            # create node to be inserted\\n            node.next,curr.next = curr.next, node\\n            # pointer rearrange: Keep in mind. the lowest level always push\\n            \\n            if prev: \\n                node.down = prev\\n            else:\\n                prev = node\\n                # in case of dealing the lowest level, \\n                # need to increase count 1 when inserting\\n                self.count += 1\\n            \\n            if random.random() > (numNextLevel / self.count):\\n                break\\n            # if random probability result says it\\'s okay to process next level\\n            # update numNextLevel\\n            numNextLevel = math.sqrt(numNextLevel)\\n            \\n        \\n    def erase(self, num):\\n        curr = self.head\\n        result = False\\n        \\n        while curr and curr.val < num:\\n            if num <= curr.next.val:\\n                if curr.next and curr.next.val == num:\\n                    self.count -= 1\\n                    result = True\\n                    curr.next = curr.next.next\\n                curr = curr.down\\n            else: \\n                curr = curr.next   \\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport random, math\\nclass Node(object): \\n    def __init__(self,val): \\n        # each node needs val, next, down\\n        # initial value of next, down are None, None\\n        self.val,self.next, self.down = val, None, None\\n        \\nclass Skiplist(object):\\n    def __init__(self, levels = 30):\\n        \\'\\'\\'\\n        1. For sentinel putpose, prepare head and tail\\n        2. for tail, since it\\'s role is little different from head. So just prepare one tail\\n            instead of head that should be the same number as the number of level\\n        3. count: number of nodes at the lowest level\\n        \\'\\'\\'\\n        \\n        self.head = Node(-float(\\'inf\\'))\\n        self.globaltail = Node(float(\\'inf\\'))\\n        self.count = 0\\n        \\n        # two things to do\\n        # 1. prepare head at all levels\\n        # 2. prepare tail and it can be one rather than every level (nevertheless strange drawing)\\n        curr = self.head\\n        curr.next = self.globaltail\\n        for _ in range(levels - 1):\\n            curr.down = Node(-float(\\'inf\\'))\\n            curr = curr.down\\n            curr.next = self.globaltail\\n        # from this construction, there will be self.levels number of head\\n        # and level top head --> level top-1 head --> level top-2 head --- ... ---> level 1 head\\n        \\n        # and after that, self.head points to the head at the top level\\n            \\n    def search(self, target):\\n        \\'\\'\\'\\n        1. Start from self.head (head at the top level)\\n        2. traverse until curr: Why?\\n        2-1. if curr == target, return True. Otherwise, it\\'s destiny is either next or down\\n        \\'\\'\\'\\n        curr = self.head\\n        while curr:\\n            if curr.val == target:\\n                return True\\n            else:\\n                if curr.next.val <= target:\\n                    curr = curr.next\\n                else:\\n                    curr = curr.down\\n        return False\\n                \\n\\n    def add(self, num):\\n        \\'\\'\\'\\n        At the upper level, go next until curr meets curr.next.val is greater than num\\n        So, it should be curr ---- num ---- curr.next if another condition (probability) meets\\n        Probability should be handled after traversing all level, so prepare stack to store curr\\n        \\'\\'\\'\\n        \\n        stack = []\\n        curr = self.head\\n        \\n        while curr:\\n            if num  <= curr.next.val:\\n                stack.append(curr)\\n                curr = curr.down\\n            else: \\n                curr = curr.next\\n        \\n        \\'\\'\\'\\n        prev is to point curr.down pointer to be after add\\n        numNextLevel is to calculate probability upper level at each level\\n        From MIT lecture, it seems the most optimal number of nodes at level is sqrt(level-1)\\n        Then the upper probability to insert node at the level is \\n        (calculated max num of node at the level ) / (original total num of node, self.count)\\n        \\'\\'\\'\\n        prev = None\\n        numNextLevel = math.sqrt(self.count)\\n        while(stack):\\n            curr = stack.pop()\\n            # curr is the node at the lowest level first\\n            node = Node(num)\\n            # create node to be inserted\\n            node.next,curr.next = curr.next, node\\n            # pointer rearrange: Keep in mind. the lowest level always push\\n            \\n            if prev: \\n                node.down = prev\\n            else:\\n                prev = node\\n                # in case of dealing the lowest level, \\n                # need to increase count 1 when inserting\\n                self.count += 1\\n            \\n            if random.random() > (numNextLevel / self.count):\\n                break\\n            # if random probability result says it\\'s okay to process next level\\n            # update numNextLevel\\n            numNextLevel = math.sqrt(numNextLevel)\\n            \\n        \\n    def erase(self, num):\\n        curr = self.head\\n        result = False\\n        \\n        while curr and curr.val < num:\\n            if num <= curr.next.val:\\n                if curr.next and curr.next.val == num:\\n                    self.count -= 1\\n                    result = True\\n                    curr.next = curr.next.next\\n                curr = curr.down\\n            else: \\n                curr = curr.next   \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1973105,
                "title": "skip-list-implementation-future-implementation-complexity-analysis",
                "content": "Below is the randomized implemenation of skip list.\\n\\n\\n```\\nclass Skiplist {\\n    class Node {\\n        int val;\\n        Node next, down;\\n        public Node(int val, Node next, Node down) {\\n            this.val = val;\\n            this.next = next;\\n            this.down = down;\\n        }\\n    }\\n    Node head = new Node(-1, null, null);\\n    Random rand = new Random();\\n    public Skiplist() {\\n        \\n    }\\n    \\n    public boolean search(int target) {\\n        Node cur = head;\\n        while (cur != null) {\\n            while (cur.next != null && cur.next.val < target) {\\n                cur = cur.next;\\n            }\\n            if (cur.next != null && cur.next.val == target) return true;\\n            cur = cur.down;\\n        }\\n        return false;\\n    }\\n    \\n    public void add(int num) {\\n        Stack<Node> stack = new Stack<>();\\n        Node cur = head;\\n        while (cur != null) {\\n            while (cur.next != null && cur.next.val < num) {\\n                cur = cur.next;\\n            }\\n            stack.push(cur);\\n            cur = cur.down;\\n        }\\n        boolean insert = true;\\n        Node down = null;\\n        while (insert && !stack.isEmpty()) {\\n            cur = stack.pop();\\n            cur.next = new Node(num, cur.next, down);\\n            down = cur.next;\\n            insert = rand.nextDouble() < 0.5;\\n        }\\n        if (insert) head = new Node(-1, null, head);\\n    }\\n    \\n    public boolean erase(int num) {\\n        Node cur = head;\\n        boolean found = false;\\n        while (cur != null) {\\n            while (cur.next != null && cur.next.val < num) {\\n                cur = cur.next;\\n            }\\n            if (cur.next != null && cur.next.val == num) {\\n                found = true;\\n                cur.next = cur.next.next;\\n            }\\n            cur = cur.down;\\n        }\\n        return found;\\n    }\\n}\\n```\\n\\nReference. : https://www.youtube.com/watch?v=NDGpsfwAaqo\\n\\nAbove video does not contains code but it contains following valueable points\\n1.Complexity analysis.\\n2.Perfect Skip List( quite rigid as levels will be constant)\\n3.Randomized skip list.\\n\\nHint for Future work : Since like in this question max value of n can be 2*10^4 so levels in skips list will 16.\\nBy this logic we can fix number of coni flips to 16. For this question this might give you better memory advantage.\\n\\nNote : Even if you are using above code, please make sure you debug it and understand it well, otherwise there is no point of copy pasting it.",
                "solutionTags": [],
                "code": "```\\nclass Skiplist {\\n    class Node {\\n        int val;\\n        Node next, down;\\n        public Node(int val, Node next, Node down) {\\n            this.val = val;\\n            this.next = next;\\n            this.down = down;\\n        }\\n    }\\n    Node head = new Node(-1, null, null);\\n    Random rand = new Random();\\n    public Skiplist() {\\n        \\n    }\\n    \\n    public boolean search(int target) {\\n        Node cur = head;\\n        while (cur != null) {\\n            while (cur.next != null && cur.next.val < target) {\\n                cur = cur.next;\\n            }\\n            if (cur.next != null && cur.next.val == target) return true;\\n            cur = cur.down;\\n        }\\n        return false;\\n    }\\n    \\n    public void add(int num) {\\n        Stack<Node> stack = new Stack<>();\\n        Node cur = head;\\n        while (cur != null) {\\n            while (cur.next != null && cur.next.val < num) {\\n                cur = cur.next;\\n            }\\n            stack.push(cur);\\n            cur = cur.down;\\n        }\\n        boolean insert = true;\\n        Node down = null;\\n        while (insert && !stack.isEmpty()) {\\n            cur = stack.pop();\\n            cur.next = new Node(num, cur.next, down);\\n            down = cur.next;\\n            insert = rand.nextDouble() < 0.5;\\n        }\\n        if (insert) head = new Node(-1, null, head);\\n    }\\n    \\n    public boolean erase(int num) {\\n        Node cur = head;\\n        boolean found = false;\\n        while (cur != null) {\\n            while (cur.next != null && cur.next.val < num) {\\n                cur = cur.next;\\n            }\\n            if (cur.next != null && cur.next.val == num) {\\n                found = true;\\n                cur.next = cur.next.next;\\n            }\\n            cur = cur.down;\\n        }\\n        return found;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1972012,
                "title": "simple-c-solution-o-n-space-and-o-1-time",
                "content": "```\\nclass Skiplist {\\npublic:\\n    int mp[100005];\\n    Skiplist() {\\n        memset(mp,0,sizeof(mp));\\n    }\\n    \\n    bool search(int target) {\\n         return mp[target];\\n    }\\n    \\n    void add(int num) {\\n        mp[num]++;\\n    }\\n    \\n    bool erase(int num) {\\n         if(mp[num]) {\\n             mp[num]--;\\n             return true;\\n         }else {\\n             return false;\\n         }\\n    }\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Skiplist {\\npublic:\\n    int mp[100005];\\n    Skiplist() {\\n        memset(mp,0,sizeof(mp));\\n    }\\n    \\n    bool search(int target) {\\n         return mp[target];\\n    }\\n    \\n    void add(int num) {\\n        mp[num]++;\\n    }\\n    \\n    bool erase(int num) {\\n         if(mp[num]) {\\n             mp[num]--;\\n             return true;\\n         }else {\\n             return false;\\n         }\\n    }\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1964863,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n\\tclass Skiplist {\\n\\n    static final int MAX_LEVEL = 16;\\n    static final double P = 0.5;\\n    static final Node sentinel = new Node(0, Integer.MAX_VALUE);\\n    \\n    static class Node {\\n        Node[] forward; // 0-indexed level-wise pointer array\\n        int key;\\n        int value;\\n        \\n        Node(int level, int key) {\\n            forward = new Node[level];\\n            this.key = key;\\n            this.value = 1;\\n        }\\n    }\\n    \\n    Node header;\\n    int listLevel;\\n\\n    public Skiplist() {\\n        header = new Node(MAX_LEVEL, -1);\\n        Arrays.fill(header.forward, sentinel);\\n        listLevel = 1;\\n    }\\n    \\n    public boolean search(int target) {\\n        Node cur = header;\\n        for (int i = listLevel - 1; i >= 0; --i) {\\n            while (cur.forward[i].key < target) {\\n                cur = cur.forward[i];\\n            }\\n        }\\n        return cur.forward[0].key == target;\\n    }\\n    \\n    public void add(int num) {\\n        Node[] update = getPredecessors(num);\\n        Node cur = update[0].forward[0];\\n        \\n        if (cur.key == num) {\\n            ++cur.value;\\n        } else {\\n            int level = randomLevel();\\n            if (level > listLevel) {\\n                for (int i = listLevel; i < level; ++i) {\\n                    update[i] = header;\\n                }\\n                listLevel = level;\\n            }\\n            cur = new Node(level, num);\\n            for (int i = 0; i < level; ++i) {\\n                cur.forward[i] = update[i].forward[i];\\n                update[i].forward[i] = cur;\\n            }\\n        }\\n    }\\n    \\n    public boolean erase(int num) {\\n        Node[] update = getPredecessors(num);\\n        Node cur = update[0].forward[0];\\n        if (cur.key != num) {\\n            return false;\\n        } else {\\n            if (cur.value > 1) {\\n                --cur.value;\\n            } else {\\n                for (int i = 0; i < listLevel; ++i) {\\n                    if (update[i].forward[i] != cur) {\\n                        break;\\n                    }\\n                    update[i].forward[i] = cur.forward[i];\\n                }\\n                while (listLevel > 1 && header.forward[listLevel - 1] == sentinel) {\\n                    --listLevel;\\n                }\\n            }\\n            return true;\\n        }\\n    }\\n    \\n    private Node[] getPredecessors(int target) {\\n        Node[] update = new Node[MAX_LEVEL];\\n        Node cur = header;\\n        for (int i = listLevel - 1; i >= 0; --i) {\\n            while (cur.forward[i].key < target) {\\n                cur = cur.forward[i];\\n            }\\n            update[i] = cur;\\n        }\\n        return update;\\n    }\\n    \\n    private int randomLevel() {\\n        int level = 1;\\n        while (Math.random() < P && level < Math.min(MAX_LEVEL, listLevel + 1)) {\\n            ++level;\\n        }\\n        return level;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n\\tclass Skiplist {\\n\\n    static final int MAX_LEVEL = 16;\\n    static final double P = 0.5;\\n    static final Node sentinel = new Node(0, Integer.MAX_VALUE);\\n    \\n    static class Node {\\n        Node[] forward; // 0-indexed level-wise pointer array\\n        int key;\\n        int value;\\n        \\n        Node(int level, int key) {\\n            forward = new Node[level];\\n            this.key = key;\\n            this.value = 1;\\n        }\\n    }\\n    \\n    Node header;\\n    int listLevel;\\n\\n    public Skiplist() {\\n        header = new Node(MAX_LEVEL, -1);\\n        Arrays.fill(header.forward, sentinel);\\n        listLevel = 1;\\n    }\\n    \\n    public boolean search(int target) {\\n        Node cur = header;\\n        for (int i = listLevel - 1; i >= 0; --i) {\\n            while (cur.forward[i].key < target) {\\n                cur = cur.forward[i];\\n            }\\n        }\\n        return cur.forward[0].key == target;\\n    }\\n    \\n    public void add(int num) {\\n        Node[] update = getPredecessors(num);\\n        Node cur = update[0].forward[0];\\n        \\n        if (cur.key == num) {\\n            ++cur.value;\\n        } else {\\n            int level = randomLevel();\\n            if (level > listLevel) {\\n                for (int i = listLevel; i < level; ++i) {\\n                    update[i] = header;\\n                }\\n                listLevel = level;\\n            }\\n            cur = new Node(level, num);\\n            for (int i = 0; i < level; ++i) {\\n                cur.forward[i] = update[i].forward[i];\\n                update[i].forward[i] = cur;\\n            }\\n        }\\n    }\\n    \\n    public boolean erase(int num) {\\n        Node[] update = getPredecessors(num);\\n        Node cur = update[0].forward[0];\\n        if (cur.key != num) {\\n            return false;\\n        } else {\\n            if (cur.value > 1) {\\n                --cur.value;\\n            } else {\\n                for (int i = 0; i < listLevel; ++i) {\\n                    if (update[i].forward[i] != cur) {\\n                        break;\\n                    }\\n                    update[i].forward[i] = cur.forward[i];\\n                }\\n                while (listLevel > 1 && header.forward[listLevel - 1] == sentinel) {\\n                    --listLevel;\\n                }\\n            }\\n            return true;\\n        }\\n    }\\n    \\n    private Node[] getPredecessors(int target) {\\n        Node[] update = new Node[MAX_LEVEL];\\n        Node cur = header;\\n        for (int i = listLevel - 1; i >= 0; --i) {\\n            while (cur.forward[i].key < target) {\\n                cur = cur.forward[i];\\n            }\\n            update[i] = cur;\\n        }\\n        return update;\\n    }\\n    \\n    private int randomLevel() {\\n        int level = 1;\\n        while (Math.random() < P && level < Math.min(MAX_LEVEL, listLevel + 1)) {\\n            ++level;\\n        }\\n        return level;\\n    }\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1397493,
                "title": "c-solution-with-comments",
                "content": "```\\nclass Skiplist {\\nprivate : \\n        struct Node {\\n            Node* next;\\n            Node* down;\\n            int val;\\n            Node(int val1, Node* next1=nullptr, Node* down1=nullptr) : val(val1), next(next1), down(down1){}\\n        };\\n    \\npublic:\\n    \\n    Node* head;\\n    int numlevels = 1;\\n    int numcount = 0;\\n    \\n    Skiplist() {\\n        // keeping -1 as the first element in all levels\\n        head = new Node(-1);\\n    }\\n    \\n    bool search(int target) {\\n        Node* ptr = head;\\n        while(ptr)\\n        {\\n            while(ptr->next && ptr->next->val < target)\\n                ptr = ptr->next;\\n            \\n            if(ptr->next && ptr->next->val == target) return true;\\n            ptr = ptr->down;\\n        }\\n        return false;\\n    }\\n    \\n    // get the number of levels for new element \\n    int getLevel(){\\n        int ans = 1;\\n        while(rand()%2 && ans < numlevels)\\n            ans++;\\n        return ans;\\n    }\\n    \\n    \\n    void add(int num) {\\n        \\n        // move down till the last level where we will insert the new element\\n        int maxlev = getLevel();\\n        Node* ptr=head;\\n        for(int i=0; i<numlevels-maxlev; i++)\\n            ptr = ptr->down;\\n        \\n        // using stack to assign down pointer after they have all been created\\n        stack<Node*> stk;\\n        \\n        while(ptr)\\n        {  \\n            while( ptr->next && ptr->next->val < num)  \\n                ptr = ptr->next;\\n            \\n            ptr->next = new Node(num,ptr->next,nullptr);\\n            stk.push(ptr->next);\\n            ptr = ptr->down;\\n        }\\n        \\n        Node* prevNode = stk.top(); stk.pop();\\n        while(!stk.empty())\\n        {\\n            stk.top()->down = prevNode;\\n            prevNode = stk.top();\\n            stk.pop();\\n        }\\n        \\n        // keeping the logarithmic bound\\n        numcount++;\\n        if(numcount > (1<<(numlevels-1)))\\n        {\\n            head = new Node(-1,nullptr,head);\\n            numlevels++;\\n        }\\n        \\n    }\\n    \\n    bool erase(int num) {\\n        \\n        bool ans=false;\\n        \\n        Node* ptr = head;\\n        Node* todel = nullptr; // delete elements from a single column only, necessary to handle duplicates\\n        while(ptr)\\n        {\\n            while(ptr->next && (ptr->next->val < num || ( ptr->next->val == num && todel && ptr->next != todel) ) )\\n                ptr=ptr->next;\\n             \\n            if(ptr->next && ptr->next->val == num)\\n            {\\n                todel = ptr->next->down;\\n                Node* temp = ptr->next;\\n                ptr->next = ptr->next->next;\\n                delete temp; // deleting the node is important \\n                ans = true;\\n            }\\n            \\n            ptr = ptr->down;\\n        }\\n        numcount--;\\n        return ans;\\n        \\n    }\\n\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Skiplist {\\nprivate : \\n        struct Node {\\n            Node* next;\\n            Node* down;\\n            int val;\\n            Node(int val1, Node* next1=nullptr, Node* down1=nullptr) : val(val1), next(next1), down(down1){}\\n        };\\n    \\npublic:\\n    \\n    Node* head;\\n    int numlevels = 1;\\n    int numcount = 0;\\n    \\n    Skiplist() {\\n        // keeping -1 as the first element in all levels\\n        head = new Node(-1);\\n    }\\n    \\n    bool search(int target) {\\n        Node* ptr = head;\\n        while(ptr)\\n        {\\n            while(ptr->next && ptr->next->val < target)\\n                ptr = ptr->next;\\n            \\n            if(ptr->next && ptr->next->val == target) return true;\\n            ptr = ptr->down;\\n        }\\n        return false;\\n    }\\n    \\n    // get the number of levels for new element \\n    int getLevel(){\\n        int ans = 1;\\n        while(rand()%2 && ans < numlevels)\\n            ans++;\\n        return ans;\\n    }\\n    \\n    \\n    void add(int num) {\\n        \\n        // move down till the last level where we will insert the new element\\n        int maxlev = getLevel();\\n        Node* ptr=head;\\n        for(int i=0; i<numlevels-maxlev; i++)\\n            ptr = ptr->down;\\n        \\n        // using stack to assign down pointer after they have all been created\\n        stack<Node*> stk;\\n        \\n        while(ptr)\\n        {  \\n            while( ptr->next && ptr->next->val < num)  \\n                ptr = ptr->next;\\n            \\n            ptr->next = new Node(num,ptr->next,nullptr);\\n            stk.push(ptr->next);\\n            ptr = ptr->down;\\n        }\\n        \\n        Node* prevNode = stk.top(); stk.pop();\\n        while(!stk.empty())\\n        {\\n            stk.top()->down = prevNode;\\n            prevNode = stk.top();\\n            stk.pop();\\n        }\\n        \\n        // keeping the logarithmic bound\\n        numcount++;\\n        if(numcount > (1<<(numlevels-1)))\\n        {\\n            head = new Node(-1,nullptr,head);\\n            numlevels++;\\n        }\\n        \\n    }\\n    \\n    bool erase(int num) {\\n        \\n        bool ans=false;\\n        \\n        Node* ptr = head;\\n        Node* todel = nullptr; // delete elements from a single column only, necessary to handle duplicates\\n        while(ptr)\\n        {\\n            while(ptr->next && (ptr->next->val < num || ( ptr->next->val == num && todel && ptr->next != todel) ) )\\n                ptr=ptr->next;\\n             \\n            if(ptr->next && ptr->next->val == num)\\n            {\\n                todel = ptr->next->down;\\n                Node* temp = ptr->next;\\n                ptr->next = ptr->next->next;\\n                delete temp; // deleting the node is important \\n                ans = true;\\n            }\\n            \\n            ptr = ptr->down;\\n        }\\n        numcount--;\\n        return ans;\\n        \\n    }\\n\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304164,
                "title": "concise-solution",
                "content": "```\\nclass Skiplist {\\n    constructor() {\\n        this.head = new Node();\\n    }\\n\\n    search(value) {\\n        for (let curr = this.head; curr; curr = curr.down) {\\n            for (; curr.next && curr.next.value < value; curr = curr.next);\\n            if (curr.next && curr.next.value === value) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    add(value) {\\n        const stack = [];\\n        let curr = this.head;\\n        for (; curr; curr = curr.down) {\\n            for (; curr.next && curr.next.value < value; curr = curr.next);\\n            stack.push(curr);\\n        }\\n        let shouldInsert = true;\\n        for (let down = null; shouldInsert && stack.length; down = curr.next) {\\n            curr = stack.pop();\\n            curr.next = new Node(value, curr.next, down);\\n            shouldInsert = Math.random() < 0.5;\\n        }\\n        if (shouldInsert) {\\n            this.head = new Node(undefined, null, this.head);\\n        }\\n    }\\n\\n    erase(value) {\\n        let isFound = false;\\n        for (let curr = this.head; curr; curr = curr.down) {\\n            for (; curr.next && curr.next.value < value; curr = curr.next);\\n            if (curr.next && curr.next.value === value) {\\n                isFound = true;\\n                curr.next = curr.next.next;\\n            }\\n        }\\n        return isFound;\\n    }\\n}\\n\\nclass Node {\\n    constructor(value, next = null, down = null) {\\n        this.value = value;\\n        this.next = next;\\n        this.down = down;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Skiplist {\\n    constructor() {\\n        this.head = new Node();\\n    }\\n\\n    search(value) {\\n        for (let curr = this.head; curr; curr = curr.down) {\\n            for (; curr.next && curr.next.value < value; curr = curr.next);\\n            if (curr.next && curr.next.value === value) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    add(value) {\\n        const stack = [];\\n        let curr = this.head;\\n        for (; curr; curr = curr.down) {\\n            for (; curr.next && curr.next.value < value; curr = curr.next);\\n            stack.push(curr);\\n        }\\n        let shouldInsert = true;\\n        for (let down = null; shouldInsert && stack.length; down = curr.next) {\\n            curr = stack.pop();\\n            curr.next = new Node(value, curr.next, down);\\n            shouldInsert = Math.random() < 0.5;\\n        }\\n        if (shouldInsert) {\\n            this.head = new Node(undefined, null, this.head);\\n        }\\n    }\\n\\n    erase(value) {\\n        let isFound = false;\\n        for (let curr = this.head; curr; curr = curr.down) {\\n            for (; curr.next && curr.next.value < value; curr = curr.next);\\n            if (curr.next && curr.next.value === value) {\\n                isFound = true;\\n                curr.next = curr.next.next;\\n            }\\n        }\\n        return isFound;\\n    }\\n}\\n\\nclass Node {\\n    constructor(value, next = null, down = null) {\\n        this.value = value;\\n        this.next = next;\\n        this.down = down;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 981585,
                "title": "java",
                "content": "```\\nclass Skiplist {\\n    class Node{\\n        Integer value;\\n        Node left;\\n        Node right;\\n        Node up;\\n        Node down;\\n        public Node(int n){\\n            value = n;\\n        }\\n    }\\n    int height = 0;\\n    Random rand;\\n    Node head;\\n    Node tail;\\n    public Skiplist() {\\n        Node node1 = new Node(Integer.MIN_VALUE);\\n        Node node2 = new Node(Integer.MAX_VALUE);\\n        node1.right = node2;\\n        node2.left = node1;\\n        head = node1;\\n        tail = node2;\\n        rand = new Random();\\n    }\\n    \\n    public boolean search(int target) {\\n        return find(target).value == target;\\n    }\\n    \\n    public void add(int num) {\\n        Node node = find(num);\\n        Node n = new Node(num);\\n        Node right = node.right;\\n        node.right = n;\\n        n.left = node;\\n        n.right = right;\\n        right.left = n;\\n        int curHeight = 0;\\n        while(rand.nextDouble()<0.5){\\n            if(curHeight == height)\\n                addLevel();\\n            node = n;\\n            while(node.up==null)\\n                node = node.left;\\n            node = node.up;\\n            Node nRight = node.right;\\n            Node next = new Node(num);\\n            node.right = next;\\n            next.left = node;\\n            next.right = nRight;\\n            nRight.left = next;\\n            next.down = n;\\n            n.up = next;\\n            n = next;\\n            curHeight++;\\n        }\\n    }\\n    \\n    public boolean erase(int num) {\\n        Node node = find(num);\\n        if(node.value != num)\\n            return false;\\n        while(node != null){\\n            Node left = node.left;\\n            Node right = node.right;\\n            left.right = right;\\n            right.left = left;\\n            node = node.up;\\n        }\\n        return true;\\n    }\\n    public Node find(int target){\\n        Node cur = head;\\n        while(true){\\n            while(cur.right.value!=Integer.MAX_VALUE && cur.right.value<=target)\\n                cur = cur.right;\\n            if(cur.down!=null)\\n                cur=cur.down;\\n            else\\n                break;\\n        }\\n        return cur;\\n    }\\n    public void addLevel(){\\n        Node node1 = new Node(Integer.MIN_VALUE);\\n        Node node2 = new Node(Integer.MAX_VALUE);\\n        node1.down = head;\\n        node1.right = node2;\\n        head.up = node1;\\n        head = node1;\\n        node2.left = node1;\\n        node2.down = tail;\\n        tail.up =node2;\\n        tail = node2;\\n        height++;\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nclass Skiplist {\\n    class Node{\\n        Integer value;\\n        Node left;\\n        Node right;\\n        Node up;\\n        Node down;\\n        public Node(int n){\\n            value = n;\\n        }\\n    }\\n    int height = 0;\\n    Random rand;\\n    Node head;\\n    Node tail;\\n    public Skiplist() {\\n        Node node1 = new Node(Integer.MIN_VALUE);\\n        Node node2 = new Node(Integer.MAX_VALUE);\\n        node1.right = node2;\\n        node2.left = node1;\\n        head = node1;\\n        tail = node2;\\n        rand = new Random();\\n    }\\n    \\n    public boolean search(int target) {\\n        return find(target).value == target;\\n    }\\n    \\n    public void add(int num) {\\n        Node node = find(num);\\n        Node n = new Node(num);\\n        Node right = node.right;\\n        node.right = n;\\n        n.left = node;\\n        n.right = right;\\n        right.left = n;\\n        int curHeight = 0;\\n        while(rand.nextDouble()<0.5){\\n            if(curHeight == height)\\n                addLevel();\\n            node = n;\\n            while(node.up==null)\\n                node = node.left;\\n            node = node.up;\\n            Node nRight = node.right;\\n            Node next = new Node(num);\\n            node.right = next;\\n            next.left = node;\\n            next.right = nRight;\\n            nRight.left = next;\\n            next.down = n;\\n            n.up = next;\\n            n = next;\\n            curHeight++;\\n        }\\n    }\\n    \\n    public boolean erase(int num) {\\n        Node node = find(num);\\n        if(node.value != num)\\n            return false;\\n        while(node != null){\\n            Node left = node.left;\\n            Node right = node.right;\\n            left.right = right;\\n            right.left = left;\\n            node = node.up;\\n        }\\n        return true;\\n    }\\n    public Node find(int target){\\n        Node cur = head;\\n        while(true){\\n            while(cur.right.value!=Integer.MAX_VALUE && cur.right.value<=target)\\n                cur = cur.right;\\n            if(cur.down!=null)\\n                cur=cur.down;\\n            else\\n                break;\\n        }\\n        return cur;\\n    }\\n    public void addLevel(){\\n        Node node1 = new Node(Integer.MIN_VALUE);\\n        Node node2 = new Node(Integer.MAX_VALUE);\\n        node1.down = head;\\n        node1.right = node2;\\n        head.up = node1;\\n        head = node1;\\n        node2.left = node1;\\n        node2.down = tail;\\n        tail.up =node2;\\n        tail = node2;\\n        height++;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 840319,
                "title": "c-simple-skiplist",
                "content": "```\\nstruct Node\\n{\\n    Node(int val, shared_ptr<Node> right, shared_ptr<Node> down)\\n        : val(val), right(right), down(down) {}\\n    \\n    int val;\\n    shared_ptr<Node> right;\\n    shared_ptr<Node> down;\\n};\\n\\nclass Skiplist \\n{\\npublic:\\n    Skiplist() : node(new Node(-1, shared_ptr<Node>(), shared_ptr<Node>()))\\n    {}\\n    \\n    bool search(int target) \\n    {\\n        for (auto ptr = node; ptr; ptr = ptr->down)\\n        {\\n            while (ptr->right && ptr->right->val < target)\\n                ptr = ptr->right;\\n            \\n            if (ptr->right && ptr->right->val == target)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    void add(int num) \\n    {\\n        stack<shared_ptr<Node>> stack;\\n        shared_ptr<Node> down;\\n        auto insert = true;\\n        \\n        for (auto ptr = node; ptr; ptr = ptr->down)\\n        {\\n            while (ptr->right && ptr->right->val < num)\\n                ptr = ptr->right;\\n            \\n            stack.push(ptr);\\n        }\\n        \\n        while (insert && !stack.empty())\\n        {\\n            auto cur = stack.top();\\n            stack.pop();\\n            \\n            cur->right = make_shared<Node>(num, cur->right, down);\\n            down = cur->right;\\n            \\n            insert = rand() & 1;\\n        }\\n       \\n        if (insert)\\n            node = make_shared<Node>(-1, shared_ptr<Node>(), node);\\n    }\\n    \\n    bool erase(int num) \\n    {\\n        auto seen = false;\\n        \\n        for (auto ptr = node; ptr; ptr = ptr->down)\\n        {\\n            while (ptr->right && ptr->right->val < num)\\n                ptr = ptr->right;\\n            \\n            if (ptr->right && ptr->right->val == num)\\n                seen = true, ptr->right = ptr->right->right;\\n        }\\n        \\n        return seen;\\n    }\\n    \\nprivate:\\n    shared_ptr<Node> node;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Node\\n{\\n    Node(int val, shared_ptr<Node> right, shared_ptr<Node> down)\\n        : val(val), right(right), down(down) {}\\n    \\n    int val;\\n    shared_ptr<Node> right;\\n    shared_ptr<Node> down;\\n};\\n\\nclass Skiplist \\n{\\npublic:\\n    Skiplist() : node(new Node(-1, shared_ptr<Node>(), shared_ptr<Node>()))\\n    {}\\n    \\n    bool search(int target) \\n    {\\n        for (auto ptr = node; ptr; ptr = ptr->down)\\n        {\\n            while (ptr->right && ptr->right->val < target)\\n                ptr = ptr->right;\\n            \\n            if (ptr->right && ptr->right->val == target)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    void add(int num) \\n    {\\n        stack<shared_ptr<Node>> stack;\\n        shared_ptr<Node> down;\\n        auto insert = true;\\n        \\n        for (auto ptr = node; ptr; ptr = ptr->down)\\n        {\\n            while (ptr->right && ptr->right->val < num)\\n                ptr = ptr->right;\\n            \\n            stack.push(ptr);\\n        }\\n        \\n        while (insert && !stack.empty())\\n        {\\n            auto cur = stack.top();\\n            stack.pop();\\n            \\n            cur->right = make_shared<Node>(num, cur->right, down);\\n            down = cur->right;\\n            \\n            insert = rand() & 1;\\n        }\\n       \\n        if (insert)\\n            node = make_shared<Node>(-1, shared_ptr<Node>(), node);\\n    }\\n    \\n    bool erase(int num) \\n    {\\n        auto seen = false;\\n        \\n        for (auto ptr = node; ptr; ptr = ptr->down)\\n        {\\n            while (ptr->right && ptr->right->val < num)\\n                ptr = ptr->right;\\n            \\n            if (ptr->right && ptr->right->val == num)\\n                seen = true, ptr->right = ptr->right->right;\\n        }\\n        \\n        return seen;\\n    }\\n    \\nprivate:\\n    shared_ptr<Node> node;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 762661,
                "title": "rust-using-rc-and-only-right-and-down-pointers-idiomatic-code-with-pretty-printer",
                "content": "Each node only has value, right and down. I use a stack of nodes when traversing, so I can find the previous node of a target node.\\n\\n\\nI also implemented a pretty printer which was tougher than expected since each node only has right and down. I had to create a map from Node to upper node and then go row by row from the bottom-most row.\\n\\nI use `.filter()` in some places. I would not like to use this, but currently rust doesn\\'t allow for the syntax `if let Some(x) = y() && x.some_function()`, so I have to make do with `y().filter(...)`.\\n\\n\\n\\n```\\nuse std::cell::RefCell;\\nuse std::collections::HashMap;\\nuse std::rc::Rc;\\n\\ntype Link = Rc<RefCell<Node>>;\\nfn new_link(value: i32) -> Link {\\n    Rc::new(RefCell::new(Node::new(value)))\\n}\\n\\n#[derive(Debug)]\\nstruct Node {\\n    value: i32,\\n    right: Option<Link>,\\n    down: Option<Link>,\\n}\\n\\nimpl Node {\\n    pub fn new(value: i32) -> Node {\\n        Node {\\n            value,\\n            right: None,\\n            down: None,\\n        }\\n    }\\n}\\n\\nstruct Skiplist {\\n    start: Link,\\n}\\n\\nimpl Skiplist {\\n    fn new() -> Self {\\n        Skiplist {\\n            start: new_link(std::i32::MIN),\\n        }\\n    }\\n\\n    fn find(&self, target: i32) -> Vec<Link> {\\n        let mut node_opt = Some(self.start.clone());\\n        let mut stack = vec![];\\n\\n        while let Some(node) = node_opt {\\n            if node\\n                .borrow()\\n                .right\\n                .clone()\\n                .filter(|n| n.borrow().value <= target)\\n                .is_some()\\n            {\\n                node_opt = node.borrow().right.clone();\\n            } else {\\n                stack.push(node.clone());\\n                node_opt = node.borrow().down.clone();\\n            }\\n        }\\n\\n        stack\\n    }\\n\\n    fn search(&self, target: i32) -> bool {\\n        self.find(target)\\n            .last()\\n            .filter(|node| node.borrow().value == target)\\n            .is_some()\\n    }\\n\\n    fn add(&mut self, num: i32) {\\n        let mut left_nodes = self.find(num);\\n\\n        let mut node = new_link(num);\\n        // Safe unwrap because there must be at least one node in the Skiplist.\\n        let left_node = left_nodes.pop().unwrap();\\n        node.borrow_mut().right = left_node.borrow_mut().right.clone();\\n        left_node.borrow_mut().right = Some(node.clone());\\n\\n        while rand::random() {\\n            let left_node = match left_nodes.pop() {\\n                Some(left_node) => left_node,\\n                None => {\\n                    let new_start = new_link(std::i32::MIN);\\n                    new_start.borrow_mut().down = Some(self.start.clone());\\n                    self.start = new_start;\\n                    self.start.clone()\\n                }\\n            };\\n\\n            let new_node = new_link(num);\\n            new_node.borrow_mut().down = Some(node);\\n            new_node.borrow_mut().right = left_node.borrow_mut().right.clone();\\n\\n            left_node.borrow_mut().right = Some(new_node.clone());\\n\\n            node = new_node;\\n        }\\n    }\\n\\n    fn erase(&self, num: i32) -> bool {\\n        let mut num_found = false;\\n        for node in self.find(num - 1) {\\n            let target_node_opt = node.borrow().right.clone();\\n            // println!(\"pre node {:?}\", node.borrow().value);\\n            // println!(\"target_node_opt {:?}\", target_node_opt);\\n            if let Some(target_node) = target_node_opt.filter(|n| n.borrow().value == num) {\\n                num_found = true;\\n                node.borrow_mut().right = target_node.borrow().right.clone();\\n                target_node.borrow_mut().right = None;\\n                target_node.borrow_mut().down = None;\\n            }\\n        }\\n\\n        num_found\\n    }\\n}\\n\\nimpl std::fmt::Debug for Skiplist {\\n    fn fmt(&self, f: &mut std::fmt::Formatter<\\'_>) -> std::fmt::Result {\\n        let mut bottom_row = vec![];\\n        {\\n            let mut cur = self.start.clone();\\n            let mut down = cur.borrow().down.clone();\\n            while let Some(down_rc) = down {\\n                cur = down_rc;\\n                down = cur.borrow().down.clone();\\n            }\\n            bottom_row.push(cur.clone());\\n            let mut right = cur.borrow().right.clone();\\n            while let Some(right_rc) = right {\\n                bottom_row.push(right_rc.clone());\\n\\n                cur = right_rc;\\n                right = cur.borrow().right.clone();\\n            }\\n        }\\n\\n        let mut upper = HashMap::new();\\n        {\\n            let mut worklist = vec![self.start.clone()];\\n            while let Some(node) = worklist.pop() {\\n                if let Some(down) = node.borrow().down.clone() {\\n                    if upper.insert(down.as_ptr(), node.clone()).is_none() {\\n                        worklist.push(down);\\n                    }\\n                }\\n                if let Some(right) = node.borrow().right.clone() {\\n                    if !upper.contains_key(&right.as_ptr()) {\\n                        worklist.push(right);\\n                    }\\n                }\\n            }\\n        }\\n\\n        let mut values = vec![];\\n\\n        let mut cur_row: Vec<_> = bottom_row.iter().map(|node| Some(node)).collect();\\n        while cur_row.iter().any(Option::is_some) {\\n            let mut next_row = vec![];\\n            let mut row_values = vec![];\\n            for node in cur_row.iter() {\\n                match node {\\n                    Some(node) => {\\n                        row_values.push(Some(node.borrow().value));\\n                        next_row.push(upper.get(&node.as_ptr()).clone());\\n                    }\\n                    None => {\\n                        row_values.push(None);\\n                        next_row.push(None)\\n                    }\\n                }\\n            }\\n\\n            values.push(row_values);\\n            std::mem::swap(&mut cur_row, &mut next_row);\\n        }\\n\\n        writeln!(f, \"Skiplist:\")?;\\n        for row in values.iter().rev() {\\n            for value in row {\\n                if let Some(val) = value {\\n                    write!(f, \"{:7}\", val)?;\\n                } else {\\n                    write!(f, \"       \")?;\\n                }\\n            }\\n            writeln!(f)?;\\n        }\\n\\n        Ok(())\\n    }\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n\\n    #[test]\\n    fn test_skiplist_simple() {\\n        let mut skiplist = Skiplist::new();\\n        skiplist.add(5);\\n        skiplist.add(6);\\n        skiplist.add(7);\\n        skiplist.add(7);\\n\\n        assert!(skiplist.search(5));\\n        assert!(skiplist.search(6));\\n        assert!(skiplist.search(7));\\n\\n        println!(\"{:?}\", skiplist);\\n        assert!(skiplist.erase(5));\\n        assert!(!skiplist.search(5));\\n\\n        // 7 was added twice so it needs to be removed twice for both to go away.\\n        assert!(skiplist.erase(7));\\n        assert!(skiplist.search(7));\\n\\n        assert!(skiplist.erase(7));\\n        assert!(!skiplist.search(7));\\n        assert!(!skiplist.erase(7));\\n    }\\n\\n    #[test]\\n    fn test_skiplist_complex() {\\n        let mut skiplist = Skiplist::new();\\n\\n        skiplist.add(1);\\n        skiplist.add(2);\\n        skiplist.add(3);\\n        // 1, 2, 3 are only there. 0 is not there.\\n        assert!(!skiplist.search(0));\\n\\n        skiplist.add(4);\\n        // 1, 2, 3, 4 are there. 1 is there.\\n        assert!(skiplist.search(1));\\n\\n        // 0 is not there.\\n        assert!(!skiplist.erase(0));\\n        // 1 is there, and gets erased.\\n        assert!(skiplist.erase(1));\\n        // 1 is not there anymore.\\n        assert!(!skiplist.search(1));\\n    }\\n\\n    #[test]\\n    fn test_skiplist_v_complex() {\\n        let mut skiplist = Skiplist::new();\\n\\n        skiplist.add(1);\\n        skiplist.add(2);\\n        skiplist.add(3);\\n        skiplist.add(1);\\n        skiplist.add(2);\\n        skiplist.add(3);\\n        skiplist.add(1);\\n        skiplist.add(9);\\n        skiplist.add(988);\\n        skiplist.add(3);\\n        skiplist.add(1);\\n        skiplist.add(2);\\n        skiplist.add(3);\\n        println!(\"{:?}\", skiplist);\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cell::RefCell;\\nuse std::collections::HashMap;\\nuse std::rc::Rc;\\n\\ntype Link = Rc<RefCell<Node>>;\\nfn new_link(value: i32) -> Link {\\n    Rc::new(RefCell::new(Node::new(value)))\\n}\\n\\n#[derive(Debug)]\\nstruct Node {\\n    value: i32,\\n    right: Option<Link>,\\n    down: Option<Link>,\\n}\\n\\nimpl Node {\\n    pub fn new(value: i32) -> Node {\\n        Node {\\n            value,\\n            right: None,\\n            down: None,\\n        }\\n    }\\n}\\n\\nstruct Skiplist {\\n    start: Link,\\n}\\n\\nimpl Skiplist {\\n    fn new() -> Self {\\n        Skiplist {\\n            start: new_link(std::i32::MIN),\\n        }\\n    }\\n\\n    fn find(&self, target: i32) -> Vec<Link> {\\n        let mut node_opt = Some(self.start.clone());\\n        let mut stack = vec![];\\n\\n        while let Some(node) = node_opt {\\n            if node\\n                .borrow()\\n                .right\\n                .clone()\\n                .filter(|n| n.borrow().value <= target)\\n                .is_some()\\n            {\\n                node_opt = node.borrow().right.clone();\\n            } else {\\n                stack.push(node.clone());\\n                node_opt = node.borrow().down.clone();\\n            }\\n        }\\n\\n        stack\\n    }\\n\\n    fn search(&self, target: i32) -> bool {\\n        self.find(target)\\n            .last()\\n            .filter(|node| node.borrow().value == target)\\n            .is_some()\\n    }\\n\\n    fn add(&mut self, num: i32) {\\n        let mut left_nodes = self.find(num);\\n\\n        let mut node = new_link(num);\\n        // Safe unwrap because there must be at least one node in the Skiplist.\\n        let left_node = left_nodes.pop().unwrap();\\n        node.borrow_mut().right = left_node.borrow_mut().right.clone();\\n        left_node.borrow_mut().right = Some(node.clone());\\n\\n        while rand::random() {\\n            let left_node = match left_nodes.pop() {\\n                Some(left_node) => left_node,\\n                None => {\\n                    let new_start = new_link(std::i32::MIN);\\n                    new_start.borrow_mut().down = Some(self.start.clone());\\n                    self.start = new_start;\\n                    self.start.clone()\\n                }\\n            };\\n\\n            let new_node = new_link(num);\\n            new_node.borrow_mut().down = Some(node);\\n            new_node.borrow_mut().right = left_node.borrow_mut().right.clone();\\n\\n            left_node.borrow_mut().right = Some(new_node.clone());\\n\\n            node = new_node;\\n        }\\n    }\\n\\n    fn erase(&self, num: i32) -> bool {\\n        let mut num_found = false;\\n        for node in self.find(num - 1) {\\n            let target_node_opt = node.borrow().right.clone();\\n            // println!(\"pre node {:?}\", node.borrow().value);\\n            // println!(\"target_node_opt {:?}\", target_node_opt);\\n            if let Some(target_node) = target_node_opt.filter(|n| n.borrow().value == num) {\\n                num_found = true;\\n                node.borrow_mut().right = target_node.borrow().right.clone();\\n                target_node.borrow_mut().right = None;\\n                target_node.borrow_mut().down = None;\\n            }\\n        }\\n\\n        num_found\\n    }\\n}\\n\\nimpl std::fmt::Debug for Skiplist {\\n    fn fmt(&self, f: &mut std::fmt::Formatter<\\'_>) -> std::fmt::Result {\\n        let mut bottom_row = vec![];\\n        {\\n            let mut cur = self.start.clone();\\n            let mut down = cur.borrow().down.clone();\\n            while let Some(down_rc) = down {\\n                cur = down_rc;\\n                down = cur.borrow().down.clone();\\n            }\\n            bottom_row.push(cur.clone());\\n            let mut right = cur.borrow().right.clone();\\n            while let Some(right_rc) = right {\\n                bottom_row.push(right_rc.clone());\\n\\n                cur = right_rc;\\n                right = cur.borrow().right.clone();\\n            }\\n        }\\n\\n        let mut upper = HashMap::new();\\n        {\\n            let mut worklist = vec![self.start.clone()];\\n            while let Some(node) = worklist.pop() {\\n                if let Some(down) = node.borrow().down.clone() {\\n                    if upper.insert(down.as_ptr(), node.clone()).is_none() {\\n                        worklist.push(down);\\n                    }\\n                }\\n                if let Some(right) = node.borrow().right.clone() {\\n                    if !upper.contains_key(&right.as_ptr()) {\\n                        worklist.push(right);\\n                    }\\n                }\\n            }\\n        }\\n\\n        let mut values = vec![];\\n\\n        let mut cur_row: Vec<_> = bottom_row.iter().map(|node| Some(node)).collect();\\n        while cur_row.iter().any(Option::is_some) {\\n            let mut next_row = vec![];\\n            let mut row_values = vec![];\\n            for node in cur_row.iter() {\\n                match node {\\n                    Some(node) => {\\n                        row_values.push(Some(node.borrow().value));\\n                        next_row.push(upper.get(&node.as_ptr()).clone());\\n                    }\\n                    None => {\\n                        row_values.push(None);\\n                        next_row.push(None)\\n                    }\\n                }\\n            }\\n\\n            values.push(row_values);\\n            std::mem::swap(&mut cur_row, &mut next_row);\\n        }\\n\\n        writeln!(f, \"Skiplist:\")?;\\n        for row in values.iter().rev() {\\n            for value in row {\\n                if let Some(val) = value {\\n                    write!(f, \"{:7}\", val)?;\\n                } else {\\n                    write!(f, \"       \")?;\\n                }\\n            }\\n            writeln!(f)?;\\n        }\\n\\n        Ok(())\\n    }\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n\\n    #[test]\\n    fn test_skiplist_simple() {\\n        let mut skiplist = Skiplist::new();\\n        skiplist.add(5);\\n        skiplist.add(6);\\n        skiplist.add(7);\\n        skiplist.add(7);\\n\\n        assert!(skiplist.search(5));\\n        assert!(skiplist.search(6));\\n        assert!(skiplist.search(7));\\n\\n        println!(\"{:?}\", skiplist);\\n        assert!(skiplist.erase(5));\\n        assert!(!skiplist.search(5));\\n\\n        // 7 was added twice so it needs to be removed twice for both to go away.\\n        assert!(skiplist.erase(7));\\n        assert!(skiplist.search(7));\\n\\n        assert!(skiplist.erase(7));\\n        assert!(!skiplist.search(7));\\n        assert!(!skiplist.erase(7));\\n    }\\n\\n    #[test]\\n    fn test_skiplist_complex() {\\n        let mut skiplist = Skiplist::new();\\n\\n        skiplist.add(1);\\n        skiplist.add(2);\\n        skiplist.add(3);\\n        // 1, 2, 3 are only there. 0 is not there.\\n        assert!(!skiplist.search(0));\\n\\n        skiplist.add(4);\\n        // 1, 2, 3, 4 are there. 1 is there.\\n        assert!(skiplist.search(1));\\n\\n        // 0 is not there.\\n        assert!(!skiplist.erase(0));\\n        // 1 is there, and gets erased.\\n        assert!(skiplist.erase(1));\\n        // 1 is not there anymore.\\n        assert!(!skiplist.search(1));\\n    }\\n\\n    #[test]\\n    fn test_skiplist_v_complex() {\\n        let mut skiplist = Skiplist::new();\\n\\n        skiplist.add(1);\\n        skiplist.add(2);\\n        skiplist.add(3);\\n        skiplist.add(1);\\n        skiplist.add(2);\\n        skiplist.add(3);\\n        skiplist.add(1);\\n        skiplist.add(9);\\n        skiplist.add(988);\\n        skiplist.add(3);\\n        skiplist.add(1);\\n        skiplist.add(2);\\n        skiplist.add(3);\\n        println!(\"{:?}\", skiplist);\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 434422,
                "title": "skiplist-56ms",
                "content": "### Solution 1: Node has two pointers (right and down)\\n\\nRuntime: 56 ms, faster than 98.87% of C++ online submissions for Design Skiplist.\\nMemory Usage: 28.9 MB, less than 100.00% of C++ online submissions for Design Skiplist.\\n![image](https://assets.leetcode.com/users/leoyang95/image_1574343329.png)\\n\\n**2D list with directions of right and down (multi-row and multi-col lists)**\\n\\n```cpp\\nstruct Node {\\n    int val;\\n    Node* right, * down;\\n\\n    Node(int _val, Node* _right = nullptr, Node* _down = nullptr)\\n        : val(_val), right(_right), down(_down) {}\\n};\\n\\n\\nclass Skiplist {\\npublic:\\n    Skiplist(): m_head(nullptr), m_level(0) {}\\n\\n    bool search(int target) {\\n        Node* node = m_head;\\n        while (node) {\\n\\t\\t\\t// find the node with maximum value less than target or equal to target\\n            while (node->right && node->right->val <= target) node = node->right;\\n            if (node->val == target) break;\\n            node = node->down;\\n        }\\n        return node && node->val == target;\\n    }\\n\\n    void add(int num) {\\n        int level = randomLevel();      // random number of levels for current node\\n        if (level > m_level) {          // insert new level\\n            m_head = new Node(INT_MIN, nullptr, m_head);\\n            ++m_level;\\n        }\\n\\n        Node* node = m_head, * up = nullptr;\\n        while (node) {\\n\\t\\t\\t// find the node with maximum value less than num\\n            while (node->right && node->right->val < num) node = node->right;\\n            if (level >= m_level) {     // insert new node to current level\\n                node->right = new Node(num, node->right);\\n                if (up) up->down = node->right;\\n                up = node->right;\\n            }\\n            node = node->down;\\n            ++level;\\n        }\\n    }\\n\\n    bool erase(int num) {\\n        bool ret = false;\\n        Node* node = m_head, *delt = nullptr;\\n        while (node) {\\n            if (!delt) {\\n\\t\\t\\t    // find the node with maximum value less than num\\n                while (node->right && node->right->val < num) node = node->right;\\n                if (node->right && node->right->val == num) {\\n                    delt = node->right;\\n                    ret = true;\\n                }\\n            }\\n            if (delt) { // erase delt in current level\\n                while (node->right != delt) node = node->right;\\n                Node* temp = node->right;\\n                delt = node->right->down;\\n                node->right = node->right->right;\\n                delete temp;\\n            }\\n            node = node->down;\\n        }\\n        return ret;\\n    }\\n\\nprivate:\\n\\n\\t// p = 1/2\\n    int randomLevel() {\\n        int ret = 1;\\n        while (rand() & 1) ++ret;\\n        return ret;\\n    }\\n\\n    Node* m_head;   // the head of skip list\\n    int m_level;    // the total level of skip list\\n};\\n```\\n\\n---\\n\\n### Solution 2 (Merge nodes in the same column in Solution 1 into one node)\\n\\nRuntime: 60 ms, faster than 97.74% of C++ online submissions for Design Skiplist.\\nMemory Usage: 28.8 MB, less than 100.00% of C++ online submissions for Design Skiplist.\\n\\n![image](https://assets.leetcode.com/users/leoyang95/image_1574343344.png)\\n\\n**1D list with skip information stored in each node.**\\n\\n```cpp\\nstruct Node {\\n    int val;\\n    vector<Node*> forwards;    // pointers to successor nodes, and forwards.size() is the level of the Node\\n    Node(int _val, int _level) : val(_val), forwards(_level, nullptr) {}\\n    int level() { return forwards.size(); }\\n};\\n\\n\\nclass Skiplist {\\npublic:\\n    Skiplist() : m_head(new Node(INT_MIN, 0)) {}\\n\\n    bool search(int target) {\\n        Node* node = m_head;\\n        int level = m_head->forwards.size() - 1;\\n\\n        while (level >= 0) {\\n            // find the node with maximum value less than target or equal to target\\n            while (node->forwards[level] && node->forwards[level]->val <= target) node = node->forwards[level];\\n            if (node->val == target) break;\\n            --level;\\n        }\\n        return node->val == target;\\n    }\\n\\n    void add(int num) {\\n        int level = randomLevel();      // random number of levels for current node\\n        while (level > m_head->level()) {          // insert new level\\n            m_head->forwards.push_back(nullptr);\\n        }\\n\\n        Node* inst = new Node(num, level);  // the node to insert\\n        Node* node = m_head;\\n        level = m_head->level() - 1;\\n        while (level >= 0) {\\n            // find the node with maximum value less than num\\n            while (node->forwards[level] && node->forwards[level]->val < num) node = node->forwards[level];\\n            if (level < inst->level()) {         // insert new node into current level\\n                inst->forwards[level] = node->forwards[level];\\n                node->forwards[level] = inst;\\n            }\\n            --level;\\n        }\\n    }\\n\\n    bool erase(int num) {\\n        Node* node = m_head;\\n        Node* delt = nullptr;   // the node to delete\\n        int level = m_head->level() - 1;\\n        while (level >= 0) {\\n            if (!delt) {    // find the node with maximum value less than num\\n                while (node->forwards[level] && node->forwards[level]->val < num) node = node->forwards[level];\\n                if (node->forwards[level] && node->forwards[level]->val == num) {    // succeed to find the node to delete\\n                    delt = node->forwards[level];       \\n                    node->forwards[level] = delt->forwards[level];\\n                }\\n            }\\n            else {  // erase delt in current level\\n                while (node->forwards[level] != delt) node = node->forwards[level];\\n                node->forwards[level] = delt->forwards[level];\\n            }\\n            --level;\\n        }\\n\\t\\tdelete delt;    // erase delt in the skip list\\n        return delt;\\n    }\\n\\nprivate:\\n    // p = 1/2\\n    int randomLevel() {\\n        int ret = 1;\\n        while (rand() & 1) ++ret;\\n        return ret;\\n    }\\n\\n    // the head of skip list, and the level of skip list is m_head->forwards.size()\\n    Node* m_head;   \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nstruct Node {\\n    int val;\\n    Node* right, * down;\\n\\n    Node(int _val, Node* _right = nullptr, Node* _down = nullptr)\\n        : val(_val), right(_right), down(_down) {}\\n};\\n\\n\\nclass Skiplist {\\npublic:\\n    Skiplist(): m_head(nullptr), m_level(0) {}\\n\\n    bool search(int target) {\\n        Node* node = m_head;\\n        while (node) {\\n\\t\\t\\t// find the node with maximum value less than target or equal to target\\n            while (node->right && node->right->val <= target) node = node->right;\\n            if (node->val == target) break;\\n            node = node->down;\\n        }\\n        return node && node->val == target;\\n    }\\n\\n    void add(int num) {\\n        int level = randomLevel();      // random number of levels for current node\\n        if (level > m_level) {          // insert new level\\n            m_head = new Node(INT_MIN, nullptr, m_head);\\n            ++m_level;\\n        }\\n\\n        Node* node = m_head, * up = nullptr;\\n        while (node) {\\n\\t\\t\\t// find the node with maximum value less than num\\n            while (node->right && node->right->val < num) node = node->right;\\n            if (level >= m_level) {     // insert new node to current level\\n                node->right = new Node(num, node->right);\\n                if (up) up->down = node->right;\\n                up = node->right;\\n            }\\n            node = node->down;\\n            ++level;\\n        }\\n    }\\n\\n    bool erase(int num) {\\n        bool ret = false;\\n        Node* node = m_head, *delt = nullptr;\\n        while (node) {\\n            if (!delt) {\\n\\t\\t\\t    // find the node with maximum value less than num\\n                while (node->right && node->right->val < num) node = node->right;\\n                if (node->right && node->right->val == num) {\\n                    delt = node->right;\\n                    ret = true;\\n                }\\n            }\\n            if (delt) { // erase delt in current level\\n                while (node->right != delt) node = node->right;\\n                Node* temp = node->right;\\n                delt = node->right->down;\\n                node->right = node->right->right;\\n                delete temp;\\n            }\\n            node = node->down;\\n        }\\n        return ret;\\n    }\\n\\nprivate:\\n\\n\\t// p = 1/2\\n    int randomLevel() {\\n        int ret = 1;\\n        while (rand() & 1) ++ret;\\n        return ret;\\n    }\\n\\n    Node* m_head;   // the head of skip list\\n    int m_level;    // the total level of skip list\\n};\\n```\n```cpp\\nstruct Node {\\n    int val;\\n    vector<Node*> forwards;    // pointers to successor nodes, and forwards.size() is the level of the Node\\n    Node(int _val, int _level) : val(_val), forwards(_level, nullptr) {}\\n    int level() { return forwards.size(); }\\n};\\n\\n\\nclass Skiplist {\\npublic:\\n    Skiplist() : m_head(new Node(INT_MIN, 0)) {}\\n\\n    bool search(int target) {\\n        Node* node = m_head;\\n        int level = m_head->forwards.size() - 1;\\n\\n        while (level >= 0) {\\n            // find the node with maximum value less than target or equal to target\\n            while (node->forwards[level] && node->forwards[level]->val <= target) node = node->forwards[level];\\n            if (node->val == target) break;\\n            --level;\\n        }\\n        return node->val == target;\\n    }\\n\\n    void add(int num) {\\n        int level = randomLevel();      // random number of levels for current node\\n        while (level > m_head->level()) {          // insert new level\\n            m_head->forwards.push_back(nullptr);\\n        }\\n\\n        Node* inst = new Node(num, level);  // the node to insert\\n        Node* node = m_head;\\n        level = m_head->level() - 1;\\n        while (level >= 0) {\\n            // find the node with maximum value less than num\\n            while (node->forwards[level] && node->forwards[level]->val < num) node = node->forwards[level];\\n            if (level < inst->level()) {         // insert new node into current level\\n                inst->forwards[level] = node->forwards[level];\\n                node->forwards[level] = inst;\\n            }\\n            --level;\\n        }\\n    }\\n\\n    bool erase(int num) {\\n        Node* node = m_head;\\n        Node* delt = nullptr;   // the node to delete\\n        int level = m_head->level() - 1;\\n        while (level >= 0) {\\n            if (!delt) {    // find the node with maximum value less than num\\n                while (node->forwards[level] && node->forwards[level]->val < num) node = node->forwards[level];\\n                if (node->forwards[level] && node->forwards[level]->val == num) {    // succeed to find the node to delete\\n                    delt = node->forwards[level];       \\n                    node->forwards[level] = delt->forwards[level];\\n                }\\n            }\\n            else {  // erase delt in current level\\n                while (node->forwards[level] != delt) node = node->forwards[level];\\n                node->forwards[level] = delt->forwards[level];\\n            }\\n            --level;\\n        }\\n\\t\\tdelete delt;    // erase delt in the skip list\\n        return delt;\\n    }\\n\\nprivate:\\n    // p = 1/2\\n    int randomLevel() {\\n        int ret = 1;\\n        while (rand() & 1) ++ret;\\n        return ret;\\n    }\\n\\n    // the head of skip list, and the level of skip list is m_head->forwards.size()\\n    Node* m_head;   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681861,
                "title": "1206-design-skiplist-c-mapping-easy-to-understand-74ms-linked-list",
                "content": "# C++ | MAPPING | SKIPLIST | EASY TO UNDERSTAND | <74MS\\n```\\nclass Skiplist {\\npublic:\\n    Skiplist() {}\\n    map<int,int> m;\\n    bool search(int target) {\\n        if(m[target]>0) return true;\\n        return false;\\n    }\\n    \\n    void add(int num) {\\n        m[num]++;\\n    }\\n    \\n    bool erase(int num) {\\n        if(m[num]>0){\\n            m[num]--;\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Skiplist {\\npublic:\\n    Skiplist() {}\\n    map<int,int> m;\\n    bool search(int target) {\\n        if(m[target]>0) return true;\\n        return false;\\n    }\\n    \\n    void add(int num) {\\n        m[num]++;\\n    }\\n    \\n    bool erase(int num) {\\n        if(m[num]>0){\\n            m[num]--;\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670680,
                "title": "java-2-solutions-arraylist-binarysearch-o-n-hashmap-o-1",
                "content": "# Complexity\\n- Time complexity: O(N), since adding/removing in ArrayList may result in copying almost all values one index left or right. That\\'s why it\\'s O(N).\\n\\n# Solution 1 | 19ms | Runtime 63% | Memory 85%\\n```\\nclass Skiplist {\\n\\n    List<Integer> list;\\n    public Skiplist() {\\n        list = new ArrayList<>();\\n    }\\n\\n    public boolean search(int target) {\\n        if (list.size() == 0) return false;\\n        int idx = Collections.binarySearch(list, target);\\n        return idx >= 0;\\n    }\\n\\n    public void add(int num) {\\n        if (list.size() == 0) {\\n            list.add(num);\\n        } else {\\n            int idx = Collections.binarySearch(list, num);\\n            if (idx < 0) idx = -idx - 1;\\n            list.add(idx, num);\\n        }\\n    }\\n\\n    public boolean erase(int num) {\\n        int idx = Collections.binarySearch(list, num);\\n        if (idx < 0) return false;\\n        list.remove(idx);\\n        return true;\\n    }\\n}\\n```\\n\\n# Complexity\\n- Time complexity: O(1) for each method\\n\\n# Solution 2 | 11ms | Runtime 95% | Memory 83%\\n```\\nclass Skiplist {\\n\\n    Map<Integer, Integer> map;\\n    public Skiplist() {\\n        map = new HashMap<>();\\n    }\\n\\n    public boolean search(int target) {\\n        return map.containsKey(target);\\n    }\\n\\n    public void add(int num) {\\n        map.put(num, map.getOrDefault(num, 0) + 1);\\n    }\\n\\n    public boolean erase(int num) {\\n        Integer count = map.get(num);\\n        if (count == null) return false;\\n        if (count == 1) map.remove(num);\\n        else map.put(num, count - 1);\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Skiplist {\\n\\n    List<Integer> list;\\n    public Skiplist() {\\n        list = new ArrayList<>();\\n    }\\n\\n    public boolean search(int target) {\\n        if (list.size() == 0) return false;\\n        int idx = Collections.binarySearch(list, target);\\n        return idx >= 0;\\n    }\\n\\n    public void add(int num) {\\n        if (list.size() == 0) {\\n            list.add(num);\\n        } else {\\n            int idx = Collections.binarySearch(list, num);\\n            if (idx < 0) idx = -idx - 1;\\n            list.add(idx, num);\\n        }\\n    }\\n\\n    public boolean erase(int num) {\\n        int idx = Collections.binarySearch(list, num);\\n        if (idx < 0) return false;\\n        list.remove(idx);\\n        return true;\\n    }\\n}\\n```\n```\\nclass Skiplist {\\n\\n    Map<Integer, Integer> map;\\n    public Skiplist() {\\n        map = new HashMap<>();\\n    }\\n\\n    public boolean search(int target) {\\n        return map.containsKey(target);\\n    }\\n\\n    public void add(int num) {\\n        map.put(num, map.getOrDefault(num, 0) + 1);\\n    }\\n\\n    public boolean erase(int num) {\\n        Integer count = map.get(num);\\n        if (count == null) return false;\\n        if (count == 1) map.remove(num);\\n        else map.put(num, count - 1);\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078533,
                "title": "java-solution-o-log-n-18-ms-beats-100-memory-usage",
                "content": "import java.util.ArrayList;\\nclass Skiplist {\\n    List<Integer> list;\\n    static int counter=1;\\n    public Skiplist() {\\n        list = new ArrayList<>();\\n        \\n    }\\n    \\n    public boolean search(int target) {\\n        int low=0;\\n        int high = list.size()-1;\\n        int mid=0;\\n        boolean res= false;\\n        while(low<=high)\\n        {\\n            mid = (low)+(high-low)/2;\\n            \\n            if(target == list.get(mid))\\n            {\\n                res=true;\\n                break;\\n            }\\n            \\n            else if ( target>list.get(mid))\\n                low=mid+1;\\n            \\n            else\\n                high =mid-1;\\n        }\\n       // System.out.println(counter++ +\":\" +list);\\n        return res;\\n    }\\n    \\n    public void add(int num) {\\n        \\n        int low=0;\\n        int high = list.size()-1;\\n        int mid=0;\\n       \\n        while(low<=high)\\n        {\\n            mid = (low)+(high-low)/2;\\n            \\n           if ( num>list.get(mid))\\n                low=mid+1;\\n            \\n            else\\n                high =mid-1;\\n        }\\n        \\n        \\n            list.add(high+1,num);\\n       // System.out.println(counter++ +\":\" +list);\\n    }\\n    \\n    public boolean erase(int num) {\\n        int low=0;\\n        int high = list.size()-1;\\n        int mid=0;\\n        boolean res= false;\\n        while(low<=high)\\n        {\\n            mid = (low)+(high-low)/2;\\n            \\n            if(num == list.get(mid))\\n            {\\n                list.remove(mid);\\n                res=true;\\n                break;\\n            }\\n            \\n            else if ( num>list.get(mid))\\n                low=mid+1;\\n            \\n            else\\n                high =mid-1;\\n        }\\n        //System.out.println(counter++ +\":\" +list);\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist obj = new Skiplist();\\n * boolean param_1 = obj.search(target);\\n * obj.add(num);\\n * boolean param_3 = obj.erase(num);\\n */",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "import java.util.ArrayList;\\nclass Skiplist {\\n    List<Integer> list;\\n    static int counter=1;\\n    public Skiplist() {\\n        list = new ArrayList<>();\\n        \\n    }\\n    \\n    public boolean search(int target) {\\n        int low=0;\\n        int high = list.size()-1;\\n        int mid=0;\\n        boolean res= false;\\n        while(low<=high)\\n        {\\n            mid = (low)+(high-low)/2;\\n            \\n            if(target == list.get(mid))\\n            {\\n                res=true;\\n                break;\\n            }\\n            \\n            else if ( target>list.get(mid))\\n                low=mid+1;\\n            \\n            else\\n                high =mid-1;\\n        }\\n       // System.out.println(counter++ +\":\" +list);\\n        return res;\\n    }\\n    \\n    public void add(int num) {\\n        \\n        int low=0;\\n        int high = list.size()-1;\\n        int mid=0;\\n       \\n        while(low<=high)\\n        {\\n            mid = (low)+(high-low)/2;\\n            \\n           if ( num>list.get(mid))\\n                low=mid+1;\\n            \\n            else\\n                high =mid-1;\\n        }\\n        \\n        \\n            list.add(high+1,num);\\n       // System.out.println(counter++ +\":\" +list);\\n    }\\n    \\n    public boolean erase(int num) {\\n        int low=0;\\n        int high = list.size()-1;\\n        int mid=0;\\n        boolean res= false;\\n        while(low<=high)\\n        {\\n            mid = (low)+(high-low)/2;\\n            \\n            if(num == list.get(mid))\\n            {\\n                list.remove(mid);\\n                res=true;\\n                break;\\n            }\\n            \\n            else if ( num>list.get(mid))\\n                low=mid+1;\\n            \\n            else\\n                high =mid-1;\\n        }\\n        //System.out.println(counter++ +\":\" +list);\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist obj = new Skiplist();\\n * boolean param_1 = obj.search(target);\\n * obj.add(num);\\n * boolean param_3 = obj.erase(num);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 2586904,
                "title": "my-solutions",
                "content": "**1. Implement the skip list without the help of `std`, maintaining 5 pointers, `up_`, `down_`, `left_`, `right_`, and `head_`**\\n```\\nclass Skiplist {\\n private:\\n  class SkiplistNode\\n  {\\n   public:\\n    SkiplistNode(const int value, SkiplistNode *head)\\n    : value_(value), up_(nullptr), down_(nullptr), left_(nullptr), right_(nullptr), head_(head) {\\n    }\\n\\n    int value() const {\\n      return value_;\\n    }\\n\\n    void set_up(SkiplistNode *up) {\\n      up_ = up;\\n    }\\n\\n    SkiplistNode* up() const {\\n      return up_;\\n    }\\n\\n    void set_down(SkiplistNode *down) {\\n      down_ = down;\\n    }\\n\\n    SkiplistNode* down() const {\\n      return down_;\\n    }\\n\\n    void set_left(SkiplistNode *left) {\\n      left_ = left;\\n    }\\n\\n    SkiplistNode* left() const {\\n      return left_;\\n    }\\n\\n    void set_right(SkiplistNode *right) {\\n      right_ = right;\\n    }\\n\\n    SkiplistNode* right() const {\\n      return right_;\\n    }\\n    \\n    void set_head(SkiplistNode *head) {\\n      head_ = head;\\n    }\\n\\n    SkiplistNode* head() const {\\n      return head_;\\n    }\\n\\n   private:\\n    const int value_;\\n    SkiplistNode *up_;\\n    SkiplistNode *down_;\\n    SkiplistNode *left_;\\n    SkiplistNode *right_;\\n    SkiplistNode * head_;\\n  };\\n    \\npublic:\\n  Skiplist() : gen_(rd_()), left_top_(new SkiplistNode(numeric_limits<int>::min(), nullptr)) {\\n    left_top_->set_head(left_top_);\\n  }\\n\\n  ~Skiplist() {\\n    SkiplistNode *node = left_top_;\\n    SkiplistNode *down = nullptr;\\n    while (node != nullptr) {\\n      down = node->down();\\n      while (node != nullptr) {\\n        SkiplistNode *to_delete = node;\\n        node = node->right();\\n        delete to_delete;\\n      }\\n      node = down;\\n    }\\n  }\\n\\n  bool search(const int target) {\\n    return search_node(target)->value() == target;\\n  }\\n\\n  void add(const int num) {\\n    SkiplistNode *node = search_node(num);\\n    SkiplistNode *node_num = new SkiplistNode(num, node->head());\\n    node_num->set_right(node->right());\\n    if (node->right() != nullptr) {\\n      node->right()->set_left(node_num);\\n    }\\n    node->set_right(node_num);\\n    node_num->set_left(node);\\n    while (is_flip_coin_head()) {\\n      create_up_head_node_if_not_existing(node);\\n      node = find_up_node(node);\\n\\n      SkiplistNode *up_node_num = new SkiplistNode(num, node->head());\\n      // set the left-right relationship\\n      up_node_num->set_right(node->right());\\n      if (node->right() != nullptr) {\\n          node->right()->set_left(up_node_num);\\n      }\\n      node->set_right(up_node_num);\\n      up_node_num->set_left(node);\\n      // set the up-down relationship\\n      up_node_num->set_down(node_num);\\n      node_num->set_up(up_node_num);\\n      node_num = up_node_num;\\n    }\\n  }\\n\\n  bool erase(const int num) {\\n    SkiplistNode *node = search_node(num);\\n    if (node->value() != num) {\\n      return false;\\n    }\\n\\n    while (node != nullptr) {\\n      node->left()->set_right(node->right());\\n      if (node->right() != nullptr) {\\n        node->right()->set_left(node->left());\\n      }\\n      SkiplistNode *to_delete = node;\\n      node = node->up();\\n      delete to_delete;\\n    }\\n    return true;\\n  }\\n\\nprivate:\\n  SkiplistNode* search_node(const int target) {\\n    SkiplistNode *node = left_top_;\\n    SkiplistNode *prev = nullptr;\\n    while (node != nullptr && node->value() <= target) {\\n      prev = node;\\n      if (node->value() == target) {\\n        node = node->down();\\n      } else {\\n        node = node->right();\\n        if (node == nullptr || node->value() > target) {\\n          node = prev;\\n          node = node->down();\\n        }\\n      }\\n    }\\n    return prev;\\n  }\\n\\n  bool is_flip_coin_head() {\\n    uniform_int_distribution<> distrib(0, 1);\\n    return distrib(gen_) == 1;\\n  }\\n\\n  void create_up_head_node_if_not_existing(SkiplistNode *node) {\\n    SkiplistNode *head = node->head();\\n    if (head->up() == nullptr) {\\n      SkiplistNode *up = new SkiplistNode(numeric_limits<int>::min(), nullptr);\\n      up->set_head(up);\\n      head->set_up(up);\\n      up->set_down(head);\\n      left_top_ = up;\\n    }\\n  }\\n\\n  SkiplistNode* find_up_node(SkiplistNode *node) {\\n    while (true) {\\n      if (node->up() != nullptr) {\\n        return node->up();\\n      }\\n      node = node->left();\\n    }\\n  }\\n\\n  random_device rd_;\\n  mt19937 gen_;\\n  SkiplistNode *left_top_;\\n};\\n```\\n**2. Implement the skip list with the help of `std`, maintaining 2 `\\'pointers\\'`, `up_` and `down_`**\\n```\\nclass Skiplist {\\n private:\\n  class SkiplistNode\\n  {\\n   public:\\n    SkiplistNode(const int value,\\n                 const list<SkiplistNode>::iterator &up,\\n                 const list<SkiplistNode>::iterator &down)\\n      : value_(value), up_(up), down_(down) {\\n    }\\n\\n    int value() const {\\n      return value_;\\n    }\\n\\n    void set_up(const list<SkiplistNode>::iterator &up) {\\n      up_ = up;\\n    }\\n\\n    const list<SkiplistNode>::iterator& up() const {\\n      return up_;\\n    }\\n\\n    void set_down(const list<SkiplistNode>::iterator &down) {\\n      down_ = down;\\n    }\\n\\n    const list<SkiplistNode>::iterator& down() const {\\n      return down_;\\n    }\\n\\n   private:\\n    const int value_;\\n    /**\\n     * if `up_` is equal to the first iterator (`begin()`) of the list in which it is,\\n     * which means the skip list node has not `up_` node.\\n     */\\n    list<SkiplistNode>::iterator up_;\\n    /**\\n     * if `down_` is equal to the first iterator (`begin()`) of the list in which it is,\\n     * which means the skip list node has not `down_` node.\\n     */\\n    list<SkiplistNode>::iterator down_;\\n  };\\n    \\npublic:\\n  Skiplist() : gen_(rd_())\\n             , nodes_{list<SkiplistNode>{}} {\\n    nodes_.front().emplace_back(numeric_limits<int>::min(), nodes_.front().end(), nodes_.front().end());\\n    nodes_.front().front().set_up(nodes_.front().begin());\\n    nodes_.front().front().set_down(nodes_.front().begin());\\n  }\\n\\n  bool search(const int target) {\\n    return search_node(target)->value() == target;\\n  }\\n\\n  void add(const int num) {\\n    list<SkiplistNode>::iterator node = search_node(num);\\n    list<SkiplistNode>::iterator node_num = nodes_.front().insert(next(node),\\n                                                                  SkiplistNode{num,\\n                                                                               nodes_[0].begin(),\\n                                                                               nodes_[0].begin()});\\n    \\n    int layer = 0;\\n    while (is_flip_coin_head()) {\\n      create_up_head_node_if_not_existing(layer);\\n      node = find_up_node(layer, node);\\n      ++layer;\\n\\n      list<SkiplistNode>::iterator up_node_num = nodes_[layer].insert(next(node),\\n                                                                      SkiplistNode{num,\\n                                                                                   nodes_[layer].begin(),\\n                                                                                   nodes_[layer].begin()});\\n      // set the up-down relationship\\n      up_node_num->set_down(node_num);\\n      node_num->set_up(up_node_num);\\n      node_num = move(up_node_num);\\n    }\\n  }\\n\\n  bool erase(const int num) {\\n    list<SkiplistNode>::iterator node = search_node(num);\\n    if (node->value() != num) {\\n      return false;\\n    }\\n\\n    for (int layer = 0; layer == 0 || node != nodes_[layer - 1].begin(); ++layer) {\\n      list<SkiplistNode>::iterator to_delete = node;\\n      node = node->up();\\n      nodes_[layer].erase(to_delete);\\n    }\\n    return true;\\n  }\\n\\nprivate:\\n  list<SkiplistNode>::iterator search_node(const int target) {\\n    int layer = static_cast<int>(nodes_.size()) - 1;\\n    list<SkiplistNode>::iterator node = nodes_.back().begin();\\n    list<SkiplistNode>::iterator prev;\\n    while (layer > -1 && node != nodes_[layer].end() && node->value() <= target) {\\n      prev = node;\\n      if (node->value() == target) {\\n        --layer;\\n        node = node->down();\\n      } else {\\n        ++node;\\n        if (node == nodes_[layer].end() || node->value() > target) {\\n          --layer;\\n          node = prev;\\n          node = node->down();\\n        }\\n      }\\n    }\\n    return prev;\\n  }\\n\\n  bool is_flip_coin_head() {\\n    uniform_int_distribution<> distrib(0, 1);\\n    return distrib(gen_) == 1;\\n  }\\n\\n  void create_up_head_node_if_not_existing(const int layer) {\\n    if (nodes_.size() == layer + 1) {\\n      nodes_.emplace_back(list<SkiplistNode>{});\\n      nodes_.back().emplace_back(numeric_limits<int>::min(), nodes_.back().end(), nodes_.back().end());\\n      nodes_.back().front().set_up(nodes_.back().begin());\\n      nodes_.back().front().set_down(nodes_[layer].begin());\\n      nodes_[layer].front().set_up(nodes_.back().begin());\\n    }\\n  }\\n\\n  list<SkiplistNode>::iterator find_up_node(const int layer, list<SkiplistNode>::iterator node) {\\n    while (true) {\\n      if (node->up() != nodes_[layer].begin()) {\\n        return node->up();\\n      }\\n      --node;\\n    }\\n  }\\n\\n  random_device rd_;\\n  mt19937 gen_;\\n  vector<list<SkiplistNode>> nodes_;\\n};\\n```\\n**3. Implement the skip list without the help of `std`, maintaining 2 pointers, `down_` and `right_`**\\n```\\nclass Skiplist {\\n private:\\n  class SkiplistNode {\\n   public:\\n    SkiplistNode(const int value) : SkiplistNode(value, nullptr, nullptr) {\\n    }\\n\\n    SkiplistNode(const int value,\\n                 SkiplistNode * const right,\\n                 SkiplistNode * const down) : value_(value), right_(right), down_(down) {\\n    }\\n\\n    ~SkiplistNode() {\\n      delete right_;\\n    }\\n    \\n    int value() const {\\n      return value_;\\n    }\\n\\n    void set_right(SkiplistNode *right) {\\n      right_ = right;\\n    }\\n\\n    SkiplistNode* right() const {\\n      return right_;\\n    }\\n\\n    SkiplistNode* down() const {\\n      return down_;\\n    }\\n\\n   private:\\n    const int value_;\\n    SkiplistNode *right_;\\n    SkiplistNode * const down_;\\n  };\\n\\n public:\\n  Skiplist() : gen_(rd_()), left_top_(new SkiplistNode(numeric_limits<int>::min())) {\\n  }\\n  \\n  ~Skiplist() {\\n    for (SkiplistNode *node = left_top_; node != nullptr; ) {\\n      SkiplistNode *below_node = node->down();\\n      delete node;\\n      node = below_node;\\n    }\\n  }\\n  \\n  bool search(const int target) {\\n    SkiplistNode *node = left_top_;\\n    while (node != nullptr) {\\n      while (node->right() != nullptr && node->right()->value() < target) {\\n        node = node->right();\\n      }\\n      if (node->right() != nullptr && node->right()->value() == target) {\\n        return true;\\n      }\\n      node = node->down();\\n    }\\n    return false;\\n  }\\n  \\n  void add(const int num) {\\n    stack<SkiplistNode *> nodes_from_top_to_bottom;\\n    SkiplistNode *node = left_top_;\\n    while (node != nullptr) {\\n      while (node->right() != nullptr && node->right()->value() < num) {\\n        node = node->right();\\n      }\\n      nodes_from_top_to_bottom.emplace(node);\\n      node = node->down();\\n    }\\n    \\n    SkiplistNode *added = nullptr;\\n    for (bool coin_head = true; coin_head; coin_head = is_flip_coin_head()) {\\n      SkiplistNode *left = nullptr;\\n      if (nodes_from_top_to_bottom.empty()) {\\n        left_top_ = new SkiplistNode(numeric_limits<int>::min(), nullptr, left_top_);\\n        left = left_top_;\\n      } else {\\n        left = nodes_from_top_to_bottom.top();\\n        nodes_from_top_to_bottom.pop();\\n      }\\n      added = new SkiplistNode(num, left->right(), added);\\n      left->set_right(added);\\n    }\\n  }\\n  \\n  bool erase(const int num) {\\n    bool ret = false;\\n    SkiplistNode *node = left_top_;\\n    while (node != nullptr) {\\n      while (node->right() != nullptr && node->right()->value() < num) {\\n        node = node->right();\\n      }\\n      if (node->right() != nullptr && node->right()->value() == num) {\\n        SkiplistNode *to_delete = node->right();\\n        node->set_right(node->right()->right());\\n        to_delete->set_right(nullptr);\\n        delete to_delete;\\n        ret = true;\\n      }\\n      node = node->down();\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  bool is_flip_coin_head() {\\n    uniform_int_distribution<> distrib(0, 1);\\n    return distrib(gen_) == 1;\\n  }\\n\\n  random_device rd_;\\n  mt19937 gen_;\\n  SkiplistNode *left_top_;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Skiplist {\\n private:\\n  class SkiplistNode\\n  {\\n   public:\\n    SkiplistNode(const int value, SkiplistNode *head)\\n    : value_(value), up_(nullptr), down_(nullptr), left_(nullptr), right_(nullptr), head_(head) {\\n    }\\n\\n    int value() const {\\n      return value_;\\n    }\\n\\n    void set_up(SkiplistNode *up) {\\n      up_ = up;\\n    }\\n\\n    SkiplistNode* up() const {\\n      return up_;\\n    }\\n\\n    void set_down(SkiplistNode *down) {\\n      down_ = down;\\n    }\\n\\n    SkiplistNode* down() const {\\n      return down_;\\n    }\\n\\n    void set_left(SkiplistNode *left) {\\n      left_ = left;\\n    }\\n\\n    SkiplistNode* left() const {\\n      return left_;\\n    }\\n\\n    void set_right(SkiplistNode *right) {\\n      right_ = right;\\n    }\\n\\n    SkiplistNode* right() const {\\n      return right_;\\n    }\\n    \\n    void set_head(SkiplistNode *head) {\\n      head_ = head;\\n    }\\n\\n    SkiplistNode* head() const {\\n      return head_;\\n    }\\n\\n   private:\\n    const int value_;\\n    SkiplistNode *up_;\\n    SkiplistNode *down_;\\n    SkiplistNode *left_;\\n    SkiplistNode *right_;\\n    SkiplistNode * head_;\\n  };\\n    \\npublic:\\n  Skiplist() : gen_(rd_()), left_top_(new SkiplistNode(numeric_limits<int>::min(), nullptr)) {\\n    left_top_->set_head(left_top_);\\n  }\\n\\n  ~Skiplist() {\\n    SkiplistNode *node = left_top_;\\n    SkiplistNode *down = nullptr;\\n    while (node != nullptr) {\\n      down = node->down();\\n      while (node != nullptr) {\\n        SkiplistNode *to_delete = node;\\n        node = node->right();\\n        delete to_delete;\\n      }\\n      node = down;\\n    }\\n  }\\n\\n  bool search(const int target) {\\n    return search_node(target)->value() == target;\\n  }\\n\\n  void add(const int num) {\\n    SkiplistNode *node = search_node(num);\\n    SkiplistNode *node_num = new SkiplistNode(num, node->head());\\n    node_num->set_right(node->right());\\n    if (node->right() != nullptr) {\\n      node->right()->set_left(node_num);\\n    }\\n    node->set_right(node_num);\\n    node_num->set_left(node);\\n    while (is_flip_coin_head()) {\\n      create_up_head_node_if_not_existing(node);\\n      node = find_up_node(node);\\n\\n      SkiplistNode *up_node_num = new SkiplistNode(num, node->head());\\n      // set the left-right relationship\\n      up_node_num->set_right(node->right());\\n      if (node->right() != nullptr) {\\n          node->right()->set_left(up_node_num);\\n      }\\n      node->set_right(up_node_num);\\n      up_node_num->set_left(node);\\n      // set the up-down relationship\\n      up_node_num->set_down(node_num);\\n      node_num->set_up(up_node_num);\\n      node_num = up_node_num;\\n    }\\n  }\\n\\n  bool erase(const int num) {\\n    SkiplistNode *node = search_node(num);\\n    if (node->value() != num) {\\n      return false;\\n    }\\n\\n    while (node != nullptr) {\\n      node->left()->set_right(node->right());\\n      if (node->right() != nullptr) {\\n        node->right()->set_left(node->left());\\n      }\\n      SkiplistNode *to_delete = node;\\n      node = node->up();\\n      delete to_delete;\\n    }\\n    return true;\\n  }\\n\\nprivate:\\n  SkiplistNode* search_node(const int target) {\\n    SkiplistNode *node = left_top_;\\n    SkiplistNode *prev = nullptr;\\n    while (node != nullptr && node->value() <= target) {\\n      prev = node;\\n      if (node->value() == target) {\\n        node = node->down();\\n      } else {\\n        node = node->right();\\n        if (node == nullptr || node->value() > target) {\\n          node = prev;\\n          node = node->down();\\n        }\\n      }\\n    }\\n    return prev;\\n  }\\n\\n  bool is_flip_coin_head() {\\n    uniform_int_distribution<> distrib(0, 1);\\n    return distrib(gen_) == 1;\\n  }\\n\\n  void create_up_head_node_if_not_existing(SkiplistNode *node) {\\n    SkiplistNode *head = node->head();\\n    if (head->up() == nullptr) {\\n      SkiplistNode *up = new SkiplistNode(numeric_limits<int>::min(), nullptr);\\n      up->set_head(up);\\n      head->set_up(up);\\n      up->set_down(head);\\n      left_top_ = up;\\n    }\\n  }\\n\\n  SkiplistNode* find_up_node(SkiplistNode *node) {\\n    while (true) {\\n      if (node->up() != nullptr) {\\n        return node->up();\\n      }\\n      node = node->left();\\n    }\\n  }\\n\\n  random_device rd_;\\n  mt19937 gen_;\\n  SkiplistNode *left_top_;\\n};\\n```\n```\\nclass Skiplist {\\n private:\\n  class SkiplistNode\\n  {\\n   public:\\n    SkiplistNode(const int value,\\n                 const list<SkiplistNode>::iterator &up,\\n                 const list<SkiplistNode>::iterator &down)\\n      : value_(value), up_(up), down_(down) {\\n    }\\n\\n    int value() const {\\n      return value_;\\n    }\\n\\n    void set_up(const list<SkiplistNode>::iterator &up) {\\n      up_ = up;\\n    }\\n\\n    const list<SkiplistNode>::iterator& up() const {\\n      return up_;\\n    }\\n\\n    void set_down(const list<SkiplistNode>::iterator &down) {\\n      down_ = down;\\n    }\\n\\n    const list<SkiplistNode>::iterator& down() const {\\n      return down_;\\n    }\\n\\n   private:\\n    const int value_;\\n    /**\\n     * if `up_` is equal to the first iterator (`begin()`) of the list in which it is,\\n     * which means the skip list node has not `up_` node.\\n     */\\n    list<SkiplistNode>::iterator up_;\\n    /**\\n     * if `down_` is equal to the first iterator (`begin()`) of the list in which it is,\\n     * which means the skip list node has not `down_` node.\\n     */\\n    list<SkiplistNode>::iterator down_;\\n  };\\n    \\npublic:\\n  Skiplist() : gen_(rd_())\\n             , nodes_{list<SkiplistNode>{}} {\\n    nodes_.front().emplace_back(numeric_limits<int>::min(), nodes_.front().end(), nodes_.front().end());\\n    nodes_.front().front().set_up(nodes_.front().begin());\\n    nodes_.front().front().set_down(nodes_.front().begin());\\n  }\\n\\n  bool search(const int target) {\\n    return search_node(target)->value() == target;\\n  }\\n\\n  void add(const int num) {\\n    list<SkiplistNode>::iterator node = search_node(num);\\n    list<SkiplistNode>::iterator node_num = nodes_.front().insert(next(node),\\n                                                                  SkiplistNode{num,\\n                                                                               nodes_[0].begin(),\\n                                                                               nodes_[0].begin()});\\n    \\n    int layer = 0;\\n    while (is_flip_coin_head()) {\\n      create_up_head_node_if_not_existing(layer);\\n      node = find_up_node(layer, node);\\n      ++layer;\\n\\n      list<SkiplistNode>::iterator up_node_num = nodes_[layer].insert(next(node),\\n                                                                      SkiplistNode{num,\\n                                                                                   nodes_[layer].begin(),\\n                                                                                   nodes_[layer].begin()});\\n      // set the up-down relationship\\n      up_node_num->set_down(node_num);\\n      node_num->set_up(up_node_num);\\n      node_num = move(up_node_num);\\n    }\\n  }\\n\\n  bool erase(const int num) {\\n    list<SkiplistNode>::iterator node = search_node(num);\\n    if (node->value() != num) {\\n      return false;\\n    }\\n\\n    for (int layer = 0; layer == 0 || node != nodes_[layer - 1].begin(); ++layer) {\\n      list<SkiplistNode>::iterator to_delete = node;\\n      node = node->up();\\n      nodes_[layer].erase(to_delete);\\n    }\\n    return true;\\n  }\\n\\nprivate:\\n  list<SkiplistNode>::iterator search_node(const int target) {\\n    int layer = static_cast<int>(nodes_.size()) - 1;\\n    list<SkiplistNode>::iterator node = nodes_.back().begin();\\n    list<SkiplistNode>::iterator prev;\\n    while (layer > -1 && node != nodes_[layer].end() && node->value() <= target) {\\n      prev = node;\\n      if (node->value() == target) {\\n        --layer;\\n        node = node->down();\\n      } else {\\n        ++node;\\n        if (node == nodes_[layer].end() || node->value() > target) {\\n          --layer;\\n          node = prev;\\n          node = node->down();\\n        }\\n      }\\n    }\\n    return prev;\\n  }\\n\\n  bool is_flip_coin_head() {\\n    uniform_int_distribution<> distrib(0, 1);\\n    return distrib(gen_) == 1;\\n  }\\n\\n  void create_up_head_node_if_not_existing(const int layer) {\\n    if (nodes_.size() == layer + 1) {\\n      nodes_.emplace_back(list<SkiplistNode>{});\\n      nodes_.back().emplace_back(numeric_limits<int>::min(), nodes_.back().end(), nodes_.back().end());\\n      nodes_.back().front().set_up(nodes_.back().begin());\\n      nodes_.back().front().set_down(nodes_[layer].begin());\\n      nodes_[layer].front().set_up(nodes_.back().begin());\\n    }\\n  }\\n\\n  list<SkiplistNode>::iterator find_up_node(const int layer, list<SkiplistNode>::iterator node) {\\n    while (true) {\\n      if (node->up() != nodes_[layer].begin()) {\\n        return node->up();\\n      }\\n      --node;\\n    }\\n  }\\n\\n  random_device rd_;\\n  mt19937 gen_;\\n  vector<list<SkiplistNode>> nodes_;\\n};\\n```\n```\\nclass Skiplist {\\n private:\\n  class SkiplistNode {\\n   public:\\n    SkiplistNode(const int value) : SkiplistNode(value, nullptr, nullptr) {\\n    }\\n\\n    SkiplistNode(const int value,\\n                 SkiplistNode * const right,\\n                 SkiplistNode * const down) : value_(value), right_(right), down_(down) {\\n    }\\n\\n    ~SkiplistNode() {\\n      delete right_;\\n    }\\n    \\n    int value() const {\\n      return value_;\\n    }\\n\\n    void set_right(SkiplistNode *right) {\\n      right_ = right;\\n    }\\n\\n    SkiplistNode* right() const {\\n      return right_;\\n    }\\n\\n    SkiplistNode* down() const {\\n      return down_;\\n    }\\n\\n   private:\\n    const int value_;\\n    SkiplistNode *right_;\\n    SkiplistNode * const down_;\\n  };\\n\\n public:\\n  Skiplist() : gen_(rd_()), left_top_(new SkiplistNode(numeric_limits<int>::min())) {\\n  }\\n  \\n  ~Skiplist() {\\n    for (SkiplistNode *node = left_top_; node != nullptr; ) {\\n      SkiplistNode *below_node = node->down();\\n      delete node;\\n      node = below_node;\\n    }\\n  }\\n  \\n  bool search(const int target) {\\n    SkiplistNode *node = left_top_;\\n    while (node != nullptr) {\\n      while (node->right() != nullptr && node->right()->value() < target) {\\n        node = node->right();\\n      }\\n      if (node->right() != nullptr && node->right()->value() == target) {\\n        return true;\\n      }\\n      node = node->down();\\n    }\\n    return false;\\n  }\\n  \\n  void add(const int num) {\\n    stack<SkiplistNode *> nodes_from_top_to_bottom;\\n    SkiplistNode *node = left_top_;\\n    while (node != nullptr) {\\n      while (node->right() != nullptr && node->right()->value() < num) {\\n        node = node->right();\\n      }\\n      nodes_from_top_to_bottom.emplace(node);\\n      node = node->down();\\n    }\\n    \\n    SkiplistNode *added = nullptr;\\n    for (bool coin_head = true; coin_head; coin_head = is_flip_coin_head()) {\\n      SkiplistNode *left = nullptr;\\n      if (nodes_from_top_to_bottom.empty()) {\\n        left_top_ = new SkiplistNode(numeric_limits<int>::min(), nullptr, left_top_);\\n        left = left_top_;\\n      } else {\\n        left = nodes_from_top_to_bottom.top();\\n        nodes_from_top_to_bottom.pop();\\n      }\\n      added = new SkiplistNode(num, left->right(), added);\\n      left->set_right(added);\\n    }\\n  }\\n  \\n  bool erase(const int num) {\\n    bool ret = false;\\n    SkiplistNode *node = left_top_;\\n    while (node != nullptr) {\\n      while (node->right() != nullptr && node->right()->value() < num) {\\n        node = node->right();\\n      }\\n      if (node->right() != nullptr && node->right()->value() == num) {\\n        SkiplistNode *to_delete = node->right();\\n        node->set_right(node->right()->right());\\n        to_delete->set_right(nullptr);\\n        delete to_delete;\\n        ret = true;\\n      }\\n      node = node->down();\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  bool is_flip_coin_head() {\\n    uniform_int_distribution<> distrib(0, 1);\\n    return distrib(gen_) == 1;\\n  }\\n\\n  random_device rd_;\\n  mt19937 gen_;\\n  SkiplistNode *left_top_;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2370377,
                "title": "python-simple-soln",
                "content": "\\n\\n```\\nclass Node:\\n    def __init__(self, val=-1, right=None, down=None):\\n        self.val=val\\n        self.right=right\\n        self.down=down\\n\\nclass Skiplist:\\n\\n    def __init__(self):\\n        self.head=Node()\\n\\n    def search(self, target: int) -> bool:\\n        node=self.head\\n        while node:\\n            while node.right and node.right.val<target:\\n                node=node.right\\n            if node.right and node.right.val==target:\\n                return True\\n            node=node.down\\n        return False\\n\\n    def add(self, num: int) -> None:\\n        nodes=[]\\n        node=self.head\\n        while node:\\n            while node.right and node.right.val<num:\\n                node=node.right\\n            nodes.append(node)\\n            node=node.down\\n        insert=True\\n        down=None\\n        while insert and nodes:\\n            node=nodes.pop()\\n            node.right=Node(num,node.right,down)\\n            down=node.right\\n            insert=(random.getrandbits(1)==0)\\n        if insert:\\n            self.head=Node(-1,None,self.head)\\n\\n    def erase(self, num: int) -> bool:\\n        node=self.head\\n        found=False\\n        while node:\\n            while node.right and node.right.val<num:\\n                node=node.right\\n            if node.right and node.right.val==num:\\n                node.right=node.right.right\\n                found=True\\n            node=node.down\\n        return found\\n\\n",
                "solutionTags": [],
                "code": "\\n\\n```\\nclass Node:\\n    def __init__(self, val=-1, right=None, down=None):\\n        self.val=val\\n        self.right=right\\n        self.down=down\\n\\nclass Skiplist:\\n\\n    def __init__(self):\\n        self.head=Node()\\n\\n    def search(self, target: int) -> bool:\\n        node=self.head\\n        while node:\\n            while node.right and node.right.val<target:\\n                node=node.right\\n            if node.right and node.right.val==target:\\n                return True\\n            node=node.down\\n        return False\\n\\n    def add(self, num: int) -> None:\\n        nodes=[]\\n        node=self.head\\n        while node:\\n            while node.right and node.right.val<num:\\n                node=node.right\\n            nodes.append(node)\\n            node=node.down\\n        insert=True\\n        down=None\\n        while insert and nodes:\\n            node=nodes.pop()\\n            node.right=Node(num,node.right,down)\\n            down=node.right\\n            insert=(random.getrandbits(1)==0)\\n        if insert:\\n            self.head=Node(-1,None,self.head)\\n\\n    def erase(self, num: int) -> bool:\\n        node=self.head\\n        found=False\\n        while node:\\n            while node.right and node.right.val<num:\\n                node=node.right\\n            if node.right and node.right.val==num:\\n                node.right=node.right.right\\n                found=True\\n            node=node.down\\n        return found\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2330428,
                "title": "quite-simple-java-solution",
                "content": "This is my quite simple solution on Java\\n```\\nclass Skiplist {\\n\\n        public static final int MAX_LEVEL = 4;\\n\\n        private final int levels;\\n\\n        private SkipListEntry head;\\n\\n        private SkipListEntry tail;\\n\\n        public Skiplist() {\\n            this(MAX_LEVEL);\\n        }\\n\\n        public Skiplist(int levels) {\\n            this.levels = levels;\\n\\n            //init new SkipList with defined level\\n            //Firstly, create the root level (level = 0) entry for left (min) and right (max)\\n            // and linked it\\n            //          LEFT <------------------------------------------------> RIGHT\\n            SkipListEntry left = new SkipListEntry(Integer.MIN_VALUE, Integer.MIN_VALUE);\\n            SkipListEntry right = new SkipListEntry(Integer.MAX_VALUE, Integer.MAX_VALUE);\\n            left.right = right;\\n            right.left = left;\\n\\n            // After, we can define left and right as the head and tail nodes\\n            //   HEAD = LEFT <------------------------------------------------> RIGHT = TAIL\\n            this.head = left;\\n            this.tail = right;\\n\\n            // Next, we can define left and right nodes for other levels and linked it\\n            // 0 HEAD = LEFT <------------------------------------------------> RIGHT = TAIL\\n            //            ^                                                  ^\\n            //            |                                                  |\\n            //            v                                                  v\\n            // 1 HEAD = LEFT <------------------------------------------------> RIGHT = TAIL\\n            //            ^                                                  ^\\n            //            |                                                  |\\n            //            v                                                  v\\n            // 2 HEAD = LEFT <------------------------------------------------> RIGHT = TAIL\\n            //            ^                                                  ^\\n            //            |                                                  |\\n            //            v                                                  v\\n            // 3 HEAD = LEFT <------------------------------------------------> RIGHT = TAIL\\n            //            ^                                                  ^\\n            //            |                                                  |\\n            //            v                                                  v\\n            // N HEAD = LEFT <------------------------------------------------> RIGHT = TAIL\\n            for (int i = 1; i < this.levels; i++) {\\n                left.down = new SkipListEntry(\\n                        Integer.MIN_VALUE,\\n                        Integer.MIN_VALUE,\\n                        null,\\n                        null,\\n                        left,\\n                        null\\n                );\\n                left = left.down;\\n\\n                right.down = new SkipListEntry(\\n                        Integer.MAX_VALUE,\\n                        Integer.MAX_VALUE,\\n                        null,\\n                        null,\\n                        right,\\n                        null\\n                );\\n                right = right.down;\\n\\n                left.right = right;\\n                right.left = left;\\n            }\\n        }\\n\\n        public boolean search(int target) {\\n            return this.find(target).key == target;\\n        }\\n\\n        public void add(int num) {\\n            // We have to always start from head\\n            SkipListEntry current = this.head;\\n\\n            // For the searching newNode we have to:\\n            // 1 - start from the head\\n            // 2 - go down the bottom level\\n            while (current.hasDown()) {\\n                current = current.down;\\n            }\\n\\n            // 3 - try to find newNode\\n            while (current.hasRight() && num > current.right.key) {\\n                current = current.right;\\n            }\\n\\n            // 4 - if we found newNode on the step 3, we have to do nothing (return;)\\n            if (num == current.key) {\\n                return;\\n            }\\n\\n            // 5 - otherwise, we have to a put new newNode on the right\\n            SkipListEntry newNode = new SkipListEntry(num, num, current, current.right);\\n            current.right.left = newNode;\\n            current.right = newNode;\\n\\n            // 6 - have to go up one level\\n            // 7 - flip the coin\\n            // 8 - if on the step 8 true - repeat step 5\\n            for (int level = this.levels - 2; level >= 0; level--) {\\n                if (!this.coinFlip(level)) {\\n                    return;\\n                }\\n\\n                // go up one level and find left node for new level\\n                while (!current.hasUp() && current.hasLeft()) {\\n                    current = current.left;\\n                }\\n                current = current.up;\\n\\n                newNode.up = new SkipListEntry(\\n                        num,\\n                        num,\\n                        current,\\n                        current.right,\\n                        null,\\n                        newNode\\n                );\\n                newNode = newNode.up;\\n\\n                current.right.left = newNode;\\n                current.right = newNode;\\n            }\\n        }\\n\\n        public boolean erase(int num) {\\n            SkipListEntry entry = this.find(num);\\n            if (entry.key != num) {\\n                return false;\\n            }\\n\\n            entry.left.right = entry.right;\\n            entry.right.left = entry.left;\\n\\n        while ((entry = entry.up) != null) {\\n            entry.left.right = entry.right;\\n            entry.right.left = entry.left;\\n        }\\n\\n            return true;\\n        }\\n\\n        private SkipListEntry find(int key) {\\n            // We have to always start from head\\n            SkipListEntry current = this.head;\\n\\n            // while node has right or down we can go down a level or right\\n            // 1 - we have to go right and try to find element\\n            // 2 - if element is not presented at this level, we have to go down a level\\n            // and repeat step 1\\n            // 3 - if we found element we have to go down to the bottom\\n            // if we found element we have to return it, otherwise - return last visited\\n            while (current != null && current.hasRight()) {\\n                while (current.hasRight() && key > current.right.key) {\\n                    current = current.right;\\n                }\\n\\n                if (key == current.right.key) {\\n                    current = current.right;\\n                    while (current.hasDown()) {\\n                        current = current.down;\\n                    }\\n\\n                    return current;\\n                }\\n\\n                current = current.down;\\n            }\\n\\n            return this.head;\\n        }\\n\\n        private boolean coinFlip(int level) {\\n            return ThreadLocalRandom.current().nextInt(this.levels - level) == 0;\\n        }\\n\\n        public static class SkipListEntry {\\n\\n            private final int key;\\n\\n            private final int value;\\n\\n            private SkipListEntry up;\\n\\n            private SkipListEntry down;\\n\\n            private SkipListEntry left;\\n\\n            private SkipListEntry right;\\n\\n            public SkipListEntry(int key, int value) {\\n                this(key, value, null, null, null, null);\\n            }\\n\\n            public SkipListEntry(int key,\\n                                 int value,\\n                                 SkipListEntry left,\\n                                 SkipListEntry right) {\\n                this(key, value, left, right, null, null);\\n            }\\n\\n            public SkipListEntry(int key,\\n                                 int value,\\n                                 SkipListEntry left,\\n                                 SkipListEntry right,\\n                                 SkipListEntry up,\\n                                 SkipListEntry down) {\\n                this.key = key;\\n                this.value = value;\\n                this.left = left;\\n                this.right = right;\\n                this.up = up;\\n                this.down = down;\\n            }\\n\\n            public int getKey() {\\n                return this.key;\\n            }\\n\\n            public int getValue() {\\n                return this.value;\\n            }\\n\\n            public SkipListEntry left() {\\n                if (!this.hasLeft()) {\\n                    return null;\\n                }\\n\\n                return this.left;\\n            }\\n\\n            public void setLeft(SkipListEntry entry) {\\n                this.left = Objects.requireNonNull(entry);\\n            }\\n\\n            public SkipListEntry right() {\\n                if (!this.hasRight()) {\\n                    return null;\\n                }\\n\\n                return this.right;\\n            }\\n\\n            public void setRight(SkipListEntry entry) {\\n                this.right = Objects.requireNonNull(entry);\\n            }\\n\\n            public SkipListEntry up() {\\n                if (!this.hasUp()) {\\n                    return null;\\n                }\\n\\n                return this.up;\\n            }\\n\\n            public void setUp(SkipListEntry entry) {\\n                this.up = Objects.requireNonNull(entry);\\n            }\\n\\n            public SkipListEntry getDown() {\\n                return this.down;\\n            }\\n\\n            public SkipListEntry down() {\\n                if (!this.hasDown()) {\\n                    return null;\\n                }\\n\\n                return this.down;\\n            }\\n\\n            public void setDown(SkipListEntry entry) {\\n                this.down = Objects.requireNonNull(entry);\\n            }\\n\\n            public boolean hasLeft() {\\n                return this.left != null;\\n            }\\n\\n            public boolean hasRight() {\\n                return this.right != null;\\n            }\\n\\n            public boolean hasUp() {\\n                return this.up != null;\\n            }\\n\\n            public boolean hasDown() {\\n                return this.down != null;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Skiplist {\\n\\n        public static final int MAX_LEVEL = 4;\\n\\n        private final int levels;\\n\\n        private SkipListEntry head;\\n\\n        private SkipListEntry tail;\\n\\n        public Skiplist() {\\n            this(MAX_LEVEL);\\n        }\\n\\n        public Skiplist(int levels) {\\n            this.levels = levels;\\n\\n            //init new SkipList with defined level\\n            //Firstly, create the root level (level = 0) entry for left (min) and right (max)\\n            // and linked it\\n            //          LEFT <------------------------------------------------> RIGHT\\n            SkipListEntry left = new SkipListEntry(Integer.MIN_VALUE, Integer.MIN_VALUE);\\n            SkipListEntry right = new SkipListEntry(Integer.MAX_VALUE, Integer.MAX_VALUE);\\n            left.right = right;\\n            right.left = left;\\n\\n            // After, we can define left and right as the head and tail nodes\\n            //   HEAD = LEFT <------------------------------------------------> RIGHT = TAIL\\n            this.head = left;\\n            this.tail = right;\\n\\n            // Next, we can define left and right nodes for other levels and linked it\\n            // 0 HEAD = LEFT <------------------------------------------------> RIGHT = TAIL\\n            //            ^                                                  ^\\n            //            |                                                  |\\n            //            v                                                  v\\n            // 1 HEAD = LEFT <------------------------------------------------> RIGHT = TAIL\\n            //            ^                                                  ^\\n            //            |                                                  |\\n            //            v                                                  v\\n            // 2 HEAD = LEFT <------------------------------------------------> RIGHT = TAIL\\n            //            ^                                                  ^\\n            //            |                                                  |\\n            //            v                                                  v\\n            // 3 HEAD = LEFT <------------------------------------------------> RIGHT = TAIL\\n            //            ^                                                  ^\\n            //            |                                                  |\\n            //            v                                                  v\\n            // N HEAD = LEFT <------------------------------------------------> RIGHT = TAIL\\n            for (int i = 1; i < this.levels; i++) {\\n                left.down = new SkipListEntry(\\n                        Integer.MIN_VALUE,\\n                        Integer.MIN_VALUE,\\n                        null,\\n                        null,\\n                        left,\\n                        null\\n                );\\n                left = left.down;\\n\\n                right.down = new SkipListEntry(\\n                        Integer.MAX_VALUE,\\n                        Integer.MAX_VALUE,\\n                        null,\\n                        null,\\n                        right,\\n                        null\\n                );\\n                right = right.down;\\n\\n                left.right = right;\\n                right.left = left;\\n            }\\n        }\\n\\n        public boolean search(int target) {\\n            return this.find(target).key == target;\\n        }\\n\\n        public void add(int num) {\\n            // We have to always start from head\\n            SkipListEntry current = this.head;\\n\\n            // For the searching newNode we have to:\\n            // 1 - start from the head\\n            // 2 - go down the bottom level\\n            while (current.hasDown()) {\\n                current = current.down;\\n            }\\n\\n            // 3 - try to find newNode\\n            while (current.hasRight() && num > current.right.key) {\\n                current = current.right;\\n            }\\n\\n            // 4 - if we found newNode on the step 3, we have to do nothing (return;)\\n            if (num == current.key) {\\n                return;\\n            }\\n\\n            // 5 - otherwise, we have to a put new newNode on the right\\n            SkipListEntry newNode = new SkipListEntry(num, num, current, current.right);\\n            current.right.left = newNode;\\n            current.right = newNode;\\n\\n            // 6 - have to go up one level\\n            // 7 - flip the coin\\n            // 8 - if on the step 8 true - repeat step 5\\n            for (int level = this.levels - 2; level >= 0; level--) {\\n                if (!this.coinFlip(level)) {\\n                    return;\\n                }\\n\\n                // go up one level and find left node for new level\\n                while (!current.hasUp() && current.hasLeft()) {\\n                    current = current.left;\\n                }\\n                current = current.up;\\n\\n                newNode.up = new SkipListEntry(\\n                        num,\\n                        num,\\n                        current,\\n                        current.right,\\n                        null,\\n                        newNode\\n                );\\n                newNode = newNode.up;\\n\\n                current.right.left = newNode;\\n                current.right = newNode;\\n            }\\n        }\\n\\n        public boolean erase(int num) {\\n            SkipListEntry entry = this.find(num);\\n            if (entry.key != num) {\\n                return false;\\n            }\\n\\n            entry.left.right = entry.right;\\n            entry.right.left = entry.left;\\n\\n        while ((entry = entry.up) != null) {\\n            entry.left.right = entry.right;\\n            entry.right.left = entry.left;\\n        }\\n\\n            return true;\\n        }\\n\\n        private SkipListEntry find(int key) {\\n            // We have to always start from head\\n            SkipListEntry current = this.head;\\n\\n            // while node has right or down we can go down a level or right\\n            // 1 - we have to go right and try to find element\\n            // 2 - if element is not presented at this level, we have to go down a level\\n            // and repeat step 1\\n            // 3 - if we found element we have to go down to the bottom\\n            // if we found element we have to return it, otherwise - return last visited\\n            while (current != null && current.hasRight()) {\\n                while (current.hasRight() && key > current.right.key) {\\n                    current = current.right;\\n                }\\n\\n                if (key == current.right.key) {\\n                    current = current.right;\\n                    while (current.hasDown()) {\\n                        current = current.down;\\n                    }\\n\\n                    return current;\\n                }\\n\\n                current = current.down;\\n            }\\n\\n            return this.head;\\n        }\\n\\n        private boolean coinFlip(int level) {\\n            return ThreadLocalRandom.current().nextInt(this.levels - level) == 0;\\n        }\\n\\n        public static class SkipListEntry {\\n\\n            private final int key;\\n\\n            private final int value;\\n\\n            private SkipListEntry up;\\n\\n            private SkipListEntry down;\\n\\n            private SkipListEntry left;\\n\\n            private SkipListEntry right;\\n\\n            public SkipListEntry(int key, int value) {\\n                this(key, value, null, null, null, null);\\n            }\\n\\n            public SkipListEntry(int key,\\n                                 int value,\\n                                 SkipListEntry left,\\n                                 SkipListEntry right) {\\n                this(key, value, left, right, null, null);\\n            }\\n\\n            public SkipListEntry(int key,\\n                                 int value,\\n                                 SkipListEntry left,\\n                                 SkipListEntry right,\\n                                 SkipListEntry up,\\n                                 SkipListEntry down) {\\n                this.key = key;\\n                this.value = value;\\n                this.left = left;\\n                this.right = right;\\n                this.up = up;\\n                this.down = down;\\n            }\\n\\n            public int getKey() {\\n                return this.key;\\n            }\\n\\n            public int getValue() {\\n                return this.value;\\n            }\\n\\n            public SkipListEntry left() {\\n                if (!this.hasLeft()) {\\n                    return null;\\n                }\\n\\n                return this.left;\\n            }\\n\\n            public void setLeft(SkipListEntry entry) {\\n                this.left = Objects.requireNonNull(entry);\\n            }\\n\\n            public SkipListEntry right() {\\n                if (!this.hasRight()) {\\n                    return null;\\n                }\\n\\n                return this.right;\\n            }\\n\\n            public void setRight(SkipListEntry entry) {\\n                this.right = Objects.requireNonNull(entry);\\n            }\\n\\n            public SkipListEntry up() {\\n                if (!this.hasUp()) {\\n                    return null;\\n                }\\n\\n                return this.up;\\n            }\\n\\n            public void setUp(SkipListEntry entry) {\\n                this.up = Objects.requireNonNull(entry);\\n            }\\n\\n            public SkipListEntry getDown() {\\n                return this.down;\\n            }\\n\\n            public SkipListEntry down() {\\n                if (!this.hasDown()) {\\n                    return null;\\n                }\\n\\n                return this.down;\\n            }\\n\\n            public void setDown(SkipListEntry entry) {\\n                this.down = Objects.requireNonNull(entry);\\n            }\\n\\n            public boolean hasLeft() {\\n                return this.left != null;\\n            }\\n\\n            public boolean hasRight() {\\n                return this.right != null;\\n            }\\n\\n            public boolean hasUp() {\\n                return this.up != null;\\n            }\\n\\n            public boolean hasDown() {\\n                return this.down != null;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2160564,
                "title": "python-129ms-96-97-20-9mb-88-67",
                "content": "``` python\\nclass Skiplist:\\n\\n    def __init__(self):\\n        self.map = defaultdict(lambda *args: 0)\\n\\n    def search(self, target: int) -> bool:\\n        return target in self.map\\n\\n    def add(self, num: int) -> None:\\n        self.map[num] += 1\\n\\n    def erase(self, num: int) -> bool:\\n        if num not in self.map:\\n            return False\\n        self.map[num] -= 1\\n        if self.map[num] <= 0:\\n            try:\\n                self.map.pop(num)\\n            except KeyError:\\n                pass\\n        return True\\n\\n\\n```",
                "solutionTags": [],
                "code": "``` python\\nclass Skiplist:\\n\\n    def __init__(self):\\n        self.map = defaultdict(lambda *args: 0)\\n\\n    def search(self, target: int) -> bool:\\n        return target in self.map\\n\\n    def add(self, num: int) -> None:\\n        self.map[num] += 1\\n\\n    def erase(self, num: int) -> bool:\\n        if num not in self.map:\\n            return False\\n        self.map[num] -= 1\\n        if self.map[num] <= 0:\\n            try:\\n                self.map.pop(num)\\n            except KeyError:\\n                pass\\n        return True\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1972547,
                "title": "my-solution-in-c-with-one-express-lane-and-one-normal-lane",
                "content": "My solution in C++ with one express lane, and one normal lane.\\n\\n```cpp\\n\\nclass Node{\\npublic:\\n\\tint n;\\n\\tNode* next;\\n\\tNode* down;\\n\\n\\tNode() {\\n\\t\\tn = -1;\\n\\t\\tnext = nullptr;\\n\\t\\tdown = nullptr;\\n\\t}\\n\\n\\t~Node() {\\n\\t\\tif(next!=nullptr) delete next;\\n\\t\\tif(down!=nullptr) delete down;\\n\\t\\n\\t\\tnext = nullptr;\\n\\t\\tdown = nullptr;\\n\\t}\\n\\n};\\n\\nclass Skiplist {\\nprivate:\\n\\tNode* normalLane; // sentinel node\\n\\tNode* expressLane; // sentinel node\\n\\n\\tint normalLaneSize = 0;\\n\\tint expressLaneSize = 0;\\n\\n\\tint coin = 0;\\n\\tbool flipCoin() {  // if true, insert inside the express lane\\n\\t\\tcoin++;\\n\\t\\tif(coin == expressLaneSize) coin = 0;\\n\\t\\treturn (coin == 0);\\n\\t}\\n\\npublic:\\n  Skiplist() {\\n    normalLane = new Node();\\n    expressLane = new Node();\\n    expressLane->down = normalLane;\\n  }\\n\\n  ~Skiplist() {\\n    if(expressLane!=nullptr) {\\n      expressLane->down = nullptr;\\n      delete expressLane;\\n    } \\n  \\n  \\tif(normalLane!=nullptr) delete normalLane;\\n  \\t\\n  \\tnormalLane = nullptr;\\n  \\texpressLane = nullptr;\\n  }\\n  \\n  bool search(int target) {\\n      Node* curr = expressLane;\\n\\t\\t\\twhile( (curr->next!=nullptr) && (target <= curr->next->n) ) {\\n      \\tcurr = curr->next;\\n      }\\n\\n      bool found = false;\\n      if(curr->n == target) {\\n      \\tfound = true;\\n      \\tcurr = nullptr;\\n      \\treturn found;\\n      }\\n\\n      curr = curr->down;\\n\\t\\t\\twhile( (curr->next!=nullptr) && (target <= curr->next->n) ) {\\n      \\tcurr = curr->next;\\n      }\\n      found = (curr->n == target);\\n      return found;\\n  }\\n  \\n  void add(int target) {\\n      normalLaneSize++;\\n      expressLaneSize = sqrt(normalLaneSize);\\n\\n      bool isHead = flipCoin();\\n\\n      Node* curr = expressLane;\\n      Node* temp = nullptr;\\n      \\n      while( (curr->next!=nullptr) && (target < curr->next->n) ) {\\n      \\tcurr = curr->next;\\n      }\\n\\n      if(isHead) {\\n      \\ttemp = new Node();\\n      \\ttemp->n = target;\\n      \\ttemp->next = curr->next;\\n      }\\n\\n      curr = curr->down; // so now we are in the normal lane\\n\\t\\t\\twhile( (curr->next!=nullptr) && (target < curr->next->n) ) {\\n        // if(target < curr->next->n)\\n        \\tcurr = curr->next;\\n        // else break;\\n      }\\n\\n      Node* temp2 = new Node();\\n      temp2->n = target;\\n\\n      temp2->next = curr->next;\\n      curr->next = temp2;\\n\\n      if(temp!=nullptr) {\\n\\t      temp->down = temp2;\\n  \\t    temp = temp2;\\n      }\\n      \\n      // all temp variables to null\\n      curr = nullptr;\\n      temp = nullptr;\\n      temp2 = nullptr;\\n  }\\n  \\n  bool erase(int num) {\\n      bool isErased = false;\\n      normalLaneSize--;\\n      expressLaneSize = sqrt(normalLaneSize);\\n  \\n      Node* curr = expressLane;\\n      Node* temp = nullptr;\\n      Node* temp2 = nullptr;\\n      \\n      while( (curr->next!=nullptr) && (num < curr->next->n) ) {\\n      \\tcurr = curr->next;\\n      }\\n\\n      if( (curr->next != nullptr) && curr->next->n == num ) {\\n      \\ttemp = curr->next;\\n      \\tcurr->next = temp->next;\\n      \\ttemp->next = nullptr;\\n        isErased = true;\\n      }\\n\\n      curr = curr->down; // now we are in normalLane\\n\\t\\t\\t\\n\\t\\t\\twhile( (curr->next!=nullptr) && (num < curr->next->n) ) {\\n      \\tcurr = curr->next;\\n      }\\n\\n      if( (curr->next != nullptr) && (curr->next->n == num) ) {\\n      \\ttemp2 = curr->next;\\n      \\tcurr->next = temp2->next;\\n      \\ttemp2->next = nullptr;\\n              isErased = true;\\n      }\\n\\n      delete temp;\\n      delete temp2;\\n\\n      curr = nullptr;\\n      temp = nullptr;\\n      temp2 = nullptr;\\n    return isErased;\\n  }\\n\\n\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n\\n```",
                "solutionTags": [],
                "code": "```cpp\\n\\nclass Node{\\npublic:\\n\\tint n;\\n\\tNode* next;\\n\\tNode* down;\\n\\n\\tNode() {\\n\\t\\tn = -1;\\n\\t\\tnext = nullptr;\\n\\t\\tdown = nullptr;\\n\\t}\\n\\n\\t~Node() {\\n\\t\\tif(next!=nullptr) delete next;\\n\\t\\tif(down!=nullptr) delete down;\\n\\t\\n\\t\\tnext = nullptr;\\n\\t\\tdown = nullptr;\\n\\t}\\n\\n};\\n\\nclass Skiplist {\\nprivate:\\n\\tNode* normalLane; // sentinel node\\n\\tNode* expressLane; // sentinel node\\n\\n\\tint normalLaneSize = 0;\\n\\tint expressLaneSize = 0;\\n\\n\\tint coin = 0;\\n\\tbool flipCoin() {  // if true, insert inside the express lane\\n\\t\\tcoin++;\\n\\t\\tif(coin == expressLaneSize) coin = 0;\\n\\t\\treturn (coin == 0);\\n\\t}\\n\\npublic:\\n  Skiplist() {\\n    normalLane = new Node();\\n    expressLane = new Node();\\n    expressLane->down = normalLane;\\n  }\\n\\n  ~Skiplist() {\\n    if(expressLane!=nullptr) {\\n      expressLane->down = nullptr;\\n      delete expressLane;\\n    } \\n  \\n  \\tif(normalLane!=nullptr) delete normalLane;\\n  \\t\\n  \\tnormalLane = nullptr;\\n  \\texpressLane = nullptr;\\n  }\\n  \\n  bool search(int target) {\\n      Node* curr = expressLane;\\n\\t\\t\\twhile( (curr->next!=nullptr) && (target <= curr->next->n) ) {\\n      \\tcurr = curr->next;\\n      }\\n\\n      bool found = false;\\n      if(curr->n == target) {\\n      \\tfound = true;\\n      \\tcurr = nullptr;\\n      \\treturn found;\\n      }\\n\\n      curr = curr->down;\\n\\t\\t\\twhile( (curr->next!=nullptr) && (target <= curr->next->n) ) {\\n      \\tcurr = curr->next;\\n      }\\n      found = (curr->n == target);\\n      return found;\\n  }\\n  \\n  void add(int target) {\\n      normalLaneSize++;\\n      expressLaneSize = sqrt(normalLaneSize);\\n\\n      bool isHead = flipCoin();\\n\\n      Node* curr = expressLane;\\n      Node* temp = nullptr;\\n      \\n      while( (curr->next!=nullptr) && (target < curr->next->n) ) {\\n      \\tcurr = curr->next;\\n      }\\n\\n      if(isHead) {\\n      \\ttemp = new Node();\\n      \\ttemp->n = target;\\n      \\ttemp->next = curr->next;\\n      }\\n\\n      curr = curr->down; // so now we are in the normal lane\\n\\t\\t\\twhile( (curr->next!=nullptr) && (target < curr->next->n) ) {\\n        // if(target < curr->next->n)\\n        \\tcurr = curr->next;\\n        // else break;\\n      }\\n\\n      Node* temp2 = new Node();\\n      temp2->n = target;\\n\\n      temp2->next = curr->next;\\n      curr->next = temp2;\\n\\n      if(temp!=nullptr) {\\n\\t      temp->down = temp2;\\n  \\t    temp = temp2;\\n      }\\n      \\n      // all temp variables to null\\n      curr = nullptr;\\n      temp = nullptr;\\n      temp2 = nullptr;\\n  }\\n  \\n  bool erase(int num) {\\n      bool isErased = false;\\n      normalLaneSize--;\\n      expressLaneSize = sqrt(normalLaneSize);\\n  \\n      Node* curr = expressLane;\\n      Node* temp = nullptr;\\n      Node* temp2 = nullptr;\\n      \\n      while( (curr->next!=nullptr) && (num < curr->next->n) ) {\\n      \\tcurr = curr->next;\\n      }\\n\\n      if( (curr->next != nullptr) && curr->next->n == num ) {\\n      \\ttemp = curr->next;\\n      \\tcurr->next = temp->next;\\n      \\ttemp->next = nullptr;\\n        isErased = true;\\n      }\\n\\n      curr = curr->down; // now we are in normalLane\\n\\t\\t\\t\\n\\t\\t\\twhile( (curr->next!=nullptr) && (num < curr->next->n) ) {\\n      \\tcurr = curr->next;\\n      }\\n\\n      if( (curr->next != nullptr) && (curr->next->n == num) ) {\\n      \\ttemp2 = curr->next;\\n      \\tcurr->next = temp2->next;\\n      \\ttemp2->next = nullptr;\\n              isErased = true;\\n      }\\n\\n      delete temp;\\n      delete temp2;\\n\\n      curr = nullptr;\\n      temp = nullptr;\\n      temp2 = nullptr;\\n    return isErased;\\n  }\\n\\n\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1807700,
                "title": "python3",
                "content": "```\\nfrom random import getrandbits\\n\\nMAX_HEIGHT = 16\\n\\nclass Node:\\n    __slots__ = (\\'next\\', \\'val\\')\\n    def __init__(self, val):\\n        self.val = val\\n\\ndef create(val, prevs):\\n    res, next_ = Node(val), []\\n    for i in range(MAX_HEIGHT):\\n        next_.append(prevs[i].next[i])\\n        prevs[i].next[i] = res\\n        if getrandbits(1):\\n            break\\n    res.next = next_\\n    return res\\n\\ndef search_prevs(cur, val):\\n    level, prevs  = MAX_HEIGHT - 1, [None for _ in range(MAX_HEIGHT)]\\n    while level >= 0:\\n        prevs[level] = cur\\n        if cur.next[level].val is not None and cur.next[level].val < val:\\n            cur = cur.next[level]\\n        else:\\n            level -= 1\\n    return prevs\\n\\n\\nclass Skiplist:\\n    def __init__(self):\\n        self.start, end_node = Node(None), Node(None)\\n        self.start.next = [end_node for _ in range(MAX_HEIGHT)]\\n\\n    def search(self, target: int) -> bool:\\n        return search_prevs(self.start, target)[0].next[0].val == target\\n\\n    def add(self, num: int) -> None:\\n        create(num, search_prevs(self.start, num))\\n\\n    def erase(self, num: int) -> bool:\\n        prevs = search_prevs(self.start, num)\\n        cur = prevs[0].next[0]\\n        if cur.val != num:\\n            return False\\n        for i, ptr in enumerate(cur.next):\\n            prevs[i].next[i] = ptr\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nfrom random import getrandbits\\n\\nMAX_HEIGHT = 16\\n\\nclass Node:\\n    __slots__ = (\\'next\\', \\'val\\')\\n    def __init__(self, val):\\n        self.val = val\\n\\ndef create(val, prevs):\\n    res, next_ = Node(val), []\\n    for i in range(MAX_HEIGHT):\\n        next_.append(prevs[i].next[i])\\n        prevs[i].next[i] = res\\n        if getrandbits(1):\\n            break\\n    res.next = next_\\n    return res\\n\\ndef search_prevs(cur, val):\\n    level, prevs  = MAX_HEIGHT - 1, [None for _ in range(MAX_HEIGHT)]\\n    while level >= 0:\\n        prevs[level] = cur\\n        if cur.next[level].val is not None and cur.next[level].val < val:\\n            cur = cur.next[level]\\n        else:\\n            level -= 1\\n    return prevs\\n\\n\\nclass Skiplist:\\n    def __init__(self):\\n        self.start, end_node = Node(None), Node(None)\\n        self.start.next = [end_node for _ in range(MAX_HEIGHT)]\\n\\n    def search(self, target: int) -> bool:\\n        return search_prevs(self.start, target)[0].next[0].val == target\\n\\n    def add(self, num: int) -> None:\\n        create(num, search_prevs(self.start, num))\\n\\n    def erase(self, num: int) -> bool:\\n        prevs = search_prevs(self.start, num)\\n        cur = prevs[0].next[0]\\n        if cur.val != num:\\n            return False\\n        for i, ptr in enumerate(cur.next):\\n            prevs[i].next[i] = ptr\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1609369,
                "title": "golang-solution",
                "content": "```go\\ntype Skiplist struct {\\n\\tlevel int\\n\\thead  *SkipListNode\\n}\\n\\ntype SkipListNode struct {\\n\\tval  int\\n\\tcount int\\n\\tnext []*SkipListNode\\n}\\n\\nfunc Constructor() Skiplist {\\n\\tlevel := 16\\n\\trand.Seed(time.Now().UnixNano())\\n\\ttail := &SkipListNode{\\n\\t\\tval:  math.MaxInt64,\\n\\t\\tnext: nil,\\n\\t}\\n\\tnext := make([]*SkipListNode, level)\\n\\tfor i := range next {\\n\\t\\tnext[i] = tail\\n\\t}\\n\\thead := &SkipListNode{\\n\\t\\tval:  -1,\\n\\t\\tnext: next,\\n\\t}\\n\\treturn Skiplist{\\n\\t\\tlevel: level,\\n\\t\\thead:  head,\\n\\t}\\n}\\n\\nfunc (sl *Skiplist) Search(target int) bool {\\n\\tcurNode := sl.head\\n\\tcurLevel := 0\\n\\tfor curLevel < sl.level {\\n\\t\\tif curNode.next[curLevel].val == target {\\n\\t\\t\\t// found, return true\\n\\t\\t\\tfmt.Println(fmt.Sprintf(\"search %v, found\", target))\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tif curNode.next[curLevel].val < target {\\n\\t\\t\\t// try next node\\n\\t\\t\\tcurNode = curNode.next[curLevel]\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\t// try next level\\n\\t\\tcurLevel++\\n\\t}\\n\\t// not found\\n\\tfmt.Println(fmt.Sprintf(\"search %v, not found\", target))\\n\\treturn false\\n}\\n\\nfunc (sl *Skiplist) Add(num int) {\\n\\t// random pick a level\\n\\taddLevel := rand.Intn(sl.level)\\n\\tcurNode := sl.head\\n\\tcurLevel := 0\\n\\tneedAdd := make([]*SkipListNode, 0)\\n\\tfor curLevel < sl.level {\\n\\t\\tif curNode.next[curLevel].val == num {\\n\\t\\t\\t// already exist\\n\\t\\t\\tfmt.Println(fmt.Sprintf(\"add %v already exist, count++\", num))\\n\\t\\t\\tcurNode.next[curLevel].count++\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tif curNode.next[curLevel].val < num {\\n\\t\\t\\t// try next node\\n\\t\\t\\tcurNode = curNode.next[curLevel]\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif curLevel >= addLevel {\\n\\t\\t\\tneedAdd = append(needAdd, curNode)\\n\\t\\t}\\n\\t\\t// try next level\\n\\t\\tcurLevel++\\n\\t}\\n\\t// num not exist, insert into SkipList\\n\\tnewNode := &SkipListNode{\\n\\t\\tval:  num,\\n\\t\\tcount: 1,\\n\\t\\tnext: make([]*SkipListNode, sl.level),\\n\\t}\\n\\tfor l, v := range needAdd {\\n\\t\\tnewNode.next[l+addLevel] = v.next[l+addLevel]\\n\\t\\tv.next[l+addLevel] = newNode\\n\\t}\\n\\tfmt.Println(fmt.Sprintf(\"add %v successfully\", num))\\n}\\n\\nfunc (sl *Skiplist) Erase(num int) bool {\\n\\tcurNode := sl.head\\n\\tcurLevel := 0\\n\\terased := false\\n\\tfor curLevel < sl.level {\\n\\t\\tif curNode.next[curLevel].val == num {\\n\\t\\t\\tif curNode.next[curLevel].count > 1 {\\n\\t\\t\\t\\tcurNode.next[curLevel].count--\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t\\tcurNode.next[curLevel] = curNode.next[curLevel].next[curLevel]\\n\\t\\t\\terased = true\\n\\t\\t\\tcurLevel++\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif curNode.next[curLevel].val < num {\\n\\t\\t\\tcurNode = curNode.next[curLevel]\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tcurLevel++\\n\\t}\\n\\tfmt.Println(fmt.Sprintf(\"erase %v result %v\", num, erased))\\n\\treturn erased\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\ntype Skiplist struct {\\n\\tlevel int\\n\\thead  *SkipListNode\\n}\\n\\ntype SkipListNode struct {\\n\\tval  int\\n\\tcount int\\n\\tnext []*SkipListNode\\n}\\n\\nfunc Constructor() Skiplist {\\n\\tlevel := 16\\n\\trand.Seed(time.Now().UnixNano())\\n\\ttail := &SkipListNode{\\n\\t\\tval:  math.MaxInt64,\\n\\t\\tnext: nil,\\n\\t}\\n\\tnext := make([]*SkipListNode, level)\\n\\tfor i := range next {\\n\\t\\tnext[i] = tail\\n\\t}\\n\\thead := &SkipListNode{\\n\\t\\tval:  -1,\\n\\t\\tnext: next,\\n\\t}\\n\\treturn Skiplist{\\n\\t\\tlevel: level,\\n\\t\\thead:  head,\\n\\t}\\n}\\n\\nfunc (sl *Skiplist) Search(target int) bool {\\n\\tcurNode := sl.head\\n\\tcurLevel := 0\\n\\tfor curLevel < sl.level {\\n\\t\\tif curNode.next[curLevel].val == target {\\n\\t\\t\\t// found, return true\\n\\t\\t\\tfmt.Println(fmt.Sprintf(\"search %v, found\", target))\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tif curNode.next[curLevel].val < target {\\n\\t\\t\\t// try next node\\n\\t\\t\\tcurNode = curNode.next[curLevel]\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\t// try next level\\n\\t\\tcurLevel++\\n\\t}\\n\\t// not found\\n\\tfmt.Println(fmt.Sprintf(\"search %v, not found\", target))\\n\\treturn false\\n}\\n\\nfunc (sl *Skiplist) Add(num int) {\\n\\t// random pick a level\\n\\taddLevel := rand.Intn(sl.level)\\n\\tcurNode := sl.head\\n\\tcurLevel := 0\\n\\tneedAdd := make([]*SkipListNode, 0)\\n\\tfor curLevel < sl.level {\\n\\t\\tif curNode.next[curLevel].val == num {\\n\\t\\t\\t// already exist\\n\\t\\t\\tfmt.Println(fmt.Sprintf(\"add %v already exist, count++\", num))\\n\\t\\t\\tcurNode.next[curLevel].count++\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tif curNode.next[curLevel].val < num {\\n\\t\\t\\t// try next node\\n\\t\\t\\tcurNode = curNode.next[curLevel]\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif curLevel >= addLevel {\\n\\t\\t\\tneedAdd = append(needAdd, curNode)\\n\\t\\t}\\n\\t\\t// try next level\\n\\t\\tcurLevel++\\n\\t}\\n\\t// num not exist, insert into SkipList\\n\\tnewNode := &SkipListNode{\\n\\t\\tval:  num,\\n\\t\\tcount: 1,\\n\\t\\tnext: make([]*SkipListNode, sl.level),\\n\\t}\\n\\tfor l, v := range needAdd {\\n\\t\\tnewNode.next[l+addLevel] = v.next[l+addLevel]\\n\\t\\tv.next[l+addLevel] = newNode\\n\\t}\\n\\tfmt.Println(fmt.Sprintf(\"add %v successfully\", num))\\n}\\n\\nfunc (sl *Skiplist) Erase(num int) bool {\\n\\tcurNode := sl.head\\n\\tcurLevel := 0\\n\\terased := false\\n\\tfor curLevel < sl.level {\\n\\t\\tif curNode.next[curLevel].val == num {\\n\\t\\t\\tif curNode.next[curLevel].count > 1 {\\n\\t\\t\\t\\tcurNode.next[curLevel].count--\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t\\tcurNode.next[curLevel] = curNode.next[curLevel].next[curLevel]\\n\\t\\t\\terased = true\\n\\t\\t\\tcurLevel++\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif curNode.next[curLevel].val < num {\\n\\t\\t\\tcurNode = curNode.next[curLevel]\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tcurLevel++\\n\\t}\\n\\tfmt.Println(fmt.Sprintf(\"erase %v result %v\", num, erased))\\n\\treturn erased\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1499787,
                "title": "c",
                "content": "Inspired by this post: https://leetcode.com/problems/design-skiplist/discuss/400028/C%2B%2B-SkipList.-2-pointer-for-each-node.-64ms\\n\\n```\\nclass Skiplist {\\nprivate:\\n    struct ListNode {\\n        int val;\\n        ListNode* next = nullptr;\\n        ListNode* down = nullptr;\\n        ListNode() {};\\n        ListNode(int v, ListNode* n, ListNode* d) : val(v), next(n), down(d) {}\\n    };\\n    \\n    ListNode dummy;\\n    ListNode* head;\\npublic:\\n    Skiplist(): head(&dummy) {\\n        \\n    }\\n    \\n    bool search(int target) {\\n        for(ListNode* node = head; node; node = node->down) {\\n            for(; node->next && node->next->val < target; node = node->next) {}\\n            if(node->next && node->next->val == target) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    void add(int num) {\\n        vector<ListNode*> pre_nodes;\\n        for(ListNode* node = head; node; node = node->down) {\\n            for(; node->next && node->next->val < num; node = node->next) {}\\n            pre_nodes.push_back(node);\\n        }\\n        \\n        bool rnd = true;\\n        ListNode* down = nullptr, *pre = nullptr;\\n        for(; rnd && !pre_nodes.empty(); rnd = rand() & 3) {\\n            pre = pre_nodes.back();\\n            pre->next = new ListNode(num, pre->next, down);\\n            down = pre->next;\\n            pre_nodes.pop_back();\\n        }\\n    }\\n    \\n    bool erase(int num) {\\n        bool found = false;\\n        for(ListNode* node = head; node; node = node->down) {\\n            for(; node->next && node->next->val < num; node = node->next) {}\\n            if(node->next && node->next->val == num) {\\n                found = true;\\n                auto* p = node->next;\\n                node->next = p->next;\\n                delete p;\\n            }\\n        }\\n        return found;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Skiplist {\\nprivate:\\n    struct ListNode {\\n        int val;\\n        ListNode* next = nullptr;\\n        ListNode* down = nullptr;\\n        ListNode() {};\\n        ListNode(int v, ListNode* n, ListNode* d) : val(v), next(n), down(d) {}\\n    };\\n    \\n    ListNode dummy;\\n    ListNode* head;\\npublic:\\n    Skiplist(): head(&dummy) {\\n        \\n    }\\n    \\n    bool search(int target) {\\n        for(ListNode* node = head; node; node = node->down) {\\n            for(; node->next && node->next->val < target; node = node->next) {}\\n            if(node->next && node->next->val == target) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    void add(int num) {\\n        vector<ListNode*> pre_nodes;\\n        for(ListNode* node = head; node; node = node->down) {\\n            for(; node->next && node->next->val < num; node = node->next) {}\\n            pre_nodes.push_back(node);\\n        }\\n        \\n        bool rnd = true;\\n        ListNode* down = nullptr, *pre = nullptr;\\n        for(; rnd && !pre_nodes.empty(); rnd = rand() & 3) {\\n            pre = pre_nodes.back();\\n            pre->next = new ListNode(num, pre->next, down);\\n            down = pre->next;\\n            pre_nodes.pop_back();\\n        }\\n    }\\n    \\n    bool erase(int num) {\\n        bool found = false;\\n        for(ListNode* node = head; node; node = node->down) {\\n            for(; node->next && node->next->val < num; node = node->next) {}\\n            if(node->next && node->next->val == num) {\\n                found = true;\\n                auto* p = node->next;\\n                node->next = p->next;\\n                delete p;\\n            }\\n        }\\n        return found;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491081,
                "title": "c-40ms-100-simple-easy-small-and-clean-new-time-record",
                "content": "**General idea :**\\n1. Will support vector with \"falseheades\" for each 64 numbers and will resizing it when it will be necessary \\n2. Will support in each node count of the same values\\n3. Will support in each linked list increasing order  \\n\\nRuntime: 40 ms, faster than 100.00% of C++ online submissions for Design Skiplist.\\nMemory Usage: 28.9 MB, less than 93.80% of C++ online submissions for Design Skiplist.\\n```\\nclass Skiplist {\\npublic:\\n  struct Node{\\n    int val, count;\\n    Node * next;\\n    Node(int v, Node* n){val = v, count = 1, next = n;} \\n  };\\n  vector<Node*> table;\\n    \\n  bool search(int target) {\\n    int id = target>>6;\\n    Node *p = table[id];\\n    \\n    while(p)\\n      if(p->val == target) return true;\\n      else p = p->next;\\n    \\n    return false;\\n  }\\n    \\n  void add(int num) {\\n    int id = num>>6;\\n    if(id >= table.size()) for(int i = table.size(); i <= id; i++) table.push_back(new Node(-1, NULL));\\n    Node* p = table[id];\\n    \\n    while(p->next)\\n      if(p->next->val == num) {p->next->count++; return;}\\n      else if(p->next->val < num) p = p->next;\\n            else{p->next = new Node(num, p->next); return;}\\n    \\n    p->next = new Node(num, NULL);\\n  }\\n    \\n  bool erase(int num) {\\n    int id = num>>6;\\n    Node* p = table[id];\\n   \\n    while(p->next)\\n      if(p->next->val == num){\\n        if(--p->next->count == 0) p->next = p->next->next;\\n        return true;\\n      }\\n      else if(p->next->val > num) return false;\\n           else p = p->next;\\n    \\n    return false;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Skiplist {\\npublic:\\n  struct Node{\\n    int val, count;\\n    Node * next;\\n    Node(int v, Node* n){val = v, count = 1, next = n;} \\n  };\\n  vector<Node*> table;\\n    \\n  bool search(int target) {\\n    int id = target>>6;\\n    Node *p = table[id];\\n    \\n    while(p)\\n      if(p->val == target) return true;\\n      else p = p->next;\\n    \\n    return false;\\n  }\\n    \\n  void add(int num) {\\n    int id = num>>6;\\n    if(id >= table.size()) for(int i = table.size(); i <= id; i++) table.push_back(new Node(-1, NULL));\\n    Node* p = table[id];\\n    \\n    while(p->next)\\n      if(p->next->val == num) {p->next->count++; return;}\\n      else if(p->next->val < num) p = p->next;\\n            else{p->next = new Node(num, p->next); return;}\\n    \\n    p->next = new Node(num, NULL);\\n  }\\n    \\n  bool erase(int num) {\\n    int id = num>>6;\\n    Node* p = table[id];\\n   \\n    while(p->next)\\n      if(p->next->val == num){\\n        if(--p->next->count == 0) p->next = p->next->next;\\n        return true;\\n      }\\n      else if(p->next->val > num) return false;\\n           else p = p->next;\\n    \\n    return false;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438302,
                "title": "implement-a-skiplist-with-print-for-debug",
                "content": "```java\\nclass Skiplist {\\n    int MAX_LEVEL = 10;\\n    class Node{\\n        int val;\\n        Node[] next = new Node[MAX_LEVEL];\\n        Node(int val){\\n            this.val = val;\\n        }\\n        Node(){}\\n    }\\n    \\n    Node head;\\n    int curLevel;\\n    \\n    public Skiplist() {\\n        head = new Node();\\n        curLevel = 0;\\n    }\\n    \\n    public boolean search(int target) {\\n        // printSL();\\n        Node cur = head;\\n        for(int i = curLevel; i >= 0; i--){\\n            while(cur.next[i] != null && cur.next[i].val < target){\\n                cur = cur.next[i];\\n            }\\n        }\\n        if(cur.next[0] != null && cur.next[0].val == target) return true;\\n        else return false;\\n    }\\n    \\n    public void add(int num) {\\n        Node cur = head;\\n        Node[] updates = new Node[MAX_LEVEL];\\n        for(int i = curLevel; i >= 0; i--){\\n            while(cur.next[i] != null && cur.next[i].val < num){\\n                cur = cur.next[i];\\n            }\\n            updates[i] = cur;\\n        }\\n        int lvl = randomLevel(0.5);\\n        Node newNode = new Node(num);\\n        if(lvl > curLevel){\\n            for(int i = curLevel+1; i <= lvl; i++){\\n                updates[i] = head;\\n            }\\n            curLevel = lvl;\\n        }\\n        for(int i = 0; i <= lvl; i++){\\n            newNode.next[i] = updates[i].next[i];\\n            updates[i].next[i] = newNode;\\n        }\\n    }\\n    \\n    public boolean erase(int num) {\\n        Node cur = head;\\n        Node[] updates = new Node[MAX_LEVEL];\\n        for(int i = curLevel; i >= 0; i--){\\n            while(cur.next[i] != null && cur.next[i].val < num){\\n                cur = cur.next[i];\\n            }\\n            updates[i] = cur;\\n        }\\n        boolean ans = false;\\n        for(int i = 0; i < curLevel; i++){\\n            if(updates[i].next[i] != null && updates[i].next[i].val == num){\\n                updates[i].next[i] = updates[i].next[i].next[i];\\n                ans = true;\\n            } else {\\n                break;\\n            }\\n        }\\n        while(curLevel > 0 && head.next[curLevel] == null){\\n            curLevel--;\\n        }\\n        return ans;\\n    }\\n    \\n    private int randomLevel(double p){\\n        int lvl = 0;\\n        while(lvl < (MAX_LEVEL-1) && Math.random() < p){\\n            lvl++;\\n        }\\n        return lvl;\\n    }\\n    \\n    // print for debug\\n    private void printSL(){\\n        System.out.println(\"print SkipList:\");\\n        for(int i = curLevel; i >= 0; i--){\\n            Node cur = head;\\n            while(cur.next[i] != null){\\n                System.out.printf(\"%d->\", cur.next[i].val);\\n                cur = cur.next[i];\\n            }\\n            System.out.println(\"null\");\\n        }\\n    }\\n}\\n```\\n\\n**Reference paper**:\\n[Skip Lists: A Probabilistic Alternative to Balanced Trees](https://www.cl.cam.ac.uk/teaching/0506/Algorithms/skiplists.pdf)\\n",
                "solutionTags": [
                    "Java",
                    "Design"
                ],
                "code": "```java\\nclass Skiplist {\\n    int MAX_LEVEL = 10;\\n    class Node{\\n        int val;\\n        Node[] next = new Node[MAX_LEVEL];\\n        Node(int val){\\n            this.val = val;\\n        }\\n        Node(){}\\n    }\\n    \\n    Node head;\\n    int curLevel;\\n    \\n    public Skiplist() {\\n        head = new Node();\\n        curLevel = 0;\\n    }\\n    \\n    public boolean search(int target) {\\n        // printSL();\\n        Node cur = head;\\n        for(int i = curLevel; i >= 0; i--){\\n            while(cur.next[i] != null && cur.next[i].val < target){\\n                cur = cur.next[i];\\n            }\\n        }\\n        if(cur.next[0] != null && cur.next[0].val == target) return true;\\n        else return false;\\n    }\\n    \\n    public void add(int num) {\\n        Node cur = head;\\n        Node[] updates = new Node[MAX_LEVEL];\\n        for(int i = curLevel; i >= 0; i--){\\n            while(cur.next[i] != null && cur.next[i].val < num){\\n                cur = cur.next[i];\\n            }\\n            updates[i] = cur;\\n        }\\n        int lvl = randomLevel(0.5);\\n        Node newNode = new Node(num);\\n        if(lvl > curLevel){\\n            for(int i = curLevel+1; i <= lvl; i++){\\n                updates[i] = head;\\n            }\\n            curLevel = lvl;\\n        }\\n        for(int i = 0; i <= lvl; i++){\\n            newNode.next[i] = updates[i].next[i];\\n            updates[i].next[i] = newNode;\\n        }\\n    }\\n    \\n    public boolean erase(int num) {\\n        Node cur = head;\\n        Node[] updates = new Node[MAX_LEVEL];\\n        for(int i = curLevel; i >= 0; i--){\\n            while(cur.next[i] != null && cur.next[i].val < num){\\n                cur = cur.next[i];\\n            }\\n            updates[i] = cur;\\n        }\\n        boolean ans = false;\\n        for(int i = 0; i < curLevel; i++){\\n            if(updates[i].next[i] != null && updates[i].next[i].val == num){\\n                updates[i].next[i] = updates[i].next[i].next[i];\\n                ans = true;\\n            } else {\\n                break;\\n            }\\n        }\\n        while(curLevel > 0 && head.next[curLevel] == null){\\n            curLevel--;\\n        }\\n        return ans;\\n    }\\n    \\n    private int randomLevel(double p){\\n        int lvl = 0;\\n        while(lvl < (MAX_LEVEL-1) && Math.random() < p){\\n            lvl++;\\n        }\\n        return lvl;\\n    }\\n    \\n    // print for debug\\n    private void printSL(){\\n        System.out.println(\"print SkipList:\");\\n        for(int i = curLevel; i >= 0; i--){\\n            Node cur = head;\\n            while(cur.next[i] != null){\\n                System.out.printf(\"%d->\", cur.next[i].val);\\n                cur = cur.next[i];\\n            }\\n            System.out.println(\"null\");\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389948,
                "title": "python-with-detailed-comments-faster-than-90-52-memory-usage-less-than-67-77",
                "content": "```\\nclass SkipNode:\\n    \\'\\'\\'\\n    key: the value held by node\\n    count: the count of occurences of the value held by the node\\n    forward: the next List for different levels\\n    \\'\\'\\'\\n    def __init__(self,levelCount, key):\\n        self.key =key\\n        self.count =1 \\n        self.forward = [None]*levelCount\\n\\nclass Skiplist: \\n    # parallely run linked list at multiple levels\\n    # For best understanding read in the following order:-\\n    # 1. randomlevels, \\n    # 2. search,\\n    # 3. GetUpdatePredeccesors\\n    # 4. add\\n    # 4. erase\\n    \\n    def __init__(self,p=0.5):\\n        self.p = 0.5 # probability of adding another level to a node\\n        \\n        # Calculating max level depending on max number of unique nodes that can be present\\n        self.maxLevel = math.ceil(math.log2(2*10000))+1\\n        \\n        # here Head & tail are dummy\\n        \\n        # setting head as -1 as no input value will be -ve\\n        self.head = SkipNode(self.maxLevel,-1)\\n        # setting tail as infinity as that is the max value possible\\n        self.tail = SkipNode(0,float(\\'inf\\'))\\n        \\n        # Making the head point to the tail for all levels\\n        for level in range(len(self.head.forward)):\\n            self.head.forward[level] = self.tail\\n        \\n        \\n        self.curMaxLevelInList = 1\\n        \\n\\n    def search(self, target: int) -> bool:\\n        cur = self.head\\n        # Search at the highest level, for fastest skips\\n        # If next node in the current level is higher than or equal to target, \\n        # go down one level for shorter skips\\n        for level in range(self.curMaxLevelInList-1,-1,-1):\\n            while cur.forward[level].key<target:\\n                cur = cur.forward[level]\\n            # return if target value found in next node\\n            if cur.forward[level].key==target:\\n                return True\\n        return False\\n\\n    def add(self, num: int) -> None:\\n        # getting the predecessors to num value at each available level\\n        update = self.getUpdatePredecessors(num)\\n        \\n        # getting the next node to it\\'s predecessor at the lowest level i.e. 0\\n        cur = update[0].forward[0] \\n        \\n        if cur.key==num: # num already exists, \\n            # just increments it\\'s count\\n            cur.count+=1\\n        else:\\n            # request number of levels for this node\\n            curNodeLevel = self.randomLevel() \\n            \\n            if curNodeLevel>self.curMaxLevelInList: # if the number of levels is greater than the current max\\n                # no actual nodes exist at this level\\n                # for all levels above current max levels predecessor is head\\n                for level in range(self.curMaxLevelInList,curNodeLevel):\\n                    update[level]=self.head\\n                \\n                # updating the max number of levels in the list\\n                self.curMaxLevelInList = curNodeLevel\\n            \\n            # Finally create the node to be inserted\\n            cur = SkipNode(curNodeLevel,num)\\n            \\n            # Inserting node by appointing the next node \\n            # after it\\'s predecessor, to it\\'s own next node\\n            # and predecessor\\'s node \\n            for level in range(curNodeLevel):\\n                cur.forward[level] = update[level].forward[level]\\n                update[level].forward[level] = cur\\n        \\n    def erase(self, num: int) -> bool:\\n        # getting the predecessors to num value at each available level\\n        update = self.getUpdatePredecessors(num)\\n        \\n        # getting the next node to it\\'s predecessor at the lowest level i.e. 0\\n        cur = update[0].forward[0]\\n        \\n        if cur.key!=num: # num value does not exist in the skiplis\\n            return False\\n        else:\\n            \\n            if cur.count>1: # if there are multiple instances of the num value\\n                # Delete any one and reduce counter\\n                cur.count-=1\\n            else:\\n                # Iterate through all levels, and \\n                for level in range(self.curMaxLevelInList):\\n                    # Stop at the level when the node does not exist\\n                    if update[level].forward[level]!=cur: \\n                        break\\n                    update[level].forward[level] = cur.forward[level]\\n                \\n                # Delete Node to free memory\\n                del cur\\n                \\n                # For all levels where no nodes exist now, \\n                # i.e. dummy head points to dummy tail\\n                # reducing max level count in the list\\n                while self.curMaxLevelInList>1 and self.head.forward[self.curMaxLevelInList-1]==self.tail:\\n                    self.curMaxLevelInList-=1\\n            \\n            return True # Since num value was found\\n    \\n    # getting predecessors at each level before the target val \\n    # which need to be updated\\n    def getUpdatePredecessors(self,target):\\n        update = [None]*self.maxLevel\\n       \\n        # Apply similar rountine to search \\n        # but here we keep predecessor at the ach level in update\\n        cur = self.head\\n        for level in range(self.curMaxLevelInList-1,-1,-1):\\n            while cur.forward[level].key<target:\\n                cur = cur.forward[level]\\n            update[level] = cur\\n        return update\\n        \\n    \\n    def randomLevel(self):\\n\\t\\t# Atleast present in one level\\n        level = 1\\n\\t\\t# Random.random produces number in range (0,1)\\n\\t\\t# Only producing more levels until we are less that max number of levels allowed in the skip list\\n        while random.random()<self.p and level<min(self.maxLevel,self.curMaxLevelInList+1):\\n            level+=1\\n        return level\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass SkipNode:\\n    \\'\\'\\'\\n    key: the value held by node\\n    count: the count of occurences of the value held by the node\\n    forward: the next List for different levels\\n    \\'\\'\\'\\n    def __init__(self,levelCount, key):\\n        self.key =key\\n        self.count =1 \\n        self.forward = [None]*levelCount\\n\\nclass Skiplist: \\n    # parallely run linked list at multiple levels\\n    # For best understanding read in the following order:-\\n    # 1. randomlevels, \\n    # 2. search,\\n    # 3. GetUpdatePredeccesors\\n    # 4. add\\n    # 4. erase\\n    \\n    def __init__(self,p=0.5):\\n        self.p = 0.5 # probability of adding another level to a node\\n        \\n        # Calculating max level depending on max number of unique nodes that can be present\\n        self.maxLevel = math.ceil(math.log2(2*10000))+1\\n        \\n        # here Head & tail are dummy\\n        \\n        # setting head as -1 as no input value will be -ve\\n        self.head = SkipNode(self.maxLevel,-1)\\n        # setting tail as infinity as that is the max value possible\\n        self.tail = SkipNode(0,float(\\'inf\\'))\\n        \\n        # Making the head point to the tail for all levels\\n        for level in range(len(self.head.forward)):\\n            self.head.forward[level] = self.tail\\n        \\n        \\n        self.curMaxLevelInList = 1\\n        \\n\\n    def search(self, target: int) -> bool:\\n        cur = self.head\\n        # Search at the highest level, for fastest skips\\n        # If next node in the current level is higher than or equal to target, \\n        # go down one level for shorter skips\\n        for level in range(self.curMaxLevelInList-1,-1,-1):\\n            while cur.forward[level].key<target:\\n                cur = cur.forward[level]\\n            # return if target value found in next node\\n            if cur.forward[level].key==target:\\n                return True\\n        return False\\n\\n    def add(self, num: int) -> None:\\n        # getting the predecessors to num value at each available level\\n        update = self.getUpdatePredecessors(num)\\n        \\n        # getting the next node to it\\'s predecessor at the lowest level i.e. 0\\n        cur = update[0].forward[0] \\n        \\n        if cur.key==num: # num already exists, \\n            # just increments it\\'s count\\n            cur.count+=1\\n        else:\\n            # request number of levels for this node\\n            curNodeLevel = self.randomLevel() \\n            \\n            if curNodeLevel>self.curMaxLevelInList: # if the number of levels is greater than the current max\\n                # no actual nodes exist at this level\\n                # for all levels above current max levels predecessor is head\\n                for level in range(self.curMaxLevelInList,curNodeLevel):\\n                    update[level]=self.head\\n                \\n                # updating the max number of levels in the list\\n                self.curMaxLevelInList = curNodeLevel\\n            \\n            # Finally create the node to be inserted\\n            cur = SkipNode(curNodeLevel,num)\\n            \\n            # Inserting node by appointing the next node \\n            # after it\\'s predecessor, to it\\'s own next node\\n            # and predecessor\\'s node \\n            for level in range(curNodeLevel):\\n                cur.forward[level] = update[level].forward[level]\\n                update[level].forward[level] = cur\\n        \\n    def erase(self, num: int) -> bool:\\n        # getting the predecessors to num value at each available level\\n        update = self.getUpdatePredecessors(num)\\n        \\n        # getting the next node to it\\'s predecessor at the lowest level i.e. 0\\n        cur = update[0].forward[0]\\n        \\n        if cur.key!=num: # num value does not exist in the skiplis\\n            return False\\n        else:\\n            \\n            if cur.count>1: # if there are multiple instances of the num value\\n                # Delete any one and reduce counter\\n                cur.count-=1\\n            else:\\n                # Iterate through all levels, and \\n                for level in range(self.curMaxLevelInList):\\n                    # Stop at the level when the node does not exist\\n                    if update[level].forward[level]!=cur: \\n                        break\\n                    update[level].forward[level] = cur.forward[level]\\n                \\n                # Delete Node to free memory\\n                del cur\\n                \\n                # For all levels where no nodes exist now, \\n                # i.e. dummy head points to dummy tail\\n                # reducing max level count in the list\\n                while self.curMaxLevelInList>1 and self.head.forward[self.curMaxLevelInList-1]==self.tail:\\n                    self.curMaxLevelInList-=1\\n            \\n            return True # Since num value was found\\n    \\n    # getting predecessors at each level before the target val \\n    # which need to be updated\\n    def getUpdatePredecessors(self,target):\\n        update = [None]*self.maxLevel\\n       \\n        # Apply similar rountine to search \\n        # but here we keep predecessor at the ach level in update\\n        cur = self.head\\n        for level in range(self.curMaxLevelInList-1,-1,-1):\\n            while cur.forward[level].key<target:\\n                cur = cur.forward[level]\\n            update[level] = cur\\n        return update\\n        \\n    \\n    def randomLevel(self):\\n\\t\\t# Atleast present in one level\\n        level = 1\\n\\t\\t# Random.random produces number in range (0,1)\\n\\t\\t# Only producing more levels until we are less that max number of levels allowed in the skip list\\n        while random.random()<self.p and level<min(self.maxLevel,self.curMaxLevelInList+1):\\n            level+=1\\n        return level\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332520,
                "title": "java-skiplist-with-resizing-array-and-fixed-the-dice-implement-based-on-research-paper",
                "content": "Fix the dice\\nIf we generate a random level that is more than one greater than the current maximum level in the list, we simply use one plus the current maximum level in the list as\\nthe level of the new node. In practice and intuitively, this change seems to work well. However, it totally destroys our ability to analyze the resulting algorithms, since the level of\\na node is no longer completely random. Programmers should probably feel free to implement this, purists should avoid it.\\n\\nreferences:\\nhttps://www.cl.cam.ac.uk/teaching/2005/Algorithms/skiplists.pdf\\nhttps://docs.microsoft.com/en-us/previous-versions/ms379573(v=vs.80)?redirectedfrom=MSDN\\n```\\nclass Skiplist {\\n    private static final int INIT_CAPACITY = 8;\\n    private final int MIN_BOUNDARY;     // lower boundary of headCapacity\\n    private final int MAX_LEVEL = 14;  // 2 ^ h = # of elements, where h is optimal maximum level, when P = 0.5\\n    private final double P = 0.5;\\n    private final Node head;\\n    private int headCapacity;\\n    private int headLevel = 0;\\n    \\n    private class Node {\\n        private final int val;\\n        private Node[] next;\\n               \\n        private Node(int val, int level) {\\n            this.val = val;\\n            next = new Node[level];\\n        }\\n    }\\n\\n    public Skiplist() {\\n        this(INIT_CAPACITY);\\n    }\\n    \\n    public Skiplist(int size) {\\n        if (size == 0) throw new IllegalArgumentException(\"size should be greater than 0\");\\n\\t\\tif (size < INIT_CAPACITY) size = INIT_CAPACITY;\\n\\t\\tMIN_BOUNDARY = size/2;\\n\\t\\theadCapacity = size;\\n\\t\\thead = new Node(0, size);\\n    }\\n    \\n    public boolean search(int target) {\\n        Node curr = head;\\n        for (int i = headLevel-1; i >= 0; i--) {\\n            while (curr.next[i] != null) {\\n                int cmp = target - curr.next[i].val;\\n                if (cmp < 0) break;\\n                else if (cmp > 0) curr = curr.next[i];\\n                else return true;                \\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public void add(int num) {\\n        Node[] update = new Node[headLevel + 1];\\n        update[headLevel] = head;\\n        buildUpdate(num, update);\\n        \\n        int level = getRandomLevel();\\n        if (level > headLevel) {\\n            if (headLevel == headCapacity) resizeHead(2 * headCapacity);\\n            headLevel++;\\n        }\\n        \\n        Node x = new Node(num, level);\\n        for (int i = 0; i < level; i++) {\\n            Node n = update[i].next[i];\\n            update[i].next[i] = x;\\n            x.next[i] = n;\\n        }\\n    }\\n    \\n    public boolean erase(int num) {\\n        if (headLevel == 0) return false;\\n        Node[] update = new Node[headLevel];\\n        buildUpdate(num, update);\\n        if (update[0].next[0] == null || update[0].next[0].val != num) return false;\\n        \\n        for (int i = 0; i < headLevel; i++) {\\n            if (update[i].next[i] == null || update[i].next[i].val != num) break;\\n            update[i].next[i] = update[i].next[i].next[i];\\n        }\\n        \\n        if (head.next[headLevel-1] == null && --headLevel >= MIN_BOUNDARY && headLevel == headCapacity/4) resizeHead(headCapacity/2);\\n        return true;\\n    }\\n    \\n    private void buildUpdate(int x, Node[] update) {\\n        Node curr = head;\\n        for (int i = headLevel - 1; i >= 0; i--) {\\n            while (curr.next[i] != null && curr.next[i].val < x)\\n                curr = curr.next[i];\\n            update[i] = curr;\\n        }\\n    }\\n    \\n    // fixed the dice: generate a random level that is more than one greater than the current level\\n    private int getRandomLevel() {\\n        int level = 1, limit = Math.min(MAX_LEVEL, headLevel + 1);\\n        while (Math.random() < P && level < limit) level++;\\n        return level;\\n    }\\n    \\n    // resize head level\\n    private void resizeHead(int size) {\\n        Node[] copy = new Node[size];\\n        System.arraycopy(head.next, 0, copy, 0, headLevel);\\n        head.next = copy;\\n        headCapacity = size;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Skiplist {\\n    private static final int INIT_CAPACITY = 8;\\n    private final int MIN_BOUNDARY;     // lower boundary of headCapacity\\n    private final int MAX_LEVEL = 14;  // 2 ^ h = # of elements, where h is optimal maximum level, when P = 0.5\\n    private final double P = 0.5;\\n    private final Node head;\\n    private int headCapacity;\\n    private int headLevel = 0;\\n    \\n    private class Node {\\n        private final int val;\\n        private Node[] next;\\n               \\n        private Node(int val, int level) {\\n            this.val = val;\\n            next = new Node[level];\\n        }\\n    }\\n\\n    public Skiplist() {\\n        this(INIT_CAPACITY);\\n    }\\n    \\n    public Skiplist(int size) {\\n        if (size == 0) throw new IllegalArgumentException(\"size should be greater than 0\");\\n\\t\\tif (size < INIT_CAPACITY) size = INIT_CAPACITY;\\n\\t\\tMIN_BOUNDARY = size/2;\\n\\t\\theadCapacity = size;\\n\\t\\thead = new Node(0, size);\\n    }\\n    \\n    public boolean search(int target) {\\n        Node curr = head;\\n        for (int i = headLevel-1; i >= 0; i--) {\\n            while (curr.next[i] != null) {\\n                int cmp = target - curr.next[i].val;\\n                if (cmp < 0) break;\\n                else if (cmp > 0) curr = curr.next[i];\\n                else return true;                \\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public void add(int num) {\\n        Node[] update = new Node[headLevel + 1];\\n        update[headLevel] = head;\\n        buildUpdate(num, update);\\n        \\n        int level = getRandomLevel();\\n        if (level > headLevel) {\\n            if (headLevel == headCapacity) resizeHead(2 * headCapacity);\\n            headLevel++;\\n        }\\n        \\n        Node x = new Node(num, level);\\n        for (int i = 0; i < level; i++) {\\n            Node n = update[i].next[i];\\n            update[i].next[i] = x;\\n            x.next[i] = n;\\n        }\\n    }\\n    \\n    public boolean erase(int num) {\\n        if (headLevel == 0) return false;\\n        Node[] update = new Node[headLevel];\\n        buildUpdate(num, update);\\n        if (update[0].next[0] == null || update[0].next[0].val != num) return false;\\n        \\n        for (int i = 0; i < headLevel; i++) {\\n            if (update[i].next[i] == null || update[i].next[i].val != num) break;\\n            update[i].next[i] = update[i].next[i].next[i];\\n        }\\n        \\n        if (head.next[headLevel-1] == null && --headLevel >= MIN_BOUNDARY && headLevel == headCapacity/4) resizeHead(headCapacity/2);\\n        return true;\\n    }\\n    \\n    private void buildUpdate(int x, Node[] update) {\\n        Node curr = head;\\n        for (int i = headLevel - 1; i >= 0; i--) {\\n            while (curr.next[i] != null && curr.next[i].val < x)\\n                curr = curr.next[i];\\n            update[i] = curr;\\n        }\\n    }\\n    \\n    // fixed the dice: generate a random level that is more than one greater than the current level\\n    private int getRandomLevel() {\\n        int level = 1, limit = Math.min(MAX_LEVEL, headLevel + 1);\\n        while (Math.random() < P && level < limit) level++;\\n        return level;\\n    }\\n    \\n    // resize head level\\n    private void resizeHead(int size) {\\n        Node[] copy = new Node[size];\\n        System.arraycopy(head.next, 0, copy, 0, headLevel);\\n        head.next = copy;\\n        headCapacity = size;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1177629,
                "title": "python3-code-with-level-handler",
                "content": "python3 code with level handler. It can add level or remove level itself.\\nLeft and right are walls with -infinity and +infinity value\\n```\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.next = None\\n        self.down = None\\n        \\ndef flip_coin():\\n    coin = random.random()\\n    if coin >= 0.5:\\n        return True\\n    else:\\n        return False\\n        \\nclass Skiplist:\\n\\n    def __init__(self):\\n        self.left = []\\n        self.right = []\\n        self._add_level()\\n        self.head = self.left[-1]\\n        self.cnt = 0\\n        \\n    def _add_level(self):\\n        if not self.left:\\n            self.left.append(Node(-float(\"inf\")))\\n            self.right.append(Node(float(\"inf\")))\\n            self.left[-1].next = self.right[-1]\\n        else:\\n            self.left.append(Node(-float(\"inf\")))\\n            self.right.append(Node(float(\"inf\")))\\n            self.left[-1].next = self.right[-1]\\n            self.left[-1].down = self.left[-2]\\n            self.right[-1].down = self.right[-2]\\n    \\n    def _del_level(self):\\n        while self.left[-1].next == self.right[-1]:\\n            self.left.pop()\\n            self.right.pop()\\n        if not self.left:\\n            self._add_level()\\n\\n    def search(self, target: int) -> bool:\\n        cur = self.head\\n        while cur:\\n            if cur.next.val < target:\\n                cur = cur.next\\n            elif cur.next.val > target:\\n                cur = cur.down\\n            else:\\n                return True\\n        return False\\n                         \\n    def add(self, num: int) -> None:\\n        self.cnt += 1\\n        max_level = int(math.log(self.cnt, 2)) + 1\\n        while max_level > len(self.left):\\n            self._add_level()\\n        # redirect head\\n        self.head = self.left[-1]\\n        path = []\\n        # find position\\n        cur = self.head\\n        while cur:\\n            if cur.next.val < num:\\n                cur = cur.next\\n            elif cur.next.val >= num:\\n                path.append(cur)\\n                cur = cur.down\\n        # add 1st level \\n        # c: current node, n: next node, d: downside node\\n        c = path.pop()\\n        n = c.next\\n        c.next = Node(num)\\n        c.next.next = n\\n        d = c.next\\n        # add other levels\\n        while path:\\n            if flip_coin():\\n                c = path.pop()\\n                n = c.next\\n                c.next = Node(num)\\n                c.next.next = n\\n                c.next.down = d\\n                d = c.next\\n            else:\\n                break\\n     \\n    def erase(self, num: int) -> bool:\\n        self.cnt -= 1\\n        max_level = int(math.log(self.cnt, 2)) + 1\\n        self._del_level()\\n        self.head = self.left[-1]\\n        # find node\\n        cur = self.head\\n        while cur:\\n            res = False\\n            if cur.next.val < num:\\n                cur = cur.next\\n            elif cur.next.val > num:\\n                cur = cur.down\\n            else:\\n                res = True\\n                cur.next = cur.next.next\\n                cur = cur.down\\n        return res\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.next = None\\n        self.down = None\\n        \\ndef flip_coin():\\n    coin = random.random()\\n    if coin >= 0.5:\\n        return True\\n    else:\\n        return False\\n        \\nclass Skiplist:\\n\\n    def __init__(self):\\n        self.left = []\\n        self.right = []\\n        self._add_level()\\n        self.head = self.left[-1]\\n        self.cnt = 0\\n        \\n    def _add_level(self):\\n        if not self.left:\\n            self.left.append(Node(-float(\"inf\")))\\n            self.right.append(Node(float(\"inf\")))\\n            self.left[-1].next = self.right[-1]\\n        else:\\n            self.left.append(Node(-float(\"inf\")))\\n            self.right.append(Node(float(\"inf\")))\\n            self.left[-1].next = self.right[-1]\\n            self.left[-1].down = self.left[-2]\\n            self.right[-1].down = self.right[-2]\\n    \\n    def _del_level(self):\\n        while self.left[-1].next == self.right[-1]:\\n            self.left.pop()\\n            self.right.pop()\\n        if not self.left:\\n            self._add_level()\\n\\n    def search(self, target: int) -> bool:\\n        cur = self.head\\n        while cur:\\n            if cur.next.val < target:\\n                cur = cur.next\\n            elif cur.next.val > target:\\n                cur = cur.down\\n            else:\\n                return True\\n        return False\\n                         \\n    def add(self, num: int) -> None:\\n        self.cnt += 1\\n        max_level = int(math.log(self.cnt, 2)) + 1\\n        while max_level > len(self.left):\\n            self._add_level()\\n        # redirect head\\n        self.head = self.left[-1]\\n        path = []\\n        # find position\\n        cur = self.head\\n        while cur:\\n            if cur.next.val < num:\\n                cur = cur.next\\n            elif cur.next.val >= num:\\n                path.append(cur)\\n                cur = cur.down\\n        # add 1st level \\n        # c: current node, n: next node, d: downside node\\n        c = path.pop()\\n        n = c.next\\n        c.next = Node(num)\\n        c.next.next = n\\n        d = c.next\\n        # add other levels\\n        while path:\\n            if flip_coin():\\n                c = path.pop()\\n                n = c.next\\n                c.next = Node(num)\\n                c.next.next = n\\n                c.next.down = d\\n                d = c.next\\n            else:\\n                break\\n     \\n    def erase(self, num: int) -> bool:\\n        self.cnt -= 1\\n        max_level = int(math.log(self.cnt, 2)) + 1\\n        self._del_level()\\n        self.head = self.left[-1]\\n        # find node\\n        cur = self.head\\n        while cur:\\n            res = False\\n            if cur.next.val < num:\\n                cur = cur.next\\n            elif cur.next.val > num:\\n                cur = cur.down\\n            else:\\n                res = True\\n                cur.next = cur.next.next\\n                cur = cur.down\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123450,
                "title": "c-skiplist",
                "content": "```\\nstruct Node{\\n    int val;\\n    Node* next;\\n    Node* prev;//previous level\\n    Node(int vali)\\n    {\\n        val = vali;\\n        next = prev = NULL;   \\n    }\\n};\\nclass Skiplist {\\n    vector<Node*> head;    \\npublic:\\n    Skiplist() {\\n        head.push_back(new Node(-100000000));//safe guarder\\n    }\\n    \\n    bool searchImpl(int target, vector<Node*>& pos, bool setpos = false) {\\n        bool res = false;\\n        int i=head.size()-1;\\n        pos.resize(head.size());\\n        Node* tmp = head[i], *prev = NULL;\\n        while(i >= 0)\\n        {\\n            while(tmp !=NULL && tmp->val < target)\\n            {\\n                prev = tmp;\\n                tmp=tmp->next;\\n            }\\n            if (tmp != NULL && tmp->val == target)\\n            {\\n                res = true;\\n                if (!setpos)\\n                    return true;\\n            }\\n            \\n            if (setpos) pos[i] = prev;\\n            tmp = prev->prev;\\n            i--;\\n        }\\n        return res;\\n    }\\n    \\n    bool search(int target) {\\n        vector<Node*> pos;\\n        return searchImpl(target, pos);\\n    }\\n    \\n    void add(int num) {\\n        vector<Node*> pos;\\n        searchImpl(num, pos, true);\\n        int i = 0;\\n        Node* prevpos = NULL;\\n        while(i<pos.size())\\n        { \\n            auto add = new Node(num);\\n            add->next = pos[i]->next;  \\n            pos[i]->next = add;\\n            add->prev = prevpos;\\n            prevpos = add;\\n            if (rand() < (RAND_MAX / 2))\\n                break;\\n            i++;\\n        }\\n        if (i==pos.size() && rand() < (RAND_MAX / 2))\\n        {\\n            head.push_back(new Node(head[0]->val));\\n            if (head.size() >= 2)\\n                head[head.size()-1]->prev = head[head.size()-2];\\n        }\\n    }\\n    \\n    bool erase(int num) {\\n        vector<Node*> pos;\\n        bool res = searchImpl(num, pos, true);   \\n        if (!res) return false;\\n        else\\n        {\\n            int i=0;\\n            while(i<pos.size())\\n            {\\n                auto tmp = pos[i]->next;\\n                if (pos[i]->next != NULL)\\n                    pos[i]->next = pos[i]->next->next;   \\n                else\\n                    pos[i]->next = NULL;\\n                delete tmp;\\n                if (head[i]->next == NULL)\\n                {\\n                    delete head[i];\\n                    head.pop_back();\\n                }\\n                i++;\\n            }\\n            return true;\\n        }    \\n    }\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Node{\\n    int val;\\n    Node* next;\\n    Node* prev;//previous level\\n    Node(int vali)\\n    {\\n        val = vali;\\n        next = prev = NULL;   \\n    }\\n};\\nclass Skiplist {\\n    vector<Node*> head;    \\npublic:\\n    Skiplist() {\\n        head.push_back(new Node(-100000000));//safe guarder\\n    }\\n    \\n    bool searchImpl(int target, vector<Node*>& pos, bool setpos = false) {\\n        bool res = false;\\n        int i=head.size()-1;\\n        pos.resize(head.size());\\n        Node* tmp = head[i], *prev = NULL;\\n        while(i >= 0)\\n        {\\n            while(tmp !=NULL && tmp->val < target)\\n            {\\n                prev = tmp;\\n                tmp=tmp->next;\\n            }\\n            if (tmp != NULL && tmp->val == target)\\n            {\\n                res = true;\\n                if (!setpos)\\n                    return true;\\n            }\\n            \\n            if (setpos) pos[i] = prev;\\n            tmp = prev->prev;\\n            i--;\\n        }\\n        return res;\\n    }\\n    \\n    bool search(int target) {\\n        vector<Node*> pos;\\n        return searchImpl(target, pos);\\n    }\\n    \\n    void add(int num) {\\n        vector<Node*> pos;\\n        searchImpl(num, pos, true);\\n        int i = 0;\\n        Node* prevpos = NULL;\\n        while(i<pos.size())\\n        { \\n            auto add = new Node(num);\\n            add->next = pos[i]->next;  \\n            pos[i]->next = add;\\n            add->prev = prevpos;\\n            prevpos = add;\\n            if (rand() < (RAND_MAX / 2))\\n                break;\\n            i++;\\n        }\\n        if (i==pos.size() && rand() < (RAND_MAX / 2))\\n        {\\n            head.push_back(new Node(head[0]->val));\\n            if (head.size() >= 2)\\n                head[head.size()-1]->prev = head[head.size()-2];\\n        }\\n    }\\n    \\n    bool erase(int num) {\\n        vector<Node*> pos;\\n        bool res = searchImpl(num, pos, true);   \\n        if (!res) return false;\\n        else\\n        {\\n            int i=0;\\n            while(i<pos.size())\\n            {\\n                auto tmp = pos[i]->next;\\n                if (pos[i]->next != NULL)\\n                    pos[i]->next = pos[i]->next->next;   \\n                else\\n                    pos[i]->next = NULL;\\n                delete tmp;\\n                if (head[i]->next == NULL)\\n                {\\n                    delete head[i];\\n                    head.pop_back();\\n                }\\n                i++;\\n            }\\n            return true;\\n        }    \\n    }\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 926207,
                "title": "python-skip-list-class-with-resource",
                "content": "Before this problem, I was not familiar with skip lists.  \\nFor anyone else who is new to skip lists I will leave a resource that I found helpful in the comments below.  \\n\\n```python\\nclass Node(object):\\n    def __init__(self, val):\\n        self.val = val\\n        self.right = None\\n        self.left = None\\n        self.up = None\\n        self.down = None\\n\\nclass Skiplist(object):\\n    \\n    def __init__(self):\\n        self.memo = collections.Counter()  # Stores a count of all numbers in the skip list\\n        self.root = Node(-math.inf)        # Starting node for all searches (top-left of the skip-list)\\n        self.root.right = Node(math.inf)   # Ending node (Nil in the description picture)\\n        self.height = 1                    # Maximum level (bounded at log2(len(memo)))\\n\\n    def search(self, target: int) -> bool:\\n        \\'\\'\\'Returns True if target is in the skip list\\'\\'\\'\\n        return self.memo[target] > 0\\n        \\n    def find(self, num):\\n        \\'\\'\\'Returns path of nodes to reach the largest node that is <= num\\'\\'\\'\\n        path = [self.root]\\n        curr = self.root\\n        while (curr.right and curr.right.val <= num) or curr.down:\\n            curr = curr.right if curr.right else curr.down\\n            path.append(curr)\\n        return path\\n                \\n    def add(self, num):\\n        \\'\\'\\'\\n        If the number IS NOT in the skip list: inserts number into the skip list\\n        If the number IS in the skip list: increases memo[num] by one and does nothing else         \\n        \\'\\'\\'\\n        self.memo[num] += 1\\n        \\n        # don\\'t put repeat values into the skip list\\n        if self.memo[num] > 1:\\n            return None\\n        \\n        path = self.find(num)\\n        \\n        # Insert num to the right of each node in path\\n        next_node = None\\n        while path:\\n            # Insert num\\n            node = Node(num) if (next_node is None) else next_node\\n            prev = path.pop()\\n            node.right = prev.right\\n            node.left = prev\\n            prev.right = node\\n            if node.right: node.right.left = node\\n            \\n            # Flip Coin (heads [0,0.25], tails [0.25,1])\\n            if random.random() <= 0.25:\\n                next_node = Node(num)\\n                node.up = next_node\\n                next_node.down = node\\n            else:\\n                break\\n        else:\\n            # Do not increase the height of the skip-list beyond log2 the length of the skip-list\\n            max_height = int(math.log2(len(self.memo)))\\n            while (self.height <= max_height) and (random.random() <= 0.25):\\n                self.height += 1\\n                \\n                # Add new higher level to start and to current input\\n                next_node = Node(num)\\n                node.up = next_node\\n                next_node.down = node\\n\\n                # Increase height of the root node\\n                self.root.up = Node(-math.inf)\\n                self.root.up.down = self.root\\n                self.root = self.root.up\\n                self.root.right = next_node\\n                next_node.left = self.root\\n    \\n    \\n    def erase(self, num):\\n        \\'\\'\\'\\n        If there is only one of num in the skip list, removes num from the skip list: returns True\\n        If there is MORE THAN ONE of num in the skip list, decreases memo[num] by 1: returns True\\n        If num IS NOT in the skip list: returns False\\n        \\'\\'\\'\\n        # Check if number is in the skip list\\n        if self.memo[num] == 0:\\n            return False\\n        \\n        # Reduce the count for num by 1\\n        self.memo[num] -= 1\\n        \\n        # if memo[num] != 0 don\\'t delete it from the skip list\\n        if self.memo[num] >= 1:\\n            return True\\n        \\n        # Find node to be removed\\n        node = self.find(num)[-1]\\n        \\n        # Remove the lowest node first, then all of the nodes stacked directly above it\\n        while node and node.left:\\n            node.left.right = node.right\\n            if node.right:\\n                node.right.left = node.left\\n            if node.up:\\n                node = node.up\\n                node.down = None\\n            else:\\n                node = None\\n        \\n        return True\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Node(object):\\n    def __init__(self, val):\\n        self.val = val\\n        self.right = None\\n        self.left = None\\n        self.up = None\\n        self.down = None\\n\\nclass Skiplist(object):\\n    \\n    def __init__(self):\\n        self.memo = collections.Counter()  # Stores a count of all numbers in the skip list\\n        self.root = Node(-math.inf)        # Starting node for all searches (top-left of the skip-list)\\n        self.root.right = Node(math.inf)   # Ending node (Nil in the description picture)\\n        self.height = 1                    # Maximum level (bounded at log2(len(memo)))\\n\\n    def search(self, target: int) -> bool:\\n        \\'\\'\\'Returns True if target is in the skip list\\'\\'\\'\\n        return self.memo[target] > 0\\n        \\n    def find(self, num):\\n        \\'\\'\\'Returns path of nodes to reach the largest node that is <= num\\'\\'\\'\\n        path = [self.root]\\n        curr = self.root\\n        while (curr.right and curr.right.val <= num) or curr.down:\\n            curr = curr.right if curr.right else curr.down\\n            path.append(curr)\\n        return path\\n                \\n    def add(self, num):\\n        \\'\\'\\'\\n        If the number IS NOT in the skip list: inserts number into the skip list\\n        If the number IS in the skip list: increases memo[num] by one and does nothing else         \\n        \\'\\'\\'\\n        self.memo[num] += 1\\n        \\n        # don\\'t put repeat values into the skip list\\n        if self.memo[num] > 1:\\n            return None\\n        \\n        path = self.find(num)\\n        \\n        # Insert num to the right of each node in path\\n        next_node = None\\n        while path:\\n            # Insert num\\n            node = Node(num) if (next_node is None) else next_node\\n            prev = path.pop()\\n            node.right = prev.right\\n            node.left = prev\\n            prev.right = node\\n            if node.right: node.right.left = node\\n            \\n            # Flip Coin (heads [0,0.25], tails [0.25,1])\\n            if random.random() <= 0.25:\\n                next_node = Node(num)\\n                node.up = next_node\\n                next_node.down = node\\n            else:\\n                break\\n        else:\\n            # Do not increase the height of the skip-list beyond log2 the length of the skip-list\\n            max_height = int(math.log2(len(self.memo)))\\n            while (self.height <= max_height) and (random.random() <= 0.25):\\n                self.height += 1\\n                \\n                # Add new higher level to start and to current input\\n                next_node = Node(num)\\n                node.up = next_node\\n                next_node.down = node\\n\\n                # Increase height of the root node\\n                self.root.up = Node(-math.inf)\\n                self.root.up.down = self.root\\n                self.root = self.root.up\\n                self.root.right = next_node\\n                next_node.left = self.root\\n    \\n    \\n    def erase(self, num):\\n        \\'\\'\\'\\n        If there is only one of num in the skip list, removes num from the skip list: returns True\\n        If there is MORE THAN ONE of num in the skip list, decreases memo[num] by 1: returns True\\n        If num IS NOT in the skip list: returns False\\n        \\'\\'\\'\\n        # Check if number is in the skip list\\n        if self.memo[num] == 0:\\n            return False\\n        \\n        # Reduce the count for num by 1\\n        self.memo[num] -= 1\\n        \\n        # if memo[num] != 0 don\\'t delete it from the skip list\\n        if self.memo[num] >= 1:\\n            return True\\n        \\n        # Find node to be removed\\n        node = self.find(num)[-1]\\n        \\n        # Remove the lowest node first, then all of the nodes stacked directly above it\\n        while node and node.left:\\n            node.left.right = node.right\\n            if node.right:\\n                node.right.left = node.left\\n            if node.up:\\n                node = node.up\\n                node.down = None\\n            else:\\n                node = None\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 661556,
                "title": "simple-c-solution",
                "content": "```\\nclass Skiplist{\\n\\tstruct Node{\\n\\t\\tint value;\\n\\t\\tNode** next;\\n\\t\\tNode(int val, short levels) : value(val){\\n\\t\\t\\tnext = new Node * [levels>0?levels:1];\\n\\t\\t\\tfill_n(next, levels, nullptr);\\n\\t\\t}\\n\\t\\t~Node(){\\n\\t\\t\\tdelete[] next;\\n\\t\\t}\\n\\t};\\n\\n\\tNode* head;\\n\\tshort levels;\\n\\t\\n    public:\\n\\tSkiplist() {\\n\\t\\tlevels = 1;\\n\\t\\thead = new Node(INT_MIN, 1);\\n\\t}\\n\\n\\tbool search(int target) {\\n\\t\\tNode* cur = head;\\n\\t\\tshort i = levels - 1;\\n\\t\\tfor (; i >= 0; i--){\\n\\t\\t\\twhile (cur->next[i] != nullptr && cur->next[i]->value < target)\\n\\t\\t\\t\\tcur = cur->next[i];\\n\\t\\t}\\n\\t\\tcur = cur->next[0];\\n\\t\\tif (cur != nullptr && cur->value == target)\\n\\t\\t\\treturn true;\\n\\t\\treturn false;\\n\\t}\\n\\n\\tstatic void seedRandomGenerator();\\n\\n\\tshort generateRandomLevels(){\\n\\t\\tshort l = 1;\\n\\t\\tseedRandomGenerator();\\n\\t\\twhile (rand() % 2 == 0) l++;\\n\\t\\treturn l;\\n\\t}\\n\\n\\tvoid add(int num) {\\n\\t\\tNode* cur = head;\\n\\t\\tshort l = generateRandomLevels();\\n\\t\\tauto* nodeToInsert = new Node(num, l);\\n\\n\\t\\tNode** update = new Node * [levels];\\n\\t\\tfill_n(update, levels, nullptr );\\n\\t\\tfor (short i = levels - 1; i >= 0; i--){\\n\\t\\t\\twhile (cur->next[i] != nullptr && cur->next[i]->value < num)\\n\\t\\t\\t\\tcur = cur->next[i];\\n\\t\\t\\tupdate[i] = cur;\\n\\t\\t}\\n\\t\\tfor (short i = 0; i < (min(levels,l)); i++){\\n\\t\\t\\tif (update[i] != nullptr){\\n\\t\\t\\t\\tnodeToInsert->next[i] = update[i]->next[i];\\n\\t\\t\\t\\tupdate[i]->next[i] = nodeToInsert;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (l > levels){\\n\\t\\t\\tcur = new Node(INT_MIN, l);\\n\\t\\t\\tfill_n(cur->next, l, nodeToInsert);\\n\\t\\t\\tfor (short i = 0; i < levels; i++){\\n\\t\\t\\t\\tcur->next[i] = head->next[i];\\n\\t\\t\\t\\thead->next[i] = nullptr;\\n\\t\\t\\t}\\n\\t\\t\\tdelete head;\\n\\t\\t\\thead = cur;\\n\\t\\t\\tlevels = l;\\n\\t\\t}\\n\\t\\tdelete[] update;\\n\\t}\\n\\n\\tbool erase(int num) {\\n\\t\\tNode* cur = head;\\n\\t\\tNode** update = new Node * [levels];\\n\\t\\tfill_n(update, levels, nullptr);\\n\\n\\t\\tfor (short i = levels - 1; i >= 0; i--){\\n\\t\\t\\twhile (cur->next[i] != nullptr && cur->next[i]->value < num)\\n\\t\\t\\t\\tcur = cur->next[i];\\n\\t\\t\\tupdate[i] = cur;\\n\\t\\t}\\n\\t\\tNode* nodeToDel = cur->next[0];\\n\\t\\tif (nodeToDel != nullptr && nodeToDel->value == num){\\n\\t\\t\\tfor (short i = levels-1; i>=0; i--){\\n\\t\\t\\t\\tif (update[i]->next[i] != cur->next[0])\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tupdate[i]->next[i] = update[i]->next[i]->next[i];\\n\\t\\t\\t\\tupdate[i] = nullptr;\\n\\t\\t\\t\\tnodeToDel->next[i] = nullptr;\\n\\t\\t\\t}\\n\\t\\t\\tfor (short i = levels - 1; i >= 0; i--){\\n\\t\\t\\t\\tif (head->next[i] != nullptr)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tlevels--;\\n\\t\\t\\t}\\n\\t\\t\\tdelete nodeToDel;\\n\\t\\t\\tdelete[] update;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tdelete[] update;\\n\\t\\treturn false;\\n\\t}\\n\\n\\tvoid printAll(){\\n\\t\\tfor (short i = levels - 1; i >= 0; i--){\\n\\t\\t\\tNode* cur = head->next[i];\\n\\t\\t\\twhile (cur != nullptr){\\n\\t\\t\\t\\tcur = cur->next[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n\\nvoid Skiplist::seedRandomGenerator(){\\n\\tstatic bool isSeeded = false;\\n\\tif (!isSeeded){\\n\\t\\tisSeeded = true;\\n\\t\\tsrand(chrono::system_clock::now().time_since_epoch().count());\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Skiplist{\\n\\tstruct Node{\\n\\t\\tint value;\\n\\t\\tNode** next;\\n\\t\\tNode(int val, short levels) : value(val){\\n\\t\\t\\tnext = new Node * [levels>0?levels:1];\\n\\t\\t\\tfill_n(next, levels, nullptr);\\n\\t\\t}\\n\\t\\t~Node(){\\n\\t\\t\\tdelete[] next;\\n\\t\\t}\\n\\t};\\n\\n\\tNode* head;\\n\\tshort levels;\\n\\t\\n    public:\\n\\tSkiplist() {\\n\\t\\tlevels = 1;\\n\\t\\thead = new Node(INT_MIN, 1);\\n\\t}\\n\\n\\tbool search(int target) {\\n\\t\\tNode* cur = head;\\n\\t\\tshort i = levels - 1;\\n\\t\\tfor (; i >= 0; i--){\\n\\t\\t\\twhile (cur->next[i] != nullptr && cur->next[i]->value < target)\\n\\t\\t\\t\\tcur = cur->next[i];\\n\\t\\t}\\n\\t\\tcur = cur->next[0];\\n\\t\\tif (cur != nullptr && cur->value == target)\\n\\t\\t\\treturn true;\\n\\t\\treturn false;\\n\\t}\\n\\n\\tstatic void seedRandomGenerator();\\n\\n\\tshort generateRandomLevels(){\\n\\t\\tshort l = 1;\\n\\t\\tseedRandomGenerator();\\n\\t\\twhile (rand() % 2 == 0) l++;\\n\\t\\treturn l;\\n\\t}\\n\\n\\tvoid add(int num) {\\n\\t\\tNode* cur = head;\\n\\t\\tshort l = generateRandomLevels();\\n\\t\\tauto* nodeToInsert = new Node(num, l);\\n\\n\\t\\tNode** update = new Node * [levels];\\n\\t\\tfill_n(update, levels, nullptr );\\n\\t\\tfor (short i = levels - 1; i >= 0; i--){\\n\\t\\t\\twhile (cur->next[i] != nullptr && cur->next[i]->value < num)\\n\\t\\t\\t\\tcur = cur->next[i];\\n\\t\\t\\tupdate[i] = cur;\\n\\t\\t}\\n\\t\\tfor (short i = 0; i < (min(levels,l)); i++){\\n\\t\\t\\tif (update[i] != nullptr){\\n\\t\\t\\t\\tnodeToInsert->next[i] = update[i]->next[i];\\n\\t\\t\\t\\tupdate[i]->next[i] = nodeToInsert;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (l > levels){\\n\\t\\t\\tcur = new Node(INT_MIN, l);\\n\\t\\t\\tfill_n(cur->next, l, nodeToInsert);\\n\\t\\t\\tfor (short i = 0; i < levels; i++){\\n\\t\\t\\t\\tcur->next[i] = head->next[i];\\n\\t\\t\\t\\thead->next[i] = nullptr;\\n\\t\\t\\t}\\n\\t\\t\\tdelete head;\\n\\t\\t\\thead = cur;\\n\\t\\t\\tlevels = l;\\n\\t\\t}\\n\\t\\tdelete[] update;\\n\\t}\\n\\n\\tbool erase(int num) {\\n\\t\\tNode* cur = head;\\n\\t\\tNode** update = new Node * [levels];\\n\\t\\tfill_n(update, levels, nullptr);\\n\\n\\t\\tfor (short i = levels - 1; i >= 0; i--){\\n\\t\\t\\twhile (cur->next[i] != nullptr && cur->next[i]->value < num)\\n\\t\\t\\t\\tcur = cur->next[i];\\n\\t\\t\\tupdate[i] = cur;\\n\\t\\t}\\n\\t\\tNode* nodeToDel = cur->next[0];\\n\\t\\tif (nodeToDel != nullptr && nodeToDel->value == num){\\n\\t\\t\\tfor (short i = levels-1; i>=0; i--){\\n\\t\\t\\t\\tif (update[i]->next[i] != cur->next[0])\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tupdate[i]->next[i] = update[i]->next[i]->next[i];\\n\\t\\t\\t\\tupdate[i] = nullptr;\\n\\t\\t\\t\\tnodeToDel->next[i] = nullptr;\\n\\t\\t\\t}\\n\\t\\t\\tfor (short i = levels - 1; i >= 0; i--){\\n\\t\\t\\t\\tif (head->next[i] != nullptr)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tlevels--;\\n\\t\\t\\t}\\n\\t\\t\\tdelete nodeToDel;\\n\\t\\t\\tdelete[] update;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tdelete[] update;\\n\\t\\treturn false;\\n\\t}\\n\\n\\tvoid printAll(){\\n\\t\\tfor (short i = levels - 1; i >= 0; i--){\\n\\t\\t\\tNode* cur = head->next[i];\\n\\t\\t\\twhile (cur != nullptr){\\n\\t\\t\\t\\tcur = cur->next[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n\\nvoid Skiplist::seedRandomGenerator(){\\n\\tstatic bool isSeeded = false;\\n\\tif (!isSeeded){\\n\\t\\tisSeeded = true;\\n\\t\\tsrand(chrono::system_clock::now().time_since_epoch().count());\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 655413,
                "title": "rust-solution-with-tests-runs-in-24ms",
                "content": "```\\nuse core::cell::RefCell;\\nuse std::rc::Rc;\\nuse EntryRef::*;\\n\\npub struct Skiplist<T = i32>\\nwhere\\n    T: Ord,\\n    T: Copy,\\n{\\n    head: EntryRef<T>,\\n    tail: EntryRef<T>,\\n    height: usize,\\n}\\n\\n#[derive(Debug)]\\nstruct Entry<T>\\nwhere\\n    T: Ord,\\n{\\n    key: Option<T>,\\n    up: EntryRef<T>,\\n    down: EntryRef<T>,\\n    left: EntryRef<T>,\\n    right: EntryRef<T>,\\n}\\n\\nimpl<T> Entry<T>\\nwhere\\n    T: Ord,\\n{\\n    fn new(key: Option<T>) -> Self {\\n        Entry {\\n            key,\\n            up: Empty,\\n            down: Empty,\\n            left: Empty,\\n            right: Empty,\\n        }\\n    }\\n}\\n\\n#[derive(Debug)]\\nenum EntryRef<T>\\nwhere\\n    T: Ord,\\n{\\n    Any(Rc<RefCell<Entry<T>>>),\\n    Empty,\\n}\\n\\nimpl<T: std::cmp::Ord> EntryRef<T> {\\n    fn is_none(&self) -> bool {\\n        match self {\\n            Empty => true,\\n            _ => false,\\n        }\\n    }\\n\\n    fn is_some(&self) -> bool {\\n        match self {\\n            Empty => false,\\n            _ => true,\\n        }\\n    }\\n\\n    fn as_ref(&self) -> Rc<RefCell<Entry<T>>> {\\n        match self {\\n            Empty => panic!(\"Entry is none!\"),\\n            Any(reference) => Rc::clone(&reference),\\n        }\\n    }\\n}\\n\\nimpl<T: std::cmp::Ord> PartialEq for EntryRef<T> {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.is_none() && other.is_none() || Rc::ptr_eq(&self.as_ref(), &other.as_ref())\\n    }\\n}\\n\\nimpl<T: std::cmp::Ord> Clone for EntryRef<T> {\\n    fn clone(&self) -> Self {\\n        match self {\\n            Empty => Empty,\\n            Any(reference) => Any(Rc::clone(reference)),\\n        }\\n    }\\n}\\n\\nimpl<T: std::cmp::Ord> PartialEq for Entry<T> {\\n    fn eq(&self, other: &Self) -> bool {\\n        other.key == self.key\\n            && other.left == self.left\\n            && other.right == self.right\\n            && other.up == self.up\\n            && other.down == self.down\\n    }\\n}\\n\\nimpl<T> Skiplist<T>\\nwhere\\n    T: Ord,\\n    T: Copy,\\n{\\n    pub fn new() -> Self {\\n        let head = Rc::new(RefCell::new(Entry::new(None)));\\n        let tail = Rc::new(RefCell::new(Entry::new(None)));\\n\\n        head.borrow_mut().right = Any(Rc::clone(&tail));\\n        tail.borrow_mut().left = Any(Rc::clone(&head));\\n\\n        Skiplist {\\n            head: Any(head),\\n            tail: Any(tail),\\n            height: 1,\\n        }\\n    }\\n\\n    pub fn search(&self, target: T) -> bool {\\n        let entry = self.find_entry(&target);\\n        entry\\n            .as_ref()\\n            .borrow()\\n            .key\\n            .map_or(false, |key| key == target)\\n    }\\n\\n    pub fn add(&mut self, num: T) {\\n        let mut before_entry = self.find_entry(&num);\\n        let mut next_entry = before_entry.as_ref().borrow().right.clone();\\n        let mut new_entry = Any(Rc::new(RefCell::new(Entry::new(Some(num)))));\\n        let mut previous = Empty;\\n        let mut level = 1;\\n\\n        loop {\\n            new_entry.as_ref().borrow_mut().left = before_entry.clone();\\n            new_entry.as_ref().borrow_mut().right = next_entry.clone();\\n            new_entry.as_ref().borrow_mut().down = previous.clone();\\n            before_entry.as_ref().borrow_mut().right = new_entry.clone();\\n            next_entry.as_ref().borrow_mut().left = new_entry.clone();\\n\\n            if rand::random::<bool>() {\\n                if level == self.height {\\n                    let new_head = Rc::new(RefCell::new(Entry::new(None)));\\n                    let new_tail = Rc::new(RefCell::new(Entry::new(None)));\\n\\n                    new_head.borrow_mut().right = Any(Rc::clone(&new_tail));\\n                    new_head.borrow_mut().down = self.head.clone();\\n                    self.head.as_ref().borrow_mut().up = Any(Rc::clone(&new_head));\\n\\n                    new_tail.borrow_mut().left = Any(Rc::clone(&new_head));\\n                    new_tail.borrow_mut().down = self.tail.clone();\\n                    self.tail.as_ref().borrow_mut().up = Any(Rc::clone(&new_tail));\\n\\n                    self.head = Any(Rc::clone(&new_head));\\n                    self.tail = Any(Rc::clone(&new_tail));\\n                    self.height += 1;\\n                }\\n\\n                while before_entry.as_ref().borrow().up.is_none() {\\n                    before_entry = before_entry.as_ref().borrow().left.clone();\\n                }\\n                before_entry = before_entry.as_ref().borrow().up.clone();\\n\\n                while next_entry.as_ref().borrow().up.is_none() {\\n                    next_entry = next_entry.as_ref().borrow().right.clone();\\n                }\\n                next_entry = next_entry.as_ref().borrow().up.clone();\\n\\n                level += 1;\\n                previous = new_entry;\\n                new_entry = Any(Rc::new(RefCell::new(Entry::new(Some(num)))));\\n                previous.as_ref().borrow_mut().up = new_entry.clone();\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n\\n    pub fn erase(&mut self, num: T) -> bool {\\n        let mut entry = self.find_entry(&num);\\n        if !entry.as_ref().borrow().key.map_or(false, |key| key == num) {\\n            return false;\\n        }\\n\\n        while entry.is_some() {\\n            let up = entry.as_ref().borrow().up.clone();\\n            let left = entry.as_ref().borrow().left.clone();\\n            let right = entry.as_ref().borrow().right.clone();\\n\\n            left.as_ref().borrow_mut().right = right.clone();\\n            right.as_ref().borrow_mut().left = left.clone();\\n\\n            entry.as_ref().borrow_mut().down = Empty;\\n            entry.as_ref().borrow_mut().up = Empty;\\n            entry = up.clone();\\n        }\\n\\n        true\\n    }\\n\\n    fn find_entry(&self, target: &T) -> EntryRef<T> {\\n        let mut node = self.head.as_ref();\\n\\n        loop {\\n            let node_ref = Rc::clone(&node);\\n            let node_value = node_ref.borrow();\\n\\n            if node_value\\n                .right\\n                .as_ref()\\n                .borrow()\\n                .key\\n                .map_or(false, |key| &key <= target)\\n            {\\n                node = node_value.right.as_ref();\\n            } else if node_value.down.is_none() {\\n                break;\\n            } else {\\n                node = node_value.down.as_ref();\\n            }\\n        }\\n\\n        Any(node)\\n    }\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n\\n    #[test]\\n    fn create_empty_skip_list_entry() {\\n        let entry: Entry<i32> = Entry::new(None);\\n        assert!(entry.key.is_none());\\n        assert!(entry.left.is_none());\\n        assert!(entry.right.is_none());\\n        assert!(entry.up.is_none());\\n        assert!(entry.down.is_none());\\n    }\\n\\n    #[test]\\n    fn create_skip_list_entry() {\\n        let entry = Entry::new(Some(5));\\n        assert_eq!(entry.key, Some(5));\\n        assert!(entry.left.is_none());\\n        assert!(entry.right.is_none());\\n        assert!(entry.up.is_none());\\n        assert!(entry.down.is_none());\\n    }\\n\\n    #[test]\\n    fn create_skip_list() {\\n        let skiplist: Skiplist<i32> = Skiplist::new();\\n        let head = skiplist.head;\\n        let tail = skiplist.tail;\\n\\n        assert!(head.is_some());\\n        assert!(tail.is_some());\\n\\n        let head = head.as_ref();\\n        let tail = tail.as_ref();\\n\\n        assert!(head.borrow().left.is_none());\\n        assert!(head.borrow().up.is_none());\\n        assert!(head.borrow().down.is_none());\\n\\n        assert!(tail.borrow().right.is_none());\\n        assert!(tail.borrow().up.is_none());\\n        assert!(tail.borrow().down.is_none());\\n\\n        assert_eq!(head.borrow().right, Any(Rc::clone(&tail)));\\n        assert_eq!(tail.borrow().left, Any(Rc::clone(&head)));\\n    }\\n\\n    #[test]\\n    fn search_not_existing_element() {\\n        let skiplist: Skiplist<i32> = Skiplist::new();\\n        assert_eq!(skiplist.search(5), false);\\n        assert_eq!(skiplist.search(37), false);\\n        assert_eq!(skiplist.search(i32::min_value()), false);\\n        assert_eq!(skiplist.search(i32::max_value()), false);\\n    }\\n\\n    #[test]\\n    fn add_few_elements() {\\n        let mut skiplist: Skiplist<i32> = Skiplist::new();\\n\\n        assert_eq!(skiplist.search(5), false);\\n        skiplist.add(5);\\n        assert_eq!(skiplist.search(5), true);\\n\\n        assert_eq!(skiplist.search(i32::min_value()), false);\\n        skiplist.add(i32::min_value());\\n        assert_eq!(skiplist.search(i32::min_value()), true);\\n\\n        assert_eq!(skiplist.search(i32::max_value()), false);\\n        skiplist.add(i32::max_value());\\n        assert_eq!(skiplist.search(i32::max_value()), true);\\n    }\\n\\n    #[test]\\n    fn erase_not_existing() {\\n        let mut skiplist: Skiplist<i32> = Skiplist::new();\\n\\n        assert_eq!(skiplist.erase(5), false);\\n        assert_eq!(skiplist.erase(i32::max_value()), false);\\n        assert_eq!(skiplist.erase(i32::min_value()), false);\\n    }\\n\\n    #[test]\\n    fn erase_existing() {\\n        let mut skiplist: Skiplist<i32> = Skiplist::new();\\n\\n        skiplist.add(5);\\n        skiplist.add(7);\\n        skiplist.add(i32::max_value());\\n        skiplist.add(i32::min_value());\\n\\n        assert_eq!(skiplist.erase(5), true);\\n        assert_eq!(skiplist.erase(i32::max_value()), true);\\n        assert_eq!(skiplist.erase(i32::min_value()), true);\\n\\n        assert_eq!(skiplist.search(5), false);\\n        assert_eq!(skiplist.search(7), true);\\n        assert_eq!(skiplist.search(i32::max_value()), false);\\n        assert_eq!(skiplist.search(i32::min_value()), false);\\n    }\\n\\n    #[test]\\n    fn add_many_elements() {\\n        let mut skiplist: Skiplist<i32> = Skiplist::new();\\n        let elements: [i32; 30] = rand::random();\\n\\n        for &element in elements.iter() {\\n            skiplist.add(element);\\n            assert!(skiplist.search(element));\\n        }\\n\\n        for &element in elements.iter() {\\n            assert!(skiplist.search(element));\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nuse core::cell::RefCell;\\nuse std::rc::Rc;\\nuse EntryRef::*;\\n\\npub struct Skiplist<T = i32>\\nwhere\\n    T: Ord,\\n    T: Copy,\\n{\\n    head: EntryRef<T>,\\n    tail: EntryRef<T>,\\n    height: usize,\\n}\\n\\n#[derive(Debug)]\\nstruct Entry<T>\\nwhere\\n    T: Ord,\\n{\\n    key: Option<T>,\\n    up: EntryRef<T>,\\n    down: EntryRef<T>,\\n    left: EntryRef<T>,\\n    right: EntryRef<T>,\\n}\\n\\nimpl<T> Entry<T>\\nwhere\\n    T: Ord,\\n{\\n    fn new(key: Option<T>) -> Self {\\n        Entry {\\n            key,\\n            up: Empty,\\n            down: Empty,\\n            left: Empty,\\n            right: Empty,\\n        }\\n    }\\n}\\n\\n#[derive(Debug)]\\nenum EntryRef<T>\\nwhere\\n    T: Ord,\\n{\\n    Any(Rc<RefCell<Entry<T>>>),\\n    Empty,\\n}\\n\\nimpl<T: std::cmp::Ord> EntryRef<T> {\\n    fn is_none(&self) -> bool {\\n        match self {\\n            Empty => true,\\n            _ => false,\\n        }\\n    }\\n\\n    fn is_some(&self) -> bool {\\n        match self {\\n            Empty => false,\\n            _ => true,\\n        }\\n    }\\n\\n    fn as_ref(&self) -> Rc<RefCell<Entry<T>>> {\\n        match self {\\n            Empty => panic!(\"Entry is none!\"),\\n            Any(reference) => Rc::clone(&reference),\\n        }\\n    }\\n}\\n\\nimpl<T: std::cmp::Ord> PartialEq for EntryRef<T> {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.is_none() && other.is_none() || Rc::ptr_eq(&self.as_ref(), &other.as_ref())\\n    }\\n}\\n\\nimpl<T: std::cmp::Ord> Clone for EntryRef<T> {\\n    fn clone(&self) -> Self {\\n        match self {\\n            Empty => Empty,\\n            Any(reference) => Any(Rc::clone(reference)),\\n        }\\n    }\\n}\\n\\nimpl<T: std::cmp::Ord> PartialEq for Entry<T> {\\n    fn eq(&self, other: &Self) -> bool {\\n        other.key == self.key\\n            && other.left == self.left\\n            && other.right == self.right\\n            && other.up == self.up\\n            && other.down == self.down\\n    }\\n}\\n\\nimpl<T> Skiplist<T>\\nwhere\\n    T: Ord,\\n    T: Copy,\\n{\\n    pub fn new() -> Self {\\n        let head = Rc::new(RefCell::new(Entry::new(None)));\\n        let tail = Rc::new(RefCell::new(Entry::new(None)));\\n\\n        head.borrow_mut().right = Any(Rc::clone(&tail));\\n        tail.borrow_mut().left = Any(Rc::clone(&head));\\n\\n        Skiplist {\\n            head: Any(head),\\n            tail: Any(tail),\\n            height: 1,\\n        }\\n    }\\n\\n    pub fn search(&self, target: T) -> bool {\\n        let entry = self.find_entry(&target);\\n        entry\\n            .as_ref()\\n            .borrow()\\n            .key\\n            .map_or(false, |key| key == target)\\n    }\\n\\n    pub fn add(&mut self, num: T) {\\n        let mut before_entry = self.find_entry(&num);\\n        let mut next_entry = before_entry.as_ref().borrow().right.clone();\\n        let mut new_entry = Any(Rc::new(RefCell::new(Entry::new(Some(num)))));\\n        let mut previous = Empty;\\n        let mut level = 1;\\n\\n        loop {\\n            new_entry.as_ref().borrow_mut().left = before_entry.clone();\\n            new_entry.as_ref().borrow_mut().right = next_entry.clone();\\n            new_entry.as_ref().borrow_mut().down = previous.clone();\\n            before_entry.as_ref().borrow_mut().right = new_entry.clone();\\n            next_entry.as_ref().borrow_mut().left = new_entry.clone();\\n\\n            if rand::random::<bool>() {\\n                if level == self.height {\\n                    let new_head = Rc::new(RefCell::new(Entry::new(None)));\\n                    let new_tail = Rc::new(RefCell::new(Entry::new(None)));\\n\\n                    new_head.borrow_mut().right = Any(Rc::clone(&new_tail));\\n                    new_head.borrow_mut().down = self.head.clone();\\n                    self.head.as_ref().borrow_mut().up = Any(Rc::clone(&new_head));\\n\\n                    new_tail.borrow_mut().left = Any(Rc::clone(&new_head));\\n                    new_tail.borrow_mut().down = self.tail.clone();\\n                    self.tail.as_ref().borrow_mut().up = Any(Rc::clone(&new_tail));\\n\\n                    self.head = Any(Rc::clone(&new_head));\\n                    self.tail = Any(Rc::clone(&new_tail));\\n                    self.height += 1;\\n                }\\n\\n                while before_entry.as_ref().borrow().up.is_none() {\\n                    before_entry = before_entry.as_ref().borrow().left.clone();\\n                }\\n                before_entry = before_entry.as_ref().borrow().up.clone();\\n\\n                while next_entry.as_ref().borrow().up.is_none() {\\n                    next_entry = next_entry.as_ref().borrow().right.clone();\\n                }\\n                next_entry = next_entry.as_ref().borrow().up.clone();\\n\\n                level += 1;\\n                previous = new_entry;\\n                new_entry = Any(Rc::new(RefCell::new(Entry::new(Some(num)))));\\n                previous.as_ref().borrow_mut().up = new_entry.clone();\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n\\n    pub fn erase(&mut self, num: T) -> bool {\\n        let mut entry = self.find_entry(&num);\\n        if !entry.as_ref().borrow().key.map_or(false, |key| key == num) {\\n            return false;\\n        }\\n\\n        while entry.is_some() {\\n            let up = entry.as_ref().borrow().up.clone();\\n            let left = entry.as_ref().borrow().left.clone();\\n            let right = entry.as_ref().borrow().right.clone();\\n\\n            left.as_ref().borrow_mut().right = right.clone();\\n            right.as_ref().borrow_mut().left = left.clone();\\n\\n            entry.as_ref().borrow_mut().down = Empty;\\n            entry.as_ref().borrow_mut().up = Empty;\\n            entry = up.clone();\\n        }\\n\\n        true\\n    }\\n\\n    fn find_entry(&self, target: &T) -> EntryRef<T> {\\n        let mut node = self.head.as_ref();\\n\\n        loop {\\n            let node_ref = Rc::clone(&node);\\n            let node_value = node_ref.borrow();\\n\\n            if node_value\\n                .right\\n                .as_ref()\\n                .borrow()\\n                .key\\n                .map_or(false, |key| &key <= target)\\n            {\\n                node = node_value.right.as_ref();\\n            } else if node_value.down.is_none() {\\n                break;\\n            } else {\\n                node = node_value.down.as_ref();\\n            }\\n        }\\n\\n        Any(node)\\n    }\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n\\n    #[test]\\n    fn create_empty_skip_list_entry() {\\n        let entry: Entry<i32> = Entry::new(None);\\n        assert!(entry.key.is_none());\\n        assert!(entry.left.is_none());\\n        assert!(entry.right.is_none());\\n        assert!(entry.up.is_none());\\n        assert!(entry.down.is_none());\\n    }\\n\\n    #[test]\\n    fn create_skip_list_entry() {\\n        let entry = Entry::new(Some(5));\\n        assert_eq!(entry.key, Some(5));\\n        assert!(entry.left.is_none());\\n        assert!(entry.right.is_none());\\n        assert!(entry.up.is_none());\\n        assert!(entry.down.is_none());\\n    }\\n\\n    #[test]\\n    fn create_skip_list() {\\n        let skiplist: Skiplist<i32> = Skiplist::new();\\n        let head = skiplist.head;\\n        let tail = skiplist.tail;\\n\\n        assert!(head.is_some());\\n        assert!(tail.is_some());\\n\\n        let head = head.as_ref();\\n        let tail = tail.as_ref();\\n\\n        assert!(head.borrow().left.is_none());\\n        assert!(head.borrow().up.is_none());\\n        assert!(head.borrow().down.is_none());\\n\\n        assert!(tail.borrow().right.is_none());\\n        assert!(tail.borrow().up.is_none());\\n        assert!(tail.borrow().down.is_none());\\n\\n        assert_eq!(head.borrow().right, Any(Rc::clone(&tail)));\\n        assert_eq!(tail.borrow().left, Any(Rc::clone(&head)));\\n    }\\n\\n    #[test]\\n    fn search_not_existing_element() {\\n        let skiplist: Skiplist<i32> = Skiplist::new();\\n        assert_eq!(skiplist.search(5), false);\\n        assert_eq!(skiplist.search(37), false);\\n        assert_eq!(skiplist.search(i32::min_value()), false);\\n        assert_eq!(skiplist.search(i32::max_value()), false);\\n    }\\n\\n    #[test]\\n    fn add_few_elements() {\\n        let mut skiplist: Skiplist<i32> = Skiplist::new();\\n\\n        assert_eq!(skiplist.search(5), false);\\n        skiplist.add(5);\\n        assert_eq!(skiplist.search(5), true);\\n\\n        assert_eq!(skiplist.search(i32::min_value()), false);\\n        skiplist.add(i32::min_value());\\n        assert_eq!(skiplist.search(i32::min_value()), true);\\n\\n        assert_eq!(skiplist.search(i32::max_value()), false);\\n        skiplist.add(i32::max_value());\\n        assert_eq!(skiplist.search(i32::max_value()), true);\\n    }\\n\\n    #[test]\\n    fn erase_not_existing() {\\n        let mut skiplist: Skiplist<i32> = Skiplist::new();\\n\\n        assert_eq!(skiplist.erase(5), false);\\n        assert_eq!(skiplist.erase(i32::max_value()), false);\\n        assert_eq!(skiplist.erase(i32::min_value()), false);\\n    }\\n\\n    #[test]\\n    fn erase_existing() {\\n        let mut skiplist: Skiplist<i32> = Skiplist::new();\\n\\n        skiplist.add(5);\\n        skiplist.add(7);\\n        skiplist.add(i32::max_value());\\n        skiplist.add(i32::min_value());\\n\\n        assert_eq!(skiplist.erase(5), true);\\n        assert_eq!(skiplist.erase(i32::max_value()), true);\\n        assert_eq!(skiplist.erase(i32::min_value()), true);\\n\\n        assert_eq!(skiplist.search(5), false);\\n        assert_eq!(skiplist.search(7), true);\\n        assert_eq!(skiplist.search(i32::max_value()), false);\\n        assert_eq!(skiplist.search(i32::min_value()), false);\\n    }\\n\\n    #[test]\\n    fn add_many_elements() {\\n        let mut skiplist: Skiplist<i32> = Skiplist::new();\\n        let elements: [i32; 30] = rand::random();\\n\\n        for &element in elements.iter() {\\n            skiplist.add(element);\\n            assert!(skiplist.search(element));\\n        }\\n\\n        for &element in elements.iter() {\\n            assert!(skiplist.search(element));\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 619012,
                "title": "java-14ms-but-i-might-have-misunderstood-the-task",
                "content": "The description or the picture does not show what should happen if a value smaller than the current top left value is added. I somehow assumed we should in that case insert to the left of root, which led to a solution where we read either right or left from a root that can be anywhere in the top level:\\n* If adding to empty list, added node becomes root.\\n* If coinflips decide to grow a node higher than previous root, it becomes the new root.\\n* If root is removed, select a new root from highest remaining level.\\n\\nIt seems to me this method should on average be faster than always starting the search from the left, but seeing other people\\'s solutions, it appears this is not what we were supposed to do. Apart from not being exactly what was asked for, is there any reason why this variation of a skiplist would be worse than having the root fixed top left?\\n\\n\\n```\\nclass Skiplist {\\n    private int height;\\n    private Node root;\\n    private final Random random = new Random();\\n\\n    public Skiplist() {\\n        height = 1;        \\n    }\\n    \\n    public void add(int num) {\\n        if (root == null) { // if list empty\\n            root = (new Node(num));\\n            return;\\n        }\\n        Node insertionPoint = findNode(num, root);\\n        if (insertionPoint.value == num) {\\n            increaseCount(insertionPoint);\\n            return;\\n        }\\n        Node newNode = new Node(num);\\n        insert(newNode, insertionPoint, 1);\\n    }\\n    \\n    public boolean search(int target) {\\n        if (root == null) return false;\\n        return findNode(target, root).value == target;\\n    }\\n    \\n    /* Returns the highest level target node if target exists in list, \\n       otherwise returns a bottom level node next to target insertion point.*/\\n    private Node findNode(int target, Node cur) {\\n        if (target > root.value) {\\n            while (cur.next != null && cur.next.value <= target)\\n                cur = cur.next;\\n        }\\n        else {\\n            while (cur.prev != null && cur.prev.value >= target)\\n                cur = cur.prev;\\n        }\\n        if (cur.value != target && cur.below != null) {\\n            return findNode(target, cur.below);\\n        }\\n        return cur;\\n    }\\n    \\n    private void insert(Node newNode, Node insertionPoint, int insertionHeight) {\\n        if (newNode.value > insertionPoint.value) {\\n            newNode.prev = insertionPoint;\\n            newNode.next = insertionPoint.next;\\n        }\\n        else {\\n            newNode.prev = insertionPoint.prev;\\n            newNode.next = insertionPoint;\\n        }\\n        if (newNode.prev != null)\\n            newNode.prev.next = newNode;\\n        if (newNode.next != null)\\n            newNode.next.prev = newNode;\\n        if (coinFlip())\\n            addAbove(newNode, insertionHeight + 1);\\n    }\\n    \\n    private void increaseCount(Node cur) {\\n        cur.count++; // Only the highest level node of a value needs to know the count\\n        if (cur != root && coinFlip()) { \\n            // If coinflip so decides, calculate height of current node and insert above\\n            int insertionHeight = 1;\\n            if (cur.below != null) {\\n                Node belowCur = cur.below;\\n                insertionHeight++;\\n                while (belowCur.below != null) {\\n                    belowCur = belowCur.below;\\n                    insertionHeight++;\\n                }\\n            }\\n            addAbove(cur, insertionHeight + 1);\\n        }\\n    }\\n    \\n    private boolean coinFlip() {\\n        return random.nextInt(2) == 1;\\n    }\\n    \\n    private void addAbove(Node cur, int newHeight) {\\n        Node newNode = new Node(cur.value);\\n        newNode.below = cur;\\n        newNode.count = cur.count;\\n        cur.above = newNode;\\n        if (newHeight > height) {\\n            height = newHeight;\\n            root = newNode;\\n            return;\\n        }\\n        if (cur.value > root.value) { // Searching towards root will eventually find a node with a node above\\n            cur = cur.prev;\\n            while (cur.above == null) {\\n                cur = cur.prev;\\n            }\\n        }\\n        else {\\n            cur = cur.next;\\n            while (cur.above == null) {\\n                cur = cur.next;\\n            }\\n        }\\n        insert(newNode, cur.above, newHeight);\\n    }\\n    \\n    public boolean erase(int num) {\\n        if (root == null) return false;\\n        Node toErase = findNode(num, root);\\n        if (toErase == null || toErase.value != num) {\\n            return false;\\n        }\\n        if (toErase.count > 1) {\\n            toErase.count--;\\n            return true;\\n        }\\n        if (toErase == root) {\\n            root = (findNewRoot(root));\\n        }\\n        while (toErase != null) {\\n            if (toErase.prev != null)\\n                toErase.prev.next = toErase.next;\\n            if (toErase.next != null)\\n                toErase.next.prev = toErase.prev;    \\n            toErase = toErase.below;\\n        }\\n        return true;\\n    }\\n    \\n    private Node findNewRoot(Node cur) {\\n        if (cur.next != null)\\n            return cur.next; \\n        if (cur.prev != null)\\n            return cur.prev;\\n        if (cur.below != null) {\\n            height--;\\n            return findNewRoot(cur.below);\\n        }\\n        return null;\\n    }\\n    \\n    class Node {\\n        Node next;\\n        Node prev;\\n        Node above;\\n        Node below;\\n        int value;\\n        int count;\\n        \\n        public Node(int val) {\\n            value = val;\\n            count = 1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Skiplist {\\n    private int height;\\n    private Node root;\\n    private final Random random = new Random();\\n\\n    public Skiplist() {\\n        height = 1;        \\n    }\\n    \\n    public void add(int num) {\\n        if (root == null) { // if list empty\\n            root = (new Node(num));\\n            return;\\n        }\\n        Node insertionPoint = findNode(num, root);\\n        if (insertionPoint.value == num) {\\n            increaseCount(insertionPoint);\\n            return;\\n        }\\n        Node newNode = new Node(num);\\n        insert(newNode, insertionPoint, 1);\\n    }\\n    \\n    public boolean search(int target) {\\n        if (root == null) return false;\\n        return findNode(target, root).value == target;\\n    }\\n    \\n    /* Returns the highest level target node if target exists in list, \\n       otherwise returns a bottom level node next to target insertion point.*/\\n    private Node findNode(int target, Node cur) {\\n        if (target > root.value) {\\n            while (cur.next != null && cur.next.value <= target)\\n                cur = cur.next;\\n        }\\n        else {\\n            while (cur.prev != null && cur.prev.value >= target)\\n                cur = cur.prev;\\n        }\\n        if (cur.value != target && cur.below != null) {\\n            return findNode(target, cur.below);\\n        }\\n        return cur;\\n    }\\n    \\n    private void insert(Node newNode, Node insertionPoint, int insertionHeight) {\\n        if (newNode.value > insertionPoint.value) {\\n            newNode.prev = insertionPoint;\\n            newNode.next = insertionPoint.next;\\n        }\\n        else {\\n            newNode.prev = insertionPoint.prev;\\n            newNode.next = insertionPoint;\\n        }\\n        if (newNode.prev != null)\\n            newNode.prev.next = newNode;\\n        if (newNode.next != null)\\n            newNode.next.prev = newNode;\\n        if (coinFlip())\\n            addAbove(newNode, insertionHeight + 1);\\n    }\\n    \\n    private void increaseCount(Node cur) {\\n        cur.count++; // Only the highest level node of a value needs to know the count\\n        if (cur != root && coinFlip()) { \\n            // If coinflip so decides, calculate height of current node and insert above\\n            int insertionHeight = 1;\\n            if (cur.below != null) {\\n                Node belowCur = cur.below;\\n                insertionHeight++;\\n                while (belowCur.below != null) {\\n                    belowCur = belowCur.below;\\n                    insertionHeight++;\\n                }\\n            }\\n            addAbove(cur, insertionHeight + 1);\\n        }\\n    }\\n    \\n    private boolean coinFlip() {\\n        return random.nextInt(2) == 1;\\n    }\\n    \\n    private void addAbove(Node cur, int newHeight) {\\n        Node newNode = new Node(cur.value);\\n        newNode.below = cur;\\n        newNode.count = cur.count;\\n        cur.above = newNode;\\n        if (newHeight > height) {\\n            height = newHeight;\\n            root = newNode;\\n            return;\\n        }\\n        if (cur.value > root.value) { // Searching towards root will eventually find a node with a node above\\n            cur = cur.prev;\\n            while (cur.above == null) {\\n                cur = cur.prev;\\n            }\\n        }\\n        else {\\n            cur = cur.next;\\n            while (cur.above == null) {\\n                cur = cur.next;\\n            }\\n        }\\n        insert(newNode, cur.above, newHeight);\\n    }\\n    \\n    public boolean erase(int num) {\\n        if (root == null) return false;\\n        Node toErase = findNode(num, root);\\n        if (toErase == null || toErase.value != num) {\\n            return false;\\n        }\\n        if (toErase.count > 1) {\\n            toErase.count--;\\n            return true;\\n        }\\n        if (toErase == root) {\\n            root = (findNewRoot(root));\\n        }\\n        while (toErase != null) {\\n            if (toErase.prev != null)\\n                toErase.prev.next = toErase.next;\\n            if (toErase.next != null)\\n                toErase.next.prev = toErase.prev;    \\n            toErase = toErase.below;\\n        }\\n        return true;\\n    }\\n    \\n    private Node findNewRoot(Node cur) {\\n        if (cur.next != null)\\n            return cur.next; \\n        if (cur.prev != null)\\n            return cur.prev;\\n        if (cur.below != null) {\\n            height--;\\n            return findNewRoot(cur.below);\\n        }\\n        return null;\\n    }\\n    \\n    class Node {\\n        Node next;\\n        Node prev;\\n        Node above;\\n        Node below;\\n        int value;\\n        int count;\\n        \\n        public Node(int val) {\\n            value = val;\\n            count = 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 599790,
                "title": "java-ac-straightforward-solution",
                "content": "\\n```\\nclass Skiplist {\\n    Node head;\\n    Node tail;\\n    int height = 0;\\n\\n    public Skiplist() {\\n        head = new Node(Integer.MIN_VALUE);\\n        tail = new Node(Integer.MAX_VALUE);\\n        head.right = tail;\\n        tail.left = head;\\n\\n    }\\n\\n    public boolean search(int target) {\\n        Node cur = findClosest(target);\\n        return cur.val == target;\\n    }\\n\\n    public void add(int num) {\\n        Node cur = findClosest(num);\\n\\n        while (cur.down != null) {\\n            cur = cur.down;\\n        }\\n\\n        Node newNode = new Node(num);\\n        newNode.left = cur;\\n        newNode.right = cur.right;\\n        cur.right.left = newNode;\\n        cur.right = newNode;\\n\\n        // Do we need to mae new Level;\\n        Random r = new Random();\\n        int currentLevel = 0;\\n\\n        while (r.nextBoolean()) {\\n\\n            currentLevel++;\\n\\n            if (currentLevel > height) {\\n                height = currentLevel;\\n                head.up = new Node(Integer.MIN_VALUE);\\n                head.up.down = head;\\n                head = head.up;\\n                tail.up = new Node(Integer.MAX_VALUE);\\n                tail.up.down = tail;\\n                tail = tail.up;\\n\\n                Node newNodeUp = new Node(num);\\n                newNode.up = newNodeUp;\\n                newNodeUp.down = newNode;\\n                newNodeUp.left = head;\\n                newNodeUp.right = tail;\\n                head.right = newNodeUp;\\n                tail.left = newNodeUp;\\n                break;\\n            }\\n\\n            Node leftPtr = newNode.left;\\n            Node rightPtr = newNode.right;\\n\\n            while (leftPtr.up == null) {\\n                leftPtr = leftPtr.left;\\n            }\\n\\n            while (rightPtr.up == null) {\\n                rightPtr = rightPtr.right;\\n            }\\n\\n            leftPtr = leftPtr.up;\\n            rightPtr = rightPtr.up;\\n\\n            newNode.up = new Node(num);\\n            newNode.up.down = newNode;\\n            newNode = newNode.up;\\n\\n            newNode.left = leftPtr;\\n            leftPtr.right = newNode;\\n            newNode.right = rightPtr;\\n            rightPtr.left = newNode;\\n        }\\n    }\\n\\n    private Node findClosest(int target) {\\n        Node cur = head;\\n        while (cur.right != null) {\\n            while (cur.right != null && cur.right.val <= target) {\\n                cur = cur.right;\\n            }\\n\\n            if (cur.down != null) {\\n                cur = cur.down;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        return cur;\\n    }\\n\\n    public boolean erase(int num) {\\n        Node cur = findClosest(num);\\n        if (cur.val != num) return false;\\n\\n        while (cur != null) {\\n            cur.right.left = cur.left;\\n            cur.left.right = cur.right;\\n            cur = cur.up;\\n        }\\n\\n        return true;\\n    }\\n\\n    class Node {\\n        Node left = null;\\n        Node right = null;\\n        Node up = null;\\n        Node down = null;\\n        int val = 0;\\n\\n        Node(int val) {\\n            this.val = val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist obj = new Skiplist();\\n * boolean param_1 = obj.search(target);\\n * obj.add(num);\\n * boolean param_3 = obj.erase(num);\\n */",
                "solutionTags": [],
                "code": "\\n```\\nclass Skiplist {\\n    Node head;\\n    Node tail;\\n    int height = 0;\\n\\n    public Skiplist() {\\n        head = new Node(Integer.MIN_VALUE);\\n        tail = new Node(Integer.MAX_VALUE);\\n        head.right = tail;\\n        tail.left = head;\\n\\n    }\\n\\n    public boolean search(int target) {\\n        Node cur = findClosest(target);\\n        return cur.val == target;\\n    }\\n\\n    public void add(int num) {\\n        Node cur = findClosest(num);\\n\\n        while (cur.down != null) {\\n            cur = cur.down;\\n        }\\n\\n        Node newNode = new Node(num);\\n        newNode.left = cur;\\n        newNode.right = cur.right;\\n        cur.right.left = newNode;\\n        cur.right = newNode;\\n\\n        // Do we need to mae new Level;\\n        Random r = new Random();\\n        int currentLevel = 0;\\n\\n        while (r.nextBoolean()) {\\n\\n            currentLevel++;\\n\\n            if (currentLevel > height) {\\n                height = currentLevel;\\n                head.up = new Node(Integer.MIN_VALUE);\\n                head.up.down = head;\\n                head = head.up;\\n                tail.up = new Node(Integer.MAX_VALUE);\\n                tail.up.down = tail;\\n                tail = tail.up;\\n\\n                Node newNodeUp = new Node(num);\\n                newNode.up = newNodeUp;\\n                newNodeUp.down = newNode;\\n                newNodeUp.left = head;\\n                newNodeUp.right = tail;\\n                head.right = newNodeUp;\\n                tail.left = newNodeUp;\\n                break;\\n            }\\n\\n            Node leftPtr = newNode.left;\\n            Node rightPtr = newNode.right;\\n\\n            while (leftPtr.up == null) {\\n                leftPtr = leftPtr.left;\\n            }\\n\\n            while (rightPtr.up == null) {\\n                rightPtr = rightPtr.right;\\n            }\\n\\n            leftPtr = leftPtr.up;\\n            rightPtr = rightPtr.up;\\n\\n            newNode.up = new Node(num);\\n            newNode.up.down = newNode;\\n            newNode = newNode.up;\\n\\n            newNode.left = leftPtr;\\n            leftPtr.right = newNode;\\n            newNode.right = rightPtr;\\n            rightPtr.left = newNode;\\n        }\\n    }\\n\\n    private Node findClosest(int target) {\\n        Node cur = head;\\n        while (cur.right != null) {\\n            while (cur.right != null && cur.right.val <= target) {\\n                cur = cur.right;\\n            }\\n\\n            if (cur.down != null) {\\n                cur = cur.down;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        return cur;\\n    }\\n\\n    public boolean erase(int num) {\\n        Node cur = findClosest(num);\\n        if (cur.val != num) return false;\\n\\n        while (cur != null) {\\n            cur.right.left = cur.left;\\n            cur.left.right = cur.right;\\n            cur = cur.up;\\n        }\\n\\n        return true;\\n    }\\n\\n    class Node {\\n        Node left = null;\\n        Node right = null;\\n        Node up = null;\\n        Node down = null;\\n        int val = 0;\\n\\n        Node(int val) {\\n            this.val = val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist obj = new Skiplist();\\n * boolean param_1 = obj.search(target);\\n * obj.add(num);\\n * boolean param_3 = obj.erase(num);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 527640,
                "title": "java-solution",
                "content": "```\\nclass Skiplist {\\n    private SkipListEntry head = new SkipListEntry(Integer.MIN_VALUE);\\n    private SkipListEntry tail = new SkipListEntry(Integer.MAX_VALUE);\\n    private int n;\\n    private int h;\\n    private Random random = new Random();\\n\\n    public Skiplist() {\\n        head.right = tail;\\n        tail.left = head;\\n    }\\n\\n    public boolean search(int target) {\\n        SkipListEntry entry = floorEntry(target);\\n        return entry.val == target;\\n    }\\n\\n    public void add(int num) {\\n        SkipListEntry p = floorEntry(num);\\n        SkipListEntry q = new SkipListEntry(num);\\n        link(p, q);\\n        int i = 0;\\n        while (random.nextDouble() < 0.5) {\\n            if (i == h) addEmptyRow();\\n            while (p.up == null) p = p.left;\\n            p = p.up;\\n            SkipListEntry e = new SkipListEntry(num);\\n            link(p, e);\\n            e.down = q;\\n            q.up = e;\\n            q = e;\\n            i++;\\n        }\\n        n++;\\n    }\\n\\n    public boolean erase(int num) {\\n        SkipListEntry entry = floorEntry(num);\\n        if (entry.val != num) return false;\\n        do {\\n            entry.left.right = entry.right;\\n            entry.right.left = entry.left;\\n            entry = entry.up;\\n        } while (entry != null);\\n        return true;\\n    }\\n\\n    private SkipListEntry floorEntry(int target) {\\n        SkipListEntry entry = head;\\n        while (true) {\\n            while (entry.right.val <= target) entry = entry.right;\\n            if (entry.down == null) break;\\n            entry = entry.down;\\n        }\\n        return entry;\\n    }\\n\\n    private void addEmptyRow() {\\n        SkipListEntry a = new SkipListEntry(Integer.MIN_VALUE);\\n        SkipListEntry b = new SkipListEntry(Integer.MAX_VALUE);\\n        a.down = head;\\n        head.up = a;\\n        b.down = tail;\\n        tail.up = b;\\n        a.right = b;\\n        b.left = a;\\n        head = a;\\n        tail = b;\\n        h++;\\n    }\\n    \\n    private void link(SkipListEntry p, SkipListEntry q) {\\n        p.right.left = q;\\n        q.right = p.right;\\n        p.right = q;\\n        q.left = p;\\n    }\\n\\n    class SkipListEntry {\\n        private Integer val;\\n        private SkipListEntry left;\\n        private SkipListEntry right;\\n        private SkipListEntry up;\\n        private SkipListEntry down;\\n        SkipListEntry(Integer val) {\\n            this.val = val;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nclass Skiplist {\\n    private SkipListEntry head = new SkipListEntry(Integer.MIN_VALUE);\\n    private SkipListEntry tail = new SkipListEntry(Integer.MAX_VALUE);\\n    private int n;\\n    private int h;\\n    private Random random = new Random();\\n\\n    public Skiplist() {\\n        head.right = tail;\\n        tail.left = head;\\n    }\\n\\n    public boolean search(int target) {\\n        SkipListEntry entry = floorEntry(target);\\n        return entry.val == target;\\n    }\\n\\n    public void add(int num) {\\n        SkipListEntry p = floorEntry(num);\\n        SkipListEntry q = new SkipListEntry(num);\\n        link(p, q);\\n        int i = 0;\\n        while (random.nextDouble() < 0.5) {\\n            if (i == h) addEmptyRow();\\n            while (p.up == null) p = p.left;\\n            p = p.up;\\n            SkipListEntry e = new SkipListEntry(num);\\n            link(p, e);\\n            e.down = q;\\n            q.up = e;\\n            q = e;\\n            i++;\\n        }\\n        n++;\\n    }\\n\\n    public boolean erase(int num) {\\n        SkipListEntry entry = floorEntry(num);\\n        if (entry.val != num) return false;\\n        do {\\n            entry.left.right = entry.right;\\n            entry.right.left = entry.left;\\n            entry = entry.up;\\n        } while (entry != null);\\n        return true;\\n    }\\n\\n    private SkipListEntry floorEntry(int target) {\\n        SkipListEntry entry = head;\\n        while (true) {\\n            while (entry.right.val <= target) entry = entry.right;\\n            if (entry.down == null) break;\\n            entry = entry.down;\\n        }\\n        return entry;\\n    }\\n\\n    private void addEmptyRow() {\\n        SkipListEntry a = new SkipListEntry(Integer.MIN_VALUE);\\n        SkipListEntry b = new SkipListEntry(Integer.MAX_VALUE);\\n        a.down = head;\\n        head.up = a;\\n        b.down = tail;\\n        tail.up = b;\\n        a.right = b;\\n        b.left = a;\\n        head = a;\\n        tail = b;\\n        h++;\\n    }\\n    \\n    private void link(SkipListEntry p, SkipListEntry q) {\\n        p.right.left = q;\\n        q.right = p.right;\\n        p.right = q;\\n        q.left = p;\\n    }\\n\\n    class SkipListEntry {\\n        private Integer val;\\n        private SkipListEntry left;\\n        private SkipListEntry right;\\n        private SkipListEntry up;\\n        private SkipListEntry down;\\n        SkipListEntry(Integer val) {\\n            this.val = val;\\n        }\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 401582,
                "title": "java-solution-simple-idea",
                "content": "* Naive design\\n  - make sure the first layer is empty before adding; that is to keep at least two layers anytime\\n  - use stack to trace the position to add or remove nodes\\n\\n```\\nclass Skiplist {\\n    Node root;\\n    Random r = new Random();\\n    public Skiplist() {\\n        root = new Node(-1);\\n        root.low = new Node(-1);\\n    }\\n\\n    public boolean search(int target) {\\n        Node prev = root, curr = root.next;\\n        while(true) {\\n            if(curr == null || curr.val >= target) {\\n                if(curr != null && curr.val == target) return true;\\n                if(prev.low == null) return false;\\n                prev = prev.low;\\n                if(prev.val == -1) curr = prev.next;\\n                else curr = prev;\\n            } else if(curr.val < target) {\\n                prev = curr;\\n                curr = curr.next;\\n            }\\n        }\\n    }\\n\\n    public boolean flipCoin() {\\n        int i = r.nextInt(2);\\n        return i == 1;\\n    }\\n\\n    public void add(int num) {\\n        if(root.next != null) {\\n            Node nr = new Node(-1);\\n            nr.low = root;\\n            root = nr;\\n        }\\n        Stack<Node> stack = new Stack<>();\\n        Node curr = root.next, prev = root;\\n        while(true) {\\n            if(curr == null || curr.val >= num) {\\n                if(prev.low == null) break;\\n                stack.push(prev);\\n                prev = prev.low;\\n                if(prev.val == -1) {\\n                    curr = prev.next;\\n                } else {\\n                    curr = prev;\\n                }\\n            } else {\\n                prev = curr;\\n                curr = curr.next;\\n            }\\n        }\\n        Node n = new Node(num);\\n        n.next = curr;\\n        prev.next = n;\\n        Node low = n;\\n        while(!stack.isEmpty()) {\\n            if(flipCoin()) {\\n                prev = stack.pop();\\n                n = new Node(num);\\n                n.next = prev.next;\\n                prev.next = n;\\n                n.low = low;\\n                low = n;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        //     print();\\n        // System.out.println(\"_________above Add \" + num + \" ___________\");\\n    }\\n\\n    public void print() {\\n        Node head = root;\\n        while(head != null) {\\n            Node curr = head;\\n            while(curr != null) {\\n                System.out.print(curr.val + \"->\");\\n                curr = curr.next;\\n            }\\n            System.out.println();\\n            head = head.low;\\n        }\\n\\n    }\\n\\n    public boolean erase(int num) {\\n\\n        Stack<Node> stack = new Stack<>();\\n        Node prev = root, curr = root.next;\\n        while(true) {\\n            if(curr == null || curr.val >= num) {\\n                if(prev.low == null) break;\\n                stack.push(prev);\\n                prev = prev.low;\\n                if(prev.val == -1) curr = prev.next;\\n                else curr = prev;\\n            } else if(curr.val < num) {\\n                prev = curr;\\n                curr = curr.next;\\n            }\\n        }\\n        if(curr == null || curr.val != num) return false;\\n        prev.next = curr.next;\\n        while(!stack.isEmpty()) {\\n            prev = stack.pop();\\n            curr = prev.next;\\n            // System.out.println(prev.val);\\n            if(curr == null || curr.val != num) break;\\n            prev.next = curr.next;\\n        }\\n        while(root.next == null && root.low.next == null && root.low.low != null) {\\n            root = root.low;\\n        }\\n\\n        //     print();\\n        // System.out.println(\"_________above Erase \" + num + \" ___________\");\\n        return true;\\n    }\\n\\n    class Node {\\n        int val;\\n        Node next;\\n        Node low;\\n        public Node(int val) {\\n            this.val = val;\\n        }\\n        public String toString() {\\n            return \"\" + val;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Skiplist {\\n    Node root;\\n    Random r = new Random();\\n    public Skiplist() {\\n        root = new Node(-1);\\n        root.low = new Node(-1);\\n    }\\n\\n    public boolean search(int target) {\\n        Node prev = root, curr = root.next;\\n        while(true) {\\n            if(curr == null || curr.val >= target) {\\n                if(curr != null && curr.val == target) return true;\\n                if(prev.low == null) return false;\\n                prev = prev.low;\\n                if(prev.val == -1) curr = prev.next;\\n                else curr = prev;\\n            } else if(curr.val < target) {\\n                prev = curr;\\n                curr = curr.next;\\n            }\\n        }\\n    }\\n\\n    public boolean flipCoin() {\\n        int i = r.nextInt(2);\\n        return i == 1;\\n    }\\n\\n    public void add(int num) {\\n        if(root.next != null) {\\n            Node nr = new Node(-1);\\n            nr.low = root;\\n            root = nr;\\n        }\\n        Stack<Node> stack = new Stack<>();\\n        Node curr = root.next, prev = root;\\n        while(true) {\\n            if(curr == null || curr.val >= num) {\\n                if(prev.low == null) break;\\n                stack.push(prev);\\n                prev = prev.low;\\n                if(prev.val == -1) {\\n                    curr = prev.next;\\n                } else {\\n                    curr = prev;\\n                }\\n            } else {\\n                prev = curr;\\n                curr = curr.next;\\n            }\\n        }\\n        Node n = new Node(num);\\n        n.next = curr;\\n        prev.next = n;\\n        Node low = n;\\n        while(!stack.isEmpty()) {\\n            if(flipCoin()) {\\n                prev = stack.pop();\\n                n = new Node(num);\\n                n.next = prev.next;\\n                prev.next = n;\\n                n.low = low;\\n                low = n;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        //     print();\\n        // System.out.println(\"_________above Add \" + num + \" ___________\");\\n    }\\n\\n    public void print() {\\n        Node head = root;\\n        while(head != null) {\\n            Node curr = head;\\n            while(curr != null) {\\n                System.out.print(curr.val + \"->\");\\n                curr = curr.next;\\n            }\\n            System.out.println();\\n            head = head.low;\\n        }\\n\\n    }\\n\\n    public boolean erase(int num) {\\n\\n        Stack<Node> stack = new Stack<>();\\n        Node prev = root, curr = root.next;\\n        while(true) {\\n            if(curr == null || curr.val >= num) {\\n                if(prev.low == null) break;\\n                stack.push(prev);\\n                prev = prev.low;\\n                if(prev.val == -1) curr = prev.next;\\n                else curr = prev;\\n            } else if(curr.val < num) {\\n                prev = curr;\\n                curr = curr.next;\\n            }\\n        }\\n        if(curr == null || curr.val != num) return false;\\n        prev.next = curr.next;\\n        while(!stack.isEmpty()) {\\n            prev = stack.pop();\\n            curr = prev.next;\\n            // System.out.println(prev.val);\\n            if(curr == null || curr.val != num) break;\\n            prev.next = curr.next;\\n        }\\n        while(root.next == null && root.low.next == null && root.low.low != null) {\\n            root = root.low;\\n        }\\n\\n        //     print();\\n        // System.out.println(\"_________above Erase \" + num + \" ___________\");\\n        return true;\\n    }\\n\\n    class Node {\\n        int val;\\n        Node next;\\n        Node low;\\n        public Node(int val) {\\n            this.val = val;\\n        }\\n        public String toString() {\\n            return \"\" + val;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394176,
                "title": "javascripts-100-short-solution-just-with-next-and-down-two-pointers",
                "content": "Before solve this problem, better to read https://www.geeksforgeeks.org/skip-list/\\nFor the one who has no idea about skip-list like me, it need you more time to understand its structure and some detail first.\\nBetter use less pointers in Node structrue. If you have more pointers like double linked, left, right, up, down. You need to maintain all of them in you code when add and erase, which will increase difficulty of your coding.\\n\\nAnother trick is when search for value, you can keep a list of pre node for all levels, this list will help you a lot when you add and erase, whichi I implements in my iter().\\n\\nTo decide how many levels a value can reach, you can use one function, decideLevels(), then just loop it. For-Loop is always simplier than while loop or recursion.\\n\\n\\n\\n```\\nconst decideLevels = (max) => { //to decide how many level will this value go up, I use p = 50%\\n    let ans = 1;\\n    while (Math.random() > 0.5 && ans < max) ans++;\\n    return ans;\\n};\\n\\nconst Node = function(val) {\\n    this.val = val;\\n    this.next = null;\\n    this.down = null;\\n};\\n\\nvar Skiplist = function() {\\n    this.maxLvl = ~~Math.log2(20000);  //max levels decided by your input range.\\n    this.levels = [...Array(this.maxLvl)].map(() => new Node(-1)); //this will save all the begin node in each level\\n    for (let i = this.maxLvl - 1; i > 0; i--) {\\n        this.levels[i].down = this.levels[i - 1];\\n    }\\n    this.head = this.levels[this.maxLvl - 1];\\n};\\n\\n/** \\n * @param {number} target\\n * @return {boolean}\\n */\\nSkiplist.prototype.search = function(target) {\\n    const pre = this.iter(target);\\n    return !pre[0].next ? false : pre[0].next.val === target;\\n};\\n\\nSkiplist.prototype.iter = function(target) {\\n    let cur = this.head;\\n    const pre = [];\\n    for (let i = this.maxLvl - 1; i >= 0; i--) {\\n        while (cur.next && cur.next.val < target) cur = cur.next;\\n        pre[i] = cur;\\n        cur = cur.down;\\n    }\\n    return pre;\\n}\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\n\\nSkiplist.prototype.add = function(num) {\\n    const pre = this.iter(num);\\n    const lvs = decideLevels(this.maxLvl);\\n    for (let i = 0; i < lvs; i++) {\\n        const next = pre[i].next;\\n        pre[i].next = new Node(num);\\n        pre[i].next.next = next;\\n        if (i > 0) pre[i].next.down = pre[i - 1].next;\\n    }\\n};\\n\\n/** \\n * @param {number} num\\n * @return {boolean}\\n */\\nSkiplist.prototype.erase = function(num) {\\n    const pre = this.iter(num);\\n    let ret;\\n    if (!pre[0].next || pre[0].next.val !== num) return false;\\n   for (let i = this.maxLvl - 1; i >= 0; i--) {\\n\\t\\tif (pre[i].next && pre[i].next.val === num) {\\n\\t\\t\\tconst toBeDeleted = pre[i].next;\\n\\t\\t\\tpre[i].next = toBeDeleted.next;\\n\\t\\t\\ttoBeDeleted.next = null; //not necessary, but better to clean the unused links\\n\\t\\t\\ttoBeDeleted.down = null;\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nconst decideLevels = (max) => { //to decide how many level will this value go up, I use p = 50%\\n    let ans = 1;\\n    while (Math.random() > 0.5 && ans < max) ans++;\\n    return ans;\\n};\\n\\nconst Node = function(val) {\\n    this.val = val;\\n    this.next = null;\\n    this.down = null;\\n};\\n\\nvar Skiplist = function() {\\n    this.maxLvl = ~~Math.log2(20000);  //max levels decided by your input range.\\n    this.levels = [...Array(this.maxLvl)].map(() => new Node(-1)); //this will save all the begin node in each level\\n    for (let i = this.maxLvl - 1; i > 0; i--) {\\n        this.levels[i].down = this.levels[i - 1];\\n    }\\n    this.head = this.levels[this.maxLvl - 1];\\n};\\n\\n/** \\n * @param {number} target\\n * @return {boolean}\\n */\\nSkiplist.prototype.search = function(target) {\\n    const pre = this.iter(target);\\n    return !pre[0].next ? false : pre[0].next.val === target;\\n};\\n\\nSkiplist.prototype.iter = function(target) {\\n    let cur = this.head;\\n    const pre = [];\\n    for (let i = this.maxLvl - 1; i >= 0; i--) {\\n        while (cur.next && cur.next.val < target) cur = cur.next;\\n        pre[i] = cur;\\n        cur = cur.down;\\n    }\\n    return pre;\\n}\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\n\\nSkiplist.prototype.add = function(num) {\\n    const pre = this.iter(num);\\n    const lvs = decideLevels(this.maxLvl);\\n    for (let i = 0; i < lvs; i++) {\\n        const next = pre[i].next;\\n        pre[i].next = new Node(num);\\n        pre[i].next.next = next;\\n        if (i > 0) pre[i].next.down = pre[i - 1].next;\\n    }\\n};\\n\\n/** \\n * @param {number} num\\n * @return {boolean}\\n */\\nSkiplist.prototype.erase = function(num) {\\n    const pre = this.iter(num);\\n    let ret;\\n    if (!pre[0].next || pre[0].next.val !== num) return false;\\n   for (let i = this.maxLvl - 1; i >= 0; i--) {\\n\\t\\tif (pre[i].next && pre[i].next.val === num) {\\n\\t\\t\\tconst toBeDeleted = pre[i].next;\\n\\t\\t\\tpre[i].next = toBeDeleted.next;\\n\\t\\t\\ttoBeDeleted.next = null; //not necessary, but better to clean the unused links\\n\\t\\t\\ttoBeDeleted.down = null;\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 392720,
                "title": "python-beats-100-with-2-direction-nodes-clean-code-with-explanations",
                "content": "```\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.next = None\\n        self.lower = None\\n\\nclass Skiplist:\\n    def __init__(self):\\n        self.sentinel = Node(-sys.maxsize)\\n\\n    def _flip(self, cur):\\n        target = None if not cur.next else cur.next.lower\\n        p, count = cur.lower, 0\\n        while p != target:\\n            p = p.next\\n            count += 1\\n        if count >= 4:\\n            lower = cur.lower.next.next\\n            new_node = Node(lower.val)\\n            new_node.next, new_node.lower = cur.next, lower\\n            cur.next = new_node\\n    \\n    def search(self, target: int) -> bool:\\n        cur = self.sentinel\\n        while cur:\\n            if cur.val == target:\\n                return True\\n            elif not cur.next or cur.next.val > target:\\n                cur = cur.lower\\n            else:\\n                cur = cur.next\\n        return False\\n\\n    def add(self, num: int) -> None:\\n        def insertLower(head):\\n            cur= head\\n            while cur.next and cur.next.val <= num: # will append at the last of duplicated elements\\n                cur = cur.next\\n            if cur.lower: # if there are lower levels, insert into lower levels and coin flip if needed               \\n                insertLower(cur.lower)\\n                self._flip(cur)  # coin flip if needed\\n            else: # if there are not lower levels (current level is deepest), insert into current level\\n                new_node = Node(num)\\n                new_node.next = cur.next\\n                cur.next = new_node\\n                \\n        insertLower(self.sentinel)\\n        count = 0\\n        p = self.sentinel\\n        while p:\\n            p = p.next\\n            count += 1\\n        if count >= 4: # initiatiate a new level\\n            new_level = Node(-sys.maxsize)\\n            lower = self.sentinel.next.next\\n            new_node = Node(lower.val)\\n            new_node.lower = lower\\n            new_level.next = new_node\\n            new_level.lower = self.sentinel\\n            self.sentinel = new_level\\n\\n    def erase(self, num: int) -> bool:\\n        def eraseLower(head): # returns the deleted node if any\\n            cur = head\\n            while cur.next and cur.next.val < num: # will delete from the beginning of duplicated elements\\n                cur = cur.next\\n            removed = None\\n            if cur.lower: # if there are lower levels, delete from lower levels first\\n                deleted = eraseLower(cur.lower)\\n                if cur.next and cur.next.lower == deleted:\\n                    removed = cur.next\\n                    cur.next = cur.next.next\\n                self._flip(cur) # coin flip if needed\\n            else: # if there are no lower levels, delete from current level\\n                removed = cur.next\\n                cur.next = cur.next.next\\n            return removed            \\n                \\n        if not self.search(num):\\n            return False\\n        \\n        eraseLower(self.sentinel)\\n        while self.sentinel.lower and not self.sentinel.next: # delete empty levels if needed\\n            self.sentinel = self.sentinel.lower\\n            \\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.next = None\\n        self.lower = None\\n\\nclass Skiplist:\\n    def __init__(self):\\n        self.sentinel = Node(-sys.maxsize)\\n\\n    def _flip(self, cur):\\n        target = None if not cur.next else cur.next.lower\\n        p, count = cur.lower, 0\\n        while p != target:\\n            p = p.next\\n            count += 1\\n        if count >= 4:\\n            lower = cur.lower.next.next\\n            new_node = Node(lower.val)\\n            new_node.next, new_node.lower = cur.next, lower\\n            cur.next = new_node\\n    \\n    def search(self, target: int) -> bool:\\n        cur = self.sentinel\\n        while cur:\\n            if cur.val == target:\\n                return True\\n            elif not cur.next or cur.next.val > target:\\n                cur = cur.lower\\n            else:\\n                cur = cur.next\\n        return False\\n\\n    def add(self, num: int) -> None:\\n        def insertLower(head):\\n            cur= head\\n            while cur.next and cur.next.val <= num: # will append at the last of duplicated elements\\n                cur = cur.next\\n            if cur.lower: # if there are lower levels, insert into lower levels and coin flip if needed               \\n                insertLower(cur.lower)\\n                self._flip(cur)  # coin flip if needed\\n            else: # if there are not lower levels (current level is deepest), insert into current level\\n                new_node = Node(num)\\n                new_node.next = cur.next\\n                cur.next = new_node\\n                \\n        insertLower(self.sentinel)\\n        count = 0\\n        p = self.sentinel\\n        while p:\\n            p = p.next\\n            count += 1\\n        if count >= 4: # initiatiate a new level\\n            new_level = Node(-sys.maxsize)\\n            lower = self.sentinel.next.next\\n            new_node = Node(lower.val)\\n            new_node.lower = lower\\n            new_level.next = new_node\\n            new_level.lower = self.sentinel\\n            self.sentinel = new_level\\n\\n    def erase(self, num: int) -> bool:\\n        def eraseLower(head): # returns the deleted node if any\\n            cur = head\\n            while cur.next and cur.next.val < num: # will delete from the beginning of duplicated elements\\n                cur = cur.next\\n            removed = None\\n            if cur.lower: # if there are lower levels, delete from lower levels first\\n                deleted = eraseLower(cur.lower)\\n                if cur.next and cur.next.lower == deleted:\\n                    removed = cur.next\\n                    cur.next = cur.next.next\\n                self._flip(cur) # coin flip if needed\\n            else: # if there are no lower levels, delete from current level\\n                removed = cur.next\\n                cur.next = cur.next.next\\n            return removed            \\n                \\n        if not self.search(num):\\n            return False\\n        \\n        eraseLower(self.sentinel)\\n        while self.sentinel.lower and not self.sentinel.next: # delete empty levels if needed\\n            self.sentinel = self.sentinel.lower\\n            \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039244,
                "title": "c-solution-by-bst",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe delete node function can be refered to the problem: 450. Delete Node in a BST.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary Search Tree\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BST{\\npublic:\\n    TreeNode* root;\\n    BST(){\\n        this->root = nullptr;\\n    }\\n    void insert(int v){\\n        if (this->root == nullptr){\\n            this->root = new TreeNode(v);\\n            return;\\n        }\\n        return this->insert(this->root, v);\\n    }\\n    void insert(TreeNode* root, int v){\\n        if (root == nullptr) return;\\n        if (v <= root->val){\\n            if (root->left == nullptr){\\n                TreeNode* p = new TreeNode(v);\\n                root->left = p;\\n                return;\\n            }\\n            return this->insert(root->left, v);\\n        }\\n        if (root->right == nullptr){\\n            TreeNode* p = new TreeNode(v);\\n            root->right = p;\\n            return;\\n        }\\n        return this->insert(root->right, v);\\n    }\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        // search the node\\n        auto [node, parent] = search(root, key, nullptr);\\n        if (node == nullptr) return root;\\n        // node is a leaf\\n        if (node->left == nullptr && node->right == nullptr){\\n            if (node == root) return nullptr;\\n            (parent->left == node) ? parent->left = nullptr : parent->right = nullptr;\\n            delete node; node = nullptr;\\n            return root;\\n        }\\n        // node has only one child\\n        if (node->left == nullptr && node->right != nullptr){\\n            if(node == root) {\\n                TreeNode* update_root = node->right;\\n                node->right = nullptr;\\n                delete node; node = nullptr;\\n                return update_root;\\n            }\\n            if (parent->left == node){\\n                parent->left = node->right;\\n                node->right = nullptr;\\n                delete node; node = nullptr;\\n                return root;\\n            }\\n            if (parent->right == node){\\n                parent->right = node->right;\\n                node->right = nullptr;\\n                delete node; node = nullptr;\\n                return root;\\n            }\\n            return nullptr;\\n        }\\n        if (node->left != nullptr && node->right == nullptr){\\n            if (node == root){\\n                TreeNode* update_root = node->left;\\n                node->left = nullptr;\\n                delete node; node = nullptr;\\n                return update_root;\\n            }\\n            if (parent->left == node){\\n                parent->left = node->left;\\n                node->left = nullptr;\\n                delete node; node = nullptr;\\n                return root;\\n            }\\n            if (parent->right == node){\\n                parent->right = node->left;\\n                node->left = nullptr;\\n                delete node; node = nullptr;\\n                return root;\\n            }\\n            return nullptr;\\n        }\\n        // the node has children\\n        if (node == root){\\n            TreeNode* p = node->right;\\n            TreeNode* q = nullptr;\\n            while(p != nullptr){\\n                q = p;\\n                p = p->left;\\n            }\\n            TreeNode* update_root = node->right;\\n            q->left = node->left;\\n            node->left = nullptr;   node->right = nullptr;\\n            delete node;    node = nullptr;\\n            return update_root;\\n        }\\n        if (parent->left == node){\\n            TreeNode* p = node->right;\\n            TreeNode* q = nullptr;\\n            while(p != nullptr){\\n                q = p;\\n                p = p->left;\\n            }\\n            parent->left = node->right;\\n            q->left = node->left;\\n            node->left = nullptr;   node->right = nullptr;\\n            delete node;    node = nullptr;\\n            return root;\\n        }\\n        if (parent->right == node){\\n            TreeNode* p = node->right;\\n            TreeNode* q = nullptr;\\n            while(p != nullptr){\\n                q = p;\\n                p = p->left;\\n            }\\n            parent->right = node->right;\\n            q->left = node->left;\\n            node->left = nullptr;   node->right = nullptr;\\n            delete node;    node = nullptr;\\n            return root;\\n        }\\n        return nullptr;\\n    }\\n    /* initially call search(root, key, nullptr)\\n    */\\n    pair<TreeNode*, TreeNode*> search(TreeNode* node, int key, TreeNode* parent){\\n        if (node == nullptr) return {nullptr, nullptr};\\n        if (node->val == key) return {node, parent};\\n        return (key < node->val) ? search(node->left, key, node) : search(node->right, key, node);\\n    }\\n};\\n\\nclass Skiplist {\\npublic:\\n    BST bst;\\n    Skiplist() {\\n        this->bst = BST();\\n    }\\n    \\n    bool search(int target) {\\n        auto [node, parent] = this->bst.search(this->bst.root, target, nullptr);\\n        return (node == nullptr) ? false : true;\\n    }\\n    \\n    void add(int num) {\\n        bst.insert(num);\\n    }\\n    \\n    bool erase(int num) {\\n        auto [node, parent] = this->bst.search(this->bst.root, num, nullptr);\\n        if (node == nullptr) return false;\\n        this->bst.root = this->bst.deleteNode(this->bst.root, num);\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass BST{\\npublic:\\n    TreeNode* root;\\n    BST(){\\n        this->root = nullptr;\\n    }\\n    void insert(int v){\\n        if (this->root == nullptr){\\n            this->root = new TreeNode(v);\\n            return;\\n        }\\n        return this->insert(this->root, v);\\n    }\\n    void insert(TreeNode* root, int v){\\n        if (root == nullptr) return;\\n        if (v <= root->val){\\n            if (root->left == nullptr){\\n                TreeNode* p = new TreeNode(v);\\n                root->left = p;\\n                return;\\n            }\\n            return this->insert(root->left, v);\\n        }\\n        if (root->right == nullptr){\\n            TreeNode* p = new TreeNode(v);\\n            root->right = p;\\n            return;\\n        }\\n        return this->insert(root->right, v);\\n    }\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        // search the node\\n        auto [node, parent] = search(root, key, nullptr);\\n        if (node == nullptr) return root;\\n        // node is a leaf\\n        if (node->left == nullptr && node->right == nullptr){\\n            if (node == root) return nullptr;\\n            (parent->left == node) ? parent->left = nullptr : parent->right = nullptr;\\n            delete node; node = nullptr;\\n            return root;\\n        }\\n        // node has only one child\\n        if (node->left == nullptr && node->right != nullptr){\\n            if(node == root) {\\n                TreeNode* update_root = node->right;\\n                node->right = nullptr;\\n                delete node; node = nullptr;\\n                return update_root;\\n            }\\n            if (parent->left == node){\\n                parent->left = node->right;\\n                node->right = nullptr;\\n                delete node; node = nullptr;\\n                return root;\\n            }\\n            if (parent->right == node){\\n                parent->right = node->right;\\n                node->right = nullptr;\\n                delete node; node = nullptr;\\n                return root;\\n            }\\n            return nullptr;\\n        }\\n        if (node->left != nullptr && node->right == nullptr){\\n            if (node == root){\\n                TreeNode* update_root = node->left;\\n                node->left = nullptr;\\n                delete node; node = nullptr;\\n                return update_root;\\n            }\\n            if (parent->left == node){\\n                parent->left = node->left;\\n                node->left = nullptr;\\n                delete node; node = nullptr;\\n                return root;\\n            }\\n            if (parent->right == node){\\n                parent->right = node->left;\\n                node->left = nullptr;\\n                delete node; node = nullptr;\\n                return root;\\n            }\\n            return nullptr;\\n        }\\n        // the node has children\\n        if (node == root){\\n            TreeNode* p = node->right;\\n            TreeNode* q = nullptr;\\n            while(p != nullptr){\\n                q = p;\\n                p = p->left;\\n            }\\n            TreeNode* update_root = node->right;\\n            q->left = node->left;\\n            node->left = nullptr;   node->right = nullptr;\\n            delete node;    node = nullptr;\\n            return update_root;\\n        }\\n        if (parent->left == node){\\n            TreeNode* p = node->right;\\n            TreeNode* q = nullptr;\\n            while(p != nullptr){\\n                q = p;\\n                p = p->left;\\n            }\\n            parent->left = node->right;\\n            q->left = node->left;\\n            node->left = nullptr;   node->right = nullptr;\\n            delete node;    node = nullptr;\\n            return root;\\n        }\\n        if (parent->right == node){\\n            TreeNode* p = node->right;\\n            TreeNode* q = nullptr;\\n            while(p != nullptr){\\n                q = p;\\n                p = p->left;\\n            }\\n            parent->right = node->right;\\n            q->left = node->left;\\n            node->left = nullptr;   node->right = nullptr;\\n            delete node;    node = nullptr;\\n            return root;\\n        }\\n        return nullptr;\\n    }\\n    /* initially call search(root, key, nullptr)\\n    */\\n    pair<TreeNode*, TreeNode*> search(TreeNode* node, int key, TreeNode* parent){\\n        if (node == nullptr) return {nullptr, nullptr};\\n        if (node->val == key) return {node, parent};\\n        return (key < node->val) ? search(node->left, key, node) : search(node->right, key, node);\\n    }\\n};\\n\\nclass Skiplist {\\npublic:\\n    BST bst;\\n    Skiplist() {\\n        this->bst = BST();\\n    }\\n    \\n    bool search(int target) {\\n        auto [node, parent] = this->bst.search(this->bst.root, target, nullptr);\\n        return (node == nullptr) ? false : true;\\n    }\\n    \\n    void add(int num) {\\n        bst.insert(num);\\n    }\\n    \\n    bool erase(int num) {\\n        auto [node, parent] = this->bst.search(this->bst.root, num, nullptr);\\n        if (node == nullptr) return false;\\n        this->bst.root = this->bst.deleteNode(this->bst.root, num);\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022402,
                "title": "go",
                "content": "# Complexity\\n- Time complexity:\\n$$O(log(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nconst (\\n    maxLevel = 32\\n)\\n\\nfunc randomLevel() int {\\n    level := 1\\n    for rand.Intn(2) == 1 {\\n        level++\\n    }\\n    if level > maxLevel {\\n        level = maxLevel\\n    }\\n    return level\\n}\\n\\ntype node struct {\\n    val int\\n    replicas int\\n    forwards []*node\\n}\\n\\ntype Skiplist struct {\\n    level int\\n    head *node\\n}\\n\\nfunc Constructor() Skiplist {\\n    return Skiplist {\\n        level: 0,\\n        head: &node{\\n            forwards: make([]*node, maxLevel),\\n        },\\n    }\\n}\\n\\nfunc (this *Skiplist) Search(target int) bool {\\n    return this.searchWithOp(target, searchOpNull)\\n}\\n\\ntype searchOp int\\n\\nconst (\\n    searchOpNull searchOp = 0\\n    searchOpAdd searchOp = 1\\n)\\n\\nfunc (this *Skiplist) searchWithOp(target int, op searchOp) bool {\\n    x := this.head\\n    for i := this.level-1; i >= 0; i-- {\\n        for x.forwards[i] != nil && x.forwards[i].val < target {\\n            x = x.forwards[i]\\n        }\\n        if x.forwards[i] != nil && x.forwards[i].val == target {\\n            switch op {\\n            case searchOpNull:\\n            case searchOpAdd:\\n                x.forwards[i].replicas += 1\\n            }\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\nfunc (this *Skiplist) Add(num int)  {\\n    if this.searchWithOp(num, searchOpAdd) {\\n        return\\n    }\\n\\n    l := randomLevel()\\n    if l > this.level {\\n        this.level = l\\n    }\\n\\n    n := &node{\\n        val: num,\\n        replicas: 1,\\n        forwards: make([]*node, l),\\n    }\\n\\n    x := this.head\\n    for i := this.level-1; i >= 0; i-- {\\n        for x.forwards[i] != nil && x.forwards[i].val < num {\\n            x = x.forwards[i]\\n        }\\n        if l-1 >= i {\\n            n.forwards[i] = x.forwards[i]\\n            x.forwards[i] = n\\n        }\\n    }\\n}\\n\\nfunc (this *Skiplist) Erase(num int) bool {\\n    erased := false\\n\\n    x := this.head\\n    for i := this.level-1; i >= 0; i-- {\\n        for x.forwards[i] != nil && x.forwards[i].val < num {\\n            x = x.forwards[i]\\n        }\\n        if x.forwards[i] != nil && x.forwards[i].val == num {\\n            if !erased {\\n                erased = true\\n                x.forwards[i].replicas -= 1\\n            }\\n            if x.forwards[i].replicas < 1 {\\n                x.forwards[i] = x.forwards[i].forwards[i]\\n            }\\n        }\\n    }\\n    for i, forward := range this.head.forwards {\\n        if forward == nil {\\n            this.level = i\\n            break\\n        }\\n    }\\n    return erased    \\n}\\n\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * obj := Constructor();\\n * param_1 := obj.Search(target);\\n * obj.Add(num);\\n * param_3 := obj.Erase(num);\\n */\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nconst (\\n    maxLevel = 32\\n)\\n\\nfunc randomLevel() int {\\n    level := 1\\n    for rand.Intn(2) == 1 {\\n        level++\\n    }\\n    if level > maxLevel {\\n        level = maxLevel\\n    }\\n    return level\\n}\\n\\ntype node struct {\\n    val int\\n    replicas int\\n    forwards []*node\\n}\\n\\ntype Skiplist struct {\\n    level int\\n    head *node\\n}\\n\\nfunc Constructor() Skiplist {\\n    return Skiplist {\\n        level: 0,\\n        head: &node{\\n            forwards: make([]*node, maxLevel),\\n        },\\n    }\\n}\\n\\nfunc (this *Skiplist) Search(target int) bool {\\n    return this.searchWithOp(target, searchOpNull)\\n}\\n\\ntype searchOp int\\n\\nconst (\\n    searchOpNull searchOp = 0\\n    searchOpAdd searchOp = 1\\n)\\n\\nfunc (this *Skiplist) searchWithOp(target int, op searchOp) bool {\\n    x := this.head\\n    for i := this.level-1; i >= 0; i-- {\\n        for x.forwards[i] != nil && x.forwards[i].val < target {\\n            x = x.forwards[i]\\n        }\\n        if x.forwards[i] != nil && x.forwards[i].val == target {\\n            switch op {\\n            case searchOpNull:\\n            case searchOpAdd:\\n                x.forwards[i].replicas += 1\\n            }\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\nfunc (this *Skiplist) Add(num int)  {\\n    if this.searchWithOp(num, searchOpAdd) {\\n        return\\n    }\\n\\n    l := randomLevel()\\n    if l > this.level {\\n        this.level = l\\n    }\\n\\n    n := &node{\\n        val: num,\\n        replicas: 1,\\n        forwards: make([]*node, l),\\n    }\\n\\n    x := this.head\\n    for i := this.level-1; i >= 0; i-- {\\n        for x.forwards[i] != nil && x.forwards[i].val < num {\\n            x = x.forwards[i]\\n        }\\n        if l-1 >= i {\\n            n.forwards[i] = x.forwards[i]\\n            x.forwards[i] = n\\n        }\\n    }\\n}\\n\\nfunc (this *Skiplist) Erase(num int) bool {\\n    erased := false\\n\\n    x := this.head\\n    for i := this.level-1; i >= 0; i-- {\\n        for x.forwards[i] != nil && x.forwards[i].val < num {\\n            x = x.forwards[i]\\n        }\\n        if x.forwards[i] != nil && x.forwards[i].val == num {\\n            if !erased {\\n                erased = true\\n                x.forwards[i].replicas -= 1\\n            }\\n            if x.forwards[i].replicas < 1 {\\n                x.forwards[i] = x.forwards[i].forwards[i]\\n            }\\n        }\\n    }\\n    for i, forward := range this.head.forwards {\\n        if forward == nil {\\n            this.level = i\\n            break\\n        }\\n    }\\n    return erased    \\n}\\n\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * obj := Constructor();\\n * param_1 := obj.Search(target);\\n * obj.Add(num);\\n * param_3 := obj.Erase(num);\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4007513,
                "title": "python3-readable-version-hopefully",
                "content": "\\n```\\nfrom random import getrandbits\\n\\n\\nclass SkipNode:\\n    __slots__ = \"prev\", \"next\", \"child\", \"value\"\\n\\n    def __init__(self, prev=None, next=None, child=None, value=-float(\"inf\")):\\n        self.prev = prev\\n        self.next = next\\n        self.child = child\\n        self.value = value\\n        if next:\\n            next.prev = self\\n\\n    def insert(self, value, child=None):\\n        self.next = SkipNode(self, self.next, child, value)\\n        return self.next\\n\\n    def unlink(self):\\n        prev, next = self.prev, self.next\\n        prev.next = next\\n        if next:\\n            next.prev = prev\\n        if child := self.child:\\n            child.unlink()\\n\\n\\nclass Skiplist:\\n    __slots__ = (\"roots\",)\\n\\n    def __init__(self):\\n        self.roots = [SkipNode()]\\n\\n    def search(self, target: int) -> bool:\\n        return self._search(target)[0]\\n\\n    def _search(self, target):\\n        node = self.roots[-1]\\n        found = False\\n        chain = []\\n\\n        while node:\\n            if node.value == target:\\n                chain.append(node)\\n                found = True\\n                break\\n\\n            if (next := node.next) and next.value <= target:\\n                node = next\\n            else:\\n                chain.append(node)\\n                node = node.child\\n\\n        return found, chain\\n\\n    def add(self, num: int) -> None:\\n        chain = self._search(num)[1]\\n        node = chain[-1]\\n\\n        while child := node.child:\\n            chain.append(child)\\n            node = child\\n\\n        chain.pop()\\n        chain = iter(reversed(chain))\\n        node = node.insert(num)\\n\\n        while getrandbits(1):\\n            if not (prev := next(chain, None)):\\n                prev = SkipNode(child=self.roots[-1])\\n                self.roots.append(prev)\\n\\n            node = prev.insert(num, node)\\n\\n    def erase(self, num: int) -> bool:\\n        found, chain = self._search(num)\\n        if not found:\\n            return False\\n\\n        chain[-1].unlink()\\n\\n        roots = self.roots\\n        while len(roots) > 1 and not roots[-1].next:\\n            roots.pop()\\n\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom random import getrandbits\\n\\n\\nclass SkipNode:\\n    __slots__ = \"prev\", \"next\", \"child\", \"value\"\\n\\n    def __init__(self, prev=None, next=None, child=None, value=-float(\"inf\")):\\n        self.prev = prev\\n        self.next = next\\n        self.child = child\\n        self.value = value\\n        if next:\\n            next.prev = self\\n\\n    def insert(self, value, child=None):\\n        self.next = SkipNode(self, self.next, child, value)\\n        return self.next\\n\\n    def unlink(self):\\n        prev, next = self.prev, self.next\\n        prev.next = next\\n        if next:\\n            next.prev = prev\\n        if child := self.child:\\n            child.unlink()\\n\\n\\nclass Skiplist:\\n    __slots__ = (\"roots\",)\\n\\n    def __init__(self):\\n        self.roots = [SkipNode()]\\n\\n    def search(self, target: int) -> bool:\\n        return self._search(target)[0]\\n\\n    def _search(self, target):\\n        node = self.roots[-1]\\n        found = False\\n        chain = []\\n\\n        while node:\\n            if node.value == target:\\n                chain.append(node)\\n                found = True\\n                break\\n\\n            if (next := node.next) and next.value <= target:\\n                node = next\\n            else:\\n                chain.append(node)\\n                node = node.child\\n\\n        return found, chain\\n\\n    def add(self, num: int) -> None:\\n        chain = self._search(num)[1]\\n        node = chain[-1]\\n\\n        while child := node.child:\\n            chain.append(child)\\n            node = child\\n\\n        chain.pop()\\n        chain = iter(reversed(chain))\\n        node = node.insert(num)\\n\\n        while getrandbits(1):\\n            if not (prev := next(chain, None)):\\n                prev = SkipNode(child=self.roots[-1])\\n                self.roots.append(prev)\\n\\n            node = prev.insert(num, node)\\n\\n    def erase(self, num: int) -> bool:\\n        found, chain = self._search(num)\\n        if not found:\\n            return False\\n\\n        chain[-1].unlink()\\n\\n        roots = self.roots\\n        while len(roots) > 1 and not roots[-1].next:\\n            roots.pop()\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987445,
                "title": "design-skiplist",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Skiplist {\\n\\n    public Skiplist() {\\n        \\n    }\\n    ArrayList<Integer> arr = new ArrayList<>();\\n    public boolean search(int target) {\\n        if(arr.contains(target))\\n        return true;\\n        return false;\\n    }\\n    \\n    public void add(int num) {\\n        arr.add(num);\\n    }\\n    \\n    public boolean erase(int num) {\\n        if(arr.contains(num)==false)\\n        return false;\\n        else\\n        {\\n            arr.remove(Integer.valueOf(num));\\n        }\\n        return true;\\n    }\\n}\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist obj = new Skiplist();\\n * boolean param_1 = obj.search(target);\\n * obj.add(num);\\n * boolean param_3 = obj.erase(num);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Skiplist {\\n\\n    public Skiplist() {\\n        \\n    }\\n    ArrayList<Integer> arr = new ArrayList<>();\\n    public boolean search(int target) {\\n        if(arr.contains(target))\\n        return true;\\n        return false;\\n    }\\n    \\n    public void add(int num) {\\n        arr.add(num);\\n    }\\n    \\n    public boolean erase(int num) {\\n        if(arr.contains(num)==false)\\n        return false;\\n        else\\n        {\\n            arr.remove(Integer.valueOf(num));\\n        }\\n        return true;\\n    }\\n}\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist obj = new Skiplist();\\n * boolean param_1 = obj.search(target);\\n * obj.add(num);\\n * boolean param_3 = obj.erase(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911190,
                "title": "runtime-details-47ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// \\u5B9A\\u4E49\\u8282\\u70B9\\u7ED3\\u6784\\u4F53\\nstruct Node {\\n    int val;            // \\u8282\\u70B9\\u7684\\u503C\\n    struct Node* right; // \\u53F3\\u6307\\u9488\\uFF0C\\u8FDE\\u63A5\\u540C\\u5C42\\u7684\\u4E0B\\u4E00\\u4E2A\\u8282\\u70B9\\n    struct Node* down;  // \\u4E0B\\u6307\\u9488\\uFF0C\\u8FDE\\u63A5\\u4E0B\\u4E00\\u5C42\\u7684\\u76F8\\u540C\\u4F4D\\u7F6E\\u8282\\u70B9\\n};\\n\\ntypedef struct Node Node;\\n\\n// \\u5B9A\\u4E49 Skiplist \\u7ED3\\u6784\\u4F53\\nstruct Skiplist {\\n    Node* head; // \\u5934\\u8282\\u70B9\\uFF0C\\u4E5F\\u662F\\u6BCF\\u4E00\\u5C42\\u7684\\u8D77\\u59CB\\u8282\\u70B9\\n};\\n\\ntypedef struct Skiplist Skiplist;\\n\\n// \\u521B\\u5EFA\\u65B0\\u7684\\u8282\\u70B9\\nNode* createNode(int val, Node* right, Node* down) {\\n    Node* newNode = (Node*)malloc(sizeof(Node));\\n    newNode->val = val;\\n    newNode->right = right;\\n    newNode->down = down;\\n    return newNode;\\n}\\n\\n// \\u521D\\u59CB\\u5316 Skiplist\\nSkiplist* skiplistCreate() {\\n    Skiplist* obj = (Skiplist*)malloc(sizeof(Skiplist));\\n    // \\u521B\\u5EFA\\u4E00\\u4E2A\\u5E26\\u6709\\u8D1F\\u65E0\\u7A77\\u503C\\u7684\\u5934\\u8282\\u70B9\\uFF0C\\u4F5C\\u4E3A\\u6BCF\\u4E00\\u5C42\\u7684\\u8D77\\u59CB\\u8282\\u70B9\\n    obj->head = createNode(-1, NULL, NULL); // Dummy head\\n    return obj;\\n}\\n\\n// \\u67E5\\u627E\\u64CD\\u4F5C\\nbool skiplistSearch(Skiplist* obj, int target) {\\n    Node* node = obj->head;\\n    while (node) {\\n        // \\u5728\\u5F53\\u524D\\u5C42\\u5411\\u53F3\\u904D\\u5386\\uFF0C\\u627E\\u5230\\u5C0F\\u4E8E\\u76EE\\u6807\\u503C\\u7684\\u8282\\u70B9\\n        while (node->right && node->right->val < target) {\\n            node = node->right;\\n        }\\n        // \\u5982\\u679C\\u53F3\\u8282\\u70B9\\u5B58\\u5728\\u4E14\\u503C\\u7B49\\u4E8E\\u76EE\\u6807\\u503C\\uFF0C\\u5219\\u627E\\u5230\\u76EE\\u6807\\u503C\\n        if (node->right && node->right->val == target) {\\n            return true;\\n        }\\n        // \\u5411\\u4E0B\\u4E00\\u5C42\\u79FB\\u52A8\\n        node = node->down;\\n    }\\n    return false;\\n}\\n\\n// \\u63D2\\u5165\\u64CD\\u4F5C\\nvoid skiplistAdd(Skiplist* obj, int num) {\\n    Node* nodes[100]; // \\u5047\\u8BBE\\u6700\\u5927\\u5C42\\u6570\\u4E3A100\\n    Node* node = obj->head;\\n    int top = 0;\\n\\n    // \\u627E\\u5230\\u8981\\u63D2\\u5165\\u4F4D\\u7F6E\\u7684\\u8282\\u70B9\\n    while (node) {\\n        // \\u5728\\u5F53\\u524D\\u5C42\\u5411\\u53F3\\u904D\\u5386\\uFF0C\\u627E\\u5230\\u5C0F\\u4E8E\\u76EE\\u6807\\u503C\\u7684\\u8282\\u70B9\\n        while (node->right && node->right->val < num) {\\n            node = node->right;\\n        }\\n        nodes[top++] = node; // \\u5C06\\u904D\\u5386\\u8FC7\\u7684\\u8282\\u70B9\\u4FDD\\u5B58\\u5230\\u6570\\u7EC4\\u4E2D\\n        // \\u5411\\u4E0B\\u4E00\\u5C42\\u79FB\\u52A8\\n        node = node->down;\\n    }\\n\\n    bool insert = true;\\n    Node* down = NULL;\\n    while (insert && top > 0) {\\n        node = nodes[--top]; // \\u5F39\\u51FA\\u4FDD\\u5B58\\u7684\\u8282\\u70B9\\n        // \\u63D2\\u5165\\u65B0\\u8282\\u70B9\\n        node->right = createNode(num, node->right, down);\\n        down = node->right;\\n        // \\u968F\\u673A\\u51B3\\u5B9A\\u662F\\u5426\\u5411\\u4E0A\\u63D2\\u5165\\n        insert = (rand() & 1) == 0;\\n    }\\n\\n    // \\u521B\\u5EFA\\u4E00\\u4E2A\\u65B0\\u7684\\u5C42\\uFF0C\\u4F7F\\u7528\\u8D1F\\u65E0\\u7A77\\u503C\\u4F5C\\u4E3A\\u5934\\u8282\\u70B9\\n    if (insert) {\\n        obj->head = createNode(-1, NULL, obj->head);\\n    }\\n}\\n\\n// \\u5220\\u9664\\u64CD\\u4F5C\\nbool skiplistErase(Skiplist* obj, int num) {\\n    Node* node = obj->head;\\n    bool found = false;\\n    while (node) {\\n        // \\u5728\\u5F53\\u524D\\u5C42\\u5411\\u53F3\\u904D\\u5386\\uFF0C\\u627E\\u5230\\u5C0F\\u4E8E\\u76EE\\u6807\\u503C\\u7684\\u8282\\u70B9\\n        while (node->right && node->right->val < num) {\\n            node = node->right;\\n        }\\n        // \\u5982\\u679C\\u53F3\\u8282\\u70B9\\u5B58\\u5728\\u4E14\\u503C\\u7B49\\u4E8E\\u76EE\\u6807\\u503C\\uFF0C\\u5219\\u627E\\u5230\\u76EE\\u6807\\u503C\\n        if (node->right && node->right->val == num) {\\n            // \\u8DF3\\u8FC7\\u76EE\\u6807\\u8282\\u70B9\\uFF0C\\u5B9E\\u73B0\\u5220\\u9664\\n            Node* temp = node->right;\\n            node->right = node->right->right;\\n            free(temp);\\n            found = true;\\n        }\\n        // \\u5411\\u4E0B\\u4E00\\u5C42\\u79FB\\u52A8\\n        node = node->down;\\n    }\\n    return found;\\n}\\n\\n// \\u91CA\\u653E\\u5185\\u5B58\\nvoid skiplistFree(Skiplist* obj) {\\n    Node* node = obj->head;\\n    while (node) {\\n        Node* temp = node;\\n        node = node->down;\\n        Node* rightNode = temp->right;\\n        while (rightNode) {\\n            Node* rightTemp = rightNode;\\n            rightNode = rightNode->right;\\n            free(rightTemp);\\n        }\\n        free(temp);\\n    }\\n    free(obj);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// \\u5B9A\\u4E49\\u8282\\u70B9\\u7ED3\\u6784\\u4F53\\nstruct Node {\\n    int val;            // \\u8282\\u70B9\\u7684\\u503C\\n    struct Node* right; // \\u53F3\\u6307\\u9488\\uFF0C\\u8FDE\\u63A5\\u540C\\u5C42\\u7684\\u4E0B\\u4E00\\u4E2A\\u8282\\u70B9\\n    struct Node* down;  // \\u4E0B\\u6307\\u9488\\uFF0C\\u8FDE\\u63A5\\u4E0B\\u4E00\\u5C42\\u7684\\u76F8\\u540C\\u4F4D\\u7F6E\\u8282\\u70B9\\n};\\n\\ntypedef struct Node Node;\\n\\n// \\u5B9A\\u4E49 Skiplist \\u7ED3\\u6784\\u4F53\\nstruct Skiplist {\\n    Node* head; // \\u5934\\u8282\\u70B9\\uFF0C\\u4E5F\\u662F\\u6BCF\\u4E00\\u5C42\\u7684\\u8D77\\u59CB\\u8282\\u70B9\\n};\\n\\ntypedef struct Skiplist Skiplist;\\n\\n// \\u521B\\u5EFA\\u65B0\\u7684\\u8282\\u70B9\\nNode* createNode(int val, Node* right, Node* down) {\\n    Node* newNode = (Node*)malloc(sizeof(Node));\\n    newNode->val = val;\\n    newNode->right = right;\\n    newNode->down = down;\\n    return newNode;\\n}\\n\\n// \\u521D\\u59CB\\u5316 Skiplist\\nSkiplist* skiplistCreate() {\\n    Skiplist* obj = (Skiplist*)malloc(sizeof(Skiplist));\\n    // \\u521B\\u5EFA\\u4E00\\u4E2A\\u5E26\\u6709\\u8D1F\\u65E0\\u7A77\\u503C\\u7684\\u5934\\u8282\\u70B9\\uFF0C\\u4F5C\\u4E3A\\u6BCF\\u4E00\\u5C42\\u7684\\u8D77\\u59CB\\u8282\\u70B9\\n    obj->head = createNode(-1, NULL, NULL); // Dummy head\\n    return obj;\\n}\\n\\n// \\u67E5\\u627E\\u64CD\\u4F5C\\nbool skiplistSearch(Skiplist* obj, int target) {\\n    Node* node = obj->head;\\n    while (node) {\\n        // \\u5728\\u5F53\\u524D\\u5C42\\u5411\\u53F3\\u904D\\u5386\\uFF0C\\u627E\\u5230\\u5C0F\\u4E8E\\u76EE\\u6807\\u503C\\u7684\\u8282\\u70B9\\n        while (node->right && node->right->val < target) {\\n            node = node->right;\\n        }\\n        // \\u5982\\u679C\\u53F3\\u8282\\u70B9\\u5B58\\u5728\\u4E14\\u503C\\u7B49\\u4E8E\\u76EE\\u6807\\u503C\\uFF0C\\u5219\\u627E\\u5230\\u76EE\\u6807\\u503C\\n        if (node->right && node->right->val == target) {\\n            return true;\\n        }\\n        // \\u5411\\u4E0B\\u4E00\\u5C42\\u79FB\\u52A8\\n        node = node->down;\\n    }\\n    return false;\\n}\\n\\n// \\u63D2\\u5165\\u64CD\\u4F5C\\nvoid skiplistAdd(Skiplist* obj, int num) {\\n    Node* nodes[100]; // \\u5047\\u8BBE\\u6700\\u5927\\u5C42\\u6570\\u4E3A100\\n    Node* node = obj->head;\\n    int top = 0;\\n\\n    // \\u627E\\u5230\\u8981\\u63D2\\u5165\\u4F4D\\u7F6E\\u7684\\u8282\\u70B9\\n    while (node) {\\n        // \\u5728\\u5F53\\u524D\\u5C42\\u5411\\u53F3\\u904D\\u5386\\uFF0C\\u627E\\u5230\\u5C0F\\u4E8E\\u76EE\\u6807\\u503C\\u7684\\u8282\\u70B9\\n        while (node->right && node->right->val < num) {\\n            node = node->right;\\n        }\\n        nodes[top++] = node; // \\u5C06\\u904D\\u5386\\u8FC7\\u7684\\u8282\\u70B9\\u4FDD\\u5B58\\u5230\\u6570\\u7EC4\\u4E2D\\n        // \\u5411\\u4E0B\\u4E00\\u5C42\\u79FB\\u52A8\\n        node = node->down;\\n    }\\n\\n    bool insert = true;\\n    Node* down = NULL;\\n    while (insert && top > 0) {\\n        node = nodes[--top]; // \\u5F39\\u51FA\\u4FDD\\u5B58\\u7684\\u8282\\u70B9\\n        // \\u63D2\\u5165\\u65B0\\u8282\\u70B9\\n        node->right = createNode(num, node->right, down);\\n        down = node->right;\\n        // \\u968F\\u673A\\u51B3\\u5B9A\\u662F\\u5426\\u5411\\u4E0A\\u63D2\\u5165\\n        insert = (rand() & 1) == 0;\\n    }\\n\\n    // \\u521B\\u5EFA\\u4E00\\u4E2A\\u65B0\\u7684\\u5C42\\uFF0C\\u4F7F\\u7528\\u8D1F\\u65E0\\u7A77\\u503C\\u4F5C\\u4E3A\\u5934\\u8282\\u70B9\\n    if (insert) {\\n        obj->head = createNode(-1, NULL, obj->head);\\n    }\\n}\\n\\n// \\u5220\\u9664\\u64CD\\u4F5C\\nbool skiplistErase(Skiplist* obj, int num) {\\n    Node* node = obj->head;\\n    bool found = false;\\n    while (node) {\\n        // \\u5728\\u5F53\\u524D\\u5C42\\u5411\\u53F3\\u904D\\u5386\\uFF0C\\u627E\\u5230\\u5C0F\\u4E8E\\u76EE\\u6807\\u503C\\u7684\\u8282\\u70B9\\n        while (node->right && node->right->val < num) {\\n            node = node->right;\\n        }\\n        // \\u5982\\u679C\\u53F3\\u8282\\u70B9\\u5B58\\u5728\\u4E14\\u503C\\u7B49\\u4E8E\\u76EE\\u6807\\u503C\\uFF0C\\u5219\\u627E\\u5230\\u76EE\\u6807\\u503C\\n        if (node->right && node->right->val == num) {\\n            // \\u8DF3\\u8FC7\\u76EE\\u6807\\u8282\\u70B9\\uFF0C\\u5B9E\\u73B0\\u5220\\u9664\\n            Node* temp = node->right;\\n            node->right = node->right->right;\\n            free(temp);\\n            found = true;\\n        }\\n        // \\u5411\\u4E0B\\u4E00\\u5C42\\u79FB\\u52A8\\n        node = node->down;\\n    }\\n    return found;\\n}\\n\\n// \\u91CA\\u653E\\u5185\\u5B58\\nvoid skiplistFree(Skiplist* obj) {\\n    Node* node = obj->head;\\n    while (node) {\\n        Node* temp = node;\\n        node = node->down;\\n        Node* rightNode = temp->right;\\n        while (rightNode) {\\n            Node* rightTemp = rightNode;\\n            rightNode = rightNode->right;\\n            free(rightTemp);\\n        }\\n        free(temp);\\n    }\\n    free(obj);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3910782,
                "title": "simple-to-understand-solution-with-level-lists-2-solutions",
                "content": "![\\u0421\\u043D\\u0438\\u043C\\u043E\\u043A \\u044D\\u043A\\u0440\\u0430\\u043D\\u0430 2023-08-15 \\u0432 05.51.01.png](https://assets.leetcode.com/users/images/1da02d7b-feec-4ba6-bab4-55c6dd6e8848_1692067916.3643434.png)\\n```\\nclass ListNode:\\n    def __init__(self, val=0, counter= 1, next=[]):\\n        self.val = val\\n        self.counter = counter\\n        self.next = next\\n\\nclass Skiplist:\\n    def __init__(self):\\n        self.max_level = 1   \\n        self.max_length = 1\\n        self.length_list = 0\\n        self.tail = ListNode(val= inf)\\n        self.head = ListNode(val= -inf, next= [self.tail])\\n\\n    def search(self, target: int) -> bool:\\n        node = self.head\\n        for i in range(len(self.head.next)-1, -1, -1):\\n            while node.next[i].val <= target:\\n                node = node.next[i]\\n            if node.val == target:\\n                return True\\n        return False  \\n\\n    # generated random namber of levels in the range [0, max_level]\\n    def random_level(self):\\n        level = 0\\n        #  max_level = log(length_list, 2)\\n        if self.length_list > self.max_length:\\n            self.max_level += 1\\n            self.max_length *= 2 \\n        while random.random() < 0.5 and level < self.max_level:\\n            level += 1      \\n            yield\\n\\n    def add(self, num: int) -> None:\\n        node = self.head\\n        stack = []\\n        for i in range(len(self.head.next)-1, -1, -1):     \\n            while node.next[i].val <= num:\\n                node = node.next[i]\\n            #if \"num\" is found in the list, increase the count of \"num\"s and exit        \\n            if node.val == num: \\n                node.counter += 1\\n                return\\n            stack.append((node, i))\\n        #insert \"num\" in lowest level\\n        prev_node, i = stack.pop()\\n        node = ListNode(val= num, next=[prev_node.next[i]])\\n        prev_node.next[i] = node\\n        self.length_list += 1 #increase length list\\n        \\n        for _ in self.random_level():\\n            if stack:\\n                #insert duplicate \"num\" in exists level\\n                prev_node, i = stack.pop()\\n                node.next.append(prev_node.next[i])\\n                prev_node.next[i] = node\\n            else:\\n                #create new level with duplicate \"num\"\\n                self.head.next.append(node)\\n                node.next.append(self.tail)\\n\\n    def erase(self, num: int) -> bool:       \\n        node = self.head\\n        flag = False  #if finded \"num\" then \"flag\" = True\\n        for i in range(len(self.head.next)-1, -1, -1):     \\n            while node.next[i].val < num:\\n                node = node.next[i]\\n            if node.next[i].val == num:\\n                if flag:\\n                    node.next[i] = node.next[i].next[i] #erase \"num\" in \"i\"-level\\n                else:\\n                    node.next[i].counter -= 1 #reduce the count of \"num\"s\\n                    if node.next[i].counter > 0:  \\n                        return True         \\n                    node.next[i] = node.next[i].next[i]\\n                    flag = True     \\n        if flag:\\n            #remove the top level if it\\'s empty\\n            while self.head.next[-1] == self.tail and len(self.head.next) > 1:\\n                self.head.next.pop()\\n            self.length_list -= 1 #reduce length list\\n        return flag              \\n```\\n# One more solution\\n![\\u0421\\u043D\\u0438\\u043C\\u043E\\u043A \\u044D\\u043A\\u0440\\u0430\\u043D\\u0430 2023-08-15 \\u0432 05.02.49.png](https://assets.leetcode.com/users/images/7c047dfa-2769-42ad-9a0e-bac3e596dfdf_1692067078.5935473.png)\\n```\\nclass ValueNode:\\n    def __init__(self, num= 0, counter= 1):\\n        self.num = num\\n        self.counter = counter\\n\\nclass ListNode:\\n    def __init__(self, value= None, down = None, next= None):\\n        self.value = value\\n        self.down = down\\n        self.next = next\\n\\nclass Skiplist:\\n    def __init__(self):\\n        self.max_level = 1\\n        self.max_length = 1\\n        self.length_list = 0\\n        self.tail = ListNode(value= ValueNode(num= inf))\\n        self.head = ListNode(value= ValueNode(num= -inf), next= self.tail)     \\n\\n    def search(self, target: int) -> bool:\\n        node = self.head\\n        while node:\\n            while node.next.value.num <= target:                                          \\n                node = node.next\\n            if node.value.num == target:\\n                return True                \\n            node = node.down                          \\n        return False\\n\\n    def random_level(self):\\n        level = 0\\n        if self.length_list > self.max_length:\\n            self.max_level += 1\\n            self.max_length *= 2 \\n        while random.random() < 0.5 and level < self.max_level:\\n            level += 1      \\n            yield\\n\\n    def add(self, num: int) -> None:\\n        node = self.head\\n        stack = []\\n        while node:\\n            while node.next.value.num <= num:                                          \\n                node = node.next       \\n            if node.value.num == num: \\n                node.value.counter += 1\\n                return\\n            stack.append(node)\\n            node = node.down\\n        prev_node = stack.pop()\\n        node = ListNode(value= ValueNode(num= num))\\n        node.next = prev_node.next\\n        prev_node.next = node\\n        self.length_list += 1     \\n        for _ in self.random_level():\\n            new_node = ListNode(value= node.value, down= node)\\n            if stack:\\n                prev_node = stack.pop()\\n                new_node.next = prev_node.next\\n                prev_node.next = new_node                \\n            else:\\n                self.head = ListNode(value= self.head.value, down= self.head, next= new_node)\\n                new_node.next = ListNode(value= self.tail.value, down= self.tail)\\n                self.tail = new_node.next\\n            node = new_node\\n                   \\n    def erase(self, num: int) -> bool:\\n        node = self.head\\n        flag = False\\n        while node:\\n            while node.next.value.num < num:                                          \\n                node = node.next       \\n            if node.next.value.num == num:\\n                if flag:\\n                    node.next = node.next.next\\n                else:\\n                    node.next.value.counter -= 1\\n                    if node.next.value.counter > 0:\\n                        return True\\n                    node.next = node.next.next\\n                    flag = True \\n            node = node.down     \\n        if flag:\\n            while self.head.next == self.tail and self.head.down:\\n                self.head = self.head.down\\n                self.tail = self.tail.down\\n            self.length_list -= 1\\n        return flag                        \\n```\\n# Solution with recursion\\n```\\nclass ListNode:\\n    def __init__(self, val= 0, next= None, down = None):\\n        self.val = val\\n        self.next = next\\n        self.down = down\\n\\nclass Skiplist:\\n    def __init__(self):\\n        self.head = ListNode(val= -inf)      \\n      \\n    def searchRec(self, node, target): \\n        while node.next and node.next.val <= target:                                       \\n            node = node.next                                         \\n        if node.down == None:                                   \\n            return node.val                                      \\n        return self.searchRec(node.down, target)\\n  \\n    def search(self, target: int) -> bool:\\n        return self.searchRec(self.head, target) == target\\n\\n    def addRec(self, node, num):\\n        while node.next and node.next.val < num:\\n            node = node.next                                    \\n        if node.down == None:\\n            downNode = None\\n        else:\\n            downNode = self.addRec(node.down, num)\\n        if downNode != None or node.down == None:\\n            node.next = ListNode(val= num, next= node.next, down= downNode)\\n            if random.random() < 0.5:\\n                return node.next\\n            return None          \\n   \\n    def add(self, num: int) -> None:\\n        node = self.addRec(self.head, num)\\n        if node != None:\\n            newNode = ListNode(val= -inf, down=self.head)\\n            newNode.next = ListNode(val= num, down= node)\\n            self.head = newNode\\n          \\n    def eraseRec(self, node, num):\\n        flag = False\\n        while node.next and node.next.val < num:\\n            node = node.next\\n        if node.down != None:\\n            flag = self.eraseRec(node.down, num)\\n        if node.next and node.next.val == num:\\n            node.next = node.next.next\\n            return True\\n        return flag\\n        \\n    def erase(self, num: int) -> bool:\\n        return self.eraseRec(self.head, num)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass ListNode:\\n    def __init__(self, val=0, counter= 1, next=[]):\\n        self.val = val\\n        self.counter = counter\\n        self.next = next\\n\\nclass Skiplist:\\n    def __init__(self):\\n        self.max_level = 1   \\n        self.max_length = 1\\n        self.length_list = 0\\n        self.tail = ListNode(val= inf)\\n        self.head = ListNode(val= -inf, next= [self.tail])\\n\\n    def search(self, target: int) -> bool:\\n        node = self.head\\n        for i in range(len(self.head.next)-1, -1, -1):\\n            while node.next[i].val <= target:\\n                node = node.next[i]\\n            if node.val == target:\\n                return True\\n        return False  \\n\\n    # generated random namber of levels in the range [0, max_level]\\n    def random_level(self):\\n        level = 0\\n        #  max_level = log(length_list, 2)\\n        if self.length_list > self.max_length:\\n            self.max_level += 1\\n            self.max_length *= 2 \\n        while random.random() < 0.5 and level < self.max_level:\\n            level += 1      \\n            yield\\n\\n    def add(self, num: int) -> None:\\n        node = self.head\\n        stack = []\\n        for i in range(len(self.head.next)-1, -1, -1):     \\n            while node.next[i].val <= num:\\n                node = node.next[i]\\n            #if \"num\" is found in the list, increase the count of \"num\"s and exit        \\n            if node.val == num: \\n                node.counter += 1\\n                return\\n            stack.append((node, i))\\n        #insert \"num\" in lowest level\\n        prev_node, i = stack.pop()\\n        node = ListNode(val= num, next=[prev_node.next[i]])\\n        prev_node.next[i] = node\\n        self.length_list += 1 #increase length list\\n        \\n        for _ in self.random_level():\\n            if stack:\\n                #insert duplicate \"num\" in exists level\\n                prev_node, i = stack.pop()\\n                node.next.append(prev_node.next[i])\\n                prev_node.next[i] = node\\n            else:\\n                #create new level with duplicate \"num\"\\n                self.head.next.append(node)\\n                node.next.append(self.tail)\\n\\n    def erase(self, num: int) -> bool:       \\n        node = self.head\\n        flag = False  #if finded \"num\" then \"flag\" = True\\n        for i in range(len(self.head.next)-1, -1, -1):     \\n            while node.next[i].val < num:\\n                node = node.next[i]\\n            if node.next[i].val == num:\\n                if flag:\\n                    node.next[i] = node.next[i].next[i] #erase \"num\" in \"i\"-level\\n                else:\\n                    node.next[i].counter -= 1 #reduce the count of \"num\"s\\n                    if node.next[i].counter > 0:  \\n                        return True         \\n                    node.next[i] = node.next[i].next[i]\\n                    flag = True     \\n        if flag:\\n            #remove the top level if it\\'s empty\\n            while self.head.next[-1] == self.tail and len(self.head.next) > 1:\\n                self.head.next.pop()\\n            self.length_list -= 1 #reduce length list\\n        return flag              \\n```\n```\\nclass ValueNode:\\n    def __init__(self, num= 0, counter= 1):\\n        self.num = num\\n        self.counter = counter\\n\\nclass ListNode:\\n    def __init__(self, value= None, down = None, next= None):\\n        self.value = value\\n        self.down = down\\n        self.next = next\\n\\nclass Skiplist:\\n    def __init__(self):\\n        self.max_level = 1\\n        self.max_length = 1\\n        self.length_list = 0\\n        self.tail = ListNode(value= ValueNode(num= inf))\\n        self.head = ListNode(value= ValueNode(num= -inf), next= self.tail)     \\n\\n    def search(self, target: int) -> bool:\\n        node = self.head\\n        while node:\\n            while node.next.value.num <= target:                                          \\n                node = node.next\\n            if node.value.num == target:\\n                return True                \\n            node = node.down                          \\n        return False\\n\\n    def random_level(self):\\n        level = 0\\n        if self.length_list > self.max_length:\\n            self.max_level += 1\\n            self.max_length *= 2 \\n        while random.random() < 0.5 and level < self.max_level:\\n            level += 1      \\n            yield\\n\\n    def add(self, num: int) -> None:\\n        node = self.head\\n        stack = []\\n        while node:\\n            while node.next.value.num <= num:                                          \\n                node = node.next       \\n            if node.value.num == num: \\n                node.value.counter += 1\\n                return\\n            stack.append(node)\\n            node = node.down\\n        prev_node = stack.pop()\\n        node = ListNode(value= ValueNode(num= num))\\n        node.next = prev_node.next\\n        prev_node.next = node\\n        self.length_list += 1     \\n        for _ in self.random_level():\\n            new_node = ListNode(value= node.value, down= node)\\n            if stack:\\n                prev_node = stack.pop()\\n                new_node.next = prev_node.next\\n                prev_node.next = new_node                \\n            else:\\n                self.head = ListNode(value= self.head.value, down= self.head, next= new_node)\\n                new_node.next = ListNode(value= self.tail.value, down= self.tail)\\n                self.tail = new_node.next\\n            node = new_node\\n                   \\n    def erase(self, num: int) -> bool:\\n        node = self.head\\n        flag = False\\n        while node:\\n            while node.next.value.num < num:                                          \\n                node = node.next       \\n            if node.next.value.num == num:\\n                if flag:\\n                    node.next = node.next.next\\n                else:\\n                    node.next.value.counter -= 1\\n                    if node.next.value.counter > 0:\\n                        return True\\n                    node.next = node.next.next\\n                    flag = True \\n            node = node.down     \\n        if flag:\\n            while self.head.next == self.tail and self.head.down:\\n                self.head = self.head.down\\n                self.tail = self.tail.down\\n            self.length_list -= 1\\n        return flag                        \\n```\n```\\nclass ListNode:\\n    def __init__(self, val= 0, next= None, down = None):\\n        self.val = val\\n        self.next = next\\n        self.down = down\\n\\nclass Skiplist:\\n    def __init__(self):\\n        self.head = ListNode(val= -inf)      \\n      \\n    def searchRec(self, node, target): \\n        while node.next and node.next.val <= target:                                       \\n            node = node.next                                         \\n        if node.down == None:                                   \\n            return node.val                                      \\n        return self.searchRec(node.down, target)\\n  \\n    def search(self, target: int) -> bool:\\n        return self.searchRec(self.head, target) == target\\n\\n    def addRec(self, node, num):\\n        while node.next and node.next.val < num:\\n            node = node.next                                    \\n        if node.down == None:\\n            downNode = None\\n        else:\\n            downNode = self.addRec(node.down, num)\\n        if downNode != None or node.down == None:\\n            node.next = ListNode(val= num, next= node.next, down= downNode)\\n            if random.random() < 0.5:\\n                return node.next\\n            return None          \\n   \\n    def add(self, num: int) -> None:\\n        node = self.addRec(self.head, num)\\n        if node != None:\\n            newNode = ListNode(val= -inf, down=self.head)\\n            newNode.next = ListNode(val= num, down= node)\\n            self.head = newNode\\n          \\n    def eraseRec(self, node, num):\\n        flag = False\\n        while node.next and node.next.val < num:\\n            node = node.next\\n        if node.down != None:\\n            flag = self.eraseRec(node.down, num)\\n        if node.next and node.next.val == num:\\n            node.next = node.next.next\\n            return True\\n        return flag\\n        \\n    def erase(self, num: int) -> bool:\\n        return self.eraseRec(self.head, num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895013,
                "title": "skip-list",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Node{\\n    public:\\n    int data;\\n    Node *next;\\n    Node *down;\\n    Node(int val){\\n        data=val;\\n        next=NULL;\\n        down=NULL;\\n    }\\n};\\nclass Skiplist {\\npublic:\\n    Node *head;\\n    Skiplist() {\\n        head=new Node(-1);\\n    }\\n    \\n    bool search(int num) {\\n        Node *current=head;\\n        while(current!=NULL){\\n            while(current->next!=NULL && current->next->data < num){\\n                current=current->next;\\n            }\\n            if(current->next!=NULL && current->next->data==num){\\n                return true;\\n            }\\n            current=current->down;\\n        }\\n       return false; \\n    }\\n    \\n    void add(int num) {\\n        vector<Node*> prevnodes;\\n        Node *current=head;\\n        while(current!=NULL){\\n            while(current->next!=NULL && current->next->data<num){\\n                current=current->next;\\n            }\\n            prevnodes.push_back(current);\\n            current=current->down;\\n\\n        }\\n        bool insertup=true;\\n        Node *downnode=NULL;\\n        while(insertup==true && !prevnodes.empty()){\\n            Node *prev=prevnodes.back();\\n            prevnodes.pop_back();\\n            Node *newnode=new Node(num);\\n            newnode->next=prev->next;\\n            prev->next=newnode;\\n            newnode->down=downnode;\\n            downnode=newnode;\\n            if(rand()%2==0){\\n                insertup=true;\\n            }\\n            else{\\n                insertup=false;\\n            }\\n        }\\n        if(insertup==true){\\n            Node* newnode =new Node(num);\\n            Node *newhead=new Node(-1);\\n            newhead->down=head;\\n            head=newhead;\\n            newnode->next=newhead->next;\\n            newhead->next=newnode;\\n            newnode->down=downnode;\\n        }\\n\\n    }\\n    \\n    bool erase(int num) {\\n        bool found=false;\\n        Node *current=head;\\n        while(current!=NULL){\\n            while(current->next!=NULL && current->next->data<num){\\n                current=current->next;\\n            }\\n            if(current->next!=NULL && current->next->data==num){\\n                Node *todelete=current->next;\\n                current->next=todelete->next;\\n                delete todelete;\\n                found=true;\\n            }\\n            current=current->down;\\n        }\\n        return found; \\n    }\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Node{\\n    public:\\n    int data;\\n    Node *next;\\n    Node *down;\\n    Node(int val){\\n        data=val;\\n        next=NULL;\\n        down=NULL;\\n    }\\n};\\nclass Skiplist {\\npublic:\\n    Node *head;\\n    Skiplist() {\\n        head=new Node(-1);\\n    }\\n    \\n    bool search(int num) {\\n        Node *current=head;\\n        while(current!=NULL){\\n            while(current->next!=NULL && current->next->data < num){\\n                current=current->next;\\n            }\\n            if(current->next!=NULL && current->next->data==num){\\n                return true;\\n            }\\n            current=current->down;\\n        }\\n       return false; \\n    }\\n    \\n    void add(int num) {\\n        vector<Node*> prevnodes;\\n        Node *current=head;\\n        while(current!=NULL){\\n            while(current->next!=NULL && current->next->data<num){\\n                current=current->next;\\n            }\\n            prevnodes.push_back(current);\\n            current=current->down;\\n\\n        }\\n        bool insertup=true;\\n        Node *downnode=NULL;\\n        while(insertup==true && !prevnodes.empty()){\\n            Node *prev=prevnodes.back();\\n            prevnodes.pop_back();\\n            Node *newnode=new Node(num);\\n            newnode->next=prev->next;\\n            prev->next=newnode;\\n            newnode->down=downnode;\\n            downnode=newnode;\\n            if(rand()%2==0){\\n                insertup=true;\\n            }\\n            else{\\n                insertup=false;\\n            }\\n        }\\n        if(insertup==true){\\n            Node* newnode =new Node(num);\\n            Node *newhead=new Node(-1);\\n            newhead->down=head;\\n            head=newhead;\\n            newnode->next=newhead->next;\\n            newhead->next=newnode;\\n            newnode->down=downnode;\\n        }\\n\\n    }\\n    \\n    bool erase(int num) {\\n        bool found=false;\\n        Node *current=head;\\n        while(current!=NULL){\\n            while(current->next!=NULL && current->next->data<num){\\n                current=current->next;\\n            }\\n            if(current->next!=NULL && current->next->data==num){\\n                Node *todelete=current->next;\\n                current->next=todelete->next;\\n                delete todelete;\\n                found=true;\\n            }\\n            current=current->down;\\n        }\\n        return found; \\n    }\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873236,
                "title": "clean-java-with-creating-doubly-linked-list",
                "content": "Improved on top of this solution: https://leetcode.com/problems/design-skiplist/solutions/947076/clean-java/\\n\\nCreated doubly linked list to further optimise the delete operation.\\n\\n# Code\\n```\\nclass Node{\\n    public int val;\\n    public Node next, down, prev;\\n\\n    public Node(int val, Node next, Node down, Node prev)\\n    {\\n        this.val = val;\\n        this.next = next;\\n        this.down = down;\\n        this.prev = prev;\\n    }\\n}\\n\\nclass Skiplist {\\n    Node head;\\n    Random random;\\n\\n    public Skiplist() {\\n        head = new Node(-1, null, null, null);\\n        random = new Random();\\n    }\\n    \\n    public boolean search(int target) {\\n        Node cur = head;\\n        while(cur!=null)\\n        {\\n            while(cur.next!=null && cur.next.val<target)\\n            {\\n                cur=cur.next;\\n            }\\n            if(cur.next!=null&& cur.next.val==target)\\n            {\\n                return true;\\n            }\\n            cur = cur.down;\\n        }\\n        return false;\\n    }\\n    \\n    public void add(int num) {\\n        Node cur = head;\\n        Stack<Node> st = new Stack();\\n        while(cur!=null)\\n        {\\n            while(cur.next!=null && cur.next.val<num)\\n            {\\n                cur=cur.next;\\n            }\\n            st.push(cur);\\n            cur = cur.down;\\n        }\\n        boolean promote = true;\\n        Node prevDown = null;\\n        while(promote && st.size()>0)\\n        {\\n            cur = st.pop();\\n            cur.next = new Node(num, cur.next, prevDown, cur);\\n            if(cur.next.next!=null)\\n            {\\n                cur.next.next.prev = cur.next;\\n            }\\n            prevDown = cur.next;\\n            promote = random.nextInt(2)==0;\\n        }\\n\\n        if(promote)\\n        {\\n            head = new Node(-1,null, head, null);\\n            head.next = new Node(num, null, prevDown, head);\\n        }\\n    }\\n    \\n    public boolean erase(int num) {\\n        Node cur = head;\\n       \\n        while(cur!=null)\\n        {\\n            while(cur.next!=null && cur.next.val<num)\\n            {\\n                cur = cur.next;\\n            }\\n            if(cur.next!=null && cur.next.val == num)\\n            {\\n                cur = cur.next;\\n                break;\\n            }\\n            cur = cur.down;\\n        }\\n\\n        if(cur==null)\\n            return false;\\n\\n        while(cur!=null)\\n        {\\n            cur.prev.next=cur.next;\\n            if(cur.next!=null)\\n                cur.next.prev=cur.prev;\\n            cur = cur.down;\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist obj = new Skiplist();\\n * boolean param_1 = obj.search(target);\\n * obj.add(num);\\n * boolean param_3 = obj.erase(num);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Design",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Node{\\n    public int val;\\n    public Node next, down, prev;\\n\\n    public Node(int val, Node next, Node down, Node prev)\\n    {\\n        this.val = val;\\n        this.next = next;\\n        this.down = down;\\n        this.prev = prev;\\n    }\\n}\\n\\nclass Skiplist {\\n    Node head;\\n    Random random;\\n\\n    public Skiplist() {\\n        head = new Node(-1, null, null, null);\\n        random = new Random();\\n    }\\n    \\n    public boolean search(int target) {\\n        Node cur = head;\\n        while(cur!=null)\\n        {\\n            while(cur.next!=null && cur.next.val<target)\\n            {\\n                cur=cur.next;\\n            }\\n            if(cur.next!=null&& cur.next.val==target)\\n            {\\n                return true;\\n            }\\n            cur = cur.down;\\n        }\\n        return false;\\n    }\\n    \\n    public void add(int num) {\\n        Node cur = head;\\n        Stack<Node> st = new Stack();\\n        while(cur!=null)\\n        {\\n            while(cur.next!=null && cur.next.val<num)\\n            {\\n                cur=cur.next;\\n            }\\n            st.push(cur);\\n            cur = cur.down;\\n        }\\n        boolean promote = true;\\n        Node prevDown = null;\\n        while(promote && st.size()>0)\\n        {\\n            cur = st.pop();\\n            cur.next = new Node(num, cur.next, prevDown, cur);\\n            if(cur.next.next!=null)\\n            {\\n                cur.next.next.prev = cur.next;\\n            }\\n            prevDown = cur.next;\\n            promote = random.nextInt(2)==0;\\n        }\\n\\n        if(promote)\\n        {\\n            head = new Node(-1,null, head, null);\\n            head.next = new Node(num, null, prevDown, head);\\n        }\\n    }\\n    \\n    public boolean erase(int num) {\\n        Node cur = head;\\n       \\n        while(cur!=null)\\n        {\\n            while(cur.next!=null && cur.next.val<num)\\n            {\\n                cur = cur.next;\\n            }\\n            if(cur.next!=null && cur.next.val == num)\\n            {\\n                cur = cur.next;\\n                break;\\n            }\\n            cur = cur.down;\\n        }\\n\\n        if(cur==null)\\n            return false;\\n\\n        while(cur!=null)\\n        {\\n            cur.prev.next=cur.next;\\n            if(cur.next!=null)\\n                cur.next.prev=cur.prev;\\n            cur = cur.down;\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist obj = new Skiplist();\\n * boolean param_1 = obj.search(target);\\n * obj.add(num);\\n * boolean param_3 = obj.erase(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853666,
                "title": "javascript-clean-and-descriptive-time-o-n-space-o-n",
                "content": "```js\\n/** \\n * Linked List\\n * Time O(N) | Space O(N)\\n * https://leetcode.com/problems/design-skiplist/\\n * Your Skiplist object will be instantiated and called as such:\\n * var obj = new Skiplist()\\n * var param_1 = obj.search(target)\\n * obj.add(num)\\n * var param_3 = obj.erase(num)\\n */\\n class Skiplist {\\n    constructor() {\\n        this.head = new Node();\\n    }\\n\\n    search (target) {\\n        const curr = this.getNode(target);/* Time O(N) */\\n\\n        const isNull = (curr === null);\\n        if (isNull) return false;\\n\\n        return true;\\n    }\\n\\n    add (num, { head: curr } = this) {\\n        const stack = [];/* Space O(N) */\\n\\n        while (curr !== null) {/* Time O(N) */\\n            curr = this.moveNext(curr, num);\\n            stack.push(curr);     /* Space O(N) */\\n            curr = curr.down;\\n        }\\n\\n        let down = null;\\n        \\n        while (0 < stack.length) {/* Time O(N) */\\n            curr = stack.pop();\\n            curr.next = new Node(num, curr.next, down);/* Space O(N) */\\n            down = curr.next;\\n        }\\n    }\\n\\n    erase (num) {\\n        const curr = this.getNode(num);/* Time O(N) */\\n\\n        const isNull = (curr === null);\\n        if (isNull) return false;\\n\\n        curr.next = curr.next.next;\\n\\n        return true;\\n    }\\n\\n    getNode (value, { head: curr } = this) {\\n        while (curr !== null) {               /* Time O(N) */\\n            curr = this.moveNext(curr, value);/* Time O(N) */\\n\\n            const isTarget = (curr.next && (curr.next.value === value));\\n            if (isTarget) return curr;\\n\\n            curr = curr.down;\\n        }\\n\\n        return null;\\n    }\\n\\n    moveNext (curr, value) {\\n        const isTargetGreater = () => (curr.next && (curr.next.value < value));\\n        while (isTargetGreater()) curr = curr.next;/* Time O(N) */\\n\\n        return curr;\\n    }\\n}\\n\\nclass Node {\\n    constructor (value, next = null, down = null) {\\n        this.value = value;\\n        this.next = next;\\n        this.down = down;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/** \\n * Linked List\\n * Time O(N) | Space O(N)\\n * https://leetcode.com/problems/design-skiplist/\\n * Your Skiplist object will be instantiated and called as such:\\n * var obj = new Skiplist()\\n * var param_1 = obj.search(target)\\n * obj.add(num)\\n * var param_3 = obj.erase(num)\\n */\\n class Skiplist {\\n    constructor() {\\n        this.head = new Node();\\n    }\\n\\n    search (target) {\\n        const curr = this.getNode(target);/* Time O(N) */\\n\\n        const isNull = (curr === null);\\n        if (isNull) return false;\\n\\n        return true;\\n    }\\n\\n    add (num, { head: curr } = this) {\\n        const stack = [];/* Space O(N) */\\n\\n        while (curr !== null) {/* Time O(N) */\\n            curr = this.moveNext(curr, num);\\n            stack.push(curr);     /* Space O(N) */\\n            curr = curr.down;\\n        }\\n\\n        let down = null;\\n        \\n        while (0 < stack.length) {/* Time O(N) */\\n            curr = stack.pop();\\n            curr.next = new Node(num, curr.next, down);/* Space O(N) */\\n            down = curr.next;\\n        }\\n    }\\n\\n    erase (num) {\\n        const curr = this.getNode(num);/* Time O(N) */\\n\\n        const isNull = (curr === null);\\n        if (isNull) return false;\\n\\n        curr.next = curr.next.next;\\n\\n        return true;\\n    }\\n\\n    getNode (value, { head: curr } = this) {\\n        while (curr !== null) {               /* Time O(N) */\\n            curr = this.moveNext(curr, value);/* Time O(N) */\\n\\n            const isTarget = (curr.next && (curr.next.value === value));\\n            if (isTarget) return curr;\\n\\n            curr = curr.down;\\n        }\\n\\n        return null;\\n    }\\n\\n    moveNext (curr, value) {\\n        const isTargetGreater = () => (curr.next && (curr.next.value < value));\\n        while (isTargetGreater()) curr = curr.next;/* Time O(N) */\\n\\n        return curr;\\n    }\\n}\\n\\nclass Node {\\n    constructor (value, next = null, down = null) {\\n        this.value = value;\\n        this.next = next;\\n        this.down = down;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850247,
                "title": "simple-js-solution-that-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar Skiplist = function() {\\n    this.skiplist = new Map()\\n};\\n\\n/** \\n * @param {number} target\\n * @return {boolean}\\n */\\nSkiplist.prototype.search = function(target) {\\n    return this.skiplist.get(target) > 0\\n};\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nSkiplist.prototype.add = function(num) {\\n    this.skiplist.set(num, (this.skiplist.get(num) + 1) || 1)\\n};\\n\\n/** \\n * @param {number} num\\n * @return {boolean}\\n */\\nSkiplist.prototype.erase = function(num) {\\n    if (this.skiplist.get(num) > 0) {\\n        this.skiplist.set(num, (this.skiplist.get(num) - 1))\\n        return true\\n    } \\n    return false\\n}\\n\\n/** \\n * Your Skiplist object will be instantiated and called as such:\\n * var obj = new Skiplist()\\n * var param_1 = obj.search(target)\\n * obj.add(num)\\n * var param_3 = obj.erase(num)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar Skiplist = function() {\\n    this.skiplist = new Map()\\n};\\n\\n/** \\n * @param {number} target\\n * @return {boolean}\\n */\\nSkiplist.prototype.search = function(target) {\\n    return this.skiplist.get(target) > 0\\n};\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nSkiplist.prototype.add = function(num) {\\n    this.skiplist.set(num, (this.skiplist.get(num) + 1) || 1)\\n};\\n\\n/** \\n * @param {number} num\\n * @return {boolean}\\n */\\nSkiplist.prototype.erase = function(num) {\\n    if (this.skiplist.get(num) > 0) {\\n        this.skiplist.set(num, (this.skiplist.get(num) - 1))\\n        return true\\n    } \\n    return false\\n}\\n\\n/** \\n * Your Skiplist object will be instantiated and called as such:\\n * var obj = new Skiplist()\\n * var param_1 = obj.search(target)\\n * obj.add(num)\\n * var param_3 = obj.erase(num)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3850212,
                "title": "kotlin-simple-and-fast-solution-that-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Skiplist() {\\nprivate val skiplist = HashMap<Int, Int>()\\n    fun search(target: Int): Boolean {\\n        if (skiplist[target] != null && skiplist[target]!! > 0) return true\\n        return false\\n        \\n    }\\n\\n    fun add(num: Int) {\\n        skiplist[num] = skiplist.getOrDefault(num, 0) + 1\\n    }\\n\\n    fun erase(num: Int): Boolean {\\n        if (skiplist[num] != null && skiplist[num]!! > 0) {\\n            skiplist[num] = skiplist[num]!! - 1\\n            return true\\n        }\\n        return false\\n    }\\n\\n}\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * var obj = Skiplist()\\n * var param_1 = obj.search(target)\\n * obj.add(num)\\n * var param_3 = obj.erase(num)\\n */\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Skiplist() {\\nprivate val skiplist = HashMap<Int, Int>()\\n    fun search(target: Int): Boolean {\\n        if (skiplist[target] != null && skiplist[target]!! > 0) return true\\n        return false\\n        \\n    }\\n\\n    fun add(num: Int) {\\n        skiplist[num] = skiplist.getOrDefault(num, 0) + 1\\n    }\\n\\n    fun erase(num: Int): Boolean {\\n        if (skiplist[num] != null && skiplist[num]!! > 0) {\\n            skiplist[num] = skiplist[num]!! - 1\\n            return true\\n        }\\n        return false\\n    }\\n\\n}\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * var obj = Skiplist()\\n * var param_1 = obj.search(target)\\n * obj.add(num)\\n * var param_3 = obj.erase(num)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847227,
                "title": "super-simple-defaultdict-python-solution-that-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Skiplist:\\n\\n    def __init__(self):\\n        self.skiplist = defaultdict(int)\\n        \\n\\n    def search(self, target: int) -> bool:\\n        return self.skiplist[target] > 0\\n        \\n\\n    def add(self, num: int) -> None:\\n        self.skiplist[num] += 1\\n        \\n\\n    def erase(self, num: int) -> bool:\\n        if self.skiplist[num] > 0:\\n            self.skiplist[num] -= 1\\n            return True\\n        return False\\n        \\n\\n\\n# Your Skiplist object will be instantiated and called as such:\\n# obj = Skiplist()\\n# param_1 = obj.search(target)\\n# obj.add(num)\\n# param_3 = obj.erase(num)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Skiplist:\\n\\n    def __init__(self):\\n        self.skiplist = defaultdict(int)\\n        \\n\\n    def search(self, target: int) -> bool:\\n        return self.skiplist[target] > 0\\n        \\n\\n    def add(self, num: int) -> None:\\n        self.skiplist[num] += 1\\n        \\n\\n    def erase(self, num: int) -> bool:\\n        if self.skiplist[num] > 0:\\n            self.skiplist[num] -= 1\\n            return True\\n        return False\\n        \\n\\n\\n# Your Skiplist object will be instantiated and called as such:\\n# obj = Skiplist()\\n# param_1 = obj.search(target)\\n# obj.add(num)\\n# param_3 = obj.erase(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806112,
                "title": "design-skiplist",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/2bbf9283-8d5b-4649-b23b-8ff07e60ee05_1690122987.023143.png)\\n\\n# Code\\n```\\nclass Skiplist:\\n\\n    def __init__(self):\\n        self.skiplist=[]\\n\\n    def search(self, target: int) -> bool:\\n        if target in self.skiplist:\\n            return True\\n        return False\\n\\n    def add(self, num: int) -> None:\\n        self.skiplist.append(num)\\n\\n    def erase(self, num: int) -> bool:\\n        if num in self.skiplist:\\n            self.skiplist.remove(num)\\n            return True\\n        return False\\n\\n\\n# Your Skiplist object will be instantiated and called as such:\\n# obj = Skiplist()\\n# param_1 = obj.search(target)\\n# obj.add(num)\\n# param_3 = obj.erase(num)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Skiplist:\\n\\n    def __init__(self):\\n        self.skiplist=[]\\n\\n    def search(self, target: int) -> bool:\\n        if target in self.skiplist:\\n            return True\\n        return False\\n\\n    def add(self, num: int) -> None:\\n        self.skiplist.append(num)\\n\\n    def erase(self, num: int) -> bool:\\n        if num in self.skiplist:\\n            self.skiplist.remove(num)\\n            return True\\n        return False\\n\\n\\n# Your Skiplist object will be instantiated and called as such:\\n# obj = Skiplist()\\n# param_1 = obj.search(target)\\n# obj.add(num)\\n# param_3 = obj.erase(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806095,
                "title": "java-beats-100-onlyyyyyyy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Skiplist {\\n\\n    int[] arr;\\n    public Skiplist() {\\n        arr=new int[20001];\\n    }\\n    \\n    public boolean search(int target) {\\n        if(arr[target]>0)\\n            return true;\\n        return false;\\n    }\\n    \\n    public void add(int num) {\\n        arr[num]++;\\n    }\\n    \\n    public boolean erase(int num) {\\n        if(arr[num]>0){\\n            arr[num]--;\\n            return true;\\n        }else\\n            return false;\\n        \\n    }\\n}\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist obj = new Skiplist();\\n * boolean param_1 = obj.search(target);\\n * obj.add(num);\\n * boolean param_3 = obj.erase(num);\\n */\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist obj = new Skiplist();\\n * boolean param_1 = obj.search(target);\\n * obj.add(num);\\n * boolean param_3 = obj.erase(num);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Skiplist {\\n\\n    int[] arr;\\n    public Skiplist() {\\n        arr=new int[20001];\\n    }\\n    \\n    public boolean search(int target) {\\n        if(arr[target]>0)\\n            return true;\\n        return false;\\n    }\\n    \\n    public void add(int num) {\\n        arr[num]++;\\n    }\\n    \\n    public boolean erase(int num) {\\n        if(arr[num]>0){\\n            arr[num]--;\\n            return true;\\n        }else\\n            return false;\\n        \\n    }\\n}\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist obj = new Skiplist();\\n * boolean param_1 = obj.search(target);\\n * obj.add(num);\\n * boolean param_3 = obj.erase(num);\\n */\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist obj = new Skiplist();\\n * boolean param_1 = obj.search(target);\\n * obj.add(num);\\n * boolean param_3 = obj.erase(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3803046,
                "title": "simple-solution-by-using-map-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Skiplist {\\npublic:\\n    map<int,int>mp;\\n    Skiplist() {\\n       \\n    }\\n    \\n    bool search(int target) {\\n        if(mp[target]!=0)\\n          return true;\\n        return false;  \\n    }\\n    \\n    void add(int num) {\\n        mp[num]+=1;\\n    }\\n    \\n    bool erase(int num) {\\n        if(mp[num]!=0)\\n        {\\n            mp[num]-=1;\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Skiplist {\\npublic:\\n    map<int,int>mp;\\n    Skiplist() {\\n       \\n    }\\n    \\n    bool search(int target) {\\n        if(mp[target]!=0)\\n          return true;\\n        return false;  \\n    }\\n    \\n    void add(int num) {\\n        mp[num]+=1;\\n    }\\n    \\n    bool erase(int num) {\\n        if(mp[num]!=0)\\n        {\\n            mp[num]-=1;\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780536,
                "title": "clean-java-using-recursion-with-explanation",
                "content": "\\n\\n# Code\\n```\\nclass Skiplist {\\n    class ListNode {\\n        ListNode down, next;\\n        int val;\\n        ListNode(int val, ListNode down, ListNode next) {\\n            this.val = val; this.down = down; this.next = next;\\n        }\\n    }\\n    ListNode head;\\n    public Skiplist() {\\n        head = new ListNode(-1,null,null); //Initialize our Sentinel head node\\n    }\\n    \\n    public boolean search(int target) {\\n        //Searches for the target. Returns null if not found or the previous node if found\\n        return search(head, target) == null ? false : true;\\n    }\\n    private ListNode search(ListNode node, int target) {\\n        if(node == null) {\\n            return null;\\n        }\\n\\n        while(node.next != null && node.next.val < target) {\\n            node = node.next;\\n        }\\n\\n        //Return target or move a level below\\n        if(node.next != null && node.next.val == target) return node;\\n        return search(node.down, target);\\n    }\\n    \\n    public void add(int num) {\\n        add(head,num);\\n    }\\n    private ListNode add(ListNode node, int val) {\\n        if(node == null) {\\n            return new ListNode(val, null, null);\\n        }\\n\\n        while(node.next != null && node.next.val < val) {\\n            node = node.next;\\n        }\\n\\n        //This is for 2 cases. \\n        //1. Reach the lower levels to insert the node at the right pointer\\n        //2. Insert the node at the higher levels based on Randomise function\\n        ListNode newnode = add(node.down,val);\\n        if(newnode != null) {\\n            newnode.next = node.next;\\n            node.next = newnode;\\n\\n            //Randomise function to determine if the node to be created at top levels\\n            boolean coinflip = (new Random().nextInt(1,10) % 2)==0;\\n            if(coinflip) {\\n                if(node == head) {\\n                    /*If the node is already the current sentinel, \\n                    create empty sentinel and reassign the current head */\\n                    head = new ListNode(-1, head, null);\\n                    return null;\\n                } else {\\n                    /*If the randomize function returned true, \\n                    we must create the node at the immediate top level */\\n                    return new ListNode(val, newnode, null);\\n                }\\n            }\\n        }\\n        return null;\\n    }\\n    \\n    public boolean erase(int num) {\\n        return erase(head,num);\\n    }\\n    private boolean erase(ListNode node, int num) {\\n        if(node == null) {\\n            return false;\\n        }\\n\\n        // Search function returns the previous node at the top most level\\n        ListNode prev = search(node , num);\\n        if(prev != null) {\\n            //Recursively delete the same node at multiple lower levels\\n            boolean res = erase(prev.down, num);\\n            prev.next = prev.next.next;\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist obj = new Skiplist();\\n * boolean param_1 = obj.search(target);\\n * obj.add(num);\\n * boolean param_3 = obj.erase(num);\\n */\\n```\\n\\n# Intuition\\n\\nBefore designing a skiplist, it is necessary to have a clear understanding of how it works.\\n\\n![skiplist.png](https://assets.leetcode.com/users/images/38737b85-3726-4d06-a93c-d7f131a58c32_1689629819.2532868.png)\\n\\n\\nIt is recommended to understand the concept of skiplist , its insertion , deletion in some useful links online. \\n\\nNow, lets proceed with our design. The design has to include :\\n\\n1. A Multi Level Linked List structure with Sentinel Head Node\\n2. Individual ListNode structure with Next and Down pointers\\n3. A Randomise function to decide whether or not a node should be moved a level up. \\n\\n*Remember , the randomise technique is what that gives skiplists their probabilistic nature and allows for their efficient average time complexity. As the wikipedia says ,*\\n\\n> a skip list (or skiplist) is a probabilistic data structure\\n\\nThe following solution is based on Basic Recursion which provides our solution a few advantages like - Simplicity , Code clarity and Reusability.\\n\\n# Approach\\n\\nLet us break this discussion into 4 parts : \\n\\n- Initialisation\\n- Add\\n- Search\\n- Erase\\n\\n> Handling of Duplicates , Empty lists , Insertion / Deletion at the Head/tail nodes are handled in the implementation. Also explained with necessary comments wherever necessary. \\n\\n**Initiatisation:**\\n```\\n    public Skiplist() {\\n        //Initialize our Sentinel head node\\n        head = new ListNode(-1,null,null);\\n    }\\n\\n```\\n\\n**Add:**\\nWhen inserting an element, start from the sentinel head , move right or down through the levels until we find the appropriate position in each level.\\n\\nOnce the data node is inserted , We use our custom random function to determine the necessity to insert node at higher levels.\\n\\n```\\n    boolean coinflip = (new Random().nextInt(1,10) % 2)==0;\\n```\\n\\nWe can avoid the redundant node creation at the top most level with just a sentinel head creation\\n\\n```\\n    if(node == head) {\\n        /*If the node is already the current sentinel, \\n        create empty sentinel and reassign the current head */\\n        head = new ListNode(-1, head, null);\\n        return null;\\n    }\\n```\\n\\n**Search:**\\nTraversal the nodes similar to the insertion , except to return the reference to the target node if the node is found. We will return null otherwise. \\n\\n> Node Object is returned here in order to make our Erase operation simpler\\n\\n\\n\\n# Complexity\\n- Time complexity: **O(log n)** based on characteristics of skiplist\\nIn the worst case, the skip list degenerates to a single-linked list, and we\\u2019re looking for a value greater than the maximum , this leads to **O(n)**\\n\\n- Space complexity: **O(n)** \\nIn the worst case **O(n * k)** , in case if there are n elements in the skip list and the maximum number of levels is k\\n\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Skiplist {\\n    class ListNode {\\n        ListNode down, next;\\n        int val;\\n        ListNode(int val, ListNode down, ListNode next) {\\n            this.val = val; this.down = down; this.next = next;\\n        }\\n    }\\n    ListNode head;\\n    public Skiplist() {\\n        head = new ListNode(-1,null,null); //Initialize our Sentinel head node\\n    }\\n    \\n    public boolean search(int target) {\\n        //Searches for the target. Returns null if not found or the previous node if found\\n        return search(head, target) == null ? false : true;\\n    }\\n    private ListNode search(ListNode node, int target) {\\n        if(node == null) {\\n            return null;\\n        }\\n\\n        while(node.next != null && node.next.val < target) {\\n            node = node.next;\\n        }\\n\\n        //Return target or move a level below\\n        if(node.next != null && node.next.val == target) return node;\\n        return search(node.down, target);\\n    }\\n    \\n    public void add(int num) {\\n        add(head,num);\\n    }\\n    private ListNode add(ListNode node, int val) {\\n        if(node == null) {\\n            return new ListNode(val, null, null);\\n        }\\n\\n        while(node.next != null && node.next.val < val) {\\n            node = node.next;\\n        }\\n\\n        //This is for 2 cases. \\n        //1. Reach the lower levels to insert the node at the right pointer\\n        //2. Insert the node at the higher levels based on Randomise function\\n        ListNode newnode = add(node.down,val);\\n        if(newnode != null) {\\n            newnode.next = node.next;\\n            node.next = newnode;\\n\\n            //Randomise function to determine if the node to be created at top levels\\n            boolean coinflip = (new Random().nextInt(1,10) % 2)==0;\\n            if(coinflip) {\\n                if(node == head) {\\n                    /*If the node is already the current sentinel, \\n                    create empty sentinel and reassign the current head */\\n                    head = new ListNode(-1, head, null);\\n                    return null;\\n                } else {\\n                    /*If the randomize function returned true, \\n                    we must create the node at the immediate top level */\\n                    return new ListNode(val, newnode, null);\\n                }\\n            }\\n        }\\n        return null;\\n    }\\n    \\n    public boolean erase(int num) {\\n        return erase(head,num);\\n    }\\n    private boolean erase(ListNode node, int num) {\\n        if(node == null) {\\n            return false;\\n        }\\n\\n        // Search function returns the previous node at the top most level\\n        ListNode prev = search(node , num);\\n        if(prev != null) {\\n            //Recursively delete the same node at multiple lower levels\\n            boolean res = erase(prev.down, num);\\n            prev.next = prev.next.next;\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist obj = new Skiplist();\\n * boolean param_1 = obj.search(target);\\n * obj.add(num);\\n * boolean param_3 = obj.erase(num);\\n */\\n```\n```\\n    public Skiplist() {\\n        //Initialize our Sentinel head node\\n        head = new ListNode(-1,null,null);\\n    }\\n\\n```\n```\\n    boolean coinflip = (new Random().nextInt(1,10) % 2)==0;\\n```\n```\\n    if(node == head) {\\n        /*If the node is already the current sentinel, \\n        create empty sentinel and reassign the current head */\\n        head = new ListNode(-1, head, null);\\n        return null;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775205,
                "title": "c-with-the-stack-as-a-path-helper",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFind() returns search path as a stack which makes it a tad easier to implement add() and erase().\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Skiplist {\\nprivate:\\n    struct Node {\\n        const int v;\\n        Node* n = nullptr;\\n        Node* l = nullptr;\\n        Node(Node* n = nullptr, Node* l = nullptr, int v = -1) : n(n), l(l), v(v) { \\n        }\\n    };\\n    using Path = std::stack<Node*>;\\n\\n    Node* head = nullptr;\\n\\n    static bool coinToss() {\\n        return ((rand() % 2) == 0);\\n    }\\n\\n    void create() {\\n        if (head == nullptr) {\\n            head = new Node();\\n        }\\n    }\\n\\n    void compact() {\\n        while ( (head != nullptr) && (head->n == nullptr) ) {\\n            auto* nl = head->l;\\n            delete head;\\n            head = nl;\\n        }\\n    }\\n\\n    bool find(int v, Path* path = nullptr) const {\\n        if (head == nullptr) {\\n            return false;\\n        }\\n\\n        Node* p = nullptr;\\n        auto* n = head;\\n\\n        while (n != nullptr) {\\n            p = n;\\n\\n            if ((n->n != nullptr) && (n->n->v < v)) {\\n                n = n->n;\\n            }\\n            else {\\n                if (path != nullptr) {\\n                    path->push(n);\\n                }\\n                n = n->l;\\n            }\\n        }\\n\\n        return (p->n != nullptr) && (p->n->v == v);\\n    }\\n\\n    Node* addNode(Node& p, Node* l, int v) {\\n        auto* n = p.n != nullptr ? p.n : nullptr;\\n        p.n = new Node(n, l, v);\\n        return p.n;\\n    }\\n\\n    void print() const {\\n        auto* h = head;\\n        while (h != nullptr) {\\n            const auto* n = h;\\n            while (n != nullptr) {\\n                std::cout << n->v << \"->\";\\n                n = n->n;\\n            }\\n            std::cout << std::endl;\\n            h = h->l;\\n        }\\n        std::cout << std::endl;\\n    }\\n\\npublic:\\n    Skiplist() {\\n    }\\n    \\n    bool search(int target) {\\n        return find(target);\\n    }\\n    \\n    void add(int num) {\\n        create();\\n\\n        Path path;\\n        find(num, &path);\\n\\n        Node* node = nullptr;\\n        do {\\n            if (path.empty()) {\\n                head = new Node(nullptr, head);\\n                path.push(head);\\n            }\\n\\n            auto* p = path.top();\\n            path.pop();\\n\\n            node = addNode(*p, node, num);\\n        }\\n        while (coinToss());\\n    }\\n    \\n    bool erase(int num) {\\n        Path path;\\n        if (!find(num, &path)) {\\n            return false;\\n        }\\n\\n        while (!path.empty()) {\\n            auto* p = path.top();\\n            path.pop();\\n\\n            auto* n = p->n;\\n            if ((n == nullptr) || (n->v != num)) {\\n                break;\\n            }\\n\\n            p->n = n->n;\\n            delete n;\\n        }\\n\\n        compact();\\n        \\n        return true;\\n    }\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Skiplist {\\nprivate:\\n    struct Node {\\n        const int v;\\n        Node* n = nullptr;\\n        Node* l = nullptr;\\n        Node(Node* n = nullptr, Node* l = nullptr, int v = -1) : n(n), l(l), v(v) { \\n        }\\n    };\\n    using Path = std::stack<Node*>;\\n\\n    Node* head = nullptr;\\n\\n    static bool coinToss() {\\n        return ((rand() % 2) == 0);\\n    }\\n\\n    void create() {\\n        if (head == nullptr) {\\n            head = new Node();\\n        }\\n    }\\n\\n    void compact() {\\n        while ( (head != nullptr) && (head->n == nullptr) ) {\\n            auto* nl = head->l;\\n            delete head;\\n            head = nl;\\n        }\\n    }\\n\\n    bool find(int v, Path* path = nullptr) const {\\n        if (head == nullptr) {\\n            return false;\\n        }\\n\\n        Node* p = nullptr;\\n        auto* n = head;\\n\\n        while (n != nullptr) {\\n            p = n;\\n\\n            if ((n->n != nullptr) && (n->n->v < v)) {\\n                n = n->n;\\n            }\\n            else {\\n                if (path != nullptr) {\\n                    path->push(n);\\n                }\\n                n = n->l;\\n            }\\n        }\\n\\n        return (p->n != nullptr) && (p->n->v == v);\\n    }\\n\\n    Node* addNode(Node& p, Node* l, int v) {\\n        auto* n = p.n != nullptr ? p.n : nullptr;\\n        p.n = new Node(n, l, v);\\n        return p.n;\\n    }\\n\\n    void print() const {\\n        auto* h = head;\\n        while (h != nullptr) {\\n            const auto* n = h;\\n            while (n != nullptr) {\\n                std::cout << n->v << \"->\";\\n                n = n->n;\\n            }\\n            std::cout << std::endl;\\n            h = h->l;\\n        }\\n        std::cout << std::endl;\\n    }\\n\\npublic:\\n    Skiplist() {\\n    }\\n    \\n    bool search(int target) {\\n        return find(target);\\n    }\\n    \\n    void add(int num) {\\n        create();\\n\\n        Path path;\\n        find(num, &path);\\n\\n        Node* node = nullptr;\\n        do {\\n            if (path.empty()) {\\n                head = new Node(nullptr, head);\\n                path.push(head);\\n            }\\n\\n            auto* p = path.top();\\n            path.pop();\\n\\n            node = addNode(*p, node, num);\\n        }\\n        while (coinToss());\\n    }\\n    \\n    bool erase(int num) {\\n        Path path;\\n        if (!find(num, &path)) {\\n            return false;\\n        }\\n\\n        while (!path.empty()) {\\n            auto* p = path.top();\\n            path.pop();\\n\\n            auto* n = p->n;\\n            if ((n == nullptr) || (n->v != num)) {\\n                break;\\n            }\\n\\n            p->n = n->n;\\n            delete n;\\n        }\\n\\n        compact();\\n        \\n        return true;\\n    }\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3769533,
                "title": "very-easy-slow",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Skiplist {\\n    private List<object> ls;\\n    public Skiplist() {\\n        ls = new List<object>();\\n    }\\n    \\n    public bool Search(int target) {\\n        return ls.Contains(target);\\n    }\\n    \\n    public void Add(int num) {\\n        ls.Add(num);\\n    }\\n    \\n    public bool Erase(int num) {\\n        return ls.Remove(num);\\n    }\\n}\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist obj = new Skiplist();\\n * bool param_1 = obj.Search(target);\\n * obj.Add(num);\\n * bool param_3 = obj.Erase(num);\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Skiplist {\\n    private List<object> ls;\\n    public Skiplist() {\\n        ls = new List<object>();\\n    }\\n    \\n    public bool Search(int target) {\\n        return ls.Contains(target);\\n    }\\n    \\n    public void Add(int num) {\\n        ls.Add(num);\\n    }\\n    \\n    public bool Erase(int num) {\\n        return ls.Remove(num);\\n    }\\n}\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist obj = new Skiplist();\\n * bool param_1 = obj.Search(target);\\n * obj.Add(num);\\n * bool param_3 = obj.Erase(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765930,
                "title": "it-is-definitely-not-perfect-implementation-but-it-gets-the-job-done",
                "content": "It was a fun thing to code\\n\\n# Intuition\\nI found papers with more details about proper implementations, so as a good programmer I read them and decided to ignore everything in there.\\n\\n# Approach\\nI chose a fixed amount of layers for simplicity. All 3 of the functions work by the same principle. And pretty much works the same way as demonstrated in the gif. Small detail in my implementation is that I store every node, where I went down, in the array and after that add/erase elements.\\n\\n# Complexity\\n- Time complexity:\\nno clue brother\\n\\n- Space complexity:\\nno clue\\n\\n# Code\\n```\\nclass Skiplist {\\nstruct Node {\\n    int val;\\n    Node* right;\\n    Node* down;\\n    Node() : val(0), right(nullptr), down(nullptr) {}\\n    Node(int val) : val(val), right(nullptr), down(nullptr) {}\\n};\\npublic:\\n    Skiplist() {\\n        m_head = new Node();\\n        Node* curr = m_head->right = new Node();\\n        for (int i = 0 ; i < layers - 1; ++i, curr = curr->down) {\\n            curr->down = new Node(0);\\n        }\\n    }\\n    \\n    bool search(const int target) const noexcept {\\n        for (Node* curr = m_head->right, *next = curr->right;;) {\\n            if (!next) {\\n                curr = curr->down;\\n                if (curr == nullptr) break;\\n                next = curr;\\n                next = next->right;\\n                continue;\\n            }\\n            if (next->val == target) return true;\\n            if (next->val < target) {\\n                next = next->right;\\n                curr = curr->right;\\n            } else {\\n                curr = curr->down;\\n                if (curr == nullptr) break;\\n                next = curr;\\n                next = next->right;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    void add(const int num) noexcept {\\n        array<Node*, layers> ladder;\\n        int index = 0;\\n        for (Node* curr = m_head->right, *next = curr->right;;) {\\n            if (next == nullptr) {\\n                ladder[index++] = curr;\\n                curr = curr->down;\\n                if (curr == nullptr) break;\\n                next = curr;\\n                next = next->right;\\n                continue;\\n            }\\n            if (next->val < num) {\\n                next = next->right;\\n                curr = curr->right;\\n            } else {\\n                ladder[index++] = curr;\\n                curr = curr->down;\\n                if (curr == nullptr) break;\\n                next = curr;\\n                next = next->right;\\n            }\\n        }\\n        {Node* prev = nullptr;\\n        for (int i = 0; i < layers; ++i) {\\n            if (rand()&1 || !i) {\\n                Node* new_node = new Node(num);\\n                new_node->right = ladder[layers - i - 1]->right;\\n                ladder[layers - i - 1]->right = new_node;\\n                new_node->down = prev;\\n                prev = new_node;\\n                new_node = nullptr;\\n            }\\n            else break;\\n        }}\\n    }\\n    \\n    bool erase(const int num) noexcept {\\n        array<Node*, layers> ladder;\\n        ladder.fill(nullptr);\\n        int index = 0;\\n        for (Node* curr = m_head->right, *next = curr->right;;) {\\n            if (next == nullptr) {\\n                curr = curr->down;\\n                if (curr == nullptr) break;\\n                next = curr;\\n                next = next->right;\\n                continue;\\n            }\\n            if (next->val < num) {\\n                next = next->right;\\n                curr = curr->right;\\n            } else if (next->val == num){\\n                ladder[index++] = curr;\\n                curr = curr->down;\\n                if (curr == nullptr) break;\\n                next = curr;\\n                next = next->right;\\n            } else {\\n                curr = curr->down;\\n                if (curr == nullptr) break;\\n                next = curr;\\n                next = next->right;\\n            }\\n        }\\n        if(ladder[0]) {\\n            for (int i = 0; i < index; ++i) {\\n                Node* curr = ladder[i]->right;\\n                ladder[i]->right = curr->right;\\n                delete curr;\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\nprivate:\\n    static constexpr const int layers = 6;\\n    Node* m_head = nullptr;\\n};\\n\\n/*\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Skiplist {\\nstruct Node {\\n    int val;\\n    Node* right;\\n    Node* down;\\n    Node() : val(0), right(nullptr), down(nullptr) {}\\n    Node(int val) : val(val), right(nullptr), down(nullptr) {}\\n};\\npublic:\\n    Skiplist() {\\n        m_head = new Node();\\n        Node* curr = m_head->right = new Node();\\n        for (int i = 0 ; i < layers - 1; ++i, curr = curr->down) {\\n            curr->down = new Node(0);\\n        }\\n    }\\n    \\n    bool search(const int target) const noexcept {\\n        for (Node* curr = m_head->right, *next = curr->right;;) {\\n            if (!next) {\\n                curr = curr->down;\\n                if (curr == nullptr) break;\\n                next = curr;\\n                next = next->right;\\n                continue;\\n            }\\n            if (next->val == target) return true;\\n            if (next->val < target) {\\n                next = next->right;\\n                curr = curr->right;\\n            } else {\\n                curr = curr->down;\\n                if (curr == nullptr) break;\\n                next = curr;\\n                next = next->right;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    void add(const int num) noexcept {\\n        array<Node*, layers> ladder;\\n        int index = 0;\\n        for (Node* curr = m_head->right, *next = curr->right;;) {\\n            if (next == nullptr) {\\n                ladder[index++] = curr;\\n                curr = curr->down;\\n                if (curr == nullptr) break;\\n                next = curr;\\n                next = next->right;\\n                continue;\\n            }\\n            if (next->val < num) {\\n                next = next->right;\\n                curr = curr->right;\\n            } else {\\n                ladder[index++] = curr;\\n                curr = curr->down;\\n                if (curr == nullptr) break;\\n                next = curr;\\n                next = next->right;\\n            }\\n        }\\n        {Node* prev = nullptr;\\n        for (int i = 0; i < layers; ++i) {\\n            if (rand()&1 || !i) {\\n                Node* new_node = new Node(num);\\n                new_node->right = ladder[layers - i - 1]->right;\\n                ladder[layers - i - 1]->right = new_node;\\n                new_node->down = prev;\\n                prev = new_node;\\n                new_node = nullptr;\\n            }\\n            else break;\\n        }}\\n    }\\n    \\n    bool erase(const int num) noexcept {\\n        array<Node*, layers> ladder;\\n        ladder.fill(nullptr);\\n        int index = 0;\\n        for (Node* curr = m_head->right, *next = curr->right;;) {\\n            if (next == nullptr) {\\n                curr = curr->down;\\n                if (curr == nullptr) break;\\n                next = curr;\\n                next = next->right;\\n                continue;\\n            }\\n            if (next->val < num) {\\n                next = next->right;\\n                curr = curr->right;\\n            } else if (next->val == num){\\n                ladder[index++] = curr;\\n                curr = curr->down;\\n                if (curr == nullptr) break;\\n                next = curr;\\n                next = next->right;\\n            } else {\\n                curr = curr->down;\\n                if (curr == nullptr) break;\\n                next = curr;\\n                next = next->right;\\n            }\\n        }\\n        if(ladder[0]) {\\n            for (int i = 0; i < index; ++i) {\\n                Node* curr = ladder[i]->right;\\n                ladder[i]->right = curr->right;\\n                delete curr;\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\nprivate:\\n    static constexpr const int layers = 6;\\n    Node* m_head = nullptr;\\n};\\n\\n/*\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681552,
                "title": "design-skiplist",
                "content": "# Code\\n```\\nclass Skiplist:\\n\\n    def __init__(self):\\n        self.l = []\\n        \\n\\n    def search(self, target: int) -> bool:\\n        if target in self.l:\\n            return True\\n        else:\\n            return False\\n\\n    def add(self, num: int) -> None:\\n        self.l.append(num)\\n        \\n\\n    def erase(self, num: int) -> bool:\\n        if num in self.l:\\n            self.l.pop(self.l.index(num))\\n            return True\\n        else:\\n            return False\\n        \\n\\n        \\n        \\n\\n\\n# Your Skiplist object will be instantiated and called as such:\\n# obj = Skiplist()\\n# param_1 = obj.search(target)\\n# obj.add(num)\\n# param_3 = obj.erase(num)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Skiplist:\\n\\n    def __init__(self):\\n        self.l = []\\n        \\n\\n    def search(self, target: int) -> bool:\\n        if target in self.l:\\n            return True\\n        else:\\n            return False\\n\\n    def add(self, num: int) -> None:\\n        self.l.append(num)\\n        \\n\\n    def erase(self, num: int) -> bool:\\n        if num in self.l:\\n            self.l.pop(self.l.index(num))\\n            return True\\n        else:\\n            return False\\n        \\n\\n        \\n        \\n\\n\\n# Your Skiplist object will be instantiated and called as such:\\n# obj = Skiplist()\\n# param_1 = obj.search(target)\\n# obj.add(num)\\n# param_3 = obj.erase(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650092,
                "title": "simple-dictionary-py-97-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Skiplist:\\n\\n    def __init__(self):\\n        self.dic=dict()\\n    def search(self, target: int) -> bool:\\n        return False if self.dic.get(target)==None else True\\n\\n    def add(self, num: int) -> None:\\n        \\n        if self.dic.get(num)!=None:self.dic[num]+=1\\n        else:self.dic[num]=1\\n\\n    def erase(self, num: int) -> bool:\\n        if  self.dic.get(num)==None:return False\\n        self.dic[num]-=1\\n        if self.dic[num]==0:self.dic.pop(num)\\n        return True\\n\\n\\n# Your Skiplist object will be instantiated and called as such:\\n# obj = Skiplist()\\n# param_1 = obj.search(target)\\n# obj.add(num)\\n# param_3 = obj.erase(num)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Skiplist:\\n\\n    def __init__(self):\\n        self.dic=dict()\\n    def search(self, target: int) -> bool:\\n        return False if self.dic.get(target)==None else True\\n\\n    def add(self, num: int) -> None:\\n        \\n        if self.dic.get(num)!=None:self.dic[num]+=1\\n        else:self.dic[num]=1\\n\\n    def erase(self, num: int) -> bool:\\n        if  self.dic.get(num)==None:return False\\n        self.dic[num]-=1\\n        if self.dic[num]==0:self.dic.pop(num)\\n        return True\\n\\n\\n# Your Skiplist object will be instantiated and called as such:\\n# obj = Skiplist()\\n# param_1 = obj.search(target)\\n# obj.add(num)\\n# param_3 = obj.erase(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579821,
                "title": "easy-vector-solution-time-complexity-o-n-brute-force-soln-for-beginners",
                "content": "# Intuition\\nHere we apply a simple vector solution in c++ for Beginners only.\\nWe store all values in vector (unsorted) and do :\\n- `search` : we use linear search $$O(n)$$\\n    - You can use binary search ($$O(log(n))$$) if your storing in sorted manner.\\n- `add` : $$O(1)$$\\n    - We just append the given `num` in vector - $$O(1)$$\\n    - If you are using sorted vector, then you have to sort the vector after pushing the value to the vector - ($$O(nlog(n))$$)\\n- `erase` : we use linear search $$O(n)$$\\n    - You can use binary search ($$O(log(n))$$) if your storing in sorted manner.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n---\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n---\\n# Code\\n```\\nclass Skiplist {\\npublic:\\n    vector<int>vec;\\n    Skiplist() {\\n        \\n    }\\n    \\n    bool search(int target) {\\n        for(int i=0;i<vec.size();i++){\\n            if(vec[i]==target)return true;\\n        }\\n        return false;\\n    }\\n    \\n    void add(int num) {\\n        vec.push_back(num);\\n    }\\n    \\n    bool erase(int num) {\\n        bool found=false;\\n        vector<int>temp;\\n        for(int i=0;i<vec.size();i++){\\n            if(vec[i]!=num || found){\\n                temp.push_back(vec[i]);\\n            }\\n            else{\\n                found=true;\\n            }\\n        }\\n        vec=temp;\\n        return found;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Design"
                ],
                "code": "```\\nclass Skiplist {\\npublic:\\n    vector<int>vec;\\n    Skiplist() {\\n        \\n    }\\n    \\n    bool search(int target) {\\n        for(int i=0;i<vec.size();i++){\\n            if(vec[i]==target)return true;\\n        }\\n        return false;\\n    }\\n    \\n    void add(int num) {\\n        vec.push_back(num);\\n    }\\n    \\n    bool erase(int num) {\\n        bool found=false;\\n        vector<int>temp;\\n        for(int i=0;i<vec.size();i++){\\n            if(vec[i]!=num || found){\\n                temp.push_back(vec[i]);\\n            }\\n            else{\\n                found=true;\\n            }\\n        }\\n        vec=temp;\\n        return found;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579710,
                "title": "hash-table-using-2-universal-hashing-in-c-beating-100-speed",
                "content": "# Code\\n```\\nclass Skiplist {\\nprivate:\\n    vector<vector<int>> v ;\\n    /**\\n    values of a and b don\\'t really matter\\n    p must be a prime in [2 * 10^4, 4 * 10^4]\\n    N is the size of our vector, the bigger the vector the faster (but takes more memory)\\n    **/\\n    const int p = 20011, a = 950, b = 3123, N = 500 ;\\n\\n    // 2-Universal Hash Families\\n    int hash(int x){\\n        return ((a * x + b) % p) % N ;\\n    }\\npublic:\\n    Skiplist() {\\n        v.resize(N, vector<int>()) ;\\n    }\\n    \\n    bool search(int target) {\\n        vector<int> vec = v[hash(target)] ;\\n        auto it = find(vec.begin(), vec.end(), target) ;\\n        return it != vec.end() ;\\n    }\\n    \\n    void add(int num){\\n        v[hash(num)].push_back(num) ;\\n    }\\n    \\n    bool erase(int num) {\\n        int idx = hash(num) ;\\n        auto it = find(v[idx].begin(), v[idx].end(), num) ;\\n        if(it == v[idx].end())\\n            return false ;\\n        v[idx].erase(it) ;\\n        return true ;\\n    } \\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Skiplist {\\nprivate:\\n    vector<vector<int>> v ;\\n    /**\\n    values of a and b don\\'t really matter\\n    p must be a prime in [2 * 10^4, 4 * 10^4]\\n    N is the size of our vector, the bigger the vector the faster (but takes more memory)\\n    **/\\n    const int p = 20011, a = 950, b = 3123, N = 500 ;\\n\\n    // 2-Universal Hash Families\\n    int hash(int x){\\n        return ((a * x + b) % p) % N ;\\n    }\\npublic:\\n    Skiplist() {\\n        v.resize(N, vector<int>()) ;\\n    }\\n    \\n    bool search(int target) {\\n        vector<int> vec = v[hash(target)] ;\\n        auto it = find(vec.begin(), vec.end(), target) ;\\n        return it != vec.end() ;\\n    }\\n    \\n    void add(int num){\\n        v[hash(num)].push_back(num) ;\\n    }\\n    \\n    bool erase(int num) {\\n        int idx = hash(num) ;\\n        auto it = find(v[idx].begin(), v[idx].end(), num) ;\\n        if(it == v[idx].end())\\n            return false ;\\n        v[idx].erase(it) ;\\n        return true ;\\n    } \\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578140,
                "title": "easiest-solution-using-arraylist",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize an arraylist.\\n2. For search(), just check if the list contains the element\\n3. Follow the same approach for erase(), and remove the element.\\n4. For add(), directly add the number to the list\\n\\n\\n\\n# Code\\n```\\nclass Skiplist {\\nList<Integer> list;\\n    public Skiplist() {\\n        list=new ArrayList<>();\\n    }\\n    \\n    public boolean search(int target) {\\n        for(int i=0;i<list.size();i++){\\n            if(list.get(i)==target){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public void add(int num) {\\n        list.add(num);\\n    }\\n    \\n    public boolean erase(int num) {\\n        for(int i=0;i<list.size();i++){\\n            if(list.get(i)==num){\\n                list.remove(list.get(i));\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist obj = new Skiplist();\\n * boolean param_1 = obj.search(target);\\n * obj.add(num);\\n * boolean param_3 = obj.erase(num);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Skiplist {\\nList<Integer> list;\\n    public Skiplist() {\\n        list=new ArrayList<>();\\n    }\\n    \\n    public boolean search(int target) {\\n        for(int i=0;i<list.size();i++){\\n            if(list.get(i)==target){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public void add(int num) {\\n        list.add(num);\\n    }\\n    \\n    public boolean erase(int num) {\\n        for(int i=0;i<list.size();i++){\\n            if(list.get(i)==num){\\n                list.remove(list.get(i));\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist obj = new Skiplist();\\n * boolean param_1 = obj.search(target);\\n * obj.add(num);\\n * boolean param_3 = obj.erase(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3577862,
                "title": "easiest-o-1-object-javascript",
                "content": "# Intuition\\nObject\\n\\n# Approach\\n1. Initialise the object of the skiplist for each new instance.\\n2. Search : return true if target is present else return false.\\n3. Add : If num (key) is not present in list, defined it with value 1, else just increase the value by 1.\\n4. Erase : if value of the num (key) is greater than 1 then decrease value by 1 & return true, else if val is equal to 1 delete the num (key) from list and return true, else return false.\\n\\n# Complexity\\n- Time complexity:\\nSearch => $$O(1)$$\\nAdd => $$O(1)$$\\nErase => $$O(1)$$\\n\\n- Space complexity:\\n$$O(noOfNumbersAdded)$$\\n\\n# Code\\n```\\nvar Skiplist = function() {\\n    this.skiplist = {}\\n};\\n\\n/** \\n * @param {number} target\\n * @return {boolean}\\n */\\nSkiplist.prototype.search = function(target) {\\n    return this.skiplist[target]!==undefined ? true : false;\\n};\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nSkiplist.prototype.add = function(num) {\\n    if(this.skiplist[num]) this.skiplist[num]++\\n    else this.skiplist[num] = 1\\n};\\n\\n/** \\n * @param {number} num\\n * @return {boolean}\\n */\\nSkiplist.prototype.erase = function(num) {\\n    if(this.skiplist[num] > 1) {\\n        this.skiplist[num]--\\n        return true;\\n    } else if(this.skiplist[num] === 1){\\n        delete this.skiplist[num];\\n        return true\\n    } else {\\n        return false;\\n    }\\n};\\n\\n/** \\n * Your Skiplist object will be instantiated and called as such:\\n * var obj = new Skiplist()\\n * var param_1 = obj.search(target)\\n * obj.add(num)\\n * var param_3 = obj.erase(num)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar Skiplist = function() {\\n    this.skiplist = {}\\n};\\n\\n/** \\n * @param {number} target\\n * @return {boolean}\\n */\\nSkiplist.prototype.search = function(target) {\\n    return this.skiplist[target]!==undefined ? true : false;\\n};\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nSkiplist.prototype.add = function(num) {\\n    if(this.skiplist[num]) this.skiplist[num]++\\n    else this.skiplist[num] = 1\\n};\\n\\n/** \\n * @param {number} num\\n * @return {boolean}\\n */\\nSkiplist.prototype.erase = function(num) {\\n    if(this.skiplist[num] > 1) {\\n        this.skiplist[num]--\\n        return true;\\n    } else if(this.skiplist[num] === 1){\\n        delete this.skiplist[num];\\n        return true\\n    } else {\\n        return false;\\n    }\\n};\\n\\n/** \\n * Your Skiplist object will be instantiated and called as such:\\n * var obj = new Skiplist()\\n * var param_1 = obj.search(target)\\n * obj.add(num)\\n * var param_3 = obj.erase(num)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3577579,
                "title": "best-solution-in-java-runtime-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Skiplist {\\n        private static final int MAX_LEVEL = 16;\\n        private final Node head = new Node(Integer.MIN_VALUE);\\n        private int level = 1;\\n        private final Random rand = new Random();\\n\\n        public Skiplist() {\\n\\n        }\\n        public boolean search(int target) {\\n            Node cur = head;\\n            for(int i = level -1; i>=0; i--){\\n                while (cur.next[i] != null && cur.next[i].val < target){\\n                    cur = cur.next[i];\\n                }\\n            }    \\n            cur = cur.next[0];\\n            return cur != null && cur.val == target;\\n        }\\n    \\n        public void add(int num) {\\n            int newLevel = randomLevel();\\n            Node newNode = new Node(num, newLevel);\\n            Node cur = head;\\n            for (int i = level - 1; i >= 0; i--) {\\n                while (cur.next[i] != null && cur.next[i].val < num) {\\n                    cur = cur.next[i];\\n                }\\n                if (i < newLevel) {\\n                    newNode.next[i] = cur.next[i];\\n                    cur.next[i] = newNode;\\n                }\\n            }\\n            level = Math.max(level, newLevel);\\n        }\\n    \\n        public boolean erase(int num) {\\n            Node[] prev = new Node[level];\\n            Node cur = head;\\n            for (int i = level - 1; i >= 0; i--) {\\n                while (cur.next[i] != null && cur.next[i].val < num) {\\n                    cur = cur.next[i];\\n                }\\n                prev[i] = cur;\\n            }\\n            cur = cur.next[0];\\n            if (cur == null || cur.val != num) {\\n                return false;\\n            }\\n            for (int i = level - 1; i >= 0; i--) {\\n                if (prev[i].next[i] == cur) {\\n                    prev[i].next[i] = cur.next[i];\\n                    if (head.next[i] == null) {\\n                        level--;\\n                    }\\n                }\\n            }\\n            return true;\\n        }\\n\\n        private int randomLevel() {\\n            int newLevel = 1;\\n            while (rand.nextDouble() < 0.5 && newLevel < MAX_LEVEL) {\\n                newLevel++;\\n            }\\n            return newLevel;\\n        }\\n\\n        private static class Node {\\n            final int val;\\n            final Node[] next;\\n\\n            Node(int val, int level) {\\n                this.val = val;\\n                next = new Node[level];\\n            }\\n\\n            Node(int val) {\\n                this(val, MAX_LEVEL);\\n        }\\n    }\\n}   \\n\\n/**\\nBrute force refers to a method of solving a problem by trying every possible solution until a successful one is found. In the case of the Skiplist data structure, a brute force approach to search, add, and erase operations would involve iterating through every element in the Skiplist until the target element is found or the end of the list is reached. This approach would have a time complexity of O(n) for each operation, which is much slower than the O(log(n)) time complexity achieved by the Skiplist\\'s probabilistic approach. Therefore, a brute force approach is not recommended for Skiplist operations.\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Skiplist {\\n        private static final int MAX_LEVEL = 16;\\n        private final Node head = new Node(Integer.MIN_VALUE);\\n        private int level = 1;\\n        private final Random rand = new Random();\\n\\n        public Skiplist() {\\n\\n        }\\n        public boolean search(int target) {\\n            Node cur = head;\\n            for(int i = level -1; i>=0; i--){\\n                while (cur.next[i] != null && cur.next[i].val < target){\\n                    cur = cur.next[i];\\n                }\\n            }    \\n            cur = cur.next[0];\\n            return cur != null && cur.val == target;\\n        }\\n    \\n        public void add(int num) {\\n            int newLevel = randomLevel();\\n            Node newNode = new Node(num, newLevel);\\n            Node cur = head;\\n            for (int i = level - 1; i >= 0; i--) {\\n                while (cur.next[i] != null && cur.next[i].val < num) {\\n                    cur = cur.next[i];\\n                }\\n                if (i < newLevel) {\\n                    newNode.next[i] = cur.next[i];\\n                    cur.next[i] = newNode;\\n                }\\n            }\\n            level = Math.max(level, newLevel);\\n        }\\n    \\n        public boolean erase(int num) {\\n            Node[] prev = new Node[level];\\n            Node cur = head;\\n            for (int i = level - 1; i >= 0; i--) {\\n                while (cur.next[i] != null && cur.next[i].val < num) {\\n                    cur = cur.next[i];\\n                }\\n                prev[i] = cur;\\n            }\\n            cur = cur.next[0];\\n            if (cur == null || cur.val != num) {\\n                return false;\\n            }\\n            for (int i = level - 1; i >= 0; i--) {\\n                if (prev[i].next[i] == cur) {\\n                    prev[i].next[i] = cur.next[i];\\n                    if (head.next[i] == null) {\\n                        level--;\\n                    }\\n                }\\n            }\\n            return true;\\n        }\\n\\n        private int randomLevel() {\\n            int newLevel = 1;\\n            while (rand.nextDouble() < 0.5 && newLevel < MAX_LEVEL) {\\n                newLevel++;\\n            }\\n            return newLevel;\\n        }\\n\\n        private static class Node {\\n            final int val;\\n            final Node[] next;\\n\\n            Node(int val, int level) {\\n                this.val = val;\\n                next = new Node[level];\\n            }\\n\\n            Node(int val) {\\n                this(val, MAX_LEVEL);\\n        }\\n    }\\n}   \\n\\n/**\\nBrute force refers to a method of solving a problem by trying every possible solution until a successful one is found. In the case of the Skiplist data structure, a brute force approach to search, add, and erase operations would involve iterating through every element in the Skiplist until the target element is found or the end of the list is reached. This approach would have a time complexity of O(n) for each operation, which is much slower than the O(log(n)) time complexity achieved by the Skiplist\\'s probabilistic approach. Therefore, a brute force approach is not recommended for Skiplist operations.\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3577468,
                "title": "easy-using-arrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Skiplist {\\npublic:\\n    vector<int>v;\\n    Skiplist() {\\n       v.resize(2e4+1,-1) ;\\n    }\\n    \\n    bool search(int target) {\\n        if(v[target]==-1) return false;\\n        else return true;\\n    }\\n    \\n    void add(int num) {\\n        if(v[num]==-1){\\n            v[num]=1;\\n        }\\n        else{\\n            v[num]+=1;\\n        }\\n    }\\n    \\n    bool erase(int num) {\\n        if(v[num]!=-1){\\n            v[num]-=1;\\n            if(v[num]==0) v[num]=-1;\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Skiplist {\\npublic:\\n    vector<int>v;\\n    Skiplist() {\\n       v.resize(2e4+1,-1) ;\\n    }\\n    \\n    bool search(int target) {\\n        if(v[target]==-1) return false;\\n        else return true;\\n    }\\n    \\n    void add(int num) {\\n        if(v[num]==-1){\\n            v[num]=1;\\n        }\\n        else{\\n            v[num]+=1;\\n        }\\n    }\\n    \\n    bool erase(int num) {\\n        if(v[num]!=-1){\\n            v[num]-=1;\\n            if(v[num]==0) v[num]=-1;\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554339,
                "title": "the-fastest-c-solution-beats-100-runtime-and-memory",
                "content": "1833 milisecond c solution 35.2 mb memory consistently, relies on a doubly linked list and assuming the height of the skiplist is 16 (since the probability of flipping a heads 16 times in a row is akin to finding and individual with an iq of about 170 ;). \\nBacked by a multi-level, doubly linked list.  \\n\\nnote: not fastest!\\n\\nI posted a TLE solution that doesn\\'t assume a fixed height (which is kinda stupid ngl, since I can just initialize it to a number that gives a statistically impossible probabilty of flipping heads in a row lol). Nonetheless, I also included a solution that removes all instances of an element from the skiplist, should that ever be necessary. \\n\\nIF YOU LIKE THE SOLUTION PLEASE BE SURE TO UPVOTE AND LEAVE A COMMENT!!!!!!!  \\n``` \\n\\n/*multi-level doubly linked list*/\\n\\n\\ntypedef struct node {  \\n    int data;\\n    struct node *next; \\n    struct node *prev; \\n    struct node *down;\\n} Node; \\n\\ntypedef struct {  \\n    Node *lvl_head;   \\n    int lvl;\\n} Skiplist;     \\n\\nNode *create_node(int data);  \\nvoid addlvl(Skiplist *list); \\nbool search_helper(Node *obj, int target); \\nNode *insert(Node *obj, int num, int *heads); \\nbool delete(Skiplist *list, Node *obj, int target);\\nint coin_flip(void);\\n\\n\\nSkiplist* skiplistCreate() {\\n    Skiplist *skiplist = malloc(sizeof(Skiplist));   \\n    skiplist->lvl_head = NULL;  \\n    for(int i = 0; i<16 ; i++) { \\n        addlvl(skiplist);\\n    }\\n    return skiplist;\\n}\\n\\nbool skiplistSearch(Skiplist* obj, int target) { \\n    if(!obj) \\n        return false; \\n    return search_helper(obj->lvl_head,target);\\n}\\n\\nvoid skiplistAdd(Skiplist* obj, int num) { \\n    if(!obj) \\n        return; \\n    int num_heads = 0; \\n    while(coin_flip()) { \\n        num_heads++; \\n      /* if(num_heads > obj->lvl) \\n            addlvl(obj); \\n            */\\n    }\\n    insert(obj->lvl_head,num,&num_heads);\\n}\\n\\nbool skiplistErase(Skiplist* obj, int num) {\\n    if(!obj) \\n        return false; \\n    return delete(obj,obj->lvl_head,num);\\n}\\n\\nvoid skiplistFree(Skiplist* obj) {\\n    if(!obj) \\n        return; \\n    Node *curr = obj->lvl_head; \\n    while(curr) {   \\n        Node *tmp1 = curr->down;\\n        while(curr) { \\n            Node *tmp2 = curr->next; \\n            free(curr); \\n            curr = tmp2;\\n        } \\n        curr = tmp1;\\n    }\\n}  \\n\\nNode *create_node(int data) { \\n    Node *node = malloc(sizeof(Node)); \\n    node->data = data; \\n    node->next = NULL; \\n    node->prev = NULL; \\n    node->down = NULL; \\n    return node;\\n} \\nvoid addlvl(Skiplist *list) { \\n    if(list == NULL) \\n        return; \\n    Node *new_lvl_head = create_node(-1); \\n    new_lvl_head->down = list->lvl_head;   \\n    list->lvl_head = new_lvl_head;  \\n    list->lvl++;\\n    return;\\n}   \\n\\nbool search_helper(Node *obj, int target) { \\n    if(!obj) \\n        return false; \\n    Node *curr = obj;  \\n    \\n    while(curr->next && target > curr->next->data)  \\n        curr = curr->next;  \\n     \\n    if(!curr->next) \\n        return search_helper(obj->down,target);\\n    else if(target == curr->next->data) \\n        return true; \\n    else \\n        return search_helper(curr->down, target);\\n} \\n\\nNode *insert(Node *obj, int num, int *heads) {\\n    if(!obj) \\n        return NULL; \\n    Node *curr = obj; \\n    \\n    while(curr->next && num > curr->next->data) \\n        curr = curr->next; \\n     \\n    Node *below = insert(curr->down,num,heads);    \\n    \\n    if(heads>=0) { \\n        Node *to_insert = create_node(num);\\n        to_insert->down = below; \\n        to_insert->prev = curr; \\n        to_insert->next = curr->next;  \\n        if(curr->next) \\n            curr->next->prev = to_insert;\\n        curr->next = to_insert;  \\n        below = to_insert;\\n        (*heads)--;\\n    } \\n    return below;\\n}  \\n  \\n\\nbool delete(Skiplist *list, Node *obj, int target) { \\n    if(!obj) \\n        return false;  \\n    \\n    Node *curr = obj; \\n    \\n    while(curr->next && target > curr->next->data) \\n        curr = curr->next; \\n    \\n    if(!curr->next) \\n        return delete(list,obj->down,target); \\n    else if(target == curr->next->data) { \\n        Node *tmp = curr->next; \\n        Node *inner = tmp; \\n            \\n            while(inner) {\\n                Node *tmp3 = inner->down;  \\n                \\n                inner->prev->next = inner->next; \\n                if(inner->next) \\n                    inner->next->prev = inner->prev;  \\n                else if(!inner->prev->prev) {  \\n                    if(inner->prev == list->lvl_head) /*if overall head*/\\n                        list->lvl_head = inner->prev->down; \\n                        list->lvl--;\\n                    free(inner->prev);\\n                } /*can do because going top down*/\\n                free(inner); \\n                \\n                inner = tmp3;\\n            } \\n\\n        return true;\\n    }\\n        \\n    else \\n        return delete(list,curr->down, target);\\n} \\n\\nint coin_flip(void) { \\n    return rand()%2;\\n}\\n\\n/**\\n * Your Skiplist struct will be instantiated and called as such:\\n * Skiplist* obj = skiplistCreate();\\n * bool param_1 = skiplistSearch(obj, target);\\n \\n * skiplistAdd(obj, num);\\n \\n * bool param_3 = skiplistErase(obj, num);\\n \\n * skiplistFree(obj);\\n*/",
                "solutionTags": [
                    "C"
                ],
                "code": "1833 milisecond c solution 35.2 mb memory consistently, relies on a doubly linked list and assuming the height of the skiplist is 16 (since the probability of flipping a heads 16 times in a row is akin to finding and individual with an iq of about 170 ;). \\nBacked by a multi-level, doubly linked list.  \\n\\nnote: not fastest!\\n\\nI posted a TLE solution that doesn\\'t assume a fixed height (which is kinda stupid ngl, since I can just initialize it to a number that gives a statistically impossible probabilty of flipping heads in a row lol). Nonetheless, I also included a solution that removes all instances of an element from the skiplist, should that ever be necessary. \\n\\nIF YOU LIKE THE SOLUTION PLEASE BE SURE TO UPVOTE AND LEAVE A COMMENT!!!!!!!  \\n``` \\n\\n/*multi-level doubly linked list*/\\n\\n\\ntypedef struct node {  \\n    int data;\\n    struct node *next; \\n    struct node *prev; \\n    struct node *down;\\n} Node; \\n\\ntypedef struct {  \\n    Node *lvl_head;   \\n    int lvl;\\n} Skiplist;     \\n\\nNode *create_node(int data);  \\nvoid addlvl(Skiplist *list); \\nbool search_helper(Node *obj, int target); \\nNode *insert(Node *obj, int num, int *heads); \\nbool delete(Skiplist *list, Node *obj, int target);\\nint coin_flip(void);\\n\\n\\nSkiplist* skiplistCreate() {\\n    Skiplist *skiplist = malloc(sizeof(Skiplist));   \\n    skiplist->lvl_head = NULL;  \\n    for(int i = 0; i<16 ; i++) { \\n        addlvl(skiplist);\\n    }\\n    return skiplist;\\n}\\n\\nbool skiplistSearch(Skiplist* obj, int target) { \\n    if(!obj) \\n        return false; \\n    return search_helper(obj->lvl_head,target);\\n}\\n\\nvoid skiplistAdd(Skiplist* obj, int num) { \\n    if(!obj) \\n        return; \\n    int num_heads = 0; \\n    while(coin_flip()) { \\n        num_heads++; \\n      /* if(num_heads > obj->lvl) \\n            addlvl(obj); \\n            */\\n    }\\n    insert(obj->lvl_head,num,&num_heads);\\n}\\n\\nbool skiplistErase(Skiplist* obj, int num) {\\n    if(!obj) \\n        return false; \\n    return delete(obj,obj->lvl_head,num);\\n}\\n\\nvoid skiplistFree(Skiplist* obj) {\\n    if(!obj) \\n        return; \\n    Node *curr = obj->lvl_head; \\n    while(curr) {   \\n        Node *tmp1 = curr->down;\\n        while(curr) { \\n            Node *tmp2 = curr->next; \\n            free(curr); \\n            curr = tmp2;\\n        } \\n        curr = tmp1;\\n    }\\n}  \\n\\nNode *create_node(int data) { \\n    Node *node = malloc(sizeof(Node)); \\n    node->data = data; \\n    node->next = NULL; \\n    node->prev = NULL; \\n    node->down = NULL; \\n    return node;\\n} \\nvoid addlvl(Skiplist *list) { \\n    if(list == NULL) \\n        return; \\n    Node *new_lvl_head = create_node(-1); \\n    new_lvl_head->down = list->lvl_head;   \\n    list->lvl_head = new_lvl_head;  \\n    list->lvl++;\\n    return;\\n}   \\n\\nbool search_helper(Node *obj, int target) { \\n    if(!obj) \\n        return false; \\n    Node *curr = obj;  \\n    \\n    while(curr->next && target > curr->next->data)  \\n        curr = curr->next;  \\n     \\n    if(!curr->next) \\n        return search_helper(obj->down,target);\\n    else if(target == curr->next->data) \\n        return true; \\n    else \\n        return search_helper(curr->down, target);\\n} \\n\\nNode *insert(Node *obj, int num, int *heads) {\\n    if(!obj) \\n        return NULL; \\n    Node *curr = obj; \\n    \\n    while(curr->next && num > curr->next->data) \\n        curr = curr->next; \\n     \\n    Node *below = insert(curr->down,num,heads);    \\n    \\n    if(heads>=0) { \\n        Node *to_insert = create_node(num);\\n        to_insert->down = below; \\n        to_insert->prev = curr; \\n        to_insert->next = curr->next;  \\n        if(curr->next) \\n            curr->next->prev = to_insert;\\n        curr->next = to_insert;  \\n        below = to_insert;\\n        (*heads)--;\\n    } \\n    return below;\\n}  \\n  \\n\\nbool delete(Skiplist *list, Node *obj, int target) { \\n    if(!obj) \\n        return false;  \\n    \\n    Node *curr = obj; \\n    \\n    while(curr->next && target > curr->next->data) \\n        curr = curr->next; \\n    \\n    if(!curr->next) \\n        return delete(list,obj->down,target); \\n    else if(target == curr->next->data) { \\n        Node *tmp = curr->next; \\n        Node *inner = tmp; \\n            \\n            while(inner) {\\n                Node *tmp3 = inner->down;  \\n                \\n                inner->prev->next = inner->next; \\n                if(inner->next) \\n                    inner->next->prev = inner->prev;  \\n                else if(!inner->prev->prev) {  \\n                    if(inner->prev == list->lvl_head) /*if overall head*/\\n                        list->lvl_head = inner->prev->down; \\n                        list->lvl--;\\n                    free(inner->prev);\\n                } /*can do because going top down*/\\n                free(inner); \\n                \\n                inner = tmp3;\\n            } \\n\\n        return true;\\n    }\\n        \\n    else \\n        return delete(list,curr->down, target);\\n} \\n\\nint coin_flip(void) { \\n    return rand()%2;\\n}\\n\\n/**\\n * Your Skiplist struct will be instantiated and called as such:\\n * Skiplist* obj = skiplistCreate();\\n * bool param_1 = skiplistSearch(obj, target);\\n \\n * skiplistAdd(obj, num);\\n \\n * bool param_3 = skiplistErase(obj, num);\\n \\n * skiplistFree(obj);\\n*/",
                "codeTag": "Python3"
            },
            {
                "id": 3554244,
                "title": "c-tle",
                "content": "no remove duplicates\\n``` \\n\\n/*multi-level doubly linked list*/\\n\\n\\ntypedef struct node {  \\n    int data;\\n    struct node *next; \\n    struct node *prev; \\n    struct node *down;\\n} Node;\\ntypedef struct {  \\n    Node *lvl_head;   \\n    int lvl;\\n} Skiplist;     \\n\\nNode *create_node(int data);  \\nvoid addlvl(Skiplist *list); \\nbool search_helper(Node *obj, int target); \\nNode *insert(Node *obj, int num, int *heads); \\nbool delete(Skiplist *list, Node *obj, int target);\\nint coin_flip(void);\\n\\n\\nSkiplist* skiplistCreate() {\\n    Skiplist *skiplist = malloc(sizeof(Skiplist));   \\n    skiplist->lvl_head = NULL; \\n    addlvl(skiplist);\\n    return skiplist;\\n}\\n\\nbool skiplistSearch(Skiplist* obj, int target) { \\n    if(!obj) \\n        return false; \\n    return search_helper(obj->lvl_head,target);\\n}\\n\\nvoid skiplistAdd(Skiplist* obj, int num) { \\n    if(!obj) \\n        return; \\n    int num_heads = 0; \\n    while(coin_flip()) { \\n        num_heads++; \\n        if(num_heads > obj->lvl) \\n            addlvl(obj);\\n    }\\n    insert(obj->lvl_head,num,&num_heads);\\n}\\n\\nbool skiplistErase(Skiplist* obj, int num) {\\n    if(!obj) \\n        return false; \\n    return delete(obj,obj->lvl_head,num);\\n}\\n\\nvoid skiplistFree(Skiplist* obj) {\\n    \\n}  \\n\\nNode *create_node(int data) { \\n    Node *node = malloc(sizeof(Node)); \\n    node->data = data; \\n    node->next = NULL; \\n    node->prev = NULL; \\n    node->down = NULL; \\n    return node;\\n} \\nvoid addlvl(Skiplist *list) { \\n    if(list == NULL) \\n        return; \\n    Node *new_lvl_head = create_node(-1); \\n    new_lvl_head->down = list->lvl_head;   \\n    list->lvl_head = new_lvl_head;  \\n    list->lvl++;\\n    return;\\n}   \\n\\nbool search_helper(Node *obj, int target) { \\n    if(!obj) \\n        return false; \\n    Node *curr = obj;  \\n    \\n    while(curr->next && target > curr->next->data)  \\n        curr = curr->next;  \\n     \\n    if(!curr->next) \\n        return search_helper(obj->down,target);\\n    else if(target == curr->next->data) \\n        return true; \\n    else \\n        return search_helper(curr->down, target);\\n} \\n\\nNode *insert(Node *obj, int num, int *heads) {\\n    if(!obj) \\n        return NULL; \\n    Node *curr = obj; \\n    \\n    while(curr->next && num > curr->next->data) \\n        curr = curr->next; \\n     \\n    Node *below = insert(curr->down,num,heads);    \\n    \\n    if(heads>=0) { \\n        Node *to_insert = create_node(num);\\n        to_insert->down = below; \\n        to_insert->prev = curr; \\n        to_insert->next = curr->next;  \\n        if(curr->next) \\n            curr->next->prev = to_insert;\\n        curr->next = to_insert;  \\n        below = to_insert;\\n        (*heads)--;\\n    } \\n    return below;\\n}  \\n  \\n\\nbool delete(Skiplist *list, Node *obj, int target) { \\n    if(!obj) \\n        return false;  \\n    \\n    Node *curr = obj; \\n    \\n    while(curr->next && target > curr->next->data) \\n        curr = curr->next; \\n    \\n    if(!curr->next) \\n        return delete(list,obj->down,target); \\n    else if(target == curr->next->data) { \\n        Node *tmp = curr->next; \\n        while(tmp && target == tmp->data) {  \\n            Node *tmp2 = tmp->next;\\n            Node *inner = tmp; \\n            \\n            while(inner) {\\n                Node *tmp3 = inner->down;  \\n                \\n                inner->prev->next = inner->next; \\n                if(inner->next) \\n                    inner->next->prev = inner->prev;  \\n                else if(!inner->prev->prev) {  \\n                    if(inner->prev == list->lvl_head) /*if overall head*/\\n                        list->lvl_head = inner->prev->down; \\n                        list->lvl--;\\n                    free(inner->prev);\\n                } /*can do because going top down*/\\n                free(inner); \\n                \\n                inner = tmp3;\\n            } \\n            tmp = tmp2;\\n        }\\n        return true;\\n    }\\n        \\n    else \\n        return delete(list,curr->down, target);\\n} \\n\\nint coin_flip(void) { \\n    return rand()%2;\\n}\\n\\n/**\\n * Your Skiplist struct will be instantiated and called as such:\\n * Skiplist* obj = skiplistCreate();\\n * bool param_1 = skiplistSearch(obj, target);\\n \\n * skiplistAdd(obj, num);\\n \\n * bool param_3 = skiplistErase(obj, num);\\n \\n * skiplistFree(obj);\\n*/ \\n\\n``` \\nremove duplicates \\n``` \\n\\n/*multi-level doubly linked list*/\\n\\n\\ntypedef struct node {  \\n    int data;\\n    struct node *next; \\n    struct node *prev; \\n    struct node *down;\\n} Node; \\n\\ntypedef struct {  \\n    Node *lvl_head;   \\n    int lvl;\\n} Skiplist;     \\n\\nNode *create_node(int data);  \\nvoid addlvl(Skiplist *list); \\nbool search_helper(Node *obj, int target); \\nNode *insert(Node *obj, int num, int *heads); \\nbool delete(Skiplist *list, Node *obj, int target);\\nint coin_flip(void);\\n\\n\\nSkiplist* skiplistCreate() {\\n    Skiplist *skiplist = malloc(sizeof(Skiplist));   \\n    skiplist->lvl_head = NULL; \\n    addlvl(skiplist);\\n    return skiplist;\\n}\\n\\nbool skiplistSearch(Skiplist* obj, int target) { \\n    if(!obj) \\n        return false; \\n    return search_helper(obj->lvl_head,target);\\n}\\n\\nvoid skiplistAdd(Skiplist* obj, int num) { \\n    if(!obj) \\n        return; \\n    int num_heads = 0; \\n    while(coin_flip()) { \\n        num_heads++; \\n        if(num_heads > obj->lvl) \\n            addlvl(obj);\\n    }\\n    insert(obj->lvl_head,num,&num_heads);\\n}\\n\\nbool skiplistErase(Skiplist* obj, int num) {\\n    if(!obj) \\n        return false; \\n    return delete(obj,obj->lvl_head,num);\\n}\\n\\nvoid skiplistFree(Skiplist* obj) {\\n    \\n}  \\n\\nNode *create_node(int data) { \\n    Node *node = malloc(sizeof(Node)); \\n    node->data = data; \\n    node->next = NULL; \\n    node->prev = NULL; \\n    node->down = NULL; \\n    return node;\\n} \\nvoid addlvl(Skiplist *list) { \\n    if(list == NULL) \\n        return; \\n    Node *new_lvl_head = create_node(-1); \\n    new_lvl_head->down = list->lvl_head;   \\n    list->lvl_head = new_lvl_head;  \\n    list->lvl++;\\n    return;\\n}   \\n\\nbool search_helper(Node *obj, int target) { \\n    if(!obj) \\n        return false; \\n    Node *curr = obj;  \\n    \\n    while(curr->next && target > curr->next->data)  \\n        curr = curr->next;  \\n     \\n    if(!curr->next) \\n        return search_helper(obj->down,target);\\n    else if(target == curr->next->data) \\n        return true; \\n    else \\n        return search_helper(curr->down, target);\\n} \\n\\nNode *insert(Node *obj, int num, int *heads) {\\n    if(!obj) \\n        return NULL; \\n    Node *curr = obj; \\n    \\n    while(curr->next && num > curr->next->data) \\n        curr = curr->next; \\n     \\n    Node *below = insert(curr->down,num,heads);    \\n    \\n    if(heads>=0) { \\n        Node *to_insert = create_node(num);\\n        to_insert->down = below; \\n        to_insert->prev = curr; \\n        to_insert->next = curr->next;  \\n        if(curr->next) \\n            curr->next->prev = to_insert;\\n        curr->next = to_insert;  \\n        below = to_insert;\\n        (*heads)--;\\n    } \\n    return below;\\n}  \\n  \\n\\nbool delete(Skiplist *list, Node *obj, int target) { \\n    if(!obj) \\n        return false;  \\n    \\n    Node *curr = obj; \\n    \\n    while(curr->next && target > curr->next->data) \\n        curr = curr->next; \\n    \\n    if(!curr->next) \\n        return delete(list,obj->down,target); \\n    else if(target == curr->next->data) { \\n        Node *tmp = curr->next; \\n        Node *inner = tmp; \\n            \\n            while(inner) {\\n                Node *tmp3 = inner->down;  \\n                \\n                inner->prev->next = inner->next; \\n                if(inner->next) \\n                    inner->next->prev = inner->prev;  \\n                else if(!inner->prev->prev) {  \\n                    if(inner->prev == list->lvl_head) /*if overall head*/\\n                        list->lvl_head = inner->prev->down; \\n                        list->lvl--;\\n                    free(inner->prev);\\n                } /*can do because going top down*/\\n                free(inner); \\n                \\n                inner = tmp3;\\n            } \\n\\n        return true;\\n    }\\n        \\n    else \\n        return delete(list,curr->down, target);\\n} \\n\\nint coin_flip(void) { \\n    return rand()%2;\\n}\\n\\n/**\\n * Your Skiplist struct will be instantiated and called as such:\\n * Skiplist* obj = skiplistCreate();\\n * bool param_1 = skiplistSearch(obj, target);\\n \\n * skiplistAdd(obj, num);\\n \\n * bool param_3 = skiplistErase(obj, num);\\n \\n * skiplistFree(obj);\\n*/\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "``` \\n\\n/*multi-level doubly linked list*/\\n\\n\\ntypedef struct node {  \\n    int data;\\n    struct node *next; \\n    struct node *prev; \\n    struct node *down;\\n} Node;\\ntypedef struct {  \\n    Node *lvl_head;   \\n    int lvl;\\n} Skiplist;     \\n\\nNode *create_node(int data);  \\nvoid addlvl(Skiplist *list); \\nbool search_helper(Node *obj, int target); \\nNode *insert(Node *obj, int num, int *heads); \\nbool delete(Skiplist *list, Node *obj, int target);\\nint coin_flip(void);\\n\\n\\nSkiplist* skiplistCreate() {\\n    Skiplist *skiplist = malloc(sizeof(Skiplist));   \\n    skiplist->lvl_head = NULL; \\n    addlvl(skiplist);\\n    return skiplist;\\n}\\n\\nbool skiplistSearch(Skiplist* obj, int target) { \\n    if(!obj) \\n        return false; \\n    return search_helper(obj->lvl_head,target);\\n}\\n\\nvoid skiplistAdd(Skiplist* obj, int num) { \\n    if(!obj) \\n        return; \\n    int num_heads = 0; \\n    while(coin_flip()) { \\n        num_heads++; \\n        if(num_heads > obj->lvl) \\n            addlvl(obj);\\n    }\\n    insert(obj->lvl_head,num,&num_heads);\\n}\\n\\nbool skiplistErase(Skiplist* obj, int num) {\\n    if(!obj) \\n        return false; \\n    return delete(obj,obj->lvl_head,num);\\n}\\n\\nvoid skiplistFree(Skiplist* obj) {\\n    \\n}  \\n\\nNode *create_node(int data) { \\n    Node *node = malloc(sizeof(Node)); \\n    node->data = data; \\n    node->next = NULL; \\n    node->prev = NULL; \\n    node->down = NULL; \\n    return node;\\n} \\nvoid addlvl(Skiplist *list) { \\n    if(list == NULL) \\n        return; \\n    Node *new_lvl_head = create_node(-1); \\n    new_lvl_head->down = list->lvl_head;   \\n    list->lvl_head = new_lvl_head;  \\n    list->lvl++;\\n    return;\\n}   \\n\\nbool search_helper(Node *obj, int target) { \\n    if(!obj) \\n        return false; \\n    Node *curr = obj;  \\n    \\n    while(curr->next && target > curr->next->data)  \\n        curr = curr->next;  \\n     \\n    if(!curr->next) \\n        return search_helper(obj->down,target);\\n    else if(target == curr->next->data) \\n        return true; \\n    else \\n        return search_helper(curr->down, target);\\n} \\n\\nNode *insert(Node *obj, int num, int *heads) {\\n    if(!obj) \\n        return NULL; \\n    Node *curr = obj; \\n    \\n    while(curr->next && num > curr->next->data) \\n        curr = curr->next; \\n     \\n    Node *below = insert(curr->down,num,heads);    \\n    \\n    if(heads>=0) { \\n        Node *to_insert = create_node(num);\\n        to_insert->down = below; \\n        to_insert->prev = curr; \\n        to_insert->next = curr->next;  \\n        if(curr->next) \\n            curr->next->prev = to_insert;\\n        curr->next = to_insert;  \\n        below = to_insert;\\n        (*heads)--;\\n    } \\n    return below;\\n}  \\n  \\n\\nbool delete(Skiplist *list, Node *obj, int target) { \\n    if(!obj) \\n        return false;  \\n    \\n    Node *curr = obj; \\n    \\n    while(curr->next && target > curr->next->data) \\n        curr = curr->next; \\n    \\n    if(!curr->next) \\n        return delete(list,obj->down,target); \\n    else if(target == curr->next->data) { \\n        Node *tmp = curr->next; \\n        while(tmp && target == tmp->data) {  \\n            Node *tmp2 = tmp->next;\\n            Node *inner = tmp; \\n            \\n            while(inner) {\\n                Node *tmp3 = inner->down;  \\n                \\n                inner->prev->next = inner->next; \\n                if(inner->next) \\n                    inner->next->prev = inner->prev;  \\n                else if(!inner->prev->prev) {  \\n                    if(inner->prev == list->lvl_head) /*if overall head*/\\n                        list->lvl_head = inner->prev->down; \\n                        list->lvl--;\\n                    free(inner->prev);\\n                } /*can do because going top down*/\\n                free(inner); \\n                \\n                inner = tmp3;\\n            } \\n            tmp = tmp2;\\n        }\\n        return true;\\n    }\\n        \\n    else \\n        return delete(list,curr->down, target);\\n} \\n\\nint coin_flip(void) { \\n    return rand()%2;\\n}\\n\\n/**\\n * Your Skiplist struct will be instantiated and called as such:\\n * Skiplist* obj = skiplistCreate();\\n * bool param_1 = skiplistSearch(obj, target);\\n \\n * skiplistAdd(obj, num);\\n \\n * bool param_3 = skiplistErase(obj, num);\\n \\n * skiplistFree(obj);\\n*/ \\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3504429,
                "title": "c-skiplist-implementation",
                "content": "\\n# Code\\n```\\nstruct Node {\\n    int val;\\n    struct Node* next;\\n    struct Node* up;\\n    struct Node* down;\\n};\\n\\ntypedef struct {\\n    struct Node* top;\\n} Skiplist;\\n\\n// create stack structure we will need\\n\\nvoid printSkipList(Skiplist* obj) {\\n    struct Node* st_ptr = obj->top;\\n    while (st_ptr) {\\n        struct Node* dummy = st_ptr;\\n        while (dummy) {\\n            printf(\"%d->\", dummy->val);\\n            dummy = dummy->next;\\n        }\\n        printf(\"\\\\n\");\\n        st_ptr = st_ptr->down;\\n    }\\n}\\nstruct Node* createNode(int val) {\\n    struct Node* newNode = malloc(sizeof(struct Node));\\n    newNode->val = val;\\n    newNode->next = NULL;\\n    newNode->up = NULL;\\n    newNode->down = NULL;\\n    return newNode;\\n}\\n\\nvoid freeNode(struct Node* node) {\\n    node->next = NULL;\\n    node->up = NULL;\\n    node->down = NULL;\\n}\\n\\nint addToStack(Skiplist* obj, struct Node* node) {\\n    obj->top->up = node;\\n    node->down = obj->top;\\n    obj->top = node;\\n    return 0;\\n}\\n\\n\\nint deleteFromStack(Skiplist* obj) {\\n    // no elements left or only 1 element left\\n    if (obj->top == NULL || obj->top->down == NULL) {\\n        return -1;\\n    }\\n    struct Node* belowNode = obj->top->down;\\n    belowNode->up = NULL;\\n    struct Node* temp = obj->top;\\n    freeNode(temp);\\n    free(temp);\\n    obj->top = belowNode;\\n    return 0;\\n}\\n\\n\\n\\nSkiplist* skiplistCreate() {\\n    struct Node* tempHead = createNode(-1);\\n    struct Node* tempTail = createNode(20001);\\n    tempHead->next = tempTail;\\n    Skiplist *s = malloc(sizeof(Skiplist));\\n    s->top = tempHead;\\n    return s;\\n}\\n\\nbool skiplistSearch(Skiplist* obj, int target) {\\n    struct Node* level = obj->top;\\n    while (level != NULL) {\\n        struct Node* temp = level;\\n        while (temp->next != NULL && temp->next->val < target) {\\n            temp = temp->next;\\n        }\\n        if (temp->next != NULL && temp->next->val == target) {\\n            return true;\\n        }\\n        level = temp->down;\\n    }\\n    return false;\\n}\\n\\nvoid skiplistAdd(Skiplist* obj, int num) {\\n    // assuming stack size will not grow over 500\\n    srand(time(NULL));\\n    struct Node* st[500];\\n    int ind = 0;\\n    struct Node* level = obj->top;\\n    while (level != NULL) {\\n        struct Node* dummy = level;\\n        while (dummy->next != NULL && dummy->next->val < num) {\\n            dummy = dummy->next;\\n        }\\n        st[ind] = dummy;\\n        ind++;\\n        level = dummy->down;\\n    }\\n    ind--;\\n    level = NULL;\\n    int head = 1;\\n    while (ind >= 0 && head) {\\n        struct Node* newNode = createNode(num);\\n        newNode->down = level;\\n        struct Node* cur = st[ind];\\n        newNode->next = cur->next;\\n        cur->next = newNode;\\n        level = newNode;\\n        ind--;\\n        head = rand() % 2;\\n    }\\n    if (ind < 0 && head) {\\n        // create a new level\\n        struct Node* tempHead = createNode(-1);\\n        struct Node* tempTail = createNode(20001);\\n        struct Node* newNode = createNode(num);\\n        tempHead->next = newNode;\\n        newNode->next = tempTail;\\n        newNode->down = level;\\n        tempHead->down = obj->top;\\n        obj->top = tempHead;\\n    }\\n    return;\\n}\\n\\nbool skiplistErase(Skiplist* obj, int num) {\\n    // again assuming stack size to be 500\\n    struct Node* st[500];\\n    int ind = 0;\\n    struct Node* level = obj->top;\\n    struct Node* temp = obj->top;\\n    while (temp) {\\n        temp = temp->next;\\n    }\\n    while (level != NULL) {\\n        struct Node* dummy = level;\\n        while (dummy->next != NULL && dummy->next->val < num) {\\n            dummy = dummy->next;\\n        }\\n        if (dummy->next != NULL && dummy->next->val == num) {\\n            st[ind] = dummy;\\n            ind++;\\n        }\\n        level = dummy->down;\\n    }\\n    if (ind == 0) {\\n        return false;\\n    }\\n    ind--;\\n    while (ind >= 0) {\\n        struct Node* cur = st[ind];\\n        struct Node* temp = cur->next;\\n        cur->next = cur->next->next;\\n        freeNode(temp);\\n        free(temp);\\n        ind--;\\n    }\\n    while (obj->top->down != NULL && obj->top->down->down != NULL && obj->top->next->next == NULL) {\\n        struct Node* temp1 = obj->top;\\n        struct Node* temp2 = obj->top->next;\\n        obj->top = obj->top->down;\\n        freeNode(temp1);\\n        freeNode(temp2);\\n        free(temp1);\\n        free(temp2);\\n    }\\n    return true;\\n}\\n\\nvoid skiplistFree(Skiplist* obj) {\\n    free(obj);\\n    return;\\n}\\n\\n/**\\n * Your Skiplist struct will be instantiated and called as such:\\n * Skiplist* obj = skiplistCreate();\\n * bool param_1 = skiplistSearch(obj, target);\\n \\n * skiplistAdd(obj, num);\\n \\n * bool param_3 = skiplistErase(obj, num);\\n \\n * skiplistFree(obj);\\n*/\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct Node {\\n    int val;\\n    struct Node* next;\\n    struct Node* up;\\n    struct Node* down;\\n};\\n\\ntypedef struct {\\n    struct Node* top;\\n} Skiplist;\\n\\n// create stack structure we will need\\n\\nvoid printSkipList(Skiplist* obj) {\\n    struct Node* st_ptr = obj->top;\\n    while (st_ptr) {\\n        struct Node* dummy = st_ptr;\\n        while (dummy) {\\n            printf(\"%d->\", dummy->val);\\n            dummy = dummy->next;\\n        }\\n        printf(\"\\\\n\");\\n        st_ptr = st_ptr->down;\\n    }\\n}\\nstruct Node* createNode(int val) {\\n    struct Node* newNode = malloc(sizeof(struct Node));\\n    newNode->val = val;\\n    newNode->next = NULL;\\n    newNode->up = NULL;\\n    newNode->down = NULL;\\n    return newNode;\\n}\\n\\nvoid freeNode(struct Node* node) {\\n    node->next = NULL;\\n    node->up = NULL;\\n    node->down = NULL;\\n}\\n\\nint addToStack(Skiplist* obj, struct Node* node) {\\n    obj->top->up = node;\\n    node->down = obj->top;\\n    obj->top = node;\\n    return 0;\\n}\\n\\n\\nint deleteFromStack(Skiplist* obj) {\\n    // no elements left or only 1 element left\\n    if (obj->top == NULL || obj->top->down == NULL) {\\n        return -1;\\n    }\\n    struct Node* belowNode = obj->top->down;\\n    belowNode->up = NULL;\\n    struct Node* temp = obj->top;\\n    freeNode(temp);\\n    free(temp);\\n    obj->top = belowNode;\\n    return 0;\\n}\\n\\n\\n\\nSkiplist* skiplistCreate() {\\n    struct Node* tempHead = createNode(-1);\\n    struct Node* tempTail = createNode(20001);\\n    tempHead->next = tempTail;\\n    Skiplist *s = malloc(sizeof(Skiplist));\\n    s->top = tempHead;\\n    return s;\\n}\\n\\nbool skiplistSearch(Skiplist* obj, int target) {\\n    struct Node* level = obj->top;\\n    while (level != NULL) {\\n        struct Node* temp = level;\\n        while (temp->next != NULL && temp->next->val < target) {\\n            temp = temp->next;\\n        }\\n        if (temp->next != NULL && temp->next->val == target) {\\n            return true;\\n        }\\n        level = temp->down;\\n    }\\n    return false;\\n}\\n\\nvoid skiplistAdd(Skiplist* obj, int num) {\\n    // assuming stack size will not grow over 500\\n    srand(time(NULL));\\n    struct Node* st[500];\\n    int ind = 0;\\n    struct Node* level = obj->top;\\n    while (level != NULL) {\\n        struct Node* dummy = level;\\n        while (dummy->next != NULL && dummy->next->val < num) {\\n            dummy = dummy->next;\\n        }\\n        st[ind] = dummy;\\n        ind++;\\n        level = dummy->down;\\n    }\\n    ind--;\\n    level = NULL;\\n    int head = 1;\\n    while (ind >= 0 && head) {\\n        struct Node* newNode = createNode(num);\\n        newNode->down = level;\\n        struct Node* cur = st[ind];\\n        newNode->next = cur->next;\\n        cur->next = newNode;\\n        level = newNode;\\n        ind--;\\n        head = rand() % 2;\\n    }\\n    if (ind < 0 && head) {\\n        // create a new level\\n        struct Node* tempHead = createNode(-1);\\n        struct Node* tempTail = createNode(20001);\\n        struct Node* newNode = createNode(num);\\n        tempHead->next = newNode;\\n        newNode->next = tempTail;\\n        newNode->down = level;\\n        tempHead->down = obj->top;\\n        obj->top = tempHead;\\n    }\\n    return;\\n}\\n\\nbool skiplistErase(Skiplist* obj, int num) {\\n    // again assuming stack size to be 500\\n    struct Node* st[500];\\n    int ind = 0;\\n    struct Node* level = obj->top;\\n    struct Node* temp = obj->top;\\n    while (temp) {\\n        temp = temp->next;\\n    }\\n    while (level != NULL) {\\n        struct Node* dummy = level;\\n        while (dummy->next != NULL && dummy->next->val < num) {\\n            dummy = dummy->next;\\n        }\\n        if (dummy->next != NULL && dummy->next->val == num) {\\n            st[ind] = dummy;\\n            ind++;\\n        }\\n        level = dummy->down;\\n    }\\n    if (ind == 0) {\\n        return false;\\n    }\\n    ind--;\\n    while (ind >= 0) {\\n        struct Node* cur = st[ind];\\n        struct Node* temp = cur->next;\\n        cur->next = cur->next->next;\\n        freeNode(temp);\\n        free(temp);\\n        ind--;\\n    }\\n    while (obj->top->down != NULL && obj->top->down->down != NULL && obj->top->next->next == NULL) {\\n        struct Node* temp1 = obj->top;\\n        struct Node* temp2 = obj->top->next;\\n        obj->top = obj->top->down;\\n        freeNode(temp1);\\n        freeNode(temp2);\\n        free(temp1);\\n        free(temp2);\\n    }\\n    return true;\\n}\\n\\nvoid skiplistFree(Skiplist* obj) {\\n    free(obj);\\n    return;\\n}\\n\\n/**\\n * Your Skiplist struct will be instantiated and called as such:\\n * Skiplist* obj = skiplistCreate();\\n * bool param_1 = skiplistSearch(obj, target);\\n \\n * skiplistAdd(obj, num);\\n \\n * bool param_3 = skiplistErase(obj, num);\\n \\n * skiplistFree(obj);\\n*/\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3458725,
                "title": "clean-kotlin-solution",
                "content": "# Code\\n```\\nimport kotlin.math.ln\\nimport kotlin.random.Random\\n\\nclass Skiplist {\\n\\n    private data class Node(val value: Int, val next: MutableList<Node> = mutableListOf()) {\\n        private fun <T> MutableList<T>.insertOrAdd(item: T, index: Int): T? {\\n            return if (this.lastIndex < index) {\\n                this.add(item)\\n                null\\n            } else {\\n                val old = this[index]\\n                this[index] = item\\n                old\\n            }\\n        }\\n\\n        val levelsDescending get() = next.lastIndex downTo 0\\n\\n        fun insert(other: Node, level: Int) {\\n            val forward = next.insertOrAdd(other, level)\\n            if (forward != null && forward !== other) {\\n                other.insert(forward, level)\\n            }\\n        }\\n\\n        fun delete(level: Int) {\\n            val node = this.next.removeAt(level)\\n            if (node.next.lastIndex >= level) {\\n                next.insertOrAdd(node.next[level], level)\\n            }\\n        }\\n\\n        fun canFastForward(value: Int, level: Int): Boolean {\\n            return next.lastIndex >= level && value > next[level].value\\n        }\\n\\n        inline fun forEachLevel(consumer: (Int) -> Unit) {\\n            for (level in levelsDescending) {\\n                consumer(level)\\n            }\\n        }\\n\\n        fun hasNext(value: Int, level: Int): Boolean {\\n            return next.lastIndex >= level && value == next[level].value\\n        }\\n    }\\n\\n    private val head: Node = Node(0)\\n    private val randomFactor = 0.5\\n\\n    private var size = 0\\n\\n    fun add(num: Int) {\\n        val nodesToUpdate = mutableMapOf<Int, Node>()\\n        val newNode = Node(num)\\n\\n        var node = head\\n        head.forEachLevel { i ->\\n            while (node.canFastForward(num, i)) {\\n                node = node.next[i]\\n            }\\n            nodesToUpdate[i] = node\\n        }\\n\\n\\n        val nodeLevel = randomLevel()\\n        for (i in 0..nodeLevel) {\\n            val nodeToUpdate = nodesToUpdate.getOrDefault(i, head)\\n            nodeToUpdate.insert(newNode, i)\\n        }\\n        size++\\n    }\\n\\n    fun erase(num: Int): Boolean {\\n        val nodesToUpdate = mutableMapOf<Int, Node>()\\n        var node = head\\n        var found = false\\n\\n        head.forEachLevel { level ->\\n            while (node.canFastForward(num, level)) {\\n                node = node.next[level]\\n            }\\n            if (node.hasNext(num, level)) {\\n                nodesToUpdate[level] = node\\n                found = true\\n                return@forEachLevel\\n            }\\n        }\\n\\n        if (!found) {\\n            return false\\n        }\\n\\n        nodesToUpdate.forEach { (level, nodeToUpdate) -> nodeToUpdate.delete(level) }\\n        size--\\n\\n        return true\\n    }\\n\\n    fun search(target: Int): Boolean {\\n        var node = head\\n\\n        head.forEachLevel { level ->\\n            while (node.canFastForward(target, level)) {\\n                node = node.next[level]\\n            }\\n            if (node.hasNext(target, level)) {\\n                return true\\n            }\\n        }\\n\\n        return false\\n    }\\n\\n    private fun randomLevel(): Int {\\n        var level = 0\\n        val maxLevel = maxLevel()\\n        while (Math.random() > randomFactor && level < maxLevel) {\\n            level++\\n        }\\n        return level\\n    }\\n\\n    private fun maxLevel(): Int {\\n        return (ln(size.toDouble()) / ln(1 / randomFactor)).toInt()\\n    }\\n\\n\\n    // TEST FUNCTION\\n    fun draw(): String {\\n        val builder = StringBuilder()\\n        for (i in head.next.indices.reversed()) {\\n            var node: Node? = head.next.getOrNull(i)\\n            builder.append(\"Lane $i: \")\\n\\n            while (node != null) {\\n                builder.append(\"${node.value} -> \")\\n                node = node.next.getOrNull(i)\\n            }\\n            builder.delete(builder.length - 3, builder.length)\\n            builder.append(\"\\\\n\")\\n        }\\n        return builder.toString()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nimport kotlin.math.ln\\nimport kotlin.random.Random\\n\\nclass Skiplist {\\n\\n    private data class Node(val value: Int, val next: MutableList<Node> = mutableListOf()) {\\n        private fun <T> MutableList<T>.insertOrAdd(item: T, index: Int): T? {\\n            return if (this.lastIndex < index) {\\n                this.add(item)\\n                null\\n            } else {\\n                val old = this[index]\\n                this[index] = item\\n                old\\n            }\\n        }\\n\\n        val levelsDescending get() = next.lastIndex downTo 0\\n\\n        fun insert(other: Node, level: Int) {\\n            val forward = next.insertOrAdd(other, level)\\n            if (forward != null && forward !== other) {\\n                other.insert(forward, level)\\n            }\\n        }\\n\\n        fun delete(level: Int) {\\n            val node = this.next.removeAt(level)\\n            if (node.next.lastIndex >= level) {\\n                next.insertOrAdd(node.next[level], level)\\n            }\\n        }\\n\\n        fun canFastForward(value: Int, level: Int): Boolean {\\n            return next.lastIndex >= level && value > next[level].value\\n        }\\n\\n        inline fun forEachLevel(consumer: (Int) -> Unit) {\\n            for (level in levelsDescending) {\\n                consumer(level)\\n            }\\n        }\\n\\n        fun hasNext(value: Int, level: Int): Boolean {\\n            return next.lastIndex >= level && value == next[level].value\\n        }\\n    }\\n\\n    private val head: Node = Node(0)\\n    private val randomFactor = 0.5\\n\\n    private var size = 0\\n\\n    fun add(num: Int) {\\n        val nodesToUpdate = mutableMapOf<Int, Node>()\\n        val newNode = Node(num)\\n\\n        var node = head\\n        head.forEachLevel { i ->\\n            while (node.canFastForward(num, i)) {\\n                node = node.next[i]\\n            }\\n            nodesToUpdate[i] = node\\n        }\\n\\n\\n        val nodeLevel = randomLevel()\\n        for (i in 0..nodeLevel) {\\n            val nodeToUpdate = nodesToUpdate.getOrDefault(i, head)\\n            nodeToUpdate.insert(newNode, i)\\n        }\\n        size++\\n    }\\n\\n    fun erase(num: Int): Boolean {\\n        val nodesToUpdate = mutableMapOf<Int, Node>()\\n        var node = head\\n        var found = false\\n\\n        head.forEachLevel { level ->\\n            while (node.canFastForward(num, level)) {\\n                node = node.next[level]\\n            }\\n            if (node.hasNext(num, level)) {\\n                nodesToUpdate[level] = node\\n                found = true\\n                return@forEachLevel\\n            }\\n        }\\n\\n        if (!found) {\\n            return false\\n        }\\n\\n        nodesToUpdate.forEach { (level, nodeToUpdate) -> nodeToUpdate.delete(level) }\\n        size--\\n\\n        return true\\n    }\\n\\n    fun search(target: Int): Boolean {\\n        var node = head\\n\\n        head.forEachLevel { level ->\\n            while (node.canFastForward(target, level)) {\\n                node = node.next[level]\\n            }\\n            if (node.hasNext(target, level)) {\\n                return true\\n            }\\n        }\\n\\n        return false\\n    }\\n\\n    private fun randomLevel(): Int {\\n        var level = 0\\n        val maxLevel = maxLevel()\\n        while (Math.random() > randomFactor && level < maxLevel) {\\n            level++\\n        }\\n        return level\\n    }\\n\\n    private fun maxLevel(): Int {\\n        return (ln(size.toDouble()) / ln(1 / randomFactor)).toInt()\\n    }\\n\\n\\n    // TEST FUNCTION\\n    fun draw(): String {\\n        val builder = StringBuilder()\\n        for (i in head.next.indices.reversed()) {\\n            var node: Node? = head.next.getOrNull(i)\\n            builder.append(\"Lane $i: \")\\n\\n            while (node != null) {\\n                builder.append(\"${node.value} -> \")\\n                node = node.next.getOrNull(i)\\n            }\\n            builder.delete(builder.length - 3, builder.length)\\n            builder.append(\"\\\\n\")\\n        }\\n        return builder.toString()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452649,
                "title": "easy-to-understand-faster-simple-python-solution",
                "content": "# Code\\n```\\nclass ListNode: \\n    def __init__(self, val, cnt=1, next=None, down=None): \\n        self.val = val\\n        self.cnt = cnt\\n        self.next = next\\n        self.down = down\\n\\n        \\nclass Skiplist:\\n\\n    def __init__(self):\\n        self.head = ListNode(-inf)\\n        self.p = 1/4 \\n            \\n    def search(self, target: int) -> bool:\\n        node = self.head \\n        while node and node.val < target: \\n            if node.next and node.next.val <= target: node = node.next \\n            else: node = node.down \\n        return node\\n\\n    def add(self, num: int) -> None:\\n        node = self.head \\n        stack = []\\n        while node and node.val < num: \\n            if node.next and node.next.val <= num: node = node.next \\n            else: \\n                stack.append(node)\\n                node = node.down\\n        if node: \\n            while node: \\n                node.cnt += 1\\n                node = node.down \\n        else: \\n            prev = None\\n            while True: \\n                if stack: \\n                    node = stack.pop()\\n                    node.next = prev = ListNode(num, down=prev, next=node.next)\\n                else: \\n                    self.head = ListNode(-inf, down=self.head)\\n                    self.head.next = prev = ListNode(num, down=prev)\\n                if random.random() >= self.p: break \\n\\n    def erase(self, num: int) -> bool:\\n        node = self.head \\n        stack = []\\n        ans = False\\n        while node: \\n            if node.next and node.next.val < num: node = node.next\\n            else: \\n                stack.append(node)\\n                node = node.down \\n        while stack: \\n            node = stack.pop()\\n            if node.next and node.next.val == num: \\n                ans = True\\n                if node.next.cnt > 1: node.next.cnt -= 1\\n                else: node.next = node.next.next \\n            else: break \\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass ListNode: \\n    def __init__(self, val, cnt=1, next=None, down=None): \\n        self.val = val\\n        self.cnt = cnt\\n        self.next = next\\n        self.down = down\\n\\n        \\nclass Skiplist:\\n\\n    def __init__(self):\\n        self.head = ListNode(-inf)\\n        self.p = 1/4 \\n            \\n    def search(self, target: int) -> bool:\\n        node = self.head \\n        while node and node.val < target: \\n            if node.next and node.next.val <= target: node = node.next \\n            else: node = node.down \\n        return node\\n\\n    def add(self, num: int) -> None:\\n        node = self.head \\n        stack = []\\n        while node and node.val < num: \\n            if node.next and node.next.val <= num: node = node.next \\n            else: \\n                stack.append(node)\\n                node = node.down\\n        if node: \\n            while node: \\n                node.cnt += 1\\n                node = node.down \\n        else: \\n            prev = None\\n            while True: \\n                if stack: \\n                    node = stack.pop()\\n                    node.next = prev = ListNode(num, down=prev, next=node.next)\\n                else: \\n                    self.head = ListNode(-inf, down=self.head)\\n                    self.head.next = prev = ListNode(num, down=prev)\\n                if random.random() >= self.p: break \\n\\n    def erase(self, num: int) -> bool:\\n        node = self.head \\n        stack = []\\n        ans = False\\n        while node: \\n            if node.next and node.next.val < num: node = node.next\\n            else: \\n                stack.append(node)\\n                node = node.down \\n        while stack: \\n            node = stack.pop()\\n            if node.next and node.next.val == num: \\n                ans = True\\n                if node.next.cnt > 1: node.next.cnt -= 1\\n                else: node.next = node.next.next \\n            else: break \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311196,
                "title": "c-easy-to-understand-solution-version",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Skiplist {\\n\\n    ArrayList al = null;\\n\\n    public Skiplist() {\\n        al = new ArrayList();\\n    }\\n    \\n    public bool Search(int target) {\\n        return al.Contains(target); \\n    }\\n    \\n    public void Add(int num) {\\n        al.Add(num);\\n    }\\n    \\n    public bool Erase(int num) {\\n        if (al.Contains(num))\\n        {\\n            al.Remove(num);\\n            return true;\\n        } \\n        else {\\n            return false;\\n        }\\n    }\\n}\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist obj = new Skiplist();\\n * bool param_1 = obj.Search(target);\\n * obj.Add(num);\\n * bool param_3 = obj.Erase(num);\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Skiplist {\\n\\n    ArrayList al = null;\\n\\n    public Skiplist() {\\n        al = new ArrayList();\\n    }\\n    \\n    public bool Search(int target) {\\n        return al.Contains(target); \\n    }\\n    \\n    public void Add(int num) {\\n        al.Add(num);\\n    }\\n    \\n    public bool Erase(int num) {\\n        if (al.Contains(num))\\n        {\\n            al.Remove(num);\\n            return true;\\n        } \\n        else {\\n            return false;\\n        }\\n    }\\n}\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist obj = new Skiplist();\\n * bool param_1 = obj.Search(target);\\n * obj.Add(num);\\n * bool param_3 = obj.Erase(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279978,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct Node{\\n    int val=INT_MIN;\\n    int count=-1;\\n    Node* left=NULL;\\n    Node* right=NULL;\\n    Node* up=NULL;\\n    Node* down=NULL;\\n    Node(){\\n        count=1;\\n    }\\n    Node(int value):val(value),count(1){}\\n};\\n\\nNode* find_up_l(Node* sentinel,int value){\\n    Node* temp=sentinel;\\n    while(temp->right && temp->right->val<=value) temp=temp->right;\\n    return temp;\\n}\\n\\nNode* promotion(Node*& up_l,Node*& up_r,Node*& n){\\n    Node* new_node=new Node(n->val);\\n    new_node->down=n;\\n    new_node->left=up_l;\\n    new_node->right=up_r;\\n    up_l->right=new_node;\\n    n->up=new_node;\\n    if(up_r) up_r->left=new_node;\\n    return new_node;\\n}\\n\\nNode* skip_search(Node* top_head_s,int target,Node* &sentinel){\\n    Node* temp=top_head_s;\\n    while(true){\\n        if(temp->val==target) return temp;\\n        if(temp->right && temp->right->val<=target){\\n            temp=temp->right;\\n        }\\n        else{\\n            if(temp->down){ \\n                sentinel=sentinel->down;\\n                temp=temp->down;\\n            }\\n            else return temp;\\n        }\\n    }\\n}\\n\\ninline int rand_toss(){\\n    return rand()%2;\\n}\\n\\nvoid print_skipy(Node* head){\\n    Node* sentinel=head;\\n    while(sentinel){\\n        Node* temp=sentinel;\\n        while(temp) {\\n            cout<<temp->val<<\" \";\\n            temp=temp->right;\\n        }\\n        cout<<endl;\\n        sentinel=sentinel->down;\\n    }\\n}\\n\\nNode* del(Node*& temp){\\n    Node* u=temp->up;\\n    Node* l=temp->left;\\n    Node* r=temp->right;\\n    temp->left=NULL;\\n    temp->right=NULL;\\n    temp->up=NULL;\\n    l->right=r;\\n    if(r) r->left=l;\\n    return u;\\n}\\n\\nvoid reach_bottom(Node* &sentinel,Node*& temp){\\n    while(temp->down){\\n        sentinel=sentinel->down;\\n        temp=temp->down;\\n    }\\n}\\n\\nclass Skiplist {\\npublic:\\nNode* top_head_sentinel=NULL;\\n    Skiplist() {\\n       srand(time(0)); \\n       top_head_sentinel=new Node();\\n    }\\n    \\n    bool search(int target) {\\n        Node* sentinel=top_head_sentinel;\\n        Node* temp=skip_search(top_head_sentinel,target,sentinel);\\n        return (temp->val==target);\\n    }\\n    \\n    void add(int num) {\\n        Node* sentinel=top_head_sentinel;\\n        Node* temp=skip_search(top_head_sentinel,num,sentinel);\\n        if(temp->val==num){\\n            reach_bottom(sentinel,temp);\\n            while(temp){\\n                temp->count++;\\n                temp=temp->up;\\n                sentinel=sentinel->up;\\n            }\\n            return;\\n        }\\n        Node* new_node=new Node(num);\\n        new_node->left=temp;\\n        new_node->right=temp->right;\\n        if(temp->right) temp->right->left=new_node;\\n        temp->right=new_node;\\n        while(rand_toss()){\\n            Node* up_l;\\n            Node* up_r;\\n            Node* n;\\n            if(temp->up){\\n                up_l=temp->up;\\n            }\\n            else if(sentinel->up){\\n                up_l=find_up_l(sentinel->up,num);\\n            }\\n            else{\\n                Node* x=new Node();\\n                top_head_sentinel->up=x;\\n                x->down=top_head_sentinel;\\n                top_head_sentinel=x;\\n\\n                up_l=top_head_sentinel;\\n            }\\n            up_r=up_l->right;\\n            n=new_node;\\n            new_node=promotion(up_l,up_r,n);\\n            temp=up_l;\\n            sentinel=sentinel->up;\\n        }\\n        // print_skipy(top_head_sentinel);\\n        // cout<<endl;\\n    }\\n    \\n    bool erase(int num) {\\n        Node* sentinel=top_head_sentinel;\\n        Node* temp=skip_search(top_head_sentinel,num,sentinel);\\n        if(temp->val!=num) return false;\\n        reach_bottom(sentinel,temp);\\n        if(temp->count>1){\\n            while(temp){\\n                temp->count--;\\n                temp=temp->up;\\n                sentinel=sentinel->up;\\n            }\\n            return true;\\n        }\\n        while(temp){\\n            temp=del(temp);\\n            if(temp) sentinel=sentinel->up;\\n        }\\n        // print_skipy(top_head_sentinel);\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct Node{\\n    int val=INT_MIN;\\n    int count=-1;\\n    Node* left=NULL;\\n    Node* right=NULL;\\n    Node* up=NULL;\\n    Node* down=NULL;\\n    Node(){\\n        count=1;\\n    }\\n    Node(int value):val(value),count(1){}\\n};\\n\\nNode* find_up_l(Node* sentinel,int value){\\n    Node* temp=sentinel;\\n    while(temp->right && temp->right->val<=value) temp=temp->right;\\n    return temp;\\n}\\n\\nNode* promotion(Node*& up_l,Node*& up_r,Node*& n){\\n    Node* new_node=new Node(n->val);\\n    new_node->down=n;\\n    new_node->left=up_l;\\n    new_node->right=up_r;\\n    up_l->right=new_node;\\n    n->up=new_node;\\n    if(up_r) up_r->left=new_node;\\n    return new_node;\\n}\\n\\nNode* skip_search(Node* top_head_s,int target,Node* &sentinel){\\n    Node* temp=top_head_s;\\n    while(true){\\n        if(temp->val==target) return temp;\\n        if(temp->right && temp->right->val<=target){\\n            temp=temp->right;\\n        }\\n        else{\\n            if(temp->down){ \\n                sentinel=sentinel->down;\\n                temp=temp->down;\\n            }\\n            else return temp;\\n        }\\n    }\\n}\\n\\ninline int rand_toss(){\\n    return rand()%2;\\n}\\n\\nvoid print_skipy(Node* head){\\n    Node* sentinel=head;\\n    while(sentinel){\\n        Node* temp=sentinel;\\n        while(temp) {\\n            cout<<temp->val<<\" \";\\n            temp=temp->right;\\n        }\\n        cout<<endl;\\n        sentinel=sentinel->down;\\n    }\\n}\\n\\nNode* del(Node*& temp){\\n    Node* u=temp->up;\\n    Node* l=temp->left;\\n    Node* r=temp->right;\\n    temp->left=NULL;\\n    temp->right=NULL;\\n    temp->up=NULL;\\n    l->right=r;\\n    if(r) r->left=l;\\n    return u;\\n}\\n\\nvoid reach_bottom(Node* &sentinel,Node*& temp){\\n    while(temp->down){\\n        sentinel=sentinel->down;\\n        temp=temp->down;\\n    }\\n}\\n\\nclass Skiplist {\\npublic:\\nNode* top_head_sentinel=NULL;\\n    Skiplist() {\\n       srand(time(0)); \\n       top_head_sentinel=new Node();\\n    }\\n    \\n    bool search(int target) {\\n        Node* sentinel=top_head_sentinel;\\n        Node* temp=skip_search(top_head_sentinel,target,sentinel);\\n        return (temp->val==target);\\n    }\\n    \\n    void add(int num) {\\n        Node* sentinel=top_head_sentinel;\\n        Node* temp=skip_search(top_head_sentinel,num,sentinel);\\n        if(temp->val==num){\\n            reach_bottom(sentinel,temp);\\n            while(temp){\\n                temp->count++;\\n                temp=temp->up;\\n                sentinel=sentinel->up;\\n            }\\n            return;\\n        }\\n        Node* new_node=new Node(num);\\n        new_node->left=temp;\\n        new_node->right=temp->right;\\n        if(temp->right) temp->right->left=new_node;\\n        temp->right=new_node;\\n        while(rand_toss()){\\n            Node* up_l;\\n            Node* up_r;\\n            Node* n;\\n            if(temp->up){\\n                up_l=temp->up;\\n            }\\n            else if(sentinel->up){\\n                up_l=find_up_l(sentinel->up,num);\\n            }\\n            else{\\n                Node* x=new Node();\\n                top_head_sentinel->up=x;\\n                x->down=top_head_sentinel;\\n                top_head_sentinel=x;\\n\\n                up_l=top_head_sentinel;\\n            }\\n            up_r=up_l->right;\\n            n=new_node;\\n            new_node=promotion(up_l,up_r,n);\\n            temp=up_l;\\n            sentinel=sentinel->up;\\n        }\\n        // print_skipy(top_head_sentinel);\\n        // cout<<endl;\\n    }\\n    \\n    bool erase(int num) {\\n        Node* sentinel=top_head_sentinel;\\n        Node* temp=skip_search(top_head_sentinel,num,sentinel);\\n        if(temp->val!=num) return false;\\n        reach_bottom(sentinel,temp);\\n        if(temp->count>1){\\n            while(temp){\\n                temp->count--;\\n                temp=temp->up;\\n                sentinel=sentinel->up;\\n            }\\n            return true;\\n        }\\n        while(temp){\\n            temp=del(temp);\\n            if(temp) sentinel=sentinel->up;\\n        }\\n        // print_skipy(top_head_sentinel);\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3251032,
                "title": "java-possible-fastest-solution",
                "content": "- In this code, the Skiplist class implements a SkipList data structure, which is a randomized data structure that allows for efficient searching, insertion, and deletion of elements in a sorted list.\\n\\n- The SkipList is implemented as a series of linked lists, where each list contains a subset of the elements in the overall list. Each element in the SkipList is represented by a Node object, which contains a value and an array of pointers to the next Node object at each level of the SkipList.\\n\\n- The search, add, and erase methods are used to search for, insert, and delete elements in the SkipList, respectively. The randomLevel method is a helper function that generates a random level for a new Node object to be inserted into the SkipList.\\n\\n- The runtime of the SkipList data structure is O(log n).\\n# Code\\n```\\nimport java.util.*;\\nclass Skiplist {\\n    private static final int MAX_LEVEL = 16;\\n    private Node head;\\n    private int level;\\n\\n    private static class Node {\\n        int val;\\n        Node[] next;\\n\\n        public Node(int val, int level) {\\n            this.val = val;\\n            this.next = new Node[level];\\n        }\\n    }\\n\\n    public Skiplist() {\\n        this.head = new Node(-1, MAX_LEVEL);\\n        this.level = 1;\\n    }\\n\\n    public boolean search(int target) {\\n        Node curr = head;\\n        for (int i = level - 1; i >= 0; i--) {\\n            while (curr.next[i] != null && curr.next[i].val < target) {\\n                curr = curr.next[i];\\n            }\\n        }\\n        return curr.next[0] != null && curr.next[0].val == target;\\n    }\\n\\n    public void add(int num) {\\n        int newLevel = randomLevel();\\n        Node newNode = new Node(num, newLevel);\\n        Node curr = head;\\n\\n        // track nodes at each level where the new node should be inserted\\n        Node[] update = new Node[newLevel];\\n        Arrays.fill(update, head);\\n\\n        for (int i = level - 1; i >= 0; i--) {\\n            while (curr.next[i] != null && curr.next[i].val < num) {\\n                curr = curr.next[i];\\n            }\\n            if (i < newLevel) {\\n                update[i] = curr;\\n            }\\n        }\\n\\n        // insert new node at each level\\n        for (int i = 0; i < newLevel; i++) {\\n            newNode.next[i] = update[i].next[i];\\n            update[i].next[i] = newNode;\\n        }\\n\\n        // update level if necessary\\n        level = Math.max(level, newLevel);\\n    }\\n\\n    public boolean erase(int num) {\\n        Node curr = head;\\n        boolean found = false;\\n        for (int i = level - 1; i >= 0; i--) {\\n            while (curr.next[i] != null && curr.next[i].val < num) {\\n                curr = curr.next[i];\\n            }\\n            if (curr.next[i] != null && curr.next[i].val == num) {\\n                found = true;\\n                curr.next[i] = curr.next[i].next[i];\\n            }\\n        }\\n        return found;\\n    }\\n\\n    // helper function to generate a random level for a new node\\n    private int randomLevel() {\\n        int level = 1;\\n        while (level < MAX_LEVEL && Math.random() < 0.5) {\\n            level++;\\n        }\\n        return level;\\n    }\\n}\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist obj = new Skiplist();\\n * boolean param_1 = obj.search(target);\\n * obj.add(num);\\n * boolean param_3 = obj.erase(num);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Design"
                ],
                "code": "```\\nimport java.util.*;\\nclass Skiplist {\\n    private static final int MAX_LEVEL = 16;\\n    private Node head;\\n    private int level;\\n\\n    private static class Node {\\n        int val;\\n        Node[] next;\\n\\n        public Node(int val, int level) {\\n            this.val = val;\\n            this.next = new Node[level];\\n        }\\n    }\\n\\n    public Skiplist() {\\n        this.head = new Node(-1, MAX_LEVEL);\\n        this.level = 1;\\n    }\\n\\n    public boolean search(int target) {\\n        Node curr = head;\\n        for (int i = level - 1; i >= 0; i--) {\\n            while (curr.next[i] != null && curr.next[i].val < target) {\\n                curr = curr.next[i];\\n            }\\n        }\\n        return curr.next[0] != null && curr.next[0].val == target;\\n    }\\n\\n    public void add(int num) {\\n        int newLevel = randomLevel();\\n        Node newNode = new Node(num, newLevel);\\n        Node curr = head;\\n\\n        // track nodes at each level where the new node should be inserted\\n        Node[] update = new Node[newLevel];\\n        Arrays.fill(update, head);\\n\\n        for (int i = level - 1; i >= 0; i--) {\\n            while (curr.next[i] != null && curr.next[i].val < num) {\\n                curr = curr.next[i];\\n            }\\n            if (i < newLevel) {\\n                update[i] = curr;\\n            }\\n        }\\n\\n        // insert new node at each level\\n        for (int i = 0; i < newLevel; i++) {\\n            newNode.next[i] = update[i].next[i];\\n            update[i].next[i] = newNode;\\n        }\\n\\n        // update level if necessary\\n        level = Math.max(level, newLevel);\\n    }\\n\\n    public boolean erase(int num) {\\n        Node curr = head;\\n        boolean found = false;\\n        for (int i = level - 1; i >= 0; i--) {\\n            while (curr.next[i] != null && curr.next[i].val < num) {\\n                curr = curr.next[i];\\n            }\\n            if (curr.next[i] != null && curr.next[i].val == num) {\\n                found = true;\\n                curr.next[i] = curr.next[i].next[i];\\n            }\\n        }\\n        return found;\\n    }\\n\\n    // helper function to generate a random level for a new node\\n    private int randomLevel() {\\n        int level = 1;\\n        while (level < MAX_LEVEL && Math.random() < 0.5) {\\n            level++;\\n        }\\n        return level;\\n    }\\n}\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist obj = new Skiplist();\\n * boolean param_1 = obj.search(target);\\n * obj.add(num);\\n * boolean param_3 = obj.erase(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231790,
                "title": "typescript-solution-with-map-beats-100",
                "content": "# Code\\n```\\nclass Skiplist {\\n  private readonly list = new Map<number, number>();\\n  search(target: number): boolean {\\n    return this.list.has(target);\\n  }\\n\\n  add(num: number): void {\\n    const existing = this.list.get(num) ?? 0;\\n    this.list.set(num, existing + 1);\\n  }\\n\\n  erase(num: number): boolean {\\n    const existing = this.list.get(num);\\n    if (!existing) {\\n      return false;\\n    }\\n\\n    if (existing === 1) {\\n      this.list.delete(num);\\n    } else {\\n      this.list.set(num, existing - 1);\\n    }\\n\\n    return true;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass Skiplist {\\n  private readonly list = new Map<number, number>();\\n  search(target: number): boolean {\\n    return this.list.has(target);\\n  }\\n\\n  add(num: number): void {\\n    const existing = this.list.get(num) ?? 0;\\n    this.list.set(num, existing + 1);\\n  }\\n\\n  erase(num: number): boolean {\\n    const existing = this.list.get(num);\\n    if (!existing) {\\n      return false;\\n    }\\n\\n    if (existing === 1) {\\n      this.list.delete(num);\\n    } else {\\n      this.list.set(num, existing - 1);\\n    }\\n\\n    return true;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223982,
                "title": "python-solution-with-list-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Honestly, this is nothing different to making a regular list.\\n    I thought of using the in keyword for the search method of the Skiplist class. \\n    Then, I decided to use the list.remove and list.append functions when adding or erasing a value.\\n    \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Step 1: In __init__, create a self.list = []\\n    Step 2: In the search method, write an if statement for if a target is in self.list\\n    Step 2.5: If the target is, then return True. Else return false.\\n    Step 3: In the add method, append the number to self.list\\n    Step 4: In the erase method, write an if statement to check if num is in self.list\\n    Step 4.5: If so, return True and remove the num from self.list. Else return false.\\n    Step 5: Run the program!!!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(1) \\n# Code\\n```\\nclass Skiplist:\\n\\n    def __init__(self):\\n        self.list = []\\n\\n    def search(self, target: int) -> bool:\\n        if target in self.list:\\n            return True\\n        else:\\n            return False\\n\\n    def add(self, num: int) -> None:\\n        self.list.append(num)\\n\\n    def erase(self, num: int) -> bool:\\n        if num in self.list:\\n            self.list.remove(num)\\n            return True\\n        else: \\n            return False\\n\\n\\n# Your Skiplist object will be instantiated and called as such:\\n# obj = Skiplist()\\n# param_1 = obj.search(target)\\n# obj.add(num)\\n# param_3 = obj.erase(num)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Skiplist:\\n\\n    def __init__(self):\\n        self.list = []\\n\\n    def search(self, target: int) -> bool:\\n        if target in self.list:\\n            return True\\n        else:\\n            return False\\n\\n    def add(self, num: int) -> None:\\n        self.list.append(num)\\n\\n    def erase(self, num: int) -> bool:\\n        if num in self.list:\\n            self.list.remove(num)\\n            return True\\n        else: \\n            return False\\n\\n\\n# Your Skiplist object will be instantiated and called as such:\\n# obj = Skiplist()\\n# param_1 = obj.search(target)\\n# obj.add(num)\\n# param_3 = obj.erase(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221412,
                "title": "simple-python",
                "content": "```\\nfrom random import random\\n\\nclass Node:\\n    def __init__(self, val, nxt, down):\\n        self.val = val\\n        self.next = nxt\\n        self.down = down\\n\\nclass Skiplist:\\n    def __init__(self):\\n        n = None\\n        \\n        for i in range(8):\\n            n = Node(-inf, Node(inf, None, None), n)\\n        \\n        self.root = n\\n\\n    def __path(self, target):\\n        n = self.root\\n        s = []\\n        \\n        while n.down:\\n            n = n.down\\n            while n.next.val < target:\\n                n = n.next\\n            s.append(n)\\n        \\n        return s\\n\\n    def search(self, target: int) -> bool:\\n        s = self.__path(target)\\n        return s[-1].next.val == target\\n\\n    def add(self, num: int) -> None:\\n        s = self.__path(num)\\n        down = None\\n        \\n        for n in reversed(s):\\n            down = Node(num, n.next, down)\\n            n.next = down\\n            if random() > 0.25:\\n                break\\n        \\n    def erase(self, num: int) -> bool:\\n        s = self.__path(num)\\n\\n        if s[-1].next.val != num:\\n            return False\\n                    \\n        for n in s:\\n            if n.next.val == num:\\n                n.next = n.next.next\\n                \\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom random import random\\n\\nclass Node:\\n    def __init__(self, val, nxt, down):\\n        self.val = val\\n        self.next = nxt\\n        self.down = down\\n\\nclass Skiplist:\\n    def __init__(self):\\n        n = None\\n        \\n        for i in range(8):\\n            n = Node(-inf, Node(inf, None, None), n)\\n        \\n        self.root = n\\n\\n    def __path(self, target):\\n        n = self.root\\n        s = []\\n        \\n        while n.down:\\n            n = n.down\\n            while n.next.val < target:\\n                n = n.next\\n            s.append(n)\\n        \\n        return s\\n\\n    def search(self, target: int) -> bool:\\n        s = self.__path(target)\\n        return s[-1].next.val == target\\n\\n    def add(self, num: int) -> None:\\n        s = self.__path(num)\\n        down = None\\n        \\n        for n in reversed(s):\\n            down = Node(num, n.next, down)\\n            n.next = down\\n            if random() > 0.25:\\n                break\\n        \\n    def erase(self, num: int) -> bool:\\n        s = self.__path(num)\\n\\n        if s[-1].next.val != num:\\n            return False\\n                    \\n        for n in s:\\n            if n.next.val == num:\\n                n.next = n.next.next\\n                \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194384,
                "title": "map-easy-c-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Skiplist {\\npublic:\\n    map<int, int> mp;\\n    Skiplist() {\\n        \\n    }\\n    \\n    bool search(int target) {\\n        return mp.find(target)!=mp.end();\\n    }\\n    \\n    void add(int num) {\\n        mp[num]++;\\n    }\\n    \\n    bool erase(int num) {\\n       if(mp.find(num)==mp.end())return false;\\n        else {\\n            mp[num]--;\\n            if(mp[num]==0)mp.erase(mp.find(num));\\n        }\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Skiplist {\\npublic:\\n    map<int, int> mp;\\n    Skiplist() {\\n        \\n    }\\n    \\n    bool search(int target) {\\n        return mp.find(target)!=mp.end();\\n    }\\n    \\n    void add(int num) {\\n        mp[num]++;\\n    }\\n    \\n    bool erase(int num) {\\n       if(mp.find(num)==mp.end())return false;\\n        else {\\n            mp[num]--;\\n            if(mp[num]==0)mp.erase(mp.find(num));\\n        }\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159254,
                "title": "c-very-easy-solution-using-map",
                "content": "\\n# Code\\n```\\nclass Skiplist {\\npublic:\\n    Skiplist() {}\\n    map<int,int> m;\\n    bool search(int target) {\\n        if(m[target]>0) return true;\\n        return false;\\n    }\\n    \\n    void add(int num) {\\n        m[num]++;\\n    }\\n    \\n    bool erase(int num) {\\n        if(m[num]>0){\\n            m[num]--;\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Skiplist {\\npublic:\\n    Skiplist() {}\\n    map<int,int> m;\\n    bool search(int target) {\\n        if(m[target]>0) return true;\\n        return false;\\n    }\\n    \\n    void add(int num) {\\n        m[num]++;\\n    }\\n    \\n    bool erase(int num) {\\n        if(m[num]>0){\\n            m[num]--;\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3121700,
                "title": "java-record-the-search-path",
                "content": "```\\nclass Skiplist {\\n    private static final int MAX_LEVEL = 33;\\n    class Node {\\n        int val;\\n        Node[] next;\\n        Node (int val) {\\n            this.val = val;\\n            next = new Node[MAX_LEVEL];\\n        }\\n    }\\n    \\n    private Node head;\\n    private Node[] searchPath;\\n    private Random random;\\n    \\n    public Skiplist() {\\n        head = new Node(Integer.MIN_VALUE);    \\n        searchPath = new Node[MAX_LEVEL];\\n        random = new Random();\\n    }\\n    \\n    private Node findNode(int target) {\\n        Node cur = head;\\n        for (int level = MAX_LEVEL - 1; level >= 0; level--) {\\n            while (cur.next[level] != null && cur.next[level].val < target) {\\n                cur = cur.next[level];\\n            }\\n            searchPath[level] = cur; // add the last node\\n        }\\n        return cur;\\n    }\\n    \\n    public boolean search(int target) {\\n        Node targetNode = findNode(target).next[0];\\n        if (targetNode == null) return false;\\n        return targetNode.val == target;\\n    }\\n    \\n    private int getRandomLevel() {\\n        int level = 0;\\n        while (random.nextBoolean() && level < MAX_LEVEL - 1) level++; \\n        return level;\\n    }\\n    \\n    public void add(int num) {\\n        Node prevNode = findNode(num);\\n        Node newNode = new Node(num);\\n        int level = getRandomLevel();\\n        for (int i = 0; i <= level; i++) {\\n            newNode.next[i] = searchPath[i].next[i];\\n            searchPath[i].next[i] = newNode;\\n        }\\n    }\\n    \\n    public boolean erase(int num) {\\n        Node cur = findNode(num).next[0];\\n        if (cur == null || cur.val != num) return false;\\n        for (int i = 0; i < MAX_LEVEL; i++) {\\n            if (searchPath[i].next[i] != null) searchPath[i].next[i] = searchPath[i].next[i].next[i];\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Skiplist {\\n    private static final int MAX_LEVEL = 33;\\n    class Node {\\n        int val;\\n        Node[] next;\\n        Node (int val) {\\n            this.val = val;\\n            next = new Node[MAX_LEVEL];\\n        }\\n    }\\n    \\n    private Node head;\\n    private Node[] searchPath;\\n    private Random random;\\n    \\n    public Skiplist() {\\n        head = new Node(Integer.MIN_VALUE);    \\n        searchPath = new Node[MAX_LEVEL];\\n        random = new Random();\\n    }\\n    \\n    private Node findNode(int target) {\\n        Node cur = head;\\n        for (int level = MAX_LEVEL - 1; level >= 0; level--) {\\n            while (cur.next[level] != null && cur.next[level].val < target) {\\n                cur = cur.next[level];\\n            }\\n            searchPath[level] = cur; // add the last node\\n        }\\n        return cur;\\n    }\\n    \\n    public boolean search(int target) {\\n        Node targetNode = findNode(target).next[0];\\n        if (targetNode == null) return false;\\n        return targetNode.val == target;\\n    }\\n    \\n    private int getRandomLevel() {\\n        int level = 0;\\n        while (random.nextBoolean() && level < MAX_LEVEL - 1) level++; \\n        return level;\\n    }\\n    \\n    public void add(int num) {\\n        Node prevNode = findNode(num);\\n        Node newNode = new Node(num);\\n        int level = getRandomLevel();\\n        for (int i = 0; i <= level; i++) {\\n            newNode.next[i] = searchPath[i].next[i];\\n            searchPath[i].next[i] = newNode;\\n        }\\n    }\\n    \\n    public boolean erase(int num) {\\n        Node cur = findNode(num).next[0];\\n        if (cur == null || cur.val != num) return false;\\n        for (int i = 0; i < MAX_LEVEL; i++) {\\n            if (searchPath[i].next[i] != null) searchPath[i].next[i] = searchPath[i].next[i].next[i];\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084955,
                "title": "on-time-on-space-0ms-my-fastest-solution-explained",
                "content": "\\n```\\nclass Skiplist {\\n    static final int MAX_LEVEL = 16;\\n    static final double P = 0.5;\\n    static final Node sentinel = new Node(0, Integer.MAX_VALUE);\\n    \\n    static class Node {\\n        Node[] forward; // 0-indexed level-wise pointer array\\n        int key;\\n        int value;\\n        \\n        Node(int level, int key) {\\n            forward = new Node[level];\\n            this.key = key;\\n            this.value = 1;\\n        }\\n    }\\n    \\n    Node header;\\n    int listLevel;\\n\\n    public Skiplist() {\\n        header = new Node(MAX_LEVEL, -1);\\n        Arrays.fill(header.forward, sentinel);\\n        listLevel = 1;\\n    }\\n    \\n    public boolean search(int target) {\\n        Node cur = header;\\n        for (int i = listLevel - 1; i >= 0; --i) {\\n            while (cur.forward[i].key < target) {\\n                cur = cur.forward[i];\\n            }\\n        }\\n        return cur.forward[0].key == target;\\n    }\\n    \\n    public void add(int num) {\\n        Node[] update = getPredecessors(num);\\n        Node cur = update[0].forward[0];\\n        \\n        if (cur.key == num) {\\n            ++cur.value;\\n        } else {\\n            int level = randomLevel();\\n            if (level > listLevel) {\\n                for (int i = listLevel; i < level; ++i) {\\n                    update[i] = header;\\n                }\\n                listLevel = level;\\n            }\\n            cur = new Node(level, num);\\n            for (int i = 0; i < level; ++i) {\\n                cur.forward[i] = update[i].forward[i];\\n                update[i].forward[i] = cur;\\n            }\\n        }\\n    }\\n    \\n    public boolean erase(int num) {\\n        Node[] update = getPredecessors(num);\\n        Node cur = update[0].forward[0];\\n        if (cur.key != num) {\\n            return false;\\n        } else {\\n            if (cur.value > 1) {\\n                --cur.value;\\n            } else {\\n                for (int i = 0; i < listLevel; ++i) {\\n                    if (update[i].forward[i] != cur) {\\n                        break;\\n                    }\\n                    update[i].forward[i] = cur.forward[i];\\n                }\\n                while (listLevel > 1 && header.forward[listLevel - 1] == sentinel) {\\n                    --listLevel;\\n                }\\n            }\\n            return true;\\n        }\\n    }\\n    \\n    private Node[] getPredecessors(int target) {\\n        Node[] update = new Node[MAX_LEVEL];\\n        Node cur = header;\\n        for (int i = listLevel - 1; i >= 0; --i) {\\n            while (cur.forward[i].key < target) {\\n                cur = cur.forward[i];\\n            }\\n            update[i] = cur;\\n        }\\n        return update;\\n    }\\n    \\n    private int randomLevel() {\\n        int level = 1;\\n        while (Math.random() < P && level < Math.min(MAX_LEVEL, listLevel + 1)) {\\n            ++level;\\n        }\\n        return level;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Skiplist {\\n    static final int MAX_LEVEL = 16;\\n    static final double P = 0.5;\\n    static final Node sentinel = new Node(0, Integer.MAX_VALUE);\\n    \\n    static class Node {\\n        Node[] forward; // 0-indexed level-wise pointer array\\n        int key;\\n        int value;\\n        \\n        Node(int level, int key) {\\n            forward = new Node[level];\\n            this.key = key;\\n            this.value = 1;\\n        }\\n    }\\n    \\n    Node header;\\n    int listLevel;\\n\\n    public Skiplist() {\\n        header = new Node(MAX_LEVEL, -1);\\n        Arrays.fill(header.forward, sentinel);\\n        listLevel = 1;\\n    }\\n    \\n    public boolean search(int target) {\\n        Node cur = header;\\n        for (int i = listLevel - 1; i >= 0; --i) {\\n            while (cur.forward[i].key < target) {\\n                cur = cur.forward[i];\\n            }\\n        }\\n        return cur.forward[0].key == target;\\n    }\\n    \\n    public void add(int num) {\\n        Node[] update = getPredecessors(num);\\n        Node cur = update[0].forward[0];\\n        \\n        if (cur.key == num) {\\n            ++cur.value;\\n        } else {\\n            int level = randomLevel();\\n            if (level > listLevel) {\\n                for (int i = listLevel; i < level; ++i) {\\n                    update[i] = header;\\n                }\\n                listLevel = level;\\n            }\\n            cur = new Node(level, num);\\n            for (int i = 0; i < level; ++i) {\\n                cur.forward[i] = update[i].forward[i];\\n                update[i].forward[i] = cur;\\n            }\\n        }\\n    }\\n    \\n    public boolean erase(int num) {\\n        Node[] update = getPredecessors(num);\\n        Node cur = update[0].forward[0];\\n        if (cur.key != num) {\\n            return false;\\n        } else {\\n            if (cur.value > 1) {\\n                --cur.value;\\n            } else {\\n                for (int i = 0; i < listLevel; ++i) {\\n                    if (update[i].forward[i] != cur) {\\n                        break;\\n                    }\\n                    update[i].forward[i] = cur.forward[i];\\n                }\\n                while (listLevel > 1 && header.forward[listLevel - 1] == sentinel) {\\n                    --listLevel;\\n                }\\n            }\\n            return true;\\n        }\\n    }\\n    \\n    private Node[] getPredecessors(int target) {\\n        Node[] update = new Node[MAX_LEVEL];\\n        Node cur = header;\\n        for (int i = listLevel - 1; i >= 0; --i) {\\n            while (cur.forward[i].key < target) {\\n                cur = cur.forward[i];\\n            }\\n            update[i] = cur;\\n        }\\n        return update;\\n    }\\n    \\n    private int randomLevel() {\\n        int level = 1;\\n        while (Math.random() < P && level < Math.min(MAX_LEVEL, listLevel + 1)) {\\n            ++level;\\n        }\\n        return level;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067574,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nuse rand::Rng;\\nuse std::{cell::RefCell, rc::Rc, vec};\\n\\nconst MAX_LEVEL: usize = 32;\\nconst P_FACTOR: f64 = 0.25;\\n\\ntype Link = Option<Rc<RefCell<Node>>>;\\n\\nfn new_link(value: i32, level: usize) -> Link {\\n    Some(Rc::new(RefCell::new(Node::new(value, level))))\\n}\\n\\nfn random_level() -> usize {\\n    let mut level = 1;\\n    let mut rng = rand::thread_rng();\\n    while level < MAX_LEVEL && rng.gen::<f64>() < P_FACTOR {\\n        level += 1;\\n    }\\n    level\\n}\\n\\n#[derive(Debug, Default)]\\npub struct Node {\\n    val: i32,\\n    level: usize,\\n    forward: Vec<Link>,\\n}\\n\\nimpl PartialEq for Node {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.val == other.val && self.forward.len() == other.forward.len()\\n    }\\n}\\n\\nimpl Node {\\n    pub fn new(value: i32, level: usize) -> Node {\\n        Node {\\n            val: value,\\n            level,\\n            forward: vec![None; level],\\n        }\\n    }\\n}\\n\\n#[derive(Debug, Default)]\\npub struct Skiplist {\\n    head: Link,\\n    level: usize,\\n}\\n\\nimpl Skiplist {\\n    pub fn new() -> Self {\\n        Skiplist {\\n            head: new_link(-1, MAX_LEVEL),\\n            ..Default::default()\\n        }\\n    }\\n\\n    pub fn search(&self, target: i32) -> bool {\\n        self._search(target).unwrap_or(false)\\n    }\\n    fn _search(&self, target: i32) -> Option<bool> {\\n        let mut cur = self.head.clone();\\n        for i in (0..self.level).rev() {\\n            loop {\\n                let node = cur.as_ref()?.borrow().forward[i].clone();\\n                match node {\\n                    node @ Some(_) => {\\n                        if node.as_ref()?.borrow().val < target {\\n                            cur = node;\\n                            continue;\\n                        }\\n                        break;\\n                    }\\n                    None => break,\\n                }\\n            }\\n        }\\n        let node = cur.as_ref()?.borrow().forward[0].clone();\\n        match node {\\n            Some(node) => {\\n                if node.borrow().val == target {\\n                    return Some(true);\\n                }\\n                Some(false)\\n            }\\n            None => Some(false),\\n        }\\n    }\\n\\n    pub fn add(&mut self, num: i32) {\\n        let mut cur = self.head.clone().unwrap();\\n        let mut update = vec![Some(cur.clone()); MAX_LEVEL];\\n        for i in (0..self.level).rev() {\\n            while let Some(node) = cur.clone().borrow().forward[i].clone() {\\n                if node.borrow().val < num {\\n                    cur = node;\\n                    continue;\\n                }\\n                break;\\n            }\\n            update[i] = Some(cur.clone());\\n        }\\n        let level = random_level();\\n        self.level = self.level.max(level);\\n        let node = new_link(num, level);\\n        for (i, item) in update.iter().enumerate().take(level) {\\n            node.as_ref().unwrap().borrow_mut().forward[i] = item.as_ref().unwrap().borrow().forward[i].clone();\\n            item.as_ref().unwrap().borrow_mut().forward[i] = node.clone();\\n        }\\n    }\\n\\n    pub fn erase(&mut self, num: i32) -> bool {\\n        self._erase(num).unwrap_or(false)\\n    }\\n    fn _erase(&mut self, num: i32) -> Option<bool> {\\n        let mut cur = self.head.clone();\\n        let mut update: Vec<Link> = vec![None; MAX_LEVEL];\\n        for i in (0..self.level).rev() {\\n            loop {\\n                let node = cur.as_ref()?.borrow().forward[i].clone();\\n                match node {\\n                    node @ Some(_) => {\\n                        if node.as_ref()?.borrow().val < num {\\n                            cur = node;\\n                            continue;\\n                        }\\n                        break;\\n                    }\\n                    None => break,\\n                }\\n            }\\n            update[i] = cur.clone();\\n        }\\n        let cur = cur.as_ref()?.borrow().forward[0].clone();\\n        match cur.clone() {\\n            Some(node) => {\\n                if node.borrow().val != num {\\n                    return Some(false);\\n                }\\n            }\\n            None => return Some(false),\\n        };\\n\\n        for (i, item) in update.iter().enumerate().take(self.level) {\\n            if item.clone().unwrap().borrow().forward[i] != cur.clone() {\\n                break;\\n            }\\n            item.clone().unwrap().borrow_mut().forward[i] = cur.clone().unwrap().borrow().forward[i].clone();\\n        }\\n        while self.level > 1 && self.head.clone().unwrap().borrow().forward[self.level - 1].is_none() {\\n            self.level -= 1;\\n        }\\n\\n        Some(true)\\n    }\\n\\n    pub fn debug(&self) {\\n        let head = self.head.clone().unwrap();\\n        let mut table: Vec<Vec<(i32, usize, usize)>> =\\n            vec![vec![(head.borrow().val, head.borrow().level, head.borrow().forward.len())]; self.level];\\n\\n        for i in (0..self.level).rev() {\\n            let mut node = head.clone();\\n            while let Some(tmp) = node.clone().borrow().forward[i].clone() {\\n                table[i].push((tmp.borrow().val, tmp.borrow().level, tmp.borrow().forward.len()));\\n                node = tmp;\\n            }\\n        }\\n        for t in table.iter().rev() {\\n            println!(\"{:?}\", t);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse rand::Rng;\\nuse std::{cell::RefCell, rc::Rc, vec};\\n\\nconst MAX_LEVEL: usize = 32;\\nconst P_FACTOR: f64 = 0.25;\\n\\ntype Link = Option<Rc<RefCell<Node>>>;\\n\\nfn new_link(value: i32, level: usize) -> Link {\\n    Some(Rc::new(RefCell::new(Node::new(value, level))))\\n}\\n\\nfn random_level() -> usize {\\n    let mut level = 1;\\n    let mut rng = rand::thread_rng();\\n    while level < MAX_LEVEL && rng.gen::<f64>() < P_FACTOR {\\n        level += 1;\\n    }\\n    level\\n}\\n\\n#[derive(Debug, Default)]\\npub struct Node {\\n    val: i32,\\n    level: usize,\\n    forward: Vec<Link>,\\n}\\n\\nimpl PartialEq for Node {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.val == other.val && self.forward.len() == other.forward.len()\\n    }\\n}\\n\\nimpl Node {\\n    pub fn new(value: i32, level: usize) -> Node {\\n        Node {\\n            val: value,\\n            level,\\n            forward: vec![None; level],\\n        }\\n    }\\n}\\n\\n#[derive(Debug, Default)]\\npub struct Skiplist {\\n    head: Link,\\n    level: usize,\\n}\\n\\nimpl Skiplist {\\n    pub fn new() -> Self {\\n        Skiplist {\\n            head: new_link(-1, MAX_LEVEL),\\n            ..Default::default()\\n        }\\n    }\\n\\n    pub fn search(&self, target: i32) -> bool {\\n        self._search(target).unwrap_or(false)\\n    }\\n    fn _search(&self, target: i32) -> Option<bool> {\\n        let mut cur = self.head.clone();\\n        for i in (0..self.level).rev() {\\n            loop {\\n                let node = cur.as_ref()?.borrow().forward[i].clone();\\n                match node {\\n                    node @ Some(_) => {\\n                        if node.as_ref()?.borrow().val < target {\\n                            cur = node;\\n                            continue;\\n                        }\\n                        break;\\n                    }\\n                    None => break,\\n                }\\n            }\\n        }\\n        let node = cur.as_ref()?.borrow().forward[0].clone();\\n        match node {\\n            Some(node) => {\\n                if node.borrow().val == target {\\n                    return Some(true);\\n                }\\n                Some(false)\\n            }\\n            None => Some(false),\\n        }\\n    }\\n\\n    pub fn add(&mut self, num: i32) {\\n        let mut cur = self.head.clone().unwrap();\\n        let mut update = vec![Some(cur.clone()); MAX_LEVEL];\\n        for i in (0..self.level).rev() {\\n            while let Some(node) = cur.clone().borrow().forward[i].clone() {\\n                if node.borrow().val < num {\\n                    cur = node;\\n                    continue;\\n                }\\n                break;\\n            }\\n            update[i] = Some(cur.clone());\\n        }\\n        let level = random_level();\\n        self.level = self.level.max(level);\\n        let node = new_link(num, level);\\n        for (i, item) in update.iter().enumerate().take(level) {\\n            node.as_ref().unwrap().borrow_mut().forward[i] = item.as_ref().unwrap().borrow().forward[i].clone();\\n            item.as_ref().unwrap().borrow_mut().forward[i] = node.clone();\\n        }\\n    }\\n\\n    pub fn erase(&mut self, num: i32) -> bool {\\n        self._erase(num).unwrap_or(false)\\n    }\\n    fn _erase(&mut self, num: i32) -> Option<bool> {\\n        let mut cur = self.head.clone();\\n        let mut update: Vec<Link> = vec![None; MAX_LEVEL];\\n        for i in (0..self.level).rev() {\\n            loop {\\n                let node = cur.as_ref()?.borrow().forward[i].clone();\\n                match node {\\n                    node @ Some(_) => {\\n                        if node.as_ref()?.borrow().val < num {\\n                            cur = node;\\n                            continue;\\n                        }\\n                        break;\\n                    }\\n                    None => break,\\n                }\\n            }\\n            update[i] = cur.clone();\\n        }\\n        let cur = cur.as_ref()?.borrow().forward[0].clone();\\n        match cur.clone() {\\n            Some(node) => {\\n                if node.borrow().val != num {\\n                    return Some(false);\\n                }\\n            }\\n            None => return Some(false),\\n        };\\n\\n        for (i, item) in update.iter().enumerate().take(self.level) {\\n            if item.clone().unwrap().borrow().forward[i] != cur.clone() {\\n                break;\\n            }\\n            item.clone().unwrap().borrow_mut().forward[i] = cur.clone().unwrap().borrow().forward[i].clone();\\n        }\\n        while self.level > 1 && self.head.clone().unwrap().borrow().forward[self.level - 1].is_none() {\\n            self.level -= 1;\\n        }\\n\\n        Some(true)\\n    }\\n\\n    pub fn debug(&self) {\\n        let head = self.head.clone().unwrap();\\n        let mut table: Vec<Vec<(i32, usize, usize)>> =\\n            vec![vec![(head.borrow().val, head.borrow().level, head.borrow().forward.len())]; self.level];\\n\\n        for i in (0..self.level).rev() {\\n            let mut node = head.clone();\\n            while let Some(tmp) = node.clone().borrow().forward[i].clone() {\\n                table[i].push((tmp.borrow().val, tmp.borrow().level, tmp.borrow().forward.len()));\\n                node = tmp;\\n            }\\n        }\\n        for t in table.iter().rev() {\\n            println!(\"{:?}\", t);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3033700,
                "title": "simple-solution-upvote-if-you-like-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Skiplist {\\npublic:\\n    vector<vector<int>> nums;\\n    Skiplist() {\\n        nums.resize(20005, {});\\n    }\\n    \\n    bool search(int target) {\\n        return (nums[target].size() > 0 );\\n    }\\n    \\n    void add(int num) {\\n        nums[num].push_back(num);\\n    }\\n    \\n    bool erase(int num) {\\n        bool result = false;\\n        if(nums[num].size() > 0){\\n            result = true;\\n            nums[num].pop_back();\\n        }\\n        return result;\\n    }\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Skiplist {\\npublic:\\n    vector<vector<int>> nums;\\n    Skiplist() {\\n        nums.resize(20005, {});\\n    }\\n    \\n    bool search(int target) {\\n        return (nums[target].size() > 0 );\\n    }\\n    \\n    void add(int num) {\\n        nums[num].push_back(num);\\n    }\\n    \\n    bool erase(int num) {\\n        bool result = false;\\n        if(nums[num].size() > 0){\\n            result = true;\\n            nums[num].pop_back();\\n        }\\n        return result;\\n    }\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923069,
                "title": "python-solution-using-hashmap-easy-to-understand-for-beginners",
                "content": "```\\nclass Skiplist:\\n\\n    def __init__(self):\\n        self.l = {}\\n\\n    def search(self, target: int) -> bool:\\n        return self.l.get(target,False)\\n\\n    def add(self, num: int) -> None:\\n        self.l[num] = self.l.get(num,0)+1\\n\\n    def erase(self, num: int) -> bool:\\n        try:\\n            self.l[num]-=1\\n            if not self.l[num]:\\n                del self.l[num]\\n            return True\\n        except:\\n            return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Skiplist:\\n\\n    def __init__(self):\\n        self.l = {}\\n\\n    def search(self, target: int) -> bool:\\n        return self.l.get(target,False)\\n\\n    def add(self, num: int) -> None:\\n        self.l[num] = self.l.get(num,0)+1\\n\\n    def erase(self, num: int) -> bool:\\n        try:\\n            self.l[num]-=1\\n            if not self.l[num]:\\n                del self.l[num]\\n            return True\\n        except:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2825596,
                "title": "far-too-verbose-version-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI was solving this in a personal project, so conciseness was not really on the mind.\\nIf this looks like a Java developer writing in C...that\\'s because it kinda is.  Apologies in advance.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI followed the Wikipedia images a bit too literally.\\nInstead of using dummy heads, I ensure the first valid element is always present on every level which makes adding and removing the head a little tricky.\\nAlso from the Wikipedia article, I made the SkipList indexable by adding a `distanceToNext` value for each node, which added a decent bit of unnecessary complexity for LeetCode.\\n\\n# Complexity\\nI believe it follows the standard complexities mentioned in the Wikipedia article, but I might be missing something there.\\n\\n# Code\\n```\\ntypedef enum\\n{\\n    FALSE,\\n    TRUE\\n} Boolean;\\n\\ndouble Util_log2(double pValue)\\n{\\n    return log(pValue) / log(2);\\n}\\n\\ntypedef struct Skiplist Skiplist;\\ntypedef struct SkiplistNode SkiplistNode;\\n\\nstruct Skiplist\\n{\\n    unsigned int size;\\n    unsigned int numLevels;\\n    unsigned int maxLevels;\\n    unsigned int nextLevelChance;\\n    SkiplistNode* topHead;\\n};\\n\\nstruct SkiplistNode\\n{\\n    int value;\\n    SkiplistNode* next;\\n    SkiplistNode* down;\\n    unsigned int distNext;\\n};\\n\\nSkiplist* Skiplist_create(void);\\nSkiplist* Skiplist_createFull(\\n    const unsigned int pNumLevels,\\n    const unsigned int pMaxLevels,\\n    const unsigned int pNextLevelChance\\n);\\n\\nvoid Skiplist_destroy(Skiplist* pList);\\nSkiplist* Skiplist_add(Skiplist* pList, const int pValue);\\nSkiplist* Skiplist_addNewLevel(Skiplist* pList);\\nBoolean Skiplist_contains(Skiplist* pList, const int pValue);\\nint Skiplist_get(Skiplist* pList, const unsigned int index);\\nBoolean Skiplist_remove(Skiplist* pList, const int pValue);\\n\\nstatic const unsigned int DEFAULT_MAX_LEVELS = 40U;\\nstatic const unsigned int DEFAULT_NEXT_LEVEL_CHANCE = 50U;\\n\\nstatic int randChance(const Skiplist* pList)\\n{\\n    return rand() % 100U < pList->nextLevelChance;\\n}\\n\\nstatic unsigned int rollLevels(const Skiplist* pList)\\n{\\n    unsigned int retVal = 1;\\n    unsigned int i;\\n    Boolean passing = TRUE;\\n    for (i = 1; i < pList->numLevels && passing; i++) {\\n        if (randChance(pList))\\n        {\\n            retVal++;\\n        }\\n        else\\n        {\\n            passing = FALSE;\\n        }\\n    }\\n    return retVal;\\n}\\n\\nstatic void _Skiplist_addNonHead(Skiplist* pList, int pValue, Boolean dupesInBack)\\n{\\n    unsigned int i = pList->numLevels - 1;\\n    unsigned int numNewLevels = rollLevels(pList);\\n    unsigned int* totalDistPerLevel = malloc(sizeof(unsigned int) * pList->numLevels);\\n    unsigned int totalDist = 0U;\\n    SkiplistNode* currNode = pList->topHead;\\n    SkiplistNode* prevNewNode = NULL;\\n    SkiplistNode** closestNodes = malloc(sizeof(SkiplistNode*) * pList->numLevels);\\n    while (currNode != NULL)\\n    {\\n        Boolean goRight = currNode->next != NULL\\n            && (\\n                pValue > currNode->next->value\\n                || (dupesInBack && pValue == currNode->next->value)\\n            );\\n        if (goRight)\\n        {\\n            totalDist += currNode->distNext;\\n            currNode = currNode->next;\\n        }\\n        else if (currNode->down != NULL)\\n        {\\n            totalDistPerLevel[i] = totalDist;\\n            closestNodes[i--] = currNode;\\n            currNode = currNode->down;\\n        }\\n        else\\n        {\\n            totalDistPerLevel[i] = totalDist;\\n            closestNodes[i] = currNode;\\n            currNode = NULL;\\n        }\\n    }\\n\\n    for (i = 0; i < pList->numLevels; i++)\\n    {\\n        if (i < numNewLevels)\\n        {\\n            unsigned int leftDistance = (totalDist - totalDistPerLevel[i]) + 1;\\n\\n            SkiplistNode* newNode = malloc(sizeof(SkiplistNode));\\n            newNode->value = pValue;\\n            newNode->next = closestNodes[i]->next;\\n            newNode->down = prevNewNode;\\n\\n            if (closestNodes[i]->next == NULL)\\n            {\\n                newNode->distNext = 0U;\\n            }\\n            else\\n            {\\n                unsigned int rightDistance = closestNodes[i]->distNext - (totalDist - totalDistPerLevel[i]);\\n                newNode->distNext = rightDistance;\\n            }\\n\\n            closestNodes[i]->next = newNode;\\n            closestNodes[i]->distNext = leftDistance;\\n\\n            prevNewNode = newNode;\\n        }\\n        else if (closestNodes[i]->next != NULL)\\n        {\\n            closestNodes[i]->distNext += 1;\\n        }\\n    }\\n\\n    free(totalDistPerLevel);\\n    free(closestNodes);\\n}\\n\\nstatic void _Skiplist_addHead(Skiplist* pList, int pValue)\\n{\\n    SkiplistNode* currHead = pList->topHead;\\n    int oldHeadValue = currHead->value;\\n\\n    while (currHead != NULL)\\n    {\\n        currHead->value = pValue;\\n        currHead = currHead->down;\\n    }\\n\\n    _Skiplist_addNonHead(pList, oldHeadValue, FALSE);\\n}\\n\\nstatic Boolean _Skiplist_removeHead(Skiplist* pList)\\n{\\n    Boolean retVal = FALSE;\\n    SkiplistNode* currNode = pList->topHead;\\n    if (pList->size == 1)\\n    {\\n        while (currNode != NULL)\\n        {\\n            SkiplistNode* tmpNode = currNode->down;\\n            free(currNode);\\n            currNode = tmpNode;\\n        }\\n        pList->topHead = NULL;\\n        pList->size--;\\n        retVal = TRUE;\\n    }\\n    else\\n    {\\n        int bottomNextValue;\\n        while (currNode->down != NULL)\\n        {\\n            currNode = currNode->down;\\n        }\\n        bottomNextValue = currNode->next->value;\\n\\n        currNode = pList->topHead;\\n        while (currNode != NULL)\\n        {\\n            if (currNode->next != NULL && currNode->next->value == bottomNextValue)\\n            {\\n                SkiplistNode* nextNode = currNode->next;\\n                currNode->next = nextNode->next;\\n                currNode->distNext = (currNode->distNext + nextNode->distNext) - 1;\\n                free(nextNode);\\n            }\\n            else if (currNode->next != NULL)\\n            {\\n                currNode->distNext--;\\n            }\\n            currNode->value = bottomNextValue;\\n\\n            currNode = currNode->down;\\n        }\\n        pList->size--;\\n        retVal = TRUE;\\n    }\\n    return retVal;\\n}\\n\\nstatic Boolean _Skiplist_removeNonHead(Skiplist* pList, const int pValue)\\n{\\n    Boolean retVal = FALSE;\\n    SkiplistNode* currNode = pList->topHead;\\n    unsigned int i = pList->numLevels - 1;\\n    SkiplistNode** closestNodes = malloc(sizeof(SkiplistNode*) * pList->numLevels);\\n    while (currNode != NULL)\\n    {\\n        if (currNode->next != NULL && pValue > currNode->next->value)\\n        {\\n            currNode = currNode->next;\\n        }\\n        else if (currNode->down != NULL)\\n        {\\n            closestNodes[i--] = currNode;\\n            currNode = currNode->down;\\n        }\\n        else\\n        {\\n            closestNodes[i] = currNode;\\n            currNode = NULL;\\n        }\\n    }\\n\\n    if (closestNodes[0]->next != NULL && closestNodes[0]->next->value == pValue)\\n    {\\n        for (i = 0; i < pList->numLevels; i++)\\n        {\\n            SkiplistNode* thisNode = closestNodes[i];\\n            SkiplistNode* nextNode = thisNode->next;\\n            if (nextNode != NULL && nextNode->value == pValue)\\n            {\\n                thisNode->next = nextNode->next;\\n                thisNode->distNext = (thisNode->distNext + nextNode->distNext) - 1;\\n                free(nextNode);\\n            }\\n            else if (nextNode != NULL)\\n            {\\n                thisNode->distNext--;\\n            }\\n        }\\n        pList->size--;\\n        retVal = TRUE;\\n    }\\n\\n    free(closestNodes);\\n    return retVal;\\n}\\n\\nSkiplist* Skiplist_create(void)\\n{\\n    return Skiplist_createFull(1U, DEFAULT_MAX_LEVELS, DEFAULT_NEXT_LEVEL_CHANCE);\\n}\\n\\nSkiplist* Skiplist_createFull(\\n    const unsigned int pNumLevels,\\n    const unsigned int pMaxLevels,\\n    const unsigned int pNextLevelChance)\\n{\\n    Skiplist* retVal =  malloc(sizeof(Skiplist));\\n\\n    unsigned int numLevels = (pNumLevels < 1U) ? 1U : pNumLevels;\\n    unsigned int maxLevels = (pMaxLevels < numLevels) ? numLevels : pMaxLevels;\\n    unsigned int nextLevelChance = (pNextLevelChance > 100U)\\n        ? DEFAULT_NEXT_LEVEL_CHANCE\\n        : pNextLevelChance;\\n\\n    retVal->size = 0U;\\n    retVal->numLevels = numLevels;\\n    retVal->maxLevels = maxLevels;\\n    retVal->nextLevelChance = nextLevelChance;\\n    retVal->topHead = NULL;\\n\\n    return retVal;\\n}\\n\\nvoid Skiplist_destroy(Skiplist* pList)\\n{\\n    SkiplistNode* prevHead = NULL;\\n    SkiplistNode* currHead = pList->topHead;\\n    while (currHead != NULL)\\n    {\\n        SkiplistNode* prevNode = NULL;\\n        SkiplistNode* currNode = currHead->next;\\n        while (currNode != NULL)\\n        {\\n            prevNode = currNode;\\n            currNode = currNode->next;\\n            free(prevNode);\\n        }\\n        prevHead = currHead;\\n        currHead = currHead->down;\\n        free(prevHead);\\n    }\\n    free(pList);\\n}\\n\\nSkiplist* Skiplist_add(Skiplist* pList, const int pValue)\\n{\\n    unsigned int logSize;\\n\\n    if (pList->topHead == NULL)\\n    {\\n        SkiplistNode* lastNode = NULL;\\n        unsigned int i;\\n        for (i = 0; i < pList->numLevels; i++)\\n        {\\n            SkiplistNode* newNode = malloc(sizeof(SkiplistNode));\\n            newNode->value = pValue;\\n            newNode->next = NULL;\\n            newNode->down = lastNode;\\n            newNode->distNext = 0;\\n\\n            lastNode = newNode;\\n        }\\n\\n        pList->topHead = lastNode;\\n    }\\n    else\\n    {\\n        SkiplistNode* topHead = pList->topHead;\\n\\n        if (pValue >= topHead->value)\\n        {\\n            _Skiplist_addNonHead(pList, pValue, TRUE);\\n        }\\n        else if (pValue < topHead->value)\\n        {\\n            _Skiplist_addHead(pList, pValue);\\n        }\\n\\n    }\\n\\n    pList->size++;\\n\\n    logSize = (pList->size == 0) ? 0 : Util_log2((double)pList->size);\\n    if (logSize > pList->numLevels && pList->numLevels < pList->maxLevels)\\n    {\\n        Skiplist_addNewLevel(pList);\\n    }\\n\\n    return pList;\\n}\\n\\nSkiplist* Skiplist_addNewLevel(Skiplist* pList)\\n{\\n    SkiplistNode* currTopNode = pList->topHead;\\n    SkiplistNode* prevNewNode;\\n    unsigned int i = 0;\\n    unsigned int currDist = 0U;\\n    while (currTopNode != NULL)\\n    {\\n        if (i == 0 || randChance(pList))\\n        {\\n            SkiplistNode* newNode = malloc(sizeof(SkiplistNode));\\n            newNode->value = currTopNode->value;\\n            newNode->next = NULL;\\n            newNode->distNext = 0U;\\n            newNode->down = currTopNode;\\n            if (i == 0)\\n            {\\n                pList->topHead = newNode;\\n            }\\n            else\\n            {\\n                prevNewNode->next = newNode;\\n                prevNewNode->distNext = currDist;\\n            }\\n            prevNewNode = newNode;\\n            currDist = 0U;\\n        }\\n\\n        currDist += currTopNode->distNext;\\n        currTopNode = currTopNode->next;\\n        i++;\\n    }\\n\\n    pList->numLevels++;\\n\\n    return pList;\\n}\\n\\nBoolean Skiplist_contains(Skiplist* pList, const int pValue)\\n{\\n    SkiplistNode* currNode = pList->topHead;\\n    Boolean retVal = FALSE;\\n\\n    while (currNode != NULL)\\n    {\\n        if (currNode->value == pValue)\\n        {\\n            retVal = TRUE;\\n            break;\\n        }\\n        else if (currNode->next != NULL && pValue >= currNode->next->value)\\n        {\\n            currNode = currNode->next;\\n        }\\n        else if (currNode->down != NULL)\\n        {\\n            currNode = currNode->down;\\n        }\\n        else\\n        {\\n            currNode = NULL;\\n        }\\n    }\\n\\n    return retVal;\\n}\\n\\nint Skiplist_get(Skiplist* pList, const unsigned int index)\\n{\\n    SkiplistNode* currNode = pList->topHead;\\n\\n    /*\\n        TODO Using -1 as error value because I\\'m lazy.\\n        Might add proper error handling if I\\'m bored in the future.\\n    */\\n    int retVal = -1;\\n    unsigned int currDist = 0;\\n    int i = 0;\\n\\n    if (index >= pList->size)\\n    {\\n        return retVal;\\n    }\\n\\n    while (currNode != NULL)\\n    {\\n        i++;\\n        if (currDist == index)\\n        {\\n            retVal = currNode->value;\\n            break;\\n        }\\n        else if (currNode->next != NULL && currDist + currNode->distNext <= index)\\n        {\\n            currDist += currNode->distNext;\\n            currNode = currNode->next;\\n        }\\n        else if (currNode->down != NULL)\\n        {\\n            currNode = currNode->down;\\n        }\\n        else\\n        {\\n            currNode = NULL;\\n        }\\n    }\\n\\n    return retVal;\\n}\\n\\nBoolean Skiplist_remove(Skiplist* pList, const int pValue)\\n{\\n    Boolean retVal = FALSE;\\n\\n    if (pList->size > 0)\\n    {\\n        if (pList->topHead->value == pValue)\\n        {\\n            retVal = _Skiplist_removeHead(pList);\\n        }\\n        else\\n        {\\n            retVal = _Skiplist_removeNonHead(pList, pValue);\\n        }\\n    }\\n\\n    return retVal;\\n}\\n\\n/* ---------------------- */\\n\\nSkiplist* skiplistCreate() {\\n    return Skiplist_createFull(1U, DEFAULT_MAX_LEVELS, DEFAULT_NEXT_LEVEL_CHANCE);\\n}\\n\\nbool skiplistSearch(Skiplist* obj, int target) {\\n    return Skiplist_contains(obj, target);\\n}\\n\\nvoid skiplistAdd(Skiplist* obj, int num) {\\n    Skiplist_add(obj, num);\\n}\\n\\nbool skiplistErase(Skiplist* obj, int num) {\\n    return Skiplist_remove(obj, num);\\n}\\n\\nvoid skiplistFree(Skiplist* obj) {\\n    Skiplist_destroy(obj);\\n}\\n\\n/**\\n * Your Skiplist struct will be instantiated and called as such:\\n * Skiplist* obj = SkiplistCreate();\\n * bool param_1 = SkiplistSearch(obj, target);\\n \\n * SkiplistAdd(obj, num);\\n \\n * bool param_3 = SkiplistErase(obj, num);\\n \\n * SkiplistFree(obj);\\n*/\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef enum\\n{\\n    FALSE,\\n    TRUE\\n} Boolean;\\n\\ndouble Util_log2(double pValue)\\n{\\n    return log(pValue) / log(2);\\n}\\n\\ntypedef struct Skiplist Skiplist;\\ntypedef struct SkiplistNode SkiplistNode;\\n\\nstruct Skiplist\\n{\\n    unsigned int size;\\n    unsigned int numLevels;\\n    unsigned int maxLevels;\\n    unsigned int nextLevelChance;\\n    SkiplistNode* topHead;\\n};\\n\\nstruct SkiplistNode\\n{\\n    int value;\\n    SkiplistNode* next;\\n    SkiplistNode* down;\\n    unsigned int distNext;\\n};\\n\\nSkiplist* Skiplist_create(void);\\nSkiplist* Skiplist_createFull(\\n    const unsigned int pNumLevels,\\n    const unsigned int pMaxLevels,\\n    const unsigned int pNextLevelChance\\n);\\n\\nvoid Skiplist_destroy(Skiplist* pList);\\nSkiplist* Skiplist_add(Skiplist* pList, const int pValue);\\nSkiplist* Skiplist_addNewLevel(Skiplist* pList);\\nBoolean Skiplist_contains(Skiplist* pList, const int pValue);\\nint Skiplist_get(Skiplist* pList, const unsigned int index);\\nBoolean Skiplist_remove(Skiplist* pList, const int pValue);\\n\\nstatic const unsigned int DEFAULT_MAX_LEVELS = 40U;\\nstatic const unsigned int DEFAULT_NEXT_LEVEL_CHANCE = 50U;\\n\\nstatic int randChance(const Skiplist* pList)\\n{\\n    return rand() % 100U < pList->nextLevelChance;\\n}\\n\\nstatic unsigned int rollLevels(const Skiplist* pList)\\n{\\n    unsigned int retVal = 1;\\n    unsigned int i;\\n    Boolean passing = TRUE;\\n    for (i = 1; i < pList->numLevels && passing; i++) {\\n        if (randChance(pList))\\n        {\\n            retVal++;\\n        }\\n        else\\n        {\\n            passing = FALSE;\\n        }\\n    }\\n    return retVal;\\n}\\n\\nstatic void _Skiplist_addNonHead(Skiplist* pList, int pValue, Boolean dupesInBack)\\n{\\n    unsigned int i = pList->numLevels - 1;\\n    unsigned int numNewLevels = rollLevels(pList);\\n    unsigned int* totalDistPerLevel = malloc(sizeof(unsigned int) * pList->numLevels);\\n    unsigned int totalDist = 0U;\\n    SkiplistNode* currNode = pList->topHead;\\n    SkiplistNode* prevNewNode = NULL;\\n    SkiplistNode** closestNodes = malloc(sizeof(SkiplistNode*) * pList->numLevels);\\n    while (currNode != NULL)\\n    {\\n        Boolean goRight = currNode->next != NULL\\n            && (\\n                pValue > currNode->next->value\\n                || (dupesInBack && pValue == currNode->next->value)\\n            );\\n        if (goRight)\\n        {\\n            totalDist += currNode->distNext;\\n            currNode = currNode->next;\\n        }\\n        else if (currNode->down != NULL)\\n        {\\n            totalDistPerLevel[i] = totalDist;\\n            closestNodes[i--] = currNode;\\n            currNode = currNode->down;\\n        }\\n        else\\n        {\\n            totalDistPerLevel[i] = totalDist;\\n            closestNodes[i] = currNode;\\n            currNode = NULL;\\n        }\\n    }\\n\\n    for (i = 0; i < pList->numLevels; i++)\\n    {\\n        if (i < numNewLevels)\\n        {\\n            unsigned int leftDistance = (totalDist - totalDistPerLevel[i]) + 1;\\n\\n            SkiplistNode* newNode = malloc(sizeof(SkiplistNode));\\n            newNode->value = pValue;\\n            newNode->next = closestNodes[i]->next;\\n            newNode->down = prevNewNode;\\n\\n            if (closestNodes[i]->next == NULL)\\n            {\\n                newNode->distNext = 0U;\\n            }\\n            else\\n            {\\n                unsigned int rightDistance = closestNodes[i]->distNext - (totalDist - totalDistPerLevel[i]);\\n                newNode->distNext = rightDistance;\\n            }\\n\\n            closestNodes[i]->next = newNode;\\n            closestNodes[i]->distNext = leftDistance;\\n\\n            prevNewNode = newNode;\\n        }\\n        else if (closestNodes[i]->next != NULL)\\n        {\\n            closestNodes[i]->distNext += 1;\\n        }\\n    }\\n\\n    free(totalDistPerLevel);\\n    free(closestNodes);\\n}\\n\\nstatic void _Skiplist_addHead(Skiplist* pList, int pValue)\\n{\\n    SkiplistNode* currHead = pList->topHead;\\n    int oldHeadValue = currHead->value;\\n\\n    while (currHead != NULL)\\n    {\\n        currHead->value = pValue;\\n        currHead = currHead->down;\\n    }\\n\\n    _Skiplist_addNonHead(pList, oldHeadValue, FALSE);\\n}\\n\\nstatic Boolean _Skiplist_removeHead(Skiplist* pList)\\n{\\n    Boolean retVal = FALSE;\\n    SkiplistNode* currNode = pList->topHead;\\n    if (pList->size == 1)\\n    {\\n        while (currNode != NULL)\\n        {\\n            SkiplistNode* tmpNode = currNode->down;\\n            free(currNode);\\n            currNode = tmpNode;\\n        }\\n        pList->topHead = NULL;\\n        pList->size--;\\n        retVal = TRUE;\\n    }\\n    else\\n    {\\n        int bottomNextValue;\\n        while (currNode->down != NULL)\\n        {\\n            currNode = currNode->down;\\n        }\\n        bottomNextValue = currNode->next->value;\\n\\n        currNode = pList->topHead;\\n        while (currNode != NULL)\\n        {\\n            if (currNode->next != NULL && currNode->next->value == bottomNextValue)\\n            {\\n                SkiplistNode* nextNode = currNode->next;\\n                currNode->next = nextNode->next;\\n                currNode->distNext = (currNode->distNext + nextNode->distNext) - 1;\\n                free(nextNode);\\n            }\\n            else if (currNode->next != NULL)\\n            {\\n                currNode->distNext--;\\n            }\\n            currNode->value = bottomNextValue;\\n\\n            currNode = currNode->down;\\n        }\\n        pList->size--;\\n        retVal = TRUE;\\n    }\\n    return retVal;\\n}\\n\\nstatic Boolean _Skiplist_removeNonHead(Skiplist* pList, const int pValue)\\n{\\n    Boolean retVal = FALSE;\\n    SkiplistNode* currNode = pList->topHead;\\n    unsigned int i = pList->numLevels - 1;\\n    SkiplistNode** closestNodes = malloc(sizeof(SkiplistNode*) * pList->numLevels);\\n    while (currNode != NULL)\\n    {\\n        if (currNode->next != NULL && pValue > currNode->next->value)\\n        {\\n            currNode = currNode->next;\\n        }\\n        else if (currNode->down != NULL)\\n        {\\n            closestNodes[i--] = currNode;\\n            currNode = currNode->down;\\n        }\\n        else\\n        {\\n            closestNodes[i] = currNode;\\n            currNode = NULL;\\n        }\\n    }\\n\\n    if (closestNodes[0]->next != NULL && closestNodes[0]->next->value == pValue)\\n    {\\n        for (i = 0; i < pList->numLevels; i++)\\n        {\\n            SkiplistNode* thisNode = closestNodes[i];\\n            SkiplistNode* nextNode = thisNode->next;\\n            if (nextNode != NULL && nextNode->value == pValue)\\n            {\\n                thisNode->next = nextNode->next;\\n                thisNode->distNext = (thisNode->distNext + nextNode->distNext) - 1;\\n                free(nextNode);\\n            }\\n            else if (nextNode != NULL)\\n            {\\n                thisNode->distNext--;\\n            }\\n        }\\n        pList->size--;\\n        retVal = TRUE;\\n    }\\n\\n    free(closestNodes);\\n    return retVal;\\n}\\n\\nSkiplist* Skiplist_create(void)\\n{\\n    return Skiplist_createFull(1U, DEFAULT_MAX_LEVELS, DEFAULT_NEXT_LEVEL_CHANCE);\\n}\\n\\nSkiplist* Skiplist_createFull(\\n    const unsigned int pNumLevels,\\n    const unsigned int pMaxLevels,\\n    const unsigned int pNextLevelChance)\\n{\\n    Skiplist* retVal =  malloc(sizeof(Skiplist));\\n\\n    unsigned int numLevels = (pNumLevels < 1U) ? 1U : pNumLevels;\\n    unsigned int maxLevels = (pMaxLevels < numLevels) ? numLevels : pMaxLevels;\\n    unsigned int nextLevelChance = (pNextLevelChance > 100U)\\n        ? DEFAULT_NEXT_LEVEL_CHANCE\\n        : pNextLevelChance;\\n\\n    retVal->size = 0U;\\n    retVal->numLevels = numLevels;\\n    retVal->maxLevels = maxLevels;\\n    retVal->nextLevelChance = nextLevelChance;\\n    retVal->topHead = NULL;\\n\\n    return retVal;\\n}\\n\\nvoid Skiplist_destroy(Skiplist* pList)\\n{\\n    SkiplistNode* prevHead = NULL;\\n    SkiplistNode* currHead = pList->topHead;\\n    while (currHead != NULL)\\n    {\\n        SkiplistNode* prevNode = NULL;\\n        SkiplistNode* currNode = currHead->next;\\n        while (currNode != NULL)\\n        {\\n            prevNode = currNode;\\n            currNode = currNode->next;\\n            free(prevNode);\\n        }\\n        prevHead = currHead;\\n        currHead = currHead->down;\\n        free(prevHead);\\n    }\\n    free(pList);\\n}\\n\\nSkiplist* Skiplist_add(Skiplist* pList, const int pValue)\\n{\\n    unsigned int logSize;\\n\\n    if (pList->topHead == NULL)\\n    {\\n        SkiplistNode* lastNode = NULL;\\n        unsigned int i;\\n        for (i = 0; i < pList->numLevels; i++)\\n        {\\n            SkiplistNode* newNode = malloc(sizeof(SkiplistNode));\\n            newNode->value = pValue;\\n            newNode->next = NULL;\\n            newNode->down = lastNode;\\n            newNode->distNext = 0;\\n\\n            lastNode = newNode;\\n        }\\n\\n        pList->topHead = lastNode;\\n    }\\n    else\\n    {\\n        SkiplistNode* topHead = pList->topHead;\\n\\n        if (pValue >= topHead->value)\\n        {\\n            _Skiplist_addNonHead(pList, pValue, TRUE);\\n        }\\n        else if (pValue < topHead->value)\\n        {\\n            _Skiplist_addHead(pList, pValue);\\n        }\\n\\n    }\\n\\n    pList->size++;\\n\\n    logSize = (pList->size == 0) ? 0 : Util_log2((double)pList->size);\\n    if (logSize > pList->numLevels && pList->numLevels < pList->maxLevels)\\n    {\\n        Skiplist_addNewLevel(pList);\\n    }\\n\\n    return pList;\\n}\\n\\nSkiplist* Skiplist_addNewLevel(Skiplist* pList)\\n{\\n    SkiplistNode* currTopNode = pList->topHead;\\n    SkiplistNode* prevNewNode;\\n    unsigned int i = 0;\\n    unsigned int currDist = 0U;\\n    while (currTopNode != NULL)\\n    {\\n        if (i == 0 || randChance(pList))\\n        {\\n            SkiplistNode* newNode = malloc(sizeof(SkiplistNode));\\n            newNode->value = currTopNode->value;\\n            newNode->next = NULL;\\n            newNode->distNext = 0U;\\n            newNode->down = currTopNode;\\n            if (i == 0)\\n            {\\n                pList->topHead = newNode;\\n            }\\n            else\\n            {\\n                prevNewNode->next = newNode;\\n                prevNewNode->distNext = currDist;\\n            }\\n            prevNewNode = newNode;\\n            currDist = 0U;\\n        }\\n\\n        currDist += currTopNode->distNext;\\n        currTopNode = currTopNode->next;\\n        i++;\\n    }\\n\\n    pList->numLevels++;\\n\\n    return pList;\\n}\\n\\nBoolean Skiplist_contains(Skiplist* pList, const int pValue)\\n{\\n    SkiplistNode* currNode = pList->topHead;\\n    Boolean retVal = FALSE;\\n\\n    while (currNode != NULL)\\n    {\\n        if (currNode->value == pValue)\\n        {\\n            retVal = TRUE;\\n            break;\\n        }\\n        else if (currNode->next != NULL && pValue >= currNode->next->value)\\n        {\\n            currNode = currNode->next;\\n        }\\n        else if (currNode->down != NULL)\\n        {\\n            currNode = currNode->down;\\n        }\\n        else\\n        {\\n            currNode = NULL;\\n        }\\n    }\\n\\n    return retVal;\\n}\\n\\nint Skiplist_get(Skiplist* pList, const unsigned int index)\\n{\\n    SkiplistNode* currNode = pList->topHead;\\n\\n    /*\\n        TODO Using -1 as error value because I\\'m lazy.\\n        Might add proper error handling if I\\'m bored in the future.\\n    */\\n    int retVal = -1;\\n    unsigned int currDist = 0;\\n    int i = 0;\\n\\n    if (index >= pList->size)\\n    {\\n        return retVal;\\n    }\\n\\n    while (currNode != NULL)\\n    {\\n        i++;\\n        if (currDist == index)\\n        {\\n            retVal = currNode->value;\\n            break;\\n        }\\n        else if (currNode->next != NULL && currDist + currNode->distNext <= index)\\n        {\\n            currDist += currNode->distNext;\\n            currNode = currNode->next;\\n        }\\n        else if (currNode->down != NULL)\\n        {\\n            currNode = currNode->down;\\n        }\\n        else\\n        {\\n            currNode = NULL;\\n        }\\n    }\\n\\n    return retVal;\\n}\\n\\nBoolean Skiplist_remove(Skiplist* pList, const int pValue)\\n{\\n    Boolean retVal = FALSE;\\n\\n    if (pList->size > 0)\\n    {\\n        if (pList->topHead->value == pValue)\\n        {\\n            retVal = _Skiplist_removeHead(pList);\\n        }\\n        else\\n        {\\n            retVal = _Skiplist_removeNonHead(pList, pValue);\\n        }\\n    }\\n\\n    return retVal;\\n}\\n\\n/* ---------------------- */\\n\\nSkiplist* skiplistCreate() {\\n    return Skiplist_createFull(1U, DEFAULT_MAX_LEVELS, DEFAULT_NEXT_LEVEL_CHANCE);\\n}\\n\\nbool skiplistSearch(Skiplist* obj, int target) {\\n    return Skiplist_contains(obj, target);\\n}\\n\\nvoid skiplistAdd(Skiplist* obj, int num) {\\n    Skiplist_add(obj, num);\\n}\\n\\nbool skiplistErase(Skiplist* obj, int num) {\\n    return Skiplist_remove(obj, num);\\n}\\n\\nvoid skiplistFree(Skiplist* obj) {\\n    Skiplist_destroy(obj);\\n}\\n\\n/**\\n * Your Skiplist struct will be instantiated and called as such:\\n * Skiplist* obj = SkiplistCreate();\\n * bool param_1 = SkiplistSearch(obj, target);\\n \\n * SkiplistAdd(obj, num);\\n \\n * bool param_3 = SkiplistErase(obj, num);\\n \\n * SkiplistFree(obj);\\n*/\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2814048,
                "title": "c",
                "content": "```\\nclass Node{\\n    public:\\n    Node* next;\\n    int val;\\n    Node(int val){\\n        this->val=val;\\n        next=NULL;\\n    }\\n};\\nclass Skiplist {\\npublic:\\n    Node* head=new Node(0);\\n    int size=0;\\n    Skiplist() {\\n        \\n    }\\n    \\n    bool search(int target) {\\n        if(size==0)return false;\\n        Node* temp=head->next;\\n        while(temp!=NULL)\\n        {//cout<<temp->val<<endl;\\n            if(temp->val==target)\\n                return true;\\n            \\n            temp=temp->next;\\n        }\\n        return false;\\n    }\\n    \\n    void add(int num) {\\n         Node* temp = head->next;\\n        head->next = new Node(num);\\n        head->next->next = temp;\\n        size++;\\n    }\\n    \\n    bool erase(int num) { \\n        int c=0;\\n        Node* temp = head;\\n        while(temp->next!= NULL){\\n            if(temp->next->val==num){\\n                c=1; \\n                break;}\\n            temp = temp->next;}\\n        if(c==1){\\n        size--;\\n       temp->next= temp->next->next;\\n        \\n            return true;\\n        }\\n        \\n        return false;\\n            \\n        \\n    }\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Node{\\n    public:\\n    Node* next;\\n    int val;\\n    Node(int val){\\n        this->val=val;\\n        next=NULL;\\n    }\\n};\\nclass Skiplist {\\npublic:\\n    Node* head=new Node(0);\\n    int size=0;\\n    Skiplist() {\\n        \\n    }\\n    \\n    bool search(int target) {\\n        if(size==0)return false;\\n        Node* temp=head->next;\\n        while(temp!=NULL)\\n        {//cout<<temp->val<<endl;\\n            if(temp->val==target)\\n                return true;\\n            \\n            temp=temp->next;\\n        }\\n        return false;\\n    }\\n    \\n    void add(int num) {\\n         Node* temp = head->next;\\n        head->next = new Node(num);\\n        head->next->next = temp;\\n        size++;\\n    }\\n    \\n    bool erase(int num) { \\n        int c=0;\\n        Node* temp = head;\\n        while(temp->next!= NULL){\\n            if(temp->next->val==num){\\n                c=1; \\n                break;}\\n            temp = temp->next;}\\n        if(c==1){\\n        size--;\\n       temp->next= temp->next->next;\\n        \\n            return true;\\n        }\\n        \\n        return false;\\n            \\n        \\n    }\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */",
                "codeTag": "C++"
            },
            {
                "id": 2774869,
                "title": "databricks-solution-with-dynamic-adding-of-levels-in-go",
                "content": "# Intuition\\n\\nWe want to be able to create levels on demand and they need to grow out\\n\\nSo on add we will extend array of grown levels out and we need to keep all the elements that we went down on while creating this elemenet, to update their next value.\\n\\nOn search we go from the top levels into the lower levels.\\n\\nOn erase it becomes a bit more interesting and it could be nice to have back links, then we could go through them and connect the elements.\\n\\n# Approach\\n\\nMy main insight was to grow the skiplist \"down\", instead of up, as we promote nodes.\\n\\nWhat also makes the implementation much simpler is \"dead head\", we don\\'t have to deal with a special case of deleting the head then.\\n\\nThe other imporant aspect is to remove the node in place when we are searching for its position.\\n\\nLastly, not allowing duplicate nodes, but storing them as `count` makes the implementation structure much simpler.\\n\\nFurther just follow implementation on intuition. (I did have to debug it on the course of 1.5h though, so don\\'t feel bad if it fails and fails tests).\\n\\n# Complexity\\n- Time complexity:\\n$$O(LogN)$$\\n\\n- Space complexity:\\n$$O(n)$$ \\u2014 in case we fix the amount of allowed levels (in my implementation I didn\\'t).\\n\\n# Code\\n```\\ntype Node struct {\\n    Val int\\n    Count int\\n    Next []*Node\\n}\\n\\ntype Skiplist struct {\\n    Head *Node    \\n}\\n\\nfunc Constructor() Skiplist {\\n    // \"Dead head\"\\n    return Skiplist{ \\n        Head: &Node{ \\n            Val: math.MinInt, \\n            Next: []*Node{nil},\\n        },\\n    }    \\n}\\n\\nfunc (s *Skiplist) Search(target int) bool {\\n    cur := s.Head\\n    level := len(cur.Next) - 1\\n    for {\\n        if cur.Next[level] == nil || cur.Next[level].Val > target {\\n            // Go down\\n            if level == 0 {\\n                return false // target would\\'ve been here if it was found\\n            }\\n            level--\\n        } else if cur.Next[level].Val < target {\\n            cur = cur.Next[level]\\n            level = len(cur.Next)-1\\n        } else if cur.Next[level].Val == target {\\n            return true\\n        }\\n    }\\n}\\n\\nfunc (s *Skiplist) Add(num int)  {\\n    cur := s.Head\\n    // Keep pivots where we go down, as we \\n    // might have to connect them if we will \\n    //promote added node to their level\\n    pivots := []*Node{cur}\\n\\n    // Find place\\n    level := len(cur.Next)-1\\n    for {\\n        if cur.Next[level] == nil || cur.Next[level].Val > num {\\n            if level == 0 {\\n                break // insert before cur.Next[level]\\n            }\\n            pivots = append(pivots, cur)\\n            level--\\n        } else if cur.Next[level].Val < num {\\n            cur = cur.Next[level]\\n            level = len(cur.Next)-1\\n        } else if cur.Next[level].Val == num {\\n            cur.Next[level].Count++\\n            return\\n        }\\n    }\\n\\n    // Insert\\n    n := &Node{Val: num, Count: 1, Next: []*Node{cur.Next[0]}}\\n    cur.Next[0] = n\\n\\n    // Promote\\n    pivotLevel := 1\\n    for rand.Intn(10) % 2 == 1 && len(pivots) > 0 {\\n        pivot := pivots[len(pivots)-1]\\n        pivots = pivots[:len(pivots)-1]\\n\\n        if pivotLevel < len(pivot.Next) {\\n            // Update\\n            next := pivot.Next[pivotLevel]\\n            pivot.Next[pivotLevel] = n\\n            n.Next = append(n.Next, next)\\n        } else {\\n            // Extend\\n            pivot.Next = append(pivot.Next, n)\\n            n.Next = append(n.Next, nil)\\n        }\\n        pivotLevel++\\n    }\\n}\\n\\n\\nfunc (s *Skiplist) Erase(num int) bool {\\n    cur := s.Head\\n    // Find\\n    level := len(cur.Next)-1\\n    for {\\n        if cur.Next[level] == nil || cur.Next[level].Val > num {\\n            if level == 0 {\\n                // Not found\\n                return false\\n            }\\n            level--\\n        } else if cur.Next[level].Val < num {\\n            cur = cur.Next[level]\\n            level = len(cur.Next)-1\\n        } else if cur.Next[level].Val == num {\\n            // Erase at current level\\n            if cur.Next[level].Count > 1 {\\n                // Duplicate \\u2014 keep structure, but reduce count\\n                cur.Next[level].Count--\\n                return true\\n            }\\n            // Needs to be removed from bottom up through all levels\\n            cur.Next[level] = cur.Next[level].Next[level]\\n            level--\\n            if level < 0 {\\n                return true\\n            }\\n        }\\n    }\\n    return true\\n}\\n\\nfunc (s *Skiplist) Report() {\\n    for level := 0; level < len(s.Head.Next); level++ {\\n        for cur := s.Head; cur != nil; cur = cur.Next[level] {\\n            if cur.Count > 1 {\\n                fmt.Printf(\"%d(%d) -> \", cur.Val, cur.Count)\\n            } else {\\n                fmt.Printf(\"%d -> \", cur.Val)\\n            }\\n        }\\n        fmt.Printf(\"nil \\\\n\")\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Linked List"
                ],
                "code": "```\\ntype Node struct {\\n    Val int\\n    Count int\\n    Next []*Node\\n}\\n\\ntype Skiplist struct {\\n    Head *Node    \\n}\\n\\nfunc Constructor() Skiplist {\\n    // \"Dead head\"\\n    return Skiplist{ \\n        Head: &Node{ \\n            Val: math.MinInt, \\n            Next: []*Node{nil},\\n        },\\n    }    \\n}\\n\\nfunc (s *Skiplist) Search(target int) bool {\\n    cur := s.Head\\n    level := len(cur.Next) - 1\\n    for {\\n        if cur.Next[level] == nil || cur.Next[level].Val > target {\\n            // Go down\\n            if level == 0 {\\n                return false // target would\\'ve been here if it was found\\n            }\\n            level--\\n        } else if cur.Next[level].Val < target {\\n            cur = cur.Next[level]\\n            level = len(cur.Next)-1\\n        } else if cur.Next[level].Val == target {\\n            return true\\n        }\\n    }\\n}\\n\\nfunc (s *Skiplist) Add(num int)  {\\n    cur := s.Head\\n    // Keep pivots where we go down, as we \\n    // might have to connect them if we will \\n    //promote added node to their level\\n    pivots := []*Node{cur}\\n\\n    // Find place\\n    level := len(cur.Next)-1\\n    for {\\n        if cur.Next[level] == nil || cur.Next[level].Val > num {\\n            if level == 0 {\\n                break // insert before cur.Next[level]\\n            }\\n            pivots = append(pivots, cur)\\n            level--\\n        } else if cur.Next[level].Val < num {\\n            cur = cur.Next[level]\\n            level = len(cur.Next)-1\\n        } else if cur.Next[level].Val == num {\\n            cur.Next[level].Count++\\n            return\\n        }\\n    }\\n\\n    // Insert\\n    n := &Node{Val: num, Count: 1, Next: []*Node{cur.Next[0]}}\\n    cur.Next[0] = n\\n\\n    // Promote\\n    pivotLevel := 1\\n    for rand.Intn(10) % 2 == 1 && len(pivots) > 0 {\\n        pivot := pivots[len(pivots)-1]\\n        pivots = pivots[:len(pivots)-1]\\n\\n        if pivotLevel < len(pivot.Next) {\\n            // Update\\n            next := pivot.Next[pivotLevel]\\n            pivot.Next[pivotLevel] = n\\n            n.Next = append(n.Next, next)\\n        } else {\\n            // Extend\\n            pivot.Next = append(pivot.Next, n)\\n            n.Next = append(n.Next, nil)\\n        }\\n        pivotLevel++\\n    }\\n}\\n\\n\\nfunc (s *Skiplist) Erase(num int) bool {\\n    cur := s.Head\\n    // Find\\n    level := len(cur.Next)-1\\n    for {\\n        if cur.Next[level] == nil || cur.Next[level].Val > num {\\n            if level == 0 {\\n                // Not found\\n                return false\\n            }\\n            level--\\n        } else if cur.Next[level].Val < num {\\n            cur = cur.Next[level]\\n            level = len(cur.Next)-1\\n        } else if cur.Next[level].Val == num {\\n            // Erase at current level\\n            if cur.Next[level].Count > 1 {\\n                // Duplicate \\u2014 keep structure, but reduce count\\n                cur.Next[level].Count--\\n                return true\\n            }\\n            // Needs to be removed from bottom up through all levels\\n            cur.Next[level] = cur.Next[level].Next[level]\\n            level--\\n            if level < 0 {\\n                return true\\n            }\\n        }\\n    }\\n    return true\\n}\\n\\nfunc (s *Skiplist) Report() {\\n    for level := 0; level < len(s.Head.Next); level++ {\\n        for cur := s.Head; cur != nil; cur = cur.Next[level] {\\n            if cur.Count > 1 {\\n                fmt.Printf(\"%d(%d) -> \", cur.Val, cur.Count)\\n            } else {\\n                fmt.Printf(\"%d -> \", cur.Val)\\n            }\\n        }\\n        fmt.Printf(\"nil \\\\n\")\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2735212,
                "title": "very-easy-java-code-faster-than-90-linked-list",
                "content": "class Skiplist {\\n    class Node {\\n        int val;\\n        Node next, down;\\n        public Node(int val, Node next, Node down) {\\n            this.val = val;\\n            this.next = next;\\n            this.down = down;\\n        }\\n    }\\n    Node head = new Node(-1, null, null);\\n    Random rand = new Random();\\n    public Skiplist() {\\n        \\n    }\\n    \\n    public boolean search(int target) {\\n        Node cur = head;\\n        while (cur != null) {\\n            while (cur.next != null && cur.next.val < target) {\\n                cur = cur.next;\\n            }\\n            if (cur.next != null && cur.next.val == target) return true;\\n            cur = cur.down;\\n        }\\n        return false;\\n    }\\n    \\n    public void add(int num) {\\n        Stack<Node> stack = new Stack<>();\\n        Node cur = head;\\n        while (cur != null) {\\n            while (cur.next != null && cur.next.val < num) {\\n                cur = cur.next;\\n            }\\n            stack.push(cur);\\n            cur = cur.down;\\n        }\\n        boolean insert = true;\\n        Node down = null;\\n        while (insert && !stack.isEmpty()) {\\n            cur = stack.pop();\\n            cur.next = new Node(num, cur.next, down);\\n            down = cur.next;\\n            insert = rand.nextDouble() < 0.5;\\n        }\\n        if (insert) head = new Node(-1, null, head);\\n    }\\n    \\n    public boolean erase(int num) {\\n        Node cur = head;\\n        boolean found = false;\\n        while (cur != null) {\\n            while (cur.next != null && cur.next.val < num) {\\n                cur = cur.next;\\n            }\\n            if (cur.next != null && cur.next.val == num) {\\n                found = true;\\n                cur.next = cur.next.next;\\n            }\\n            cur = cur.down;\\n        }\\n        return found;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Skiplist {\\n    class Node {\\n        int val;\\n        Node next, down;\\n        public Node(int val, Node next, Node down) {\\n            this.val = val;\\n            this.next = next;\\n            this.down = down;\\n        }\\n    }\\n    Node head = new Node(-1, null, null);\\n    Random rand = new Random();\\n    public Skiplist() {\\n        \\n    }\\n    \\n    public boolean search(int target) {\\n        Node cur = head;\\n        while (cur != null) {\\n            while (cur.next != null && cur.next.val < target) {\\n                cur = cur.next;\\n            }\\n            if (cur.next != null && cur.next.val == target) return true;\\n            cur = cur.down;\\n        }\\n        return false;\\n    }\\n    \\n    public void add(int num) {\\n        Stack<Node> stack = new Stack<>();\\n        Node cur = head;\\n        while (cur != null) {\\n            while (cur.next != null && cur.next.val < num) {\\n                cur = cur.next;\\n            }\\n            stack.push(cur);\\n            cur = cur.down;\\n        }\\n        boolean insert = true;\\n        Node down = null;\\n        while (insert && !stack.isEmpty()) {\\n            cur = stack.pop();\\n            cur.next = new Node(num, cur.next, down);\\n            down = cur.next;\\n            insert = rand.nextDouble() < 0.5;\\n        }\\n        if (insert) head = new Node(-1, null, head);\\n    }\\n    \\n    public boolean erase(int num) {\\n        Node cur = head;\\n        boolean found = false;\\n        while (cur != null) {\\n            while (cur.next != null && cur.next.val < num) {\\n                cur = cur.next;\\n            }\\n            if (cur.next != null && cur.next.val == num) {\\n                found = true;\\n                cur.next = cur.next.next;\\n            }\\n            cur = cur.down;\\n        }\\n        return found;\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 2696838,
                "title": "ruby-concise-solution",
                "content": "```\\nclass Node\\n    attr_accessor :val, :next, :down\\n    def initialize(val=nil, nxt=nil, down=nil)\\n        @val=val\\n        @next=nxt\\n        @down=down\\n    end\\nend\\n\\n\\nclass Skiplist\\n    def initialize()\\n        @head=Node.new\\n    end\\n\\n\\n=begin\\n    :type target: Integer\\n    :rtype: Boolean\\n=end\\n    def search(target)\\n        p=@head\\n        while p\\n            p=p.next while p.next && p.next.val < target\\n            return true if p.next && p.next.val==target\\n            p=p.down\\n        end\\n        false\\n    end\\n\\n\\n=begin\\n    :type num: Integer\\n    :rtype: Void\\n=end\\n    def add(num)\\n        stack=[]\\n        p=@head\\n        while p\\n            p=p.next while p.next && p.next.val < num\\n            stack << p\\n            p=p.down\\n        end\\n        down=nil\\n        need=true\\n        while need && stack.any?\\n            p=stack.pop\\n            p.next=Node.new(num,p.next,down)\\n            down=p.next\\n            need=rand > 0.5\\n        end\\n        @head=Node.new(nil,nil, @head) if need\\n    end\\n\\n\\n=begin\\n    :type num: Integer\\n    :rtype: Boolean\\n=end\\n    def erase(num)\\n        p=@head\\n        found=false\\n        while p\\n            p=p.next while p.next && p.next.val < num\\n            if p.next && p.next.val==num\\n                found=true\\n                p.next=p.next.next\\n            end\\n            p=p.down\\n        end\\n        found\\n    end\\n\\n\\nend\\n\\n# Your Skiplist object will be instantiated and called as such:\\n# obj = Skiplist.new()\\n# param_1 = obj.search(target)\\n# obj.add(num)\\n# param_3 = obj.erase(num)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node\\n    attr_accessor :val, :next, :down\\n    def initialize(val=nil, nxt=nil, down=nil)\\n        @val=val\\n        @next=nxt\\n        @down=down\\n    end\\nend\\n\\n\\nclass Skiplist\\n    def initialize()\\n        @head=Node.new\\n    end\\n\\n\\n=begin\\n    :type target: Integer\\n    :rtype: Boolean\\n=end\\n    def search(target)\\n        p=@head\\n        while p\\n            p=p.next while p.next && p.next.val < target\\n            return true if p.next && p.next.val==target\\n            p=p.down\\n        end\\n        false\\n    end\\n\\n\\n=begin\\n    :type num: Integer\\n    :rtype: Void\\n=end\\n    def add(num)\\n        stack=[]\\n        p=@head\\n        while p\\n            p=p.next while p.next && p.next.val < num\\n            stack << p\\n            p=p.down\\n        end\\n        down=nil\\n        need=true\\n        while need && stack.any?\\n            p=stack.pop\\n            p.next=Node.new(num,p.next,down)\\n            down=p.next\\n            need=rand > 0.5\\n        end\\n        @head=Node.new(nil,nil, @head) if need\\n    end\\n\\n\\n=begin\\n    :type num: Integer\\n    :rtype: Boolean\\n=end\\n    def erase(num)\\n        p=@head\\n        found=false\\n        while p\\n            p=p.next while p.next && p.next.val < num\\n            if p.next && p.next.val==num\\n                found=true\\n                p.next=p.next.next\\n            end\\n            p=p.down\\n        end\\n        found\\n    end\\n\\n\\nend\\n\\n# Your Skiplist object will be instantiated and called as such:\\n# obj = Skiplist.new()\\n# param_1 = obj.search(target)\\n# obj.add(num)\\n# param_3 = obj.erase(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650677,
                "title": "linkedlist-java-solution-285-ms",
                "content": "```\\nclass Skiplist {\\n\\n    private ListNode head;\\n    private int size;\\n    public Skiplist() {\\n        this.head=new ListNode();\\n        this.size=0;\\n    }\\n    \\n    public boolean search(int target) {\\n        \\n      ListNode node=this.head.next;\\n      while(node!=null){\\n        if(node.val==target)\\n          return true;\\n        node=node.next;\\n      }\\n      \\n      return false;\\n    }\\n    \\n    public void add(int num) {\\n        \\n      this.size++;\\n      ListNode node=this.head.next;\\n      if(node==null){\\n        this.head.next=new ListNode(num);\\n        return;\\n      }\\n        \\n      while(node.next!=null){ \\n        node=node.next;\\n      }\\n      node.next=new ListNode(num);\\n    }\\n    \\n    public boolean erase(int num) {\\n        \\n      ListNode node=this.head.next;\\n      if(node==null){\\n        return false;\\n      }\\n      \\n      if( num==node.val){\\n        this.head.next=this.head.next.next;\\n        this.size--;\\n        return true;\\n      }\\n        \\n      while(node.next!=null && node.next.next!=null){\\n        if(node.next.val==num)\\n          break;\\n        node=node.next;\\n      }\\n      if(node.next!=null && node.next.next!=null){\\n        node.next=node.next.next;\\n        this.size--;\\n        return true;\\n      } \\n      if(node.next!=null && node.next.val==num){\\n        node.next=null;\\n        this.size--;\\n        return true;\\n      }\\n        \\n      return false;\\n    }\\n}\\nclass ListNode {\\n  public int val;\\n  public ListNode next;\\n  public ListNode(){}\\n  public ListNode(int val){\\n    this.val=val;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Skiplist {\\n\\n    private ListNode head;\\n    private int size;\\n    public Skiplist() {\\n        this.head=new ListNode();\\n        this.size=0;\\n    }\\n    \\n    public boolean search(int target) {\\n        \\n      ListNode node=this.head.next;\\n      while(node!=null){\\n        if(node.val==target)\\n          return true;\\n        node=node.next;\\n      }\\n      \\n      return false;\\n    }\\n    \\n    public void add(int num) {\\n        \\n      this.size++;\\n      ListNode node=this.head.next;\\n      if(node==null){\\n        this.head.next=new ListNode(num);\\n        return;\\n      }\\n        \\n      while(node.next!=null){ \\n        node=node.next;\\n      }\\n      node.next=new ListNode(num);\\n    }\\n    \\n    public boolean erase(int num) {\\n        \\n      ListNode node=this.head.next;\\n      if(node==null){\\n        return false;\\n      }\\n      \\n      if( num==node.val){\\n        this.head.next=this.head.next.next;\\n        this.size--;\\n        return true;\\n      }\\n        \\n      while(node.next!=null && node.next.next!=null){\\n        if(node.next.val==num)\\n          break;\\n        node=node.next;\\n      }\\n      if(node.next!=null && node.next.next!=null){\\n        node.next=node.next.next;\\n        this.size--;\\n        return true;\\n      } \\n      if(node.next!=null && node.next.val==num){\\n        node.next=null;\\n        this.size--;\\n        return true;\\n      }\\n        \\n      return false;\\n    }\\n}\\nclass ListNode {\\n  public int val;\\n  public ListNode next;\\n  public ListNode(){}\\n  public ListNode(int val){\\n    this.val=val;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2624251,
                "title": "c-fast-and-easy",
                "content": "```\\nclass Skiplist {\\npublic:\\n  struct Node{\\n    int val, count;\\n    Node * next;\\n    Node(int v, Node* n){val = v, count = 1, next = n;} \\n  };\\n  vector<Node*> table;\\n    \\n  bool search(int target) {\\n    int id = target>>6;\\n    Node *p = table[id];\\n    \\n    while(p)\\n      if(p->val == target) return true;\\n      else p = p->next;\\n    \\n    return false;\\n  }\\n    \\n  void add(int num) {\\n    int id = num>>6;\\n    if(id >= table.size()) for(int i = table.size(); i <= id; i++) table.push_back(new Node(-1, NULL));\\n    Node* p = table[id];\\n    \\n    while(p->next)\\n      if(p->next->val == num) {p->next->count++; return;}\\n      else if(p->next->val < num) p = p->next;\\n            else{p->next = new Node(num, p->next); return;}\\n    \\n    p->next = new Node(num, NULL);\\n  }\\n    \\n  bool erase(int num) {\\n    int id = num>>6;\\n    Node* p = table[id];\\n   \\n    while(p->next)\\n      if(p->next->val == num){\\n        if(--p->next->count == 0) p->next = p->next->next;\\n        return true;\\n      }\\n      else if(p->next->val > num) return false;\\n           else p = p->next;\\n    \\n    return false;\\n  }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Skiplist {\\npublic:\\n  struct Node{\\n    int val, count;\\n    Node * next;\\n    Node(int v, Node* n){val = v, count = 1, next = n;} \\n  };\\n  vector<Node*> table;\\n    \\n  bool search(int target) {\\n    int id = target>>6;\\n    Node *p = table[id];\\n    \\n    while(p)\\n      if(p->val == target) return true;\\n      else p = p->next;\\n    \\n    return false;\\n  }\\n    \\n  void add(int num) {\\n    int id = num>>6;\\n    if(id >= table.size()) for(int i = table.size(); i <= id; i++) table.push_back(new Node(-1, NULL));\\n    Node* p = table[id];\\n    \\n    while(p->next)\\n      if(p->next->val == num) {p->next->count++; return;}\\n      else if(p->next->val < num) p = p->next;\\n            else{p->next = new Node(num, p->next); return;}\\n    \\n    p->next = new Node(num, NULL);\\n  }\\n    \\n  bool erase(int num) {\\n    int id = num>>6;\\n    Node* p = table[id];\\n   \\n    while(p->next)\\n      if(p->next->val == num){\\n        if(--p->next->count == 0) p->next = p->next->next;\\n        return true;\\n      }\\n      else if(p->next->val > num) return false;\\n           else p = p->next;\\n    \\n    return false;\\n  }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2588021,
                "title": "c-easy-code",
                "content": "```\\n\\nclass Skiplist {\\npublic:\\n    map<int,int>s;\\n    Skiplist() {\\n        \\n    }\\n    \\n    bool search(int target) {\\n        if(s.find(target)!=s.end())\\n            return true;\\n        else \\n            return false;\\n    }\\n    \\n    void add(int num) {\\n        s[num]++;\\n    }\\n    \\n    bool erase(int num) {\\n        if(s.find(num)==s.end())\\n            return false;\\n        else{\\n            s[num]--;\\n            if(s[num]==0)\\n                s.erase(num);\\n            return true;\\n        }\\n    }\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */",
                "solutionTags": [],
                "code": "```\\n\\nclass Skiplist {\\npublic:\\n    map<int,int>s;\\n    Skiplist() {\\n        \\n    }\\n    \\n    bool search(int target) {\\n        if(s.find(target)!=s.end())\\n            return true;\\n        else \\n            return false;\\n    }\\n    \\n    void add(int num) {\\n        s[num]++;\\n    }\\n    \\n    bool erase(int num) {\\n        if(s.find(num)==s.end())\\n            return false;\\n        else{\\n            s[num]--;\\n            if(s[num]==0)\\n                s.erase(num);\\n            return true;\\n        }\\n    }\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 2572857,
                "title": "python-solution-two-next-for-each-listnode",
                "content": "```\\nimport random\\nclass ListNode:\\n    def __init__(self, val, right, down):\\n        self.val = val\\n        self.right = right\\n        self.down = down\\n\\nclass Skiplist:\\n    # We can initialize head with a list of ListNodes that points to None\\n    # From the wikipedia demonstration, we want each node to have two pointers:\\n    # one to the next level (down), one to the next node at the same level (right)\\n    # In all three functions, it will be handy to record all the nodes on the trace path\\n    # To facilitate the erase function, the path node I chose was the one just before a search match (if match exist)\\n    \\n    def __init__(self):\\n        self.head = [ListNode(-1, None, None) for i in range(16)]\\n        for j in range(15,0,-1):\\n            self.head[j].down = self.head[j-1]\\n\\n    def search_path(self, num):\\n        cur = self.head[15]\\n        nodes = []\\n        while cur:\\n            while cur.right and cur.right.val < num:\\n                cur = cur.right\\n            nodes.append(cur)\\n            cur = cur.down\\n        return nodes\\n        \\n    def search(self, target: int) -> bool:\\n        path = self.search_path(target)\\n        return path[-1].right and path[-1].right.val == target\\n    \\n    def add(self, num: int) -> None:\\n        path = self.search_path(num)\\n        j, seed = len(path)-1, 2\\n        while j >= 0 and seed > 0.5:\\n            new_node = ListNode(num, None, None)\\n            new_node.right, path[j].right = path[j].right, new_node\\n            if seed <= 1:\\n                new_node.down = prev\\n            prev, seed = new_node, random.random()\\n            j -= 1\\n        \\n    def erase(self, num: int) -> bool:\\n        if not self.search(num):\\n            return False\\n        path = self.search_path(num)\\n        j = len(path)-1\\n        while j >= 0:\\n            if path[j].right:\\n                old_node = path[j].right\\n                path[j].right = old_node.right\\n                del old_node\\n            j -= 1\\n        return True\\n\\n# Your Skiplist object will be instantiated and called as such:\\n# obj = Skiplist()\\n# param_1 = obj.search(target)\\n# obj.add(num)\\n# param_3 = obj.erase(num)\\n```",
                "solutionTags": [],
                "code": "```\\nimport random\\nclass ListNode:\\n    def __init__(self, val, right, down):\\n        self.val = val\\n        self.right = right\\n        self.down = down\\n\\nclass Skiplist:\\n    # We can initialize head with a list of ListNodes that points to None\\n    # From the wikipedia demonstration, we want each node to have two pointers:\\n    # one to the next level (down), one to the next node at the same level (right)\\n    # In all three functions, it will be handy to record all the nodes on the trace path\\n    # To facilitate the erase function, the path node I chose was the one just before a search match (if match exist)\\n    \\n    def __init__(self):\\n        self.head = [ListNode(-1, None, None) for i in range(16)]\\n        for j in range(15,0,-1):\\n            self.head[j].down = self.head[j-1]\\n\\n    def search_path(self, num):\\n        cur = self.head[15]\\n        nodes = []\\n        while cur:\\n            while cur.right and cur.right.val < num:\\n                cur = cur.right\\n            nodes.append(cur)\\n            cur = cur.down\\n        return nodes\\n        \\n    def search(self, target: int) -> bool:\\n        path = self.search_path(target)\\n        return path[-1].right and path[-1].right.val == target\\n    \\n    def add(self, num: int) -> None:\\n        path = self.search_path(num)\\n        j, seed = len(path)-1, 2\\n        while j >= 0 and seed > 0.5:\\n            new_node = ListNode(num, None, None)\\n            new_node.right, path[j].right = path[j].right, new_node\\n            if seed <= 1:\\n                new_node.down = prev\\n            prev, seed = new_node, random.random()\\n            j -= 1\\n        \\n    def erase(self, num: int) -> bool:\\n        if not self.search(num):\\n            return False\\n        path = self.search_path(num)\\n        j = len(path)-1\\n        while j >= 0:\\n            if path[j].right:\\n                old_node = path[j].right\\n                path[j].right = old_node.right\\n                del old_node\\n            j -= 1\\n        return True\\n\\n# Your Skiplist object will be instantiated and called as such:\\n# obj = Skiplist()\\n# param_1 = obj.search(target)\\n# obj.add(num)\\n# param_3 = obj.erase(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2564481,
                "title": "javascript-180-350ms-runtime-55mem",
                "content": "References:\\nhttps://opendatastructures.org/newhtml/ods/latex/skiplists.html\\nhttps://igoro.com/archive/skip-lists-are-fascinating/\\n\\n\\n```\\nclass Skiplist {\\n  constructor() {\\n    this.head = {val: 0, next: new Array(16).fill(null)};\\n    this.levels = 1;\\n  }\\n\\n  add(num) {\\n    let level = 0;\\n    while (Math.random() * 2 | 0) {\\n      level++;\\n      if (level === this.levels) {\\n        this.levels++;\\n        break;\\n      }\\n    }\\n\\n    const node = {val: num, next: new Array(level + 1).fill(null)};\\n    let head = this.head;\\n    for (let i = this.levels - 1; i >= 0; i--) {\\n      while (head.next[i] !== null && head.next[i].val < num) {\\n        head = head.next[i];\\n      }\\n      if (i <= level) {\\n        node.next[i] = head.next[i];\\n        head.next[i] = node;\\n      }\\n    }\\n  }\\n\\n  erase(num) {\\n    let erased = false;\\n    let head = this.head;\\n    for (let i = this.levels - 1; i >= 0; i--) {\\n      while (head.next[i] !== null) {\\n        const val = head.next[i].val;\\n        if (val > num) break;\\n        if (val === num) {\\n          head.next[i] = head.next[i].next[i];\\n          erased = true;\\n          break;\\n        }\\n        head = head.next[i];\\n      }\\n    }\\n    return erased;\\n  }\\n\\n  search(target) {\\n    let head = this.head;\\n    for (let i = this.levels - 1; i >= 0; i--) {\\n      while (head.next[i] !== null) {\\n        const val = head.next[i].val;\\n        if (val > target) break;\\n        if (val === target) return true;\\n        head = head.next[i];\\n      }\\n    }\\n    return false;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Skiplist {\\n  constructor() {\\n    this.head = {val: 0, next: new Array(16).fill(null)};\\n    this.levels = 1;\\n  }\\n\\n  add(num) {\\n    let level = 0;\\n    while (Math.random() * 2 | 0) {\\n      level++;\\n      if (level === this.levels) {\\n        this.levels++;\\n        break;\\n      }\\n    }\\n\\n    const node = {val: num, next: new Array(level + 1).fill(null)};\\n    let head = this.head;\\n    for (let i = this.levels - 1; i >= 0; i--) {\\n      while (head.next[i] !== null && head.next[i].val < num) {\\n        head = head.next[i];\\n      }\\n      if (i <= level) {\\n        node.next[i] = head.next[i];\\n        head.next[i] = node;\\n      }\\n    }\\n  }\\n\\n  erase(num) {\\n    let erased = false;\\n    let head = this.head;\\n    for (let i = this.levels - 1; i >= 0; i--) {\\n      while (head.next[i] !== null) {\\n        const val = head.next[i].val;\\n        if (val > num) break;\\n        if (val === num) {\\n          head.next[i] = head.next[i].next[i];\\n          erased = true;\\n          break;\\n        }\\n        head = head.next[i];\\n      }\\n    }\\n    return erased;\\n  }\\n\\n  search(target) {\\n    let head = this.head;\\n    for (let i = this.levels - 1; i >= 0; i--) {\\n      while (head.next[i] !== null) {\\n        const val = head.next[i].val;\\n        if (val > target) break;\\n        if (val === target) return true;\\n        head = head.next[i];\\n      }\\n    }\\n    return false;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2356192,
                "title": "rust-use-vec-rc-refcell",
                "content": "There may be redundant clone and borrow ...\\n```\\nuse std::{cell::RefCell, rc::Rc, vec};\\n\\nuse rand::Rng;\\n\\nconst MAX_LEVEL: usize = 32;\\nconst P_FACTOR: f64 = 0.25;\\n\\ntype Link = Option<Rc<RefCell<Node>>>;\\n\\nfn new_link(value: i32, level: usize) -> Link {\\n    Some(Rc::new(RefCell::new(Node::new(value, level))))\\n}\\n\\nfn random_level() -> usize {\\n    let mut level = 1;\\n    let mut rng = rand::thread_rng();\\n    while level < MAX_LEVEL && rng.gen::<f64>() < P_FACTOR {\\n        level += 1;\\n    }\\n    level\\n}\\n\\n#[derive(Debug, Default)]\\npub struct Node {\\n    val: i32,\\n    level: usize,\\n    forward: Vec<Link>,\\n}\\n\\nimpl PartialEq for Node {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.val == other.val && self.forward.len() == other.forward.len()\\n    }\\n}\\n\\nimpl Node {\\n    pub fn new(value: i32, level: usize) -> Node {\\n        Node {\\n            val: value,\\n            level: level,\\n            forward: vec![None; level],\\n        }\\n    }\\n}\\n\\n#[derive(Debug, Default)]\\npub struct Skiplist {\\n    head: Link,\\n    level: usize,\\n}\\n\\nimpl Skiplist {\\n    pub fn new() -> Self {\\n        Skiplist {\\n            head: new_link(-1, MAX_LEVEL),\\n            ..Default::default()\\n        }\\n    }\\n\\n    pub fn search(&self, target: i32) -> bool {\\n        let mut cur = self.head.clone().unwrap();\\n        for i in (0..self.level).rev() {\\n            loop {\\n                match cur.clone().borrow().forward[i].clone() {\\n                    Some(node) => {\\n                        if node.borrow().val < target {\\n                            cur = node;\\n                            continue;\\n                        }\\n                        break;\\n                    }\\n                    None => break,\\n                }\\n            }\\n        }\\n        match cur.clone().borrow().forward[0].clone() {\\n            Some(node) => {\\n                if node.borrow().val == target {\\n                    return true;\\n                }\\n                false\\n            }\\n            None => false,\\n        }\\n    }\\n\\n    pub fn add(&mut self, num: i32) {\\n        let mut cur = self.head.clone().unwrap();\\n        let mut update = vec![Some(cur.clone()); MAX_LEVEL];\\n        for i in (0..self.level).rev() {\\n            loop {\\n                match cur.clone().borrow().forward[i].clone() {\\n                    Some(node) => {\\n                        if node.borrow().val < num {\\n                            cur = node;\\n                            continue;\\n                        }\\n                        break;\\n                    }\\n                    None => break,\\n                }\\n            }\\n            update[i] = Some(cur.clone());\\n        }\\n        let level = random_level();\\n        self.level = self.level.max(level);\\n        let node = new_link(num, level);\\n        for i in 0..level {\\n            node.as_ref().unwrap().borrow_mut().forward[i] =\\n                update[i].as_ref().unwrap().borrow().forward[i].clone();\\n            update[i].as_ref().unwrap().borrow_mut().forward[i] = node.clone();\\n        }\\n    }\\n\\n    pub fn erase(&mut self, num: i32) -> bool {\\n        let mut cur = self.head.clone().unwrap();\\n        let mut update: Vec<Link> = vec![None; MAX_LEVEL];\\n        for i in (0..self.level).rev() {\\n            loop {\\n                match cur.clone().borrow().forward[i].clone() {\\n                    Some(node) => {\\n                        if node.borrow().val < num {\\n                            cur = node;\\n                            continue;\\n                        }\\n                        break;\\n                    }\\n                    None => break,\\n                }\\n            }\\n            update[i] = Some(cur.clone());\\n        }\\n        let cur = cur.clone().borrow().forward[0].clone();\\n        match cur.clone() {\\n            Some(node) => {\\n                if node.borrow().val != num {\\n                    return false;\\n                }\\n            }\\n            None => return false,\\n        };\\n\\n        for i in 0..self.level {\\n            if update[i].clone().unwrap().borrow().forward[i] != cur.clone() {\\n                break;\\n            }\\n            update[i].clone().unwrap().borrow_mut().forward[i] =\\n                cur.clone().unwrap().borrow().forward[i].clone();\\n        }\\n        while self.level > 1\\n            && self.head.clone().unwrap().borrow().forward[self.level - 1].is_none()\\n        {\\n            self.level -= 1;\\n        }\\n\\n        return true;\\n    }\\n\\n    pub fn debug(&self) {\\n        let head = self.head.clone().unwrap();\\n        let mut table: Vec<Vec<(i32, usize, usize)>> = vec![\\n            vec![(\\n                head.borrow().val,\\n                head.borrow().level,\\n                head.borrow().forward.len()\\n            )];\\n            self.level\\n        ];\\n\\n        for i in (0..self.level).rev() {\\n            let mut node = head.clone();\\n            loop {\\n                match node.clone().borrow().forward[i].clone() {\\n                    Some(tmp) => {\\n                        table[i].push((\\n                            tmp.borrow().val,\\n                            tmp.borrow().level,\\n                            tmp.borrow().forward.len(),\\n                        ));\\n                        node = tmp;\\n                    }\\n                    None => break,\\n                }\\n            }\\n        }\\n        for t in table.iter().rev() {\\n            println!(\"{:?}\", t);\\n        }\\n    }\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n\\n    const N: i32 = 10;\\n    #[test]\\n    fn test_skiplist() {\\n        let mut rng = rand::thread_rng();\\n        let mut skiplist = Skiplist::new();\\n        let mut v = vec![];\\n        for _ in 0..N {\\n            let num = rng.gen_range(0..N);\\n            v.push(num);\\n            skiplist.add(num);\\n        }\\n        skiplist.debug();\\n\\n        for _ in 0..N {\\n            let num = rng.gen_range(0..N);\\n            assert_eq!(v.contains(&num), skiplist.search(num));\\n        }\\n        for _ in 0..N {\\n            let num = rng.gen_range(0..N);\\n            println!(\"=====\");\\n            println!(\"{}\", num);\\n            match v.iter().position(|&x| x == num) {\\n                Some(index) => {\\n                    assert!(skiplist.erase(num));\\n                    v.remove(index);\\n                }\\n                None => assert!(!skiplist.erase(num)),\\n            }\\n            skiplist.debug()\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::{cell::RefCell, rc::Rc, vec};\\n\\nuse rand::Rng;\\n\\nconst MAX_LEVEL: usize = 32;\\nconst P_FACTOR: f64 = 0.25;\\n\\ntype Link = Option<Rc<RefCell<Node>>>;\\n\\nfn new_link(value: i32, level: usize) -> Link {\\n    Some(Rc::new(RefCell::new(Node::new(value, level))))\\n}\\n\\nfn random_level() -> usize {\\n    let mut level = 1;\\n    let mut rng = rand::thread_rng();\\n    while level < MAX_LEVEL && rng.gen::<f64>() < P_FACTOR {\\n        level += 1;\\n    }\\n    level\\n}\\n\\n#[derive(Debug, Default)]\\npub struct Node {\\n    val: i32,\\n    level: usize,\\n    forward: Vec<Link>,\\n}\\n\\nimpl PartialEq for Node {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.val == other.val && self.forward.len() == other.forward.len()\\n    }\\n}\\n\\nimpl Node {\\n    pub fn new(value: i32, level: usize) -> Node {\\n        Node {\\n            val: value,\\n            level: level,\\n            forward: vec![None; level],\\n        }\\n    }\\n}\\n\\n#[derive(Debug, Default)]\\npub struct Skiplist {\\n    head: Link,\\n    level: usize,\\n}\\n\\nimpl Skiplist {\\n    pub fn new() -> Self {\\n        Skiplist {\\n            head: new_link(-1, MAX_LEVEL),\\n            ..Default::default()\\n        }\\n    }\\n\\n    pub fn search(&self, target: i32) -> bool {\\n        let mut cur = self.head.clone().unwrap();\\n        for i in (0..self.level).rev() {\\n            loop {\\n                match cur.clone().borrow().forward[i].clone() {\\n                    Some(node) => {\\n                        if node.borrow().val < target {\\n                            cur = node;\\n                            continue;\\n                        }\\n                        break;\\n                    }\\n                    None => break,\\n                }\\n            }\\n        }\\n        match cur.clone().borrow().forward[0].clone() {\\n            Some(node) => {\\n                if node.borrow().val == target {\\n                    return true;\\n                }\\n                false\\n            }\\n            None => false,\\n        }\\n    }\\n\\n    pub fn add(&mut self, num: i32) {\\n        let mut cur = self.head.clone().unwrap();\\n        let mut update = vec![Some(cur.clone()); MAX_LEVEL];\\n        for i in (0..self.level).rev() {\\n            loop {\\n                match cur.clone().borrow().forward[i].clone() {\\n                    Some(node) => {\\n                        if node.borrow().val < num {\\n                            cur = node;\\n                            continue;\\n                        }\\n                        break;\\n                    }\\n                    None => break,\\n                }\\n            }\\n            update[i] = Some(cur.clone());\\n        }\\n        let level = random_level();\\n        self.level = self.level.max(level);\\n        let node = new_link(num, level);\\n        for i in 0..level {\\n            node.as_ref().unwrap().borrow_mut().forward[i] =\\n                update[i].as_ref().unwrap().borrow().forward[i].clone();\\n            update[i].as_ref().unwrap().borrow_mut().forward[i] = node.clone();\\n        }\\n    }\\n\\n    pub fn erase(&mut self, num: i32) -> bool {\\n        let mut cur = self.head.clone().unwrap();\\n        let mut update: Vec<Link> = vec![None; MAX_LEVEL];\\n        for i in (0..self.level).rev() {\\n            loop {\\n                match cur.clone().borrow().forward[i].clone() {\\n                    Some(node) => {\\n                        if node.borrow().val < num {\\n                            cur = node;\\n                            continue;\\n                        }\\n                        break;\\n                    }\\n                    None => break,\\n                }\\n            }\\n            update[i] = Some(cur.clone());\\n        }\\n        let cur = cur.clone().borrow().forward[0].clone();\\n        match cur.clone() {\\n            Some(node) => {\\n                if node.borrow().val != num {\\n                    return false;\\n                }\\n            }\\n            None => return false,\\n        };\\n\\n        for i in 0..self.level {\\n            if update[i].clone().unwrap().borrow().forward[i] != cur.clone() {\\n                break;\\n            }\\n            update[i].clone().unwrap().borrow_mut().forward[i] =\\n                cur.clone().unwrap().borrow().forward[i].clone();\\n        }\\n        while self.level > 1\\n            && self.head.clone().unwrap().borrow().forward[self.level - 1].is_none()\\n        {\\n            self.level -= 1;\\n        }\\n\\n        return true;\\n    }\\n\\n    pub fn debug(&self) {\\n        let head = self.head.clone().unwrap();\\n        let mut table: Vec<Vec<(i32, usize, usize)>> = vec![\\n            vec![(\\n                head.borrow().val,\\n                head.borrow().level,\\n                head.borrow().forward.len()\\n            )];\\n            self.level\\n        ];\\n\\n        for i in (0..self.level).rev() {\\n            let mut node = head.clone();\\n            loop {\\n                match node.clone().borrow().forward[i].clone() {\\n                    Some(tmp) => {\\n                        table[i].push((\\n                            tmp.borrow().val,\\n                            tmp.borrow().level,\\n                            tmp.borrow().forward.len(),\\n                        ));\\n                        node = tmp;\\n                    }\\n                    None => break,\\n                }\\n            }\\n        }\\n        for t in table.iter().rev() {\\n            println!(\"{:?}\", t);\\n        }\\n    }\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n\\n    const N: i32 = 10;\\n    #[test]\\n    fn test_skiplist() {\\n        let mut rng = rand::thread_rng();\\n        let mut skiplist = Skiplist::new();\\n        let mut v = vec![];\\n        for _ in 0..N {\\n            let num = rng.gen_range(0..N);\\n            v.push(num);\\n            skiplist.add(num);\\n        }\\n        skiplist.debug();\\n\\n        for _ in 0..N {\\n            let num = rng.gen_range(0..N);\\n            assert_eq!(v.contains(&num), skiplist.search(num));\\n        }\\n        for _ in 0..N {\\n            let num = rng.gen_range(0..N);\\n            println!(\"=====\");\\n            println!(\"{}\", num);\\n            match v.iter().position(|&x| x == num) {\\n                Some(index) => {\\n                    assert!(skiplist.erase(num));\\n                    v.remove(index);\\n                }\\n                None => assert!(!skiplist.erase(num)),\\n            }\\n            skiplist.debug()\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2293231,
                "title": "very-easy-c-solution",
                "content": "\\'\\'\\'\\npublic class Skiplist {\\n\\n     SortedDictionary<int,int> sortedDict = new SortedDictionary<int,int>();\\n    public Skiplist() {\\n        \\n    }\\n    \\n    public bool Search(int target) {\\n        if(sortedDict.ContainsKey(target))\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public void Add(int num) {\\n        \\n        if(sortedDict.ContainsKey(num))\\n        {\\n            sortedDict[num]+=1;\\n        }\\n        else\\n        {\\n            sortedDict.Add(num,1);\\n        }\\n    }\\n    \\n    public bool Erase(int num) {\\n        if(sortedDict.ContainsKey(num))\\n        {\\n            if(sortedDict[num]>1)\\n            {\\n              sortedDict[num]-=1;\\n            }\\n            else\\n            {\\n                sortedDict.Remove(num);\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n",
                "solutionTags": [],
                "code": "\\'\\'\\'\\npublic class Skiplist {\\n\\n     SortedDictionary<int,int> sortedDict = new SortedDictionary<int,int>();\\n    public Skiplist() {\\n        \\n    }\\n    \\n    public bool Search(int target) {\\n        if(sortedDict.ContainsKey(target))\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public void Add(int num) {\\n        \\n        if(sortedDict.ContainsKey(num))\\n        {\\n            sortedDict[num]+=1;\\n        }\\n        else\\n        {\\n            sortedDict.Add(num,1);\\n        }\\n    }\\n    \\n    public bool Erase(int num) {\\n        if(sortedDict.ContainsKey(num))\\n        {\\n            if(sortedDict[num]>1)\\n            {\\n              sortedDict[num]-=1;\\n            }\\n            else\\n            {\\n                sortedDict.Remove(num);\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2253586,
                "title": "a-short-c-implementation",
                "content": "```\\nclass Skiplist {\\nprivate:\\n    struct Node {\\n        int val;\\n        Node(){}\\n        Node(int val){  this->val = val;}\\n        vector<Node*> next;//next[t] points to the next element in the t-th layer\\n    };\\n    Node* head;\\n    void append(Node* prev, int layer, Node* node){\\n        while(node->next.size() <= layer)  node->next.push_back(NULL);\\n        node->next[layer] = prev->next[layer];\\n        prev->next[layer] = node;\\n    }\\n    bool search(Node* prev, int i,int target){\\n        while(prev->next[i] != NULL && prev->next[i]->val < target)   prev = prev->next[i];\\n        if(prev->next[i] != NULL && prev->next[i]->val == target) return true;\\n        if(i > 0)   return search(prev,i-1,target);\\n        return false;\\n    }\\n    bool add(Node *prev, int i, Node *node){\\n        int val = node->val;\\n        while(prev->next[i] != NULL && prev->next[i]->val < val)   prev = prev->next[i];\\n        if(i == 0 || add(prev,i-1,node) && rand()%2 == 1){\\n            append(prev,i,node);\\n            return true;\\n        }else   return false;\\n    }\\n    bool erase(Node *prev, int i, int val){\\n        while(prev->next[i] != NULL && prev->next[i]->val < val)   prev = prev->next[i];\\n        if(i > 0 && erase(prev,i-1,val) == true)    return true;\\n        if(prev->next[i] != NULL && prev->next[i]->val == val){\\n            Node* node = prev->next[i];\\n            prev->next[i] = node->next[i];\\n            if(node->next.size() == i+1){\\n                delete node;\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    Skiplist() {\\n        const int INF = 0x3f3f3f3f;\\n        head = new Node(-INF);\\n        head->next.resize(50);\\n    }\\n    bool search(int target) {\\n        // printf(\"search(%d)\\\\n\",target);\\n        int layers = head->next.size();\\n        return search(head, layers-1,target);\\n        return false;\\n    }\\n    void add(int num) {\\n        // printf(\"add(%d)\\\\n\",num);\\n        int layers = head->next.size();\\n        assert(add(head, layers-1,new Node(num))==false);\\n    }\\n    bool erase(int num) {\\n        // printf(\"erase(%d)\\\\n\",num);\\n        int layers = head->next.size();\\n        return erase(head,layers-1,num);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Skiplist {\\nprivate:\\n    struct Node {\\n        int val;\\n        Node(){}\\n        Node(int val){  this->val = val;}\\n        vector<Node*> next;//next[t] points to the next element in the t-th layer\\n    };\\n    Node* head;\\n    void append(Node* prev, int layer, Node* node){\\n        while(node->next.size() <= layer)  node->next.push_back(NULL);\\n        node->next[layer] = prev->next[layer];\\n        prev->next[layer] = node;\\n    }\\n    bool search(Node* prev, int i,int target){\\n        while(prev->next[i] != NULL && prev->next[i]->val < target)   prev = prev->next[i];\\n        if(prev->next[i] != NULL && prev->next[i]->val == target) return true;\\n        if(i > 0)   return search(prev,i-1,target);\\n        return false;\\n    }\\n    bool add(Node *prev, int i, Node *node){\\n        int val = node->val;\\n        while(prev->next[i] != NULL && prev->next[i]->val < val)   prev = prev->next[i];\\n        if(i == 0 || add(prev,i-1,node) && rand()%2 == 1){\\n            append(prev,i,node);\\n            return true;\\n        }else   return false;\\n    }\\n    bool erase(Node *prev, int i, int val){\\n        while(prev->next[i] != NULL && prev->next[i]->val < val)   prev = prev->next[i];\\n        if(i > 0 && erase(prev,i-1,val) == true)    return true;\\n        if(prev->next[i] != NULL && prev->next[i]->val == val){\\n            Node* node = prev->next[i];\\n            prev->next[i] = node->next[i];\\n            if(node->next.size() == i+1){\\n                delete node;\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    Skiplist() {\\n        const int INF = 0x3f3f3f3f;\\n        head = new Node(-INF);\\n        head->next.resize(50);\\n    }\\n    bool search(int target) {\\n        // printf(\"search(%d)\\\\n\",target);\\n        int layers = head->next.size();\\n        return search(head, layers-1,target);\\n        return false;\\n    }\\n    void add(int num) {\\n        // printf(\"add(%d)\\\\n\",num);\\n        int layers = head->next.size();\\n        assert(add(head, layers-1,new Node(num))==false);\\n    }\\n    bool erase(int num) {\\n        // printf(\"erase(%d)\\\\n\",num);\\n        int layers = head->next.size();\\n        return erase(head,layers-1,num);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2145112,
                "title": "python3-probabalistic-depth-o-lg-n-average-time-ops-o-n-average-space",
                "content": "Worst Case Time: O(N)\\nWorst Cast Space: O(N*lg(N))\\n\\n```\\nimport random\\nclass Skiplist:\\n\\n    def __init__(self):\\n        random.seed()\\n        self.levels = 0\\n        self.head = None\\n        \\n\\n    def search(self, target: int) -> bool:\\n        cur = self.head\\n        while cur:\\n            if cur.next and cur.next.val < target:\\n                cur = cur.next\\n            elif cur.next and cur.next.val == target:\\n                return True\\n            else:\\n                cur = cur.down\\n        return False\\n        \\n\\n    def add(self, num: int) -> None:\\n        \\n        insertLevel = 1\\n        while random.randint(0,1):\\n            insertLevel += 1\\n        while self.levels <= insertLevel:\\n            self.head = Skiplist.Node(down = self.head)\\n            self.levels += 1\\n        \\n        cur, curLevel, above = self.head, self.levels, None\\n        while cur:\\n            if cur.next and cur.next.val < num: \\n                cur = cur.next\\n            elif curLevel <= insertLevel:\\n                newNode = Skiplist.Node(num)\\n                newNode.next, cur.next = cur.next, newNode\\n                if above:\\n                    above.down = newNode\\n                cur, above = cur.down, newNode\\n            else:\\n                cur = cur.down\\n                curLevel -= 1\\n\\n    def erase(self, num: int) -> bool:\\n        \\n        cur, existed = self.head, False\\n        while cur:\\n            if cur.next and cur.next.val < num:\\n                cur = cur.next\\n            elif cur.next and cur.next.val == num:\\n                cur.next, cur, existed = cur.next.next, cur.down, True\\n            else:\\n                cur = cur.down\\n        return existed\\n        \\n        \\n    class Node:\\n        def __init__(self, val=-float(\"inf\"),next = None, down = None):\\n            self.val = val\\n            self.next = next\\n            self.down = down\\n\\t```",
                "solutionTags": [],
                "code": "```\\nimport random\\nclass Skiplist:\\n\\n    def __init__(self):\\n        random.seed()\\n        self.levels = 0\\n        self.head = None\\n        \\n\\n    def search(self, target: int) -> bool:\\n        cur = self.head\\n        while cur:\\n            if cur.next and cur.next.val < target:\\n                cur = cur.next\\n            elif cur.next and cur.next.val == target:\\n                return True\\n            else:\\n                cur = cur.down\\n        return False\\n        \\n\\n    def add(self, num: int) -> None:\\n        \\n        insertLevel = 1\\n        while random.randint(0,1):\\n            insertLevel += 1\\n        while self.levels <= insertLevel:\\n            self.head = Skiplist.Node(down = self.head)\\n            self.levels += 1\\n        \\n        cur, curLevel, above = self.head, self.levels, None\\n        while cur:\\n            if cur.next and cur.next.val < num: \\n                cur = cur.next\\n            elif curLevel <= insertLevel:\\n                newNode = Skiplist.Node(num)\\n                newNode.next, cur.next = cur.next, newNode\\n                if above:\\n                    above.down = newNode\\n                cur, above = cur.down, newNode\\n            else:\\n                cur = cur.down\\n                curLevel -= 1\\n\\n    def erase(self, num: int) -> bool:\\n        \\n        cur, existed = self.head, False\\n        while cur:\\n            if cur.next and cur.next.val < num:\\n                cur = cur.next\\n            elif cur.next and cur.next.val == num:\\n                cur.next, cur, existed = cur.next.next, cur.down, True\\n            else:\\n                cur = cur.down\\n        return existed\\n        \\n        \\n    class Node:\\n        def __init__(self, val=-float(\"inf\"),next = None, down = None):\\n            self.val = val\\n            self.next = next\\n            self.down = down\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2013671,
                "title": "python-node-with-next-and-down-pointers-clean-code",
                "content": "based on https://leetcode.com/problems/design-skiplist/discuss/394679/Python-the-%22down%22-pointer-of-each-node-must-point-to-node-of-same-value-in-the-next-level\\n\\n```\\nfrom random import random\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.next = None\\n        self.down = None\\n        \\nclass Skiplist:\\n\\n    def __init__(self):\\n        self.MAXLEVEL = 32\\n        self.levels = [Node(float(\\'-inf\\')) for i in range(self.MAXLEVEL)]\\n        for i in range(self.MAXLEVEL-1):\\n            self.levels[i].down = self.levels[i+1]\\n    \\n    def _iter(self, val):\\n        res = []\\n        l = self.levels[0]\\n        while l:\\n            while l.next and l.next.val < val:\\n                l = l.next\\n            res.append(l)\\n            l = l.down\\n        return res\\n    \\n    def search(self, target: int) -> bool:\\n        last = self._iter(target)[-1]\\n        return last.next and last.next.val == target\\n\\n    def add(self, num: int) -> None:\\n        res = self._iter(num)\\n        prev = None\\n        for i in range(self.MAXLEVEL-1,-1,-1):\\n            node = Node(num)\\n            node.next, node.down = res[i].next, prev\\n            res[i].next = node\\n            prev = node\\n            rand = random()\\n            if rand < 0.5:\\n                break\\n\\n    def erase(self, num: int) -> bool:\\n        res = self._iter(num)\\n        for i in range(self.MAXLEVEL):\\n            if res[i].next and res[i].next.val == num:\\n                res[i].next = res[i].next.next\\n                if i==self.MAXLEVEL-1: return True\\n        return False",
                "solutionTags": [],
                "code": "based on https://leetcode.com/problems/design-skiplist/discuss/394679/Python-the-%22down%22-pointer-of-each-node-must-point-to-node-of-same-value-in-the-next-level\\n\\n```\\nfrom random import random\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.next = None\\n        self.down = None\\n        \\nclass Skiplist:\\n\\n    def __init__(self):\\n        self.MAXLEVEL = 32\\n        self.levels = [Node(float(\\'-inf\\')) for i in range(self.MAXLEVEL)]\\n        for i in range(self.MAXLEVEL-1):\\n            self.levels[i].down = self.levels[i+1]\\n    \\n    def _iter(self, val):\\n        res = []\\n        l = self.levels[0]\\n        while l:\\n            while l.next and l.next.val < val:\\n                l = l.next\\n            res.append(l)\\n            l = l.down\\n        return res\\n    \\n    def search(self, target: int) -> bool:\\n        last = self._iter(target)[-1]\\n        return last.next and last.next.val == target\\n\\n    def add(self, num: int) -> None:\\n        res = self._iter(num)\\n        prev = None\\n        for i in range(self.MAXLEVEL-1,-1,-1):\\n            node = Node(num)\\n            node.next, node.down = res[i].next, prev\\n            res[i].next = node\\n            prev = node\\n            rand = random()\\n            if rand < 0.5:\\n                break\\n\\n    def erase(self, num: int) -> bool:\\n        res = self._iter(num)\\n        for i in range(self.MAXLEVEL):\\n            if res[i].next and res[i].next.val == num:\\n                res[i].next = res[i].next.next\\n                if i==self.MAXLEVEL-1: return True\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 1968109,
                "title": "c-simple-solution-using-vector-one-line-code-for-each",
                "content": "```\\n    vector<int>v;\\n    Skiplist() {\\n        v.resize(100005,0);\\n    }\\n    \\n    bool search(int target) {\\n        return v[target];\\n    }\\n    \\n    void add(int num) {\\n        v[num]++;\\n    }\\n    \\n    bool erase(int num) {\\n        bool flag;\\n        if(v[num]>0)\\n        {\\n            flag=true;\\n            v[num]--;\\n        }\\n        else\\n            flag=false;\\n        return flag;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<int>v;\\n    Skiplist() {\\n        v.resize(100005,0);\\n    }\\n    \\n    bool search(int target) {\\n        return v[target];\\n    }\\n    \\n    void add(int num) {\\n        v[num]++;\\n    }\\n    \\n    bool erase(int num) {\\n        bool flag;\\n        if(v[num]>0)\\n        {\\n            flag=true;\\n            v[num]--;\\n        }\\n        else\\n            flag=false;\\n        return flag;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1957448,
                "title": "python-solution",
                "content": "```\\nclass Node:\\n    def __init__(self, val):\\n        self.val=val\\n        self.right=None\\n        self.left=None\\n        self.down=None\\n    \\nclass Skiplist:\\n\\n    def __init__(self):\\n        self.skiplist=[]\\n        for i in range(16):\\n            s1=Node(-1)\\n            s2=Node(20007)\\n            s1.right=s2\\n            s2.left=s1\\n            self.skiplist.append(s1);\\n        for i in range(0,15):\\n            self.skiplist[i].down=self.skiplist[i+1]\\n            self.skiplist[i].right.down=self.skiplist[i+1].right\\n\\n    def search(self, target: int) -> bool:\\n        start_node=self.skiplist[0]\\n        while start_node is not None:\\n            if start_node.right.val < target:\\n                start_node=start_node.right\\n            elif start_node.right.val > target:\\n                start_node=start_node.down\\n            else:\\n                return True\\n        return False\\n                \\n\\n    def add(self, num: int) -> None:\\n        start_node=self.skiplist[0]\\n        prev_pointer_list=[]\\n        while start_node is not None:\\n            if start_node.right.val < num:\\n                start_node=start_node.right\\n            else:\\n                prev_pointer_list.append(start_node)\\n                start_node=start_node.down\\n        \\n        l=len(prev_pointer_list)\\n        prev_y=None\\n        for i in range(l-1, -1, -1):\\n            x=prev_pointer_list[i]\\n            z=x.right\\n            y=Node(num)\\n            y.left=x\\n            y.right=z\\n            x.right=y\\n            y.down=prev_y\\n            z.left=y\\n            prev_y=y\\n            toss=random.randint(0,2)\\n            if toss==0:\\n                break\\n        \\n        \\n    def erase(self, num: int) -> bool:\\n        start_node=self.skiplist[0]\\n        pointer_list=[]\\n        while start_node is not None:\\n            if start_node.right.val < num:\\n                start_node=start_node.right\\n            else:\\n                if start_node.right.val == num:\\n                    pointer_list.append(start_node.right)\\n                start_node=start_node.down\\n\\n        l=len(pointer_list)\\n        for i in range(l-1, -1, -1):\\n            x=pointer_list[i]\\n            p=x.left\\n            n=x.right\\n            p.right=n\\n            n.left=p\\n        \\n        return len(pointer_list)>0\\n\\n# Your Skiplist object will be instantiated and called as such:\\n# obj = Skiplist()\\n# param_1 = obj.search(target)\\n# obj.add(num)\\n# param_3 = obj.erase(num)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, val):\\n        self.val=val\\n        self.right=None\\n        self.left=None\\n        self.down=None\\n    \\nclass Skiplist:\\n\\n    def __init__(self):\\n        self.skiplist=[]\\n        for i in range(16):\\n            s1=Node(-1)\\n            s2=Node(20007)\\n            s1.right=s2\\n            s2.left=s1\\n            self.skiplist.append(s1);\\n        for i in range(0,15):\\n            self.skiplist[i].down=self.skiplist[i+1]\\n            self.skiplist[i].right.down=self.skiplist[i+1].right\\n\\n    def search(self, target: int) -> bool:\\n        start_node=self.skiplist[0]\\n        while start_node is not None:\\n            if start_node.right.val < target:\\n                start_node=start_node.right\\n            elif start_node.right.val > target:\\n                start_node=start_node.down\\n            else:\\n                return True\\n        return False\\n                \\n\\n    def add(self, num: int) -> None:\\n        start_node=self.skiplist[0]\\n        prev_pointer_list=[]\\n        while start_node is not None:\\n            if start_node.right.val < num:\\n                start_node=start_node.right\\n            else:\\n                prev_pointer_list.append(start_node)\\n                start_node=start_node.down\\n        \\n        l=len(prev_pointer_list)\\n        prev_y=None\\n        for i in range(l-1, -1, -1):\\n            x=prev_pointer_list[i]\\n            z=x.right\\n            y=Node(num)\\n            y.left=x\\n            y.right=z\\n            x.right=y\\n            y.down=prev_y\\n            z.left=y\\n            prev_y=y\\n            toss=random.randint(0,2)\\n            if toss==0:\\n                break\\n        \\n        \\n    def erase(self, num: int) -> bool:\\n        start_node=self.skiplist[0]\\n        pointer_list=[]\\n        while start_node is not None:\\n            if start_node.right.val < num:\\n                start_node=start_node.right\\n            else:\\n                if start_node.right.val == num:\\n                    pointer_list.append(start_node.right)\\n                start_node=start_node.down\\n\\n        l=len(pointer_list)\\n        for i in range(l-1, -1, -1):\\n            x=pointer_list[i]\\n            p=x.left\\n            n=x.right\\n            p.right=n\\n            n.left=p\\n        \\n        return len(pointer_list)>0\\n\\n# Your Skiplist object will be instantiated and called as such:\\n# obj = Skiplist()\\n# param_1 = obj.search(target)\\n# obj.add(num)\\n# param_3 = obj.erase(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859822,
                "title": "expected-behavior-on-erase-for-duplicates",
                "content": "The instructions do not indicate how erasing of duplicates is supposed to happen.  I am seeing failure on searching for a number that was previously added twice.  If there are duplicates, shouldn\\'t erase remove both?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1791609,
                "title": "skip-list-clean-c-code",
                "content": "```\\nclass Skiplist {\\n    private:\\n    const int kMaxHeight=8;\\n    struct Node{\\n        int val;\\n        int height;\\n        Node** next;\\n        Node(int v, int h) { //constructor\\n            val = v;\\n            height = h;\\n            next = new Node*[h];\\n            while (--h >= 0) next[h] = NULL;\\n        }\\n        ~Node() { delete [] next;} //destructor\\n    };\\n    int getRandomHeight() {\\n        int h = 1;\\n        while (h<kMaxHeight and rand()%4 == 1) ++h;\\n        return h;\\n    }\\n    Node* findGreaterOrEqual(int target, Node** prev){\\n        Node* it = head;\\n        int level = kMaxHeight-1;\\n        while (true){\\n            Node* next = it->next[level];\\n            if (next and next->val < target) it = next;\\n            else{\\n                if (prev)  prev[level] = it;\\n                if (!level) return next; else --level;\\n            }\\n        }\\n    }\\n    Node* head; \\n    public:\\n    Skiplist() { head = new Node(0, kMaxHeight);}\\n    bool search(int target) {\\n        Node* node = findGreaterOrEqual(target, NULL);\\n        return node and node->val == target;\\n    }\\n    void add(int num){\\n        Node* prev[kMaxHeight];\\n        findGreaterOrEqual(num, prev);\\n        Node* node = new Node(num, getRandomHeight());  \\n        for (int i = 0; i < node->height; ++i) {\\n            node->next[i] = prev[i]->next[i];\\n            prev[i]->next[i] = node;\\n        }\\n    }\\n    bool erase(int num) {\\n        Node* prev[kMaxHeight];\\n        Node* to_del = findGreaterOrEqual(num, prev);\\n        if (!to_del or to_del->val != num) return false;\\n        for (int i = 0; i < to_del->height; ++i) prev[i]->next[i] = to_del->next[i];\\n        delete to_del;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Skiplist {\\n    private:\\n    const int kMaxHeight=8;\\n    struct Node{\\n        int val;\\n        int height;\\n        Node** next;\\n        Node(int v, int h) { //constructor\\n            val = v;\\n            height = h;\\n            next = new Node*[h];\\n            while (--h >= 0) next[h] = NULL;\\n        }\\n        ~Node() { delete [] next;} //destructor\\n    };\\n    int getRandomHeight() {\\n        int h = 1;\\n        while (h<kMaxHeight and rand()%4 == 1) ++h;\\n        return h;\\n    }\\n    Node* findGreaterOrEqual(int target, Node** prev){\\n        Node* it = head;\\n        int level = kMaxHeight-1;\\n        while (true){\\n            Node* next = it->next[level];\\n            if (next and next->val < target) it = next;\\n            else{\\n                if (prev)  prev[level] = it;\\n                if (!level) return next; else --level;\\n            }\\n        }\\n    }\\n    Node* head; \\n    public:\\n    Skiplist() { head = new Node(0, kMaxHeight);}\\n    bool search(int target) {\\n        Node* node = findGreaterOrEqual(target, NULL);\\n        return node and node->val == target;\\n    }\\n    void add(int num){\\n        Node* prev[kMaxHeight];\\n        findGreaterOrEqual(num, prev);\\n        Node* node = new Node(num, getRandomHeight());  \\n        for (int i = 0; i < node->height; ++i) {\\n            node->next[i] = prev[i]->next[i];\\n            prev[i]->next[i] = node;\\n        }\\n    }\\n    bool erase(int num) {\\n        Node* prev[kMaxHeight];\\n        Node* to_del = findGreaterOrEqual(num, prev);\\n        if (!to_del or to_del->val != num) return false;\\n        for (int i = 0; i < to_del->height; ++i) prev[i]->next[i] = to_del->next[i];\\n        delete to_del;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640903,
                "title": "py3-skiplist",
                "content": "```\\nclass Node:\\n    def __init__(self, key, level):\\n        self.key = key\\n        self.count = 1\\n        self.level = level\\n        self.nxt = [None for _ in range(level)]\\n        \\nclass Skiplist:\\n\\n    def __init__(self):\\n        self.maxlevel = pow(2,5)\\n        self.curlevel = -1\\n        self.head = Node(-1, self.maxlevel)\\n\\n    def predecessor(self, K: int) -> Node:\\n        curr = self.head\\n        pred = [curr for _ in range(self.maxlevel)]\\n        \\n        for l in range(self.curlevel, -1, -1):\\n            while curr.nxt[l] and curr.nxt[l].key < K:\\n                curr = curr.nxt[l]\\n            pred[l] = curr\\n        \\n        return pred\\n        \\n    def search(self, K: int) -> bool:\\n        pred = self.predecessor(K)\\n        curr = pred[0].nxt[0]\\n        return curr and curr.key == K \\n        \\n    def add(self, K: int) -> None:\\n        pred = self.predecessor(K)\\n        curr = pred[0].nxt[0]\\n        if curr and curr.key == K:\\n            curr.count += 1\\n            return\\n        \\n        # level 0 creates a lot of trouble\\n        level = max(1, mod(K, self.maxlevel))\\n        self.curlevel = max(self.curlevel, level)\\n        node = Node(K, level)\\n\\n        for l in range(level):\\n            node.nxt[l] = pred[l].nxt[l]\\n            pred[l].nxt[l] = node\\n                \\n    def erase(self, K: int) -> bool:\\n        pred = self.predecessor(K)\\n        curr = pred[0].nxt[0]\\n        if not curr or curr.key != K:\\n            return False\\n        \\n        if curr and curr.key == K:\\n            curr.count -= 1\\n            if curr.count >= 1:\\n                return True\\n        \\n        for l in range(curr.level):\\n            pred[l].nxt[l] = curr.nxt[l]\\n        \\n        del curr\\n        \\n        curlevel = self.curlevel\\n        for l in range(curlevel, -1, -1):\\n            if self.head.nxt[l] == None:\\n                self.curlevel -= 1\\n            else:\\n                break\\n        return True                \\n        \\n        \\n\\n\\n# Your Skiplist object will be instantiated and called as such:\\n# obj = Skiplist()\\n# param_1 = obj.search(target)\\n# obj.add(num)\\n# param_3 = obj.erase(num)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node:\\n    def __init__(self, key, level):\\n        self.key = key\\n        self.count = 1\\n        self.level = level\\n        self.nxt = [None for _ in range(level)]\\n        \\nclass Skiplist:\\n\\n    def __init__(self):\\n        self.maxlevel = pow(2,5)\\n        self.curlevel = -1\\n        self.head = Node(-1, self.maxlevel)\\n\\n    def predecessor(self, K: int) -> Node:\\n        curr = self.head\\n        pred = [curr for _ in range(self.maxlevel)]\\n        \\n        for l in range(self.curlevel, -1, -1):\\n            while curr.nxt[l] and curr.nxt[l].key < K:\\n                curr = curr.nxt[l]\\n            pred[l] = curr\\n        \\n        return pred\\n        \\n    def search(self, K: int) -> bool:\\n        pred = self.predecessor(K)\\n        curr = pred[0].nxt[0]\\n        return curr and curr.key == K \\n        \\n    def add(self, K: int) -> None:\\n        pred = self.predecessor(K)\\n        curr = pred[0].nxt[0]\\n        if curr and curr.key == K:\\n            curr.count += 1\\n            return\\n        \\n        # level 0 creates a lot of trouble\\n        level = max(1, mod(K, self.maxlevel))\\n        self.curlevel = max(self.curlevel, level)\\n        node = Node(K, level)\\n\\n        for l in range(level):\\n            node.nxt[l] = pred[l].nxt[l]\\n            pred[l].nxt[l] = node\\n                \\n    def erase(self, K: int) -> bool:\\n        pred = self.predecessor(K)\\n        curr = pred[0].nxt[0]\\n        if not curr or curr.key != K:\\n            return False\\n        \\n        if curr and curr.key == K:\\n            curr.count -= 1\\n            if curr.count >= 1:\\n                return True\\n        \\n        for l in range(curr.level):\\n            pred[l].nxt[l] = curr.nxt[l]\\n        \\n        del curr\\n        \\n        curlevel = self.curlevel\\n        for l in range(curlevel, -1, -1):\\n            if self.head.nxt[l] == None:\\n                self.curlevel -= 1\\n            else:\\n                break\\n        return True                \\n        \\n        \\n\\n\\n# Your Skiplist object will be instantiated and called as such:\\n# obj = Skiplist()\\n# param_1 = obj.search(target)\\n# obj.add(num)\\n# param_3 = obj.erase(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1566591,
                "title": "maintain-a-downward-reference-and-some-helpful-findings",
                "content": "A custom data structure will make it easier:\\n```\\n\\n    inner class Node(val value: Int) {\\n        var next: Node? = null\\n        var downRef: Node? = null\\n\\t\\tvar level: Int = 0\\n\\n        override fun toString(): String {\\n            return \"Node($value, next=${next?.value})\"\\n        }\\n    }\\n```\\n\\nThe `Node#downRef` will maintain a downward reference from higher level to lower level. \\nHaving `Node#level` also makes traversal easy. Check tip#1.\\n\\nBy downard reference, I mean a node inserted during `SkipList#add` call \\u2013 should have a reference to its below level (check the `SkipList#add`).\\n\\n```\\n    private val _headNode = Array<Node>(3) { level ->\\n        Node(Int.MIN_VALUE).also {\\n            it.level = level\\n        }\\n    }\\n    private val random = Random(58)\\n\\n    private var array: Array<Node> // this is the levels\\n\\n    init {\\n        for (i in 1.._headNode.lastIndex) {\\n            _headNode[i].downRef = _headNode[i - 1]\\n        }\\n        array = Array(_headNode.size) {\\n            _headNode[it]\\n        }\\n    }\\n```\\n\\n\\n#### Parent element\\nParent element is the element whose value is less than the target and whose `next` Node\\'s value is higher than the target or null. i,e, inserting `Node(target)` should locate in between parent and its next.\\n```\\n private fun findParentInCurrentLevel(node: Node, target: Int): Node {\\n        var current: Node? = node\\n        while (current != null) {\\n            if (current.next == null) {\\n                return current\\n            } else if (current.value < target && current.next!!.value >= target) {\\n                return current\\n            }\\n            current = current.next\\n        }\\n        return node\\n\\n    }\\n```\\n\\n#### Add\\nFind the parent in level 0. And flip a coin to see if it needs to be added in higher level or skipped.\\nLevel0 must contain all the node. Don\\'t forget to maintain a downward reference to earlier added node and level.\\n```\\n    fun add(num: Int) {\\n        val node = Node(num)\\n        val level0Parent = findParentInCurrentLevel(array[0], num)\\n        val next = level0Parent.next\\n        // level 0 must contain the node\\n        level0Parent.next = node\\n        level0Parent.level = 0\\n        node.next = next\\n        var tempNode = node\\n        for (i in 1..array.lastIndex) {\\n            if (shouldAddUp()) { // flip a coin\\n                val cloneNode = Node(num)\\n                cloneNode.downRef = tempNode\\n                cloneNode.level = i\\n                val parent = findParentInCurrentLevel(array[i], num)\\n                val next = parent.next\\n                parent.next = cloneNode\\n                cloneNode.next = next\\n                tempNode = cloneNode\\n            }\\n        }\\n    }\\n```\\n\\n#### Search\\nStart from highest level  and see if there\\'s a match. Use parent\\'s `downRef` to go a level below.\\n```\\n\\n    fun search(target: Int): Boolean {\\n        return search(array.last(), target)\\n    }\\n\\n    private fun search(node: Node?, target: Int): Boolean {\\n        if (node == null) {\\n            return false\\n        }\\n        val parent = findParentInCurrentLevel(node, target)\\n        if (parent.value == target) {\\n            return true\\n        }\\n        if (parent.next != null) {\\n            if (parent.next!!.value == target) {\\n                return true\\n            }\\n        }\\n        return search(parent.downRef, target)\\n    }\\n\\n```\\n\\n\\n### TIPS:\\n* DO NOT use recursion. It might do what it is intented to but there\\'s a HUGE test case somewhere where it will fail due to StackOverflowException (java).\\n* Head of each level starts with Integer.MIN_VALUE so that there is always one parent",
                "solutionTags": [],
                "code": "```\\n\\n    inner class Node(val value: Int) {\\n        var next: Node? = null\\n        var downRef: Node? = null\\n\\t\\tvar level: Int = 0\\n\\n        override fun toString(): String {\\n            return \"Node($value, next=${next?.value})\"\\n        }\\n    }\\n```\n```\\n    private val _headNode = Array<Node>(3) { level ->\\n        Node(Int.MIN_VALUE).also {\\n            it.level = level\\n        }\\n    }\\n    private val random = Random(58)\\n\\n    private var array: Array<Node> // this is the levels\\n\\n    init {\\n        for (i in 1.._headNode.lastIndex) {\\n            _headNode[i].downRef = _headNode[i - 1]\\n        }\\n        array = Array(_headNode.size) {\\n            _headNode[it]\\n        }\\n    }\\n```\n```\\n private fun findParentInCurrentLevel(node: Node, target: Int): Node {\\n        var current: Node? = node\\n        while (current != null) {\\n            if (current.next == null) {\\n                return current\\n            } else if (current.value < target && current.next!!.value >= target) {\\n                return current\\n            }\\n            current = current.next\\n        }\\n        return node\\n\\n    }\\n```\n```\\n    fun add(num: Int) {\\n        val node = Node(num)\\n        val level0Parent = findParentInCurrentLevel(array[0], num)\\n        val next = level0Parent.next\\n        // level 0 must contain the node\\n        level0Parent.next = node\\n        level0Parent.level = 0\\n        node.next = next\\n        var tempNode = node\\n        for (i in 1..array.lastIndex) {\\n            if (shouldAddUp()) { // flip a coin\\n                val cloneNode = Node(num)\\n                cloneNode.downRef = tempNode\\n                cloneNode.level = i\\n                val parent = findParentInCurrentLevel(array[i], num)\\n                val next = parent.next\\n                parent.next = cloneNode\\n                cloneNode.next = next\\n                tempNode = cloneNode\\n            }\\n        }\\n    }\\n```\n```\\n\\n    fun search(target: Int): Boolean {\\n        return search(array.last(), target)\\n    }\\n\\n    private fun search(node: Node?, target: Int): Boolean {\\n        if (node == null) {\\n            return false\\n        }\\n        val parent = findParentInCurrentLevel(node, target)\\n        if (parent.value == target) {\\n            return true\\n        }\\n        if (parent.next != null) {\\n            if (parent.next!!.value == target) {\\n                return true\\n            }\\n        }\\n        return search(parent.downRef, target)\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514616,
                "title": "simple-commented-c-solution",
                "content": "Structured as a list of lists (2D list), each element in a list has roughly probability of 0.5 to occur in list above it.\\n\\nStarting element of each list row is a dummy with INT_MIN, so that we don\\'t accidentaly skip some values.\\n\\nTry to maintain around log2(n) levels.\\n\\nlower is NULL for all last level nodes \\n\\n```\\n//List structured as 2D matrix, with next pointer to right and lower pointer to the same element in the list below\\nstruct MyNode {\\n    int val;\\n    MyNode *next, *lower;\\n    MyNode(int val) {\\n        this->val = val;\\n        next = NULL;\\n        lower=NULL;\\n    }\\n};\\n\\nclass Skiplist {\\nprivate:\\n// head stores the first (dummy -inf) element of the top most list\\n    MyNode *head;\\n\\t// n is number of nodes , lv is number of levels\\n    int n, lv;\\npublic:\\n    Skiplist() {\\n        head = new MyNode(INT_MIN);\\n        n = 0;\\n        lv = 1;\\n        srand(time(0));\\n    }\\n    \\n    bool search(int target) {\\n        MyNode *node = head;\\n        while(node) {\\n\\t\\t\\t// go right till its smaller than search term\\n            while(node->next && node->next->val<target) node = node->next;\\n\\t\\t\\t// return true if we find it\\n            if(node->next && node->next->val==target) return true;\\n\\t\\t\\t// else go down and search\\n            node = node->lower;\\n        }\\n        return false;\\n    }\\n    \\n    void add(int num) {\\n\\t\\t//stack stores the just previous nodes for the new node so that we can insert after them\\n        stack<MyNode*> s;\\n        MyNode *ptr = head;\\n\\t\\t\\n\\t\\t//search for right position and store previous of each level in stack\\n        while(ptr) {\\n            while(ptr->next && ptr->next->val<=num) ptr=ptr->next;\\n            s.push(ptr);\\n            ptr = ptr->lower;\\n        }\\n\\t\\t// last is the node for the same value in just lower level to populate lower in new nodes\\n        MyNode *last = NULL;\\n        while(!s.empty()) {\\n\\t\\t\\t//previous node in the level\\n            ptr = s.top();\\n            s.pop();\\n\\t\\t\\t// create new node\\n            MyNode *node = new MyNode(num);\\n            node->lower = last;\\n\\t\\t\\t//insert node in level\\n            node->next = ptr->next;\\n            ptr->next = node;\\n            last = node;\\n\\t\\t\\t// keep going with 50% chance\\n            if(rand()>=RAND_MAX/2) break;\\n        }\\n        n++;\\n\\t\\t//if we reached the top level and didn\\'t stop, then create new levels with same idea\\n        if(s.empty()) {\\n\\t\\t\\t//hard limit number of levels\\n            int mx = log2(n)+1;\\n            while(lv<=mx) {\\n                if(rand()>=RAND_MAX/2) break;\\n\\t\\t\\t\\t//create head for new level\\n                MyNode *nhead = new MyNode(INT_MIN);\\n                nhead->lower = head;\\n                head = nhead;\\n\\t\\t\\t\\t//create node for level and insert after head\\n                MyNode *node = new MyNode(num);\\n                node->lower = last;\\n                last = node;\\n                nhead->next = node;\\n                lv++;\\n            }\\n        }\\n    }\\n    \\n    bool erase(int num) {\\n        MyNode *node = head;\\n        bool ans = false;\\n\\t\\t//similar to search but delete node if we find it instead of return\\n        while(node) {\\n            while(node->next && node->next->val<num) node = node->next;\\n            if(node->next && node->next->val==num) {\\n                node->next = node->next->next;\\n                ans = true;\\n            }\\n            node = node->lower;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n//List structured as 2D matrix, with next pointer to right and lower pointer to the same element in the list below\\nstruct MyNode {\\n    int val;\\n    MyNode *next, *lower;\\n    MyNode(int val) {\\n        this->val = val;\\n        next = NULL;\\n        lower=NULL;\\n    }\\n};\\n\\nclass Skiplist {\\nprivate:\\n// head stores the first (dummy -inf) element of the top most list\\n    MyNode *head;\\n\\t// n is number of nodes , lv is number of levels\\n    int n, lv;\\npublic:\\n    Skiplist() {\\n        head = new MyNode(INT_MIN);\\n        n = 0;\\n        lv = 1;\\n        srand(time(0));\\n    }\\n    \\n    bool search(int target) {\\n        MyNode *node = head;\\n        while(node) {\\n\\t\\t\\t// go right till its smaller than search term\\n            while(node->next && node->next->val<target) node = node->next;\\n\\t\\t\\t// return true if we find it\\n            if(node->next && node->next->val==target) return true;\\n\\t\\t\\t// else go down and search\\n            node = node->lower;\\n        }\\n        return false;\\n    }\\n    \\n    void add(int num) {\\n\\t\\t//stack stores the just previous nodes for the new node so that we can insert after them\\n        stack<MyNode*> s;\\n        MyNode *ptr = head;\\n\\t\\t\\n\\t\\t//search for right position and store previous of each level in stack\\n        while(ptr) {\\n            while(ptr->next && ptr->next->val<=num) ptr=ptr->next;\\n            s.push(ptr);\\n            ptr = ptr->lower;\\n        }\\n\\t\\t// last is the node for the same value in just lower level to populate lower in new nodes\\n        MyNode *last = NULL;\\n        while(!s.empty()) {\\n\\t\\t\\t//previous node in the level\\n            ptr = s.top();\\n            s.pop();\\n\\t\\t\\t// create new node\\n            MyNode *node = new MyNode(num);\\n            node->lower = last;\\n\\t\\t\\t//insert node in level\\n            node->next = ptr->next;\\n            ptr->next = node;\\n            last = node;\\n\\t\\t\\t// keep going with 50% chance\\n            if(rand()>=RAND_MAX/2) break;\\n        }\\n        n++;\\n\\t\\t//if we reached the top level and didn\\'t stop, then create new levels with same idea\\n        if(s.empty()) {\\n\\t\\t\\t//hard limit number of levels\\n            int mx = log2(n)+1;\\n            while(lv<=mx) {\\n                if(rand()>=RAND_MAX/2) break;\\n\\t\\t\\t\\t//create head for new level\\n                MyNode *nhead = new MyNode(INT_MIN);\\n                nhead->lower = head;\\n                head = nhead;\\n\\t\\t\\t\\t//create node for level and insert after head\\n                MyNode *node = new MyNode(num);\\n                node->lower = last;\\n                last = node;\\n                nhead->next = node;\\n                lv++;\\n            }\\n        }\\n    }\\n    \\n    bool erase(int num) {\\n        MyNode *node = head;\\n        bool ans = false;\\n\\t\\t//similar to search but delete node if we find it instead of return\\n        while(node) {\\n            while(node->next && node->next->val<num) node = node->next;\\n            if(node->next && node->next->val==num) {\\n                node->next = node->next->next;\\n                ans = true;\\n            }\\n            node = node->lower;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1496633,
                "title": "anyone-know-why-this-code-gets-tle",
                "content": "Each level is a independent C++ list.\\nEach list node holdes a reference (list iterator) to the same (value) node at the lower level.\\nEach add has only (1/2)^N chance of being added to level N.\\n\\nAnyone know what went wrong? \\n\\n```\\nclass Skiplist {\\npublic:\\n    typedef struct ln {\\n        int val;\\n        list<struct ln>::iterator prev; // A pointer to the lower level\\n        bool operator<(int t){\\n            return this->val < t;\\n        }\\n    } ln;\\n    list<ln> lvl [16];\\n    list<ln>::iterator lvlp[16];\\n    \\n    friend bool operator<(int t, struct ln& rhs){\\n        return t < rhs.val;\\n    }\\n    \\n    Skiplist() {\\n        srand(time(NULL));\\n    }\\n    \\n    void find(int val){\\n        int i;\\n        list<ln>::iterator j,k;\\n        \\n        j = lvl[15].begin();\\n        for(i=15;i>0;i--){\\n            lvlp[i]=lower_bound(j, lvl[i].end(),val);\\n            if (lvlp[i]==lvl[i].begin()){\\n                j=lvl[i-1].begin();\\n            }\\n            else {\\n                k = lvlp[i];\\n                k--;\\n                j = k->prev;\\n            }\\n        }\\n        lvlp[0]=lower_bound(j, lvl[0].end(),val);\\n        \\n        /*\\n        cout << \"================================\\\\n\";\\n        for(i=0;i<5;i++){\\n            for(j=lvl[i].begin();j!=lvl[i].end();j++){\\n                cout << j->val << \" -> \";\\n            }\\n            cout << endl;\\n        }\\n        cout << \"================================\\\\n\";\\n        */\\n    }\\n    \\n    bool search(int target) {\\n        find(target);\\n        return lvlp[0] != lvl[0].end() && lvlp[0]->val==target;\\n    }\\n    \\n    void add(int num) {\\n        int i;\\n        ln tmp;\\n        find(num);\\n        tmp.val=num;\\n        for(i=0;i<16;i++){\\n            lvl[i].insert(lvlp[i],tmp);\\n            tmp.prev=lvlp[i];   // Hold a reference to the lower level\\n            tmp.prev--;\\n            \\n            if(rand()&1) break; // 1/2 chance of elevating level\\n        }\\n    }\\n    \\n    bool erase(int num) {\\n        int i;\\n        find(num);\\n        for(i=0;i<16;i++){\\n            if (lvlp[i]!=lvl[i].end() && lvlp[i]->val==num){\\n                lvl[i].erase(lvlp[i]);\\n            }\\n            else break;\\n        }\\n        return i>0;\\n    }\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Skiplist {\\npublic:\\n    typedef struct ln {\\n        int val;\\n        list<struct ln>::iterator prev; // A pointer to the lower level\\n        bool operator<(int t){\\n            return this->val < t;\\n        }\\n    } ln;\\n    list<ln> lvl [16];\\n    list<ln>::iterator lvlp[16];\\n    \\n    friend bool operator<(int t, struct ln& rhs){\\n        return t < rhs.val;\\n    }\\n    \\n    Skiplist() {\\n        srand(time(NULL));\\n    }\\n    \\n    void find(int val){\\n        int i;\\n        list<ln>::iterator j,k;\\n        \\n        j = lvl[15].begin();\\n        for(i=15;i>0;i--){\\n            lvlp[i]=lower_bound(j, lvl[i].end(),val);\\n            if (lvlp[i]==lvl[i].begin()){\\n                j=lvl[i-1].begin();\\n            }\\n            else {\\n                k = lvlp[i];\\n                k--;\\n                j = k->prev;\\n            }\\n        }\\n        lvlp[0]=lower_bound(j, lvl[0].end(),val);\\n        \\n        /*\\n        cout << \"================================\\\\n\";\\n        for(i=0;i<5;i++){\\n            for(j=lvl[i].begin();j!=lvl[i].end();j++){\\n                cout << j->val << \" -> \";\\n            }\\n            cout << endl;\\n        }\\n        cout << \"================================\\\\n\";\\n        */\\n    }\\n    \\n    bool search(int target) {\\n        find(target);\\n        return lvlp[0] != lvl[0].end() && lvlp[0]->val==target;\\n    }\\n    \\n    void add(int num) {\\n        int i;\\n        ln tmp;\\n        find(num);\\n        tmp.val=num;\\n        for(i=0;i<16;i++){\\n            lvl[i].insert(lvlp[i],tmp);\\n            tmp.prev=lvlp[i];   // Hold a reference to the lower level\\n            tmp.prev--;\\n            \\n            if(rand()&1) break; // 1/2 chance of elevating level\\n        }\\n    }\\n    \\n    bool erase(int num) {\\n        int i;\\n        find(num);\\n        for(i=0;i<16;i++){\\n            if (lvlp[i]!=lvl[i].end() && lvlp[i]->val==num){\\n                lvl[i].erase(lvlp[i]);\\n            }\\n            else break;\\n        }\\n        return i>0;\\n    }\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1488029,
                "title": "javascript-redis-internal-data-structure",
                "content": "```\\nvar Node = function (val = -1, right = null, down = null) {\\n    this.val = val;\\n    this.right = right;\\n    this.down = down;\\n}\\n\\nvar Skiplist = function() {\\n    this.head = new Node() // dummy head\\n};\\n\\n/** \\n * @param {number} target\\n * @return {boolean}\\n */\\nSkiplist.prototype.search = function(target) {\\n    var node = this.head;\\n    while (node) {\\n        while (node.right && node.right.val < target) {\\n            node = node.right;\\n        }\\n        if (node.right && node.right.val === target) {\\n            return true;\\n        }\\n        node = node.down;\\n    }\\n    return false;\\n};\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nSkiplist.prototype.add = function(num) {\\n    var pathlist = [];\\n    var node = this.head;\\n    while (node) {\\n        while (node.right && node.right.val < num) {\\n            node = node.right;\\n        }\\n        pathlist.push(node);\\n        node = node.down;\\n    }\\n    var insertUp = true;\\n    var downNode = null;\\n    while (insertUp && pathlist.length !== 0) {\\n        var insertNode = pathlist.pop();\\n        insertNode.right = new Node(num, insertNode.right, downNode);\\n        downNode = insertNode.right;\\n        insertUp = (Math.random() * 10 & 1) === 0;\\n    }\\n    if (insertUp) {\\n        this.head = new Node(-1, null, this.head);\\n    }  \\n};\\n\\n/** \\n * @param {number} num\\n * @return {boolean}\\n */\\nSkiplist.prototype.erase = function(num) {\\n    var node = this.head;\\n    var found = false;\\n    while (node) {\\n        while (node.right && node.right.val < num) {\\n            node = node.right;\\n        }\\n        if (!node.right || node.right.val > num) {\\n            node = node.down;\\n        } else {\\n            found = true;\\n            node.right = node.right.right;\\n            node = node.down;\\n        }\\n        \\n    }\\n    return found;    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar Node = function (val = -1, right = null, down = null) {\\n    this.val = val;\\n    this.right = right;\\n    this.down = down;\\n}\\n\\nvar Skiplist = function() {\\n    this.head = new Node() // dummy head\\n};\\n\\n/** \\n * @param {number} target\\n * @return {boolean}\\n */\\nSkiplist.prototype.search = function(target) {\\n    var node = this.head;\\n    while (node) {\\n        while (node.right && node.right.val < target) {\\n            node = node.right;\\n        }\\n        if (node.right && node.right.val === target) {\\n            return true;\\n        }\\n        node = node.down;\\n    }\\n    return false;\\n};\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nSkiplist.prototype.add = function(num) {\\n    var pathlist = [];\\n    var node = this.head;\\n    while (node) {\\n        while (node.right && node.right.val < num) {\\n            node = node.right;\\n        }\\n        pathlist.push(node);\\n        node = node.down;\\n    }\\n    var insertUp = true;\\n    var downNode = null;\\n    while (insertUp && pathlist.length !== 0) {\\n        var insertNode = pathlist.pop();\\n        insertNode.right = new Node(num, insertNode.right, downNode);\\n        downNode = insertNode.right;\\n        insertUp = (Math.random() * 10 & 1) === 0;\\n    }\\n    if (insertUp) {\\n        this.head = new Node(-1, null, this.head);\\n    }  \\n};\\n\\n/** \\n * @param {number} num\\n * @return {boolean}\\n */\\nSkiplist.prototype.erase = function(num) {\\n    var node = this.head;\\n    var found = false;\\n    while (node) {\\n        while (node.right && node.right.val < num) {\\n            node = node.right;\\n        }\\n        if (!node.right || node.right.val > num) {\\n            node = node.down;\\n        } else {\\n            found = true;\\n            node.right = node.right.right;\\n            node = node.down;\\n        }\\n        \\n    }\\n    return found;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1432788,
                "title": "python-3-implementation",
                "content": "The core idea of skiplist is when walking through, use step-size of 2 rather 1 to boost efficiency. So, don\\'t have to use a real linked-list, a sequential list will be ok as long as the step-size is 2.\\n\\n```\\nclass Skiplist:\\n\\n    def __init__(self):\\n        self.elements = []\\n        \\n\\n    def search(self, target: int) -> bool:\\n        length = len(self.elements)\\n        i = 0\\n        while i < length-1 and target > self.elements[i]:\\n            if i + 2 >= length:\\n                i += 1\\n            else:\\n                i += 2\\n        if i > 0:\\n            if target == self.elements[i] or target == self.elements[i - 1]:\\n                return True\\n            else:\\n                return False\\n        elif i == 0:\\n            if target == self.elements[i]:\\n                return True\\n            else:\\n                return False\\n            \\n            \\n        \\n            \\n        \\n\\n    def add(self, num: int) -> None:\\n        length = len(self.elements)\\n        i = 0\\n        while i < length and num > self.elements[i]:\\n            if i + 2 >= length:\\n                i += 1\\n            else:\\n                i += 2\\n        if i > 0:\\n            if num > self.elements[i - 1]:\\n                self.elements.insert(i, num)\\n            else:\\n                self.elements.insert(i - 1, num)\\n        elif i == 0:\\n            self.elements.insert(i, num)\\n        \\n\\n    def erase(self, num: int) -> bool:\\n        length = len(self.elements)\\n        i = 0\\n        while i < length - 1 and num > self.elements[i]:\\n            if i + 2 >= length:\\n                i += 1\\n            else:\\n                i += 2\\n        if i > 0:\\n            if num == self.elements[i]:\\n                self.elements.pop(i)\\n                return True\\n            elif num == self.elements[i - 1]:\\n                self.elements.pop(i - 1)\\n                return True\\n            else:\\n                return False\\n        elif i == 0:\\n            if num == self.elements[i]:\\n                self.elements.pop(i)\\n                return True\\n            else:\\n                return False\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Skiplist:\\n\\n    def __init__(self):\\n        self.elements = []\\n        \\n\\n    def search(self, target: int) -> bool:\\n        length = len(self.elements)\\n        i = 0\\n        while i < length-1 and target > self.elements[i]:\\n            if i + 2 >= length:\\n                i += 1\\n            else:\\n                i += 2\\n        if i > 0:\\n            if target == self.elements[i] or target == self.elements[i - 1]:\\n                return True\\n            else:\\n                return False\\n        elif i == 0:\\n            if target == self.elements[i]:\\n                return True\\n            else:\\n                return False\\n            \\n            \\n        \\n            \\n        \\n\\n    def add(self, num: int) -> None:\\n        length = len(self.elements)\\n        i = 0\\n        while i < length and num > self.elements[i]:\\n            if i + 2 >= length:\\n                i += 1\\n            else:\\n                i += 2\\n        if i > 0:\\n            if num > self.elements[i - 1]:\\n                self.elements.insert(i, num)\\n            else:\\n                self.elements.insert(i - 1, num)\\n        elif i == 0:\\n            self.elements.insert(i, num)\\n        \\n\\n    def erase(self, num: int) -> bool:\\n        length = len(self.elements)\\n        i = 0\\n        while i < length - 1 and num > self.elements[i]:\\n            if i + 2 >= length:\\n                i += 1\\n            else:\\n                i += 2\\n        if i > 0:\\n            if num == self.elements[i]:\\n                self.elements.pop(i)\\n                return True\\n            elif num == self.elements[i - 1]:\\n                self.elements.pop(i - 1)\\n                return True\\n            else:\\n                return False\\n        elif i == 0:\\n            if num == self.elements[i]:\\n                self.elements.pop(i)\\n                return True\\n            else:\\n                return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431554,
                "title": "c-adhoc-solution-with-list-and-vector",
                "content": "```\\nclass Skiplist {\\npublic:\\n    Skiplist() {\\n        list<SkipListNode> init_list;\\n        init_list.push_back(SkipListNode(INT_MIN, true, false));\\n        init_list.push_back(SkipListNode(INT_MAX, false, true));\\n        skip_list.push_back(init_list);\\n    }\\n    \\n    bool search(int target) {\\n        int level = skip_list.size()-1;\\n        list<SkipListNode>::iterator prev = skip_list[level].begin();\\n        while (true) { \\n            while (true) {\\n                auto next_iter = std::next(prev);\\n                if (next_iter->is_tail == false && next_iter->val <= target) {\\n                    prev = next_iter;\\n                    continue;\\n                }\\n                break;\\n            }\\n            if (prev->val == target) return true;\\n            if (level == 0) break;\\n            --level;\\n            prev = prev->lower_level_iter;\\n        }\\n        return false;\\n    }\\n    \\n    void add(int num) {\\n        int level = skip_list.size()-1;\\n        list<SkipListNode>::iterator prev = skip_list[level].begin();\\n        vector<list<SkipListNode>::iterator> locales(skip_list.size());\\n        while (true) { \\n            while (true) {\\n                auto next_iter = std::next(prev);\\n                if (next_iter->is_tail == false && next_iter->val <= num) {\\n                    prev = next_iter;\\n                    continue;\\n                }\\n                break;\\n            }\\n            locales[level] = prev;\\n            if (prev->val == num) prev->count += 1;\\n            if (level == 0) break;\\n            --level;\\n            prev = prev->lower_level_iter;\\n        }\\n        if (prev->val == num) return;\\n        \\n        skip_list[level].insert(std::next(prev), SkipListNode(num, false, false));\\n        auto curr = std::next(prev);\\n        // promote\\n        while (level < skip_list.size()) {\\n            double r = ((double) rand() / (RAND_MAX));\\n            if (r < promote_probility) break;\\n            // go to level + 1;\\n            if (level+1 == skip_list.size()) {\\n                // create a new level;\\n                list<SkipListNode> top_list;\\n                top_list.push_back(SkipListNode(INT_MIN, true, false));\\n                skip_list.push_back(top_list);\\n                \\n                auto& head = skip_list[level+1].front();\\n                head.lower_level_iter = skip_list[level].begin();\\n                \\n                \\n                skip_list[level+1].push_back(SkipListNode(num, false, false));\\n                auto& back = skip_list[level+1].back();\\n                back.lower_level_iter = curr;\\n                \\n                \\n                skip_list[level+1].push_back(SkipListNode(INT_MAX, false, true));\\n                auto& nil = skip_list[level+1].back();\\n                nil.lower_level_iter = std::prev(skip_list[level].end());\\n                \\n                break;\\n            }\\n            \\n            auto loc = locales[level+1];\\n            skip_list[level+1].insert(std::next(loc), SkipListNode(num, false, false));\\n            auto next_curr = std::next(loc);\\n            next_curr->lower_level_iter = curr;\\n            curr = next_curr;\\n            ++level;\\n        }\\n    }\\n    \\n    bool erase(int num) {\\n        int level = skip_list.size()-1;\\n        list<SkipListNode>::iterator prev = skip_list[level].begin();\\n        bool is_found = false;\\n        while (true) { \\n            while (true) {\\n                auto next_iter = std::next(prev);\\n                if (next_iter->is_tail == false && next_iter->val <= num) {\\n                    prev = next_iter;\\n                    continue;\\n                }\\n                break;\\n            }\\n            bool is_eligible_remove = false;\\n            list<SkipListNode>::iterator to_remove_iter;\\n            if (prev->val == num) {\\n                is_found = true;\\n                prev->count -= 1;\\n                if (prev->count == 0) {\\n                    is_eligible_remove = true;\\n                    to_remove_iter = prev;\\n                }\\n            }\\n            prev = prev->lower_level_iter;\\n            if (is_eligible_remove) skip_list[level].erase(to_remove_iter);\\n            if (level == 0) break;\\n            --level;\\n        }\\n        return is_found;\\n    }\\n    \\n    vector<list<SkipListNode>> skip_list;\\n    double promote_probility = 0.5;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Skiplist {\\npublic:\\n    Skiplist() {\\n        list<SkipListNode> init_list;\\n        init_list.push_back(SkipListNode(INT_MIN, true, false));\\n        init_list.push_back(SkipListNode(INT_MAX, false, true));\\n        skip_list.push_back(init_list);\\n    }\\n    \\n    bool search(int target) {\\n        int level = skip_list.size()-1;\\n        list<SkipListNode>::iterator prev = skip_list[level].begin();\\n        while (true) { \\n            while (true) {\\n                auto next_iter = std::next(prev);\\n                if (next_iter->is_tail == false && next_iter->val <= target) {\\n                    prev = next_iter;\\n                    continue;\\n                }\\n                break;\\n            }\\n            if (prev->val == target) return true;\\n            if (level == 0) break;\\n            --level;\\n            prev = prev->lower_level_iter;\\n        }\\n        return false;\\n    }\\n    \\n    void add(int num) {\\n        int level = skip_list.size()-1;\\n        list<SkipListNode>::iterator prev = skip_list[level].begin();\\n        vector<list<SkipListNode>::iterator> locales(skip_list.size());\\n        while (true) { \\n            while (true) {\\n                auto next_iter = std::next(prev);\\n                if (next_iter->is_tail == false && next_iter->val <= num) {\\n                    prev = next_iter;\\n                    continue;\\n                }\\n                break;\\n            }\\n            locales[level] = prev;\\n            if (prev->val == num) prev->count += 1;\\n            if (level == 0) break;\\n            --level;\\n            prev = prev->lower_level_iter;\\n        }\\n        if (prev->val == num) return;\\n        \\n        skip_list[level].insert(std::next(prev), SkipListNode(num, false, false));\\n        auto curr = std::next(prev);\\n        // promote\\n        while (level < skip_list.size()) {\\n            double r = ((double) rand() / (RAND_MAX));\\n            if (r < promote_probility) break;\\n            // go to level + 1;\\n            if (level+1 == skip_list.size()) {\\n                // create a new level;\\n                list<SkipListNode> top_list;\\n                top_list.push_back(SkipListNode(INT_MIN, true, false));\\n                skip_list.push_back(top_list);\\n                \\n                auto& head = skip_list[level+1].front();\\n                head.lower_level_iter = skip_list[level].begin();\\n                \\n                \\n                skip_list[level+1].push_back(SkipListNode(num, false, false));\\n                auto& back = skip_list[level+1].back();\\n                back.lower_level_iter = curr;\\n                \\n                \\n                skip_list[level+1].push_back(SkipListNode(INT_MAX, false, true));\\n                auto& nil = skip_list[level+1].back();\\n                nil.lower_level_iter = std::prev(skip_list[level].end());\\n                \\n                break;\\n            }\\n            \\n            auto loc = locales[level+1];\\n            skip_list[level+1].insert(std::next(loc), SkipListNode(num, false, false));\\n            auto next_curr = std::next(loc);\\n            next_curr->lower_level_iter = curr;\\n            curr = next_curr;\\n            ++level;\\n        }\\n    }\\n    \\n    bool erase(int num) {\\n        int level = skip_list.size()-1;\\n        list<SkipListNode>::iterator prev = skip_list[level].begin();\\n        bool is_found = false;\\n        while (true) { \\n            while (true) {\\n                auto next_iter = std::next(prev);\\n                if (next_iter->is_tail == false && next_iter->val <= num) {\\n                    prev = next_iter;\\n                    continue;\\n                }\\n                break;\\n            }\\n            bool is_eligible_remove = false;\\n            list<SkipListNode>::iterator to_remove_iter;\\n            if (prev->val == num) {\\n                is_found = true;\\n                prev->count -= 1;\\n                if (prev->count == 0) {\\n                    is_eligible_remove = true;\\n                    to_remove_iter = prev;\\n                }\\n            }\\n            prev = prev->lower_level_iter;\\n            if (is_eligible_remove) skip_list[level].erase(to_remove_iter);\\n            if (level == 0) break;\\n            --level;\\n        }\\n        return is_found;\\n    }\\n    \\n    vector<list<SkipListNode>> skip_list;\\n    double promote_probility = 0.5;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1327711,
                "title": "python-one-node-with-16-pointers-per-value",
                "content": "Each node has a list of 16 next pointers. Add, erase, and search are all done similarly.\\n```\\nclass SkipNode:\\n    def __init__(self, val):\\n        self.layers = [None] * 16\\n        self.val = val\\n        \\nclass Skiplist:\\n    def __init__(self):\\n        self.head = SkipNode(None)\\n        self.size = 0\\n\\n    def search(self, target: int) -> bool:\\n        curr = self.head\\n        for x in range(15, -1, -1):\\n            while curr.layers[x] and curr.layers[x].val <= target:\\n                curr = curr.layers[x]\\n                if curr and curr.val == target:\\n                    return True\\n        return False\\n\\n    def add(self, num: int) -> None:\\n        new = SkipNode(num)\\n        count = 0\\n        for _ in range(15):\\n            if random.choice([True, False]):\\n                count += 1\\n            else:\\n                break\\n        curr = self.head\\n        for x in range(15, -1, -1):\\n            while curr.layers[x] and curr.layers[x].val <= num:\\n                curr = curr.layers[x]\\n            if not curr.layers[x] or curr.layers[x].val > num:\\n                if count >= x:\\n                    new.layers[x] = curr.layers[x]\\n                    curr.layers[x] = new\\n                else:\\n                    continue\\n\\n    def erase(self, num: int) -> bool:\\n        if not self.search(num):\\n            return False\\n        curr = self.head\\n        for x in range(15, -1, -1):\\n            while curr.layers[x] and curr.layers[x].val < num:\\n                curr = curr.layers[x]        \\n            if curr.layers[x] and curr.layers[x].val == num:\\n                curr.layers[x] = curr.layers[x].layers[x]\\n        return True\\n\\n# Your Skiplist object will be instantiated and called as such:\\n# obj = Skiplist()\\n# param_1 = obj.search(target)\\n# obj.add(num)\\n# param_3 = obj.erase(num)\\n```",
                "solutionTags": [],
                "code": "```\\nclass SkipNode:\\n    def __init__(self, val):\\n        self.layers = [None] * 16\\n        self.val = val\\n        \\nclass Skiplist:\\n    def __init__(self):\\n        self.head = SkipNode(None)\\n        self.size = 0\\n\\n    def search(self, target: int) -> bool:\\n        curr = self.head\\n        for x in range(15, -1, -1):\\n            while curr.layers[x] and curr.layers[x].val <= target:\\n                curr = curr.layers[x]\\n                if curr and curr.val == target:\\n                    return True\\n        return False\\n\\n    def add(self, num: int) -> None:\\n        new = SkipNode(num)\\n        count = 0\\n        for _ in range(15):\\n            if random.choice([True, False]):\\n                count += 1\\n            else:\\n                break\\n        curr = self.head\\n        for x in range(15, -1, -1):\\n            while curr.layers[x] and curr.layers[x].val <= num:\\n                curr = curr.layers[x]\\n            if not curr.layers[x] or curr.layers[x].val > num:\\n                if count >= x:\\n                    new.layers[x] = curr.layers[x]\\n                    curr.layers[x] = new\\n                else:\\n                    continue\\n\\n    def erase(self, num: int) -> bool:\\n        if not self.search(num):\\n            return False\\n        curr = self.head\\n        for x in range(15, -1, -1):\\n            while curr.layers[x] and curr.layers[x].val < num:\\n                curr = curr.layers[x]        \\n            if curr.layers[x] and curr.layers[x].val == num:\\n                curr.layers[x] = curr.layers[x].layers[x]\\n        return True\\n\\n# Your Skiplist object will be instantiated and called as such:\\n# obj = Skiplist()\\n# param_1 = obj.search(target)\\n# obj.add(num)\\n# param_3 = obj.erase(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285922,
                "title": "is-this-a-mistake-but-i-have-90-fast",
                "content": "```\\nclass Skiplist {\\npublic:\\n    int a[20000]={0};\\n    Skiplist() {\\n        \\n    }\\n    \\n    bool search(int target) {\\n        if(a[target])\\n            return true;\\n        else \\n            return false;\\n    }\\n    \\n    void add(int num) {\\n        a[num]++;\\n    }\\n    \\n    bool erase(int num) {\\n        if(a[num])\\n        {\\n           a[num]--;\\n           return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Skiplist {\\npublic:\\n    int a[20000]={0};\\n    Skiplist() {\\n        \\n    }\\n    \\n    bool search(int target) {\\n        if(a[target])\\n            return true;\\n        else \\n            return false;\\n    }\\n    \\n    void add(int num) {\\n        a[num]++;\\n    }\\n    \\n    bool erase(int num) {\\n        if(a[num])\\n        {\\n           a[num]--;\\n           return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285253,
                "title": "c-managing-multilevel-entries-with-p-2-next-and-down-pointers",
                "content": "```\\nstruct Node {\\n    int val;\\n    Node* next;\\n    Node* down;\\n    Node(int v) : val(v), next(NULL), down(NULL) {}\\n    Node(int v, Node* next_, Node* down_) : val(v), next(next_), down(down_) {}\\n};\\n\\nclass Skiplist {\\n    Node* head;\\n    int levelCount;\\n    int elementCount;\\n    /* Using p = 2\\n     * probability that element is in higher level = 1/2\\n     * add new level when elementCount > (1<<levelCount)\\n     * adding repeated higher level entries to be done via rand()%(1<<levelCount-1)\\n     */\\n    const int p = 2; \\n\\npublic:\\n    Skiplist() {\\n        head = new Node(-1);\\n        levelCount = 1;\\n        elementCount = 0;\\n    }\\n    \\n    stack <Node*> traverse(int target) {\\n        stack <Node*> path;\\n        \\n        Node* cur = head;\\n        while (cur != NULL) {\\n            while (cur->next != NULL and cur->next->val < target) {\\n                cur = cur->next;\\n            }\\n            path.push(cur);\\n            cur = cur->down;\\n        }\\n        \\n        return path;\\n    }\\n    bool search(int target) {\\n        stack <Node*> path = traverse(target);\\n        return (path.top()->next != NULL and path.top()->next->val == target);\\n    }\\n    \\n    void add(int num) {\\n        stack <Node*> path = traverse(num);\\n        \\n        Node* downNode = NULL;\\n        int repeat = ((rand() & ((1 << levelCount) - 1)) | 1);\\n        while (repeat & 1) {\\n            Node* curNode = new Node(num, path.top()->next, downNode);\\n            path.top()->next = curNode;\\n            downNode = curNode;\\n            repeat >>= 1;\\n            path.pop();\\n        }\\n        if (++elementCount > (1 << levelCount)) {\\n            addNewLevel();\\n        }\\n    }\\n    \\n    bool erase(int num) {\\n        stack <Node*> path = traverse(num);\\n        if (path.top()->next == NULL or path.top()->next->val != num) {\\n            return false;\\n        }\\n        --elementCount;\\n        \\n        stack <Node*> deleteNext;\\n        deleteNext.push(path.top());\\n        path.pop();\\n        while (! path.empty() and path.top()->next != NULL and path.top()->next->down == deleteNext.top()->next) {\\n            deleteNext.push(path.top());\\n            path.pop();\\n        }\\n        while (! deleteNext.empty()) {\\n            Node* curNode = deleteNext.top();\\n            curNode->next = curNode->next->next;\\n            deleteNext.pop();\\n        }\\n        return true;\\n    }\\n    \\n    void addNewLevel() {\\n        levelCount++;\\n        head = new Node(-1, NULL, head);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Node {\\n    int val;\\n    Node* next;\\n    Node* down;\\n    Node(int v) : val(v), next(NULL), down(NULL) {}\\n    Node(int v, Node* next_, Node* down_) : val(v), next(next_), down(down_) {}\\n};\\n\\nclass Skiplist {\\n    Node* head;\\n    int levelCount;\\n    int elementCount;\\n    /* Using p = 2\\n     * probability that element is in higher level = 1/2\\n     * add new level when elementCount > (1<<levelCount)\\n     * adding repeated higher level entries to be done via rand()%(1<<levelCount-1)\\n     */\\n    const int p = 2; \\n\\npublic:\\n    Skiplist() {\\n        head = new Node(-1);\\n        levelCount = 1;\\n        elementCount = 0;\\n    }\\n    \\n    stack <Node*> traverse(int target) {\\n        stack <Node*> path;\\n        \\n        Node* cur = head;\\n        while (cur != NULL) {\\n            while (cur->next != NULL and cur->next->val < target) {\\n                cur = cur->next;\\n            }\\n            path.push(cur);\\n            cur = cur->down;\\n        }\\n        \\n        return path;\\n    }\\n    bool search(int target) {\\n        stack <Node*> path = traverse(target);\\n        return (path.top()->next != NULL and path.top()->next->val == target);\\n    }\\n    \\n    void add(int num) {\\n        stack <Node*> path = traverse(num);\\n        \\n        Node* downNode = NULL;\\n        int repeat = ((rand() & ((1 << levelCount) - 1)) | 1);\\n        while (repeat & 1) {\\n            Node* curNode = new Node(num, path.top()->next, downNode);\\n            path.top()->next = curNode;\\n            downNode = curNode;\\n            repeat >>= 1;\\n            path.pop();\\n        }\\n        if (++elementCount > (1 << levelCount)) {\\n            addNewLevel();\\n        }\\n    }\\n    \\n    bool erase(int num) {\\n        stack <Node*> path = traverse(num);\\n        if (path.top()->next == NULL or path.top()->next->val != num) {\\n            return false;\\n        }\\n        --elementCount;\\n        \\n        stack <Node*> deleteNext;\\n        deleteNext.push(path.top());\\n        path.pop();\\n        while (! path.empty() and path.top()->next != NULL and path.top()->next->down == deleteNext.top()->next) {\\n            deleteNext.push(path.top());\\n            path.pop();\\n        }\\n        while (! deleteNext.empty()) {\\n            Node* curNode = deleteNext.top();\\n            curNode->next = curNode->next->next;\\n            deleteNext.pop();\\n        }\\n        return true;\\n    }\\n    \\n    void addNewLevel() {\\n        levelCount++;\\n        head = new Node(-1, NULL, head);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1102971,
                "title": "c-linked-list-with-four-directions",
                "content": "```\\nclass Skiplist {\\npublic:\\n    struct Node {\\n        int val;\\n        Node *prev, *next, *up, *down;\\n        \\n        Node(): val(INT_MIN),\\n                prev(nullptr),\\n                next(nullptr),\\n                up(nullptr),\\n                down(nullptr) {}\\n        \\n        Node(int val): val(val), prev(nullptr), next(nullptr), up(nullptr), down(nullptr) {}\\n    };\\n    \\n    \\n    Skiplist() {\\n        head = createHead();\\n        size = 0;\\n        maxLevel = 1;\\n    }\\n    \\n    Node* createHead() {\\n        Node *head = new Node(), *tail = new Node();\\n        connH(head, tail);\\n        \\n        return head;\\n    }\\n    \\n    void connH(Node *prev, Node *next) {\\n        assert(prev != nullptr);\\n        assert(next != nullptr);\\n        \\n        prev->next = next;\\n        next->prev = prev;\\n    }\\n    \\n    void connV(Node *up, Node *down) {\\n        assert(up != nullptr);\\n        assert(down != nullptr);\\n        \\n        up->down = down;\\n        down->up = up;\\n    }\\n    \\n    bool isTail(Node *node) const {\\n        assert(node != nullptr);\\n        return node->next == nullptr;\\n    }\\n    \\n    int getMaxLevel() const {\\n        return size == 0 ? 1 : (int)(ceil(log2((double) size))) + 1;\\n    }\\n    \\n    int getRandomTopLevel() const {\\n        return (int)(ceil((double) rand()/RAND_MAX * maxLevel));\\n    }\\n    \\n    bool search(int target) {\\n        list<Node*> prevNodes;\\n        return search(target, prevNodes);\\n    }\\n    \\n    bool search(int target, list<Node*> &prevNodes) {\\n        Node *curr = head;\\n        \\n        while (true) {\\n            while (!isTail(curr) && curr->val < target)\\n                curr = curr->next;\\n            \\n            // TODO: should we use INT_MAX?\\n            if ((isTail(curr) || curr->val > target) && curr->prev != nullptr)\\n                curr = curr->prev;\\n            prevNodes.push_back(curr);\\n            \\n            // Move downward?\\n            if (curr->down == nullptr)\\n                return curr->val == target;\\n            \\n            if (curr->prev == nullptr)\\n                assert(curr->down->prev == nullptr);\\n            else \\n                assert(curr->val == curr->down->val);\\n            \\n            curr = curr->down;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    void insertAfter(Node *n1, Node *n2) {\\n        assert(n1 != nullptr);\\n        assert(n2 != nullptr);\\n        \\n        Node *next = n1->next;\\n        assert(next != nullptr);\\n        \\n        connH(n1, n2);\\n        connH(n2, next);\\n    }\\n    \\n    void add(int num) {\\n        list<Node *> prevNodes;\\n        search(num, prevNodes);\\n        \\n        Node *newNode = new Node(num);\\n        \\n        size ++;\\n        \\n        if (getMaxLevel() > maxLevel) {\\n            Node *newHead = createHead();\\n            connV(newHead, head);\\n            head = newHead;\\n            maxLevel = getMaxLevel();\\n        \\n            prevNodes.push_front(newHead);\\n        }\\n        \\n        int topLevel = getRandomTopLevel();\\n        assert(topLevel <= maxLevel);\\n    \\n        auto currPrevNode = prev(prevNodes.end());\\n        for (int i = 0; i < topLevel; i ++) {\\n            insertAfter(*currPrevNode, newNode);\\n            \\n            if (i < topLevel - 1) {\\n                Node *currNewNode = new Node(num);\\n                connV(currNewNode, newNode);\\n                newNode = currNewNode;\\n                currPrevNode = prev(currPrevNode);\\n            }\\n        }\\n    }\\n    \\n    void remove(Node* n) {\\n        assert(n != nullptr);\\n        assert(n->prev != nullptr);\\n        assert(n->next != nullptr);\\n        \\n        connH(n->prev, n->next);\\n        \\n        if (n->up != nullptr && n->down != nullptr) \\n            connV(n->up, n->down);\\n        else if (n->up != nullptr)\\n            n->up->down = nullptr;\\n        else if (n->down != nullptr)\\n            n->down->up = nullptr;\\n        \\n        delete n;\\n    }\\n    \\n    bool erase(int num) {\\n        list<Node *> prevNodes;\\n        bool exist = search(num, prevNodes);\\n        \\n        if (exist) {\\n            assert(prevNodes.back()->val == num);\\n            Node *lastPrevNode = prevNodes.back();\\n            while (lastPrevNode != nullptr && lastPrevNode->prev != nullptr) {\\n                Node *nextPrevNode = lastPrevNode->up;\\n                if (nextPrevNode != nullptr) \\n                    assert(nextPrevNode->val == lastPrevNode->val);\\n\\n                remove(lastPrevNode);\\n                lastPrevNode = nextPrevNode;\\n            }\\n            size --;\\n        }\\n        \\n        return exist;\\n    }\\n    \\nprivate:\\n    Node *head;\\n    int size;\\n    int maxLevel;\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Skiplist {\\npublic:\\n    struct Node {\\n        int val;\\n        Node *prev, *next, *up, *down;\\n        \\n        Node(): val(INT_MIN),\\n                prev(nullptr),\\n                next(nullptr),\\n                up(nullptr),\\n                down(nullptr) {}\\n        \\n        Node(int val): val(val), prev(nullptr), next(nullptr), up(nullptr), down(nullptr) {}\\n    };\\n    \\n    \\n    Skiplist() {\\n        head = createHead();\\n        size = 0;\\n        maxLevel = 1;\\n    }\\n    \\n    Node* createHead() {\\n        Node *head = new Node(), *tail = new Node();\\n        connH(head, tail);\\n        \\n        return head;\\n    }\\n    \\n    void connH(Node *prev, Node *next) {\\n        assert(prev != nullptr);\\n        assert(next != nullptr);\\n        \\n        prev->next = next;\\n        next->prev = prev;\\n    }\\n    \\n    void connV(Node *up, Node *down) {\\n        assert(up != nullptr);\\n        assert(down != nullptr);\\n        \\n        up->down = down;\\n        down->up = up;\\n    }\\n    \\n    bool isTail(Node *node) const {\\n        assert(node != nullptr);\\n        return node->next == nullptr;\\n    }\\n    \\n    int getMaxLevel() const {\\n        return size == 0 ? 1 : (int)(ceil(log2((double) size))) + 1;\\n    }\\n    \\n    int getRandomTopLevel() const {\\n        return (int)(ceil((double) rand()/RAND_MAX * maxLevel));\\n    }\\n    \\n    bool search(int target) {\\n        list<Node*> prevNodes;\\n        return search(target, prevNodes);\\n    }\\n    \\n    bool search(int target, list<Node*> &prevNodes) {\\n        Node *curr = head;\\n        \\n        while (true) {\\n            while (!isTail(curr) && curr->val < target)\\n                curr = curr->next;\\n            \\n            // TODO: should we use INT_MAX?\\n            if ((isTail(curr) || curr->val > target) && curr->prev != nullptr)\\n                curr = curr->prev;\\n            prevNodes.push_back(curr);\\n            \\n            // Move downward?\\n            if (curr->down == nullptr)\\n                return curr->val == target;\\n            \\n            if (curr->prev == nullptr)\\n                assert(curr->down->prev == nullptr);\\n            else \\n                assert(curr->val == curr->down->val);\\n            \\n            curr = curr->down;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    void insertAfter(Node *n1, Node *n2) {\\n        assert(n1 != nullptr);\\n        assert(n2 != nullptr);\\n        \\n        Node *next = n1->next;\\n        assert(next != nullptr);\\n        \\n        connH(n1, n2);\\n        connH(n2, next);\\n    }\\n    \\n    void add(int num) {\\n        list<Node *> prevNodes;\\n        search(num, prevNodes);\\n        \\n        Node *newNode = new Node(num);\\n        \\n        size ++;\\n        \\n        if (getMaxLevel() > maxLevel) {\\n            Node *newHead = createHead();\\n            connV(newHead, head);\\n            head = newHead;\\n            maxLevel = getMaxLevel();\\n        \\n            prevNodes.push_front(newHead);\\n        }\\n        \\n        int topLevel = getRandomTopLevel();\\n        assert(topLevel <= maxLevel);\\n    \\n        auto currPrevNode = prev(prevNodes.end());\\n        for (int i = 0; i < topLevel; i ++) {\\n            insertAfter(*currPrevNode, newNode);\\n            \\n            if (i < topLevel - 1) {\\n                Node *currNewNode = new Node(num);\\n                connV(currNewNode, newNode);\\n                newNode = currNewNode;\\n                currPrevNode = prev(currPrevNode);\\n            }\\n        }\\n    }\\n    \\n    void remove(Node* n) {\\n        assert(n != nullptr);\\n        assert(n->prev != nullptr);\\n        assert(n->next != nullptr);\\n        \\n        connH(n->prev, n->next);\\n        \\n        if (n->up != nullptr && n->down != nullptr) \\n            connV(n->up, n->down);\\n        else if (n->up != nullptr)\\n            n->up->down = nullptr;\\n        else if (n->down != nullptr)\\n            n->down->up = nullptr;\\n        \\n        delete n;\\n    }\\n    \\n    bool erase(int num) {\\n        list<Node *> prevNodes;\\n        bool exist = search(num, prevNodes);\\n        \\n        if (exist) {\\n            assert(prevNodes.back()->val == num);\\n            Node *lastPrevNode = prevNodes.back();\\n            while (lastPrevNode != nullptr && lastPrevNode->prev != nullptr) {\\n                Node *nextPrevNode = lastPrevNode->up;\\n                if (nextPrevNode != nullptr) \\n                    assert(nextPrevNode->val == lastPrevNode->val);\\n\\n                remove(lastPrevNode);\\n                lastPrevNode = nextPrevNode;\\n            }\\n            size --;\\n        }\\n        \\n        return exist;\\n    }\\n    \\nprivate:\\n    Node *head;\\n    int size;\\n    int maxLevel;\\n};\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist* obj = new Skiplist();\\n * bool param_1 = obj->search(target);\\n * obj->add(num);\\n * bool param_3 = obj->erase(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1095728,
                "title": "python-3-predecessors-helper-routine",
                "content": "```\\nclass Node:\\n    \\n    def __init__(self, val, next=None, down=None):\\n        self.val = val\\n        self.next = next\\n        self.down = down\\n        \\n\\nclass Skiplist:\\n\\n    def __init__(self):\\n        self.layers = [Node(-1)]\\n        \\n        for rep in range(15):\\n            self.layers.append(Node(-1, None, self.layers[-1]))\\n    \\n    def _predecessors(self, targ):\\n        \\n        ret = []\\n        \\n        u = self.layers[-1]\\n        \\n        while u:\\n            \\n            while u.next and u.next.val < targ:\\n                u = u.next\\n            \\n            ret.append(u)\\n            u = u.down\\n        \\n        return ret[::-1]\\n    \\n    \\n    def search(self, targ: int) -> bool:\\n        \\n        preds = self._predecessors(targ)\\n        return preds[0].next and preds[0].next.val == targ\\n    \\n    \\n    def add(self, targ: int) -> None:\\n        \\n        preds = self._predecessors(targ)\\n        \\n        down = None\\n        \\n        for pred in preds:\\n            \\n            pred.next = Node(targ, pred.next, down)\\n            \\n            if randint(0,1):\\n                break\\n            \\n            down = pred.next\\n                \\n        \\n    def erase(self, targ: int) -> bool:\\n        \\n        preds = self._predecessors(targ)\\n        \\n        if not preds[0].next or preds[0].next.val != targ:\\n            return False\\n        \\n        down = None\\n        \\n        for pred in preds:\\n            \\n            if not pred.next or pred.next.down != down:\\n                break\\n            \\n            down = pred.next\\n            pred.next = pred.next.next\\n        \\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node:\\n    \\n    def __init__(self, val, next=None, down=None):\\n        self.val = val\\n        self.next = next\\n        self.down = down\\n        \\n\\nclass Skiplist:\\n\\n    def __init__(self):\\n        self.layers = [Node(-1)]\\n        \\n        for rep in range(15):\\n            self.layers.append(Node(-1, None, self.layers[-1]))\\n    \\n    def _predecessors(self, targ):\\n        \\n        ret = []\\n        \\n        u = self.layers[-1]\\n        \\n        while u:\\n            \\n            while u.next and u.next.val < targ:\\n                u = u.next\\n            \\n            ret.append(u)\\n            u = u.down\\n        \\n        return ret[::-1]\\n    \\n    \\n    def search(self, targ: int) -> bool:\\n        \\n        preds = self._predecessors(targ)\\n        return preds[0].next and preds[0].next.val == targ\\n    \\n    \\n    def add(self, targ: int) -> None:\\n        \\n        preds = self._predecessors(targ)\\n        \\n        down = None\\n        \\n        for pred in preds:\\n            \\n            pred.next = Node(targ, pred.next, down)\\n            \\n            if randint(0,1):\\n                break\\n            \\n            down = pred.next\\n                \\n        \\n    def erase(self, targ: int) -> bool:\\n        \\n        preds = self._predecessors(targ)\\n        \\n        if not preds[0].next or preds[0].next.val != targ:\\n            return False\\n        \\n        down = None\\n        \\n        for pred in preds:\\n            \\n            if not pred.next or pred.next.down != down:\\n                break\\n            \\n            down = pred.next\\n            pred.next = pred.next.next\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1047185,
                "title": "c-recursive-120-ms",
                "content": "All operation start at head node which is the top level head node. All levels head node has value -1.\\nEach Node has pre, next pointer for same level and down pointer for next level (up is not needed as we use recursive here).\\n\\n1    Add:   For each layer, find the last node smaller or equal to  target node (so this funcion can be shared for both add and erase). \\n\\t             For bottom layer , do insert, other layer if the lower layer has been inserted and coin choose insert, do insert.\\n\\t\\t\\t   \\n2    Search :  Start from top layer, find the last node smaller or equal to  target node, if equal, return. otherwise, goto next layer. \\n3    Erase   :  Start from top layer, find the last node smaller or equal to  target node, if equal, delete it.  Goto next layer.\\n\\n\\n```\\nstruct node\\n{\\n    int cnt = 1;\\n    int v;\\n    node* next = nullptr;\\n    node* pre = nullptr;\\n    node* down = nullptr;\\n    node()\\n    {}\\n    node(int val)\\n    {\\n        v = val;\\n    }\\n};\\nclass Skiplist {\\npublic:\\n    node* head = nullptr;\\n    Skiplist() {\\n        head = new node(-1);\\n    }\\n    node* lower(node* cur, int num)\\n    {\\n        if (cur == nullptr) return nullptr;\\n        node* next = cur->next;\\n        while (next != nullptr && next->v <= num)\\n        {\\n            cur = cur->next;\\n            next = cur->next;\\n        }\\n        return cur;\\n    }\\n    bool search(node* h, int t)\\n    {\\n        node* low = lower(h, t);\\n        if (low != nullptr && low->v == t)\\n        {\\n            return true;\\n        }\\n        if (low && low->down)\\n            return search(low->down, t);\\n        return false;\\n    }\\n    bool search(int target) {\\n        return search(head, target);\\n    }\\n    node* insert(node* cur, int num)\\n    {\\n        if (cur == nullptr) return nullptr;\\n        cur = lower(cur, num);\\n        node* next = (cur != nullptr) ? cur->next : nullptr;\\n        node* down = nullptr;\\n        bool binsert = true;\\n        if (cur->down != nullptr)\\n        {\\n            down = insert(cur->down, num);\\n            binsert = false;\\n            if (down != nullptr)\\n            {\\n                binsert = (rand() & 1) == 0;\\n            }\\n        }\\n        if (binsert)\\n        {\\n            cur->next = new node(num);\\n            cur->next->pre = cur;\\n            cur->next->down = down;\\n            cur->next->next = next;\\n            if (next)\\n            {\\n                next->pre = cur->next;\\n            }\\n            return cur->next;\\n        }\\n        return nullptr;\\n    }\\n\\n    void add(int num) {\\n        node* nd = insert(head, num);\\n        if (nd != nullptr)\\n        {\\n            bool insert = (rand() & 1) == 0;\\n            if (insert)\\n            {\\n                node* nn = new node(-1);\\n                nn->down = head;\\n                head = nn;\\n                nn->next = new node(num);\\n                nn->next->pre = nn;\\n                nn->next->down = nd;\\n            }\\n        }\\n    }\\n    bool erase(node* h, int t)\\n    {\\n        node* low = lower(h, t);\\n        bool res = false;\\n        if (low != nullptr && low->down != nullptr)\\n        {\\n            res = erase(low->down, t);\\n        }\\n        if (low != nullptr && low->v == t)\\n        {\\n            low->pre->next = low->next;\\n            if (low->next)\\n            {\\n                low->next->pre = low->pre;\\n            }\\n            delete low;\\n            res = true;\\n        }\\n        return res;\\n    }\\n    bool erase(int num) {\\n        return erase(head, num);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct node\\n{\\n    int cnt = 1;\\n    int v;\\n    node* next = nullptr;\\n    node* pre = nullptr;\\n    node* down = nullptr;\\n    node()\\n    {}\\n    node(int val)\\n    {\\n        v = val;\\n    }\\n};\\nclass Skiplist {\\npublic:\\n    node* head = nullptr;\\n    Skiplist() {\\n        head = new node(-1);\\n    }\\n    node* lower(node* cur, int num)\\n    {\\n        if (cur == nullptr) return nullptr;\\n        node* next = cur->next;\\n        while (next != nullptr && next->v <= num)\\n        {\\n            cur = cur->next;\\n            next = cur->next;\\n        }\\n        return cur;\\n    }\\n    bool search(node* h, int t)\\n    {\\n        node* low = lower(h, t);\\n        if (low != nullptr && low->v == t)\\n        {\\n            return true;\\n        }\\n        if (low && low->down)\\n            return search(low->down, t);\\n        return false;\\n    }\\n    bool search(int target) {\\n        return search(head, target);\\n    }\\n    node* insert(node* cur, int num)\\n    {\\n        if (cur == nullptr) return nullptr;\\n        cur = lower(cur, num);\\n        node* next = (cur != nullptr) ? cur->next : nullptr;\\n        node* down = nullptr;\\n        bool binsert = true;\\n        if (cur->down != nullptr)\\n        {\\n            down = insert(cur->down, num);\\n            binsert = false;\\n            if (down != nullptr)\\n            {\\n                binsert = (rand() & 1) == 0;\\n            }\\n        }\\n        if (binsert)\\n        {\\n            cur->next = new node(num);\\n            cur->next->pre = cur;\\n            cur->next->down = down;\\n            cur->next->next = next;\\n            if (next)\\n            {\\n                next->pre = cur->next;\\n            }\\n            return cur->next;\\n        }\\n        return nullptr;\\n    }\\n\\n    void add(int num) {\\n        node* nd = insert(head, num);\\n        if (nd != nullptr)\\n        {\\n            bool insert = (rand() & 1) == 0;\\n            if (insert)\\n            {\\n                node* nn = new node(-1);\\n                nn->down = head;\\n                head = nn;\\n                nn->next = new node(num);\\n                nn->next->pre = nn;\\n                nn->next->down = nd;\\n            }\\n        }\\n    }\\n    bool erase(node* h, int t)\\n    {\\n        node* low = lower(h, t);\\n        bool res = false;\\n        if (low != nullptr && low->down != nullptr)\\n        {\\n            res = erase(low->down, t);\\n        }\\n        if (low != nullptr && low->v == t)\\n        {\\n            low->pre->next = low->next;\\n            if (low->next)\\n            {\\n                low->next->pre = low->pre;\\n            }\\n            delete low;\\n            res = true;\\n        }\\n        return res;\\n    }\\n    bool erase(int num) {\\n        return erase(head, num);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030454,
                "title": "c-support-duplicates-run-fast",
                "content": "```\\nstruct Node {\\n    Node* next;\\n    Node* son;\\n    int data;\\n    Node(int data = -1, Node* next = NULL, Node* son = NULL): data(data), next(next), son(son) {};\\n};\\n\\nclass Skiplist {\\npublic:\\n    Node* head;\\n    vector<Node*> preStack;\\n    Skiplist() {\\n        this->head = new Node();\\n    }\\n    \\n    bool search(int target) {\\n        Node* pre = head;\\n        while (pre) {\\n            while (pre->next) {\\n                if (pre->next->data == target) {\\n                    return true;\\n                } else if (pre->next->data < target) {\\n                    pre = pre->next;\\n                } else {\\n                    break;\\n                }\\n            }\\n            pre = pre->son;\\n        }\\n        return false;\\n    }\\n    \\n    void add(int num) {\\n        preStack.clear();\\n        Node* pre = head;\\n        while (pre) {\\n            while (pre->next) {\\n                if (pre->next->data >= num) {\\n                    preStack.push_back(pre);\\n                    break;\\n                } else {\\n                    pre = pre->next;\\n                }\\n            }\\n            pre = pre->son;\\n        }\\n        bool insertUp = true;\\n        Node* newNode = NULL;\\n        while (insertUp && preStack.size()) {\\n            Node *pre = preStack.back();\\n            preStack.pop_back();\\n            newNode = new Node(num, pre->next, newNode);\\n            pre->next = newNode;\\n            \\n            insertUp = (rand() & 4) == 0;\\n        }\\n        if (insertUp) {\\n            head = new Node(-1, new Node(num, NULL, newNode), head);\\n        }\\n    }\\n    \\n    bool erase(int num) {\\n        Node* pre = head;\\n        Node* preHead = NULL;\\n        Node* preFather = NULL;\\n        bool result = false;\\n        while (pre) {\\n            while (pre->next) {\\n                if (pre->next->data == num) {\\n                    // \\u5904\\u7406\\u91CD\\u590D\\u5143\\u7D20\\u7684\\u60C5\\u51B5\\n                    if (preFather == NULL) {\\n                        preHead = preFather = pre->next;\\n                        pre->next = pre->next->next;\\n                        result = true;\\n                        break;\\n                    } else if(preFather->son != pre->next) {\\n                        pre = pre->next;\\n                    } else {                 \\n                        preFather = pre->next;\\n                        pre->next = pre->next->next;\\n                        result = true;\\n                        break;\\n                    }\\n                } else if (pre->next->data < num) {\\n                    pre = pre->next;\\n                } else {\\n                    break;\\n                }\\n            }\\n            pre = pre->son;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Node {\\n    Node* next;\\n    Node* son;\\n    int data;\\n    Node(int data = -1, Node* next = NULL, Node* son = NULL): data(data), next(next), son(son) {};\\n};\\n\\nclass Skiplist {\\npublic:\\n    Node* head;\\n    vector<Node*> preStack;\\n    Skiplist() {\\n        this->head = new Node();\\n    }\\n    \\n    bool search(int target) {\\n        Node* pre = head;\\n        while (pre) {\\n            while (pre->next) {\\n                if (pre->next->data == target) {\\n                    return true;\\n                } else if (pre->next->data < target) {\\n                    pre = pre->next;\\n                } else {\\n                    break;\\n                }\\n            }\\n            pre = pre->son;\\n        }\\n        return false;\\n    }\\n    \\n    void add(int num) {\\n        preStack.clear();\\n        Node* pre = head;\\n        while (pre) {\\n            while (pre->next) {\\n                if (pre->next->data >= num) {\\n                    preStack.push_back(pre);\\n                    break;\\n                } else {\\n                    pre = pre->next;\\n                }\\n            }\\n            pre = pre->son;\\n        }\\n        bool insertUp = true;\\n        Node* newNode = NULL;\\n        while (insertUp && preStack.size()) {\\n            Node *pre = preStack.back();\\n            preStack.pop_back();\\n            newNode = new Node(num, pre->next, newNode);\\n            pre->next = newNode;\\n            \\n            insertUp = (rand() & 4) == 0;\\n        }\\n        if (insertUp) {\\n            head = new Node(-1, new Node(num, NULL, newNode), head);\\n        }\\n    }\\n    \\n    bool erase(int num) {\\n        Node* pre = head;\\n        Node* preHead = NULL;\\n        Node* preFather = NULL;\\n        bool result = false;\\n        while (pre) {\\n            while (pre->next) {\\n                if (pre->next->data == num) {\\n                    // \\u5904\\u7406\\u91CD\\u590D\\u5143\\u7D20\\u7684\\u60C5\\u51B5\\n                    if (preFather == NULL) {\\n                        preHead = preFather = pre->next;\\n                        pre->next = pre->next->next;\\n                        result = true;\\n                        break;\\n                    } else if(preFather->son != pre->next) {\\n                        pre = pre->next;\\n                    } else {                 \\n                        preFather = pre->next;\\n                        pre->next = pre->next->next;\\n                        result = true;\\n                        break;\\n                    }\\n                } else if (pre->next->data < num) {\\n                    pre = pre->next;\\n                } else {\\n                    break;\\n                }\\n            }\\n            pre = pre->son;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999818,
                "title": "c-working-code-runs-too-slow",
                "content": "The following code takes 864ms (faster than only 5.8% C++ submissions). I am struggling to understand why this code is running so slow. Any help is appreciated.\\n\\nIt could be due to the use of recursion, however memory usage is quite less (better than 98% C++ submissions) and I have not heard of recursion slowing down execution.\\n```\\n/* \\nskiplist -> each layer has sorted lists,\\nlowest layer has all elements.\\nwhen an element is added in lowest layer, a coin is flipped to decide whether it should be added in immediate above layer and so on for the above layers.\\nthe upper layers act as an index, traversing which we can search,add,delete in O(logn) time\\n*/\\nclass Node\\n{\\npublic:\\n    int val;\\n    Node * right;\\n    Node * bottom;\\n    \\n    Node(int val)\\n    {\\n        this->val = val;\\n        right = NULL;\\n        bottom = NULL;\\n    }\\n    \\n};\\n\\nclass Skiplist {\\npublic:\\n    \\n    vector < Node * > skiplist;\\n    \\n    Node * init_level()\\n    {\\n\\t\\t// each level has initial entry of INT_MIN\\n        Node * ptr = new Node(INT_MIN);\\n        return ptr;\\n    }\\n    \\n    Skiplist() {\\n        for(int i=0;i<16;i++) // 16 levels cuz 16 < log200000\\n            skiplist.push_back(init_level());\\n        // seed rand so same skip list generated for given input (easier debugging)\\n        srand(100);\\n    }\\n    \\n    bool search(int target) {\\n        \\n        Node * ptr = skiplist[skiplist.size()-1];\\n        while(ptr)\\n        {\\n            Node * r = ptr->right;\\n            while(r && r->val <= target)\\n            {\\n                ptr = r;\\n                r = ptr->right;\\n            }\\n            if(ptr->val==target) return true;\\n            \\n            if(ptr->bottom)\\n                ptr = ptr->bottom;\\n            else return false;\\n        }\\n        return false;\\n        \\n    }\\n    \\n    Node * add_recurse(int val, Node * ptr)\\n    {\\n        Node * r = ptr->right;\\n        Node * new_node_ptr = NULL;\\n        Node * bot_node_ptr = NULL;\\n        while(r && r->val <= val)\\n        {\\n            ptr = r;\\n            r = r->right;\\n        }\\n        if(ptr->bottom)\\n        {\\n            bot_node_ptr = add_recurse(val,ptr->bottom);\\n            // insert new node only if inserted below with a 50% chance\\n            if(bot_node_ptr && rand()%100<50)\\n            {\\n                new_node_ptr = new Node(val);\\n                ptr->right  = new_node_ptr;\\n                new_node_ptr->right = r;\\n                new_node_ptr->bottom = bot_node_ptr;\\n            }\\n        }\\n        else\\n        { \\n            // lower most layer\\n            \\n            new_node_ptr = new Node(val);\\n            ptr->right  = new_node_ptr;\\n            new_node_ptr->right = r;\\n        }\\n        return new_node_ptr;\\n    }\\n    \\n    void add(int val) {\\n        \\n        Node * ptr = skiplist[skiplist.size()-1];\\n        add_recurse(val,ptr);\\n        \\n        \\n    }\\n    \\n    bool erase_recurse(int val, Node * ptr)\\n    {\\n        Node * r = ptr->right;\\n        Node * prev = NULL;\\n        while(r && r->val <= val)\\n        {\\n            prev = ptr;\\n            ptr = r;\\n            r = r->right;\\n        }\\n        bool flag = false;\\n        if(ptr->bottom)\\n        {\\n            flag = erase_recurse(val,ptr->bottom);\\n        }\\n        if(ptr->val==val)\\n        {                                             \\n            prev->right  = ptr->right;\\n            delete ptr;\\n            return true;\\n        }\\n        \\n        return flag;\\n        \\n      \\n        \\n    }\\n    \\n    bool erase(int val) {\\n        Node * ptr = skiplist[skiplist.size()-1];\\n        return erase_recurse(val,ptr);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/* \\nskiplist -> each layer has sorted lists,\\nlowest layer has all elements.\\nwhen an element is added in lowest layer, a coin is flipped to decide whether it should be added in immediate above layer and so on for the above layers.\\nthe upper layers act as an index, traversing which we can search,add,delete in O(logn) time\\n*/\\nclass Node\\n{\\npublic:\\n    int val;\\n    Node * right;\\n    Node * bottom;\\n    \\n    Node(int val)\\n    {\\n        this->val = val;\\n        right = NULL;\\n        bottom = NULL;\\n    }\\n    \\n};\\n\\nclass Skiplist {\\npublic:\\n    \\n    vector < Node * > skiplist;\\n    \\n    Node * init_level()\\n    {\\n\\t\\t// each level has initial entry of INT_MIN\\n        Node * ptr = new Node(INT_MIN);\\n        return ptr;\\n    }\\n    \\n    Skiplist() {\\n        for(int i=0;i<16;i++) // 16 levels cuz 16 < log200000\\n            skiplist.push_back(init_level());\\n        // seed rand so same skip list generated for given input (easier debugging)\\n        srand(100);\\n    }\\n    \\n    bool search(int target) {\\n        \\n        Node * ptr = skiplist[skiplist.size()-1];\\n        while(ptr)\\n        {\\n            Node * r = ptr->right;\\n            while(r && r->val <= target)\\n            {\\n                ptr = r;\\n                r = ptr->right;\\n            }\\n            if(ptr->val==target) return true;\\n            \\n            if(ptr->bottom)\\n                ptr = ptr->bottom;\\n            else return false;\\n        }\\n        return false;\\n        \\n    }\\n    \\n    Node * add_recurse(int val, Node * ptr)\\n    {\\n        Node * r = ptr->right;\\n        Node * new_node_ptr = NULL;\\n        Node * bot_node_ptr = NULL;\\n        while(r && r->val <= val)\\n        {\\n            ptr = r;\\n            r = r->right;\\n        }\\n        if(ptr->bottom)\\n        {\\n            bot_node_ptr = add_recurse(val,ptr->bottom);\\n            // insert new node only if inserted below with a 50% chance\\n            if(bot_node_ptr && rand()%100<50)\\n            {\\n                new_node_ptr = new Node(val);\\n                ptr->right  = new_node_ptr;\\n                new_node_ptr->right = r;\\n                new_node_ptr->bottom = bot_node_ptr;\\n            }\\n        }\\n        else\\n        { \\n            // lower most layer\\n            \\n            new_node_ptr = new Node(val);\\n            ptr->right  = new_node_ptr;\\n            new_node_ptr->right = r;\\n        }\\n        return new_node_ptr;\\n    }\\n    \\n    void add(int val) {\\n        \\n        Node * ptr = skiplist[skiplist.size()-1];\\n        add_recurse(val,ptr);\\n        \\n        \\n    }\\n    \\n    bool erase_recurse(int val, Node * ptr)\\n    {\\n        Node * r = ptr->right;\\n        Node * prev = NULL;\\n        while(r && r->val <= val)\\n        {\\n            prev = ptr;\\n            ptr = r;\\n            r = r->right;\\n        }\\n        bool flag = false;\\n        if(ptr->bottom)\\n        {\\n            flag = erase_recurse(val,ptr->bottom);\\n        }\\n        if(ptr->val==val)\\n        {                                             \\n            prev->right  = ptr->right;\\n            delete ptr;\\n            return true;\\n        }\\n        \\n        return flag;\\n        \\n      \\n        \\n    }\\n    \\n    bool erase(int val) {\\n        Node * ptr = skiplist[skiplist.size()-1];\\n        return erase_recurse(val,ptr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 964891,
                "title": "theoretical-aspect-of-skip-lists",
                "content": "I wrote an article to simplify understanding skip lists.\\nHere\\'s the link : https://leetcodesolver.medium.com/skip-lists-lets-make-it-simple-f255627706f3",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 962648,
                "title": "scala-solution",
                "content": "It is translated from https://leetcode.com/problems/design-skiplist/discuss/393499/Java-Solution-beats-100\\nbut I hope with further input, it could be made much more like with type classes etc.\\n```\\nimport scala.collection.mutable.ListBuffer\\nimport scala.util.Random\\nimport scala.util.control.Breaks._\\nclass Skiplist() {\\n\\n    case class Node(value: Int, _left: Node = null,\\n                  _right: Node = null,\\n                  _up: Node = null,\\n                  _down: Node = null) {\\n    var left = _left\\n    var right = _right\\n    var up = _up\\n    var down = _down\\n  }\\n\\n  final val DEFAULT_PROB: Double = 0.5\\n  final val random: Random = new Random()\\n  final val sentinels = ListBuffer[Node]()\\n  sentinels.addOne(Node(Int.MinValue))\\n\\n  // search\\n  def search(target: Int): Boolean = {\\n    val smallerOrEquals = getSmallerOrEqual(target)\\n    smallerOrEquals.value == target\\n  }\\n  // add\\n  def add(num: Int): Unit = {\\n    val cur = getSmallerOrEqual(num)\\n    val toInsert = Node(num)\\n    append(cur, toInsert)\\n    populateLevelUp(toInsert)\\n  }\\n  // populateLevelUp\\n  def populateLevelUp(toInsert: Node): Unit = {\\n    var curLeft = toInsert.left\\n    var cur = toInsert\\n\\n    // flip coin for the newly inserted node, either it would be added to up level or no\\n    while(flipCoin()) {\\n      // On current level go back till I find last node and add new Layer or if we are in some below layer\\n      // find node on same layer which is connected with upper layer\\n      while(curLeft.left != null && curLeft.up == null) {\\n        curLeft = curLeft.left\\n      }\\n      // Adding new Layer on Top\\n      if(curLeft.up == null) {\\n        val newSenital = Node(Int.MinValue)\\n        curLeft.up = newSenital\\n        newSenital.down = curLeft\\n        sentinels.addOne(newSenital)\\n      }\\n      // Move to upper Layer\\n      curLeft = curLeft.up\\n      // Create New Node to be inserted\\n      val newNode = Node(toInsert.value)\\n      cur.up = newNode\\n      newNode.down = cur\\n      cur = cur.up\\n      curLeft.right = cur\\n      cur.left = curLeft\\n    }\\n  }\\n  // append\\n  def append(prev: Node, cur: Node): Unit = {\\n    val next = prev.right\\n    prev.right = cur\\n    cur.left = prev\\n\\n    if(next != null) {\\n      next.left = cur\\n      cur.right = next\\n    }\\n  }\\n  // erase\\n  def erase(num: Int): Boolean = {\\n    val toRemove = getSmallerOrEqual(num)\\n    if(toRemove.value != num) return false\\n\\n    var cur = toRemove\\n    while(cur != null) {\\n      val prev = cur.left\\n      val next = cur.right\\n      prev.right = next\\n      if(next != null) next.left = prev\\n      cur = cur.up\\n    }\\n    true\\n  }\\n  // getSmallerOrEqual\\n  def getSmallerOrEqual(target: Int): Node = {\\n    var cur = sentinels(sentinels.size - 1)\\n    breakable {\\n      while (cur != null) {\\n        if (cur.right == null || cur.right.value > target) {\\n          if (cur.down == null) break\\n          cur = cur.down\\n        } else cur = cur.right\\n      }\\n    }\\n    cur\\n  }\\n  // flipCoin\\n  def flipCoin(): Boolean = {\\n    random.nextDouble() < DEFAULT_PROB\\n  }\\n\\n  // toString\\n  override def toString: String = {\\n    var node = sentinels(0)\\n    val sb = new StringBuilder()\\n    var i = 0\\n    while(node != null) {\\n      var itr = node\\n      while(itr != null) {\\n        if(itr.value == Int.MinValue) {\\n          sb.append(s\"L${i}\").append(\" --> \")\\n          i += 1\\n        } else\\n          sb.append(itr.value).append(\" --> \")\\n        itr = itr.right\\n      }\\n      sb.append(\"\\\\n\")\\n      node = node.up\\n    }\\n    sb.toString\\n  }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport scala.collection.mutable.ListBuffer\\nimport scala.util.Random\\nimport scala.util.control.Breaks._\\nclass Skiplist() {\\n\\n    case class Node(value: Int, _left: Node = null,\\n                  _right: Node = null,\\n                  _up: Node = null,\\n                  _down: Node = null) {\\n    var left = _left\\n    var right = _right\\n    var up = _up\\n    var down = _down\\n  }\\n\\n  final val DEFAULT_PROB: Double = 0.5\\n  final val random: Random = new Random()\\n  final val sentinels = ListBuffer[Node]()\\n  sentinels.addOne(Node(Int.MinValue))\\n\\n  // search\\n  def search(target: Int): Boolean = {\\n    val smallerOrEquals = getSmallerOrEqual(target)\\n    smallerOrEquals.value == target\\n  }\\n  // add\\n  def add(num: Int): Unit = {\\n    val cur = getSmallerOrEqual(num)\\n    val toInsert = Node(num)\\n    append(cur, toInsert)\\n    populateLevelUp(toInsert)\\n  }\\n  // populateLevelUp\\n  def populateLevelUp(toInsert: Node): Unit = {\\n    var curLeft = toInsert.left\\n    var cur = toInsert\\n\\n    // flip coin for the newly inserted node, either it would be added to up level or no\\n    while(flipCoin()) {\\n      // On current level go back till I find last node and add new Layer or if we are in some below layer\\n      // find node on same layer which is connected with upper layer\\n      while(curLeft.left != null && curLeft.up == null) {\\n        curLeft = curLeft.left\\n      }\\n      // Adding new Layer on Top\\n      if(curLeft.up == null) {\\n        val newSenital = Node(Int.MinValue)\\n        curLeft.up = newSenital\\n        newSenital.down = curLeft\\n        sentinels.addOne(newSenital)\\n      }\\n      // Move to upper Layer\\n      curLeft = curLeft.up\\n      // Create New Node to be inserted\\n      val newNode = Node(toInsert.value)\\n      cur.up = newNode\\n      newNode.down = cur\\n      cur = cur.up\\n      curLeft.right = cur\\n      cur.left = curLeft\\n    }\\n  }\\n  // append\\n  def append(prev: Node, cur: Node): Unit = {\\n    val next = prev.right\\n    prev.right = cur\\n    cur.left = prev\\n\\n    if(next != null) {\\n      next.left = cur\\n      cur.right = next\\n    }\\n  }\\n  // erase\\n  def erase(num: Int): Boolean = {\\n    val toRemove = getSmallerOrEqual(num)\\n    if(toRemove.value != num) return false\\n\\n    var cur = toRemove\\n    while(cur != null) {\\n      val prev = cur.left\\n      val next = cur.right\\n      prev.right = next\\n      if(next != null) next.left = prev\\n      cur = cur.up\\n    }\\n    true\\n  }\\n  // getSmallerOrEqual\\n  def getSmallerOrEqual(target: Int): Node = {\\n    var cur = sentinels(sentinels.size - 1)\\n    breakable {\\n      while (cur != null) {\\n        if (cur.right == null || cur.right.value > target) {\\n          if (cur.down == null) break\\n          cur = cur.down\\n        } else cur = cur.right\\n      }\\n    }\\n    cur\\n  }\\n  // flipCoin\\n  def flipCoin(): Boolean = {\\n    random.nextDouble() < DEFAULT_PROB\\n  }\\n\\n  // toString\\n  override def toString: String = {\\n    var node = sentinels(0)\\n    val sb = new StringBuilder()\\n    var i = 0\\n    while(node != null) {\\n      var itr = node\\n      while(itr != null) {\\n        if(itr.value == Int.MinValue) {\\n          sb.append(s\"L${i}\").append(\" --> \")\\n          i += 1\\n        } else\\n          sb.append(itr.value).append(\" --> \")\\n        itr = itr.right\\n      }\\n      sb.append(\"\\\\n\")\\n      node = node.up\\n    }\\n    sb.toString\\n  }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 954762,
                "title": "kotlin-o-log-n-time-and-o-n-space",
                "content": "\\n    class Node(var `val`: Int, var next: Node?, var down: Node?)\\n\\n    var dummy = Node(-1, null, null)\\n    val rand = Random()\\n\\n    fun search(target: Int): Boolean {\\n        var node: Node? = dummy\\n\\n        while (node != null) {\\n            while (node?.next != null && node.next!!.`val` < target)\\n                node = node.next\\n            if (node?.next != null && node.next!!.`val` == target)\\n                return true\\n            else\\n                node = node?.down\\n        }\\n        return false\\n    }\\n\\n    fun add(num: Int) {\\n        val stack = Stack<Node>()\\n        var node: Node? = dummy\\n        var down: Node? = null\\n        var isInsert = true\\n\\n        while (node != null) {\\n            while (node?.next != null && node.next!!.`val` < num)\\n                node = node.next!!\\n            stack.push(node)\\n            node = node?.down\\n        }\\n\\n        while (!stack.isEmpty() && isInsert) {\\n            node = stack.pop()\\n            node.next = Node(num, node.next, down)\\n            down = node.next!!\\n            isInsert = rand.nextDouble() < 0.5 // logN\\n        }\\n\\n        if (isInsert)\\n            dummy = Node(-1, null, dummy)\\n    }\\n\\n    fun erase(num: Int): Boolean {\\n        var node: Node? = dummy\\n        var found = false\\n\\n        while (node != null) {\\n            while (node?.next != null && node.next!!.`val` < num)\\n                node = node.next!!\\n            if (node?.next != null && node.next!!.`val` == num) {\\n                node.next = node.next!!.next\\n                found = true\\n            }\\n            node = node?.down\\n        }\\n\\n        return found\\n    }\\n\\n",
                "solutionTags": [],
                "code": "\\n    class Node(var `val`: Int, var next: Node?, var down: Node?)\\n\\n    var dummy = Node(-1, null, null)\\n    val rand = Random()\\n\\n    fun search(target: Int): Boolean {\\n        var node: Node? = dummy\\n\\n        while (node != null) {\\n            while (node?.next != null && node.next!!.`val` < target)\\n                node = node.next\\n            if (node?.next != null && node.next!!.`val` == target)\\n                return true\\n            else\\n                node = node?.down\\n        }\\n        return false\\n    }\\n\\n    fun add(num: Int) {\\n        val stack = Stack<Node>()\\n        var node: Node? = dummy\\n        var down: Node? = null\\n        var isInsert = true\\n\\n        while (node != null) {\\n            while (node?.next != null && node.next!!.`val` < num)\\n                node = node.next!!\\n            stack.push(node)\\n            node = node?.down\\n        }\\n\\n        while (!stack.isEmpty() && isInsert) {\\n            node = stack.pop()\\n            node.next = Node(num, node.next, down)\\n            down = node.next!!\\n            isInsert = rand.nextDouble() < 0.5 // logN\\n        }\\n\\n        if (isInsert)\\n            dummy = Node(-1, null, dummy)\\n    }\\n\\n    fun erase(num: Int): Boolean {\\n        var node: Node? = dummy\\n        var found = false\\n\\n        while (node != null) {\\n            while (node?.next != null && node.next!!.`val` < num)\\n                node = node.next!!\\n            if (node?.next != null && node.next!!.`val` == num) {\\n                node.next = node.next!!.next\\n                found = true\\n            }\\n            node = node?.down\\n        }\\n\\n        return found\\n    }\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 952675,
                "title": "java-speed-and-memory-beat-80",
                "content": "```\\nclass Skiplist {\\n    \\n    Random rand = new Random();\\n    class Node{\\n        Node next;\\n        Node down;\\n        int level;\\n        int val;\\n        Node(int val, int level){\\n            this.val = val;\\n            this.level = level;\\n        }\\n        \\n    }\\n    \\n    List<Node> heads;\\n    \\n    public Skiplist() {\\n        heads = new ArrayList<>();\\n        heads.add(new Node(Integer.MIN_VALUE, 0));\\n        siftUp(heads.get(0)); //check if more levels needed to be built on the top\\n    }\\n\\n    public boolean search(int target) {\\n        Node node = heads.get(heads.size()-1);\\n        while(node.down != null){\\n            while(node.next != null){\\n                if(target == node.val) return true;\\n                if(node.next.val > target)\\n                    break;\\n                node = node.next;\\n            }\\n            node = node.down;\\n        }\\n        for(;node != null && node.val <= target; node=node.next){\\n            if(node.val == target){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public void add(int num) {\\n        Node n = null;\\n        if(heads.isEmpty()){\\n            n = new Node(num, 0);\\n            heads.add(n);\\n        }else{\\n            n = add(heads.get(heads.size()-1), num);\\n        }\\n        if(n.level == this.heads.size()-1){\\n            siftUp(n); //check if more levels needed to be built on the top\\n        }\\n    }\\n\\n    private Node add(Node head, int num){\\n        if(head.next == null || head.next.val >= num){\\n            if(head.down != null){\\n                Node added = add(head.down, num);\\n                if(head.level == added.level+1 && rand.nextInt(2) == 1){\\n                    Node newNode = new Node(num, head.level);\\n                    insertAfter(head, newNode); \\n                    newNode.down = added;\\n                    return newNode;\\n                }\\n                return added;\\n            }else{\\n                Node newNode = new Node(num, head.level);\\n                insertAfter(head, newNode);\\n                return newNode;\\n            }\\n            \\n        }\\n        return add(head.next, num);\\n    }\\n\\n    private void insertAfter(Node prev, Node node){\\n        Node next = prev.next;\\n        if(next != null){\\n            node.next = next;\\n        }\\n        prev.next= node;\\n    }\\n\\n    private void siftUp(Node node){\\n        Node head = this.heads.get(this.heads.size()-1);\\n        while(rand.nextInt(2) == 1){\\n            Node newHead = new Node(head.val, head.level+1);\\n            newHead.down = head;\\n            this.heads.add(newHead);\\n            if(head != node){\\n                Node newNode = new Node(node.val, node.level+1);\\n                newNode.down = node;\\n                newHead.next = newNode;\\n                node = newNode;\\n            }else{\\n                node = newHead;\\n            }          \\n            head = newHead;\\n        }\\n    }\\n\\n    public boolean erase(int num) {\\n        Node head = heads.get(heads.size()-1);\\n        return erase(head, num);\\n    }\\n\\n    private boolean erase(Node head, int num){\\n        boolean erased = false;\\n        if(head.next == null || head.next.val >= num){\\n            if(head.down != null){\\n                erased = erase(head.down, num);\\n            }\\n            if(erased || head.down == null){\\n                if(head.next != null && head.next.val == num){\\n                    head.next = head.next.next;\\n                    erased = true;\\n                }\\n            }\\n            return erased;\\n        }\\n        return erase(head.next, num);\\n    }\\n    \\n}\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist obj = new Skiplist();\\n * boolean param_1 = obj.search(target);\\n * obj.add(num);\\n * boolean param_3 = obj.erase(num);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Skiplist {\\n    \\n    Random rand = new Random();\\n    class Node{\\n        Node next;\\n        Node down;\\n        int level;\\n        int val;\\n        Node(int val, int level){\\n            this.val = val;\\n            this.level = level;\\n        }\\n        \\n    }\\n    \\n    List<Node> heads;\\n    \\n    public Skiplist() {\\n        heads = new ArrayList<>();\\n        heads.add(new Node(Integer.MIN_VALUE, 0));\\n        siftUp(heads.get(0)); //check if more levels needed to be built on the top\\n    }\\n\\n    public boolean search(int target) {\\n        Node node = heads.get(heads.size()-1);\\n        while(node.down != null){\\n            while(node.next != null){\\n                if(target == node.val) return true;\\n                if(node.next.val > target)\\n                    break;\\n                node = node.next;\\n            }\\n            node = node.down;\\n        }\\n        for(;node != null && node.val <= target; node=node.next){\\n            if(node.val == target){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public void add(int num) {\\n        Node n = null;\\n        if(heads.isEmpty()){\\n            n = new Node(num, 0);\\n            heads.add(n);\\n        }else{\\n            n = add(heads.get(heads.size()-1), num);\\n        }\\n        if(n.level == this.heads.size()-1){\\n            siftUp(n); //check if more levels needed to be built on the top\\n        }\\n    }\\n\\n    private Node add(Node head, int num){\\n        if(head.next == null || head.next.val >= num){\\n            if(head.down != null){\\n                Node added = add(head.down, num);\\n                if(head.level == added.level+1 && rand.nextInt(2) == 1){\\n                    Node newNode = new Node(num, head.level);\\n                    insertAfter(head, newNode); \\n                    newNode.down = added;\\n                    return newNode;\\n                }\\n                return added;\\n            }else{\\n                Node newNode = new Node(num, head.level);\\n                insertAfter(head, newNode);\\n                return newNode;\\n            }\\n            \\n        }\\n        return add(head.next, num);\\n    }\\n\\n    private void insertAfter(Node prev, Node node){\\n        Node next = prev.next;\\n        if(next != null){\\n            node.next = next;\\n        }\\n        prev.next= node;\\n    }\\n\\n    private void siftUp(Node node){\\n        Node head = this.heads.get(this.heads.size()-1);\\n        while(rand.nextInt(2) == 1){\\n            Node newHead = new Node(head.val, head.level+1);\\n            newHead.down = head;\\n            this.heads.add(newHead);\\n            if(head != node){\\n                Node newNode = new Node(node.val, node.level+1);\\n                newNode.down = node;\\n                newHead.next = newNode;\\n                node = newNode;\\n            }else{\\n                node = newHead;\\n            }          \\n            head = newHead;\\n        }\\n    }\\n\\n    public boolean erase(int num) {\\n        Node head = heads.get(heads.size()-1);\\n        return erase(head, num);\\n    }\\n\\n    private boolean erase(Node head, int num){\\n        boolean erased = false;\\n        if(head.next == null || head.next.val >= num){\\n            if(head.down != null){\\n                erased = erase(head.down, num);\\n            }\\n            if(erased || head.down == null){\\n                if(head.next != null && head.next.val == num){\\n                    head.next = head.next.next;\\n                    erased = true;\\n                }\\n            }\\n            return erased;\\n        }\\n        return erase(head.next, num);\\n    }\\n    \\n}\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist obj = new Skiplist();\\n * boolean param_1 = obj.search(target);\\n * obj.add(num);\\n * boolean param_3 = obj.erase(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936235,
                "title": "c-solution",
                "content": "Not sure if I did this right, let me know otherwise!\\n\\n```\\nstruct Node {\\n    int val;\\n    Node* prev;\\n    Node* next;\\n    Node* down;\\n    \\n    Node(int val): val(val), prev(nullptr), next(nullptr), down(nullptr) {}\\n};\\n\\nclass Skiplist {\\n    Node* entry;\\n    int levels; // Number of levels to start with. This solution uses a fixed size.\\n    \\npublic:\\n    Skiplist(): levels(15) {\\n        // Dummy\\n        entry = new Node(-2);\\n        Node* prev = entry;\\n        \\n        // Initialize dummy starts for each level\\n        for (int i = 0; i < levels; ++i) {\\n            Node* head = new Node(-2); // Dummy start for level\\n            Node* tail = new Node(-1); // Dummy end for level\\n            head->next = tail;\\n            tail->prev = head;\\n            \\n            prev->down = head;\\n            prev = head;\\n        }\\n    }\\n    \\n    bool search(int num) {\\n        Node* cur = entry->down;\\n        \\n        while (cur) {\\n            if (cur ->val == num) {\\n                return true;\\n            }\\n            \\n            if (cur->val == -1 || num <= cur->val) {\\n                cur = cur->prev->down;\\n            } else {\\n                cur = cur->next;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    void add(int num) {\\n        vector<Node*> prevs; // Store the path taken, so we may insert.\\n        Node* cur = entry->down;\\n        \\n        while (cur) {\\n            if (cur->val == -1 || num <= cur->val) {\\n                prevs.push_back(cur->prev);\\n                cur = cur->prev->down;\\n            } else {\\n                cur = cur->next;\\n            }\\n        }\\n        \\n        // Insert into last last level\\n        Node* down = prevs.back();\\n        addNode(down, new Node(num));\\n        \\n        // Probabilistially add the rest while getProb returns true\\n        for (int i = prevs.size()-2; i >= 0 && getProb(); --i) {\\n            Node* n = new Node(num);\\n            addNode(prevs[i], n);\\n            \\n            n->down = down;\\n            down = n;\\n        }        \\n    }\\n    \\n    bool erase(int num) {\\n        vector<Node*> remove;\\n        Node* cur = entry->down;\\n        \\n        while (cur) {\\n            if (cur->val == -1 || num <= cur->val) {\\n                if (cur->val == num) {\\n                    remove.push_back(cur);\\n                }\\n                cur = cur->prev->down;\\n            } else {\\n                cur = cur->next;\\n            }\\n        }\\n        \\n        for (auto node: remove) {\\n            node->prev->next = node->next;\\n            node->next->prev = node->prev;\\n        }\\n        \\n        return !remove.empty();\\n    }\\n    \\n    void addNode(Node* cur, Node* node) {\\n        node->next = cur->next;\\n        cur->next->prev = node;\\n        node->prev = cur;\\n        cur->next = node;\\n    }\\n    \\n    bool getProb() {\\n        return rand() % 100 <= 50;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Node {\\n    int val;\\n    Node* prev;\\n    Node* next;\\n    Node* down;\\n    \\n    Node(int val): val(val), prev(nullptr), next(nullptr), down(nullptr) {}\\n};\\n\\nclass Skiplist {\\n    Node* entry;\\n    int levels; // Number of levels to start with. This solution uses a fixed size.\\n    \\npublic:\\n    Skiplist(): levels(15) {\\n        // Dummy\\n        entry = new Node(-2);\\n        Node* prev = entry;\\n        \\n        // Initialize dummy starts for each level\\n        for (int i = 0; i < levels; ++i) {\\n            Node* head = new Node(-2); // Dummy start for level\\n            Node* tail = new Node(-1); // Dummy end for level\\n            head->next = tail;\\n            tail->prev = head;\\n            \\n            prev->down = head;\\n            prev = head;\\n        }\\n    }\\n    \\n    bool search(int num) {\\n        Node* cur = entry->down;\\n        \\n        while (cur) {\\n            if (cur ->val == num) {\\n                return true;\\n            }\\n            \\n            if (cur->val == -1 || num <= cur->val) {\\n                cur = cur->prev->down;\\n            } else {\\n                cur = cur->next;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    void add(int num) {\\n        vector<Node*> prevs; // Store the path taken, so we may insert.\\n        Node* cur = entry->down;\\n        \\n        while (cur) {\\n            if (cur->val == -1 || num <= cur->val) {\\n                prevs.push_back(cur->prev);\\n                cur = cur->prev->down;\\n            } else {\\n                cur = cur->next;\\n            }\\n        }\\n        \\n        // Insert into last last level\\n        Node* down = prevs.back();\\n        addNode(down, new Node(num));\\n        \\n        // Probabilistially add the rest while getProb returns true\\n        for (int i = prevs.size()-2; i >= 0 && getProb(); --i) {\\n            Node* n = new Node(num);\\n            addNode(prevs[i], n);\\n            \\n            n->down = down;\\n            down = n;\\n        }        \\n    }\\n    \\n    bool erase(int num) {\\n        vector<Node*> remove;\\n        Node* cur = entry->down;\\n        \\n        while (cur) {\\n            if (cur->val == -1 || num <= cur->val) {\\n                if (cur->val == num) {\\n                    remove.push_back(cur);\\n                }\\n                cur = cur->prev->down;\\n            } else {\\n                cur = cur->next;\\n            }\\n        }\\n        \\n        for (auto node: remove) {\\n            node->prev->next = node->next;\\n            node->next->prev = node->prev;\\n        }\\n        \\n        return !remove.empty();\\n    }\\n    \\n    void addNode(Node* cur, Node* node) {\\n        node->next = cur->next;\\n        cur->next->prev = node;\\n        node->prev = cur;\\n        cur->next = node;\\n    }\\n    \\n    bool getProb() {\\n        return rand() % 100 <= 50;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 931726,
                "title": "c-primitive-solution",
                "content": "```\\npublic class Skiplist\\n{\\n  internal class Node\\n  {\\n    public int Key { get; }\\n    public Node[] ForwardNodes { get; }\\n\\n    public Node(int key, int level)\\n    {\\n      Key = key;\\n      ForwardNodes = new Node[level + 1];\\n    }\\n  }\\n\\n  private readonly int _maxLevel = 4;\\n  private readonly double _p = 0.5;\\n  private int _level;\\n  private Node _head;\\n  private readonly Random _rnd = new Random((int)DateTime.Now.Millisecond);\\n\\n  private int GetRandomLevel()\\n  {\\n    var level = 0;\\n    var rnd = _rnd.NextDouble();\\n\\n    while (rnd < _p && level < _maxLevel)\\n    {\\n      level++;\\n      rnd = _rnd.NextDouble();\\n    }\\n\\n    return level;\\n  }\\n\\n  public Skiplist()\\n  {\\n    _level = 0;\\n    _head = new Node(-1, _maxLevel);\\n  }\\n\\n  public bool Search(int target)\\n  {\\n    (Node current, Node[] updateNodes) = GetUpdateNodes(target);\\n    return current != null && current.Key == target;\\n  }\\n\\n  public void Add(int num)\\n  {\\n    (_, Node[] updateNodes) = GetUpdateNodes(num);\\n\\n    var randomLevel = GetRandomLevel();\\n    if (randomLevel > _level)\\n    {\\n      for (var i = _level + 1; i < randomLevel + 1; i++)\\n        updateNodes[i] = _head;\\n\\n      _level = randomLevel;\\n    }\\n\\n    var node = new Node(num, randomLevel);\\n\\n    for (int i = 0; i <= randomLevel; i++)\\n    {\\n      node.ForwardNodes[i] = updateNodes[i].ForwardNodes[i];\\n      updateNodes[i].ForwardNodes[i] = node;\\n    }\\n  }\\n\\n  public bool Erase(int num)\\n  {\\n    (Node current, Node[] updateNodes) = GetUpdateNodes(num);\\n\\n    if (current != null && current.Key == num)\\n    {\\n      for (int i = 0; i <= _level; i++)\\n      {\\n        if (updateNodes[i].ForwardNodes[i] != current)\\n          break;\\n\\n        updateNodes[i].ForwardNodes[i] = current.ForwardNodes[i];\\n      }\\n\\n      while (_level > 0 && _head.ForwardNodes[_level] == null)\\n        _level--;\\n\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  private (Node current, Node[] updateNodes) GetUpdateNodes(int key)\\n  {\\n    var current = _head;\\n    var updateNodes = new Node[_maxLevel + 1];\\n\\n    for (int i = _level; i >= 0; i--)\\n    {\\n      while (current.ForwardNodes[i] != null && current.ForwardNodes[i].Key < key)\\n        current = current.ForwardNodes[i];\\n\\n      updateNodes[i] = current;\\n    }\\n\\n    return (current.ForwardNodes[0], updateNodes);\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Skiplist\\n{\\n  internal class Node\\n  {\\n    public int Key { get; }\\n    public Node[] ForwardNodes { get; }\\n\\n    public Node(int key, int level)\\n    {\\n      Key = key;\\n      ForwardNodes = new Node[level + 1];\\n    }\\n  }\\n\\n  private readonly int _maxLevel = 4;\\n  private readonly double _p = 0.5;\\n  private int _level;\\n  private Node _head;\\n  private readonly Random _rnd = new Random((int)DateTime.Now.Millisecond);\\n\\n  private int GetRandomLevel()\\n  {\\n    var level = 0;\\n    var rnd = _rnd.NextDouble();\\n\\n    while (rnd < _p && level < _maxLevel)\\n    {\\n      level++;\\n      rnd = _rnd.NextDouble();\\n    }\\n\\n    return level;\\n  }\\n\\n  public Skiplist()\\n  {\\n    _level = 0;\\n    _head = new Node(-1, _maxLevel);\\n  }\\n\\n  public bool Search(int target)\\n  {\\n    (Node current, Node[] updateNodes) = GetUpdateNodes(target);\\n    return current != null && current.Key == target;\\n  }\\n\\n  public void Add(int num)\\n  {\\n    (_, Node[] updateNodes) = GetUpdateNodes(num);\\n\\n    var randomLevel = GetRandomLevel();\\n    if (randomLevel > _level)\\n    {\\n      for (var i = _level + 1; i < randomLevel + 1; i++)\\n        updateNodes[i] = _head;\\n\\n      _level = randomLevel;\\n    }\\n\\n    var node = new Node(num, randomLevel);\\n\\n    for (int i = 0; i <= randomLevel; i++)\\n    {\\n      node.ForwardNodes[i] = updateNodes[i].ForwardNodes[i];\\n      updateNodes[i].ForwardNodes[i] = node;\\n    }\\n  }\\n\\n  public bool Erase(int num)\\n  {\\n    (Node current, Node[] updateNodes) = GetUpdateNodes(num);\\n\\n    if (current != null && current.Key == num)\\n    {\\n      for (int i = 0; i <= _level; i++)\\n      {\\n        if (updateNodes[i].ForwardNodes[i] != current)\\n          break;\\n\\n        updateNodes[i].ForwardNodes[i] = current.ForwardNodes[i];\\n      }\\n\\n      while (_level > 0 && _head.ForwardNodes[_level] == null)\\n        _level--;\\n\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  private (Node current, Node[] updateNodes) GetUpdateNodes(int key)\\n  {\\n    var current = _head;\\n    var updateNodes = new Node[_maxLevel + 1];\\n\\n    for (int i = _level; i >= 0; i--)\\n    {\\n      while (current.ForwardNodes[i] != null && current.ForwardNodes[i].Key < key)\\n        current = current.ForwardNodes[i];\\n\\n      updateNodes[i] = current;\\n    }\\n\\n    return (current.ForwardNodes[0], updateNodes);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920257,
                "title": "java-link-to-next-and-child-with-different-interval",
                "content": "Create a nested linked `SkipNode` with top interval `8^4=4096`. `next`  points to `val+interval`, `child` points to the same `val` but `interval/8`. Since range is 50k, top level will have max `12` nodes and child will have `8` nodes. The max depth is `5`. The time cost is O(log(N)). Since there are duplicates, add count on node. For remove `num`, just update count.   \\n```\\nclass Skiplist {\\n    static final int TOP_INTERVAL=4096;\\n    \\n    static class SkipNode {\\n        int val;\\n        int count;\\n        int interval;\\n        SkipNode next;\\n        SkipNode child;\\n        \\n        SkipNode(int val,int interval) {\\n            this.val=val;\\n            this.interval=interval;\\n        }\\n        \\n        SkipNode search(int num) {\\n            if (val==num) return this;\\n            \\n            // search child\\n            if (num<val+interval) {\\n                if(child==null) return null;\\n                return child.search(num);\\n            }\\n            \\n            // search next\\n            if(next==null) return null;\\n            return next.search(num);\\n        }\\n        \\n        void add(int num) {\\n            if(val==num) {\\n                count++;\\n                return;\\n            }\\n            \\n            // add child\\n            if (num<val+interval) {\\n                if(child==null) {\\n                    child=new SkipNode(val,interval>>>3);\\n                }\\n                child.add(num);\\n                return;\\n            }\\n            \\n            // add next\\n            if(next==null) {\\n                next=new SkipNode(val+interval,interval);\\n            }\\n            next.add(num);\\n        }\\n        \\n        boolean erase(int num) {\\n            var node=search(num);\\n            if (node!=null&&node.count>0) {\\n                node.count--;\\n                return true;\\n            }\\n            return false;\\n        }\\n    }\\n    \\n    SkipNode head;\\n    \\n    public Skiplist() {\\n        head=new SkipNode(0,TOP_INTERVAL);\\n    }\\n    \\n    public boolean search(int target) {\\n        var node=head.search(target);\\n        return node!=null&&node.count>0;\\n    }\\n    \\n    public void add(int num) {\\n        head.add(num);\\n    }\\n    \\n    public boolean erase(int num) {\\n        return head.erase(num);\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Skiplist {\\n    static final int TOP_INTERVAL=4096;\\n    \\n    static class SkipNode {\\n        int val;\\n        int count;\\n        int interval;\\n        SkipNode next;\\n        SkipNode child;\\n        \\n        SkipNode(int val,int interval) {\\n            this.val=val;\\n            this.interval=interval;\\n        }\\n        \\n        SkipNode search(int num) {\\n            if (val==num) return this;\\n            \\n            // search child\\n            if (num<val+interval) {\\n                if(child==null) return null;\\n                return child.search(num);\\n            }\\n            \\n            // search next\\n            if(next==null) return null;\\n            return next.search(num);\\n        }\\n        \\n        void add(int num) {\\n            if(val==num) {\\n                count++;\\n                return;\\n            }\\n            \\n            // add child\\n            if (num<val+interval) {\\n                if(child==null) {\\n                    child=new SkipNode(val,interval>>>3);\\n                }\\n                child.add(num);\\n                return;\\n            }\\n            \\n            // add next\\n            if(next==null) {\\n                next=new SkipNode(val+interval,interval);\\n            }\\n            next.add(num);\\n        }\\n        \\n        boolean erase(int num) {\\n            var node=search(num);\\n            if (node!=null&&node.count>0) {\\n                node.count--;\\n                return true;\\n            }\\n            return false;\\n        }\\n    }\\n    \\n    SkipNode head;\\n    \\n    public Skiplist() {\\n        head=new SkipNode(0,TOP_INTERVAL);\\n    }\\n    \\n    public boolean search(int target) {\\n        var node=head.search(target);\\n        return node!=null&&node.count>0;\\n    }\\n    \\n    public void add(int num) {\\n        head.add(num);\\n    }\\n    \\n    public boolean erase(int num) {\\n        return head.erase(num);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 890848,
                "title": "c-solution",
                "content": "```\\npublic class Skiplist {\\n    List<int> li=new List<int>();\\n    public Skiplist() {\\n        \\n    }\\n    \\n    public bool Search(int target) {\\n        int l=0,r=li.Count-1;\\n        while(l<r)\\n        {\\n            int m=(l+r)/2;\\n            if(li[m]<target)\\n                l=m+1;\\n            else\\n                r=m;\\n        }\\n        return li[l]==target;\\n    }\\n    \\n    public void Add(int num) {\\n        int l=0,r=li.Count;\\n        while(l<r)\\n        {\\n            int m=l+(r-l)/2;\\n            if(li[m]<num)\\n                l=m+1;\\n            else\\n                r=m;\\n        }\\n        li.Insert(l,num);\\n    }\\n    \\n    public bool Erase(int num) {\\n        int l=0,r=li.Count-1;\\n        while(l<r)\\n        {\\n            int m=(l+r)/2;\\n            if(li[m]<num)\\n                l=m+1;\\n            else\\n                r=m;\\n        }\\n        if(li[l]==num)\\n        {\\n            li.RemoveAt(l);\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist obj = new Skiplist();\\n * bool param_1 = obj.Search(target);\\n * obj.Add(num);\\n * bool param_3 = obj.Erase(num);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Skiplist {\\n    List<int> li=new List<int>();\\n    public Skiplist() {\\n        \\n    }\\n    \\n    public bool Search(int target) {\\n        int l=0,r=li.Count-1;\\n        while(l<r)\\n        {\\n            int m=(l+r)/2;\\n            if(li[m]<target)\\n                l=m+1;\\n            else\\n                r=m;\\n        }\\n        return li[l]==target;\\n    }\\n    \\n    public void Add(int num) {\\n        int l=0,r=li.Count;\\n        while(l<r)\\n        {\\n            int m=l+(r-l)/2;\\n            if(li[m]<num)\\n                l=m+1;\\n            else\\n                r=m;\\n        }\\n        li.Insert(l,num);\\n    }\\n    \\n    public bool Erase(int num) {\\n        int l=0,r=li.Count-1;\\n        while(l<r)\\n        {\\n            int m=(l+r)/2;\\n            if(li[m]<num)\\n                l=m+1;\\n            else\\n                r=m;\\n        }\\n        if(li[l]==num)\\n        {\\n            li.RemoveAt(l);\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * Skiplist obj = new Skiplist();\\n * bool param_1 = obj.Search(target);\\n * obj.Add(num);\\n * bool param_3 = obj.Erase(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 859157,
                "title": "buggy-test",
                "content": "Hi,\\n\\n[\"Skiplist\",\"add\",\"add\",\"add\",\"add\",\"add\",\"add\",\"add\",\"add\",\"add\",\"erase\",\"search\",\"add\",\"erase\",\"erase\",\"erase\",\"add\",\"search\",\"search\",\"search\",\"erase\",\"search\",\"add\",\"add\",\"add\",\"erase\",\"search\",\"add\",\"search\",\"erase\",\"search\",\"search\",\"erase\",\"erase\",\"add\",\"erase\",\"search\",\"erase\",\"erase\",\"search\",\"add\",\"add\",\"erase\",\"erase\",\"erase\",\"add\",\"erase\",\"add\",\"erase\",\"erase\",\"add\",\"add\",\"add\",\"search\",\"search\",\"add\",\"erase\",\"search\",\"add\",\"add\",\"search\",\"add\",\"search\",\"erase\",\"erase\",\"search\",\"search\",\"erase\",\"search\",\"add\",\"erase\",\"search\",\"erase\",\"search\",\"erase\",\"erase\",\"search\",\"search\",\"add\",\"add\",\"add\",\"add\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\\n[[],[16],[5],[14],[13],[0],[3],[12],[9],[12],[3],[6],[7],[0],[1],[10],[5],[12],[7],[16],[7],[0],[9],[16],[3],[2],[17],[2],[17],[0],[9],[14],[1],[6],[1],[16],[9],[10],[9],[2],[3],[16],[15],[12],[7],[4],[3],[2],[1],[14],[13],[12],[3],[6],[17],[2],[3],[14],[11],[0],[13],[2],[1],[10],[17],[0],[5],[8],[9],[8],[11],[10],[11],[10],[9],[8],[15],[14],[1],[6],[17],[16],[13],[4],[5],[4],[17],[16],[7],[14],[1]]\\n\\noutput [null,null,null,null,null,null,null,null,null,null,true,false,null,true,false,false,null,true,true,true,true,false,null,null,null,false,false,null,false,false,true,true,false,false,null,true,true,false,true,true,null,null,false,true,false,null,true,null,true,true,null,null,null,false,false,null,true,false,null,null,true,null,false,false,false,true,true,false,false,null,true,false,false,false,false,true,false,false,null,null,null,null,true,true,true,true,true,true,false,false,true]\\nexpected [null,null,null,null,null,null,null,null,null,null,true,false,null,true,false,false,null,true,true,true,true,false,null,null,null,false,false,null,false,false,true,true,false,false,null,true,true,false,true,true,null,null,false,true,false,null,true,null,true,true,null,null,null,false,false,null,true,false,null,null,true,null,false,false,false,true,true,false,true,null,true,false,false,false,true,true,false,false,null,null,null,null,true,true,true,true,true,true,false,false,true]\\n\\nI think I am getting a buggy test, on the command 68 and 74 my algo returns False, but the Expected answer is True. However, the previous command to the command at 68 is an erase of the value 9. So the search should return False. Can anyone run this test case on thier algo?\\n\\nsearch [9] 68 False true\\nerase [9] 74 False true\\n\\nAll the best\\n",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 822258,
                "title": "python-dynamic-adding-new-levels",
                "content": "```python\\nimport math\\nimport random\\n\\nclass Node:\\n    def __init__(self, val: int = 0, next = None, down = None):\\n        self.val = val\\n        self.next = next\\n        self.down = down\\n\\n    def __repr__(self):\\n        return self.__str__()\\n\\n    def __str__(self):\\n        return \\'{}->{}\\'.format(\\n            self.val,\\n            self.next.val if self.next else \\'N\\')\\n\\nclass Skiplist:\\n    random.seed(0)\\n    # random.seed()\\n\\n    def __repr__(self):\\n        return self.__str__()\\n\\n    def __str__(self):\\n        li = []\\n        node = self.head\\n        while node:\\n            lily = []\\n            no = node\\n            while no:\\n                lily.append(\\'{}{}\\'.format(no.val, \\'\\' if no.down else \\'.\\'))\\n                no = no.next\\n            li.append(lily)\\n            node = node.down\\n        return \\'\\\\n\\'.join(map(lambda l: \\'->\\'.join(l), li))\\n\\n    def __init__(self):\\n        self.head = None\\n        self.tail = None\\n        self._addOneLevel()\\n\\n    def _addOneLevel(self):\\n        self.tail = Node(math.inf, None, self.tail)\\n        self.head = Node(-math.inf, self.tail, self.head)\\n\\n\\n    def _growUp(self):\\n        return random.getrandbits(1) % 2 == 0\\n\\n    def _search(self, target: int) -> bool:\\n        linodes = []\\n        node = self.head\\n        while node:\\n            if node.next.val >= target:\\n                linodes.append(node)\\n                node = node.down\\n            else:\\n                node = node.next\\n        return linodes\\n\\n    def levels(self):\\n        r = 0\\n        node = self.head\\n        while node:\\n            r += 1\\n            node = node.down\\n        return r\\n\\n    def search(self, target: int) -> bool:\\n        return self._search(target)[-1].next.val == target\\n\\n    def add(self, num: int) -> None:\\n        linodes = self._search(num)\\n        tip = linodes[-1]\\n        below = Node(num, tip.next)\\n        tip.next = below\\n        totalLevel = len(linodes)\\n        level = 1\\n        while self._growUp() and level <= totalLevel:\\n            if level == totalLevel: # maximally grows one level a time\\n                self._addOneLevel()\\n                prev = self.head\\n            else:\\n                prev = linodes[totalLevel - 1 - level]\\n            below = Node(num, prev.next, below)\\n            prev.next = below\\n            level += 1\\n\\n    def erase(self, num: int) -> bool:\\n        linodes = self._search(num)\\n        # print(\\'--- linodes\\', linodes)\\n        tip = linodes[-1]\\n        if tip.next.val != num:\\n            return False\\n        totalLevel = len(linodes)\\n        level = totalLevel - 1\\n        while level >= 0 and linodes[level].next.val == num:\\n            linodes[level].next = linodes[level].next.next\\n            level -= 1\\n        return True\\n```",
                "solutionTags": [],
                "code": "```python\\nimport math\\nimport random\\n\\nclass Node:\\n    def __init__(self, val: int = 0, next = None, down = None):\\n        self.val = val\\n        self.next = next\\n        self.down = down\\n\\n    def __repr__(self):\\n        return self.__str__()\\n\\n    def __str__(self):\\n        return \\'{}->{}\\'.format(\\n            self.val,\\n            self.next.val if self.next else \\'N\\')\\n\\nclass Skiplist:\\n    random.seed(0)\\n    # random.seed()\\n\\n    def __repr__(self):\\n        return self.__str__()\\n\\n    def __str__(self):\\n        li = []\\n        node = self.head\\n        while node:\\n            lily = []\\n            no = node\\n            while no:\\n                lily.append(\\'{}{}\\'.format(no.val, \\'\\' if no.down else \\'.\\'))\\n                no = no.next\\n            li.append(lily)\\n            node = node.down\\n        return \\'\\\\n\\'.join(map(lambda l: \\'->\\'.join(l), li))\\n\\n    def __init__(self):\\n        self.head = None\\n        self.tail = None\\n        self._addOneLevel()\\n\\n    def _addOneLevel(self):\\n        self.tail = Node(math.inf, None, self.tail)\\n        self.head = Node(-math.inf, self.tail, self.head)\\n\\n\\n    def _growUp(self):\\n        return random.getrandbits(1) % 2 == 0\\n\\n    def _search(self, target: int) -> bool:\\n        linodes = []\\n        node = self.head\\n        while node:\\n            if node.next.val >= target:\\n                linodes.append(node)\\n                node = node.down\\n            else:\\n                node = node.next\\n        return linodes\\n\\n    def levels(self):\\n        r = 0\\n        node = self.head\\n        while node:\\n            r += 1\\n            node = node.down\\n        return r\\n\\n    def search(self, target: int) -> bool:\\n        return self._search(target)[-1].next.val == target\\n\\n    def add(self, num: int) -> None:\\n        linodes = self._search(num)\\n        tip = linodes[-1]\\n        below = Node(num, tip.next)\\n        tip.next = below\\n        totalLevel = len(linodes)\\n        level = 1\\n        while self._growUp() and level <= totalLevel:\\n            if level == totalLevel: # maximally grows one level a time\\n                self._addOneLevel()\\n                prev = self.head\\n            else:\\n                prev = linodes[totalLevel - 1 - level]\\n            below = Node(num, prev.next, below)\\n            prev.next = below\\n            level += 1\\n\\n    def erase(self, num: int) -> bool:\\n        linodes = self._search(num)\\n        # print(\\'--- linodes\\', linodes)\\n        tip = linodes[-1]\\n        if tip.next.val != num:\\n            return False\\n        totalLevel = len(linodes)\\n        level = totalLevel - 1\\n        while level >= 0 and linodes[level].next.val == num:\\n            linodes[level].next = linodes[level].next.next\\n            level -= 1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 782928,
                "title": "python-complete-implementation-of-skiplist-with-inline-comments",
                "content": "```\\nimport random\\n\\nclass Node:\\n  def __init__(self, val, level, count = 1):\\n    self.val = val\\n    # list hold refr to nodes on different level\\n    self.next = [None] * (level + 1)\\n    # count the number of duplicates of this val\\n    self.count = count\\n\\nclass Skiplist:\\n\\n  def __init__(self, p = 0.5):\\n    # promote probability\\n    self.p = p\\n    # head of the skiplist\\n    self.head = Node(None, 0)\\n    # num of levels of the skiplist\\n    self.levels = 1\\n\\n  def _randomLevel(self):\\n    # generate a random level\\n    _level = 0\\n    while random.random() < self.p:\\n      _level += 1\\n    return _level\\n  \\n  def _update(self, val):\\n    # candidate list of node to be updated at each level\\n    update = [None] * self.levels\\n    x = self.head\\n    for i in reversed(range(self.levels)):\\n      while x.next[i] is not None and x.next[i].val < val:\\n        x = x.next[i]\\n      update[i] = x\\n    return update\\n  \\n  def _search(self, val, update = None):\\n    if update is None:\\n      update = self._update(val)\\n    if len(update) > 0:\\n      node = update[0].next[0]\\n      if node is not None and node.val == val:\\n        return node\\n    return None\\n\\n  def _insert(self, val: int) -> None:\\n    # node with val already exist?\\n    node = self._search(val)\\n    if node is not None:\\n      node.count += 1\\n    else:\\n      # node creation\\n      node = Node(val, self._randomLevel())\\n      # update max level and extend head correspondingly\\n      self.levels = max(self.levels, len(node.next))\\n      while len(self.head.next) < len(node.next):\\n        self.head.next.append(None)\\n      # update list of candidates\\n      update = self._update(val)\\n      for i in range(len(node.next)):\\n        node.next[i] = update[i].next[i]\\n        update[i].next[i] = node\\n    return None\\n\\n  def _delete(self, val: int) -> bool:\\n    update = self._update(val)\\n    node = self._search(val, update)\\n    if node is not None:\\n      node.count -= 1\\n      if node.count < 1:\\n        for i in reversed(range(len(node.next))):\\n          update[i].next[i] = node.next[i]\\n          if self.head.next[i] is None:\\n            self.head.next.pop()\\n            self.levels -= 1\\n      return True\\n    else:\\n      return False\\n\\n  def display(self) -> None:\\n    for i in range(len(self.head.next) - 1, -1, -1):\\n      x, s = self.head, \\'\\'\\n      while x.next[i] != None:\\n        s += str(x.next[i].val) + \\'(\\' + str(x.next[i].count) + \\') -- \\'\\n        x = x.next[i]\\n      print(\\'level\\', \\'{:4d}\\'.format(i), \\':\\',  s)\\n\\n  def search(self, target: int) -> bool:\\n    return self._search(target) is not None\\n\\n  def add(self, num: int) -> None:\\n    return self._insert(num)\\n\\n  def erase(self, num: int) -> bool:\\n    return self._delete(num)\\n\\nif __name__ == \\'__main__\\':\\n  skiplist = Skiplist()\\n  skiplist.add(1)\\n  skiplist.add(2)\\n  skiplist.add(3)\\n  print(skiplist.search(0))\\n  skiplist.add(4)\\n  skiplist.add(2)\\n  print(skiplist.display())\\n  print(skiplist.search(1))\\n  skiplist.erase(0)\\n  skiplist.erase(1)\\n  print(skiplist.search(1))\\n  skiplist.erase(2)\\n  print(skiplist.search(2))\\n  print(skiplist.display())\\n```",
                "solutionTags": [],
                "code": "```\\nimport random\\n\\nclass Node:\\n  def __init__(self, val, level, count = 1):\\n    self.val = val\\n    # list hold refr to nodes on different level\\n    self.next = [None] * (level + 1)\\n    # count the number of duplicates of this val\\n    self.count = count\\n\\nclass Skiplist:\\n\\n  def __init__(self, p = 0.5):\\n    # promote probability\\n    self.p = p\\n    # head of the skiplist\\n    self.head = Node(None, 0)\\n    # num of levels of the skiplist\\n    self.levels = 1\\n\\n  def _randomLevel(self):\\n    # generate a random level\\n    _level = 0\\n    while random.random() < self.p:\\n      _level += 1\\n    return _level\\n  \\n  def _update(self, val):\\n    # candidate list of node to be updated at each level\\n    update = [None] * self.levels\\n    x = self.head\\n    for i in reversed(range(self.levels)):\\n      while x.next[i] is not None and x.next[i].val < val:\\n        x = x.next[i]\\n      update[i] = x\\n    return update\\n  \\n  def _search(self, val, update = None):\\n    if update is None:\\n      update = self._update(val)\\n    if len(update) > 0:\\n      node = update[0].next[0]\\n      if node is not None and node.val == val:\\n        return node\\n    return None\\n\\n  def _insert(self, val: int) -> None:\\n    # node with val already exist?\\n    node = self._search(val)\\n    if node is not None:\\n      node.count += 1\\n    else:\\n      # node creation\\n      node = Node(val, self._randomLevel())\\n      # update max level and extend head correspondingly\\n      self.levels = max(self.levels, len(node.next))\\n      while len(self.head.next) < len(node.next):\\n        self.head.next.append(None)\\n      # update list of candidates\\n      update = self._update(val)\\n      for i in range(len(node.next)):\\n        node.next[i] = update[i].next[i]\\n        update[i].next[i] = node\\n    return None\\n\\n  def _delete(self, val: int) -> bool:\\n    update = self._update(val)\\n    node = self._search(val, update)\\n    if node is not None:\\n      node.count -= 1\\n      if node.count < 1:\\n        for i in reversed(range(len(node.next))):\\n          update[i].next[i] = node.next[i]\\n          if self.head.next[i] is None:\\n            self.head.next.pop()\\n            self.levels -= 1\\n      return True\\n    else:\\n      return False\\n\\n  def display(self) -> None:\\n    for i in range(len(self.head.next) - 1, -1, -1):\\n      x, s = self.head, \\'\\'\\n      while x.next[i] != None:\\n        s += str(x.next[i].val) + \\'(\\' + str(x.next[i].count) + \\') -- \\'\\n        x = x.next[i]\\n      print(\\'level\\', \\'{:4d}\\'.format(i), \\':\\',  s)\\n\\n  def search(self, target: int) -> bool:\\n    return self._search(target) is not None\\n\\n  def add(self, num: int) -> None:\\n    return self._insert(num)\\n\\n  def erase(self, num: int) -> bool:\\n    return self._delete(num)\\n\\nif __name__ == \\'__main__\\':\\n  skiplist = Skiplist()\\n  skiplist.add(1)\\n  skiplist.add(2)\\n  skiplist.add(3)\\n  print(skiplist.search(0))\\n  skiplist.add(4)\\n  skiplist.add(2)\\n  print(skiplist.display())\\n  print(skiplist.search(1))\\n  skiplist.erase(0)\\n  skiplist.erase(1)\\n  print(skiplist.search(1))\\n  skiplist.erase(2)\\n  print(skiplist.search(2))\\n  print(skiplist.display())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 744702,
                "title": "golang",
                "content": "Implementation and tests: https://github.com/qulia/go-qulia/tree/master/lib/skiplist\\n```\\nimport (\\n\\t\"container/list\"\\n\\t\"math\"\\n\\t\"math/rand\"\\n\\t\"time\"\\n)\\n\\ntype item struct {\\n\\tval  int\\n\\tdown *list.Element\\n\\tup   *list.Element\\n\\tls   *list.List\\n}\\n\\ntype Skiplist struct {\\n\\tlevels []*list.List\\n}\\n\\nfunc Constructor() Skiplist {\\n\\tsl := Skiplist{}\\n\\tsl.levels = append(sl.levels, list.New())\\n\\tsl.levels[0].PushBack(&item{math.MinInt32, nil, nil, sl.levels[0]})\\n\\trand.Seed(time.Now().UnixNano())\\n\\treturn sl\\n}\\n\\nfunc (sl *Skiplist) Search(target int) bool {\\n\\tel, _ := sl.searchHelper(target)\\n\\treturn el.Value.(*item).val == target\\n}\\n\\nfunc (sl *Skiplist) Add(num int) {\\n\\tel, path := sl.searchHelper(num)\\n\\tls := el.Value.(*item).ls\\n\\tel = ls.InsertAfter(&item{num, nil, nil, ls}, el)\\n\\tsl.promote(el, path)\\n}\\n\\nfunc (sl *Skiplist) Erase(num int) bool {\\n\\tel, _ := sl.searchHelper(num)\\n\\tif el.Value.(*item).val != num {\\n\\t\\treturn false\\n\\t}\\n\\n\\tfor el != nil {\\n\\t\\tup := el.Value.(*item).up\\n\\t\\tel.Value.(*item).ls.Remove(el)\\n\\t\\tel = up\\n\\t}\\n\\treturn true\\n}\\n\\nfunc (sl *Skiplist) searchHelper(target int) (*list.Element, []*list.Element) {\\n\\tcur := sl.levels[len(sl.levels)-1].Front()\\n\\tvar path []*list.Element\\n\\tfor {\\n\\t\\tif cur.Next() != nil {\\n\\t\\t\\tif cur.Next().Value.(*item).val >= target {\\n\\t\\t\\t\\tif cur.Value.(*item).down != nil {\\n\\t\\t\\t\\t\\tpath = append(path, cur)\\n\\t\\t\\t\\t\\tcur = cur.Value.(*item).down\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif cur.Next().Value.(*item).val == target {\\n\\t\\t\\t\\t\\t\\tcur = cur.Next()\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcur = cur.Next()\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tif cur.Value.(*item).down != nil {\\n\\t\\t\\t\\tpath = append(path, cur)\\n\\t\\t\\t\\tcur = cur.Value.(*item).down\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn cur, path\\n}\\n\\nfunc (sl *Skiplist) promote(el *list.Element, path []*list.Element) {\\n\\tnum := el.Value.(*item).val\\n\\tpathIndex := len(path) - 1\\n\\tfor rand.Uint32()%2 == 1 {\\n\\t\\tit := el.Value.(*item)\\n\\t\\tvar appendTo *list.Element\\n\\t\\tif pathIndex < 0 {\\n\\t\\t\\tnl := list.New()\\n\\t\\t\\tsl.levels = append(sl.levels, nl)\\n\\t\\t\\tappendTo = nl.PushBack(&item{math.MinInt32, it.ls.Front(), nil, nl})\\n\\t\\t\\tit.ls.Front().Value.(*item).up = appendTo\\n\\t\\t} else {\\n\\t\\t\\tappendTo = path[pathIndex]\\n\\t\\t\\tpathIndex--\\n\\t\\t}\\n\\t\\tupls := appendTo.Value.(*item).ls\\n\\t\\tit.up = upls.InsertAfter(&item{num, el, nil, upls}, appendTo)\\n\\t\\tel = it.up\\n\\t}\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nimport (\\n\\t\"container/list\"\\n\\t\"math\"\\n\\t\"math/rand\"\\n\\t\"time\"\\n)\\n\\ntype item struct {\\n\\tval  int\\n\\tdown *list.Element\\n\\tup   *list.Element\\n\\tls   *list.List\\n}\\n\\ntype Skiplist struct {\\n\\tlevels []*list.List\\n}\\n\\nfunc Constructor() Skiplist {\\n\\tsl := Skiplist{}\\n\\tsl.levels = append(sl.levels, list.New())\\n\\tsl.levels[0].PushBack(&item{math.MinInt32, nil, nil, sl.levels[0]})\\n\\trand.Seed(time.Now().UnixNano())\\n\\treturn sl\\n}\\n\\nfunc (sl *Skiplist) Search(target int) bool {\\n\\tel, _ := sl.searchHelper(target)\\n\\treturn el.Value.(*item).val == target\\n}\\n\\nfunc (sl *Skiplist) Add(num int) {\\n\\tel, path := sl.searchHelper(num)\\n\\tls := el.Value.(*item).ls\\n\\tel = ls.InsertAfter(&item{num, nil, nil, ls}, el)\\n\\tsl.promote(el, path)\\n}\\n\\nfunc (sl *Skiplist) Erase(num int) bool {\\n\\tel, _ := sl.searchHelper(num)\\n\\tif el.Value.(*item).val != num {\\n\\t\\treturn false\\n\\t}\\n\\n\\tfor el != nil {\\n\\t\\tup := el.Value.(*item).up\\n\\t\\tel.Value.(*item).ls.Remove(el)\\n\\t\\tel = up\\n\\t}\\n\\treturn true\\n}\\n\\nfunc (sl *Skiplist) searchHelper(target int) (*list.Element, []*list.Element) {\\n\\tcur := sl.levels[len(sl.levels)-1].Front()\\n\\tvar path []*list.Element\\n\\tfor {\\n\\t\\tif cur.Next() != nil {\\n\\t\\t\\tif cur.Next().Value.(*item).val >= target {\\n\\t\\t\\t\\tif cur.Value.(*item).down != nil {\\n\\t\\t\\t\\t\\tpath = append(path, cur)\\n\\t\\t\\t\\t\\tcur = cur.Value.(*item).down\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif cur.Next().Value.(*item).val == target {\\n\\t\\t\\t\\t\\t\\tcur = cur.Next()\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcur = cur.Next()\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tif cur.Value.(*item).down != nil {\\n\\t\\t\\t\\tpath = append(path, cur)\\n\\t\\t\\t\\tcur = cur.Value.(*item).down\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn cur, path\\n}\\n\\nfunc (sl *Skiplist) promote(el *list.Element, path []*list.Element) {\\n\\tnum := el.Value.(*item).val\\n\\tpathIndex := len(path) - 1\\n\\tfor rand.Uint32()%2 == 1 {\\n\\t\\tit := el.Value.(*item)\\n\\t\\tvar appendTo *list.Element\\n\\t\\tif pathIndex < 0 {\\n\\t\\t\\tnl := list.New()\\n\\t\\t\\tsl.levels = append(sl.levels, nl)\\n\\t\\t\\tappendTo = nl.PushBack(&item{math.MinInt32, it.ls.Front(), nil, nl})\\n\\t\\t\\tit.ls.Front().Value.(*item).up = appendTo\\n\\t\\t} else {\\n\\t\\t\\tappendTo = path[pathIndex]\\n\\t\\t\\tpathIndex--\\n\\t\\t}\\n\\t\\tupls := appendTo.Value.(*item).ls\\n\\t\\tit.up = upls.InsertAfter(&item{num, el, nil, upls}, appendTo)\\n\\t\\tel = it.up\\n\\t}\\n}\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 678437,
                "title": "c-solution-by-redis-zset-in-60ms",
                "content": "#define ZSKIPLIST_MAXLEVEL 32\\ntypedef struct zskiplist zskiplist;\\ntypedef struct zskiplist Skiplist;\\n/* ZSETs use a specialized version of Skiplists */\\ntypedef struct zskiplistNode {\\n    int score;\\n    struct zskiplistNode *backward;\\n    struct zskiplistLevel {\\n        struct zskiplistNode *forward;\\n    } level[];\\n} zskiplistNode;\\n\\nstruct zskiplist {\\n    struct zskiplistNode *header, *tail;\\n    int level;\\n};\\n\\nzskiplistNode *zslCreateNode(int level, double score) \\n{\\n    zskiplistNode *zn =\\n        malloc(sizeof(*zn)+level*sizeof(struct zskiplistLevel));\\n    zn->score = score;\\n    return zn;\\n}\\n\\nSkiplist* skiplistCreate() \\n{\\n    int j;\\n    zskiplist *zsl;\\n    zsl = malloc(sizeof(*zsl));\\n    zsl->level = 1;\\n    zsl->header = zslCreateNode(ZSKIPLIST_MAXLEVEL, 0);\\n    for (j = 0; j < ZSKIPLIST_MAXLEVEL; j++) {\\n        zsl->header->level[j].forward = NULL;\\n    }\\n    zsl->header->backward = NULL;\\n    zsl->tail = NULL;\\n    return zsl;\\n}\\n\\nbool skiplistSearch(Skiplist* zsl, int target) \\n{\\n    zskiplistNode *x;\\n    int i, level;\\n    x = zsl->header;\\n    for (i = zsl->level-1; i >= 0; i--) {\\n        while (x->level[i].forward &&\\n                (x->level[i].forward->score < target ||\\n                    (x->level[i].forward->score == target)))\\n        {\\n            if(x->level[i].forward->score == target)\\n                return true;\\n            x = x->level[i].forward;\\n        }\\n    }\\n    return false;\\n}\\n\\nint zslRandomLevel(void) \\n{\\n    int level = 1;\\n    while ((random()&0xFFFF) < (0.25 * 0xFFFF))\\n        level += 1;\\n    return (level<ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;\\n}\\n\\nvoid skiplistAdd(Skiplist* zsl, int score) \\n{\\n    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;\\n    int i, level;\\n    x = zsl->header;\\n    for (i = zsl->level-1; i >= 0; i--) {\\n        while (x->level[i].forward &&\\n                (x->level[i].forward->score < score))\\n        {\\n            x = x->level[i].forward;\\n        }\\n        update[i] = x;\\n    }\\n    level = zslRandomLevel();\\n    if (level > zsl->level) {\\n        for (i = zsl->level; i < level; i++) {\\n            update[i] = zsl->header;\\n        }\\n        zsl->level = level;\\n    }\\n    x = zslCreateNode(level,score);\\n    for (i = 0; i < level; i++) {\\n        x->level[i].forward = update[i]->level[i].forward;\\n        update[i]->level[i].forward = x;\\n    }\\n    x->backward = (update[0] == zsl->header) ? NULL : update[0];\\n    if (x->level[0].forward)\\n        x->level[0].forward->backward = x;\\n    else\\n        zsl->tail = x;\\n}\\n\\nvoid zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) \\n{\\n    int i;\\n    for (i = 0; i < zsl->level; i++) {\\n        if (update[i]->level[i].forward == x) {\\n            update[i]->level[i].forward = x->level[i].forward;\\n        }\\n    }\\n    if (x->level[0].forward) {\\n        x->level[0].forward->backward = x->backward;\\n    } else {\\n        zsl->tail = x->backward;\\n    }\\n    while(zsl->level > 1 && zsl->header->level[zsl->level-1].forward == NULL)\\n        zsl->level--;\\n}\\n\\nvoid zslFreeNode(zskiplistNode *node) \\n{\\n    free(node);\\n}\\n\\nbool skiplistErase(Skiplist* zsl, int score) \\n{\\n    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;\\n    int i;\\n    x = zsl->header;\\n    for (i = zsl->level-1; i >= 0; i--) {\\n        while (x->level[i].forward &&\\n                (x->level[i].forward->score < score))\\n        {\\n            x = x->level[i].forward;\\n        }\\n        update[i] = x;\\n    }\\n    x = x->level[0].forward;\\n    if (x && score == x->score) {\\n        zslDeleteNode(zsl, x, update);\\n        zslFreeNode(x);\\n        return true;\\n    }\\n    return false; /* not found */\\n}\\n\\nvoid skiplistFree(Skiplist* zsl) \\n{\\n    zskiplistNode *node = zsl->header->level[0].forward, *next;\\n    free(zsl->header);\\n    while(node) {\\n        next = node->level[0].forward;\\n        zslFreeNode(node);\\n        node = next;\\n    }\\n    free(zsl);\\n}\\n\\n/**\\n * Your Skiplist struct will be instantiated and called as such:\\n * Skiplist* obj = skiplistCreate();\\n * bool param_1 = skiplistSearch(obj, target);\\n \\n * skiplistAdd(obj, num);\\n \\n * bool param_3 = skiplistErase(obj, num);\\n \\n * skiplistFree(obj);\\n*/",
                "solutionTags": [],
                "code": "#define ZSKIPLIST_MAXLEVEL 32\\ntypedef struct zskiplist zskiplist;\\ntypedef struct zskiplist Skiplist;\\n/* ZSETs use a specialized version of Skiplists */\\ntypedef struct zskiplistNode {\\n    int score;\\n    struct zskiplistNode *backward;\\n    struct zskiplistLevel {\\n        struct zskiplistNode *forward;\\n    } level[];\\n} zskiplistNode;\\n\\nstruct zskiplist {\\n    struct zskiplistNode *header, *tail;\\n    int level;\\n};\\n\\nzskiplistNode *zslCreateNode(int level, double score) \\n{\\n    zskiplistNode *zn =\\n        malloc(sizeof(*zn)+level*sizeof(struct zskiplistLevel));\\n    zn->score = score;\\n    return zn;\\n}\\n\\nSkiplist* skiplistCreate() \\n{\\n    int j;\\n    zskiplist *zsl;\\n    zsl = malloc(sizeof(*zsl));\\n    zsl->level = 1;\\n    zsl->header = zslCreateNode(ZSKIPLIST_MAXLEVEL, 0);\\n    for (j = 0; j < ZSKIPLIST_MAXLEVEL; j++) {\\n        zsl->header->level[j].forward = NULL;\\n    }\\n    zsl->header->backward = NULL;\\n    zsl->tail = NULL;\\n    return zsl;\\n}\\n\\nbool skiplistSearch(Skiplist* zsl, int target) \\n{\\n    zskiplistNode *x;\\n    int i, level;\\n    x = zsl->header;\\n    for (i = zsl->level-1; i >= 0; i--) {\\n        while (x->level[i].forward &&\\n                (x->level[i].forward->score < target ||\\n                    (x->level[i].forward->score == target)))\\n        {\\n            if(x->level[i].forward->score == target)\\n                return true;\\n            x = x->level[i].forward;\\n        }\\n    }\\n    return false;\\n}\\n\\nint zslRandomLevel(void) \\n{\\n    int level = 1;\\n    while ((random()&0xFFFF) < (0.25 * 0xFFFF))\\n        level += 1;\\n    return (level<ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;\\n}\\n\\nvoid skiplistAdd(Skiplist* zsl, int score) \\n{\\n    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;\\n    int i, level;\\n    x = zsl->header;\\n    for (i = zsl->level-1; i >= 0; i--) {\\n        while (x->level[i].forward &&\\n                (x->level[i].forward->score < score))\\n        {\\n            x = x->level[i].forward;\\n        }\\n        update[i] = x;\\n    }\\n    level = zslRandomLevel();\\n    if (level > zsl->level) {\\n        for (i = zsl->level; i < level; i++) {\\n            update[i] = zsl->header;\\n        }\\n        zsl->level = level;\\n    }\\n    x = zslCreateNode(level,score);\\n    for (i = 0; i < level; i++) {\\n        x->level[i].forward = update[i]->level[i].forward;\\n        update[i]->level[i].forward = x;\\n    }\\n    x->backward = (update[0] == zsl->header) ? NULL : update[0];\\n    if (x->level[0].forward)\\n        x->level[0].forward->backward = x;\\n    else\\n        zsl->tail = x;\\n}\\n\\nvoid zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) \\n{\\n    int i;\\n    for (i = 0; i < zsl->level; i++) {\\n        if (update[i]->level[i].forward == x) {\\n            update[i]->level[i].forward = x->level[i].forward;\\n        }\\n    }\\n    if (x->level[0].forward) {\\n        x->level[0].forward->backward = x->backward;\\n    } else {\\n        zsl->tail = x->backward;\\n    }\\n    while(zsl->level > 1 && zsl->header->level[zsl->level-1].forward == NULL)\\n        zsl->level--;\\n}\\n\\nvoid zslFreeNode(zskiplistNode *node) \\n{\\n    free(node);\\n}\\n\\nbool skiplistErase(Skiplist* zsl, int score) \\n{\\n    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;\\n    int i;\\n    x = zsl->header;\\n    for (i = zsl->level-1; i >= 0; i--) {\\n        while (x->level[i].forward &&\\n                (x->level[i].forward->score < score))\\n        {\\n            x = x->level[i].forward;\\n        }\\n        update[i] = x;\\n    }\\n    x = x->level[0].forward;\\n    if (x && score == x->score) {\\n        zslDeleteNode(zsl, x, update);\\n        zslFreeNode(x);\\n        return true;\\n    }\\n    return false; /* not found */\\n}\\n\\nvoid skiplistFree(Skiplist* zsl) \\n{\\n    zskiplistNode *node = zsl->header->level[0].forward, *next;\\n    free(zsl->header);\\n    while(node) {\\n        next = node->level[0].forward;\\n        zslFreeNode(node);\\n        node = next;\\n    }\\n    free(zsl);\\n}\\n\\n/**\\n * Your Skiplist struct will be instantiated and called as such:\\n * Skiplist* obj = skiplistCreate();\\n * bool param_1 = skiplistSearch(obj, target);\\n \\n * skiplistAdd(obj, num);\\n \\n * bool param_3 = skiplistErase(obj, num);\\n \\n * skiplistFree(obj);\\n*/",
                "codeTag": "Python3"
            },
            {
                "id": 669507,
                "title": "golang-simple",
                "content": "```\\nimport \"math/rand\"\\nimport \"time\"\\n\\ntype Skiplist struct {\\n    val int\\n    next []*Skiplist\\n    r *rand.Rand\\n}\\n\\nfunc Constructor() Skiplist {\\n    var s Skiplist\\n    s1 := rand.NewSource(time.Now().UnixNano())\\n    s.r = rand.New(s1)\\n    return s\\n}\\n\\nfunc (this *Skiplist) Locate(target int) []*Skiplist {\\n    l := len(this.next) - 1\\n    prev := make([]*Skiplist, l+1)\\n    current := this\\n    for current != nil {\\n        next := current.next[l]\\n        if next == nil || next.val >= target {\\n            prev[l] = current\\n            if l == 0 {\\n                break\\n            } else {\\n                l--\\n            }\\n        } else {\\n            prev[l] = current\\n            current = next\\n        }\\n    }\\n    return prev\\n}\\n\\nfunc (this *Skiplist) Search(target int) bool {\\n    l := len(this.next) - 1\\n    current := this\\n    for current != nil {\\n        next := current.next[l]\\n        if next == nil || next.val > target {\\n            if l == 0 {\\n                return false\\n            } else {\\n                l--\\n            }\\n        } else if next.val == target {\\n            return true\\n        } else {\\n            current = next\\n        }\\n    }\\n    \\n    return false\\n}\\n\\n\\nfunc (this *Skiplist) Add(num int) {\\n    l := len(this.next)\\n    var prev []*Skiplist\\n    if l > 0 {\\n        prev = this.Locate(num)\\n    }\\n    \\n    n := 1\\n    for this.r.Intn(2) != 0 {\\n        n++\\n    }\\n    \\n    node := &Skiplist{val:num}\\n    node.next = make([]*Skiplist, n)\\n    for ; n > l; n-- {\\n        this.next = append(this.next, node)\\n    }\\n    \\n    for i := 0; i < n; i++ {\\n        node.next[i] = prev[i].next[i]\\n        prev[i].next[i] = node\\n    }\\n}\\n\\nfunc (this *Skiplist) Erase(num int) bool {\\n    if len(this.next) == 0 {\\n        return false\\n    }\\n    prev := this.Locate(num)\\n    \\n    node := prev[0].next[0]\\n    if node == nil || node.val != num {\\n        return false\\n    }\\n    for i := 0; i < len(node.next); i++ {\\n        prev[i].next[i] = node.next[i]\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport \"math/rand\"\\nimport \"time\"\\n\\ntype Skiplist struct {\\n    val int\\n    next []*Skiplist\\n    r *rand.Rand\\n}\\n\\nfunc Constructor() Skiplist {\\n    var s Skiplist\\n    s1 := rand.NewSource(time.Now().UnixNano())\\n    s.r = rand.New(s1)\\n    return s\\n}\\n\\nfunc (this *Skiplist) Locate(target int) []*Skiplist {\\n    l := len(this.next) - 1\\n    prev := make([]*Skiplist, l+1)\\n    current := this\\n    for current != nil {\\n        next := current.next[l]\\n        if next == nil || next.val >= target {\\n            prev[l] = current\\n            if l == 0 {\\n                break\\n            } else {\\n                l--\\n            }\\n        } else {\\n            prev[l] = current\\n            current = next\\n        }\\n    }\\n    return prev\\n}\\n\\nfunc (this *Skiplist) Search(target int) bool {\\n    l := len(this.next) - 1\\n    current := this\\n    for current != nil {\\n        next := current.next[l]\\n        if next == nil || next.val > target {\\n            if l == 0 {\\n                return false\\n            } else {\\n                l--\\n            }\\n        } else if next.val == target {\\n            return true\\n        } else {\\n            current = next\\n        }\\n    }\\n    \\n    return false\\n}\\n\\n\\nfunc (this *Skiplist) Add(num int) {\\n    l := len(this.next)\\n    var prev []*Skiplist\\n    if l > 0 {\\n        prev = this.Locate(num)\\n    }\\n    \\n    n := 1\\n    for this.r.Intn(2) != 0 {\\n        n++\\n    }\\n    \\n    node := &Skiplist{val:num}\\n    node.next = make([]*Skiplist, n)\\n    for ; n > l; n-- {\\n        this.next = append(this.next, node)\\n    }\\n    \\n    for i := 0; i < n; i++ {\\n        node.next[i] = prev[i].next[i]\\n        prev[i].next[i] = node\\n    }\\n}\\n\\nfunc (this *Skiplist) Erase(num int) bool {\\n    if len(this.next) == 0 {\\n        return false\\n    }\\n    prev := this.Locate(num)\\n    \\n    node := prev[0].next[0]\\n    if node == nil || node.val != num {\\n        return false\\n    }\\n    for i := 0; i < len(node.next); i++ {\\n        prev[i].next[i] = node.next[i]\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 568510,
                "title": "golang-for-fun",
                "content": "```\\nimport (\\n    \"fmt\"\\n    \"math/rand\"\\n)\\n\\ntype Skiplist struct {\\n    fakeHead *node\\n}\\n\\ntype node struct {\\n    val int\\n    count int\\n    next *node\\n    pre *node\\n    down *node\\n}\\n\\nfunc newNode(v int) *node {\\n    return &node{val:v, count:1, next:nil, pre:nil, down:nil}\\n}\\n\\nfunc (this *Skiplist) searchStack(num int) []*node {\\n    res := make([]*node, 0)\\n    head := this.fakeHead\\n    for head != nil && head.val != num {\\n        if head.next == nil || head.next.val > num {\\n            res = append(res, head)\\n            head = head.down\\n        } else {\\n            head = head.next\\n        }\\n    }\\n    if head != nil {\\n        return append(res, head)\\n    }\\n    return res\\n}\\n\\nfunc Constructor() Skiplist {\\n    levels := make([]*node, 10)\\n    for i := 0; i < len(levels); i += 1 {\\n        levels[i] = newNode(-1)\\n        if i != 0 {\\n            levels[i - 1].down = levels[i]\\n        }\\n    }\\n    return Skiplist{fakeHead: levels[0]}    \\n}\\n\\n\\nfunc (this *Skiplist) Search(target int) bool {\\n    stacks := this.searchStack(target)\\n    return stacks[len(stacks) - 1].val == target\\n}\\n\\nfunc (this *Skiplist) printList() {\\n    fmt.Println(\"print skip list:\")\\n    cur := this.fakeHead\\n    for cur != nil {\\n        row := cur\\n        for row != nil {\\n            fmt.Print(\"[\", row.val, \",\", row.count, \"]\", \"->\")\\n            row = row.next\\n        }\\n        fmt.Println(\"nil\")\\n        cur = cur.down\\n    }\\n    fmt.Println(\"skip list finished\")\\n}\\n\\nfunc (this *Skiplist) Add(num int)  {\\n    stacks := this.searchStack(num)\\n    if stacks[len(stacks) - 1].val == num {\\n        stacks[len(stacks) - 1].count += 1\\n        return\\n    }\\n    var down *node = nil\\n    \\n    for i := len(stacks) - 1; i >= 0; i -= 1 {\\n        var cur *node\\n        if i == len(stacks) - 1 || flipCoin() {\\n            cur = newNode(num)\\n        } else {\\n            cur = nil\\n        }\\n        \\n        if cur == nil {\\n            break\\n        }\\n        cur.next = stacks[i].next\\n        if stacks[i].next != nil {\\n            stacks[i].next.pre = cur\\n        }\\n        stacks[i].next = cur\\n        cur.pre = stacks[i]\\n        cur.down = down\\n        down = cur\\n    }\\n}\\n\\nfunc flipCoin() bool {\\n    return rand.Intn(10) > 4\\n}\\n\\nfunc (this *Skiplist) Erase(num int) bool {\\n    stacks := this.searchStack(num)\\n    cur := stacks[len(stacks) - 1]\\n    if cur.val != num {\\n        return false\\n    } else if cur.count > 1 {\\n        cur.count -= 1\\n        return true\\n    }\\n    \\n    for cur != nil {\\n        cur.pre.next = cur.next\\n        if cur.next != nil {\\n            cur.next.pre = cur.pre\\n        }\\n        cur = cur.down\\n    }\\n    return true\\n}\\n\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * obj := Constructor();\\n * param_1 := obj.Search(target);\\n * obj.Add(num);\\n * param_3 := obj.Erase(num);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nimport (\\n    \"fmt\"\\n    \"math/rand\"\\n)\\n\\ntype Skiplist struct {\\n    fakeHead *node\\n}\\n\\ntype node struct {\\n    val int\\n    count int\\n    next *node\\n    pre *node\\n    down *node\\n}\\n\\nfunc newNode(v int) *node {\\n    return &node{val:v, count:1, next:nil, pre:nil, down:nil}\\n}\\n\\nfunc (this *Skiplist) searchStack(num int) []*node {\\n    res := make([]*node, 0)\\n    head := this.fakeHead\\n    for head != nil && head.val != num {\\n        if head.next == nil || head.next.val > num {\\n            res = append(res, head)\\n            head = head.down\\n        } else {\\n            head = head.next\\n        }\\n    }\\n    if head != nil {\\n        return append(res, head)\\n    }\\n    return res\\n}\\n\\nfunc Constructor() Skiplist {\\n    levels := make([]*node, 10)\\n    for i := 0; i < len(levels); i += 1 {\\n        levels[i] = newNode(-1)\\n        if i != 0 {\\n            levels[i - 1].down = levels[i]\\n        }\\n    }\\n    return Skiplist{fakeHead: levels[0]}    \\n}\\n\\n\\nfunc (this *Skiplist) Search(target int) bool {\\n    stacks := this.searchStack(target)\\n    return stacks[len(stacks) - 1].val == target\\n}\\n\\nfunc (this *Skiplist) printList() {\\n    fmt.Println(\"print skip list:\")\\n    cur := this.fakeHead\\n    for cur != nil {\\n        row := cur\\n        for row != nil {\\n            fmt.Print(\"[\", row.val, \",\", row.count, \"]\", \"->\")\\n            row = row.next\\n        }\\n        fmt.Println(\"nil\")\\n        cur = cur.down\\n    }\\n    fmt.Println(\"skip list finished\")\\n}\\n\\nfunc (this *Skiplist) Add(num int)  {\\n    stacks := this.searchStack(num)\\n    if stacks[len(stacks) - 1].val == num {\\n        stacks[len(stacks) - 1].count += 1\\n        return\\n    }\\n    var down *node = nil\\n    \\n    for i := len(stacks) - 1; i >= 0; i -= 1 {\\n        var cur *node\\n        if i == len(stacks) - 1 || flipCoin() {\\n            cur = newNode(num)\\n        } else {\\n            cur = nil\\n        }\\n        \\n        if cur == nil {\\n            break\\n        }\\n        cur.next = stacks[i].next\\n        if stacks[i].next != nil {\\n            stacks[i].next.pre = cur\\n        }\\n        stacks[i].next = cur\\n        cur.pre = stacks[i]\\n        cur.down = down\\n        down = cur\\n    }\\n}\\n\\nfunc flipCoin() bool {\\n    return rand.Intn(10) > 4\\n}\\n\\nfunc (this *Skiplist) Erase(num int) bool {\\n    stacks := this.searchStack(num)\\n    cur := stacks[len(stacks) - 1]\\n    if cur.val != num {\\n        return false\\n    } else if cur.count > 1 {\\n        cur.count -= 1\\n        return true\\n    }\\n    \\n    for cur != nil {\\n        cur.pre.next = cur.next\\n        if cur.next != nil {\\n            cur.next.pre = cur.pre\\n        }\\n        cur = cur.down\\n    }\\n    return true\\n}\\n\\n\\n/**\\n * Your Skiplist object will be instantiated and called as such:\\n * obj := Constructor();\\n * param_1 := obj.Search(target);\\n * obj.Add(num);\\n * param_3 := obj.Erase(num);\\n */\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 559894,
                "title": "python-1-node-per-value-add-layers-when-needed",
                "content": "```\\nclass Node:\\n    def __init__(self, val=None, nxt=None):\\n        self.link_stack = [nxt]\\n        self.val = val\\n\\nclass Skiplist:\\n    def __init__(self):\\n        self.root = Node(float(\\'-inf\\'))\\n\\n    def search(self, target: int) -> bool:\\n        p = self.root\\n        for i in range(len(p.link_stack) - 1, -1, -1):\\n            while p.link_stack[i] is not None and target >= p.link_stack[i].val:\\n                p = p.link_stack[i]\\n            if p.val == target: return True\\n        return False\\n\\n    def add(self, num: int) -> None:\\n        p = self.root\\n        node = Node(num)\\n        cur_highest_level = len(p.link_stack) - 1\\n        total_highest_level = int(-log2(1 - random()))\\n        node.link_stack.extend([None] * total_highest_level)\\n        for i in range(min(total_highest_level, cur_highest_level), -1, -1):\\n            while p.link_stack[i] is not None and num >= p.link_stack[i].val:\\n                p = p.link_stack[i]\\n            node.link_stack[i] = p.link_stack[i]\\n            p.link_stack[i] = node\\n        if cur_highest_level < total_highest_level:\\n            for _ in range(total_highest_level - cur_highest_level):\\n                self.root.link_stack.append(node)\\n                \\n    def erase(self, num: int) -> bool:\\n        p = self.root\\n        for i in range(len(p.link_stack) - 1, -1, -1):\\n            while p.link_stack[i] is not None and num > p.link_stack[i].val:\\n                p = p.link_stack[i]\\n            if p.link_stack[i] is not None and num == p.link_stack[i].val:\\n                p.link_stack[i] = p.link_stack[i].link_stack[i]\\n                if not i: return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node:\\n    def __init__(self, val=None, nxt=None):\\n        self.link_stack = [nxt]\\n        self.val = val\\n\\nclass Skiplist:\\n    def __init__(self):\\n        self.root = Node(float(\\'-inf\\'))\\n\\n    def search(self, target: int) -> bool:\\n        p = self.root\\n        for i in range(len(p.link_stack) - 1, -1, -1):\\n            while p.link_stack[i] is not None and target >= p.link_stack[i].val:\\n                p = p.link_stack[i]\\n            if p.val == target: return True\\n        return False\\n\\n    def add(self, num: int) -> None:\\n        p = self.root\\n        node = Node(num)\\n        cur_highest_level = len(p.link_stack) - 1\\n        total_highest_level = int(-log2(1 - random()))\\n        node.link_stack.extend([None] * total_highest_level)\\n        for i in range(min(total_highest_level, cur_highest_level), -1, -1):\\n            while p.link_stack[i] is not None and num >= p.link_stack[i].val:\\n                p = p.link_stack[i]\\n            node.link_stack[i] = p.link_stack[i]\\n            p.link_stack[i] = node\\n        if cur_highest_level < total_highest_level:\\n            for _ in range(total_highest_level - cur_highest_level):\\n                self.root.link_stack.append(node)\\n                \\n    def erase(self, num: int) -> bool:\\n        p = self.root\\n        for i in range(len(p.link_stack) - 1, -1, -1):\\n            while p.link_stack[i] is not None and num > p.link_stack[i].val:\\n                p = p.link_stack[i]\\n            if p.link_stack[i] is not None and num == p.link_stack[i].val:\\n                p.link_stack[i] = p.link_stack[i].link_stack[i]\\n                if not i: return True\\n        return False\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565266,
                "content": [
                    {
                        "username": "rcode0",
                        "content": "I\\'ve never ran into a skiplist before, and I had a few bugs, so this was one of the most time consuming problems for me to solve on LC.\\n\\n1. There\\'s a few short skiplist videos on youtube, but the first part of this one was the most helpful I could find: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2015/lecture-videos/lecture-7-randomization-skip-lists/\\n2. Start with a -infinity node, so you never have to insert on the left edge. I had a +infinity for symmetry.\\n3. Use a deterministic RNG with a constant seed, so you can have repeatable runs for debugging.\\n4. (Big help!) Spend the easy 20-40 lines it takes to output your skiplist to a graphviz .dot text format. It\\'s not hard, you can experiment here - http://www.webgraphviz.com/ - I labeled nodes with their values, edges with the level they were on, and dotted lines for backward edges and solid lines for forward edges . Trying to draw out the pointer relationships by hand was much slower and less helpful.\\n5. Running locally in an IDE, I had a snippet of code to autogenerate a local test from the leetcode test case that was failing. I could then print out the skip list state before and after the last operation that caused the testcase to fail and compare them with graphviz.\\n\\n\\nIn the end I got ~16ms on the first run, but was from the start using an arena memory allocation strategy and indexing into the arena in place of real pointers."
                    },
                    {
                        "username": "sockofleas2",
                        "content": "This question is terrible. Doesn\\'t explain how the skiplist works or how levels are added, just has a short gif from wikipedia."
                    },
                    {
                        "username": "XIZI_leetcode",
                        "content": "Especially the gif shows first adding the new element at the bottom level, then coin flip to decide if we need to add it to the upper level. It\\'s missleading."
                    },
                    {
                        "username": "itsgosho",
                        "content": "Actually there is really different ways to implement skip list and the idea is to practice them. No one will explain you in few lines how to implement it."
                    },
                    {
                        "username": "cpcs",
                        "content": "https://mp.weixin.qq.com/s?__biz=MzUzMDQxNTI4OQ==&mid=2247484374&idx=1&sn=5ca5df5659f1860847f55129b25465e1&chksm=fa536800cd24e11674dace66861f7411f7c7c0fddce5abee884555875acfa40efaed908913bc&token=1817182455&lang=zh_CN#rd"
                    },
                    {
                        "username": "sydneyos",
                        "content": "Does it mean no HashMaps or Lists?  Or just not built in libraries that already implement Skiplist functionality?"
                    },
                    {
                        "username": "CaptainPZ",
                        "content": "Got stuck there for quite a while. \\n\\nThe number 9 has been deleted already, why searching(9) still returns true from the given solution? \\n\\nLook at the question again, you might find the following sattement helpful.\\n\\n**Note that duplicates may exist in the Skiplist, your code needs to handle this situation.**\\n\\nIf 9 has been added into skiplist twice, it should be in the list twice as duplicated element which requires two deletions to get rid of.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I try to construct a BST to solve the problem, but TLE is encountered. I guess the time complexity for my erase function is low efficiency. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I have solved it, thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "There seems to be a bug in the malloc library. In the code snippet below, if I uncomment the free(q) line, I get a \"heap-use-after-free\" error even though q is clearly not reused (or, at least, is set to point to a different memory).\\nCan anybody help?\\n```\\n    while (n->right == NULL && n->down != NULL) {\\n        q = n;\\n        n = n->down;\\n//        free(q);\\n    }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not so much hard as tedious. There are a lot of pointers that need to cooperate with each other before this skip list will work but otherwise, this is pretty straight forward if you know how to handle linked lists.\n\nOne helpful hint is to have a dummy node at the beginning of each row with the value INT_MIN. This makes traversing between the rows much easier.\n\nA way to display the list is essential if you are to see that it is working correctly. This is the code I used:\n```\nvoid printList(Skiplist *s) {\n    Node *p, *n = s->head;\n    while(n != NULL) {\n        printf(\"|--- \");\n        p = n->right;\n        while(p != NULL) {\n            printf(\"%d --- \", p->val);\n            p = p->right;\n        }\n        printf(\"|\\n\");\n        n = n->down;\n    }\n    printf(\"\\n\");\n}\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1857581,
                "content": [
                    {
                        "username": "rcode0",
                        "content": "I\\'ve never ran into a skiplist before, and I had a few bugs, so this was one of the most time consuming problems for me to solve on LC.\\n\\n1. There\\'s a few short skiplist videos on youtube, but the first part of this one was the most helpful I could find: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2015/lecture-videos/lecture-7-randomization-skip-lists/\\n2. Start with a -infinity node, so you never have to insert on the left edge. I had a +infinity for symmetry.\\n3. Use a deterministic RNG with a constant seed, so you can have repeatable runs for debugging.\\n4. (Big help!) Spend the easy 20-40 lines it takes to output your skiplist to a graphviz .dot text format. It\\'s not hard, you can experiment here - http://www.webgraphviz.com/ - I labeled nodes with their values, edges with the level they were on, and dotted lines for backward edges and solid lines for forward edges . Trying to draw out the pointer relationships by hand was much slower and less helpful.\\n5. Running locally in an IDE, I had a snippet of code to autogenerate a local test from the leetcode test case that was failing. I could then print out the skip list state before and after the last operation that caused the testcase to fail and compare them with graphviz.\\n\\n\\nIn the end I got ~16ms on the first run, but was from the start using an arena memory allocation strategy and indexing into the arena in place of real pointers."
                    },
                    {
                        "username": "sockofleas2",
                        "content": "This question is terrible. Doesn\\'t explain how the skiplist works or how levels are added, just has a short gif from wikipedia."
                    },
                    {
                        "username": "XIZI_leetcode",
                        "content": "Especially the gif shows first adding the new element at the bottom level, then coin flip to decide if we need to add it to the upper level. It\\'s missleading."
                    },
                    {
                        "username": "itsgosho",
                        "content": "Actually there is really different ways to implement skip list and the idea is to practice them. No one will explain you in few lines how to implement it."
                    },
                    {
                        "username": "cpcs",
                        "content": "https://mp.weixin.qq.com/s?__biz=MzUzMDQxNTI4OQ==&mid=2247484374&idx=1&sn=5ca5df5659f1860847f55129b25465e1&chksm=fa536800cd24e11674dace66861f7411f7c7c0fddce5abee884555875acfa40efaed908913bc&token=1817182455&lang=zh_CN#rd"
                    },
                    {
                        "username": "sydneyos",
                        "content": "Does it mean no HashMaps or Lists?  Or just not built in libraries that already implement Skiplist functionality?"
                    },
                    {
                        "username": "CaptainPZ",
                        "content": "Got stuck there for quite a while. \\n\\nThe number 9 has been deleted already, why searching(9) still returns true from the given solution? \\n\\nLook at the question again, you might find the following sattement helpful.\\n\\n**Note that duplicates may exist in the Skiplist, your code needs to handle this situation.**\\n\\nIf 9 has been added into skiplist twice, it should be in the list twice as duplicated element which requires two deletions to get rid of.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I try to construct a BST to solve the problem, but TLE is encountered. I guess the time complexity for my erase function is low efficiency. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I have solved it, thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "There seems to be a bug in the malloc library. In the code snippet below, if I uncomment the free(q) line, I get a \"heap-use-after-free\" error even though q is clearly not reused (or, at least, is set to point to a different memory).\\nCan anybody help?\\n```\\n    while (n->right == NULL && n->down != NULL) {\\n        q = n;\\n        n = n->down;\\n//        free(q);\\n    }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not so much hard as tedious. There are a lot of pointers that need to cooperate with each other before this skip list will work but otherwise, this is pretty straight forward if you know how to handle linked lists.\n\nOne helpful hint is to have a dummy node at the beginning of each row with the value INT_MIN. This makes traversing between the rows much easier.\n\nA way to display the list is essential if you are to see that it is working correctly. This is the code I used:\n```\nvoid printList(Skiplist *s) {\n    Node *p, *n = s->head;\n    while(n != NULL) {\n        printf(\"|--- \");\n        p = n->right;\n        while(p != NULL) {\n            printf(\"%d --- \", p->val);\n            p = p->right;\n        }\n        printf(\"|\\n\");\n        n = n->down;\n    }\n    printf(\"\\n\");\n}\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1569727,
                "content": [
                    {
                        "username": "rcode0",
                        "content": "I\\'ve never ran into a skiplist before, and I had a few bugs, so this was one of the most time consuming problems for me to solve on LC.\\n\\n1. There\\'s a few short skiplist videos on youtube, but the first part of this one was the most helpful I could find: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2015/lecture-videos/lecture-7-randomization-skip-lists/\\n2. Start with a -infinity node, so you never have to insert on the left edge. I had a +infinity for symmetry.\\n3. Use a deterministic RNG with a constant seed, so you can have repeatable runs for debugging.\\n4. (Big help!) Spend the easy 20-40 lines it takes to output your skiplist to a graphviz .dot text format. It\\'s not hard, you can experiment here - http://www.webgraphviz.com/ - I labeled nodes with their values, edges with the level they were on, and dotted lines for backward edges and solid lines for forward edges . Trying to draw out the pointer relationships by hand was much slower and less helpful.\\n5. Running locally in an IDE, I had a snippet of code to autogenerate a local test from the leetcode test case that was failing. I could then print out the skip list state before and after the last operation that caused the testcase to fail and compare them with graphviz.\\n\\n\\nIn the end I got ~16ms on the first run, but was from the start using an arena memory allocation strategy and indexing into the arena in place of real pointers."
                    },
                    {
                        "username": "sockofleas2",
                        "content": "This question is terrible. Doesn\\'t explain how the skiplist works or how levels are added, just has a short gif from wikipedia."
                    },
                    {
                        "username": "XIZI_leetcode",
                        "content": "Especially the gif shows first adding the new element at the bottom level, then coin flip to decide if we need to add it to the upper level. It\\'s missleading."
                    },
                    {
                        "username": "itsgosho",
                        "content": "Actually there is really different ways to implement skip list and the idea is to practice them. No one will explain you in few lines how to implement it."
                    },
                    {
                        "username": "cpcs",
                        "content": "https://mp.weixin.qq.com/s?__biz=MzUzMDQxNTI4OQ==&mid=2247484374&idx=1&sn=5ca5df5659f1860847f55129b25465e1&chksm=fa536800cd24e11674dace66861f7411f7c7c0fddce5abee884555875acfa40efaed908913bc&token=1817182455&lang=zh_CN#rd"
                    },
                    {
                        "username": "sydneyos",
                        "content": "Does it mean no HashMaps or Lists?  Or just not built in libraries that already implement Skiplist functionality?"
                    },
                    {
                        "username": "CaptainPZ",
                        "content": "Got stuck there for quite a while. \\n\\nThe number 9 has been deleted already, why searching(9) still returns true from the given solution? \\n\\nLook at the question again, you might find the following sattement helpful.\\n\\n**Note that duplicates may exist in the Skiplist, your code needs to handle this situation.**\\n\\nIf 9 has been added into skiplist twice, it should be in the list twice as duplicated element which requires two deletions to get rid of.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I try to construct a BST to solve the problem, but TLE is encountered. I guess the time complexity for my erase function is low efficiency. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I have solved it, thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "There seems to be a bug in the malloc library. In the code snippet below, if I uncomment the free(q) line, I get a \"heap-use-after-free\" error even though q is clearly not reused (or, at least, is set to point to a different memory).\\nCan anybody help?\\n```\\n    while (n->right == NULL && n->down != NULL) {\\n        q = n;\\n        n = n->down;\\n//        free(q);\\n    }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not so much hard as tedious. There are a lot of pointers that need to cooperate with each other before this skip list will work but otherwise, this is pretty straight forward if you know how to handle linked lists.\n\nOne helpful hint is to have a dummy node at the beginning of each row with the value INT_MIN. This makes traversing between the rows much easier.\n\nA way to display the list is essential if you are to see that it is working correctly. This is the code I used:\n```\nvoid printList(Skiplist *s) {\n    Node *p, *n = s->head;\n    while(n != NULL) {\n        printf(\"|--- \");\n        p = n->right;\n        while(p != NULL) {\n            printf(\"%d --- \", p->val);\n            p = p->right;\n        }\n        printf(\"|\\n\");\n        n = n->down;\n    }\n    printf(\"\\n\");\n}\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1576506,
                "content": [
                    {
                        "username": "rcode0",
                        "content": "I\\'ve never ran into a skiplist before, and I had a few bugs, so this was one of the most time consuming problems for me to solve on LC.\\n\\n1. There\\'s a few short skiplist videos on youtube, but the first part of this one was the most helpful I could find: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2015/lecture-videos/lecture-7-randomization-skip-lists/\\n2. Start with a -infinity node, so you never have to insert on the left edge. I had a +infinity for symmetry.\\n3. Use a deterministic RNG with a constant seed, so you can have repeatable runs for debugging.\\n4. (Big help!) Spend the easy 20-40 lines it takes to output your skiplist to a graphviz .dot text format. It\\'s not hard, you can experiment here - http://www.webgraphviz.com/ - I labeled nodes with their values, edges with the level they were on, and dotted lines for backward edges and solid lines for forward edges . Trying to draw out the pointer relationships by hand was much slower and less helpful.\\n5. Running locally in an IDE, I had a snippet of code to autogenerate a local test from the leetcode test case that was failing. I could then print out the skip list state before and after the last operation that caused the testcase to fail and compare them with graphviz.\\n\\n\\nIn the end I got ~16ms on the first run, but was from the start using an arena memory allocation strategy and indexing into the arena in place of real pointers."
                    },
                    {
                        "username": "sockofleas2",
                        "content": "This question is terrible. Doesn\\'t explain how the skiplist works or how levels are added, just has a short gif from wikipedia."
                    },
                    {
                        "username": "XIZI_leetcode",
                        "content": "Especially the gif shows first adding the new element at the bottom level, then coin flip to decide if we need to add it to the upper level. It\\'s missleading."
                    },
                    {
                        "username": "itsgosho",
                        "content": "Actually there is really different ways to implement skip list and the idea is to practice them. No one will explain you in few lines how to implement it."
                    },
                    {
                        "username": "cpcs",
                        "content": "https://mp.weixin.qq.com/s?__biz=MzUzMDQxNTI4OQ==&mid=2247484374&idx=1&sn=5ca5df5659f1860847f55129b25465e1&chksm=fa536800cd24e11674dace66861f7411f7c7c0fddce5abee884555875acfa40efaed908913bc&token=1817182455&lang=zh_CN#rd"
                    },
                    {
                        "username": "sydneyos",
                        "content": "Does it mean no HashMaps or Lists?  Or just not built in libraries that already implement Skiplist functionality?"
                    },
                    {
                        "username": "CaptainPZ",
                        "content": "Got stuck there for quite a while. \\n\\nThe number 9 has been deleted already, why searching(9) still returns true from the given solution? \\n\\nLook at the question again, you might find the following sattement helpful.\\n\\n**Note that duplicates may exist in the Skiplist, your code needs to handle this situation.**\\n\\nIf 9 has been added into skiplist twice, it should be in the list twice as duplicated element which requires two deletions to get rid of.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I try to construct a BST to solve the problem, but TLE is encountered. I guess the time complexity for my erase function is low efficiency. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I have solved it, thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "There seems to be a bug in the malloc library. In the code snippet below, if I uncomment the free(q) line, I get a \"heap-use-after-free\" error even though q is clearly not reused (or, at least, is set to point to a different memory).\\nCan anybody help?\\n```\\n    while (n->right == NULL && n->down != NULL) {\\n        q = n;\\n        n = n->down;\\n//        free(q);\\n    }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not so much hard as tedious. There are a lot of pointers that need to cooperate with each other before this skip list will work but otherwise, this is pretty straight forward if you know how to handle linked lists.\n\nOne helpful hint is to have a dummy node at the beginning of each row with the value INT_MIN. This makes traversing between the rows much easier.\n\nA way to display the list is essential if you are to see that it is working correctly. This is the code I used:\n```\nvoid printList(Skiplist *s) {\n    Node *p, *n = s->head;\n    while(n != NULL) {\n        printf(\"|--- \");\n        p = n->right;\n        while(p != NULL) {\n            printf(\"%d --- \", p->val);\n            p = p->right;\n        }\n        printf(\"|\\n\");\n        n = n->down;\n    }\n    printf(\"\\n\");\n}\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1570197,
                "content": [
                    {
                        "username": "rcode0",
                        "content": "I\\'ve never ran into a skiplist before, and I had a few bugs, so this was one of the most time consuming problems for me to solve on LC.\\n\\n1. There\\'s a few short skiplist videos on youtube, but the first part of this one was the most helpful I could find: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2015/lecture-videos/lecture-7-randomization-skip-lists/\\n2. Start with a -infinity node, so you never have to insert on the left edge. I had a +infinity for symmetry.\\n3. Use a deterministic RNG with a constant seed, so you can have repeatable runs for debugging.\\n4. (Big help!) Spend the easy 20-40 lines it takes to output your skiplist to a graphviz .dot text format. It\\'s not hard, you can experiment here - http://www.webgraphviz.com/ - I labeled nodes with their values, edges with the level they were on, and dotted lines for backward edges and solid lines for forward edges . Trying to draw out the pointer relationships by hand was much slower and less helpful.\\n5. Running locally in an IDE, I had a snippet of code to autogenerate a local test from the leetcode test case that was failing. I could then print out the skip list state before and after the last operation that caused the testcase to fail and compare them with graphviz.\\n\\n\\nIn the end I got ~16ms on the first run, but was from the start using an arena memory allocation strategy and indexing into the arena in place of real pointers."
                    },
                    {
                        "username": "sockofleas2",
                        "content": "This question is terrible. Doesn\\'t explain how the skiplist works or how levels are added, just has a short gif from wikipedia."
                    },
                    {
                        "username": "XIZI_leetcode",
                        "content": "Especially the gif shows first adding the new element at the bottom level, then coin flip to decide if we need to add it to the upper level. It\\'s missleading."
                    },
                    {
                        "username": "itsgosho",
                        "content": "Actually there is really different ways to implement skip list and the idea is to practice them. No one will explain you in few lines how to implement it."
                    },
                    {
                        "username": "cpcs",
                        "content": "https://mp.weixin.qq.com/s?__biz=MzUzMDQxNTI4OQ==&mid=2247484374&idx=1&sn=5ca5df5659f1860847f55129b25465e1&chksm=fa536800cd24e11674dace66861f7411f7c7c0fddce5abee884555875acfa40efaed908913bc&token=1817182455&lang=zh_CN#rd"
                    },
                    {
                        "username": "sydneyos",
                        "content": "Does it mean no HashMaps or Lists?  Or just not built in libraries that already implement Skiplist functionality?"
                    },
                    {
                        "username": "CaptainPZ",
                        "content": "Got stuck there for quite a while. \\n\\nThe number 9 has been deleted already, why searching(9) still returns true from the given solution? \\n\\nLook at the question again, you might find the following sattement helpful.\\n\\n**Note that duplicates may exist in the Skiplist, your code needs to handle this situation.**\\n\\nIf 9 has been added into skiplist twice, it should be in the list twice as duplicated element which requires two deletions to get rid of.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I try to construct a BST to solve the problem, but TLE is encountered. I guess the time complexity for my erase function is low efficiency. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I have solved it, thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "There seems to be a bug in the malloc library. In the code snippet below, if I uncomment the free(q) line, I get a \"heap-use-after-free\" error even though q is clearly not reused (or, at least, is set to point to a different memory).\\nCan anybody help?\\n```\\n    while (n->right == NULL && n->down != NULL) {\\n        q = n;\\n        n = n->down;\\n//        free(q);\\n    }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not so much hard as tedious. There are a lot of pointers that need to cooperate with each other before this skip list will work but otherwise, this is pretty straight forward if you know how to handle linked lists.\n\nOne helpful hint is to have a dummy node at the beginning of each row with the value INT_MIN. This makes traversing between the rows much easier.\n\nA way to display the list is essential if you are to see that it is working correctly. This is the code I used:\n```\nvoid printList(Skiplist *s) {\n    Node *p, *n = s->head;\n    while(n != NULL) {\n        printf(\"|--- \");\n        p = n->right;\n        while(p != NULL) {\n            printf(\"%d --- \", p->val);\n            p = p->right;\n        }\n        printf(\"|\\n\");\n        n = n->down;\n    }\n    printf(\"\\n\");\n}\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 2023447,
                "content": [
                    {
                        "username": "rcode0",
                        "content": "I\\'ve never ran into a skiplist before, and I had a few bugs, so this was one of the most time consuming problems for me to solve on LC.\\n\\n1. There\\'s a few short skiplist videos on youtube, but the first part of this one was the most helpful I could find: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2015/lecture-videos/lecture-7-randomization-skip-lists/\\n2. Start with a -infinity node, so you never have to insert on the left edge. I had a +infinity for symmetry.\\n3. Use a deterministic RNG with a constant seed, so you can have repeatable runs for debugging.\\n4. (Big help!) Spend the easy 20-40 lines it takes to output your skiplist to a graphviz .dot text format. It\\'s not hard, you can experiment here - http://www.webgraphviz.com/ - I labeled nodes with their values, edges with the level they were on, and dotted lines for backward edges and solid lines for forward edges . Trying to draw out the pointer relationships by hand was much slower and less helpful.\\n5. Running locally in an IDE, I had a snippet of code to autogenerate a local test from the leetcode test case that was failing. I could then print out the skip list state before and after the last operation that caused the testcase to fail and compare them with graphviz.\\n\\n\\nIn the end I got ~16ms on the first run, but was from the start using an arena memory allocation strategy and indexing into the arena in place of real pointers."
                    },
                    {
                        "username": "sockofleas2",
                        "content": "This question is terrible. Doesn\\'t explain how the skiplist works or how levels are added, just has a short gif from wikipedia."
                    },
                    {
                        "username": "XIZI_leetcode",
                        "content": "Especially the gif shows first adding the new element at the bottom level, then coin flip to decide if we need to add it to the upper level. It\\'s missleading."
                    },
                    {
                        "username": "itsgosho",
                        "content": "Actually there is really different ways to implement skip list and the idea is to practice them. No one will explain you in few lines how to implement it."
                    },
                    {
                        "username": "cpcs",
                        "content": "https://mp.weixin.qq.com/s?__biz=MzUzMDQxNTI4OQ==&mid=2247484374&idx=1&sn=5ca5df5659f1860847f55129b25465e1&chksm=fa536800cd24e11674dace66861f7411f7c7c0fddce5abee884555875acfa40efaed908913bc&token=1817182455&lang=zh_CN#rd"
                    },
                    {
                        "username": "sydneyos",
                        "content": "Does it mean no HashMaps or Lists?  Or just not built in libraries that already implement Skiplist functionality?"
                    },
                    {
                        "username": "CaptainPZ",
                        "content": "Got stuck there for quite a while. \\n\\nThe number 9 has been deleted already, why searching(9) still returns true from the given solution? \\n\\nLook at the question again, you might find the following sattement helpful.\\n\\n**Note that duplicates may exist in the Skiplist, your code needs to handle this situation.**\\n\\nIf 9 has been added into skiplist twice, it should be in the list twice as duplicated element which requires two deletions to get rid of.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I try to construct a BST to solve the problem, but TLE is encountered. I guess the time complexity for my erase function is low efficiency. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I have solved it, thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "There seems to be a bug in the malloc library. In the code snippet below, if I uncomment the free(q) line, I get a \"heap-use-after-free\" error even though q is clearly not reused (or, at least, is set to point to a different memory).\\nCan anybody help?\\n```\\n    while (n->right == NULL && n->down != NULL) {\\n        q = n;\\n        n = n->down;\\n//        free(q);\\n    }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not so much hard as tedious. There are a lot of pointers that need to cooperate with each other before this skip list will work but otherwise, this is pretty straight forward if you know how to handle linked lists.\n\nOne helpful hint is to have a dummy node at the beginning of each row with the value INT_MIN. This makes traversing between the rows much easier.\n\nA way to display the list is essential if you are to see that it is working correctly. This is the code I used:\n```\nvoid printList(Skiplist *s) {\n    Node *p, *n = s->head;\n    while(n != NULL) {\n        printf(\"|--- \");\n        p = n->right;\n        while(p != NULL) {\n            printf(\"%d --- \", p->val);\n            p = p->right;\n        }\n        printf(\"|\\n\");\n        n = n->down;\n    }\n    printf(\"\\n\");\n}\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1912946,
                "content": [
                    {
                        "username": "rcode0",
                        "content": "I\\'ve never ran into a skiplist before, and I had a few bugs, so this was one of the most time consuming problems for me to solve on LC.\\n\\n1. There\\'s a few short skiplist videos on youtube, but the first part of this one was the most helpful I could find: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2015/lecture-videos/lecture-7-randomization-skip-lists/\\n2. Start with a -infinity node, so you never have to insert on the left edge. I had a +infinity for symmetry.\\n3. Use a deterministic RNG with a constant seed, so you can have repeatable runs for debugging.\\n4. (Big help!) Spend the easy 20-40 lines it takes to output your skiplist to a graphviz .dot text format. It\\'s not hard, you can experiment here - http://www.webgraphviz.com/ - I labeled nodes with their values, edges with the level they were on, and dotted lines for backward edges and solid lines for forward edges . Trying to draw out the pointer relationships by hand was much slower and less helpful.\\n5. Running locally in an IDE, I had a snippet of code to autogenerate a local test from the leetcode test case that was failing. I could then print out the skip list state before and after the last operation that caused the testcase to fail and compare them with graphviz.\\n\\n\\nIn the end I got ~16ms on the first run, but was from the start using an arena memory allocation strategy and indexing into the arena in place of real pointers."
                    },
                    {
                        "username": "sockofleas2",
                        "content": "This question is terrible. Doesn\\'t explain how the skiplist works or how levels are added, just has a short gif from wikipedia."
                    },
                    {
                        "username": "XIZI_leetcode",
                        "content": "Especially the gif shows first adding the new element at the bottom level, then coin flip to decide if we need to add it to the upper level. It\\'s missleading."
                    },
                    {
                        "username": "itsgosho",
                        "content": "Actually there is really different ways to implement skip list and the idea is to practice them. No one will explain you in few lines how to implement it."
                    },
                    {
                        "username": "cpcs",
                        "content": "https://mp.weixin.qq.com/s?__biz=MzUzMDQxNTI4OQ==&mid=2247484374&idx=1&sn=5ca5df5659f1860847f55129b25465e1&chksm=fa536800cd24e11674dace66861f7411f7c7c0fddce5abee884555875acfa40efaed908913bc&token=1817182455&lang=zh_CN#rd"
                    },
                    {
                        "username": "sydneyos",
                        "content": "Does it mean no HashMaps or Lists?  Or just not built in libraries that already implement Skiplist functionality?"
                    },
                    {
                        "username": "CaptainPZ",
                        "content": "Got stuck there for quite a while. \\n\\nThe number 9 has been deleted already, why searching(9) still returns true from the given solution? \\n\\nLook at the question again, you might find the following sattement helpful.\\n\\n**Note that duplicates may exist in the Skiplist, your code needs to handle this situation.**\\n\\nIf 9 has been added into skiplist twice, it should be in the list twice as duplicated element which requires two deletions to get rid of.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I try to construct a BST to solve the problem, but TLE is encountered. I guess the time complexity for my erase function is low efficiency. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I have solved it, thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "There seems to be a bug in the malloc library. In the code snippet below, if I uncomment the free(q) line, I get a \"heap-use-after-free\" error even though q is clearly not reused (or, at least, is set to point to a different memory).\\nCan anybody help?\\n```\\n    while (n->right == NULL && n->down != NULL) {\\n        q = n;\\n        n = n->down;\\n//        free(q);\\n    }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not so much hard as tedious. There are a lot of pointers that need to cooperate with each other before this skip list will work but otherwise, this is pretty straight forward if you know how to handle linked lists.\n\nOne helpful hint is to have a dummy node at the beginning of each row with the value INT_MIN. This makes traversing between the rows much easier.\n\nA way to display the list is essential if you are to see that it is working correctly. This is the code I used:\n```\nvoid printList(Skiplist *s) {\n    Node *p, *n = s->head;\n    while(n != NULL) {\n        printf(\"|--- \");\n        p = n->right;\n        while(p != NULL) {\n            printf(\"%d --- \", p->val);\n            p = p->right;\n        }\n        printf(\"|\\n\");\n        n = n->down;\n    }\n    printf(\"\\n\");\n}\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1912278,
                "content": [
                    {
                        "username": "rcode0",
                        "content": "I\\'ve never ran into a skiplist before, and I had a few bugs, so this was one of the most time consuming problems for me to solve on LC.\\n\\n1. There\\'s a few short skiplist videos on youtube, but the first part of this one was the most helpful I could find: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2015/lecture-videos/lecture-7-randomization-skip-lists/\\n2. Start with a -infinity node, so you never have to insert on the left edge. I had a +infinity for symmetry.\\n3. Use a deterministic RNG with a constant seed, so you can have repeatable runs for debugging.\\n4. (Big help!) Spend the easy 20-40 lines it takes to output your skiplist to a graphviz .dot text format. It\\'s not hard, you can experiment here - http://www.webgraphviz.com/ - I labeled nodes with their values, edges with the level they were on, and dotted lines for backward edges and solid lines for forward edges . Trying to draw out the pointer relationships by hand was much slower and less helpful.\\n5. Running locally in an IDE, I had a snippet of code to autogenerate a local test from the leetcode test case that was failing. I could then print out the skip list state before and after the last operation that caused the testcase to fail and compare them with graphviz.\\n\\n\\nIn the end I got ~16ms on the first run, but was from the start using an arena memory allocation strategy and indexing into the arena in place of real pointers."
                    },
                    {
                        "username": "sockofleas2",
                        "content": "This question is terrible. Doesn\\'t explain how the skiplist works or how levels are added, just has a short gif from wikipedia."
                    },
                    {
                        "username": "XIZI_leetcode",
                        "content": "Especially the gif shows first adding the new element at the bottom level, then coin flip to decide if we need to add it to the upper level. It\\'s missleading."
                    },
                    {
                        "username": "itsgosho",
                        "content": "Actually there is really different ways to implement skip list and the idea is to practice them. No one will explain you in few lines how to implement it."
                    },
                    {
                        "username": "cpcs",
                        "content": "https://mp.weixin.qq.com/s?__biz=MzUzMDQxNTI4OQ==&mid=2247484374&idx=1&sn=5ca5df5659f1860847f55129b25465e1&chksm=fa536800cd24e11674dace66861f7411f7c7c0fddce5abee884555875acfa40efaed908913bc&token=1817182455&lang=zh_CN#rd"
                    },
                    {
                        "username": "sydneyos",
                        "content": "Does it mean no HashMaps or Lists?  Or just not built in libraries that already implement Skiplist functionality?"
                    },
                    {
                        "username": "CaptainPZ",
                        "content": "Got stuck there for quite a while. \\n\\nThe number 9 has been deleted already, why searching(9) still returns true from the given solution? \\n\\nLook at the question again, you might find the following sattement helpful.\\n\\n**Note that duplicates may exist in the Skiplist, your code needs to handle this situation.**\\n\\nIf 9 has been added into skiplist twice, it should be in the list twice as duplicated element which requires two deletions to get rid of.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I try to construct a BST to solve the problem, but TLE is encountered. I guess the time complexity for my erase function is low efficiency. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I have solved it, thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "There seems to be a bug in the malloc library. In the code snippet below, if I uncomment the free(q) line, I get a \"heap-use-after-free\" error even though q is clearly not reused (or, at least, is set to point to a different memory).\\nCan anybody help?\\n```\\n    while (n->right == NULL && n->down != NULL) {\\n        q = n;\\n        n = n->down;\\n//        free(q);\\n    }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not so much hard as tedious. There are a lot of pointers that need to cooperate with each other before this skip list will work but otherwise, this is pretty straight forward if you know how to handle linked lists.\n\nOne helpful hint is to have a dummy node at the beginning of each row with the value INT_MIN. This makes traversing between the rows much easier.\n\nA way to display the list is essential if you are to see that it is working correctly. This is the code I used:\n```\nvoid printList(Skiplist *s) {\n    Node *p, *n = s->head;\n    while(n != NULL) {\n        printf(\"|--- \");\n        p = n->right;\n        while(p != NULL) {\n            printf(\"%d --- \", p->val);\n            p = p->right;\n        }\n        printf(\"|\\n\");\n        n = n->down;\n    }\n    printf(\"\\n\");\n}\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1763814,
                "content": [
                    {
                        "username": "rcode0",
                        "content": "I\\'ve never ran into a skiplist before, and I had a few bugs, so this was one of the most time consuming problems for me to solve on LC.\\n\\n1. There\\'s a few short skiplist videos on youtube, but the first part of this one was the most helpful I could find: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2015/lecture-videos/lecture-7-randomization-skip-lists/\\n2. Start with a -infinity node, so you never have to insert on the left edge. I had a +infinity for symmetry.\\n3. Use a deterministic RNG with a constant seed, so you can have repeatable runs for debugging.\\n4. (Big help!) Spend the easy 20-40 lines it takes to output your skiplist to a graphviz .dot text format. It\\'s not hard, you can experiment here - http://www.webgraphviz.com/ - I labeled nodes with their values, edges with the level they were on, and dotted lines for backward edges and solid lines for forward edges . Trying to draw out the pointer relationships by hand was much slower and less helpful.\\n5. Running locally in an IDE, I had a snippet of code to autogenerate a local test from the leetcode test case that was failing. I could then print out the skip list state before and after the last operation that caused the testcase to fail and compare them with graphviz.\\n\\n\\nIn the end I got ~16ms on the first run, but was from the start using an arena memory allocation strategy and indexing into the arena in place of real pointers."
                    },
                    {
                        "username": "sockofleas2",
                        "content": "This question is terrible. Doesn\\'t explain how the skiplist works or how levels are added, just has a short gif from wikipedia."
                    },
                    {
                        "username": "XIZI_leetcode",
                        "content": "Especially the gif shows first adding the new element at the bottom level, then coin flip to decide if we need to add it to the upper level. It\\'s missleading."
                    },
                    {
                        "username": "itsgosho",
                        "content": "Actually there is really different ways to implement skip list and the idea is to practice them. No one will explain you in few lines how to implement it."
                    },
                    {
                        "username": "cpcs",
                        "content": "https://mp.weixin.qq.com/s?__biz=MzUzMDQxNTI4OQ==&mid=2247484374&idx=1&sn=5ca5df5659f1860847f55129b25465e1&chksm=fa536800cd24e11674dace66861f7411f7c7c0fddce5abee884555875acfa40efaed908913bc&token=1817182455&lang=zh_CN#rd"
                    },
                    {
                        "username": "sydneyos",
                        "content": "Does it mean no HashMaps or Lists?  Or just not built in libraries that already implement Skiplist functionality?"
                    },
                    {
                        "username": "CaptainPZ",
                        "content": "Got stuck there for quite a while. \\n\\nThe number 9 has been deleted already, why searching(9) still returns true from the given solution? \\n\\nLook at the question again, you might find the following sattement helpful.\\n\\n**Note that duplicates may exist in the Skiplist, your code needs to handle this situation.**\\n\\nIf 9 has been added into skiplist twice, it should be in the list twice as duplicated element which requires two deletions to get rid of.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I try to construct a BST to solve the problem, but TLE is encountered. I guess the time complexity for my erase function is low efficiency. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I have solved it, thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "There seems to be a bug in the malloc library. In the code snippet below, if I uncomment the free(q) line, I get a \"heap-use-after-free\" error even though q is clearly not reused (or, at least, is set to point to a different memory).\\nCan anybody help?\\n```\\n    while (n->right == NULL && n->down != NULL) {\\n        q = n;\\n        n = n->down;\\n//        free(q);\\n    }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not so much hard as tedious. There are a lot of pointers that need to cooperate with each other before this skip list will work but otherwise, this is pretty straight forward if you know how to handle linked lists.\n\nOne helpful hint is to have a dummy node at the beginning of each row with the value INT_MIN. This makes traversing between the rows much easier.\n\nA way to display the list is essential if you are to see that it is working correctly. This is the code I used:\n```\nvoid printList(Skiplist *s) {\n    Node *p, *n = s->head;\n    while(n != NULL) {\n        printf(\"|--- \");\n        p = n->right;\n        while(p != NULL) {\n            printf(\"%d --- \", p->val);\n            p = p->right;\n        }\n        printf(\"|\\n\");\n        n = n->down;\n    }\n    printf(\"\\n\");\n}\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1761887,
                "content": [
                    {
                        "username": "rcode0",
                        "content": "I\\'ve never ran into a skiplist before, and I had a few bugs, so this was one of the most time consuming problems for me to solve on LC.\\n\\n1. There\\'s a few short skiplist videos on youtube, but the first part of this one was the most helpful I could find: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2015/lecture-videos/lecture-7-randomization-skip-lists/\\n2. Start with a -infinity node, so you never have to insert on the left edge. I had a +infinity for symmetry.\\n3. Use a deterministic RNG with a constant seed, so you can have repeatable runs for debugging.\\n4. (Big help!) Spend the easy 20-40 lines it takes to output your skiplist to a graphviz .dot text format. It\\'s not hard, you can experiment here - http://www.webgraphviz.com/ - I labeled nodes with their values, edges with the level they were on, and dotted lines for backward edges and solid lines for forward edges . Trying to draw out the pointer relationships by hand was much slower and less helpful.\\n5. Running locally in an IDE, I had a snippet of code to autogenerate a local test from the leetcode test case that was failing. I could then print out the skip list state before and after the last operation that caused the testcase to fail and compare them with graphviz.\\n\\n\\nIn the end I got ~16ms on the first run, but was from the start using an arena memory allocation strategy and indexing into the arena in place of real pointers."
                    },
                    {
                        "username": "sockofleas2",
                        "content": "This question is terrible. Doesn\\'t explain how the skiplist works or how levels are added, just has a short gif from wikipedia."
                    },
                    {
                        "username": "XIZI_leetcode",
                        "content": "Especially the gif shows first adding the new element at the bottom level, then coin flip to decide if we need to add it to the upper level. It\\'s missleading."
                    },
                    {
                        "username": "itsgosho",
                        "content": "Actually there is really different ways to implement skip list and the idea is to practice them. No one will explain you in few lines how to implement it."
                    },
                    {
                        "username": "cpcs",
                        "content": "https://mp.weixin.qq.com/s?__biz=MzUzMDQxNTI4OQ==&mid=2247484374&idx=1&sn=5ca5df5659f1860847f55129b25465e1&chksm=fa536800cd24e11674dace66861f7411f7c7c0fddce5abee884555875acfa40efaed908913bc&token=1817182455&lang=zh_CN#rd"
                    },
                    {
                        "username": "sydneyos",
                        "content": "Does it mean no HashMaps or Lists?  Or just not built in libraries that already implement Skiplist functionality?"
                    },
                    {
                        "username": "CaptainPZ",
                        "content": "Got stuck there for quite a while. \\n\\nThe number 9 has been deleted already, why searching(9) still returns true from the given solution? \\n\\nLook at the question again, you might find the following sattement helpful.\\n\\n**Note that duplicates may exist in the Skiplist, your code needs to handle this situation.**\\n\\nIf 9 has been added into skiplist twice, it should be in the list twice as duplicated element which requires two deletions to get rid of.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I try to construct a BST to solve the problem, but TLE is encountered. I guess the time complexity for my erase function is low efficiency. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I have solved it, thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "There seems to be a bug in the malloc library. In the code snippet below, if I uncomment the free(q) line, I get a \"heap-use-after-free\" error even though q is clearly not reused (or, at least, is set to point to a different memory).\\nCan anybody help?\\n```\\n    while (n->right == NULL && n->down != NULL) {\\n        q = n;\\n        n = n->down;\\n//        free(q);\\n    }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not so much hard as tedious. There are a lot of pointers that need to cooperate with each other before this skip list will work but otherwise, this is pretty straight forward if you know how to handle linked lists.\n\nOne helpful hint is to have a dummy node at the beginning of each row with the value INT_MIN. This makes traversing between the rows much easier.\n\nA way to display the list is essential if you are to see that it is working correctly. This is the code I used:\n```\nvoid printList(Skiplist *s) {\n    Node *p, *n = s->head;\n    while(n != NULL) {\n        printf(\"|--- \");\n        p = n->right;\n        while(p != NULL) {\n            printf(\"%d --- \", p->val);\n            p = p->right;\n        }\n        printf(\"|\\n\");\n        n = n->down;\n    }\n    printf(\"\\n\");\n}\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1565266,
                "content": [
                    {
                        "username": "rcode0",
                        "content": "I\\'ve never ran into a skiplist before, and I had a few bugs, so this was one of the most time consuming problems for me to solve on LC.\\n\\n1. There\\'s a few short skiplist videos on youtube, but the first part of this one was the most helpful I could find: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2015/lecture-videos/lecture-7-randomization-skip-lists/\\n2. Start with a -infinity node, so you never have to insert on the left edge. I had a +infinity for symmetry.\\n3. Use a deterministic RNG with a constant seed, so you can have repeatable runs for debugging.\\n4. (Big help!) Spend the easy 20-40 lines it takes to output your skiplist to a graphviz .dot text format. It\\'s not hard, you can experiment here - http://www.webgraphviz.com/ - I labeled nodes with their values, edges with the level they were on, and dotted lines for backward edges and solid lines for forward edges . Trying to draw out the pointer relationships by hand was much slower and less helpful.\\n5. Running locally in an IDE, I had a snippet of code to autogenerate a local test from the leetcode test case that was failing. I could then print out the skip list state before and after the last operation that caused the testcase to fail and compare them with graphviz.\\n\\n\\nIn the end I got ~16ms on the first run, but was from the start using an arena memory allocation strategy and indexing into the arena in place of real pointers."
                    },
                    {
                        "username": "sockofleas2",
                        "content": "This question is terrible. Doesn\\'t explain how the skiplist works or how levels are added, just has a short gif from wikipedia."
                    },
                    {
                        "username": "XIZI_leetcode",
                        "content": "Especially the gif shows first adding the new element at the bottom level, then coin flip to decide if we need to add it to the upper level. It\\'s missleading."
                    },
                    {
                        "username": "itsgosho",
                        "content": "Actually there is really different ways to implement skip list and the idea is to practice them. No one will explain you in few lines how to implement it."
                    },
                    {
                        "username": "cpcs",
                        "content": "https://mp.weixin.qq.com/s?__biz=MzUzMDQxNTI4OQ==&mid=2247484374&idx=1&sn=5ca5df5659f1860847f55129b25465e1&chksm=fa536800cd24e11674dace66861f7411f7c7c0fddce5abee884555875acfa40efaed908913bc&token=1817182455&lang=zh_CN#rd"
                    },
                    {
                        "username": "sydneyos",
                        "content": "Does it mean no HashMaps or Lists?  Or just not built in libraries that already implement Skiplist functionality?"
                    },
                    {
                        "username": "CaptainPZ",
                        "content": "Got stuck there for quite a while. \\n\\nThe number 9 has been deleted already, why searching(9) still returns true from the given solution? \\n\\nLook at the question again, you might find the following sattement helpful.\\n\\n**Note that duplicates may exist in the Skiplist, your code needs to handle this situation.**\\n\\nIf 9 has been added into skiplist twice, it should be in the list twice as duplicated element which requires two deletions to get rid of.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I try to construct a BST to solve the problem, but TLE is encountered. I guess the time complexity for my erase function is low efficiency. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I have solved it, thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "There seems to be a bug in the malloc library. In the code snippet below, if I uncomment the free(q) line, I get a \"heap-use-after-free\" error even though q is clearly not reused (or, at least, is set to point to a different memory).\\nCan anybody help?\\n```\\n    while (n->right == NULL && n->down != NULL) {\\n        q = n;\\n        n = n->down;\\n//        free(q);\\n    }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not so much hard as tedious. There are a lot of pointers that need to cooperate with each other before this skip list will work but otherwise, this is pretty straight forward if you know how to handle linked lists.\n\nOne helpful hint is to have a dummy node at the beginning of each row with the value INT_MIN. This makes traversing between the rows much easier.\n\nA way to display the list is essential if you are to see that it is working correctly. This is the code I used:\n```\nvoid printList(Skiplist *s) {\n    Node *p, *n = s->head;\n    while(n != NULL) {\n        printf(\"|--- \");\n        p = n->right;\n        while(p != NULL) {\n            printf(\"%d --- \", p->val);\n            p = p->right;\n        }\n        printf(\"|\\n\");\n        n = n->down;\n    }\n    printf(\"\\n\");\n}\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1857581,
                "content": [
                    {
                        "username": "rcode0",
                        "content": "I\\'ve never ran into a skiplist before, and I had a few bugs, so this was one of the most time consuming problems for me to solve on LC.\\n\\n1. There\\'s a few short skiplist videos on youtube, but the first part of this one was the most helpful I could find: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2015/lecture-videos/lecture-7-randomization-skip-lists/\\n2. Start with a -infinity node, so you never have to insert on the left edge. I had a +infinity for symmetry.\\n3. Use a deterministic RNG with a constant seed, so you can have repeatable runs for debugging.\\n4. (Big help!) Spend the easy 20-40 lines it takes to output your skiplist to a graphviz .dot text format. It\\'s not hard, you can experiment here - http://www.webgraphviz.com/ - I labeled nodes with their values, edges with the level they were on, and dotted lines for backward edges and solid lines for forward edges . Trying to draw out the pointer relationships by hand was much slower and less helpful.\\n5. Running locally in an IDE, I had a snippet of code to autogenerate a local test from the leetcode test case that was failing. I could then print out the skip list state before and after the last operation that caused the testcase to fail and compare them with graphviz.\\n\\n\\nIn the end I got ~16ms on the first run, but was from the start using an arena memory allocation strategy and indexing into the arena in place of real pointers."
                    },
                    {
                        "username": "sockofleas2",
                        "content": "This question is terrible. Doesn\\'t explain how the skiplist works or how levels are added, just has a short gif from wikipedia."
                    },
                    {
                        "username": "XIZI_leetcode",
                        "content": "Especially the gif shows first adding the new element at the bottom level, then coin flip to decide if we need to add it to the upper level. It\\'s missleading."
                    },
                    {
                        "username": "itsgosho",
                        "content": "Actually there is really different ways to implement skip list and the idea is to practice them. No one will explain you in few lines how to implement it."
                    },
                    {
                        "username": "cpcs",
                        "content": "https://mp.weixin.qq.com/s?__biz=MzUzMDQxNTI4OQ==&mid=2247484374&idx=1&sn=5ca5df5659f1860847f55129b25465e1&chksm=fa536800cd24e11674dace66861f7411f7c7c0fddce5abee884555875acfa40efaed908913bc&token=1817182455&lang=zh_CN#rd"
                    },
                    {
                        "username": "sydneyos",
                        "content": "Does it mean no HashMaps or Lists?  Or just not built in libraries that already implement Skiplist functionality?"
                    },
                    {
                        "username": "CaptainPZ",
                        "content": "Got stuck there for quite a while. \\n\\nThe number 9 has been deleted already, why searching(9) still returns true from the given solution? \\n\\nLook at the question again, you might find the following sattement helpful.\\n\\n**Note that duplicates may exist in the Skiplist, your code needs to handle this situation.**\\n\\nIf 9 has been added into skiplist twice, it should be in the list twice as duplicated element which requires two deletions to get rid of.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I try to construct a BST to solve the problem, but TLE is encountered. I guess the time complexity for my erase function is low efficiency. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I have solved it, thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "There seems to be a bug in the malloc library. In the code snippet below, if I uncomment the free(q) line, I get a \"heap-use-after-free\" error even though q is clearly not reused (or, at least, is set to point to a different memory).\\nCan anybody help?\\n```\\n    while (n->right == NULL && n->down != NULL) {\\n        q = n;\\n        n = n->down;\\n//        free(q);\\n    }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not so much hard as tedious. There are a lot of pointers that need to cooperate with each other before this skip list will work but otherwise, this is pretty straight forward if you know how to handle linked lists.\n\nOne helpful hint is to have a dummy node at the beginning of each row with the value INT_MIN. This makes traversing between the rows much easier.\n\nA way to display the list is essential if you are to see that it is working correctly. This is the code I used:\n```\nvoid printList(Skiplist *s) {\n    Node *p, *n = s->head;\n    while(n != NULL) {\n        printf(\"|--- \");\n        p = n->right;\n        while(p != NULL) {\n            printf(\"%d --- \", p->val);\n            p = p->right;\n        }\n        printf(\"|\\n\");\n        n = n->down;\n    }\n    printf(\"\\n\");\n}\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1569727,
                "content": [
                    {
                        "username": "rcode0",
                        "content": "I\\'ve never ran into a skiplist before, and I had a few bugs, so this was one of the most time consuming problems for me to solve on LC.\\n\\n1. There\\'s a few short skiplist videos on youtube, but the first part of this one was the most helpful I could find: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2015/lecture-videos/lecture-7-randomization-skip-lists/\\n2. Start with a -infinity node, so you never have to insert on the left edge. I had a +infinity for symmetry.\\n3. Use a deterministic RNG with a constant seed, so you can have repeatable runs for debugging.\\n4. (Big help!) Spend the easy 20-40 lines it takes to output your skiplist to a graphviz .dot text format. It\\'s not hard, you can experiment here - http://www.webgraphviz.com/ - I labeled nodes with their values, edges with the level they were on, and dotted lines for backward edges and solid lines for forward edges . Trying to draw out the pointer relationships by hand was much slower and less helpful.\\n5. Running locally in an IDE, I had a snippet of code to autogenerate a local test from the leetcode test case that was failing. I could then print out the skip list state before and after the last operation that caused the testcase to fail and compare them with graphviz.\\n\\n\\nIn the end I got ~16ms on the first run, but was from the start using an arena memory allocation strategy and indexing into the arena in place of real pointers."
                    },
                    {
                        "username": "sockofleas2",
                        "content": "This question is terrible. Doesn\\'t explain how the skiplist works or how levels are added, just has a short gif from wikipedia."
                    },
                    {
                        "username": "XIZI_leetcode",
                        "content": "Especially the gif shows first adding the new element at the bottom level, then coin flip to decide if we need to add it to the upper level. It\\'s missleading."
                    },
                    {
                        "username": "itsgosho",
                        "content": "Actually there is really different ways to implement skip list and the idea is to practice them. No one will explain you in few lines how to implement it."
                    },
                    {
                        "username": "cpcs",
                        "content": "https://mp.weixin.qq.com/s?__biz=MzUzMDQxNTI4OQ==&mid=2247484374&idx=1&sn=5ca5df5659f1860847f55129b25465e1&chksm=fa536800cd24e11674dace66861f7411f7c7c0fddce5abee884555875acfa40efaed908913bc&token=1817182455&lang=zh_CN#rd"
                    },
                    {
                        "username": "sydneyos",
                        "content": "Does it mean no HashMaps or Lists?  Or just not built in libraries that already implement Skiplist functionality?"
                    },
                    {
                        "username": "CaptainPZ",
                        "content": "Got stuck there for quite a while. \\n\\nThe number 9 has been deleted already, why searching(9) still returns true from the given solution? \\n\\nLook at the question again, you might find the following sattement helpful.\\n\\n**Note that duplicates may exist in the Skiplist, your code needs to handle this situation.**\\n\\nIf 9 has been added into skiplist twice, it should be in the list twice as duplicated element which requires two deletions to get rid of.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I try to construct a BST to solve the problem, but TLE is encountered. I guess the time complexity for my erase function is low efficiency. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I have solved it, thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "There seems to be a bug in the malloc library. In the code snippet below, if I uncomment the free(q) line, I get a \"heap-use-after-free\" error even though q is clearly not reused (or, at least, is set to point to a different memory).\\nCan anybody help?\\n```\\n    while (n->right == NULL && n->down != NULL) {\\n        q = n;\\n        n = n->down;\\n//        free(q);\\n    }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not so much hard as tedious. There are a lot of pointers that need to cooperate with each other before this skip list will work but otherwise, this is pretty straight forward if you know how to handle linked lists.\n\nOne helpful hint is to have a dummy node at the beginning of each row with the value INT_MIN. This makes traversing between the rows much easier.\n\nA way to display the list is essential if you are to see that it is working correctly. This is the code I used:\n```\nvoid printList(Skiplist *s) {\n    Node *p, *n = s->head;\n    while(n != NULL) {\n        printf(\"|--- \");\n        p = n->right;\n        while(p != NULL) {\n            printf(\"%d --- \", p->val);\n            p = p->right;\n        }\n        printf(\"|\\n\");\n        n = n->down;\n    }\n    printf(\"\\n\");\n}\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1576506,
                "content": [
                    {
                        "username": "rcode0",
                        "content": "I\\'ve never ran into a skiplist before, and I had a few bugs, so this was one of the most time consuming problems for me to solve on LC.\\n\\n1. There\\'s a few short skiplist videos on youtube, but the first part of this one was the most helpful I could find: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2015/lecture-videos/lecture-7-randomization-skip-lists/\\n2. Start with a -infinity node, so you never have to insert on the left edge. I had a +infinity for symmetry.\\n3. Use a deterministic RNG with a constant seed, so you can have repeatable runs for debugging.\\n4. (Big help!) Spend the easy 20-40 lines it takes to output your skiplist to a graphviz .dot text format. It\\'s not hard, you can experiment here - http://www.webgraphviz.com/ - I labeled nodes with their values, edges with the level they were on, and dotted lines for backward edges and solid lines for forward edges . Trying to draw out the pointer relationships by hand was much slower and less helpful.\\n5. Running locally in an IDE, I had a snippet of code to autogenerate a local test from the leetcode test case that was failing. I could then print out the skip list state before and after the last operation that caused the testcase to fail and compare them with graphviz.\\n\\n\\nIn the end I got ~16ms on the first run, but was from the start using an arena memory allocation strategy and indexing into the arena in place of real pointers."
                    },
                    {
                        "username": "sockofleas2",
                        "content": "This question is terrible. Doesn\\'t explain how the skiplist works or how levels are added, just has a short gif from wikipedia."
                    },
                    {
                        "username": "XIZI_leetcode",
                        "content": "Especially the gif shows first adding the new element at the bottom level, then coin flip to decide if we need to add it to the upper level. It\\'s missleading."
                    },
                    {
                        "username": "itsgosho",
                        "content": "Actually there is really different ways to implement skip list and the idea is to practice them. No one will explain you in few lines how to implement it."
                    },
                    {
                        "username": "cpcs",
                        "content": "https://mp.weixin.qq.com/s?__biz=MzUzMDQxNTI4OQ==&mid=2247484374&idx=1&sn=5ca5df5659f1860847f55129b25465e1&chksm=fa536800cd24e11674dace66861f7411f7c7c0fddce5abee884555875acfa40efaed908913bc&token=1817182455&lang=zh_CN#rd"
                    },
                    {
                        "username": "sydneyos",
                        "content": "Does it mean no HashMaps or Lists?  Or just not built in libraries that already implement Skiplist functionality?"
                    },
                    {
                        "username": "CaptainPZ",
                        "content": "Got stuck there for quite a while. \\n\\nThe number 9 has been deleted already, why searching(9) still returns true from the given solution? \\n\\nLook at the question again, you might find the following sattement helpful.\\n\\n**Note that duplicates may exist in the Skiplist, your code needs to handle this situation.**\\n\\nIf 9 has been added into skiplist twice, it should be in the list twice as duplicated element which requires two deletions to get rid of.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I try to construct a BST to solve the problem, but TLE is encountered. I guess the time complexity for my erase function is low efficiency. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I have solved it, thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "There seems to be a bug in the malloc library. In the code snippet below, if I uncomment the free(q) line, I get a \"heap-use-after-free\" error even though q is clearly not reused (or, at least, is set to point to a different memory).\\nCan anybody help?\\n```\\n    while (n->right == NULL && n->down != NULL) {\\n        q = n;\\n        n = n->down;\\n//        free(q);\\n    }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not so much hard as tedious. There are a lot of pointers that need to cooperate with each other before this skip list will work but otherwise, this is pretty straight forward if you know how to handle linked lists.\n\nOne helpful hint is to have a dummy node at the beginning of each row with the value INT_MIN. This makes traversing between the rows much easier.\n\nA way to display the list is essential if you are to see that it is working correctly. This is the code I used:\n```\nvoid printList(Skiplist *s) {\n    Node *p, *n = s->head;\n    while(n != NULL) {\n        printf(\"|--- \");\n        p = n->right;\n        while(p != NULL) {\n            printf(\"%d --- \", p->val);\n            p = p->right;\n        }\n        printf(\"|\\n\");\n        n = n->down;\n    }\n    printf(\"\\n\");\n}\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1570197,
                "content": [
                    {
                        "username": "rcode0",
                        "content": "I\\'ve never ran into a skiplist before, and I had a few bugs, so this was one of the most time consuming problems for me to solve on LC.\\n\\n1. There\\'s a few short skiplist videos on youtube, but the first part of this one was the most helpful I could find: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2015/lecture-videos/lecture-7-randomization-skip-lists/\\n2. Start with a -infinity node, so you never have to insert on the left edge. I had a +infinity for symmetry.\\n3. Use a deterministic RNG with a constant seed, so you can have repeatable runs for debugging.\\n4. (Big help!) Spend the easy 20-40 lines it takes to output your skiplist to a graphviz .dot text format. It\\'s not hard, you can experiment here - http://www.webgraphviz.com/ - I labeled nodes with their values, edges with the level they were on, and dotted lines for backward edges and solid lines for forward edges . Trying to draw out the pointer relationships by hand was much slower and less helpful.\\n5. Running locally in an IDE, I had a snippet of code to autogenerate a local test from the leetcode test case that was failing. I could then print out the skip list state before and after the last operation that caused the testcase to fail and compare them with graphviz.\\n\\n\\nIn the end I got ~16ms on the first run, but was from the start using an arena memory allocation strategy and indexing into the arena in place of real pointers."
                    },
                    {
                        "username": "sockofleas2",
                        "content": "This question is terrible. Doesn\\'t explain how the skiplist works or how levels are added, just has a short gif from wikipedia."
                    },
                    {
                        "username": "XIZI_leetcode",
                        "content": "Especially the gif shows first adding the new element at the bottom level, then coin flip to decide if we need to add it to the upper level. It\\'s missleading."
                    },
                    {
                        "username": "itsgosho",
                        "content": "Actually there is really different ways to implement skip list and the idea is to practice them. No one will explain you in few lines how to implement it."
                    },
                    {
                        "username": "cpcs",
                        "content": "https://mp.weixin.qq.com/s?__biz=MzUzMDQxNTI4OQ==&mid=2247484374&idx=1&sn=5ca5df5659f1860847f55129b25465e1&chksm=fa536800cd24e11674dace66861f7411f7c7c0fddce5abee884555875acfa40efaed908913bc&token=1817182455&lang=zh_CN#rd"
                    },
                    {
                        "username": "sydneyos",
                        "content": "Does it mean no HashMaps or Lists?  Or just not built in libraries that already implement Skiplist functionality?"
                    },
                    {
                        "username": "CaptainPZ",
                        "content": "Got stuck there for quite a while. \\n\\nThe number 9 has been deleted already, why searching(9) still returns true from the given solution? \\n\\nLook at the question again, you might find the following sattement helpful.\\n\\n**Note that duplicates may exist in the Skiplist, your code needs to handle this situation.**\\n\\nIf 9 has been added into skiplist twice, it should be in the list twice as duplicated element which requires two deletions to get rid of.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I try to construct a BST to solve the problem, but TLE is encountered. I guess the time complexity for my erase function is low efficiency. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I have solved it, thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "There seems to be a bug in the malloc library. In the code snippet below, if I uncomment the free(q) line, I get a \"heap-use-after-free\" error even though q is clearly not reused (or, at least, is set to point to a different memory).\\nCan anybody help?\\n```\\n    while (n->right == NULL && n->down != NULL) {\\n        q = n;\\n        n = n->down;\\n//        free(q);\\n    }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not so much hard as tedious. There are a lot of pointers that need to cooperate with each other before this skip list will work but otherwise, this is pretty straight forward if you know how to handle linked lists.\n\nOne helpful hint is to have a dummy node at the beginning of each row with the value INT_MIN. This makes traversing between the rows much easier.\n\nA way to display the list is essential if you are to see that it is working correctly. This is the code I used:\n```\nvoid printList(Skiplist *s) {\n    Node *p, *n = s->head;\n    while(n != NULL) {\n        printf(\"|--- \");\n        p = n->right;\n        while(p != NULL) {\n            printf(\"%d --- \", p->val);\n            p = p->right;\n        }\n        printf(\"|\\n\");\n        n = n->down;\n    }\n    printf(\"\\n\");\n}\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 2023447,
                "content": [
                    {
                        "username": "rcode0",
                        "content": "I\\'ve never ran into a skiplist before, and I had a few bugs, so this was one of the most time consuming problems for me to solve on LC.\\n\\n1. There\\'s a few short skiplist videos on youtube, but the first part of this one was the most helpful I could find: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2015/lecture-videos/lecture-7-randomization-skip-lists/\\n2. Start with a -infinity node, so you never have to insert on the left edge. I had a +infinity for symmetry.\\n3. Use a deterministic RNG with a constant seed, so you can have repeatable runs for debugging.\\n4. (Big help!) Spend the easy 20-40 lines it takes to output your skiplist to a graphviz .dot text format. It\\'s not hard, you can experiment here - http://www.webgraphviz.com/ - I labeled nodes with their values, edges with the level they were on, and dotted lines for backward edges and solid lines for forward edges . Trying to draw out the pointer relationships by hand was much slower and less helpful.\\n5. Running locally in an IDE, I had a snippet of code to autogenerate a local test from the leetcode test case that was failing. I could then print out the skip list state before and after the last operation that caused the testcase to fail and compare them with graphviz.\\n\\n\\nIn the end I got ~16ms on the first run, but was from the start using an arena memory allocation strategy and indexing into the arena in place of real pointers."
                    },
                    {
                        "username": "sockofleas2",
                        "content": "This question is terrible. Doesn\\'t explain how the skiplist works or how levels are added, just has a short gif from wikipedia."
                    },
                    {
                        "username": "XIZI_leetcode",
                        "content": "Especially the gif shows first adding the new element at the bottom level, then coin flip to decide if we need to add it to the upper level. It\\'s missleading."
                    },
                    {
                        "username": "itsgosho",
                        "content": "Actually there is really different ways to implement skip list and the idea is to practice them. No one will explain you in few lines how to implement it."
                    },
                    {
                        "username": "cpcs",
                        "content": "https://mp.weixin.qq.com/s?__biz=MzUzMDQxNTI4OQ==&mid=2247484374&idx=1&sn=5ca5df5659f1860847f55129b25465e1&chksm=fa536800cd24e11674dace66861f7411f7c7c0fddce5abee884555875acfa40efaed908913bc&token=1817182455&lang=zh_CN#rd"
                    },
                    {
                        "username": "sydneyos",
                        "content": "Does it mean no HashMaps or Lists?  Or just not built in libraries that already implement Skiplist functionality?"
                    },
                    {
                        "username": "CaptainPZ",
                        "content": "Got stuck there for quite a while. \\n\\nThe number 9 has been deleted already, why searching(9) still returns true from the given solution? \\n\\nLook at the question again, you might find the following sattement helpful.\\n\\n**Note that duplicates may exist in the Skiplist, your code needs to handle this situation.**\\n\\nIf 9 has been added into skiplist twice, it should be in the list twice as duplicated element which requires two deletions to get rid of.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I try to construct a BST to solve the problem, but TLE is encountered. I guess the time complexity for my erase function is low efficiency. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I have solved it, thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "There seems to be a bug in the malloc library. In the code snippet below, if I uncomment the free(q) line, I get a \"heap-use-after-free\" error even though q is clearly not reused (or, at least, is set to point to a different memory).\\nCan anybody help?\\n```\\n    while (n->right == NULL && n->down != NULL) {\\n        q = n;\\n        n = n->down;\\n//        free(q);\\n    }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not so much hard as tedious. There are a lot of pointers that need to cooperate with each other before this skip list will work but otherwise, this is pretty straight forward if you know how to handle linked lists.\n\nOne helpful hint is to have a dummy node at the beginning of each row with the value INT_MIN. This makes traversing between the rows much easier.\n\nA way to display the list is essential if you are to see that it is working correctly. This is the code I used:\n```\nvoid printList(Skiplist *s) {\n    Node *p, *n = s->head;\n    while(n != NULL) {\n        printf(\"|--- \");\n        p = n->right;\n        while(p != NULL) {\n            printf(\"%d --- \", p->val);\n            p = p->right;\n        }\n        printf(\"|\\n\");\n        n = n->down;\n    }\n    printf(\"\\n\");\n}\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1912946,
                "content": [
                    {
                        "username": "rcode0",
                        "content": "I\\'ve never ran into a skiplist before, and I had a few bugs, so this was one of the most time consuming problems for me to solve on LC.\\n\\n1. There\\'s a few short skiplist videos on youtube, but the first part of this one was the most helpful I could find: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2015/lecture-videos/lecture-7-randomization-skip-lists/\\n2. Start with a -infinity node, so you never have to insert on the left edge. I had a +infinity for symmetry.\\n3. Use a deterministic RNG with a constant seed, so you can have repeatable runs for debugging.\\n4. (Big help!) Spend the easy 20-40 lines it takes to output your skiplist to a graphviz .dot text format. It\\'s not hard, you can experiment here - http://www.webgraphviz.com/ - I labeled nodes with their values, edges with the level they were on, and dotted lines for backward edges and solid lines for forward edges . Trying to draw out the pointer relationships by hand was much slower and less helpful.\\n5. Running locally in an IDE, I had a snippet of code to autogenerate a local test from the leetcode test case that was failing. I could then print out the skip list state before and after the last operation that caused the testcase to fail and compare them with graphviz.\\n\\n\\nIn the end I got ~16ms on the first run, but was from the start using an arena memory allocation strategy and indexing into the arena in place of real pointers."
                    },
                    {
                        "username": "sockofleas2",
                        "content": "This question is terrible. Doesn\\'t explain how the skiplist works or how levels are added, just has a short gif from wikipedia."
                    },
                    {
                        "username": "XIZI_leetcode",
                        "content": "Especially the gif shows first adding the new element at the bottom level, then coin flip to decide if we need to add it to the upper level. It\\'s missleading."
                    },
                    {
                        "username": "itsgosho",
                        "content": "Actually there is really different ways to implement skip list and the idea is to practice them. No one will explain you in few lines how to implement it."
                    },
                    {
                        "username": "cpcs",
                        "content": "https://mp.weixin.qq.com/s?__biz=MzUzMDQxNTI4OQ==&mid=2247484374&idx=1&sn=5ca5df5659f1860847f55129b25465e1&chksm=fa536800cd24e11674dace66861f7411f7c7c0fddce5abee884555875acfa40efaed908913bc&token=1817182455&lang=zh_CN#rd"
                    },
                    {
                        "username": "sydneyos",
                        "content": "Does it mean no HashMaps or Lists?  Or just not built in libraries that already implement Skiplist functionality?"
                    },
                    {
                        "username": "CaptainPZ",
                        "content": "Got stuck there for quite a while. \\n\\nThe number 9 has been deleted already, why searching(9) still returns true from the given solution? \\n\\nLook at the question again, you might find the following sattement helpful.\\n\\n**Note that duplicates may exist in the Skiplist, your code needs to handle this situation.**\\n\\nIf 9 has been added into skiplist twice, it should be in the list twice as duplicated element which requires two deletions to get rid of.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I try to construct a BST to solve the problem, but TLE is encountered. I guess the time complexity for my erase function is low efficiency. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I have solved it, thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "There seems to be a bug in the malloc library. In the code snippet below, if I uncomment the free(q) line, I get a \"heap-use-after-free\" error even though q is clearly not reused (or, at least, is set to point to a different memory).\\nCan anybody help?\\n```\\n    while (n->right == NULL && n->down != NULL) {\\n        q = n;\\n        n = n->down;\\n//        free(q);\\n    }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not so much hard as tedious. There are a lot of pointers that need to cooperate with each other before this skip list will work but otherwise, this is pretty straight forward if you know how to handle linked lists.\n\nOne helpful hint is to have a dummy node at the beginning of each row with the value INT_MIN. This makes traversing between the rows much easier.\n\nA way to display the list is essential if you are to see that it is working correctly. This is the code I used:\n```\nvoid printList(Skiplist *s) {\n    Node *p, *n = s->head;\n    while(n != NULL) {\n        printf(\"|--- \");\n        p = n->right;\n        while(p != NULL) {\n            printf(\"%d --- \", p->val);\n            p = p->right;\n        }\n        printf(\"|\\n\");\n        n = n->down;\n    }\n    printf(\"\\n\");\n}\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1912278,
                "content": [
                    {
                        "username": "rcode0",
                        "content": "I\\'ve never ran into a skiplist before, and I had a few bugs, so this was one of the most time consuming problems for me to solve on LC.\\n\\n1. There\\'s a few short skiplist videos on youtube, but the first part of this one was the most helpful I could find: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2015/lecture-videos/lecture-7-randomization-skip-lists/\\n2. Start with a -infinity node, so you never have to insert on the left edge. I had a +infinity for symmetry.\\n3. Use a deterministic RNG with a constant seed, so you can have repeatable runs for debugging.\\n4. (Big help!) Spend the easy 20-40 lines it takes to output your skiplist to a graphviz .dot text format. It\\'s not hard, you can experiment here - http://www.webgraphviz.com/ - I labeled nodes with their values, edges with the level they were on, and dotted lines for backward edges and solid lines for forward edges . Trying to draw out the pointer relationships by hand was much slower and less helpful.\\n5. Running locally in an IDE, I had a snippet of code to autogenerate a local test from the leetcode test case that was failing. I could then print out the skip list state before and after the last operation that caused the testcase to fail and compare them with graphviz.\\n\\n\\nIn the end I got ~16ms on the first run, but was from the start using an arena memory allocation strategy and indexing into the arena in place of real pointers."
                    },
                    {
                        "username": "sockofleas2",
                        "content": "This question is terrible. Doesn\\'t explain how the skiplist works or how levels are added, just has a short gif from wikipedia."
                    },
                    {
                        "username": "XIZI_leetcode",
                        "content": "Especially the gif shows first adding the new element at the bottom level, then coin flip to decide if we need to add it to the upper level. It\\'s missleading."
                    },
                    {
                        "username": "itsgosho",
                        "content": "Actually there is really different ways to implement skip list and the idea is to practice them. No one will explain you in few lines how to implement it."
                    },
                    {
                        "username": "cpcs",
                        "content": "https://mp.weixin.qq.com/s?__biz=MzUzMDQxNTI4OQ==&mid=2247484374&idx=1&sn=5ca5df5659f1860847f55129b25465e1&chksm=fa536800cd24e11674dace66861f7411f7c7c0fddce5abee884555875acfa40efaed908913bc&token=1817182455&lang=zh_CN#rd"
                    },
                    {
                        "username": "sydneyos",
                        "content": "Does it mean no HashMaps or Lists?  Or just not built in libraries that already implement Skiplist functionality?"
                    },
                    {
                        "username": "CaptainPZ",
                        "content": "Got stuck there for quite a while. \\n\\nThe number 9 has been deleted already, why searching(9) still returns true from the given solution? \\n\\nLook at the question again, you might find the following sattement helpful.\\n\\n**Note that duplicates may exist in the Skiplist, your code needs to handle this situation.**\\n\\nIf 9 has been added into skiplist twice, it should be in the list twice as duplicated element which requires two deletions to get rid of.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I try to construct a BST to solve the problem, but TLE is encountered. I guess the time complexity for my erase function is low efficiency. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I have solved it, thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "There seems to be a bug in the malloc library. In the code snippet below, if I uncomment the free(q) line, I get a \"heap-use-after-free\" error even though q is clearly not reused (or, at least, is set to point to a different memory).\\nCan anybody help?\\n```\\n    while (n->right == NULL && n->down != NULL) {\\n        q = n;\\n        n = n->down;\\n//        free(q);\\n    }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not so much hard as tedious. There are a lot of pointers that need to cooperate with each other before this skip list will work but otherwise, this is pretty straight forward if you know how to handle linked lists.\n\nOne helpful hint is to have a dummy node at the beginning of each row with the value INT_MIN. This makes traversing between the rows much easier.\n\nA way to display the list is essential if you are to see that it is working correctly. This is the code I used:\n```\nvoid printList(Skiplist *s) {\n    Node *p, *n = s->head;\n    while(n != NULL) {\n        printf(\"|--- \");\n        p = n->right;\n        while(p != NULL) {\n            printf(\"%d --- \", p->val);\n            p = p->right;\n        }\n        printf(\"|\\n\");\n        n = n->down;\n    }\n    printf(\"\\n\");\n}\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1763814,
                "content": [
                    {
                        "username": "rcode0",
                        "content": "I\\'ve never ran into a skiplist before, and I had a few bugs, so this was one of the most time consuming problems for me to solve on LC.\\n\\n1. There\\'s a few short skiplist videos on youtube, but the first part of this one was the most helpful I could find: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2015/lecture-videos/lecture-7-randomization-skip-lists/\\n2. Start with a -infinity node, so you never have to insert on the left edge. I had a +infinity for symmetry.\\n3. Use a deterministic RNG with a constant seed, so you can have repeatable runs for debugging.\\n4. (Big help!) Spend the easy 20-40 lines it takes to output your skiplist to a graphviz .dot text format. It\\'s not hard, you can experiment here - http://www.webgraphviz.com/ - I labeled nodes with their values, edges with the level they were on, and dotted lines for backward edges and solid lines for forward edges . Trying to draw out the pointer relationships by hand was much slower and less helpful.\\n5. Running locally in an IDE, I had a snippet of code to autogenerate a local test from the leetcode test case that was failing. I could then print out the skip list state before and after the last operation that caused the testcase to fail and compare them with graphviz.\\n\\n\\nIn the end I got ~16ms on the first run, but was from the start using an arena memory allocation strategy and indexing into the arena in place of real pointers."
                    },
                    {
                        "username": "sockofleas2",
                        "content": "This question is terrible. Doesn\\'t explain how the skiplist works or how levels are added, just has a short gif from wikipedia."
                    },
                    {
                        "username": "XIZI_leetcode",
                        "content": "Especially the gif shows first adding the new element at the bottom level, then coin flip to decide if we need to add it to the upper level. It\\'s missleading."
                    },
                    {
                        "username": "itsgosho",
                        "content": "Actually there is really different ways to implement skip list and the idea is to practice them. No one will explain you in few lines how to implement it."
                    },
                    {
                        "username": "cpcs",
                        "content": "https://mp.weixin.qq.com/s?__biz=MzUzMDQxNTI4OQ==&mid=2247484374&idx=1&sn=5ca5df5659f1860847f55129b25465e1&chksm=fa536800cd24e11674dace66861f7411f7c7c0fddce5abee884555875acfa40efaed908913bc&token=1817182455&lang=zh_CN#rd"
                    },
                    {
                        "username": "sydneyos",
                        "content": "Does it mean no HashMaps or Lists?  Or just not built in libraries that already implement Skiplist functionality?"
                    },
                    {
                        "username": "CaptainPZ",
                        "content": "Got stuck there for quite a while. \\n\\nThe number 9 has been deleted already, why searching(9) still returns true from the given solution? \\n\\nLook at the question again, you might find the following sattement helpful.\\n\\n**Note that duplicates may exist in the Skiplist, your code needs to handle this situation.**\\n\\nIf 9 has been added into skiplist twice, it should be in the list twice as duplicated element which requires two deletions to get rid of.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I try to construct a BST to solve the problem, but TLE is encountered. I guess the time complexity for my erase function is low efficiency. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I have solved it, thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "There seems to be a bug in the malloc library. In the code snippet below, if I uncomment the free(q) line, I get a \"heap-use-after-free\" error even though q is clearly not reused (or, at least, is set to point to a different memory).\\nCan anybody help?\\n```\\n    while (n->right == NULL && n->down != NULL) {\\n        q = n;\\n        n = n->down;\\n//        free(q);\\n    }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not so much hard as tedious. There are a lot of pointers that need to cooperate with each other before this skip list will work but otherwise, this is pretty straight forward if you know how to handle linked lists.\n\nOne helpful hint is to have a dummy node at the beginning of each row with the value INT_MIN. This makes traversing between the rows much easier.\n\nA way to display the list is essential if you are to see that it is working correctly. This is the code I used:\n```\nvoid printList(Skiplist *s) {\n    Node *p, *n = s->head;\n    while(n != NULL) {\n        printf(\"|--- \");\n        p = n->right;\n        while(p != NULL) {\n            printf(\"%d --- \", p->val);\n            p = p->right;\n        }\n        printf(\"|\\n\");\n        n = n->down;\n    }\n    printf(\"\\n\");\n}\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1761887,
                "content": [
                    {
                        "username": "rcode0",
                        "content": "I\\'ve never ran into a skiplist before, and I had a few bugs, so this was one of the most time consuming problems for me to solve on LC.\\n\\n1. There\\'s a few short skiplist videos on youtube, but the first part of this one was the most helpful I could find: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2015/lecture-videos/lecture-7-randomization-skip-lists/\\n2. Start with a -infinity node, so you never have to insert on the left edge. I had a +infinity for symmetry.\\n3. Use a deterministic RNG with a constant seed, so you can have repeatable runs for debugging.\\n4. (Big help!) Spend the easy 20-40 lines it takes to output your skiplist to a graphviz .dot text format. It\\'s not hard, you can experiment here - http://www.webgraphviz.com/ - I labeled nodes with their values, edges with the level they were on, and dotted lines for backward edges and solid lines for forward edges . Trying to draw out the pointer relationships by hand was much slower and less helpful.\\n5. Running locally in an IDE, I had a snippet of code to autogenerate a local test from the leetcode test case that was failing. I could then print out the skip list state before and after the last operation that caused the testcase to fail and compare them with graphviz.\\n\\n\\nIn the end I got ~16ms on the first run, but was from the start using an arena memory allocation strategy and indexing into the arena in place of real pointers."
                    },
                    {
                        "username": "sockofleas2",
                        "content": "This question is terrible. Doesn\\'t explain how the skiplist works or how levels are added, just has a short gif from wikipedia."
                    },
                    {
                        "username": "XIZI_leetcode",
                        "content": "Especially the gif shows first adding the new element at the bottom level, then coin flip to decide if we need to add it to the upper level. It\\'s missleading."
                    },
                    {
                        "username": "itsgosho",
                        "content": "Actually there is really different ways to implement skip list and the idea is to practice them. No one will explain you in few lines how to implement it."
                    },
                    {
                        "username": "cpcs",
                        "content": "https://mp.weixin.qq.com/s?__biz=MzUzMDQxNTI4OQ==&mid=2247484374&idx=1&sn=5ca5df5659f1860847f55129b25465e1&chksm=fa536800cd24e11674dace66861f7411f7c7c0fddce5abee884555875acfa40efaed908913bc&token=1817182455&lang=zh_CN#rd"
                    },
                    {
                        "username": "sydneyos",
                        "content": "Does it mean no HashMaps or Lists?  Or just not built in libraries that already implement Skiplist functionality?"
                    },
                    {
                        "username": "CaptainPZ",
                        "content": "Got stuck there for quite a while. \\n\\nThe number 9 has been deleted already, why searching(9) still returns true from the given solution? \\n\\nLook at the question again, you might find the following sattement helpful.\\n\\n**Note that duplicates may exist in the Skiplist, your code needs to handle this situation.**\\n\\nIf 9 has been added into skiplist twice, it should be in the list twice as duplicated element which requires two deletions to get rid of.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I try to construct a BST to solve the problem, but TLE is encountered. I guess the time complexity for my erase function is low efficiency. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I have solved it, thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "There seems to be a bug in the malloc library. In the code snippet below, if I uncomment the free(q) line, I get a \"heap-use-after-free\" error even though q is clearly not reused (or, at least, is set to point to a different memory).\\nCan anybody help?\\n```\\n    while (n->right == NULL && n->down != NULL) {\\n        q = n;\\n        n = n->down;\\n//        free(q);\\n    }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not so much hard as tedious. There are a lot of pointers that need to cooperate with each other before this skip list will work but otherwise, this is pretty straight forward if you know how to handle linked lists.\n\nOne helpful hint is to have a dummy node at the beginning of each row with the value INT_MIN. This makes traversing between the rows much easier.\n\nA way to display the list is essential if you are to see that it is working correctly. This is the code I used:\n```\nvoid printList(Skiplist *s) {\n    Node *p, *n = s->head;\n    while(n != NULL) {\n        printf(\"|--- \");\n        p = n->right;\n        while(p != NULL) {\n            printf(\"%d --- \", p->val);\n            p = p->right;\n        }\n        printf(\"|\\n\");\n        n = n->down;\n    }\n    printf(\"\\n\");\n}\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            }
        ]
    }
]