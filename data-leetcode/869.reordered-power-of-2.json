[
    {
        "title": "Binary Gap",
        "question_content": "Given a positive integer n, find and return the longest distance between any two adjacent 1's in the binary representation of n. If there are no two adjacent 1's, return 0.\nTwo 1's are adjacent if there are only 0's separating them (possibly no 0's). The distance between two 1's is the absolute difference between their bit positions. For example, the two 1's in \"1001\" have a distance of 3.\n&nbsp;\nExample 1:\n\nInput: n = 22\nOutput: 2\nExplanation: 22 in binary is \"10110\".\nThe first adjacent pair of 1's is \"10110\" with a distance of 2.\nThe second adjacent pair of 1's is \"10110\" with a distance of 1.\nThe answer is the largest of these two distances, which is 2.\nNote that \"10110\" is not a valid pair since there is a 1 separating the two 1's underlined.\n\nExample 2:\n\nInput: n = 8\nOutput: 0\nExplanation: 8 in binary is \"1000\".\nThere are not any adjacent pairs of 1's in the binary representation of 8, so we return 0.\n\nExample 3:\n\nInput: n = 5\nOutput: 2\nExplanation: 5 in binary is \"101\".\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 109",
        "solutions": [
            {
                "id": 149835,
                "title": "c-java-python-dividing-by-2",
                "content": "One pass on `N` in binary from right to left.\\n`d` means the distance from the last 1 position.\\n`d` is initial to a small enough value `-32`\\n\\n**C++:**\\n```\\n    int binaryGap(int N) {\\n        int res = 0;\\n        for (int d = -32; N; N /= 2, d++)\\n            if (N % 2) res = max(res, d), d = 0;\\n        return res;\\n    }\\n```\\n\\n**Java:**\\n```\\n    public int binaryGap(int N) {\\n        int res = 0;\\n        for (int d = -32; N > 0; N /= 2, d++)\\n            if (N % 2 == 1) {\\n                res = Math.max(res, d);\\n                d = 0;\\n            }\\n        return res;\\n    }\\n```\\n**Python:**\\n```\\n    def binaryGap(self, N):\\n        index = [i for i, v in enumerate(bin(N)) if v == \\'1\\']\\n        return max([b - a for a, b in zip(index, index[1:])] or [0])\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    int binaryGap(int N) {\\n        int res = 0;\\n        for (int d = -32; N; N /= 2, d++)\\n            if (N % 2) res = max(res, d), d = 0;\\n        return res;\\n    }\\n```\n```\\n    public int binaryGap(int N) {\\n        int res = 0;\\n        for (int d = -32; N > 0; N /= 2, d++)\\n            if (N % 2 == 1) {\\n                res = Math.max(res, d);\\n                d = 0;\\n            }\\n        return res;\\n    }\\n```\n```\\n    def binaryGap(self, N):\\n        index = [i for i, v in enumerate(bin(N)) if v == \\'1\\']\\n        return max([b - a for a, b in zip(index, index[1:])] or [0])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 149945,
                "title": "simple-java-10-ms",
                "content": "```java\\nclass Solution {\\n    public int binaryGap(int N) {\\n        int max = 0;\\n        int pos = 0;\\n        int lastPos = -1;\\n        while (N != 0) {\\n            pos++;\\n            if ((N & 1) == 1) {\\n                if (lastPos != -1) {\\n                    max = Math.max(max, pos-lastPos);\\n                }\\n                lastPos = pos;\\n            }\\n            N >>= 1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int binaryGap(int N) {\\n        int max = 0;\\n        int pos = 0;\\n        int lastPos = -1;\\n        while (N != 0) {\\n            pos++;\\n            if ((N & 1) == 1) {\\n                if (lastPos != -1) {\\n                    max = Math.max(max, pos-lastPos);\\n                }\\n                lastPos = pos;\\n            }\\n            N >>= 1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149834,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, N):\\n        pre = dist = 0\\n        for i, c in enumerate(bin(N)[2:]):\\n            if c == \"1\":\\n                dist = max(dist, i - pre)\\n                pre = i\\n        return dist\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, N):\\n        pre = dist = 0\\n        for i, c in enumerate(bin(N)[2:]):\\n            if c == \"1\":\\n                dist = max(dist, i - pre)\\n                pre = i\\n        return dist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 358693,
                "title": "868-javascript-1-line-solution",
                "content": "> Runtime: **48 ms**, faster than *95.29%* of JavaScript online submissions\\n> Memory Usage: **33.9 MB**, less than *100.00%* of JavaScript online submissions\\n\\n```javascript\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nconst binaryGap = N =>\\n  Math.max(\\n    0,\\n    ...N.toString(2)\\n      .split(\\'1\\')\\n      .slice(1, -1)\\n      .map(gap => gap.length + 1),\\n  );\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nconst binaryGap = N =>\\n  Math.max(\\n    0,\\n    ...N.toString(2)\\n      .split(\\'1\\')\\n      .slice(1, -1)\\n      .map(gap => gap.length + 1),\\n  );\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 151143,
                "title": "python-1-line-solution",
                "content": "If only one \\'1\\' exists in the binary, the number must be 2^N where N is a natural number and we return 0. Otherwise, given the binary, we strip \\'0\\' from both sides and split the string into sections by \\'1\\', and return the max length of consecutive \\'0\\'s plus 1.\\n```\\nclass Solution:\\n    def binaryGap(self, N):\\n        return max(len(c) for c in bin(N)[2:].strip(\\'0\\').split(\\'1\\')) + 1 if N & (N-1) else 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, N):\\n        return max(len(c) for c in bin(N)[2:].strip(\\'0\\').split(\\'1\\')) + 1 if N & (N-1) else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1382476,
                "title": "c-0-ms-simple-o-32",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint binaryGap(int n) {\\n\\t\\tint lastone = 32;\\n\\t\\tint ans = 0;\\n\\t\\tfor (int i = 0; i < 32; i++) {\\n\\t\\t\\tif (n & (1 << i)) {\\n\\t\\t\\t\\tans = max(ans, i - lastone);\\n\\t\\t\\t\\tlastone = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint binaryGap(int n) {\\n\\t\\tint lastone = 32;\\n\\t\\tint ans = 0;\\n\\t\\tfor (int i = 0; i < 32; i++) {\\n\\t\\t\\tif (n & (1 << i)) {\\n\\t\\t\\t\\tans = max(ans, i - lastone);\\n\\t\\t\\t\\tlastone = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 613498,
                "title": "java-solution-100-with-explanation",
                "content": "The answer key to this problem uses bitwise from the start -- which is not where my mind immediately went; nor did my mind think to use linear space in the naive implementation (since we only care about space between consecutive 1\\'s). Hopefully this solution will help you think through the problem logically.\\n\\nThe first time I did the problem, I came up with a linear time solution that used linear space.\\n\\nRuntime: 1 ms, faster than 42.91% of Java online submissions for Binary Gap.\\nMemory Usage: 36 MB, less than 7.14% of Java online submissions for Binary Gap.\\n```java\\nclass Solution {\\n    public int binaryGap(int N) {\\n        String binaryRepresentation = Integer.toBinaryString(N); // O(n) space\\n        int longestDistance = 0;\\n        int indexOne = binaryRepresentation.indexOf(\\'1\\');\\n        for (int i = 1; i < binaryRepresentation.length(); ++i) { // O(n) time\\n            if (binaryRepresentation.charAt(i) == \\'1\\') {\\n                longestDistance = Math.max(longestDistance, i - indexOne); // greedy\\n                indexOne = i; // update the index of the most recently seen \\'1\\'\\n            }\\n        }\\n        \\n        return longestDistance;\\n    }\\n}\\n```\\n\\nI then realized this can be done faster since numbers are already stored as their binary representations. We can use bitwise operators, specifically, the bitwise right shift operator. All this means is take the rightmost bit off the binary representation during each iteration. This results in a solution with logarithmic time and constant space.\\n\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Binary Gap.\\nMemory Usage: 36.1 MB, less than 7.14% of Java online submissions for Binary Gap.\\n\\n```java\\nclass Solution {\\n    public int binaryGap(int N) {\\n        int indexOne = -1, longestDistance = 0;\\n        for (int i = 0; i < 32; ++i) { // 32 bit number so 32 iterations, could also use Integer.toBinaryString(N).length() but the time it takes to convert to binary string is longer than just doing extra iterations for numbers smaller than 32 bits in size\\n            if (((N >> i) & 1) == 1) { // take the right most bit, use the bitwise \\'AND\\' operator, if result is 1 then bit was a 1\\n                if (indexOne != -1) // only the first 1 will not trigger this conditional\\n                    longestDistance = Math.max(longestDistance, i - indexOne); // greedy\\n                indexOne = i; // update the index of the most recently seen \\'1\\'\\n            }\\n        }\\n\\n        return longestDistance;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```java\\nclass Solution {\\n    public int binaryGap(int N) {\\n        String binaryRepresentation = Integer.toBinaryString(N); // O(n) space\\n        int longestDistance = 0;\\n        int indexOne = binaryRepresentation.indexOf(\\'1\\');\\n        for (int i = 1; i < binaryRepresentation.length(); ++i) { // O(n) time\\n            if (binaryRepresentation.charAt(i) == \\'1\\') {\\n                longestDistance = Math.max(longestDistance, i - indexOne); // greedy\\n                indexOne = i; // update the index of the most recently seen \\'1\\'\\n            }\\n        }\\n        \\n        return longestDistance;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int binaryGap(int N) {\\n        int indexOne = -1, longestDistance = 0;\\n        for (int i = 0; i < 32; ++i) { // 32 bit number so 32 iterations, could also use Integer.toBinaryString(N).length() but the time it takes to convert to binary string is longer than just doing extra iterations for numbers smaller than 32 bits in size\\n            if (((N >> i) & 1) == 1) { // take the right most bit, use the bitwise \\'AND\\' operator, if result is 1 then bit was a 1\\n                if (indexOne != -1) // only the first 1 will not trigger this conditional\\n                    longestDistance = Math.max(longestDistance, i - indexOne); // greedy\\n                indexOne = i; // update the index of the most recently seen \\'1\\'\\n            }\\n        }\\n\\n        return longestDistance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519571,
                "title": "simple-python-solution-o-log-n-t-o-log-n-s-explanation",
                "content": "We first convert the number to binary and then find the 1\\'s in the binary representation. We store the location of adjacent 1\\'s in the variables i and j. The maximum difference between these successive 1\\'s is the answer. \\nA number \\'n\\' has (log n) bits, hence the time complexity is log(n) and since we are storing these bits as a string, the space complexity is also log(n).\\n\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        bi = bin(n)[2:]\\n        maxi = 0\\n        i = 0\\n        j = 0\\n        \\n        for x in range(1, len(bi)):\\n            if bi[x] == \\'1\\':\\n                i = j\\n                j = x\\n                maxi = max(maxi, j - i)\\n                \\n        return maxi\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        bi = bin(n)[2:]\\n        maxi = 0\\n        i = 0\\n        j = 0\\n        \\n        for x in range(1, len(bi)):\\n            if bi[x] == \\'1\\':\\n                i = j\\n                j = x\\n                maxi = max(maxi, j - i)\\n                \\n        return maxi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 380567,
                "title": "easy-c-solution-0ms-bit-manipulation",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Gap.\\nMemory Usage: 8.2 MB, less than 100.00% of C++ online submissions for Binary Gap.\\n\\n```\\nint binaryGap(int N) {\\n        \\n        int maxGap = 0;\\n        int i = 1;\\n        int last = -1;\\n        \\n        while(N > 0)\\n        {\\n            int bit = N%2;\\n            if(bit == 1)\\n            {\\n                if(last >= 0)\\n                    maxGap = max(maxGap, i - last);\\n                last = i;\\n            }\\n            \\n            i++;\\n            N /= 2;\\n        }\\n        \\n        return maxGap;\\n    }\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint binaryGap(int N) {\\n        \\n        int maxGap = 0;\\n        int i = 1;\\n        int last = -1;\\n        \\n        while(N > 0)\\n        {\\n            int bit = N%2;\\n            if(bit == 1)\\n            {\\n                if(last >= 0)\\n                    maxGap = max(maxGap, i - last);\\n                last = i;\\n            }\\n            \\n            i++;\\n            N /= 2;\\n        }\\n        \\n        return maxGap;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1321031,
                "title": "intuitive-java-solution-with-explanation",
                "content": "We will first convert `n` into a character array which represents the binary string of `n`. We will then iterate over this array and store the indices of where a 1 occurs in this character array. If there was only one 1 in the binary string representation of `n` then we return 0 as the problem statement says. We then iterate over `indices` and calculate the distance of a 1 with its adjacent neighbor and update `ans` accordingly.\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        char[] bits = Integer.toBinaryString(n).toCharArray();\\n        List<Integer> indices = new ArrayList<>();\\n        for (int i = 0; i < bits.length; i++) {\\n            if (bits[i] == \\'1\\') indices.add(i);\\n        }\\n        if (indices.size() == 1) return 0;\\n        int ans = 0;\\n        for (int i = 0; i < indices.size()-1; i++) {\\n            ans = Math.max(ans, indices.get(i+1)-indices.get(i));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        char[] bits = Integer.toBinaryString(n).toCharArray();\\n        List<Integer> indices = new ArrayList<>();\\n        for (int i = 0; i < bits.length; i++) {\\n            if (bits[i] == \\'1\\') indices.add(i);\\n        }\\n        if (indices.size() == 1) return 0;\\n        int ans = 0;\\n        for (int i = 0; i < indices.size()-1; i++) {\\n            ans = Math.max(ans, indices.get(i+1)-indices.get(i));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481624,
                "title": "easy-solution-finding-the-total-number-of-set-bits",
                "content": "\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint binaryGap(int n) {\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tvector<int> aux;\\n\\t\\t\\twhile(n!=0){\\n\\t\\t\\t\\tif((n & 1) == 1)\\n\\t\\t\\t\\t\\taux.push_back(i);\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tn = n>>1;\\n\\t\\t\\t}\\n\\t\\t\\tif(aux.size()==1)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\tint m = INT_MIN;\\n\\t\\t\\tfor(int x=1;x<aux.size();x++){\\n\\t\\t\\t\\tm = max(m,(aux[x]-aux[x-1]));\\n        }\\n\\t\\t\\treturn m;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint binaryGap(int n) {\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tvector<int> aux;\\n\\t\\t\\twhile(n!=0){\\n\\t\\t\\t\\tif((n & 1) == 1)\\n\\t\\t\\t\\t\\taux.push_back(i);\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tn = n>>1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1129220,
                "title": "java-0ms",
                "content": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int curr = -1;\\n        int max = 0;\\n        \\n        while(n%2==0)\\n            n /= 2;\\n        \\n        while(n > 0) {\\n            if(n%2 == 1) {\\n                curr++;\\n                max = Math.max(curr, max);\\n                curr = 0;\\n            } else {\\n                curr++;\\n            }\\n            n /= 2;\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int curr = -1;\\n        int max = 0;\\n        \\n        while(n%2==0)\\n            n /= 2;\\n        \\n        while(n > 0) {\\n            if(n%2 == 1) {\\n                curr++;\\n                max = Math.max(curr, max);\\n                curr = 0;\\n            } else {\\n                curr++;\\n            }\\n            n /= 2;\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 508760,
                "title": "python3-beats-96-time-100-memory",
                "content": "\\'\\'\\'\\n\\n\\n    class Solution:\\n\\tdef binaryGap(self, N: int) -> int:\\n        \\n\\t\\tl = bin(N)\\n        p1, p2 = 0, 0\\n        dtc = 0\\n    \\n        for i in range(2, len(l)):\\n            if l[i] == \\'1\\':\\n                if p1 == 0:\\n                    p1 = i\\n                else:\\n                    p2 = i\\n                    dtc = max((p2-p1), dtc)\\n                    p1 = p2\\n                \\n        return dtc\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\'\\'\\'\\n\\n\\n    class Solution:\\n\\tdef binaryGap(self, N: int) -> int:\\n        \\n\\t\\tl = bin(N)\\n        p1, p2 = 0, 0\\n        dtc = 0\\n    \\n        for i in range(2, len(l)):\\n            if l[i] == \\'1\\':\\n                if p1 == 0:\\n                    p1 = i\\n                else:\\n                    p2 = i\\n                    dtc = max((p2-p1), dtc)\\n                    p1 = p2\\n                \\n        return dtc\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 2913701,
                "title": "java-1-ms-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        String bin = Integer.toBinaryString(n);\\n        int idx = 0, max = -1;\\n        for (int i = 0; i < bin.length(); i++) {\\n            char c = bin.charAt(i);\\n            if (c == \\'1\\') {\\n                int cur = i - idx;\\n                if (max < cur) {\\n                    max = cur;\\n                }\\n                idx = i;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        String bin = Integer.toBinaryString(n);\\n        int idx = 0, max = -1;\\n        for (int i = 0; i < bin.length(); i++) {\\n            char c = bin.charAt(i);\\n            if (c == \\'1\\') {\\n                int cur = i - idx;\\n                if (max < cur) {\\n                    max = cur;\\n                }\\n                idx = i;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2308293,
                "title": "0ms-easy-c-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int Prev = -1, i = 0, Answer = 0;\\n\\t\\t/*\\n\\t\\t    Prev is the position of the previous 1\\n\\t\\t\\ti is the position\\n\\t\\t*/\\n        while(n)\\n        {\\n            if (n % 2) // if the bit is 1\\n            {\\n                if (Prev != -1 && i - Prev > Answer) \\n                    Answer = i - Prev;\\n\\t\\t\\t\\t\\t/*\\n\\t\\t\\t\\t\\t    if we have seen a one before and\\n\\t\\t\\t\\t\\t\\tthe current index minus previous \\n\\t\\t\\t\\t\\t\\tindex is more than the answer \\n\\t\\t\\t\\t\\t*/\\n                Prev = i;\\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\t    previous index equals the current index\\n\\t\\t\\t\\t\\tbecause the bit is equal to one\\n\\t\\t\\t\\t*/\\n            }\\n            ++i; // increment the position\\n            n /= 2;\\n        }\\n        return Answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int Prev = -1, i = 0, Answer = 0;\\n\\t\\t/*\\n\\t\\t    Prev is the position of the previous 1\\n\\t\\t\\ti is the position\\n\\t\\t*/\\n        while(n)\\n        {\\n            if (n % 2) // if the bit is 1\\n            {\\n                if (Prev != -1 && i - Prev > Answer) \\n                    Answer = i - Prev;\\n\\t\\t\\t\\t\\t/*\\n\\t\\t\\t\\t\\t    if we have seen a one before and\\n\\t\\t\\t\\t\\t\\tthe current index minus previous \\n\\t\\t\\t\\t\\t\\tindex is more than the answer \\n\\t\\t\\t\\t\\t*/\\n                Prev = i;\\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\t    previous index equals the current index\\n\\t\\t\\t\\t\\tbecause the bit is equal to one\\n\\t\\t\\t\\t*/\\n            }\\n            ++i; // increment the position\\n            n /= 2;\\n        }\\n        return Answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1968113,
                "title": "c-faster-than-100-0ms-bit-manipulation-diagrammatic-representation",
                "content": "***Diagrammatic representation***\\n![image](https://assets.leetcode.com/users/images/64c84117-88d6-47e0-8f70-0a208378086d_1650504132.5012343.png)\\n![image](https://assets.leetcode.com/users/images/5759fe91-4034-47a8-8a60-c72533f6bd23_1650504170.695796.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int count=INT_MIN,res=0;\\n        while(n>0){\\n            if(n&1){\\n                res=max(count,res);\\n                count=0;\\n            }\\n            count++;\\n            n=n>>1;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nIf you find this solution useful, kindly **upvote** it.",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int count=INT_MIN,res=0;\\n        while(n>0){\\n            if(n&1){\\n                res=max(count,res);\\n                count=0;\\n            }\\n            count++;\\n            n=n>>1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1697161,
                "title": "simple-javascript-solution",
                "content": "```\\nvar binaryGap = function(n) {\\n    const binary = n.toString(2);\\n    let max = 0, last = 0, i = 0;\\n    while(i < binary.length){\\n        if(binary[i] === \"1\"){\\n            let distance = i - last;\\n            last = i;\\n            max = Math.max(max, distance)\\n        }\\n        i++;\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar binaryGap = function(n) {\\n    const binary = n.toString(2);\\n    let max = 0, last = 0, i = 0;\\n    while(i < binary.length){\\n        if(binary[i] === \"1\"){\\n            let distance = i - last;\\n            last = i;\\n            max = Math.max(max, distance)\\n        }\\n        i++;\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 365234,
                "title": "c-std-bitset-0-ms-8-3-mb",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) \\n    {\\n        constexpr const size_t Byte_Size = 8;\\n        std::bitset<sizeof(N) * Byte_Size> bits{ N };\\n        \\n        size_t i = 0;\\n        while(!bits.test(i)) // find first set bit\\n            ++i; \\n        \\n        auto max_dist = 0;\\n        auto current_dist = 0;\\n        for(++i; i < bits.size(); ++i)\\n        {\\n            ++current_dist;\\n            if(bits.test(i))\\n            {\\n                max_dist = std::max(max_dist, current_dist);\\n                current_dist = 0;\\n            }\\n        }\\n        \\n        return max_dist;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) \\n    {\\n        constexpr const size_t Byte_Size = 8;\\n        std::bitset<sizeof(N) * Byte_Size> bits{ N };\\n        \\n        size_t i = 0;\\n        while(!bits.test(i)) // find first set bit\\n            ++i; \\n        \\n        auto max_dist = 0;\\n        auto current_dist = 0;\\n        for(++i; i < bits.size(); ++i)\\n        {\\n            ++current_dist;\\n            if(bits.test(i))\\n            {\\n                max_dist = std::max(max_dist, current_dist);\\n                current_dist = 0;\\n            }\\n        }\\n        \\n        return max_dist;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316060,
                "title": "c-beats-100-time-and-92-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int ans = 0;\\n        if(N &&  !(N & (N-1))) return 0; //power of 2\\n        bool first_one = false;\\n        int k = 0;\\n        int one_idx;\\n        while(N) {\\n            k++;\\n            if(first_one) {\\n                if(N&1 == 1) {\\n                    ans = max(ans, k - one_idx);\\n                }\\n            }\\n            if(N&1 == 1) {\\n                first_one=true;\\n                one_idx = k;\\n            }\\n            N >>= 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int ans = 0;\\n        if(N &&  !(N & (N-1))) return 0; //power of 2\\n        bool first_one = false;\\n        int k = 0;\\n        int one_idx;\\n        while(N) {\\n            k++;\\n            if(first_one) {\\n                if(N&1 == 1) {\\n                    ans = max(ans, k - one_idx);\\n                }\\n            }\\n            if(N&1 == 1) {\\n                first_one=true;\\n                one_idx = k;\\n            }\\n            N >>= 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152701,
                "title": "easy-understand-java-solution",
                "content": "```\\n\\n```public int binaryGap(int N) {\\n        int max = 0;\\n        int d = -32;\\n        while(N > 0){\\n            if(N % 2 == 1){\\n                max = Math.max(max, d);\\n                d = 0;\\n            }\\n            N /= 2;\\n            d++;\\n        }\\n        return max;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2816558,
                "title": "simple-java-solution-in-linear-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGenerate a binary string then loop over string to find distance between two 1\\'s and then store the max distance in a variable\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\nwhere N=length of Binary String\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n       String s=\"\";\\n        int t=n;\\n        while(t>0)\\n        {\\n            int r=t%2;\\n            s=s+r+\"\";\\n            t=t/2;\\n        }\\n       \\n        int mx=0;\\n        int start=s.indexOf(\\'1\\');\\n        for(int i=0;i<s.length();i++)\\n        {\\n\\n            if(s.charAt(i)==\\'1\\')\\n            {\\n                 mx=Math.max(mx,i-start);\\n                 start=i;\\n            }\\n        }\\n        return mx;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n       String s=\"\";\\n        int t=n;\\n        while(t>0)\\n        {\\n            int r=t%2;\\n            s=s+r+\"\";\\n            t=t/2;\\n        }\\n       \\n        int mx=0;\\n        int start=s.indexOf(\\'1\\');\\n        for(int i=0;i<s.length();i++)\\n        {\\n\\n            if(s.charAt(i)==\\'1\\')\\n            {\\n                 mx=Math.max(mx,i-start);\\n                 start=i;\\n            }\\n        }\\n        return mx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677249,
                "title": "java-simple-solution",
                "content": "```\\n public int binaryGap(int n) {\\n        int lastPos =-1;\\n        int max = 0;\\n        int pos =0;\\n        \\n       while(n>0){\\n         pos++;\\n           if((n&1)==1){\\n               if(lastPos!=-1){\\n                   max = Math.max(max, pos-lastPos);\\n               }\\n               lastPos = pos;\\n           }\\n           n= n/2;\\n       }\\n        return max;\\n        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int binaryGap(int n) {\\n        int lastPos =-1;\\n        int max = 0;\\n        int pos =0;\\n        \\n       while(n>0){\\n         pos++;\\n           if((n&1)==1){\\n               if(lastPos!=-1){\\n                   max = Math.max(max, pos-lastPos);\\n               }\\n               lastPos = pos;\\n           }\\n           n= n/2;\\n       }\\n        return max;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2485217,
                "title": "c-faster-than-100-setbits",
                "content": "class Solution {\\npublic:\\n\\n    int binaryGap(int n) {\\n        int maxi=0,one=0,count=0;\\n        while(n){\\n            if((n&1)==1 &&one==1){\\n                maxi=max(maxi,count);\\n                count=0;\\n            }\\n            else if((n&1)==1&&one==0){\\n                one=1;\\n            }\\n            if(one==1)\\n            count++;   \\n            n>>=1;\\n        }\\n        return maxi;\\n    }\\n};",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int binaryGap(int n) {\\n        int maxi=0,one=0,count=0;\\n        while(n){\\n            if((n&1)==1 &&one==1){\\n                maxi=max(maxi,count);\\n                count=0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1582979,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn binary_gap(mut n: i32) -> i32 {\\n        let (mut max_dist, mut cur_dist) = (0, 0);\\n        n >>= n.trailing_zeros(); // drop zeros 10100000 => 101\\n\\n        while n > 0 {\\n            if n & 1 == 1 && cur_dist > 0 {\\n                max_dist = max_dist.max(cur_dist);\\n                cur_dist = 0;\\n            }\\n            cur_dist += 1;\\n            n >>= 1;\\n        }\\n        max_dist\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Bit Manipulation"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn binary_gap(mut n: i32) -> i32 {\\n        let (mut max_dist, mut cur_dist) = (0, 0);\\n        n >>= n.trailing_zeros(); // drop zeros 10100000 => 101\\n\\n        while n > 0 {\\n            if n & 1 == 1 && cur_dist > 0 {\\n                max_dist = max_dist.max(cur_dist);\\n                cur_dist = 0;\\n            }\\n            cur_dist += 1;\\n            n >>= 1;\\n        }\\n        max_dist\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1364757,
                "title": "golang-bitwise-shift",
                "content": "```\\nfunc binaryGap(n int) int {\\n\\tcurDistance, maxDistance := 0, 0\\n\\tseenOne := false\\n\\tfor ; n > 0; n >>= 1 {\\n\\t\\tif n & 1 == 1 {\\n\\t\\t\\tif curDistance > maxDistance {\\n\\t\\t\\t\\tmaxDistance = curDistance\\n\\t\\t\\t}\\n\\t\\t\\tcurDistance = 1\\n\\t\\t\\tseenOne = true\\n\\t\\t} else if seenOne {\\n\\t\\t\\tcurDistance++\\n\\t\\t}\\n\\t}\\n\\treturn maxDistance\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc binaryGap(n int) int {\\n\\tcurDistance, maxDistance := 0, 0\\n\\tseenOne := false\\n\\tfor ; n > 0; n >>= 1 {\\n\\t\\tif n & 1 == 1 {\\n\\t\\t\\tif curDistance > maxDistance {\\n\\t\\t\\t\\tmaxDistance = curDistance\\n\\t\\t\\t}\\n\\t\\t\\tcurDistance = 1\\n\\t\\t\\tseenOne = true\\n\\t\\t} else if seenOne {\\n\\t\\t\\tcurDistance++\\n\\t\\t}\\n\\t}\\n\\treturn maxDistance\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1306246,
                "title": "easy-python-solution-100",
                "content": "Runtime: 16 ms, faster than 100.00% of Python3 online submissions for Binary Gap.\\nMemory Usage: 14.2 MB, less than 44.00% of Python3 online submissions for Binary Gap.\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        if(bin(n).count(\\'1\\'))==1:\\n            return 0\\n        c=0\\n        x=bin(n)[2:]\\n        for i in range(len(x)):\\n            if(x[i]==\\'1\\'):\\n                j=i+1\\n                while j<len(x):\\n                    if(x[j]==\\'1\\'):\\n                        c=max(j-i,c)\\n                        break\\n                    j+=1\\n        return c",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 16 ms, faster than 100.00% of Python3 online submissions for Binary Gap.\\nMemory Usage: 14.2 MB, less than 44.00% of Python3 online submissions for Binary Gap.\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        if(bin(n).count(\\'1\\'))==1:\\n            return 0\\n        c=0\\n        x=bin(n)[2:]\\n        for i in range(len(x)):\\n            if(x[i]==\\'1\\'):\\n                j=i+1\\n                while j<len(x):\\n                    if(x[j]==\\'1\\'):\\n                        c=max(j-i,c)\\n                        break\\n                    j+=1\\n        return c",
                "codeTag": "Java"
            },
            {
                "id": 157931,
                "title": "0ms-commented-golang",
                "content": "```\\nfunc binaryGap(N int) int {\\n    maxGap := 0\\n    \\n    currentGap := 0\\n    for N > 0 {\\n        \\n        //Check if right most bit is a one\\n        if (N & 1 == 1) {\\n            if(currentGap > maxGap){\\n                maxGap = currentGap\\n            }\\n            currentGap = 1\\n        \\n            //need this to make sure we don\\'t increment currentGap until we have actualy hit our first one\\n        } else if (currentGap > 0){\\n            currentGap++\\n        }\\n        //right shift by 1\\n        N = N >> 1\\n    }\\n    \\n    return maxGap\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc binaryGap(N int) int {\\n    maxGap := 0\\n    \\n    currentGap := 0\\n    for N > 0 {\\n        \\n        //Check if right most bit is a one\\n        if (N & 1 == 1) {\\n            if(currentGap > maxGap){\\n                maxGap = currentGap\\n            }\\n            currentGap = 1\\n        \\n            //need this to make sure we don\\'t increment currentGap until we have actualy hit our first one\\n        } else if (currentGap > 0){\\n            currentGap++\\n        }\\n        //right shift by 1\\n        N = N >> 1\\n    }\\n    \\n    return maxGap\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3992567,
                "title": "solution",
                "content": "# Complexity\\n- Time complexity: O(n^2)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def binaryGap(self, n):\\n        b=bin(n)[2:]\\n        l=len(b)\\n        m=0\\n        for i in range(l):\\n            if b[i]==\\'1\\':\\n                for j in range(i+1,l):\\n                    if b[j]==\\'1\\':\\n                        d=j-i\\n                        if d>m:\\n                            m=d\\n                        break\\n        return m\\n\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution(object):\\n    def binaryGap(self, n):\\n        b=bin(n)[2:]\\n        l=len(b)\\n        m=0\\n        for i in range(l):\\n            if b[i]==\\'1\\':\\n                for j in range(i+1,l):\\n                    if b[j]==\\'1\\':\\n                        d=j-i\\n                        if d>m:\\n                            m=d\\n                        break\\n        return m\\n\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555976,
                "title": "868-binary-gap",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int count=0;\\n        int c=0;\\n        while(n>0){\\n            if(n%2==0){\\n                if(count>0){\\n                    count++;\\n                }\\n                c=max(c,count);\\n                n=n/2;\\n            }\\n            else{\\n                c=max(c,count);\\n                count=1;\\n                n=n/2;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int count=0;\\n        int c=0;\\n        while(n>0){\\n            if(n%2==0){\\n                if(count>0){\\n                    count++;\\n                }\\n                c=max(c,count);\\n                n=n/2;\\n            }\\n            else{\\n                c=max(c,count);\\n                count=1;\\n                n=n/2;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499368,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int result = 0;\\n        int last = -1;\\n        for (int i = 0; i < 32; ++i) {\\n            if ((N >> i) & 1) {\\n                if (last != -1) {\\n                    result = max(result, i - last);\\n                }\\n                last = i;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        s = f\\'{n:b}\\'\\n        result = 0\\n        for i in range(len(s)):\\n            if s[i] == \\'0\\':\\n                continue\\n            for j in range(i + 1, len(s)):\\n                if s[j] == \\'0\\':\\n                    continue\\n                result = max(result, j - i)\\n                break\\n        return result\\n```\\n\\n```Java []\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int prev=-1;\\n        int tc=0;\\n        int mx=-1,ct=0;\\n        while(n>0){\\n            int r= n&1;\\n            if(r==1 ){\\n                ++tc;\\n                prev=0;\\n                    mx=Math.max(ct,mx);\\n                    ct=0;\\n                \\n            }else {\\n                if(prev!=-1){\\n                    ct++;\\n                }\\n            }\\n            n=n>>1;\\n        }\\n        if(tc<=1){\\n            return 0;\\n        }\\n        return mx+1;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int result = 0;\\n        int last = -1;\\n        for (int i = 0; i < 32; ++i) {\\n            if ((N >> i) & 1) {\\n                if (last != -1) {\\n                    result = max(result, i - last);\\n                }\\n                last = i;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        s = f\\'{n:b}\\'\\n        result = 0\\n        for i in range(len(s)):\\n            if s[i] == \\'0\\':\\n                continue\\n            for j in range(i + 1, len(s)):\\n                if s[j] == \\'0\\':\\n                    continue\\n                result = max(result, j - i)\\n                break\\n        return result\\n```\n```Java []\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int prev=-1;\\n        int tc=0;\\n        int mx=-1,ct=0;\\n        while(n>0){\\n            int r= n&1;\\n            if(r==1 ){\\n                ++tc;\\n                prev=0;\\n                    mx=Math.max(ct,mx);\\n                    ct=0;\\n                \\n            }else {\\n                if(prev!=-1){\\n                    ct++;\\n                }\\n            }\\n            n=n>>1;\\n        }\\n        if(tc<=1){\\n            return 0;\\n        }\\n        return mx+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464142,
                "title": "beats-100-easy-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int ans = 0, count = 1;\\n        \\n        while(n > 0 ){\\n            // first n\\n           if(n&1){\\n               cout << n << \" break\" << endl;\\n              n  =n >> 1;\\n               break;\\n\\n           }\\n           n = n >> 1;\\n        }\\n\\n        while(n > 0 ){\\n            if(n&1){\\n                // cout << n << \" 2 one \"<<  endl;\\n                ans = max(count , ans);\\n                count =1;\\n            }\\n            else\\n                count++;\\n            // n/=2;\\n           n =  n >> 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int ans = 0, count = 1;\\n        \\n        while(n > 0 ){\\n            // first n\\n           if(n&1){\\n               cout << n << \" break\" << endl;\\n              n  =n >> 1;\\n               break;\\n\\n           }\\n           n = n >> 1;\\n        }\\n\\n        while(n > 0 ){\\n            if(n&1){\\n                // cout << n << \" 2 one \"<<  endl;\\n                ans = max(count , ans);\\n                count =1;\\n            }\\n            else\\n                count++;\\n            // n/=2;\\n           n =  n >> 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3457342,
                "title": "easiest-solution-bit-manipulation-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int last=-1;\\n        int ans=0;\\n   for(int i=0;i<32;i++){\\n       if(n&(1<<i)){\\n           if(last==-1) last=i;\\n           else{\\n               ans=max(ans,i-last);\\n               last=i;\\n           }\\n       }\\n   }\\n   return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int last=-1;\\n        int ans=0;\\n   for(int i=0;i<32;i++){\\n       if(n&(1<<i)){\\n           if(last==-1) last=i;\\n           else{\\n               ans=max(ans,i-last);\\n               last=i;\\n           }\\n       }\\n   }\\n   return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409133,
                "title": "very-understandable-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        b=bin(n)[2:]\\n        maxx=0\\n        x=0\\n        y=0\\n        for i in range(len(b)):\\n            if b[i]==\"1\":\\n                maxx=max(maxx,abs(x-y))\\n                x=y\\n            y=i+1\\n        return maxx\\n\\n\\n\\n        \"\"\"(or)\\n\\n        res=[i for i,j in enumerate(bin(n)[2:]) if j==\"1\"]\\n        return max([j-i for i,j in zip(res,res[1:])] or [0])\"\"\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        b=bin(n)[2:]\\n        maxx=0\\n        x=0\\n        y=0\\n        for i in range(len(b)):\\n            if b[i]==\"1\":\\n                maxx=max(maxx,abs(x-y))\\n                x=y\\n            y=i+1\\n        return maxx\\n\\n\\n\\n        \"\"\"(or)\\n\\n        res=[i for i,j in enumerate(bin(n)[2:]) if j==\"1\"]\\n        return max([j-i for i,j in zip(res,res[1:])] or [0])\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303808,
                "title": "c-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        string bin;\\n        while(n){\\n            bin+=to_string(n%2);\\n            n/=2;\\n        }\\n        reverse(bin.begin(), bin.end());\\n\\n        int maxi = INT_MIN;\\n        int count=1, t=0;\\n        \\n        for(int i = 0; i<bin.size(); i++){\\n            if(bin[i] == \\'1\\'){\\n                t++;\\n                maxi = max(maxi,count);\\n                count=1;\\n            }\\n            else count++;\\n        }\\n        return t > 1 ? maxi : 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        string bin;\\n        while(n){\\n            bin+=to_string(n%2);\\n            n/=2;\\n        }\\n        reverse(bin.begin(), bin.end());\\n\\n        int maxi = INT_MIN;\\n        int count=1, t=0;\\n        \\n        for(int i = 0; i<bin.size(); i++){\\n            if(bin[i] == \\'1\\'){\\n                t++;\\n                maxi = max(maxi,count);\\n                count=1;\\n            }\\n            else count++;\\n        }\\n        return t > 1 ? maxi : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181929,
                "title": "beats-98-easy-solution-please-upvote",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public int BinaryGap(int n) {\\n        int last = -1, ans = 0;\\n        for (int i = 0; i < 32; ++i)\\n            if (((n >> i) & 1) > 0) {\\n                if (last >= 0)\\n                    ans = Math.Max(ans, i - last);\\n                last = i;\\n            }\\n\\n        return ans; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int BinaryGap(int n) {\\n        int last = -1, ans = 0;\\n        for (int i = 0; i < 32; ++i)\\n            if (((n >> i) & 1) > 0) {\\n                if (last >= 0)\\n                    ans = Math.Max(ans, i - last);\\n                last = i;\\n            }\\n\\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176459,
                "title": "easy-solution-using-bin-function",
                "content": "\\n\\n# Approach\\nFirst of all ,We have to convert the given integer into its equivalent binary string. Then we will store all the indexes of \"1\" in an array.\\nThen we will calculate the difference between adjacent elements. After calculating the differences we will return the maximum difference ..\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        a=[]\\n        l=bin(n).replace(\"0b\",\"\")\\n        for i in range(len(l)):\\n            if l[i]==\"1\":\\n                a.append(i)\\n        if len(a)<=1:\\n            return 0\\n        maxi=0\\n        \\n        for i in range(len(a)-1):\\n            maxi=max(maxi,int(a[i+1])-int(a[i]))\\n        return maxi\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        a=[]\\n        l=bin(n).replace(\"0b\",\"\")\\n        for i in range(len(l)):\\n            if l[i]==\"1\":\\n                a.append(i)\\n        if len(a)<=1:\\n            return 0\\n        maxi=0\\n        \\n        for i in range(len(a)-1):\\n            maxi=max(maxi,int(a[i+1])-int(a[i]))\\n        return maxi\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113966,
                "title": "python3-easy",
                "content": "# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        \\n        ans = 0\\n        m = -1\\n        while n:\\n            if 1&n:\\n                if m==-1:\\n                    m = 1\\n                else:\\n                    ans = max(ans,m)\\n                    m=1\\n            else:\\n                if m!=-1:\\n                    m+=1\\n                \\n            n = n>>1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        \\n        ans = 0\\n        m = -1\\n        while n:\\n            if 1&n:\\n                if m==-1:\\n                    m = 1\\n                else:\\n                    ans = max(ans,m)\\n                    m=1\\n            else:\\n                if m!=-1:\\n                    m+=1\\n                \\n            n = n>>1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816573,
                "title": "simple-java-solution-in-linear-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGenerate a binary string then loop over string to find distance between two 1\\'s and then store the max distance in a variable\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\nwhere N=length of Binary String\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n       String s=\"\";\\n        int t=n;\\n        while(t>0)\\n        {\\n            int r=t%2;\\n            s=s+r+\"\";\\n            t=t/2;\\n        }\\n       \\n        int mx=0;\\n        int start=s.indexOf(\\'1\\');\\n        for(int i=0;i<s.length();i++)\\n        {\\n\\n            if(s.charAt(i)==\\'1\\')\\n            {\\n                 mx=Math.max(mx,i-start);\\n                 start=i;\\n            }\\n        }\\n        return mx;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n       String s=\"\";\\n        int t=n;\\n        while(t>0)\\n        {\\n            int r=t%2;\\n            s=s+r+\"\";\\n            t=t/2;\\n        }\\n       \\n        int mx=0;\\n        int start=s.indexOf(\\'1\\');\\n        for(int i=0;i<s.length();i++)\\n        {\\n\\n            if(s.charAt(i)==\\'1\\')\\n            {\\n                 mx=Math.max(mx,i-start);\\n                 start=i;\\n            }\\n        }\\n        return mx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790637,
                "title": "python-simple-solution-ii-o-n-one-pass",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        binary = bin(n)\\n        binary= binary[2:]\\n        found = False\\n        max_count =0\\n        for i in range(len(binary)):\\n             if(binary[i]==\\'1\\' and found ==False):\\n                 start= i\\n                 found = True\\n             elif(binary[i]==\\'1\\' and found==True):\\n                 count = i- start\\n                 start= i\\n                 if(count>max_count):\\n                     max_count= count\\n        return max_count\\n\\n             \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        binary = bin(n)\\n        binary= binary[2:]\\n        found = False\\n        max_count =0\\n        for i in range(len(binary)):\\n             if(binary[i]==\\'1\\' and found ==False):\\n                 start= i\\n                 found = True\\n             elif(binary[i]==\\'1\\' and found==True):\\n                 count = i- start\\n                 start= i\\n                 if(count>max_count):\\n                     max_count= count\\n        return max_count\\n\\n             \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687088,
                "title": "c-0ms-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int ans = 0,c=0,t=0;long x = 1;bool flag = false;\\n        while(n>=x){\\n            c++;\\n            if(x&n) {\\n                if(flag) ans = max(ans,c-t);\\n                t = c;\\n                flag = true;\\n            } x<<=1;\\n        }return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int ans = 0,c=0,t=0;long x = 1;bool flag = false;\\n        while(n>=x){\\n            c++;\\n            if(x&n) {\\n                if(flag) ans = max(ans,c-t);\\n                t = c;\\n                flag = true;\\n            } x<<=1;\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2565781,
                "title": "js-easy-solution-100-o-n",
                "content": "![image](https://assets.leetcode.com/users/images/475ee9ed-ee46-4a6a-a0f9-f5783f5b13de_1662972381.4477122.png)\\n\\n```\\nvar binaryGap = function(n) {\\n    const binaryString = (n >>> 0).toString(2);\\n    let output = 0;\\n    let start;\\n\\n    for (let i = 0; i < binaryString.length; i++) {\\n        if (binaryString[i] === \"1\") {\\n            output = Math.max(output, start !== undefined ? (i - start) : 0);\\n            start = i;\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar binaryGap = function(n) {\\n    const binaryString = (n >>> 0).toString(2);\\n    let output = 0;\\n    let start;\\n\\n    for (let i = 0; i < binaryString.length; i++) {\\n        if (binaryString[i] === \"1\") {\\n            output = Math.max(output, start !== undefined ? (i - start) : 0);\\n            start = i;\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2437228,
                "title": "my-kotlin-solution-with-time-o-1-and-space-o-1",
                "content": "Below is my solution in kotlin, it preprocess the n with it right most bit and calculate the gap through shift right.\\n```\\nclass Solution {\\n    /* Complexity:\\n     * Time O(1) & Space O(1);\\n     */\\n    fun binaryGap(n: Int): Int {\\n        tailrec fun process(num: Int, gap: Int = 0, maxGap: Int = 0): Int =\\n            when {\\n                num == 0 -> maxGap\\n                num and 1 == 0 -> process(num shr 1, gap + 1, maxGap)\\n                else -> process(num shr 1, 1, maxOf(gap, maxGap))\\n            }\\n\\n        val rightMostBit = n - (n and (n - 1))\\n        return if (rightMostBit == 0) 0 else process(num = n / rightMostBit)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    /* Complexity:\\n     * Time O(1) & Space O(1);\\n     */\\n    fun binaryGap(n: Int): Int {\\n        tailrec fun process(num: Int, gap: Int = 0, maxGap: Int = 0): Int =\\n            when {\\n                num == 0 -> maxGap\\n                num and 1 == 0 -> process(num shr 1, gap + 1, maxGap)\\n                else -> process(num shr 1, 1, maxOf(gap, maxGap))\\n            }\\n\\n        val rightMostBit = n - (n and (n - 1))\\n        return if (rightMostBit == 0) 0 else process(num = n / rightMostBit)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430116,
                "title": "binary-gap-c-5ms",
                "content": "class Solution {\\npublic:\\n    int binaryGap(int &n) {\\n        int ans = 0,x = 0;\\n        while(n){\\n            if(n%2==1){\\n                ans = max(ans,x-1);\\n                x = 1;\\n            }\\n            x > 0? x++: x = 0;\\n            n = n >> 1;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int binaryGap(int &n) {\\n        int ans = 0,x = 0;\\n        while(n){\\n            if(n%2==1){\\n                ans = max(ans,x-1);\\n                x = 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2145256,
                "title": "c-fast-easy-code-bit-manipulation",
                "content": "Check each bit from the back and if it\\'s \\'1\\', we calculate the distance using the difference between the current index and the previous index that points to the previous \\'1\\' found. Compare the value with the current max distance and store the larger value back. There\\'s no previous index for the first \\'1\\' so we simply set previous index to the current index.\\n\\n**Code:**\\n```\\nclass Solution {\\n public:\\n  int BinaryGap(int n) {\\n    int index = 0, prev_index = -1;\\n    int max_distance = 0;\\n\\n    while (n) {\\n      if (n & 1) {\\n        if (prev_index != -1)\\n          max_distance = std::max(max_distance, index - prev_index);\\n        prev_index = index;\\n      }\\n      n >>= 1, index++;\\n    }\\n\\n    return max_distance;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int BinaryGap(int n) {\\n    int index = 0, prev_index = -1;\\n    int max_distance = 0;\\n\\n    while (n) {\\n      if (n & 1) {\\n        if (prev_index != -1)\\n          max_distance = std::max(max_distance, index - prev_index);\\n        prev_index = index;\\n      }\\n      n >>= 1, index++;\\n    }\\n\\n    return max_distance;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2091944,
                "title": "java-simple-solution",
                "content": "Here is a simple approach to solve this question.\\nWhat we are doing here is\\ni) if(n&1) is equal to 1 then find next 1\\n\\t\\t........**(subcondition)**.........if(n==0) then it means next 1 not found else 1 is found so set the value of max\\nii) else right shift.\\n\\n```class Solution {\\n    public int binaryGap(int n) {\\n        int max=0;\\n        while(n>0){\\n            int r=n&1;\\n\\t\\t\\t//if r==1 then search next occurence of 1\\n            if(r==1){\\n                n=n>>1;\\n                int var=1;\\n                while(n>0 && (n&1)!=1){\\n                    n=n>>1;\\n                    var++;\\n                }\\n                if(n!=0){\\n                    max=Math.max(max,var);\\n                }\\n                // else right shift\\n            }else{\\n                n=n>>1;\\n            }\\n        }\\n        return max;\\n    }\\n}```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```class Solution {\\n    public int binaryGap(int n) {\\n        int max=0;\\n        while(n>0){\\n            int r=n&1;\\n\\t\\t\\t//if r==1 then search next occurence of 1\\n            if(r==1){\\n                n=n>>1;\\n                int var=1;\\n                while(n>0 && (n&1)!=1){\\n                    n=n>>1;\\n                    var++;\\n                }\\n                if(n!=0){\\n                    max=Math.max(max,var);\\n                }\\n                // else right shift\\n            }else{\\n                n=n>>1;\\n            }\\n        }\\n        return max;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1984287,
                "title": "super-clear-illustrated-explanation",
                "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/4517167f-0053-4740-b183-710c7bd81536_1650990891.4216025.png)\\n\\n\\n    def binaryGap(self, n: int) -> int:\\n        \"\"\" O(logN)T O(1)S \"\"\"\\n        num, ans, prev = bin(n)[2:], 0, math.inf\\n\\n        for i, b in enumerate(num):\\n            if b == \\'1\\':\\n                ans, prev = max(ans, i - prev), i\\n\\n        return ans\\n\\n    def binaryGap(self, n: int) -> int:\\n        \"\"\" O(logN)T O(1)S \"\"\"\\n        num, size = map(int, bin(n)[2:]), math.floor(math.log2(n)) + 1  # size = bit cnt\\n        return max((b - a for a, b in itertools.pairwise(itertools.compress(range(size), num))), default=0)\\n\\n    def binaryGap(self, n: int) -> int:\\n        \"\"\" O(logN)T O(1)S \"\"\"\\n        idx = [i for i, v in enumerate(bin(n)) if v == \\'1\\']\\n        return max((b - a for a, b in itertools.pairwise(idx)), default=0)",
                "solutionTags": [],
                "code": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/4517167f-0053-4740-b183-710c7bd81536_1650990891.4216025.png)\\n\\n\\n    def binaryGap(self, n: int) -> int:\\n        \"\"\" O(logN)T O(1)S \"\"\"\\n        num, ans, prev = bin(n)[2:], 0, math.inf\\n\\n        for i, b in enumerate(num):\\n            if b == \\'1\\':\\n                ans, prev = max(ans, i - prev), i\\n\\n        return ans\\n\\n    def binaryGap(self, n: int) -> int:\\n        \"\"\" O(logN)T O(1)S \"\"\"\\n        num, size = map(int, bin(n)[2:]), math.floor(math.log2(n)) + 1  # size = bit cnt\\n        return max((b - a for a, b in itertools.pairwise(itertools.compress(range(size), num))), default=0)\\n\\n    def binaryGap(self, n: int) -> int:\\n        \"\"\" O(logN)T O(1)S \"\"\"\\n        idx = [i for i, v in enumerate(bin(n)) if v == \\'1\\']\\n        return max((b - a for a, b in itertools.pairwise(idx)), default=0)",
                "codeTag": "Python3"
            },
            {
                "id": 1919356,
                "title": "fast-solution-in-python3",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        a=list(bin(n)[2:])\\n        s=[]\\n        for i in range(len(a)):\\n            if a[i]!=\\'0\\':\\n                s.append(i)\\n        t=[]\\n        for i in range(len(s)):\\n            t.append(s[i]-s[i-1])\\n        return(max(t))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        a=list(bin(n)[2:])\\n        s=[]\\n        for i in range(len(a)):\\n            if a[i]!=\\'0\\':\\n                s.append(i)\\n        t=[]\\n        for i in range(len(s)):\\n            t.append(s[i]-s[i-1])\\n        return(max(t))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859275,
                "title": "100-time-o-logn-easy-to-understand",
                "content": "**here we are using  differnt function of bit to solve question**\\n***be noted why we initialize count to -32 i wrote it in comment in code***\\n\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int count = -32, maxi = 0;//-32 is the smallest possible bit \\n\\t\\t//maxi is our answer\\n        //we have to start counting from -32 because we are moving reverse like if n=8 than we are travarsing 0->0->0->1 so be noted about it\\n        while (n != 0) {\\n            if ((n & 1) == 1) {// also write \\'n%2\\'\\n                maxi = max(maxi, count);\\n                count = 0;\\n            }\\n            count++;\\n            n >>= 1;//also write \\'n/=2\\'\\n        }\\n        return maxi;\\n    }\\n};\\n```\\n***this is my solution if yu have any doubt than fill free to ask in comment if i can than absolutly solve it***\\n***if you find solution use ful than upwote else downvote***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int count = -32, maxi = 0;//-32 is the smallest possible bit \\n\\t\\t//maxi is our answer\\n        //we have to start counting from -32 because we are moving reverse like if n=8 than we are travarsing 0->0->0->1 so be noted about it\\n        while (n != 0) {\\n            if ((n & 1) == 1) {// also write \\'n%2\\'\\n                maxi = max(maxi, count);\\n                count = 0;\\n            }\\n            count++;\\n            n >>= 1;//also write \\'n/=2\\'\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794889,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n\\t\\t int max=0;\\n\\t\\t while(n!=1) {\\n             int c=0;\\n\\t\\t\\t if((n&1)==1) {\\n\\t\\t\\t\\t while(n!=0&&(n>>1&1)==0) {\\n\\t\\t\\t\\t\\t c++;\\n\\t\\t\\t\\t\\t n>>=1;\\n\\t\\t\\t\\t }\\n\\t\\t\\t\\t if(max<c+1) { \\n\\t\\t\\t\\t\\t max=(c+1);\\n\\t\\t\\t\\t }\\n\\t\\t\\t }\\t\\t\\t\\n\\t\\t\\t n>>=1;\\n\\t\\t }\\n\\t\\n\\t\\treturn max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n\\t\\t int max=0;\\n\\t\\t while(n!=1) {\\n             int c=0;\\n\\t\\t\\t if((n&1)==1) {\\n\\t\\t\\t\\t while(n!=0&&(n>>1&1)==0) {\\n\\t\\t\\t\\t\\t c++;\\n\\t\\t\\t\\t\\t n>>=1;\\n\\t\\t\\t\\t }\\n\\t\\t\\t\\t if(max<c+1) { \\n\\t\\t\\t\\t\\t max=(c+1);\\n\\t\\t\\t\\t }\\n\\t\\t\\t }\\t\\t\\t\\n\\t\\t\\t n>>=1;\\n\\t\\t }\\n\\t\\n\\t\\treturn max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1736152,
                "title": "javascript-solution-using-bit-manipulation",
                "content": "```\\nvar max = (a,b) => {\\n    return a>b?a:b;\\n}\\nvar binaryGap = function(n) {\\n    var maxs = 0;\\n    var d=0;\\n    var i=0;\\n    var last=-1\\n    while(n!=0){\\n        if(last === -1 && n&1===1){\\n            last = i; \\n        }\\n        else if(n&1===1){\\n            maxs=max(maxs,i-last);\\n            last = i;\\n        }\\n        n=n>>1;\\n        i++;\\n    }\\n    return maxs\\n};",
                "solutionTags": [],
                "code": "```\\nvar max = (a,b) => {\\n    return a>b?a:b;\\n}\\nvar binaryGap = function(n) {\\n    var maxs = 0;\\n    var d=0;\\n    var i=0;\\n    var last=-1\\n    while(n!=0){\\n        if(last === -1 && n&1===1){\\n            last = i; \\n        }\\n        else if(n&1===1){\\n            maxs=max(maxs,i-last);\\n            last = i;\\n        }\\n        n=n>>1;\\n        i++;\\n    }\\n    return maxs\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1722203,
                "title": "using-format-for-binary-string",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        curr = \"{:b}\".format(n)\\n        n = len(curr)\\n        mdist = 0\\n        prev = -1\\n        for i in range(n):\\n            if curr[i] == \"1\":\\n                if prev >= 0:\\n                    mdist = max(mdist, i - prev)\\n                prev = i\\n        return mdist\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        curr = \"{:b}\".format(n)\\n        n = len(curr)\\n        mdist = 0\\n        prev = -1\\n        for i in range(n):\\n            if curr[i] == \"1\":\\n                if prev >= 0:\\n                    mdist = max(mdist, i - prev)\\n                prev = i\\n        return mdist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519288,
                "title": "fastest-100-passed-c-clear-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int dis =0, max_dis = 0,flag =0;\\n        while(n)\\n        {\\n            if(n&1)\\n            {\\n                flag =1;\\n                max_dis = max(max_dis,dis);\\n                dis = 1;\\n            }\\n            else if(flag)\\n            {\\n                dis++;\\n            }\\n            \\n            n = n>>1;\\n        }\\n        \\n        return max_dis;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int dis =0, max_dis = 0,flag =0;\\n        while(n)\\n        {\\n            if(n&1)\\n            {\\n                flag =1;\\n                max_dis = max(max_dis,dis);\\n                dis = 1;\\n            }\\n            else if(flag)\\n            {\\n                dis++;\\n            }\\n            \\n            n = n>>1;\\n        }\\n        \\n        return max_dis;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467446,
                "title": "simple-c-o-log-n-constant-space",
                "content": "\\n    int binaryGap(int n) {\\n        \\n        int temp{0}, ans{0}, curr{INT_MAX};\\n        \\n        while(n){\\n            temp++;\\n            if(n&1){\\n                ans=max(ans, temp-curr);\\n                curr=temp;                \\n            } \\n            n=n>>1;\\n        }\\n        return ans;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    int binaryGap(int n) {\\n        \\n        int temp{0}, ans{0}, curr{INT_MAX};\\n        \\n        while(n){\\n            temp++;\\n            if(n&1){\\n                ans=max(ans, temp-curr);\\n                curr=temp;                \\n            } \\n            n=n>>1;\\n        }\\n        return ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1410829,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public int binaryGap(int n) {\\n        String p=Integer.toBinaryString(n);\\n        int i,c=0,k=0,j=0;\\n        for(i=0;i<p.length();i++)\\n        {\\n            if(p.charAt(i)==\\'1\\'&&c>0)\\n            {\\n                k=Math.max(k,(i-j));\\n                j=i;\\n                c++;\\n            }\\n            else if(p.charAt(i)==\\'1\\')\\n            {\\n                j=i;\\n                c++;\\n            }\\n        }\\n        return k;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int binaryGap(int n) {\\n        String p=Integer.toBinaryString(n);\\n        int i,c=0,k=0,j=0;\\n        for(i=0;i<p.length();i++)\\n        {\\n            if(p.charAt(i)==\\'1\\'&&c>0)\\n            {\\n                k=Math.max(k,(i-j));\\n                j=i;\\n                c++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1405152,
                "title": "fast-c-solution-o-1-space-0-ms-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int dig, cur = 0, max = 0;\\n        if(n == 0) {\\n            return 0;\\n        }\\n        while(n > 0 && n % 2 == 0) {\\n            n /= 2;\\n        }\\n        if(n == 0) {\\n            return 0;\\n        }\\n        int count = 0;\\n        while(n > 0) {\\n            if(n % 2 == 0) {\\n                cur++;\\n            } else {\\n                max = std::max(cur, max);\\n                count++;\\n                cur = 0;\\n            }\\n            n /= 2;\\n        }\\n        if(count == 1) {\\n            return 0;\\n        }\\n        return max + 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int dig, cur = 0, max = 0;\\n        if(n == 0) {\\n            return 0;\\n        }\\n        while(n > 0 && n % 2 == 0) {\\n            n /= 2;\\n        }\\n        if(n == 0) {\\n            return 0;\\n        }\\n        int count = 0;\\n        while(n > 0) {\\n            if(n % 2 == 0) {\\n                cur++;\\n            } else {\\n                max = std::max(cur, max);\\n                count++;\\n                cur = 0;\\n            }\\n            n /= 2;\\n        }\\n        if(count == 1) {\\n            return 0;\\n        }\\n        return max + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1362260,
                "title": "o-n-0ms-100-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int k=INT_MIN,count=0;\\n        while(n!=0){\\n            if(n%2==1){\\n                count=max(count,k); k=0;\\n            }\\n            k+=1; n/=2;\\n        }\\n    \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int k=INT_MIN,count=0;\\n        while(n!=0){\\n            if(n%2==1){\\n                count=max(count,k); k=0;\\n            }\\n            k+=1; n/=2;\\n        }\\n    \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337314,
                "title": "simple-python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        ons = []\\n        for i in range(len(bin(n)[2:])):\\n            if bin(n)[2:][i] == \\'1\\': ons.append(i)\\n        if len(ons) >= 2:\\n            maxi = -1\\n            for i in range(len(ons)-1):\\n                if ons[i+1] - ons[i] > maxi: maxi = ons[i+1] - ons[i]\\n            return maxi\\n        else:return 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        ons = []\\n        for i in range(len(bin(n)[2:])):\\n            if bin(n)[2:][i] == \\'1\\': ons.append(i)\\n        if len(ons) >= 2:\\n            maxi = -1\\n            for i in range(len(ons)-1):\\n                if ons[i+1] - ons[i] > maxi: maxi = ons[i+1] - ons[i]\\n            return maxi\\n        else:return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1263330,
                "title": "c-simple-solution-0ms",
                "content": "```\\nint binaryGap(int n){\\n    int max=0, i=0, pre=-1;\\n    while(n > 0){\\n        if(n & 1){\\n            if(pre > -1 && max < i - pre)\\n                max = i - pre;\\n            pre = i;\\n        }\\n        i++;\\n        n = n >> 1;\\n    }\\n    return max;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint binaryGap(int n){\\n    int max=0, i=0, pre=-1;\\n    while(n > 0){\\n        if(n & 1){\\n            if(pre > -1 && max < i - pre)\\n                max = i - pre;\\n            pre = i;\\n        }\\n        i++;\\n        n = n >> 1;\\n    }\\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1200055,
                "title": "hashing-steps-explanation-0ms-c",
                "content": "**STEPS:-**\\n**1) convert the number in binary format and store it in a string (LSB at 0 index)**\\n**2) declare a  map( key = char, value = int) and define an int dist = 0**\\n**3) then just iterate over the string, if map does not contain key = \\'1\\' , then just insert it with value = index**\\n**4) if key = \\'1\\', already present then simply update the dist as max(dist,abs(map[\\'1\\']-index))**\\n**5) return the dist**\\n**NOTE: Why its working ??, you got it by now :)**\\n```\\n    int binaryGap(int n) {\\n        string s;\\n        while(n!=0){\\n            s+=to_string(n%2);\\n            n/=2;\\n        }\\n        unordered_map<char,int> mp;\\n        int dist=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'&&mp.count(s[i])!=0)\\n                dist=max(dist,abs(mp[s[i]]-i));\\n            mp[s[i]]=i;\\n        }\\n        return dist;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int binaryGap(int n) {\\n        string s;\\n        while(n!=0){\\n            s+=to_string(n%2);\\n            n/=2;\\n        }\\n        unordered_map<char,int> mp;\\n        int dist=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'&&mp.count(s[i])!=0)\\n                dist=max(dist,abs(mp[s[i]]-i));\\n            mp[s[i]]=i;\\n        }\\n        return dist;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1156816,
                "title": "super-simple-and-easy-cpp-solution-must-check",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        \\n        int flag =0;\\n        int dis =0;\\n        int maxi =0;\\n        while(n> 0)\\n        {\\n            if(n %2==1 and flag ==0)\\n                flag =1;\\n            \\n            else if( n %2 and flag)\\n            {\\n                dis++;\\n                maxi = max(dis,maxi);\\n                dis =0;\\n            }\\n            else if(flag)\\n                dis++;\\n            n = n>>1;    \\n        }\\n        return maxi;\\n    }\\n};\\n\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int binaryGap(int n) {\\n        \\n        int flag =0;\\n        int dis =0;\\n        int maxi =0;\\n        while(n> 0)\\n        {\\n            if(n %2==1 and flag ==0)\\n                flag =1;\\n            \\n            else if( n %2 and flag)\\n            {\\n                dis++;\\n                maxi = max(dis,maxi);\\n                dis =0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1081801,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        \\n        \\n        lst = list(bin(n)[2:])\\n        max_length = -float(\\'inf\\')\\n        flag = False\\n        \\n        for idx,val in enumerate(lst):\\n            if(val == \\'1\\'):\\n                if(flag == False):\\n                    start = idx\\n                    flag = True\\n                else:\\n                    max_length = max(max_length,idx-start)\\n                    start = idx\\n                    \\n        if(max_length == -float(\\'inf\\')):\\n            return 0\\n        \\n        return max_length\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        \\n        \\n        lst = list(bin(n)[2:])\\n        max_length = -float(\\'inf\\')\\n        flag = False\\n        \\n        for idx,val in enumerate(lst):\\n            if(val == \\'1\\'):\\n                if(flag == False):\\n                    start = idx\\n                    flag = True\\n                else:\\n                    max_length = max(max_length,idx-start)\\n                    start = idx\\n                    \\n        if(max_length == -float(\\'inf\\')):\\n            return 0\\n        \\n        return max_length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030187,
                "title": "python-solution",
                "content": "```\\ndef binary_gap(n: int):\\n    dist = 0\\n    x = float(\\'-inf\\')\\n\\n    while n > 0:\\n        if n % 2 == 1:\\n            dist = max(dist, x)\\n            x = 0\\n\\n        n//=2\\n        x+=1\\n\\n    return dist\\n```",
                "solutionTags": [],
                "code": "```\\ndef binary_gap(n: int):\\n    dist = 0\\n    x = float(\\'-inf\\')\\n\\n    while n > 0:\\n        if n % 2 == 1:\\n            dist = max(dist, x)\\n            x = 0\\n\\n        n//=2\\n        x+=1\\n\\n    return dist\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1020460,
                "title": "python-bitwise-95-faster",
                "content": "Every odd value will have a 1 on the right hand side of the binary digit (because this is the ones digit and all factors of 2 are even except 2 raised to the 0 power).  We can then bitwise right shift by 1 (i.e. integer division by 2, effectively dropping the right digit) to \\'traverse\\' across the binary and count the times until we obtain another odd (1) value.\\n\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        \\n        ans = 0\\n        while n > 1:\\n            if n % 2 == 1:\\n                count = 1\\n                n >>= 1\\n                while n % 2 == 0:\\n                    count += 1\\n                    n >>= 1\\n                ans = max(ans, count)\\n            else:\\n                n >>= 1\\n            \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        \\n        ans = 0\\n        while n > 1:\\n            if n % 2 == 1:\\n                count = 1\\n                n >>= 1\\n                while n % 2 == 0:\\n                    count += 1\\n                    n >>= 1\\n                ans = max(ans, count)\\n            else:\\n                n >>= 1\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1017556,
                "title": "clean-js-solution",
                "content": "Remove the first \\'1\\' in the binary, then loop through the string. If we hit a \\'1\\', record the gap and compare it to the max gap then reset the gap to 0.\\n```\\nvar binaryGap = function (n) {\\n  const binary = n.toString(2).substring(1)\\n  let [maxGap, gap] = [0, 0];\\n\\n  for (let num of binary) {\\n    gap++;\\n    if (num === \\'1\\') {\\n      maxGap = Math.max(maxGap, gap);\\n      gap = 0;\\n    }\\n  }\\n\\n  return maxGap;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar binaryGap = function (n) {\\n  const binary = n.toString(2).substring(1)\\n  let [maxGap, gap] = [0, 0];\\n\\n  for (let num of binary) {\\n    gap++;\\n    if (num === \\'1\\') {\\n      maxGap = Math.max(maxGap, gap);\\n      gap = 0;\\n    }\\n  }\\n\\n  return maxGap;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 989270,
                "title": "simple-java-solution-1-ms-with-explanation",
                "content": "- Intially store the first occur \\'1\\'\\n- Next if the current value is \\'1\\' then minu the previous value with current index and change the previous value\\n\\n```\\nclass Solution {\\n    public int binaryGap(int N) {\\n        String b  = Integer.toBinaryString(N);\\n        \\n        int n = b.length();\\n        int dif = 0;\\n        int prev = b.indexOf(\"1\"); \\n        \\n        for(int i=prev+1;i<n;i++){\\n            if(b.charAt(i) == \\'1\\'){\\n                dif = Integer.max(dif,i-prev);\\n                prev = i;\\n            }\\n        }\\n        return dif;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int N) {\\n        String b  = Integer.toBinaryString(N);\\n        \\n        int n = b.length();\\n        int dif = 0;\\n        int prev = b.indexOf(\"1\"); \\n        \\n        for(int i=prev+1;i<n;i++){\\n            if(b.charAt(i) == \\'1\\'){\\n                dif = Integer.max(dif,i-prev);\\n                prev = i;\\n            }\\n        }\\n        return dif;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 982479,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int binaryGap(int n) {\\n        while(n%2==0)\\n            n/=2;\\n        if(n==1)\\n            return 0;\\n        int tot=0,max=0;\\n        while(n!=0){\\n            if(n%2==0)\\n                tot++;\\n            else{\\n                if(tot>max)\\n                    max=tot;\\n                tot=0;\\n            }\\n            n/=2;\\n        }\\n        return max+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int binaryGap(int n) {\\n        while(n%2==0)\\n            n/=2;\\n        if(n==1)\\n            return 0;\\n        int tot=0,max=0;\\n        while(n!=0){\\n            if(n%2==0)\\n                tot++;\\n            else{\\n                if(tot>max)\\n                    max=tot;\\n                tot=0;\\n            }\\n            n/=2;\\n        }\\n        return max+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 964373,
                "title": "ugly-code-but-one-pass-without-casting-to-string",
                "content": "```\\nvar binaryGap = function(n) {\\n    let max = 0;\\n    let counter = 0;\\n    let found = false;\\n    while(n){\\n        if(!found && !(n%2 == 0)){\\n          found = true;\\n          n = n>>1;\\n        } else if(found && (n%2 == 0)){\\n            counter++;\\n            n = n>>1;\\n        } else if(found && !(n%2 == 0)) {\\n            counter++;\\n            max = counter > max ? counter : max;\\n            counter = 0;\\n            found = false;\\n        } else {\\n            n = n>>1\\n        }\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\nvar binaryGap = function(n) {\\n    let max = 0;\\n    let counter = 0;\\n    let found = false;\\n    while(n){\\n        if(!found && !(n%2 == 0)){\\n          found = true;\\n          n = n>>1;\\n        } else if(found && (n%2 == 0)){\\n            counter++;\\n            n = n>>1;\\n        } else if(found && !(n%2 == 0)) {\\n            counter++;\\n            max = counter > max ? counter : max;\\n            counter = 0;\\n            found = false;\\n        } else {\\n            n = n>>1\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 929372,
                "title": "3-solutions",
                "content": "**two indices**\\n```\\nint binaryGap(int n)\\n{\\n\\tint out{0};\\n\\tfor(auto i{0}, j{32}; n; n>>=1, ++i)\\n\\t\\tif(n&1) out=max(out, i-j), j=i;\\n\\treturn out;\\n}\\n```\\n**distance**\\n```\\nint binaryGap(int n)\\n{\\n\\tint out{0};\\n\\tfor(auto i{-32}; n; n>>=1, ++i)\\n\\t\\tif(n&1) out=max(out, i), i=0;              // if(n&1) out=max(out, exchange(i, 0));\\n\\treturn out;\\n}\\n```\\n\\n**`builtin_ctz` \\u2014 `gcc` builtin function that counts the number of trailing zeroes**\\n```\\nint binaryGap(int n)\\n{\\n\\tint out{0};\\n\\tfor(auto i{32}; n; n&=n-1)\\n\\t{\\n\\t\\tout = max(out, __builtin_ctz(n)-i);\\n\\t\\ti   = __builtin_ctz(n);\\n\\t}\\n\\treturn out;\\n}\\n```\\nor\\n```\\nint binaryGap(int n)\\n{\\n\\tint out{0};\\n\\tfor(auto i{32}; n; n&=n-1)\\n\\t{\\n\\t\\tauto j = exchange(i, __builtin_ctz(n));\\n        out    = max(out, i - j);\\n\\t}\\n\\treturn out;\\n}\\n```\\n\\nHere https://leetcode.com/problems/get-maximum-in-generated-array/discuss/930626/elegant-o1-space you can  different recipes on how to write `__builtin_ctz` function yourself.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint binaryGap(int n)\\n{\\n\\tint out{0};\\n\\tfor(auto i{0}, j{32}; n; n>>=1, ++i)\\n\\t\\tif(n&1) out=max(out, i-j), j=i;\\n\\treturn out;\\n}\\n```\n```\\nint binaryGap(int n)\\n{\\n\\tint out{0};\\n\\tfor(auto i{-32}; n; n>>=1, ++i)\\n\\t\\tif(n&1) out=max(out, i), i=0;              // if(n&1) out=max(out, exchange(i, 0));\\n\\treturn out;\\n}\\n```\n```\\nint binaryGap(int n)\\n{\\n\\tint out{0};\\n\\tfor(auto i{32}; n; n&=n-1)\\n\\t{\\n\\t\\tout = max(out, __builtin_ctz(n)-i);\\n\\t\\ti   = __builtin_ctz(n);\\n\\t}\\n\\treturn out;\\n}\\n```\n```\\nint binaryGap(int n)\\n{\\n\\tint out{0};\\n\\tfor(auto i{32}; n; n&=n-1)\\n\\t{\\n\\t\\tauto j = exchange(i, __builtin_ctz(n));\\n        out    = max(out, i - j);\\n\\t}\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 806074,
                "title": "faster-than-100-c-online-submisssion",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int count=0,pos=0, maxDist =INT_MIN;\\n        while(N){\\n            count++;\\n            if(N&1){\\n                if(pos){\\n                    maxDist = max(maxDist, count-pos);\\n                    pos =count;\\n                }else{\\n                    pos =count;\\n                }\\n            }\\n            N = N>>1;\\n        }\\n        \\n        return maxDist==INT_MIN?0:maxDist;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int count=0,pos=0, maxDist =INT_MIN;\\n        while(N){\\n            count++;\\n            if(N&1){\\n                if(pos){\\n                    maxDist = max(maxDist, count-pos);\\n                    pos =count;\\n                }else{\\n                    pos =count;\\n                }\\n            }\\n            N = N>>1;\\n        }\\n        \\n        return maxDist==INT_MIN?0:maxDist;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 798058,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, N: int) -> int:\\n        \\n        def findbinary(x):\\n            if x//2 < 2:\\n                return str(x//2)+str(x%2)\\n            else:\\n                return findbinary(x//2)+str(x%2)\\n            \\n        num = findbinary(N)\\n        l = [i for i in range(len(num)) if num[i] == \\'1\\']\\n        \\n        if len(l) <= 1:\\n            return 0\\n        \\n        return max([l[i]-l[i-1] for i in range(1,len(l))])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, N: int) -> int:\\n        \\n        def findbinary(x):\\n            if x//2 < 2:\\n                return str(x//2)+str(x%2)\\n            else:\\n                return findbinary(x//2)+str(x%2)\\n            \\n        num = findbinary(N)\\n        l = [i for i in range(len(num)) if num[i] == \\'1\\']\\n        \\n        if len(l) <= 1:\\n            return 0\\n        \\n        return max([l[i]-l[i-1] for i in range(1,len(l))])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 730010,
                "title": "python3-easy-soln",
                "content": "class Solution:\\n\\n\\n    def binaryGap(self, N: int) -> int:\\n        x=str(bin(N))[2:]\\n        l=[]\\n        prev=0\\n        \\n        for i in range(len(x)):\\n            if x[i]==\\'1\\':\\n                l.append(i-prev)\\n                prev=i\\n                \\n        return max(l)\\n        \\n            \\n",
                "solutionTags": [],
                "code": "class Solution:\\n\\n\\n    def binaryGap(self, N: int) -> int:\\n        x=str(bin(N))[2:]\\n        l=[]\\n        prev=0\\n        \\n        for i in range(len(x)):\\n            if x[i]==\\'1\\':\\n                l.append(i-prev)\\n                prev=i\\n                \\n        return max(l)\\n        \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 696308,
                "title": "java-simple-neat-solution-with-two-pointers-beat-100",
                "content": "\\t// Two pointers\\n    public int binaryGap(int N) {\\n        int max = 0;\\n        \\n        int i = 0, j = -1;\\n        while (N != 0) {\\n            if ((N & 1) > 0) {\\n                if (j >= 0) {\\n                    max = Math.max(max, i - j);\\n                }\\n                j = i;\\n            }\\n            \\n            N >>>= 1;\\n            i++;\\n        }\\n        \\n        return max;\\n    }\\n",
                "solutionTags": [],
                "code": "\\t// Two pointers\\n    public int binaryGap(int N) {\\n        int max = 0;\\n        \\n        int i = 0, j = -1;\\n        while (N != 0) {\\n            if ((N & 1) > 0) {\\n                if (j >= 0) {\\n                    max = Math.max(max, i - j);\\n                }\\n                j = i;\\n            }\\n            \\n            N >>>= 1;\\n            i++;\\n        }\\n        \\n        return max;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 654605,
                "title": "simple-c-solution-o-n-easy-to-understand-with-explain",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Gap.\\nMemory Usage: 5.9 MB, less than 100.00% of C++ online submissions for Binary Gap.\\n**The problem is that find longest distance between two 1\\'s such that between them all the characters are 0;\\ne.g; 110000110 ans=5\\n11101 ans=2\\n100000001 ans=8\\n1001000100001 ans=5**\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n       string s=\"\";  //convert it into binary string\\n        while(N)\\n        {\\n            int p=N%2;\\n            if(p) s=\\'1\\'+s;\\n            else\\n                s=\\'0\\'+s;\\n            N/=2;\\n        }\\n        cout<<s<<\"\\\\n\";\\n        int i=0,k=0;\\n        while(s[i]!=\\'1\\')  //find position of first one in string\\n            i++;\\n        for(int j=i+1;j<s.length();j++)\\n            \\n        {  //cout<<i<<\" \";\\n            while(s[j]==\\'0\\') j++;  //find next position of one\\n          if(j>=s.size()) break; \\n            k=max(k,j-i); //store maximum length difference\\n            i=j;\\n         //cout<<j<<\" \\\\n\";\\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n       string s=\"\";  //convert it into binary string\\n        while(N)\\n        {\\n            int p=N%2;\\n            if(p) s=\\'1\\'+s;\\n            else\\n                s=\\'0\\'+s;\\n            N/=2;\\n        }\\n        cout<<s<<\"\\\\n\";\\n        int i=0,k=0;\\n        while(s[i]!=\\'1\\')  //find position of first one in string\\n            i++;\\n        for(int j=i+1;j<s.length();j++)\\n            \\n        {  //cout<<i<<\" \";\\n            while(s[j]==\\'0\\') j++;  //find next position of one\\n          if(j>=s.size()) break; \\n            k=max(k,j-i); //store maximum length difference\\n            i=j;\\n         //cout<<j<<\" \\\\n\";\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 645879,
                "title": "o-log-binary-n-time-o-log-binary-n-space-java-solution",
                "content": "```\\n//O(log binary(N)) time where binary(N) is the binary string representation of N\\n    //O(log binary(N)) space taken by the string\\n    public int binaryGap(int N) {\\n        String n = Integer.toString(N,2);\\n        int first =-1, second =-1;\\n        int diff = 0;\\n        \\n        for(int i=0;i<n.length();i++){\\n            if(n.charAt(i) ==\\'1\\'){\\n                if(first == -1)\\n                    first = i;\\n                else if(second == -1){\\n                    second = i;\\n                    diff = Math.max(diff, second - first);\\n                }\\n                else{\\n                    first = second;\\n                    second = i;\\n                    diff = Math.max(diff, second - first);\\n                }\\n            }\\n        }\\n        \\n        return diff;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//O(log binary(N)) time where binary(N) is the binary string representation of N\\n    //O(log binary(N)) space taken by the string\\n    public int binaryGap(int N) {\\n        String n = Integer.toString(N,2);\\n        int first =-1, second =-1;\\n        int diff = 0;\\n        \\n        for(int i=0;i<n.length();i++){\\n            if(n.charAt(i) ==\\'1\\'){\\n                if(first == -1)\\n                    first = i;\\n                else if(second == -1){\\n                    second = i;\\n                    diff = Math.max(diff, second - first);\\n                }\\n                else{\\n                    first = second;\\n                    second = i;\\n                    diff = Math.max(diff, second - first);\\n                }\\n            }\\n        }\\n        \\n        return diff;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 639188,
                "title": "java-simple-solution",
                "content": "class Solution {\\n    public int binaryGap(int n)\\n    {\\n         int[] a = new int[1000]; \\n   \\n        \\n        int i = 0; \\n        while (n > 0)  \\n        { \\n           \\n            a[i] = n % 2; \\n            n = n / 2; \\n            i++; \\n        } \\n       \\n         int k=i-1;\\n         int d=0;\\n        int b=0;\\n        int c=0;\\n        int co=0;\\n        int max=0;\\n        for (int j = i - 1; j >= 0; j--) \\n        {\\n            if(a[j]==1 && co==0)\\n            {\\n                b=j;\\n                co++;\\n            }\\n            else\\n                if(a[j]==1)\\n                {\\n                  int t=b;\\n                    c=j;\\n                    d=t-c;\\n                    max=(max>=d)?max:d;\\n                    \\n                    b=c;                    \\n                }\\n                  \\n        }\\n        \\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int binaryGap(int n)\\n    {\\n         int[] a = new int[1000]; \\n   \\n        \\n        int i = 0; \\n        while (n > 0)  \\n        { \\n           \\n            a[i] = n % 2; \\n            n = n / 2; \\n            i++; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 628726,
                "title": "0ms-c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n         vector<int>pos;\\n        for(int i=0;i<32;i++)\\n        {\\n            if((N&(1<<i)))\\n                pos.push_back(i);\\n        }\\n        int mx = 0;\\n        for(int i=1;i<pos.size();i++)\\n        {\\n            mx = max(mx,pos[i]-pos[i-1]);\\n        }\\n        return mx;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    int binaryGap(int N) {\\n         vector<int>pos;\\n        for(int i=0;i<32;i++)\\n        {\\n            if((N&(1<<i)))\\n                pos.push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 608977,
                "title": "go-solution-clean-and-fast-beats-100",
                "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Binary Gap.\\nMemory Usage: 2.1 MB, less than 100.00% of Go online submissions for Binary Gap.\\n```\\nfunc binaryGap(N int) int {\\n    cnt, maxOnes := 0, 0\\n\\t// strip \\n    for N != 0 && N & 1 != 1 {\\n        N >>= 1\\n    }\\n    for N != 0 {\\n        if N&1 == 1 {\\n            maxOnes = max(maxOnes, cnt)\\n            cnt = 0\\n        }\\n        N >>= 1\\n        cnt++\\n    }\\n    return maxOnes \\n}\\n\\nfunc max(x, y int) int {\\n    if x > y { return x }\\n    return y\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc binaryGap(N int) int {\\n    cnt, maxOnes := 0, 0\\n\\t// strip \\n    for N != 0 && N & 1 != 1 {\\n        N >>= 1\\n    }\\n    for N != 0 {\\n        if N&1 == 1 {\\n            maxOnes = max(maxOnes, cnt)\\n            cnt = 0\\n        }\\n        N >>= 1\\n        cnt++\\n    }\\n    return maxOnes \\n}\\n\\nfunc max(x, y int) int {\\n    if x > y { return x }\\n    return y\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 578704,
                "title": "java-solution-use-bit-operation",
                "content": "```\\npublic int binaryGap(int N) {\\n    int gap = 0;\\n\\n    int cur = 0;\\n    int last = 33;\\n    while (N > 0) {\\n        if ((N & 1) == 1) {\\n            gap = Math.max(cur - last, gap);\\n            last = cur;\\n        }\\n\\n        cur++;\\n        N >>>= 1;\\n    }\\n\\n    return gap;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int binaryGap(int N) {\\n    int gap = 0;\\n\\n    int cur = 0;\\n    int last = 33;\\n    while (N > 0) {\\n        if ((N & 1) == 1) {\\n            gap = Math.max(cur - last, gap);\\n            last = cur;\\n        }\\n\\n        cur++;\\n        N >>>= 1;\\n    }\\n\\n    return gap;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 537449,
                "title": "c-simple-solution-beats-100-100-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int last = -1;\\n        int max = 0;\\n        // Run through each bit \\n        for (int i = 0; i < 32; i++) {\\n            // If the bit is a 1\\n            if (N & (1 << i))  {\\n                // If this isn\\'t the first bit, check to see if the\\n                // this bit defines the new max distance\\n                if (last != -1) max = std::max(max, i - last);\\n                // Change this bit to last\\n                last = i;\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int last = -1;\\n        int max = 0;\\n        // Run through each bit \\n        for (int i = 0; i < 32; i++) {\\n            // If the bit is a 1\\n            if (N & (1 << i))  {\\n                // If this isn\\'t the first bit, check to see if the\\n                // this bit defines the new max distance\\n                if (last != -1) max = std::max(max, i - last);\\n                // Change this bit to last\\n                last = i;\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 528358,
                "title": "c-100-space-100-time-solution-o-log-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int gap = 0;\\n        int gap_so_far = 0;\\n        while(N % 2 == 0) {\\n            N /= 2;\\n        }\\n        while(N) {\\n            if (N % 2) {\\n                gap = max(gap, gap_so_far);\\n                gap_so_far = 1;\\n            } else {\\n                gap_so_far++;\\n            }\\n            N /= 2;\\n        }\\n        return gap;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int gap = 0;\\n        int gap_so_far = 0;\\n        while(N % 2 == 0) {\\n            N /= 2;\\n        }\\n        while(N) {\\n            if (N % 2) {\\n                gap = max(gap, gap_so_far);\\n                gap_so_far = 1;\\n            } else {\\n                gap_so_far++;\\n            }\\n            N /= 2;\\n        }\\n        return gap;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515335,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int binaryGap(int N) {\\n        while ((N&0x1) == 0)\\n            N = N>>1;\\n        \\n        int d = 1;\\n        int max = 0;\\n        while (N>0) {\\n            N = N>>1;\\n            if ((N&0x1) == 0) {\\n                d++;\\n            }\\n            else {\\n                max = Math.max(max, d);\\n                d = 1;\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int N) {\\n        while ((N&0x1) == 0)\\n            N = N>>1;\\n        \\n        int d = 1;\\n        int max = 0;\\n        while (N>0) {\\n            N = N>>1;\\n            if ((N&0x1) == 0) {\\n                d++;\\n            }\\n            else {\\n                max = Math.max(max, d);\\n                d = 1;\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 410886,
                "title": "c-0ms-solution-using-bitset",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        bitset<32>b(N);\\n        int last=-1,ans=0;\\n        for(int i=0;i<32;++i){\\n            if(b[i]){\\n                ans=last==-1?0:max(ans,i-last);\\n                last=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        bitset<32>b(N);\\n        int last=-1,ans=0;\\n        for(int i=0;i<32;++i){\\n            if(b[i]){\\n                ans=last==-1?0:max(ans,i-last);\\n                last=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 402093,
                "title": "java-0ms-100",
                "content": "```\\nclass Solution {\\n    public int binaryGap(int N) {\\n       int lastpos = -1;\\n\\t\\tint currentpos = -1;\\n\\t\\tint max = 0;\\n\\t\\twhile (N > 0) {\\n\\t\\t\\tint a = N % 2;\\n\\t\\t\\tcurrentpos++;\\n\\t\\t\\tif (a == 1) {\\n\\t\\t\\t\\tif (lastpos >= 0)\\n\\t\\t\\t\\t\\tmax = Math.max(max, currentpos - lastpos);\\n\\t\\t\\t\\tlastpos = currentpos;\\n\\t\\t\\t}\\n\\t\\t\\tN = N / 2;\\n\\n\\t\\t}\\n\\n\\t\\treturn max;    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int N) {\\n       int lastpos = -1;\\n\\t\\tint currentpos = -1;\\n\\t\\tint max = 0;\\n\\t\\twhile (N > 0) {\\n\\t\\t\\tint a = N % 2;\\n\\t\\t\\tcurrentpos++;\\n\\t\\t\\tif (a == 1) {\\n\\t\\t\\t\\tif (lastpos >= 0)\\n\\t\\t\\t\\t\\tmax = Math.max(max, currentpos - lastpos);\\n\\t\\t\\t\\tlastpos = currentpos;\\n\\t\\t\\t}\\n\\t\\t\\tN = N / 2;\\n\\n\\t\\t}\\n\\n\\t\\treturn max;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 377082,
                "title": "simple-solution-using-bit-manipulation-java-0ms",
                "content": "Used a very simple concept of Bitwise AND (&) to check the last bit and Right shift (>>).\\n\\nclass Solution {\\n    public int binaryGap(int N) {\\n        int res = 0;\\n        int index = -1;\\n        int i=0;\\n        \\n        while(N>0){\\n            \\n            if((N&1) == 1){\\n                if(index >= 0){\\n                    res = Math.max(res, (i-index));\\n                }\\n                index = i;\\n            }\\n            \\n            N = N >> 1;\\n            i++;\\n        }\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int binaryGap(int N) {\\n        int res = 0;\\n        int index = -1;\\n        int i=0;\\n        \\n        while(N>0){\\n            \\n            if((N&1) == 1){\\n                if(index >= 0){\\n                    res = Math.max(res, (i-index));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 360221,
                "title": "go-golang-0ms-clean-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Binary Gap.\\nMemory Usage: 2 MB, less than 100.00% of Go online submissions for Binary Gap.\\n\\n```go\\nfunc binaryGap(N int) int {\\n\\n\\ts := strconv.FormatInt(int64(N), 2)\\n\\tone := \"1\"\\n\\tindexArr := []int{}\\n\\tgap := []int{}\\n\\ttmp := 0\\n\\n\\tfor i, v := range s {\\n\\t\\tif string(v) == one {\\n\\t\\t\\tindexArr = append(indexArr, i)\\n\\t\\t}\\n\\t}\\n\\tfor i := len(indexArr); i > 0; i-- {\\n\\t\\tif i-2 >= 0 {\\n\\t\\t\\tgap = append(gap, indexArr[i-1]-indexArr[i-2])\\n\\t\\t}\\n\\t}\\n\\tfor _, v := range gap {\\n\\t\\tif v > tmp {\\n\\t\\t\\ttmp = v\\n\\t\\t}\\n\\t}\\n\\treturn tmp\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc binaryGap(N int) int {\\n\\n\\ts := strconv.FormatInt(int64(N), 2)\\n\\tone := \"1\"\\n\\tindexArr := []int{}\\n\\tgap := []int{}\\n\\ttmp := 0\\n\\n\\tfor i, v := range s {\\n\\t\\tif string(v) == one {\\n\\t\\t\\tindexArr = append(indexArr, i)\\n\\t\\t}\\n\\t}\\n\\tfor i := len(indexArr); i > 0; i-- {\\n\\t\\tif i-2 >= 0 {\\n\\t\\t\\tgap = append(gap, indexArr[i-1]-indexArr[i-2])\\n\\t\\t}\\n\\t}\\n\\tfor _, v := range gap {\\n\\t\\tif v > tmp {\\n\\t\\t\\ttmp = v\\n\\t\\t}\\n\\t}\\n\\treturn tmp\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 297792,
                "title": "simple-python-solution-faster-than-94-64-and-less-than-83-31-of-python3",
                "content": "it\\'s pretty simple solution and easy to understand \\n\\n```\\nclass Solution:\\n    def binaryGap(self, N: int) -> int:\\n        BinaryN =bin(N)\\n        BinaryN = BinaryN[2::]\\n        FoundOne = False\\n        Max=0\\n        count=0\\n\\n        for i in BinaryN:\\n            \\n            if(i == \\'1\\'):\\n                if(FoundOne == True):\\n                    Max = max(count,Max)\\n                    count =0   \\n\\n                else:\\n                    FoundOne = True\\n                    \\n            if(FoundOne):\\n                count = count+1\\n            \\n                \\n        return Max\\n                    \\n                \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, N: int) -> int:\\n        BinaryN =bin(N)\\n        BinaryN = BinaryN[2::]\\n        FoundOne = False\\n        Max=0\\n        count=0\\n\\n        for i in BinaryN:\\n            \\n            if(i == \\'1\\'):\\n                if(FoundOne == True):\\n                    Max = max(count,Max)\\n                    count =0   \\n\\n                else:\\n                    FoundOne = True\\n                    \\n            if(FoundOne):\\n                count = count+1\\n            \\n                \\n        return Max\\n                    \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 293442,
                "title": "o-log-log-n",
                "content": "```\\nint binaryGap(int x){\\n    x>>=__builtin_ctz(x);\\n    if (x==1)return 0;\\n    int y=x,s=0; y|=y>>1; y|=y>>2; y|=y>>4; y|=y>>8; y|=y>>16;\\n    if (x==y)return 1;\\n    if ((x|x>>1)!=y)x|=x>>1,s+=1;else goto l3;\\n    if ((x|x>>2)!=y)x|=x>>2,s+=2;else goto l2;\\n    if ((x|x>>4)!=y)x|=x>>4,s+=4;else goto l1;\\n    if ((x|x>>8)!=y)x|=x>>8,s+=8;\\n    if ((x|x>>4)!=y)x|=x>>4,s+=4;\\n    l1:if ((x|x>>2)!=y)x|=x>>2,s+=2;\\n    l2:if ((x|x>>1)!=y)x|=x>>1,s+=1;\\n    l3:return s+2;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint binaryGap(int x){\\n    x>>=__builtin_ctz(x);\\n    if (x==1)return 0;\\n    int y=x,s=0; y|=y>>1; y|=y>>2; y|=y>>4; y|=y>>8; y|=y>>16;\\n    if (x==y)return 1;\\n    if ((x|x>>1)!=y)x|=x>>1,s+=1;else goto l3;\\n    if ((x|x>>2)!=y)x|=x>>2,s+=2;else goto l2;\\n    if ((x|x>>4)!=y)x|=x>>4,s+=4;else goto l1;\\n    if ((x|x>>8)!=y)x|=x>>8,s+=8;\\n    if ((x|x>>4)!=y)x|=x>>4,s+=4;\\n    l1:if ((x|x>>2)!=y)x|=x>>2,s+=2;\\n    l2:if ((x|x>>1)!=y)x|=x>>1,s+=1;\\n    l3:return s+2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 286322,
                "title": "python-split-bin-n-by-1",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, N: int) -> int:\\n        a = bin(N)[2:].split(\\'1\\')[1:-1]\\n        if len(a) == 0:\\n            return 0\\n        else:\\n            return max(map(len, a)) + 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, N: int) -> int:\\n        a = bin(N)[2:].split(\\'1\\')[1:-1]\\n        if len(a) == 0:\\n            return 0\\n        else:\\n            return max(map(len, a)) + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 260480,
                "title": "functional-js-solution-faster-than-90",
                "content": "```\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nvar binaryGap = function(N) {\\n    const str = N.toString(2);\\n    const bits = str.split(\\'\\');\\n    \\n    let maxDist = 0;\\n    let countBeginIndex = 0;\\n    bits.forEach((bit, index) => {\\n        if (bit !== \\'1\\') {\\n            return;\\n        }\\n        \\n        maxDist = Math.max(index - countBeginIndex, maxDist);\\n        countBeginIndex = index;\\n    });\\n    \\n    return maxDist;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nvar binaryGap = function(N) {\\n    const str = N.toString(2);\\n    const bits = str.split(\\'\\');\\n    \\n    let maxDist = 0;\\n    let countBeginIndex = 0;\\n    bits.forEach((bit, index) => {\\n        if (bit !== \\'1\\') {\\n            return;\\n        }\\n        \\n        maxDist = Math.max(index - countBeginIndex, maxDist);\\n        countBeginIndex = index;\\n    });\\n    \\n    return maxDist;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 160233,
                "title": "fast-swift-solution",
                "content": "```\\nclass Solution {\\n    func binaryGap(_ N: Int) -> Int {\\n        let str = String(N, radix: 2)\\n\\n        let position = str.enumerated().compactMap {\\n            $0.element == \"1\" ? $0.offset : nil\\n        }\\n\\n        if position.count <= 1  {\\n            return 0\\n        } else {\\n            var curGap = abs(position[0] - position[1])\\n\\n            for index in 1..<position.count - 1 {\\n                curGap = max(curGap, abs(position[index] - position[index + 1]))\\n            }\\n\\n            return curGap\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func binaryGap(_ N: Int) -> Int {\\n        let str = String(N, radix: 2)\\n\\n        let position = str.enumerated().compactMap {\\n            $0.element == \"1\" ? $0.offset : nil\\n        }\\n\\n        if position.count <= 1  {\\n            return 0\\n        } else {\\n            var curGap = abs(position[0] - position[1])\\n\\n            for index in 1..<position.count - 1 {\\n                curGap = max(curGap, abs(position[index] - position[index + 1]))\\n            }\\n\\n            return curGap\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158803,
                "title": "c-solution-using-while-loop",
                "content": "```\\npublic class Solution\\n{\\n    public int BinaryGap(int N)\\n    {\\n        if ((N & (N - 1)) == 0) // Checks for N == 0 and N being a power of two\\n            return 0;\\n        // If the preceding condition was false then N has at leat two 1s\\n        while ((N & 1) == 0) // Find the first 1\\n            N >>= 1;\\n        N >>= 1; // Since we\\'re intrested in the gap between 1s the first 1 is skipped\\n\\t\\t\\t\\t//(otherwise it would cause an additional meaningless iteration of the following loop)\\n        int maxGap = 0;\\n        int gap = 0;\\n        while (N != 0)\\n        {\\n            if ((N & 1) == 0) // If it\\'s 0 then increase the current gap\\n                gap++;\\n            else // If it\\'s 1\\n            {\\n                if (gap > maxGap) // If current gap is bigger than the max one we change the max\\n                    maxGap = gap;\\n                gap = 0; // Reset the counter\\n            }\\n            N >>= 1;\\n        }\\n        return maxGap + 1; // Because maxGap holds the number of 0s between two 1s we increment it to represent the gap\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int BinaryGap(int N)\\n    {\\n        if ((N & (N - 1)) == 0) // Checks for N == 0 and N being a power of two\\n            return 0;\\n        // If the preceding condition was false then N has at leat two 1s\\n        while ((N & 1) == 0) // Find the first 1\\n            N >>= 1;\\n        N >>= 1; // Since we\\'re intrested in the gap between 1s the first 1 is skipped\\n\\t\\t\\t\\t//(otherwise it would cause an additional meaningless iteration of the following loop)\\n        int maxGap = 0;\\n        int gap = 0;\\n        while (N != 0)\\n        {\\n            if ((N & 1) == 0) // If it\\'s 0 then increase the current gap\\n                gap++;\\n            else // If it\\'s 1\\n            {\\n                if (gap > maxGap) // If current gap is bigger than the max one we change the max\\n                    maxGap = gap;\\n                gap = 0; // Reset the counter\\n            }\\n            N >>= 1;\\n        }\\n        return maxGap + 1; // Because maxGap holds the number of 0s between two 1s we increment it to represent the gap\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151314,
                "title": "simple-java-solution",
                "content": "```\\npublic int binaryGap(int N) {\\n        int max = 0, lastSeen=-1, tmp = 0, curr = 0;\\n        while(N != 0){\\n            tmp = N % 2;\\n            if(tmp == 1){\\n                if(lastSeen != -1) /*do not calc distance for first \\'1\\'*/\\n                    max = Math.max(max, curr-lastSeen);\\n                lastSeen = curr;\\n            }\\n            N/=2;\\n            ++curr;\\n        }\\n        return max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int binaryGap(int N) {\\n        int max = 0, lastSeen=-1, tmp = 0, curr = 0;\\n        while(N != 0){\\n            tmp = N % 2;\\n            if(tmp == 1){\\n                if(lastSeen != -1) /*do not calc distance for first \\'1\\'*/\\n                    max = Math.max(max, curr-lastSeen);\\n                lastSeen = curr;\\n            }\\n            N/=2;\\n            ++curr;\\n        }\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 150926,
                "title": "c-average-case-faster-than-simple-right-shifting-0-ms",
                "content": "```\\n\\nclass Solution {\\n   \\n    constexpr inline int trailing_zero(int n) {\\n    \\n        constexpr int table[] = {32, 0, 1,\\n            26, 2, 23, 27, 0, 3, 16, 24, 30, 28, 11,\\n            0, 13, 4, 7, 17, 0, 25, 22, 31, 15, 29,\\n            10, 12, 6, 0, 21, 14, 9, 5, 20, 8, 19,\\n            18};\\n        \\n        \\n        return table[(-n & n) % 37];        \\n    }\\n    \\npublic:\\n    int binaryGap(int N) {\\n        int m = 0;\\n        \\n        int last = trailing_zero(N);\\n        while(N) {\\n            int t = trailing_zero(N);  // computes the number of zeros to the right of the rightmost one\\n            \\n            m = max(m, t - last);\\n            last = t;\\n                        \\n            N -= (1 << t);  // Zeroes out the rightmost one\\n        }\\n        \\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n   \\n    constexpr inline int trailing_zero(int n) {\\n    \\n        constexpr int table[] = {32, 0, 1,\\n            26, 2, 23, 27, 0, 3, 16, 24, 30, 28, 11,\\n            0, 13, 4, 7, 17, 0, 25, 22, 31, 15, 29,\\n            10, 12, 6, 0, 21, 14, 9, 5, 20, 8, 19,\\n            18};\\n        \\n        \\n        return table[(-n & n) % 37];        \\n    }\\n    \\npublic:\\n    int binaryGap(int N) {\\n        int m = 0;\\n        \\n        int last = trailing_zero(N);\\n        while(N) {\\n            int t = trailing_zero(N);  // computes the number of zeros to the right of the rightmost one\\n            \\n            m = max(m, t - last);\\n            last = t;\\n                        \\n            N -= (1 << t);  // Zeroes out the rightmost one\\n        }\\n        \\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150846,
                "title": "python-solution-using-3-if-statements-and-a-counter",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        max_num = 0\\n        counting = False\\n        counter = 0\\n        binary = bin(N)\\n        \\n        for index in range(0, len(binary)):\\n            \\n            if (binary[index] == \\'1\\') and (counting == False):\\n                counting = True\\n                \\n            elif (binary[index] != \\'1\\') and (counting == True):\\n                counter += 1\\n                \\n            elif (binary[index] == \\'1\\') and (counting == True):\\n                counter += 1\\n                if counter > max_num:\\n                    max_num = counter\\n                counter = 0\\n                \\n        return max_num\\n\\t\\t\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        max_num = 0\\n        counting = False\\n        counter = 0\\n        binary = bin(N)\\n        \\n        for index in range(0, len(binary)):\\n            \\n            if (binary[index] == \\'1\\') and (counting == False):\\n                counting = True\\n                \\n            elif (binary[index] != \\'1\\') and (counting == True):\\n                counter += 1\\n                \\n            elif (binary[index] == \\'1\\') and (counting == True):\\n                counter += 1\\n                if counter > max_num:\\n                    max_num = counter\\n                counter = 0\\n                \\n        return max_num\\n\\t\\t\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 149904,
                "title": "c-like-languages-o-1-simple-solution",
                "content": "In fact, I realized that it\\'s O(log N) thanks to [@sasha.pad](https://leetcode.com/sashapad) reminded me. Sorry to showed an inaccurate statement to you.\\n```C\\nint binaryGap(int N) {\\n    int max = 0;\\n    int dis = 0;\\n    // get the rightmost 1\\n    while (N % 2 == 0)\\n        N >>= 1;\\n    // find the max distance\\n    while (N != 0) {\\n        N >>= 1;\\n        ++dis;\\n        if (N % 2 == 1) {\\n            if (dis > max)\\n                max = dis;\\n            dis = 0;\\n        }\\n    }\\n    return max;\\n}\\n```",
                "solutionTags": [],
                "code": "```C\\nint binaryGap(int N) {\\n    int max = 0;\\n    int dis = 0;\\n    // get the rightmost 1\\n    while (N % 2 == 0)\\n        N >>= 1;\\n    // find the max distance\\n    while (N != 0) {\\n        N >>= 1;\\n        ++dis;\\n        if (N % 2 == 1) {\\n            if (dis > max)\\n                max = dis;\\n            dis = 0;\\n        }\\n    }\\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 149841,
                "title": "simple-java-o-1-time",
                "content": "Just maintain a variable which is a power of 2 (i.e. contains only 1 one). We right shift this every time in a loop taking at max 32 right shfift for an integer. Simply keep track of `lastPosition` where we found a one and a `max` distance between 1\\'s. \\n```\\nclass  Solution {\\n    public int binaryGap(int N) {\\n        int dist = 1, lastPos = -1, incr = 0 ; \\n        int max = Integer.MIN_VALUE; \\n        while(dist <= N){\\n            dist = 1 << incr; \\n            if((dist & N) > 0 ){\\n                if(lastPos != -1)max = Math.max(max, incr - lastPos); \\n                lastPos = incr; \\n            }\\n            incr++; \\n        }\\n        return max==Integer.MIN_VALUE ? 0 : max; \\n    }\\n}\\n```\\n\\nA bit more compact version \\n```\\nclass Solution {\\n    public int binaryGap(int N) {\\n        int max = Integer.MIN_VALUE; \\n        for(int dist = 1, lastPos = -1, incr = 0; (dist = (1 << incr)) <= N; incr++)\\n            if((dist & N) > 0 ){\\n                if(lastPos != -1)max = Math.max(max, incr - lastPos); \\n                lastPos = incr ;\\n            }\\n        return max==Integer.MIN_VALUE ? 0 : max; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass  Solution {\\n    public int binaryGap(int N) {\\n        int dist = 1, lastPos = -1, incr = 0 ; \\n        int max = Integer.MIN_VALUE; \\n        while(dist <= N){\\n            dist = 1 << incr; \\n            if((dist & N) > 0 ){\\n                if(lastPos != -1)max = Math.max(max, incr - lastPos); \\n                lastPos = incr; \\n            }\\n            incr++; \\n        }\\n        return max==Integer.MIN_VALUE ? 0 : max; \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int binaryGap(int N) {\\n        int max = Integer.MIN_VALUE; \\n        for(int dist = 1, lastPos = -1, incr = 0; (dist = (1 << incr)) <= N; incr++)\\n            if((dist & N) > 0 ){\\n                if(lastPos != -1)max = Math.max(max, incr - lastPos); \\n                lastPos = incr ;\\n            }\\n        return max==Integer.MIN_VALUE ? 0 : max; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086691,
                "title": "bitset-lib",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n      bitset<sizeof(int) * 8> binary(n);\\n      string binaryStr = binary.to_string();\\n      int last1 = -1;\\n      int gap = 0;\\n      for (int i = 0; i < binaryStr.size(); ++i) {\\n        char cur = binaryStr[i];\\n        if (cur == \\'1\\') {\\n          if (last1 >= 0) {\\n            int diff = i - last1;\\n            gap = max(gap,diff);\\n          }\\n          last1 = i;\\n        }\\n      }\\n      return gap;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n      bitset<sizeof(int) * 8> binary(n);\\n      string binaryStr = binary.to_string();\\n      int last1 = -1;\\n      int gap = 0;\\n      for (int i = 0; i < binaryStr.size(); ++i) {\\n        char cur = binaryStr[i];\\n        if (cur == \\'1\\') {\\n          if (last1 >= 0) {\\n            int diff = i - last1;\\n            gap = max(gap,diff);\\n          }\\n          last1 = i;\\n        }\\n      }\\n      return gap;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055804,
                "title": "c-easy-and-readable-solution-faster-than-70",
                "content": "![image.png](https://assets.leetcode.com/users/images/aaf78b84-c2d4-40bf-89c6-7aa0d31faa17_1694955763.498142.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public int BinaryGap(int n) {\\n        int previouse = 32;\\n        int distance = 0;\\n        int pos = 0;\\n        while (n > 0)\\n        {\\n            if (n % 2 == 1)\\n            {\\n                distance = Math.Max(distance, pos - previouse);\\n                previouse = pos;\\n            }\\n            n /= 2;\\n            pos++;\\n        }\\n        return distance;\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int BinaryGap(int n) {\\n        int previouse = 32;\\n        int distance = 0;\\n        int pos = 0;\\n        while (n > 0)\\n        {\\n            if (n % 2 == 1)\\n            {\\n                distance = Math.Max(distance, pos - previouse);\\n                previouse = pos;\\n            }\\n            n /= 2;\\n            pos++;\\n        }\\n        return distance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054572,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n     public int binaryGap(int n) {\\n        int lastPos =-1;\\n        int max = 0;\\n        int pos =0;\\n        \\n       while(n>0){\\n         pos++;\\n           if((n&1)==1){\\n               if(lastPos!=-1){\\n                   max = Math.max(max, pos-lastPos);\\n               }\\n               lastPos = pos;\\n           }\\n           n= n/2;\\n       }\\n        return max;\\n        \\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\n public:\\n  int BinaryGap(int n) {\\n    int index = 0, prev_index = -1;\\n    int max_distance = 0;\\n\\n    while (n) {\\n      if (n & 1) {\\n        if (prev_index != -1)\\n          max_distance = std::max(max_distance, index - prev_index);\\n        prev_index = index;\\n      }\\n      n >>= 1, index++;\\n    }\\n\\n    return max_distance;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n     public int binaryGap(int n) {\\n        int lastPos =-1;\\n        int max = 0;\\n        int pos =0;\\n        \\n       while(n>0){\\n         pos++;\\n           if((n&1)==1){\\n               if(lastPos!=-1){\\n                   max = Math.max(max, pos-lastPos);\\n               }\\n               lastPos = pos;\\n           }\\n           n= n/2;\\n       }\\n        return max;\\n        \\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\n public:\\n  int BinaryGap(int n) {\\n    int index = 0, prev_index = -1;\\n    int max_distance = 0;\\n\\n    while (n) {\\n      if (n & 1) {\\n        if (prev_index != -1)\\n          max_distance = std::max(max_distance, index - prev_index);\\n        prev_index = index;\\n      }\\n      n >>= 1, index++;\\n    }\\n\\n    return max_distance;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048317,
                "title": "fastest-c-single-pass-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) { \\n        int distance=0;\\n        int last=-1;\\n        int i=1;\\n        while(n)\\n        {\\n            if((n&1)==1)\\n            {\\n                if(i-last!=i+1)\\n                distance=max(distance,i-last);\\n                last=i;\\n            }\\n            n=n>>1;\\n            i++;\\n        }\\n        return distance;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) { \\n        int distance=0;\\n        int last=-1;\\n        int i=1;\\n        while(n)\\n        {\\n            if((n&1)==1)\\n            {\\n                if(i-last!=i+1)\\n                distance=max(distance,i-last);\\n                last=i;\\n            }\\n            n=n>>1;\\n            i++;\\n        }\\n        return distance;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048241,
                "title": "fastest-c-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(logn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        vector<int> positions;\\n        int i=1;\\n        while(n)\\n        {\\n            if((n&1)==1)\\n            {\\n                positions.push_back(i);\\n            }\\n            n=n>>1;\\n            i++;\\n        }\\n        int ans=INT_MIN;\\n        for(int i=1;i<positions.size();i++)\\n        ans=max(ans,positions[i]-positions[i-1]);\\n        if(ans==INT_MIN)\\n        return 0;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        vector<int> positions;\\n        int i=1;\\n        while(n)\\n        {\\n            if((n&1)==1)\\n            {\\n                positions.push_back(i);\\n            }\\n            n=n>>1;\\n            i++;\\n        }\\n        int ans=INT_MIN;\\n        for(int i=1;i<positions.size();i++)\\n        ans=max(ans,positions[i]-positions[i-1]);\\n        if(ans==INT_MIN)\\n        return 0;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037525,
                "title": "100-faster-with-branchless-techniques",
                "content": "# Intuition\\nMy attempt to get rid of as much branching as possible, even though the compiler will probably do better with optimization flags.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        auto max_distance = 0;\\n        while (!(n & 1)) n >>= 1;\\n        auto distance = 0;\\n        while (n != 0) {\\n            const bool increase = (max_distance - distance) & (1 << 31);\\n            max_distance = increase * distance + (!increase) * max_distance;\\n            distance = !(n & 1) * distance + 1;\\n            n >>= 1;\\n        }\\n        return max_distance;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        auto max_distance = 0;\\n        while (!(n & 1)) n >>= 1;\\n        auto distance = 0;\\n        while (n != 0) {\\n            const bool increase = (max_distance - distance) & (1 << 31);\\n            max_distance = increase * distance + (!increase) * max_distance;\\n            distance = !(n & 1) * distance + 1;\\n            n >>= 1;\\n        }\\n        return max_distance;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031355,
                "title": "for-loop-java-sol",
                "content": "# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n            String b = Integer.toBinaryString(n);\\n    int max = 0, t = 0, j = b.indexOf(\\'1\\');\\n\\n    // System.out.println(b);\\n    // System.out.println(b.indexOf(\\'1\\'));\\n\\n    for (int i = j + 1; i < b.length(); i++) {\\n      if (b.charAt(i) == \\'1\\') {\\n        t = i - j;\\n        max = Math.max(t, max);\\n        j = i;\\n      }\\n    }\\n    return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n            String b = Integer.toBinaryString(n);\\n    int max = 0, t = 0, j = b.indexOf(\\'1\\');\\n\\n    // System.out.println(b);\\n    // System.out.println(b.indexOf(\\'1\\'));\\n\\n    for (int i = j + 1; i < b.length(); i++) {\\n      if (b.charAt(i) == \\'1\\') {\\n        t = i - j;\\n        max = Math.max(t, max);\\n        j = i;\\n      }\\n    }\\n    return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030878,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int ans=0;\\n        int count=0;\\n        if((n&(n-1))==0){\\n            return 0;\\n        }\\n        boolean yes=false;\\n        while(n>0){\\n            if((n&1)==1){\\n                if(count>ans){\\n                    ans=count;\\n                }\\n                count=1;\\n                yes=true;\\n            }\\n            if((n&1)==0){\\n                if(yes==true){\\n                    count++;\\n                }  \\n            }\\n            n=n>>1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int ans=0;\\n        int count=0;\\n        if((n&(n-1))==0){\\n            return 0;\\n        }\\n        boolean yes=false;\\n        while(n>0){\\n            if((n&1)==1){\\n                if(count>ans){\\n                    ans=count;\\n                }\\n                count=1;\\n                yes=true;\\n            }\\n            if((n&1)==0){\\n                if(yes==true){\\n                    count++;\\n                }  \\n            }\\n            n=n>>1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024404,
                "title": "easy-python-solution-using-list-comprehension-and-bin-function-beats-81",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/b25e8437-66c7-427b-9cf4-7703085d7645_1694311239.7161283.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        a=(bin(n))[2:]\\n        l=[i for i in range(len(a)) if a[i]==\"1\"]\\n        temp=0\\n        for i in range(len(l)-1):\\n            x=l[i+1]-l[i]\\n            if x>temp:\\n                temp=x\\n        return temp\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        a=(bin(n))[2:]\\n        l=[i for i in range(len(a)) if a[i]==\"1\"]\\n        temp=0\\n        for i in range(len(l)-1):\\n            x=l[i+1]-l[i]\\n            if x>temp:\\n                temp=x\\n        return temp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017029,
                "title": "java-solution-using-bit-manipulation",
                "content": "# Intuition\\nUsing bit operations like and operation with 1 followed by right shift of 1 we can solve this.\\n\\n# Approach\\n(n & 1) will yeild right most bit. Whenever we see right most bit as 1, we will compare is there any max previous distance. If it is not 1 then we increment the distance.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int count = 0;\\n        int max = 0;\\n        while(n > 0) {\\n            if ((n & 1) == 1) {\\n                max = Math.max(count, max);\\n                count = 1;\\n            } else if(count > 0) {\\n                count++;\\n            }\\n            n >>= 1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int count = 0;\\n        int max = 0;\\n        while(n > 0) {\\n            if ((n & 1) == 1) {\\n                max = Math.max(count, max);\\n                count = 1;\\n            } else if(count > 0) {\\n                count++;\\n            }\\n            n >>= 1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011074,
                "title": "python-rust-solutions",
                "content": "# Code\\n```python []\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        result, prev = 0, None\\n        for index, char in enumerate(f\"{n:b}\"):\\n            if char == \"1\":\\n                if prev is not None:\\n                    result = max(result, index - prev)\\n                prev = index\\n\\n        return result\\n```\\n```rust []\\nimpl Solution {\\n    pub fn binary_gap(n: i32) -> i32 {\\n        let mut result = usize::MIN;\\n        let mut prev: Option<usize> = None;\\n\\n        for (index, char) in format!(\"{:b}\", n).char_indices() {\\n            if char == \\'1\\' {\\n                if let Some(x) = prev {\\n                    result = result.max(index - x);\\n                }\\n                prev = Some(index);\\n            }\\n        }\\n\\n        result as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python3",
                    "Rust"
                ],
                "code": "```python []\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        result, prev = 0, None\\n        for index, char in enumerate(f\"{n:b}\"):\\n            if char == \"1\":\\n                if prev is not None:\\n                    result = max(result, index - prev)\\n                prev = index\\n\\n        return result\\n```\n```rust []\\nimpl Solution {\\n    pub fn binary_gap(n: i32) -> i32 {\\n        let mut result = usize::MIN;\\n        let mut prev: Option<usize> = None;\\n\\n        for (index, char) in format!(\"{:b}\", n).char_indices() {\\n            if char == \\'1\\' {\\n                if let Some(x) = prev {\\n                    result = result.max(index - x);\\n                }\\n                prev = Some(index);\\n            }\\n        }\\n\\n        result as _\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010516,
                "title": "typescript-javascript-regex-solution",
                "content": "```ts\\nfunction binaryGap(n: number): number {\\n    const bin = n.toString(2);\\n    const timeAppear: number = `${bin}`.match(/1/g)?.length || 0;\\n    if(timeAppear < 2) return 0;\\n    let maxGap: number = 0;\\n    let gap: number = 0;\\n    const binArr = bin.replace(/^0+|0+$/g, \"\").split(\\'\\');\\n    for(let num of binArr){\\n        gap++;\\n        if(gap > maxGap) maxGap = gap;\\n        if(num == \\'1\\') gap = 0;\\n    }\\n    return maxGap;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```ts\\nfunction binaryGap(n: number): number {\\n    const bin = n.toString(2);\\n    const timeAppear: number = `${bin}`.match(/1/g)?.length || 0;\\n    if(timeAppear < 2) return 0;\\n    let maxGap: number = 0;\\n    let gap: number = 0;\\n    const binArr = bin.replace(/^0+|0+$/g, \"\").split(\\'\\');\\n    for(let num of binArr){\\n        gap++;\\n        if(gap > maxGap) maxGap = gap;\\n        if(num == \\'1\\') gap = 0;\\n    }\\n    return maxGap;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4004034,
                "title": "the-best-available-solution-that-beats-100-of-existing-solution",
                "content": "# Intuition\\nThe problem requires finding the maximum distance between two \\'1\\'s in the binary representation of a given integer \\'n\\'. To solve this problem, you can first convert the integer \\'n\\' to its binary representation as a string, and then iterate through the string to find the maximum gap between two \\'1\\'s. This gap represents the distance between two consecutive \\'1\\'s in the binary representation.\\n\\n# Approach\\n1. Initialize an empty string \\'bin\\' to store the binary representation of \\'n\\'.\\n2. Initialize a variable \\'result\\' to store the maximum binary gap, initially set to 0.\\n3. Use a while loop to convert \\'n\\' to its binary representation:\\n   a. Check if \\'n\\' is even (n % 2 == 0), and if so, insert \\'0\\' at the beginning of the \\'bin\\' string.\\n   b. Otherwise, insert \\'1\\' at the beginning of the \\'bin\\' string.\\n   c. Update \\'n\\' by performing integer division by 2 (n /= 2).\\n4. Initialize a temporary variable \\'temp\\' to 0, which will be used to keep track of the current binary gap.\\n5. Iterate through the \\'bin\\' string:\\n   a. If the current character is \\'1\\' and \\'temp\\' is 0, increment \\'temp\\' by 1.\\n   b. If the current character is \\'0\\', increment \\'temp\\' by 1.\\n   c. If the current character is \\'1\\' and \\'temp\\' is not 0, update \\'result\\' with the maximum of \\'result\\' and \\'temp\\', then reset \\'temp\\' to 1.\\n6. After the loop, return \\'result\\' as the maximum binary gap.\\n\\n# Complexity\\n- Time complexity: The time complexity of this solution depends on the number of bits in the binary representation of \\'n\\'. In the worst case, \\'n\\' has \\'log2(n)\\' bits. Therefore, the time complexity is O(log n) for converting \\'n\\' to its binary representation and O(log n) for iterating through the binary representation, resulting in an overall time complexity of O(log n).\\n\\n- Space complexity: Space Complexity: The space complexity is determined by the space needed for the \\'bin\\' string, which stores the binary representation of \\'n\\'. In the worst case, the length of the binary representation is \\'log2(n)\\' characters. Thus, the space complexity is O(log n) for the \\'bin\\' string, and O(1) for other variables.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        string bin;\\n        int result = 0;\\n        while(n > 0)\\n        {\\n            if(n % 2 == 0){\\n                bin.insert(bin.begin() + 0, \\'0\\');\\n            }\\n            else{\\n                bin.insert(bin.begin() + 0, \\'1\\');\\n            }\\n            n /= 2;\\n        }\\n        int temp = 0;\\n        for(int i = 0; i < bin.length(); ++i)\\n        {\\n            if((bin[i] == \\'1\\' && temp == 0) || bin[i] == \\'0\\')\\n            {\\n                ++temp;\\n            }\\n            else{\\n                if(result < temp)\\n                    result = temp;\\n                temp = 1;\\n            }\\n        }\\n        return result;\\n        \\n    }\\n}; \\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        string bin;\\n        int result = 0;\\n        while(n > 0)\\n        {\\n            if(n % 2 == 0){\\n                bin.insert(bin.begin() + 0, \\'0\\');\\n            }\\n            else{\\n                bin.insert(bin.begin() + 0, \\'1\\');\\n            }\\n            n /= 2;\\n        }\\n        int temp = 0;\\n        for(int i = 0; i < bin.length(); ++i)\\n        {\\n            if((bin[i] == \\'1\\' && temp == 0) || bin[i] == \\'0\\')\\n            {\\n                ++temp;\\n            }\\n            else{\\n                if(result < temp)\\n                    result = temp;\\n                temp = 1;\\n            }\\n        }\\n        return result;\\n        \\n    }\\n}; \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980521,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        def adjDif(arr):\\n            ans = 0\\n            for i in range(len(arr) - 1):\\n                if arr[i + 1] - arr[i] > ans:\\n                    ans = arr[i + 1] - arr[i]\\n            return ans\\n\\n\\n        index = []\\n        arr = list(str(bin(n))[2:])\\n\\n        for i in range(len(arr)):\\n            if arr[i] == \\'1\\':\\n                index.append(i)\\n                \\n        return adjDif(index)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        def adjDif(arr):\\n            ans = 0\\n            for i in range(len(arr) - 1):\\n                if arr[i + 1] - arr[i] > ans:\\n                    ans = arr[i + 1] - arr[i]\\n            return ans\\n\\n\\n        index = []\\n        arr = list(str(bin(n))[2:])\\n\\n        for i in range(len(arr)):\\n            if arr[i] == \\'1\\':\\n                index.append(i)\\n                \\n        return adjDif(index)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967409,
                "title": "c-solution-with-tc-o-logn-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int BinaryGap(int n) {\\n        int ans=0;\\n        bool countS=false;\\n        int i=0;\\n        while(n>0){\\n            if((n&1)==1){\\n                countS=true;\\n                ans=Math.Max(ans,i);\\n                i=1;\\n            }else{\\n                if(countS)\\n                   i++;     \\n            }\\n            n=n>>1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int BinaryGap(int n) {\\n        int ans=0;\\n        bool countS=false;\\n        int i=0;\\n        while(n>0){\\n            if((n&1)==1){\\n                countS=true;\\n                ans=Math.Max(ans,i);\\n                i=1;\\n            }else{\\n                if(countS)\\n                   i++;     \\n            }\\n            n=n>>1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960208,
                "title": "ugly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nMy ugly solution\\n```\\nimpl Solution {\\n    pub fn binary_gap(n: i32) -> i32 {\\n        let mut res_vec: Vec<i32> = Vec::new();\\n        let mut res: i32 = 0;\\n        let str = format!(\"{:b}\", n);\\n        if str.matches(\\'1\\').count() > 1 {\\n            for i in 0..str.len() {\\n                res += 1;\\n                if str.as_bytes()[i] as char == \\'1\\' {\\n                    res_vec.push(res);\\n                    res = 0;\\n                }\\n            }\\n            match res_vec.iter().max() {\\n                Some(max) => return *max,\\n                None => {},\\n            }\\n        } \\n        0\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn binary_gap(n: i32) -> i32 {\\n        let mut res_vec: Vec<i32> = Vec::new();\\n        let mut res: i32 = 0;\\n        let str = format!(\"{:b}\", n);\\n        if str.matches(\\'1\\').count() > 1 {\\n            for i in 0..str.len() {\\n                res += 1;\\n                if str.as_bytes()[i] as char == \\'1\\' {\\n                    res_vec.push(res);\\n                    res = 0;\\n                }\\n            }\\n            match res_vec.iter().max() {\\n                Some(max) => return *max,\\n                None => {},\\n            }\\n        } \\n        0\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3952135,
                "title": "mom-we-have-java-solution-at-home-java-solution-at-home",
                "content": "# Approach\\nIn this solution, we are processing the input in multiple steps. First, we are converting the integer value to a binary string (I felt like it will be easier to check every characters). Then chop off the zeros before and after the \\'1\\'s.\\n\\nAt this point, we have to see if there is only a single \\'1\\' character in the string. If so, there can\\'t be a distance value.\\n\\nWe define an ArrayList to keep all distances we counted with the for loop. After that, if there is at least a distance element in the arraylist, we are finding the maximum and return the result. \\u2615\\n\\nThis may seem ugly but I think this is a really simple and easy to understand solution. \\uD83D\\uDE4C\\n\\nPlease leave an upvote, to keep a random person motivated \\uD83D\\uDC7D\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(log(n))$$\\n\\n- Space complexity:\\n$$O(log(n))$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        // Convert n to binary string.\\n        String binaryString = Integer.toBinaryString(n);\\n        \\n        // Remove the leading and the trailing zeros.\\n        int start = binaryString.indexOf(\\'1\\');\\n        int end = binaryString.lastIndexOf(\\'1\\');\\n        binaryString = binaryString.substring(start, end + 1);\\n\\n        // Check the cases where there is zero or one \\'1\\'.\\n        if (binaryString.length() <= 1) { return 0; }\\n\\n        // Count zeros and store the distances in an arraylist.\\n        ArrayList<Integer> distances = new ArrayList<>();\\n        int counter = 1;\\n        for (int i = 1; i < binaryString.length(); i++) {\\n            if (binaryString.charAt(i) == \\'1\\') {\\n                distances.add(counter);\\n                counter = 0;\\n            }\\n            counter += 1;\\n        }\\n\\n        // If there was no gap between ones, return 1.\\n        if (distances.size() == 0) { return 1; }\\n\\n        // Get the max distance.\\n        int max = 1;\\n        for (int distance : distances) {\\n            if (distance > max) {\\n                max = distance;\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        // Convert n to binary string.\\n        String binaryString = Integer.toBinaryString(n);\\n        \\n        // Remove the leading and the trailing zeros.\\n        int start = binaryString.indexOf(\\'1\\');\\n        int end = binaryString.lastIndexOf(\\'1\\');\\n        binaryString = binaryString.substring(start, end + 1);\\n\\n        // Check the cases where there is zero or one \\'1\\'.\\n        if (binaryString.length() <= 1) { return 0; }\\n\\n        // Count zeros and store the distances in an arraylist.\\n        ArrayList<Integer> distances = new ArrayList<>();\\n        int counter = 1;\\n        for (int i = 1; i < binaryString.length(); i++) {\\n            if (binaryString.charAt(i) == \\'1\\') {\\n                distances.add(counter);\\n                counter = 0;\\n            }\\n            counter += 1;\\n        }\\n\\n        // If there was no gap between ones, return 1.\\n        if (distances.size() == 0) { return 1; }\\n\\n        // Get the max distance.\\n        int max = 1;\\n        for (int distance : distances) {\\n            if (distance > max) {\\n                max = distance;\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949547,
                "title": "python-beats-100-get-1s-indices",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        ones = [i for i,v in enumerate(bin(n)) if v==\\'1\\']\\n        maxi = 0\\n        for i in range(1,len(ones)):\\n            maxi = max(maxi, ones[i]-ones[i-1])\\n        return maxi\\n```\\n\\n![image](https://assets.leetcode.com/users/images/2eb9ab23-c46f-475e-8683-48b3aa516616_1692786972.5100787.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        ones = [i for i,v in enumerate(bin(n)) if v==\\'1\\']\\n        maxi = 0\\n        for i in range(1,len(ones)):\\n            maxi = max(maxi, ones[i]-ones[i-1])\\n        return maxi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943485,
                "title": "optimized-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int maxDistance = 0;\\n        int lastOnePos = -1;\\n        int bitPos = 0;\\n        \\n        while (n > 0) {\\n            if ((n & 1) == 1) {\\n                if (lastOnePos != -1) {\\n                    maxDistance = Math.max(maxDistance, bitPos - lastOnePos);\\n                }\\n                lastOnePos = bitPos;\\n            }\\n            n >>= 1;\\n            bitPos++;\\n        }\\n        \\n        return maxDistance;\\n        }\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int maxDistance = 0;\\n        int lastOnePos = -1;\\n        int bitPos = 0;\\n        \\n        while (n > 0) {\\n            if ((n & 1) == 1) {\\n                if (lastOnePos != -1) {\\n                    maxDistance = Math.max(maxDistance, bitPos - lastOnePos);\\n                }\\n                lastOnePos = bitPos;\\n            }\\n            n >>= 1;\\n            bitPos++;\\n        }\\n        \\n        return maxDistance;\\n        }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939109,
                "title": "1ms-o-n-time-complexity-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int largest = 0;\\n        int lastOne = -1;\\n        char[] digits = Integer.toBinaryString(n).toCharArray();\\n        for (int i =0; i < digits.length; i++ ) {\\n            if (digits[i] == \\'1\\') {\\n                if (lastOne > -1) {\\n                    largest = Math.max(largest, i - lastOne);\\n                    lastOne = i;\\n                }\\n                if (lastOne == -1) { lastOne = i;}\\n            }\\n        }\\n\\n        return largest;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int largest = 0;\\n        int lastOne = -1;\\n        char[] digits = Integer.toBinaryString(n).toCharArray();\\n        for (int i =0; i < digits.length; i++ ) {\\n            if (digits[i] == \\'1\\') {\\n                if (lastOne > -1) {\\n                    largest = Math.max(largest, i - lastOne);\\n                    lastOne = i;\\n                }\\n                if (lastOne == -1) { lastOne = i;}\\n            }\\n        }\\n\\n        return largest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929262,
                "title": "python-beats-100-time",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/74782748-f21c-4d2a-bd3d-9b8be148fde0_1692415205.3358538.png)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def binaryGap(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        s = bin(n)[2:]\\n        track = False\\n        res = 0\\n        curr = 0\\n        for c in s:\\n            if int(c) == 1 and track:\\n                res = max(curr, res)\\n                curr = 1\\n            elif int(c) == 1 and not track:\\n                track = True\\n                curr += 1\\n            else:\\n                curr += 1\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def binaryGap(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        s = bin(n)[2:]\\n        track = False\\n        res = 0\\n        curr = 0\\n        for c in s:\\n            if int(c) == 1 and track:\\n                res = max(curr, res)\\n                curr = 1\\n            elif int(c) == 1 and not track:\\n                track = True\\n                curr += 1\\n            else:\\n                curr += 1\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914260,
                "title": "step-by-step",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        w = bin(n)[2:]\\n        mx = 0\\n        start = 0\\n        i = 0\\n        zero = False\\n        for ch in w:\\n            # print(zero, ch)\\n            if ch == \\'1\\':\\n                mx = max(mx, i-start)\\n                start = i\\n\\n            i += 1\\n        return mx\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        w = bin(n)[2:]\\n        mx = 0\\n        start = 0\\n        i = 0\\n        zero = False\\n        for ch in w:\\n            # print(zero, ch)\\n            if ch == \\'1\\':\\n                mx = max(mx, i-start)\\n                start = i\\n\\n            i += 1\\n        return mx\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903222,
                "title": "c-easy-sol-without-storing-the-binary-in-a-variable",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int rem,result=0,dis=0,i=0,flag=0;\\n        while(n){\\n            rem=n%2;\\n            if(rem==1){\\n                if(flag!=0){\\n                    result=max(result,i-dis);\\n                    dis=i;\\n                }\\n                if(flag==0){\\n                    flag=1;\\n                    dis=i;\\n                }\\n            }\\n            n=n/2;\\n            i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int rem,result=0,dis=0,i=0,flag=0;\\n        while(n){\\n            rem=n%2;\\n            if(rem==1){\\n                if(flag!=0){\\n                    result=max(result,i-dis);\\n                    dis=i;\\n                }\\n                if(flag==0){\\n                    flag=1;\\n                    dis=i;\\n                }\\n            }\\n            n=n/2;\\n            i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892743,
                "title": "python-beats-90",
                "content": "# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n\\n        n = list(bin(n)[2:])\\n\\n        if n.count(\\'1\\') == 1 or n.count(\\'1\\') == 0:\\n            return 0\\n\\n        output = 0\\n        for i in range(len(n)):\\n            temp = 0\\n            if n[i] == \\'1\\':\\n                for x in range(i+1,len(n)):\\n                    if n[x] == \\'1\\':\\n                        temp+=1\\n                        output = max(output,temp)\\n                        break\\n                    else:\\n                        temp+=1                    \\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n\\n        n = list(bin(n)[2:])\\n\\n        if n.count(\\'1\\') == 1 or n.count(\\'1\\') == 0:\\n            return 0\\n\\n        output = 0\\n        for i in range(len(n)):\\n            temp = 0\\n            if n[i] == \\'1\\':\\n                for x in range(i+1,len(n)):\\n                    if n[x] == \\'1\\':\\n                        temp+=1\\n                        output = max(output,temp)\\n                        break\\n                    else:\\n                        temp+=1                    \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889546,
                "title": "quick-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int counter = 0;\\n        int maxCount = 0;\\n        int mask = 1;\\n        bool flag = false;\\n        while(n > 0) {\\n            // getting the first bit from the right\\n            if(n&mask == 1) {\\n                // there is one\\n                flag = true;\\n                maxCount = max(maxCount, counter);\\n                counter = 0;\\n            }\\n            if(flag == true){\\n                counter++;\\n            }\\n            n = n >> 1;\\n        }\\n        return maxCount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int counter = 0;\\n        int maxCount = 0;\\n        int mask = 1;\\n        bool flag = false;\\n        while(n > 0) {\\n            // getting the first bit from the right\\n            if(n&mask == 1) {\\n                // there is one\\n                flag = true;\\n                maxCount = max(maxCount, counter);\\n                counter = 0;\\n            }\\n            if(flag == true){\\n                counter++;\\n            }\\n            n = n >> 1;\\n        }\\n        return maxCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888853,
                "title": "c-simplest-solution-using-bit-manipulation",
                "content": "# Complexity\\n- Time complexity:\\nO(log n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n\\n        int ans = 0;\\n        int cnt = 0;\\n        int flag = 0;\\n\\n        while(n > 0) {\\n            if(n % 2 == 0) {\\n                if(flag == 1) {\\n                    cnt++;\\n                }\\n            }\\n            else {\\n                if(flag == 0) \\n                    flag = 1;\\n                else {\\n                    ans = max(cnt+1, ans);\\n                    cnt = 0;\\n                }\\n            }\\n            n = n/2;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n\\n        int ans = 0;\\n        int cnt = 0;\\n        int flag = 0;\\n\\n        while(n > 0) {\\n            if(n % 2 == 0) {\\n                if(flag == 1) {\\n                    cnt++;\\n                }\\n            }\\n            else {\\n                if(flag == 0) \\n                    flag = 1;\\n                else {\\n                    ans = max(cnt+1, ans);\\n                    cnt = 0;\\n                }\\n            }\\n            n = n/2;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855124,
                "title": "strictly-bit-manipulation-beats-100-explained-java",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBroke the problem down into steps:\\n\\n1. Iterate through each bit of the number\\n2. Count the number of zeroes between each pair of ones\\n3. return the greatest \\'gap\\'.\\n\\n---\\nThe following code iterates through the each bit from right to left:\\n```\\nwhile(n != 0){\\n    int a = n & 1; // retrieves the rightmost bit.\\n    n >>= 1; // performs a logical bitewise shift right.\\n}\\n```\\nThis boolean variable ensures that the counter \"runningCount\" does not begin counting the zeroes until the first \"1\" is encountered:\\n```\\nboolean first = true;\\n```\\nWhen a second \"1\" bit is encountered, a check is made to see if the \"runningCount\" is greater than the recorded \"max\" count and \"max\" is updated accordingly.\\n\\n---\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n\\n        int max = 0;\\n        int runningCount = 0;\\n        boolean first = true;\\n\\n        if(Integer.bitCount(n) == 1){\\n            return 0;\\n        }\\n\\n        while(n != 0){\\n            int a = n & 1;\\n            n>>=1;\\n            if(a == 1){\\n                if(runningCount > max){\\n                    max = runningCount;\\n                }\\n                runningCount = 1;\\n                first = false;\\n            }\\n            else if(first == false){\\n                runningCount++; \\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nwhile(n != 0){\\n    int a = n & 1; // retrieves the rightmost bit.\\n    n >>= 1; // performs a logical bitewise shift right.\\n}\\n```\n```\\nboolean first = true;\\n```\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n\\n        int max = 0;\\n        int runningCount = 0;\\n        boolean first = true;\\n\\n        if(Integer.bitCount(n) == 1){\\n            return 0;\\n        }\\n\\n        while(n != 0){\\n            int a = n & 1;\\n            n>>=1;\\n            if(a == 1){\\n                if(runningCount > max){\\n                    max = runningCount;\\n                }\\n                runningCount = 1;\\n                first = false;\\n            }\\n            else if(first == false){\\n                runningCount++; \\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847840,
                "title": "go-bits-shift",
                "content": "```\\nfunc binaryGap(n int) int {\\n    max := 0\\n\\n    for counter := 0 ;n > 0; n >>= 1 {\\n        if n & 1 == 0 {\\n            if counter > 0 {\\n                counter++\\n            }\\n            continue\\n        }\\n        \\n        if max < counter {\\n            max = counter\\n        }\\n        \\n        counter = 1\\n    }\\n\\n    return max\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc binaryGap(n int) int {\\n    max := 0\\n\\n    for counter := 0 ;n > 0; n >>= 1 {\\n        if n & 1 == 0 {\\n            if counter > 0 {\\n                counter++\\n            }\\n            continue\\n        }\\n        \\n        if max < counter {\\n            max = counter\\n        }\\n        \\n        counter = 1\\n    }\\n\\n    return max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3833523,
                "title": "explained-js-ts-solution",
                "content": "# Intuition\\nThe intuition behind this solution is to convert the given positive integer n to its binary representation as a string and then traverse the binary string to find the longest distance between any two adjacent 1\\'s. We keep track of the count of consecutive zeros after each \\'1\\', and whenever we encounter a \\'1\\', we update the maximum distance found so far.\\n\\n# Approach\\n1) Convert n to its binary representation as a string using toString(2).\\n\\n2) Initialize variables isOpen as false (to keep track of whether we have encountered a \\'1\\' yet), count to 0 (to track the number of consecutive zeros after each \\'1\\'), and max to 0 (to store the maximum distance found).\\n\\n3) Traverse the binary string character by character using a for-loop.\\n\\n4) When we encounter a \\'0\\' and isOpen is true (indicating we have seen a \\'1\\' already), increment the count.\\n\\n5) When we encounter a \\'1\\' and isOpen is true, update the max distance by taking the maximum of the current count + 1 and the existing max, and reset the count to 0.\\n\\n6) If we encounter a \\'1\\' and isOpen is false, set isOpen to true.\\n\\n7) After the loop, return the max, which represents the longest distance between any two adjacent 1\\'s in the binary representation of n.\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity is dominated by the conversion of n to its binary representation, which takes O(log n) time.\\nThe subsequent loop to traverse the binary string takes linear time, but its complexity is bounded by O(log n) since the binary representation of n has O(log n) digits.\\n\\n- Space complexity:\\nThe space complexity is mainly determined by the binary string representation of n, which has O(log n) bits in the worst case.\\n\\n# Code\\n```\\nfunction binaryGap(n: number): number {\\n    let chars = n.toString(2)\\n    let isOpen = false\\n    let count = 0\\n    let max = count\\n    for (let char of chars) {\\n        if (char === \\'0\\' && isOpen) {\\n            count++\\n        }\\n        if (char === \\'1\\' && isOpen) {\\n            max = Math.max(count + 1, max)\\n            count = 0\\n        } else {\\n            isOpen = true\\n        }\\n    }\\n    return max\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction binaryGap(n: number): number {\\n    let chars = n.toString(2)\\n    let isOpen = false\\n    let count = 0\\n    let max = count\\n    for (let char of chars) {\\n        if (char === \\'0\\' && isOpen) {\\n            count++\\n        }\\n        if (char === \\'1\\' && isOpen) {\\n            max = Math.max(count + 1, max)\\n            count = 0\\n        } else {\\n            isOpen = true\\n        }\\n    }\\n    return max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3806424,
                "title": "fast-solution-on-bit-operations-runtime-96-62",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n\\n        while n%2 == 0:\\n            n //= 2\\n        if n == 1:\\n            return 0\\n        count = 1\\n        while n&(n+1) != 0:\\n            n = n|(n>>1)\\n            count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n\\n        while n%2 == 0:\\n            n //= 2\\n        if n == 1:\\n            return 0\\n        count = 1\\n        while n&(n+1) != 0:\\n            n = n|(n>>1)\\n            count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801920,
                "title": "java-o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we need to find the farthest adjacent 1\\'s, we actually need the longest sequence of 0\\'s.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can start by getting rid of the trailing 0\\'s in the binary string representation of the number and then finding the longest sequence of 0\\'s.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        String s = Integer.toBinaryString(n);\\n        int i = 0, j = s.length() - 1, cnt = 0, maxCnt = Integer.MIN_VALUE;\\n        while (s.charAt(i) == \\'0\\') {\\n            i++;\\n        }\\n        while (s.charAt(j) == \\'0\\') {\\n            j--;\\n        }\\n        while (i < j) {\\n            char c = s.charAt(i);\\n            if (c == \\'1\\') {\\n                cnt = 0;\\n            } else if (c == \\'0\\') {\\n                cnt++;\\n            }\\n            maxCnt = Math.max(maxCnt, cnt);\\n            i++;\\n        }\\n        return (Math.abs(maxCnt - s.length()) <= 1 || \\n        maxCnt == Integer.MIN_VALUE) ? 0 : maxCnt + 1;\\n   }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        String s = Integer.toBinaryString(n);\\n        int i = 0, j = s.length() - 1, cnt = 0, maxCnt = Integer.MIN_VALUE;\\n        while (s.charAt(i) == \\'0\\') {\\n            i++;\\n        }\\n        while (s.charAt(j) == \\'0\\') {\\n            j--;\\n        }\\n        while (i < j) {\\n            char c = s.charAt(i);\\n            if (c == \\'1\\') {\\n                cnt = 0;\\n            } else if (c == \\'0\\') {\\n                cnt++;\\n            }\\n            maxCnt = Math.max(maxCnt, cnt);\\n            i++;\\n        }\\n        return (Math.abs(maxCnt - s.length()) <= 1 || \\n        maxCnt == Integer.MIN_VALUE) ? 0 : maxCnt + 1;\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801129,
                "title": "java-bit-manipulation-0ms-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int curr_dis=0;\\n        int max_dis=0;\\n        while(n!=0){\\n            if((n&1)==1)break;\\n            n >>= 1;\\n        }\\n        n >>= 1;\\n        while(n!=0)\\n        {\\n            curr_dis++;\\n            if( (n&1) == 1)\\n            {\\n                max_dis=Math.max(max_dis,curr_dis);\\n                curr_dis=0;\\n            }\\n            n >>= 1;\\n        }\\n        return max_dis;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int curr_dis=0;\\n        int max_dis=0;\\n        while(n!=0){\\n            if((n&1)==1)break;\\n            n >>= 1;\\n        }\\n        n >>= 1;\\n        while(n!=0)\\n        {\\n            curr_dis++;\\n            if( (n&1) == 1)\\n            {\\n                max_dis=Math.max(max_dis,curr_dis);\\n                curr_dis=0;\\n            }\\n            n >>= 1;\\n        }\\n        return max_dis;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784102,
                "title": "convert-to-string-first-then-get-a-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn binary_gap(n: i32) -> i32 {\\n        let s = format!(\"{:b}\", n);\\n        let s = s\\n            .char_indices()\\n            .filter(|n| n.1 == \\'1\\')\\n            .collect::<Vec<(_, _)>>();\\n\\n        s.windows(2).map(|n| n[1].0 - n[0].0).max().unwrap_or(0) as i32\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn binary_gap(n: i32) -> i32 {\\n        let s = format!(\"{:b}\", n);\\n        let s = s\\n            .char_indices()\\n            .filter(|n| n.1 == \\'1\\')\\n            .collect::<Vec<(_, _)>>();\\n\\n        s.windows(2).map(|n| n[1].0 - n[0].0).max().unwrap_or(0) as i32\\n    \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3753700,
                "title": "using-math-max-and-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int BinaryGap(int n) \\n    {\\n        string s = Convert.ToString(n,2);\\n\\n        int max = 0;\\n        int startPoint = 0;\\n        int endPoint = 0;\\n        for(int i = 0 ; i < s.Length ;)\\n        {\\n            if(s[i] == \\'1\\')\\n            {\\n                startPoint=1;\\n            }\\n            i++;\\n            while(i < s.Length && s[i] != \\'1\\' && startPoint == 1)\\n            {\\n                endPoint++;\\n                i++;\\n            }            \\n            if(i < s.Length && s[i] == \\'1\\' && startPoint == 1)\\n            {\\n                    max = Math.Max(max, endPoint+startPoint);\\n                    endPoint = 0;\\n            }\\n        }\\n\\n        return max;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int BinaryGap(int n) \\n    {\\n        string s = Convert.ToString(n,2);\\n\\n        int max = 0;\\n        int startPoint = 0;\\n        int endPoint = 0;\\n        for(int i = 0 ; i < s.Length ;)\\n        {\\n            if(s[i] == \\'1\\')\\n            {\\n                startPoint=1;\\n            }\\n            i++;\\n            while(i < s.Length && s[i] != \\'1\\' && startPoint == 1)\\n            {\\n                endPoint++;\\n                i++;\\n            }            \\n            if(i < s.Length && s[i] == \\'1\\' && startPoint == 1)\\n            {\\n                    max = Math.Max(max, endPoint+startPoint);\\n                    endPoint = 0;\\n            }\\n        }\\n\\n        return max;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738607,
                "title": "easy-to-understand-java-beginner-s-need",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int[] binary =new int[50];\\n        int i=0,max=0,start=0,length=0;\\n        while(n>0)\\n        {\\n            binary[i++]= n%2;\\n            n/=2;\\n            if(binary[i-1]==1)\\n            start=i-1;\\n        }\\nstart=i-start-1;//0\\n        for(int j=i-1;j>=0;j--)\\n        {\\n            \\n            if(binary[j]==1)\\n            {\\n                \\n                length=(i-1-j)-start;\\n                start=i-1-j;\\n                if(length>max)\\n                {\\n                    System.out.println(length);\\n                max=length;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int[] binary =new int[50];\\n        int i=0,max=0,start=0,length=0;\\n        while(n>0)\\n        {\\n            binary[i++]= n%2;\\n            n/=2;\\n            if(binary[i-1]==1)\\n            start=i-1;\\n        }\\nstart=i-start-1;//0\\n        for(int j=i-1;j>=0;j--)\\n        {\\n            \\n            if(binary[j]==1)\\n            {\\n                \\n                length=(i-1-j)-start;\\n                start=i-1-j;\\n                if(length>max)\\n                {\\n                    System.out.println(length);\\n                max=length;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735371,
                "title": "100-beats-eaisest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int maxi=0;\\n        int start=n&1;\\n        int prev=n&1;\\n        int cnt=0;\\n        int temp=n;\\n        n=n>>1;\\n        while(n>0)\\n        {\\n            if(prev==0 && start==1)\\n            { \\n                cnt++;\\n                maxi=max(maxi,cnt);\\n            }\\n            else\\n            {\\n                cnt=0;\\n                start=prev;\\n            }\\n            prev=n&1;\\n            n=n>>1;\\n        }\\n        if(maxi!=0)\\n        return maxi+1;\\n        else if(start==1 && temp!=1) return 1;\\n        else return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int maxi=0;\\n        int start=n&1;\\n        int prev=n&1;\\n        int cnt=0;\\n        int temp=n;\\n        n=n>>1;\\n        while(n>0)\\n        {\\n            if(prev==0 && start==1)\\n            { \\n                cnt++;\\n                maxi=max(maxi,cnt);\\n            }\\n            else\\n            {\\n                cnt=0;\\n                start=prev;\\n            }\\n            prev=n&1;\\n            n=n>>1;\\n        }\\n        if(maxi!=0)\\n        return maxi+1;\\n        else if(start==1 && temp!=1) return 1;\\n        else return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729550,
                "title": "easy-solution-in-ts",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction binaryGap(n: number): number {\\n    const binary = (n >>> 0).toString(2);\\n    let first = -1;\\n    let second = -1;\\n    let dist = 0;\\n\\n    for(let i = 0 ; i < binary.length; i++) {\\n        if(binary[i] === \\'1\\') {\\n            if(first < 0) first = i;\\n            else second = i;\\n        }\\n\\n        if(first >= 0 && second >= 0){\\n            const auxDist = second - first;\\n            if(auxDist > dist) {\\n                dist = auxDist;\\n            }\\n            first = second;\\n            second = undefined;\\n        }\\n    }\\n\\n    return dist;\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "String"
                ],
                "code": "```\\nfunction binaryGap(n: number): number {\\n    const binary = (n >>> 0).toString(2);\\n    let first = -1;\\n    let second = -1;\\n    let dist = 0;\\n\\n    for(let i = 0 ; i < binary.length; i++) {\\n        if(binary[i] === \\'1\\') {\\n            if(first < 0) first = i;\\n            else second = i;\\n        }\\n\\n        if(first >= 0 && second >= 0){\\n            const auxDist = second - first;\\n            if(auxDist > dist) {\\n                dist = auxDist;\\n            }\\n            first = second;\\n            second = undefined;\\n        }\\n    }\\n\\n    return dist;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3728531,
                "title": "aniruddha-s-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int nm = n;\\n        int cnt = 0;\\n        int cnt1 = 0;\\n        int mx = 0;\\n        bool f = false;\\n        while(nm){\\n            if(nm & 1){\\n                f = true;\\n                cnt1++;\\n                if(mx < cnt ){\\n                    mx = cnt;\\n                }\\n                cnt = 0;\\n            }else if(f){\\n                cnt++;\\n            }\\n            nm = nm >> 1;   \\n\\n        }\\n        int ans = 0;\\n        if(mx>0 ){\\n            ans = mx + 1;\\n        }else if(cnt1 > 1){\\n            ans = 1;\\n        }else{\\n            ans = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int nm = n;\\n        int cnt = 0;\\n        int cnt1 = 0;\\n        int mx = 0;\\n        bool f = false;\\n        while(nm){\\n            if(nm & 1){\\n                f = true;\\n                cnt1++;\\n                if(mx < cnt ){\\n                    mx = cnt;\\n                }\\n                cnt = 0;\\n            }else if(f){\\n                cnt++;\\n            }\\n            nm = nm >> 1;   \\n\\n        }\\n        int ans = 0;\\n        if(mx>0 ){\\n            ans = mx + 1;\\n        }else if(cnt1 > 1){\\n            ans = 1;\\n        }else{\\n            ans = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724037,
                "title": "nothing-special",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        n = bin(n) # to binary\\n        n = n.replace(\\'0b\\', \\'\\')\\n        print(n)\\n        if n.count(\\'1\\') == 1:\\n            return 0\\n        x = 0\\n        y = 0\\n        count_on = 0\\n        for i in range(0,len(n)):\\n            if n[i] == \\'1\\' and count_on == 0:\\n                count_on = 1\\n            if n[i] == \\'1\\' and count_on == 1:\\n                y = max(x,y)\\n                x = 0\\n            if n[i] == \\'0\\' and count_on == 1:\\n                x += 1\\n        return y+1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        n = bin(n) # to binary\\n        n = n.replace(\\'0b\\', \\'\\')\\n        print(n)\\n        if n.count(\\'1\\') == 1:\\n            return 0\\n        x = 0\\n        y = 0\\n        count_on = 0\\n        for i in range(0,len(n)):\\n            if n[i] == \\'1\\' and count_on == 0:\\n                count_on = 1\\n            if n[i] == \\'1\\' and count_on == 1:\\n                y = max(x,y)\\n                x = 0\\n            if n[i] == \\'0\\' and count_on == 1:\\n                x += 1\\n        return y+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721068,
                "title": "c-one-pass-beats-100-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int dis = 0, prev = -1;\\n        for(int i=0;i<31;i++)\\n        {\\n            int curr = n&(1<<i);\\n            if(curr!=0)\\n            {\\n                if(prev!=-1)\\n                    dis = max(dis, i-prev);\\n                prev = i;\\n            }\\n        }\\n        return dis;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int dis = 0, prev = -1;\\n        for(int i=0;i<31;i++)\\n        {\\n            int curr = n&(1<<i);\\n            if(curr!=0)\\n            {\\n                if(prev!=-1)\\n                    dis = max(dis, i-prev);\\n                prev = i;\\n            }\\n        }\\n        return dis;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716617,
                "title": "straightforward",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar binaryGap = function(n) {\\n    let firstIndexOf1 = undefined\\n    let secondIndexOf1 = undefined\\n    let longestDis = 0\\n    let binary = \\'\\'\\n    let newNum = n\\n    while (newNum > 0) {\\n        newNum = newNum / 2\\n        let isInt = Number(newNum) === newNum && newNum % 1 === 0;\\n        if(!isInt) {\\n        newNum = newNum.toString().substring(0, newNum.toString().indexOf(\".\"));\\n        }\\n        binary += isInt ? \\'0\\' : \\'1\\'\\n    }\\n    for (let i = 0; i < binary.length; i++) {\\n        if(binary[i] === \\'1\\') {\\n            if(firstIndexOf1 || firstIndexOf1 === 0) {\\n                secondIndexOf1 = i\\n            } else {\\n                firstIndexOf1 = i\\n            }\\n        } \\n        if (secondIndexOf1 && (firstIndexOf1 || firstIndexOf1 === 0)) {\\n        let dis = secondIndexOf1 - firstIndexOf1\\n        longestDis = dis > longestDis ? dis : longestDis\\n        firstIndexOf1 = secondIndexOf1\\n        secondIndexOf1 = undefined\\n        }\\n    }\\n\\n    return longestDis\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar binaryGap = function(n) {\\n    let firstIndexOf1 = undefined\\n    let secondIndexOf1 = undefined\\n    let longestDis = 0\\n    let binary = \\'\\'\\n    let newNum = n\\n    while (newNum > 0) {\\n        newNum = newNum / 2\\n        let isInt = Number(newNum) === newNum && newNum % 1 === 0;\\n        if(!isInt) {\\n        newNum = newNum.toString().substring(0, newNum.toString().indexOf(\".\"));\\n        }\\n        binary += isInt ? \\'0\\' : \\'1\\'\\n    }\\n    for (let i = 0; i < binary.length; i++) {\\n        if(binary[i] === \\'1\\') {\\n            if(firstIndexOf1 || firstIndexOf1 === 0) {\\n                secondIndexOf1 = i\\n            } else {\\n                firstIndexOf1 = i\\n            }\\n        } \\n        if (secondIndexOf1 && (firstIndexOf1 || firstIndexOf1 === 0)) {\\n        let dis = secondIndexOf1 - firstIndexOf1\\n        longestDis = dis > longestDis ? dis : longestDis\\n        firstIndexOf1 = secondIndexOf1\\n        secondIndexOf1 = undefined\\n        }\\n    }\\n\\n    return longestDis\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3714117,
                "title": "java-solution-with-detailed-explanation-beats-100",
                "content": "# Approach\\nHere, we need to track when we get the first 1 of the pair (if there is any) and the last 1 of the pair (the last 1 would be the first 1 of the next pair if there is any, and so on). Also, we need to count the in-between 0s of the pair.\\nTo do so, we will initialize two variables that will track the current (say, `currGap`) and maximum (say, `largestGap`) gaps between the pairs. Both will be initialized as 0, which will indicate that no pairs of 1 are still found. Then, we will run a loop that will run until the number becomes 0 (we will right shift the number to 1 position on each iteration).\\nIf we find a 1, that means it could be the start of a new pair (if there is any) or the end of an existing pair (also the start of a new pair if there is any). In both cases, we need to update the `currGap` to 1 (which will indicate that the start of a pair is found). And, if it\\'s the end of the existing pair, we need to update the `largestGap`, if applicable.\\nOn the other hand, if we encounter a 0 and the `currGap` is not 0, it means that the 0 resides in-between the pair (if there is any) of 1s. In this case, we need to increment the `currGap` by 1.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n  public int binaryGap(int n) {\\n    int currGap = 0;\\n    int largestGap = 0;\\n    while (n != 0) {\\n      if ((n & 1) == 1) {\\n        if (currGap != 0) { // Last 1 of the pair and the beginning of a new pair\\n          largestGap = currGap > largestGap ? currGap : largestGap;\\n        }\\n        currGap = 1; // First 1 of the pair \\n      } else if (currGap != 0) {\\n        currGap += 1;\\n      }\\n      n >>= 1;\\n    }\\n    return largestGap;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int binaryGap(int n) {\\n    int currGap = 0;\\n    int largestGap = 0;\\n    while (n != 0) {\\n      if ((n & 1) == 1) {\\n        if (currGap != 0) { // Last 1 of the pair and the beginning of a new pair\\n          largestGap = currGap > largestGap ? currGap : largestGap;\\n        }\\n        currGap = 1; // First 1 of the pair \\n      } else if (currGap != 0) {\\n        currGap += 1;\\n      }\\n      n >>= 1;\\n    }\\n    return largestGap;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713538,
                "title": "easy-sol-100-faster-95-in-space-bitwise-left-shift-c",
                "content": "# Complexity\\n- Time complexity:\\nO(N) where N is number of bits.\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int arr[2]={-1,-1};\\n        long long a=1,i=0;\\n        int ans=INT_MIN;\\n\\n        while(i<32)\\n        {\\n            if(n&a)\\n            {\\n                arr[0]=arr[1];\\n                arr[1]=i;\\n\\n                if(arr[0]!=-1 && arr[1]!=-1)\\n                {\\n                    ans=max(ans,arr[1]-arr[0]);\\n                }\\n            }\\n            a=a<<1;\\n            i++;\\n        }\\n        if(arr[0]==-1 || arr[1]==-1)\\n            return 0;\\n    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int arr[2]={-1,-1};\\n        long long a=1,i=0;\\n        int ans=INT_MIN;\\n\\n        while(i<32)\\n        {\\n            if(n&a)\\n            {\\n                arr[0]=arr[1];\\n                arr[1]=i;\\n\\n                if(arr[0]!=-1 && arr[1]!=-1)\\n                {\\n                    ans=max(ans,arr[1]-arr[0]);\\n                }\\n            }\\n            a=a<<1;\\n            i++;\\n        }\\n        if(arr[0]==-1 || arr[1]==-1)\\n            return 0;\\n    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710994,
                "title": "868-binary-gap-100-beats-than-all-java-submissions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition for finding the longest distance between adjacent 1\\'s in the binary representation of a positive integer:\\n\\n**-** Initialize variables: Set the longest distance and the current distance between adjacent 1\\'s to 0. Also, set a flag to keep track of the existence of the first 1 bit.\\n\\n**-** Iterate through the binary representation: Start from the least significant bit and move towards the most significant bit.\\n\\n**-** Handling 0 bits: If a 0 bit is encountered, shift the bits to the right. If the first 1 bit has been found (flag is true), increment the current distance between adjacent 1\\'s.\\n\\n**-** Handling 1 bits: If a 1 bit is encountered, update the longest distance with the maximum value between the current distance and the longest distance found so far. Set the first 1 bit flag to true and reset the current distance to 0.\\n\\n**-** Continue iteration: Repeat steps 3 and 4 until all bits have been processed.\\n\\n**-** Return the longest distance: After iterating through all bits, return the longest distance as the result.\\n\\nThe intuition behind this approach is to identify consecutive 1 bits and calculate the distance between them. By using bitwise operations and maintaining appropriate variables, the code tracks the longest distance between adjacent 1\\'s. It handles the case when there are no adjacent 1\\'s by returning 0.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code uses a bitwise operation to calculate the binary gap of a given integer. It iterates over the binary representation of the number, keeping track of the longest distance between consecutive 1 bits. It uses a distance variable to keep track of the current distance between 1 bits and updates the longestDistance variable whenever a new longest distance is found. The code also uses a **firstOneBitExist boolean flag to handle the case when the first 1 bit is encountered**. Overall, the approach is to shift the bits to the right and perform bitwise operations to identify the binary gap.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe code iterates over the bits of the given integer, which takes O(log n) time, where n is the value of the integer.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe code uses a constant amount of extra space, so the space complexity is O(1).\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int longestDistance = 0, distance = 0;\\n        boolean firstOneBitExist = false;\\n        while(n != 0){\\n            if((n & 1) == 0){\\n                n >>= 1;\\n                if(firstOneBitExist)\\n                    distance++;\\n            } else {\\n                if(firstOneBitExist)\\n                    distance++;\\n                longestDistance = Math.max(distance, longestDistance);\\n                firstOneBitExist = true;\\n                distance = 0;\\n                n >>= 1;\\n            }\\n        }\\n        return longestDistance;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int longestDistance = 0, distance = 0;\\n        boolean firstOneBitExist = false;\\n        while(n != 0){\\n            if((n & 1) == 0){\\n                n >>= 1;\\n                if(firstOneBitExist)\\n                    distance++;\\n            } else {\\n                if(firstOneBitExist)\\n                    distance++;\\n                longestDistance = Math.max(distance, longestDistance);\\n                firstOneBitExist = true;\\n                distance = 0;\\n                n >>= 1;\\n            }\\n        }\\n        return longestDistance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705608,
                "title": "beats-100-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int dis=0, i=0,j=0;\\n        while(n>0){\\n            if((n&1)!=0){\\n                if(j==0){\\n                    j=1;\\n                    // i++;\\n                }\\n                else{\\n                    // j=0;\\n                    if(dis<i){\\n                        dis=i;\\n                        // i=0;\\n                    }\\n                    i=0;\\n                }\\n                // i++;\\n                \\n            }\\n            if(j==1){\\n                i++;\\n            }\\n            n=n>>1;\\n        }\\n        return dis;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int dis=0, i=0,j=0;\\n        while(n>0){\\n            if((n&1)!=0){\\n                if(j==0){\\n                    j=1;\\n                    // i++;\\n                }\\n                else{\\n                    // j=0;\\n                    if(dis<i){\\n                        dis=i;\\n                        // i=0;\\n                    }\\n                    i=0;\\n                }\\n                // i++;\\n                \\n            }\\n            if(j==1){\\n                i++;\\n            }\\n            n=n>>1;\\n        }\\n        return dis;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697621,
                "title": "fastest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int binaryGap(int n) \\n    {\\n        int i=0;\\n        int li=-1;\\n        int ans = 0;\\n        while(n>0)\\n        {\\n            if(n%2)\\n            {\\n                if(li==-1)\\n                {\\n                    li=i;\\n                }\\n                else\\n                {\\n                    ans = max(i-li, ans);\\n                    li=i;\\n                }            \\n            }\\n            n/=2;\\n            i++;\\n        }\\n        \\n\\n        // std::cout<<;        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int binaryGap(int n) \\n    {\\n        int i=0;\\n        int li=-1;\\n        int ans = 0;\\n        while(n>0)\\n        {\\n            if(n%2)\\n            {\\n                if(li==-1)\\n                {\\n                    li=i;\\n                }\\n                else\\n                {\\n                    ans = max(i-li, ans);\\n                    li=i;\\n                }            \\n            }\\n            n/=2;\\n            i++;\\n        }\\n        \\n\\n        // std::cout<<;        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3687494,
                "title": "100-100-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int max = 0;\\n        int k = -1;\\n        int i = 0;\\n        while(n > 0)\\n        {\\n            if((n&1) == 1)\\n            {\\n               if(k != -1)\\n               {\\n                    max = Math.max(max,i-k);\\n               }\\n                k = i;\\n            }\\n            i++;\\n            n>>=1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int max = 0;\\n        int k = -1;\\n        int i = 0;\\n        while(n > 0)\\n        {\\n            if((n&1) == 1)\\n            {\\n               if(k != -1)\\n               {\\n                    max = Math.max(max,i-k);\\n               }\\n                k = i;\\n            }\\n            i++;\\n            n>>=1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675230,
                "title": "python-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n\\n        l = list(bin(n)[2:])\\n        lg=[]\\n        while \"1\" in l:\\n            indice = l.index(\"1\")\\n            lg.append(indice)\\n            l[indice]=\"0\"\\n        maximo=0\\n        for i in range(1,len(lg)):\\n            var=lg[i]-lg[i-1]\\n            if maximo<var:\\n                maximo=var\\n        return maximo\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n\\n        l = list(bin(n)[2:])\\n        lg=[]\\n        while \"1\" in l:\\n            indice = l.index(\"1\")\\n            lg.append(indice)\\n            l[indice]=\"0\"\\n        maximo=0\\n        for i in range(1,len(lg)):\\n            var=lg[i]-lg[i-1]\\n            if maximo<var:\\n                maximo=var\\n        return maximo\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669421,
                "title": "javascript-bit-manipulation",
                "content": "# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar binaryGap = function(n) {\\n\\n    let prevIndex = -1;\\n    let diff = 0;\\n    \\n    let index = 0;\\n    while(n > 0) {\\n        const bit = n & 1;\\n        if(bit === 1) {\\n            if(prevIndex === -1) {\\n                prevIndex = index; \\n            }\\n            else{\\n                diff = Math.max(diff, index - prevIndex);\\n                prevIndex = index;\\n            }\\n        }\\n\\n        n >>= 1;\\n        index++;\\n    }\\n\\n    return diff;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar binaryGap = function(n) {\\n\\n    let prevIndex = -1;\\n    let diff = 0;\\n    \\n    let index = 0;\\n    while(n > 0) {\\n        const bit = n & 1;\\n        if(bit === 1) {\\n            if(prevIndex === -1) {\\n                prevIndex = index; \\n            }\\n            else{\\n                diff = Math.max(diff, index - prevIndex);\\n                prevIndex = index;\\n            }\\n        }\\n\\n        n >>= 1;\\n        index++;\\n    }\\n\\n    return diff;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3644406,
                "title": "easy-to-understand-beats-100-0ms-tc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int last = -1 , MaxGap = 0;\\n\\n        for(int i =0 ; i<32 ; i++){\\n            if((n&1) !=0){\\n                if(last==-1){\\n                    last=i;\\n                }else{\\n                    MaxGap=Math.max(MaxGap,i-last);\\n                    last=i;\\n                }\\n            }\\n            n>>=1;\\n        }\\n        return MaxGap; \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int last = -1 , MaxGap = 0;\\n\\n        for(int i =0 ; i<32 ; i++){\\n            if((n&1) !=0){\\n                if(last==-1){\\n                    last=i;\\n                }else{\\n                    MaxGap=Math.max(MaxGap,i-last);\\n                    last=i;\\n                }\\n            }\\n            n>>=1;\\n        }\\n        return MaxGap; \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636123,
                "title": "bitwise-operation-play-with-bits",
                "content": "# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int ans = 0;\\n        int cur = 0;\\n        while( n > 0 ){\\n            int lsb = (n&1);\\n            if( lsb == 1 && cur == 0 ) cur++;\\n            else if( lsb == 1 && cur != 0 ) {\\n                ans = Math.max( ans , cur );\\n                cur = 1;\\n            }\\n            else if( cur != 0 ) cur++;\\n            n = n >> 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int ans = 0;\\n        int cur = 0;\\n        while( n > 0 ){\\n            int lsb = (n&1);\\n            if( lsb == 1 && cur == 0 ) cur++;\\n            else if( lsb == 1 && cur != 0 ) {\\n                ans = Math.max( ans , cur );\\n                cur = 1;\\n            }\\n            else if( cur != 0 ) cur++;\\n            n = n >> 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623422,
                "title": "doing-it-in-a-normal-way-thinking",
                "content": "# Intuition\\nThis is probably the first idea that comes to mind.\\n\\n# Complexity\\n- Time complexity:\\n O(n)\\n\\n- Space complexity:\\n O(n) + O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    fun binaryGap(n: Int): Int {\\n      val binaryString = Integer.toBinaryString(n)\\n        var max = 0\\n        var count = 0\\n        for (i in binaryString.indices) {\\n            if (binaryString[i] == \\'1\\') {\\n                if (count > max) max = count\\n                count = 1\\n            } else {\\n                count++\\n            }\\n        }\\n        return max  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun binaryGap(n: Int): Int {\\n      val binaryString = Integer.toBinaryString(n)\\n        var max = 0\\n        var count = 0\\n        for (i in binaryString.indices) {\\n            if (binaryString[i] == \\'1\\') {\\n                if (count > max) max = count\\n                count = 1\\n            } else {\\n                count++\\n            }\\n        }\\n        return max  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617317,
                "title": "easy-solution-with-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint binaryGap(int n){\\n    int max = 0 , cnt = 0, flag = 0;\\n    while ( n > 0){\\n        if ( ( n & 1) == 1 ){\\n            if ( flag == 1 ){\\n                if ( max < cnt){\\n                    max  = cnt;\\n                }\\n                cnt = 1;\\n            } else {\\n                flag = 1;\\n                cnt = 1;\\n            }\\n            n >>= 1;\\n        } else {\\n            cnt++;\\n            n >>= 1;\\n        }\\n    }\\n    return max;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint binaryGap(int n){\\n    int max = 0 , cnt = 0, flag = 0;\\n    while ( n > 0){\\n        if ( ( n & 1) == 1 ){\\n            if ( flag == 1 ){\\n                if ( max < cnt){\\n                    max  = cnt;\\n                }\\n                cnt = 1;\\n            } else {\\n                flag = 1;\\n                cnt = 1;\\n            }\\n            n >>= 1;\\n        } else {\\n            cnt++;\\n            n >>= 1;\\n        }\\n    }\\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3605910,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->so the approach is i take an pointer start which is the first bit and take another pointer end if character at start is equal to character at end then start pointer is equal to end pointer and the end will be incremented \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n         String s = Integer.toBinaryString(n);\\n          int ans = 0;\\n          int temp =0;\\n          //so first I took an initial pointer start that is equal to first index that is always one//\\n        int start = 0;\\n        //then I will take another pointer that will point to the one //\\n        int end  = start+1;\\n\\n        while(end<s.length()){\\n              if(s.charAt(start)!=s.charAt(end))\\n              {\\n                  end=end+1;\\n              }else{\\n                  temp = end-start;\\n                  start = end ;\\n                  end = end +1;\\n                  ans = Math.max(ans,temp);\\n              }\\n            }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n         String s = Integer.toBinaryString(n);\\n          int ans = 0;\\n          int temp =0;\\n          //so first I took an initial pointer start that is equal to first index that is always one//\\n        int start = 0;\\n        //then I will take another pointer that will point to the one //\\n        int end  = start+1;\\n\\n        while(end<s.length()){\\n              if(s.charAt(start)!=s.charAt(end))\\n              {\\n                  end=end+1;\\n              }else{\\n                  temp = end-start;\\n                  start = end ;\\n                  end = end +1;\\n                  ans = Math.max(ans,temp);\\n              }\\n            }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565853,
                "content": [
                    {
                        "username": "1creation",
                        "content": "distance between \\'1\\' and \\'1\\'\\nlet`s check all distances in binary representation\\n10010001101\\n\\t1. first distance 1001 (from 0 to 3 index) -> distance 3\\n2.10001 (from 3 to 7) -> distance 4\\n3.11 (from 7 to 8) -> distance 1\\n4.101 (from 8 to 10) -> distance 2"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Why does this problem has so many dislikes? Think it is a good problem."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The solution is wrong:\\n\\ncheck out 1041 as a test case. The solution in the editorial returns 6, but the answer should be 5"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "so why is the  test case of n=6\\nhave expected output of 1 when 6 ie. 0110, has two adjacent st bits with no 0s in between?\\ndoesnt the prob description say that return result should be 0 if thats\\'s the case?\\nany help?"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "The problem description says return 0 if there are no adjacent 1 bits . For n = 6(0110) there are two adjacent 1 bits which are at a distance of 1 apart."
                    },
                    {
                        "username": "mo7",
                        "content": "Xodility also have a question like this with different define of the distance."
                    },
                    {
                        "username": "saiful007",
                        "content": "I am struggling with the problem desciption can anyone help me with that?"
                    },
                    {
                        "username": "Adiyadav23",
                        "content": "The question is asking for absolute difference between the indices of 1's, not the number of 0's between them.\nEg: '11' = 1, not 0."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The editorial solution is wrong for 1041\\n\\n10000010001 is 1041 in binary.\\n\\nThe solution should be 5, but the editorial solution, 6 is returned. "
                    }
                ]
            },
            {
                "id": 1859732,
                "content": [
                    {
                        "username": "1creation",
                        "content": "distance between \\'1\\' and \\'1\\'\\nlet`s check all distances in binary representation\\n10010001101\\n\\t1. first distance 1001 (from 0 to 3 index) -> distance 3\\n2.10001 (from 3 to 7) -> distance 4\\n3.11 (from 7 to 8) -> distance 1\\n4.101 (from 8 to 10) -> distance 2"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Why does this problem has so many dislikes? Think it is a good problem."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The solution is wrong:\\n\\ncheck out 1041 as a test case. The solution in the editorial returns 6, but the answer should be 5"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "so why is the  test case of n=6\\nhave expected output of 1 when 6 ie. 0110, has two adjacent st bits with no 0s in between?\\ndoesnt the prob description say that return result should be 0 if thats\\'s the case?\\nany help?"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "The problem description says return 0 if there are no adjacent 1 bits . For n = 6(0110) there are two adjacent 1 bits which are at a distance of 1 apart."
                    },
                    {
                        "username": "mo7",
                        "content": "Xodility also have a question like this with different define of the distance."
                    },
                    {
                        "username": "saiful007",
                        "content": "I am struggling with the problem desciption can anyone help me with that?"
                    },
                    {
                        "username": "Adiyadav23",
                        "content": "The question is asking for absolute difference between the indices of 1's, not the number of 0's between them.\nEg: '11' = 1, not 0."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The editorial solution is wrong for 1041\\n\\n10000010001 is 1041 in binary.\\n\\nThe solution should be 5, but the editorial solution, 6 is returned. "
                    }
                ]
            },
            {
                "id": 1633657,
                "content": [
                    {
                        "username": "1creation",
                        "content": "distance between \\'1\\' and \\'1\\'\\nlet`s check all distances in binary representation\\n10010001101\\n\\t1. first distance 1001 (from 0 to 3 index) -> distance 3\\n2.10001 (from 3 to 7) -> distance 4\\n3.11 (from 7 to 8) -> distance 1\\n4.101 (from 8 to 10) -> distance 2"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Why does this problem has so many dislikes? Think it is a good problem."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The solution is wrong:\\n\\ncheck out 1041 as a test case. The solution in the editorial returns 6, but the answer should be 5"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "so why is the  test case of n=6\\nhave expected output of 1 when 6 ie. 0110, has two adjacent st bits with no 0s in between?\\ndoesnt the prob description say that return result should be 0 if thats\\'s the case?\\nany help?"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "The problem description says return 0 if there are no adjacent 1 bits . For n = 6(0110) there are two adjacent 1 bits which are at a distance of 1 apart."
                    },
                    {
                        "username": "mo7",
                        "content": "Xodility also have a question like this with different define of the distance."
                    },
                    {
                        "username": "saiful007",
                        "content": "I am struggling with the problem desciption can anyone help me with that?"
                    },
                    {
                        "username": "Adiyadav23",
                        "content": "The question is asking for absolute difference between the indices of 1's, not the number of 0's between them.\nEg: '11' = 1, not 0."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The editorial solution is wrong for 1041\\n\\n10000010001 is 1041 in binary.\\n\\nThe solution should be 5, but the editorial solution, 6 is returned. "
                    }
                ]
            },
            {
                "id": 1685912,
                "content": [
                    {
                        "username": "1creation",
                        "content": "distance between \\'1\\' and \\'1\\'\\nlet`s check all distances in binary representation\\n10010001101\\n\\t1. first distance 1001 (from 0 to 3 index) -> distance 3\\n2.10001 (from 3 to 7) -> distance 4\\n3.11 (from 7 to 8) -> distance 1\\n4.101 (from 8 to 10) -> distance 2"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Why does this problem has so many dislikes? Think it is a good problem."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The solution is wrong:\\n\\ncheck out 1041 as a test case. The solution in the editorial returns 6, but the answer should be 5"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "so why is the  test case of n=6\\nhave expected output of 1 when 6 ie. 0110, has two adjacent st bits with no 0s in between?\\ndoesnt the prob description say that return result should be 0 if thats\\'s the case?\\nany help?"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "The problem description says return 0 if there are no adjacent 1 bits . For n = 6(0110) there are two adjacent 1 bits which are at a distance of 1 apart."
                    },
                    {
                        "username": "mo7",
                        "content": "Xodility also have a question like this with different define of the distance."
                    },
                    {
                        "username": "saiful007",
                        "content": "I am struggling with the problem desciption can anyone help me with that?"
                    },
                    {
                        "username": "Adiyadav23",
                        "content": "The question is asking for absolute difference between the indices of 1's, not the number of 0's between them.\nEg: '11' = 1, not 0."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The editorial solution is wrong for 1041\\n\\n10000010001 is 1041 in binary.\\n\\nThe solution should be 5, but the editorial solution, 6 is returned. "
                    }
                ]
            },
            {
                "id": 1573579,
                "content": [
                    {
                        "username": "1creation",
                        "content": "distance between \\'1\\' and \\'1\\'\\nlet`s check all distances in binary representation\\n10010001101\\n\\t1. first distance 1001 (from 0 to 3 index) -> distance 3\\n2.10001 (from 3 to 7) -> distance 4\\n3.11 (from 7 to 8) -> distance 1\\n4.101 (from 8 to 10) -> distance 2"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Why does this problem has so many dislikes? Think it is a good problem."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The solution is wrong:\\n\\ncheck out 1041 as a test case. The solution in the editorial returns 6, but the answer should be 5"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "so why is the  test case of n=6\\nhave expected output of 1 when 6 ie. 0110, has two adjacent st bits with no 0s in between?\\ndoesnt the prob description say that return result should be 0 if thats\\'s the case?\\nany help?"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "The problem description says return 0 if there are no adjacent 1 bits . For n = 6(0110) there are two adjacent 1 bits which are at a distance of 1 apart."
                    },
                    {
                        "username": "mo7",
                        "content": "Xodility also have a question like this with different define of the distance."
                    },
                    {
                        "username": "saiful007",
                        "content": "I am struggling with the problem desciption can anyone help me with that?"
                    },
                    {
                        "username": "Adiyadav23",
                        "content": "The question is asking for absolute difference between the indices of 1's, not the number of 0's between them.\nEg: '11' = 1, not 0."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The editorial solution is wrong for 1041\\n\\n10000010001 is 1041 in binary.\\n\\nThe solution should be 5, but the editorial solution, 6 is returned. "
                    }
                ]
            },
            {
                "id": 2058642,
                "content": [
                    {
                        "username": "1creation",
                        "content": "distance between \\'1\\' and \\'1\\'\\nlet`s check all distances in binary representation\\n10010001101\\n\\t1. first distance 1001 (from 0 to 3 index) -> distance 3\\n2.10001 (from 3 to 7) -> distance 4\\n3.11 (from 7 to 8) -> distance 1\\n4.101 (from 8 to 10) -> distance 2"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Why does this problem has so many dislikes? Think it is a good problem."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The solution is wrong:\\n\\ncheck out 1041 as a test case. The solution in the editorial returns 6, but the answer should be 5"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "so why is the  test case of n=6\\nhave expected output of 1 when 6 ie. 0110, has two adjacent st bits with no 0s in between?\\ndoesnt the prob description say that return result should be 0 if thats\\'s the case?\\nany help?"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "The problem description says return 0 if there are no adjacent 1 bits . For n = 6(0110) there are two adjacent 1 bits which are at a distance of 1 apart."
                    },
                    {
                        "username": "mo7",
                        "content": "Xodility also have a question like this with different define of the distance."
                    },
                    {
                        "username": "saiful007",
                        "content": "I am struggling with the problem desciption can anyone help me with that?"
                    },
                    {
                        "username": "Adiyadav23",
                        "content": "The question is asking for absolute difference between the indices of 1's, not the number of 0's between them.\nEg: '11' = 1, not 0."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The editorial solution is wrong for 1041\\n\\n10000010001 is 1041 in binary.\\n\\nThe solution should be 5, but the editorial solution, 6 is returned. "
                    }
                ]
            },
            {
                "id": 1945810,
                "content": [
                    {
                        "username": "1creation",
                        "content": "distance between \\'1\\' and \\'1\\'\\nlet`s check all distances in binary representation\\n10010001101\\n\\t1. first distance 1001 (from 0 to 3 index) -> distance 3\\n2.10001 (from 3 to 7) -> distance 4\\n3.11 (from 7 to 8) -> distance 1\\n4.101 (from 8 to 10) -> distance 2"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Why does this problem has so many dislikes? Think it is a good problem."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The solution is wrong:\\n\\ncheck out 1041 as a test case. The solution in the editorial returns 6, but the answer should be 5"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "so why is the  test case of n=6\\nhave expected output of 1 when 6 ie. 0110, has two adjacent st bits with no 0s in between?\\ndoesnt the prob description say that return result should be 0 if thats\\'s the case?\\nany help?"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "The problem description says return 0 if there are no adjacent 1 bits . For n = 6(0110) there are two adjacent 1 bits which are at a distance of 1 apart."
                    },
                    {
                        "username": "mo7",
                        "content": "Xodility also have a question like this with different define of the distance."
                    },
                    {
                        "username": "saiful007",
                        "content": "I am struggling with the problem desciption can anyone help me with that?"
                    },
                    {
                        "username": "Adiyadav23",
                        "content": "The question is asking for absolute difference between the indices of 1's, not the number of 0's between them.\nEg: '11' = 1, not 0."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The editorial solution is wrong for 1041\\n\\n10000010001 is 1041 in binary.\\n\\nThe solution should be 5, but the editorial solution, 6 is returned. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Reordered Power of 2",
        "question_content": "<p>You are given an integer <code>n</code>. We reorder the digits in any order (including the original order) such that the leading digit is not zero.</p>\n\n<p>Return <code>true</code> <em>if and only if we can do this so that the resulting number is a power of two</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 10\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 149843,
                "title": "c-java-python-straight-forward",
                "content": "`counter` will counter the number of digits 9876543210 in the given number.\\nThen I just compare `counter(N)` with all `counter(power of 2)`.\\n`1 <= N <= 10^9`, so up to 8 same digits.\\nIf `N > 10^9`, we can use a hash map.\\n\\n**C++:**\\n```\\n    bool reorderedPowerOf2(int N) {\\n        long c = counter(N);\\n        for (int i = 0; i < 32; i++)\\n            if (counter(1 << i) == c) return true;\\n        return false;\\n    }\\n\\n    long counter(int N) {\\n        long res = 0;\\n        for (; N; N /= 10) res += pow(10, N % 10);\\n        return res;\\n    }\\n```\\n\\n**Java:**\\n```\\n    public boolean reorderedPowerOf2(int N) {\\n        long c = counter(N);\\n        for (int i = 0; i < 32; i++)\\n            if (counter(1 << i) == c) return true;\\n        return false;\\n    }\\n    public long counter(int N) {\\n        long res = 0;\\n        for (; N > 0; N /= 10) res += (int)Math.pow(10, N % 10);\\n        return res;\\n    }\\n```\\n**Python:**\\n```\\n    def reorderedPowerOf2(self, N):\\n        c = collections.Counter(str(N))\\n        return any(c == collections.Counter(str(1 << i)) for i in xrange(30))\\n```\\n\\n\\n**Python 1-line**\\nsuggested by @urashima9616, bests 80%\\n```\\n    def reorderedPowerOf2(self, N):\\n        return sorted(str(N)) in [sorted(str(1 << i)) for i in range(30)]\\n```",
                "solutionTags": [],
                "code": "```\\n    bool reorderedPowerOf2(int N) {\\n        long c = counter(N);\\n        for (int i = 0; i < 32; i++)\\n            if (counter(1 << i) == c) return true;\\n        return false;\\n    }\\n\\n    long counter(int N) {\\n        long res = 0;\\n        for (; N; N /= 10) res += pow(10, N % 10);\\n        return res;\\n    }\\n```\n```\\n    public boolean reorderedPowerOf2(int N) {\\n        long c = counter(N);\\n        for (int i = 0; i < 32; i++)\\n            if (counter(1 << i) == c) return true;\\n        return false;\\n    }\\n    public long counter(int N) {\\n        long res = 0;\\n        for (; N > 0; N /= 10) res += (int)Math.pow(10, N % 10);\\n        return res;\\n    }\\n```\n```\\n    def reorderedPowerOf2(self, N):\\n        c = collections.Counter(str(N))\\n        return any(c == collections.Counter(str(1 << i)) for i in xrange(30))\\n```\n```\\n    def reorderedPowerOf2(self, N):\\n        return sorted(str(N)) in [sorted(str(1 << i)) for i in range(30)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 151949,
                "title": "simple-java-solution-based-on-string-sorting",
                "content": "The idea here is similar to that of group Anagrams problem (Leetcode #49). \\n\\nFirst, we convert the input number (N) into a string and sort the string. Next, we get the digits that form the power of 2 (by using 1 << i and vary i), convert them into a string, and then sort them. As we convert the powers of 2 (and there are only 31 that are <= 10^9), for each power of 2, we compare if the string is equal to that of string based on N. If the two strings are equal, then we return true.\\n\\n```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        char[] a1 = String.valueOf(N).toCharArray();\\n        Arrays.sort(a1);\\n        String s1 = new String(a1);\\n        \\n        for (int i = 0; i < 31; i++) {\\n            char[] a2 = String.valueOf((int)(1 << i)).toCharArray();\\n            Arrays.sort(a2);\\n            String s2 = new String(a2);\\n            if (s1.equals(s2)) return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        char[] a1 = String.valueOf(N).toCharArray();\\n        Arrays.sort(a1);\\n        String s1 = new String(a1);\\n        \\n        for (int i = 0; i < 31; i++) {\\n            char[] a2 = String.valueOf((int)(1 << i)).toCharArray();\\n            Arrays.sort(a2);\\n            String s2 = new String(a2);\\n            if (s1.equals(s2)) return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120153,
                "title": "c-super-simple-and-short-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        string N_str = sorted_num(N);\\n        for (int i = 0; i < 32; i++)\\n            if (N_str == sorted_num(1 << i)) return true;\\n        return false;\\n    }\\n    \\n    string sorted_num(int n) {\\n        string res = to_string(n);\\n        sort(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        string N_str = sorted_num(N);\\n        for (int i = 0; i < 32; i++)\\n            if (N_str == sorted_num(1 << i)) return true;\\n        return false;\\n    }\\n    \\n    string sorted_num(int n) {\\n        string res = to_string(n);\\n        sort(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2480899,
                "title": "c-100-fast-0ms",
                "content": "```\\nbool reorderedPowerOf2(int n) {\\n        string s = to_string(n);\\n        sort(s.begin(),s.end());\\n\\t\\t\\n        vector<string> power;\\n        for(int i=0;i<=30;i++){\\n            int p = pow(2,i);\\n            power.push_back(to_string(p));\\n        }\\n        \\n        for(int i=0;i<=30;i++){\\n            sort(power[i].begin(),power[i].end());\\n        }\\n        \\n        for(int i=0;i<=30;i++){\\n            if(power[i] == s ) return true;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool reorderedPowerOf2(int n) {\\n        string s = to_string(n);\\n        sort(s.begin(),s.end());\\n\\t\\t\\n        vector<string> power;\\n        for(int i=0;i<=30;i++){\\n            int p = pow(2,i);\\n            power.push_back(to_string(p));\\n        }\\n        \\n        for(int i=0;i<=30;i++){\\n            sort(power[i].begin(),power[i].end());\\n        }\\n        \\n        for(int i=0;i<=30;i++){\\n            if(power[i] == s ) return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1120106,
                "title": "js-python-java-c-easy-short-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe easiest way to check if two things are shuffled versions of each other, which is what this problem is asking us to do, is to sort them both and the compare the result.\\n\\nIn that sense, the easiest solution here is to do exactly that: we can convert **N** to an array of its digits, sort it, then compare that result to the result of the same process on each power of **2**.\\n\\nSince the constraint upon **N** is **10e9**, we only need to check powers in the range **[0,29]**.\\n\\nTo make things easier to compare, we can always **join()** the resulting digit arrays into strings before comparison.\\n\\nThere are ways to very slightly improve the run time and memory here, but with an operation this small, it\\'s honestly not very necessary.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nPython can directly compare the lists and Java can directly compare the char arrays without needing to join them into strings. C++ can sort the strings in-place without needing to convert to an array.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 38.8MB** (beats 100% / 44).\\n```javascript\\nvar reorderedPowerOf2 = function(N) {\\n    let res = N.toString().split(\"\").sort().join(\"\")\\n    for (let i = 0; i < 30; i++)\\n        if ((1 << i).toString().split(\"\").sort().join(\"\") === res) return true\\n    return false\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **24ms / 14.1MB** (beats 98% / 76%).\\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        res = sorted([int(x) for x in str(N)])\\n        for i in range(30):\\n            if sorted([int(x) for x in str(1 << i)]) == res: return True\\n        return False\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **1ms / 35.8MB** (beats 97% / 88%).\\n```java\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        char[] res1 = String.valueOf(N).toCharArray();\\n        Arrays.sort(res1);\\n        for (int i = 0; i < 30; i++) {\\n            char[] res2 = String.valueOf(1 << i).toCharArray();\\n            Arrays.sort(res2);\\n            if (Arrays.equals(res1, res2)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 5.8MB** (beats 100% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        string res1 = to_string(N);\\n        sort(res1.begin(), res1.end());\\n        for (int i = 0; i < 30; i++) {\\n            string res2 = to_string(1 << i);\\n            sort(res2.begin(), res2.end());\\n            if (res1 == res2) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar reorderedPowerOf2 = function(N) {\\n    let res = N.toString().split(\"\").sort().join(\"\")\\n    for (let i = 0; i < 30; i++)\\n        if ((1 << i).toString().split(\"\").sort().join(\"\") === res) return true\\n    return false\\n};\\n```\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        res = sorted([int(x) for x in str(N)])\\n        for i in range(30):\\n            if sorted([int(x) for x in str(1 << i)]) == res: return True\\n        return False\\n```\n```java\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        char[] res1 = String.valueOf(N).toCharArray();\\n        Arrays.sort(res1);\\n        for (int i = 0; i < 30; i++) {\\n            char[] res2 = String.valueOf(1 << i).toCharArray();\\n            Arrays.sort(res2);\\n            if (Arrays.equals(res1, res2)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        string res1 = to_string(N);\\n        sort(res1.begin(), res1.end());\\n        for (int i = 0; i < 30; i++) {\\n            string res2 = to_string(1 << i);\\n            sort(res2.begin(), res2.end());\\n            if (res1 == res2) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481219,
                "title": "quick-math",
                "content": "The main idea is what powers of 2 look like in binary form:\\n\\n<img width=\"200\" src=\"https://assets.leetcode.com/users/images/ae9964b4-ffbd-40a5-a934-e3dc1de49d28_1661482426.3498342.png\">\\n\\nthis will help easily iterate over all powers of two\\n\\nSo all we need is to convert n to sorted digits and then compare them with the sorted digits for each power of two.\\n`n <= 10e9`, we only need to check powers in the range `[0,29]`\\n\\na little explanation of how the shift operation `<< `works: \\n\\n<img src=\"https://assets.leetcode.com/users/images/df39060e-624d-4fb8-abe2-e3f1da6d0bf9_1661486107.3084147.png\">\\n\\n\\n##### Java\\n\\n```java\\npublic boolean reorderedPowerOf2(int n) {\\n        char[] number = sortedDigits(n);\\n\\n        for (int i = 0; i < 30; ++i) {\\n            char[] powerOfTwo = sortedDigits(1 << i);\\n            if (Arrays.equals(number, powerOfTwo))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    private char[] sortedDigits(int n) {\\n        char[] digits = String.valueOf(n).toCharArray();\\n        Arrays.sort(digits);\\n        return digits;\\n    }\\n```\\n\\n##### C++\\n\\n```\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        string number = sortedDigits(n);\\n\\n        for (int i = 0; i < 30; ++i) {\\n            string powerOfTwo = sortedDigits(1 << i);\\n            if (number == powerOfTwo)\\n                return true;\\n        }\\n\\n        return false;\\n    }\\n\\nprivate:\\n    string sortedDigits(int n) {\\n        string digits = to_string(n);\\n        sort(digits.begin(), digits.end());\\n        return digits;\\n    }\\n```\\n\\n##### Python\\n```python\\ndef reorderedPowerOf2(self, n: int) -> bool:\\n        digits = Counter(str(n))\\n        \\n        for i in range(30):\\n            powerOfTwo = str(1 << i)\\n            if digits == Counter(powerOfTwo):\\n                return True\\n        return False\\n```\\n\\nMy repositories with leetcode problems solving - [Java](https://github.com/FLlGHT/algorithms/tree/master/j-algorithms/src/main/java),  [C++](https://github.com/FLlGHT/algorithms/tree/master/c-algorithms/src/main/c%2B%2B)\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\npublic boolean reorderedPowerOf2(int n) {\\n        char[] number = sortedDigits(n);\\n\\n        for (int i = 0; i < 30; ++i) {\\n            char[] powerOfTwo = sortedDigits(1 << i);\\n            if (Arrays.equals(number, powerOfTwo))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    private char[] sortedDigits(int n) {\\n        char[] digits = String.valueOf(n).toCharArray();\\n        Arrays.sort(digits);\\n        return digits;\\n    }\\n```\n```\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        string number = sortedDigits(n);\\n\\n        for (int i = 0; i < 30; ++i) {\\n            string powerOfTwo = sortedDigits(1 << i);\\n            if (number == powerOfTwo)\\n                return true;\\n        }\\n\\n        return false;\\n    }\\n\\nprivate:\\n    string sortedDigits(int n) {\\n        string digits = to_string(n);\\n        sort(digits.begin(), digits.end());\\n        return digits;\\n    }\\n```\n```python\\ndef reorderedPowerOf2(self, n: int) -> bool:\\n        digits = Counter(str(n))\\n        \\n        for i in range(30):\\n            powerOfTwo = str(1 << i)\\n            if digits == Counter(powerOfTwo):\\n                return True\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1120216,
                "title": "reordered-power-of-2-short-easy-w-explanation-beats-100",
                "content": "***Solution - I (Counting Digits Frequency)***\\n\\nA simple solution is to check if frequency of digits in N and all powers of 2 less than `10^9` are equal. In our case, we need to check for all powers of 2 from `2^0` to `2^29` and if any of them matches with digits in `N`, return true.\\n\\n```\\n// counts frequency of each digit in given number N and returns it as vector\\nvector<int> countDigits(int N){\\n\\tvector<int>digitsInN(10);\\n\\twhile(N)\\n\\t\\tdigitsInN[N % 10]++, N /= 10;\\n\\treturn digitsInN;\\n}\\nbool reorderedPowerOf2(int N) {\\n\\tvector<int> digitsInN = countDigits(N); // freq of digits in N\\n\\t// powOf2 goes from 2^0 to 2^29 and each time freq of digits in powOf2 is compared with digitsInN\\n\\tfor(int i = 0, powOf2 = 1; i < 30; i++, powOf2 <<= 1)\\n\\t\\tif(digitsInN == countDigits(powOf2)) return true;  // return true if both have same frequency of each digits\\n\\treturn false;\\n}\\n```\\n\\n**Time Complexity :** **`O(logn)`**, where `n` is maximum power of 2 for which digits are counted (2^30). More specifically the time complexity can be written as `O(logN + log2 + log4 + ... + log(2^30))` which after ignoring the constant factors and lower order terms comes out to `O(logn)`.\\n**Time Complexity :** **`O(1)`**. We are using vector to store digits of `N` and powers of 2 but they are taking constant space and don\\'t depend on the input `N`.\\n\\n---------\\n---------\\n\\n***Solution - II (Convert to string & sort)***\\n\\nWe can convert `N` to string, sort it and compare it with every power of 2 by converting and sorting that as well.\\n\\n```\\nbool reorderedPowerOf2(int N) {\\n\\tstring n = to_string(N);\\n\\tsort(begin(n), end(n));\\n\\tfor(int i = 0, powOf2 = 1; i < 30; i++, powOf2 <<= 1){\\n\\t\\tstring pow2_str = to_string(powOf2);\\n\\t\\tsort(begin(pow2_str), end(pow2_str));\\n\\t\\tif(n == pow2_str) return true;  \\n\\t}\\n\\treturn false;\\n}\\n```\\n\\n-------\\n\\nBoth solutions have the same run-time -\\n\\n![image](https://assets.leetcode.com/users/images/ec72eb4f-071d-4c4f-91b1-c6c098015f29_1616318669.6588662.png)\\n\\n-------\\n-------",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// counts frequency of each digit in given number N and returns it as vector\\nvector<int> countDigits(int N){\\n\\tvector<int>digitsInN(10);\\n\\twhile(N)\\n\\t\\tdigitsInN[N % 10]++, N /= 10;\\n\\treturn digitsInN;\\n}\\nbool reorderedPowerOf2(int N) {\\n\\tvector<int> digitsInN = countDigits(N); // freq of digits in N\\n\\t// powOf2 goes from 2^0 to 2^29 and each time freq of digits in powOf2 is compared with digitsInN\\n\\tfor(int i = 0, powOf2 = 1; i < 30; i++, powOf2 <<= 1)\\n\\t\\tif(digitsInN == countDigits(powOf2)) return true;  // return true if both have same frequency of each digits\\n\\treturn false;\\n}\\n```\n```\\nbool reorderedPowerOf2(int N) {\\n\\tstring n = to_string(N);\\n\\tsort(begin(n), end(n));\\n\\tfor(int i = 0, powOf2 = 1; i < 30; i++, powOf2 <<= 1){\\n\\t\\tstring pow2_str = to_string(powOf2);\\n\\t\\tsort(begin(pow2_str), end(pow2_str));\\n\\t\\tif(n == pow2_str) return true;  \\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2481714,
                "title": "easy-java-solution-100-faster-1ms-with-basic-explanation",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n\\nbasically we are finding occurrence of each digit in n after that we are finding same occurrence of each digit of each power of 2 which is in range between (2^0 to 2^30) if any power of 2 matches same occurence than we can return true if none of the power of 2 matches with occurence of our number n we return false\\n\\n```\\npublic boolean reorderedPowerOf2(int n) {\\n        int Count[] = Count(n);\\n        int power = 1;\\n        for (int i = 0; i < 31; i++) {\\n            int[] PowerCount = Count(power);\\n            if (Equal(Count, PowerCount)) {\\n                return true;\\n            }\\n            power *= 2;\\n        }\\n        return false;\\n    }\\n\\n    private int[] Count(int n) { // Counting Occurence of each digit\\n        int Count[] = new int[10];\\n        while (n != 0) {\\n            Count[n % 10]++;\\n            n /= 10;\\n        }\\n        return Count;\\n    }\\n\\n    private boolean Equal(int ar1[], int ar2[]) {\\n        for (int i = 0; i < ar2.length; i++) {\\n            if (ar1[i] != ar2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Counting"
                ],
                "code": "```\\npublic boolean reorderedPowerOf2(int n) {\\n        int Count[] = Count(n);\\n        int power = 1;\\n        for (int i = 0; i < 31; i++) {\\n            int[] PowerCount = Count(power);\\n            if (Equal(Count, PowerCount)) {\\n                return true;\\n            }\\n            power *= 2;\\n        }\\n        return false;\\n    }\\n\\n    private int[] Count(int n) { // Counting Occurence of each digit\\n        int Count[] = new int[10];\\n        while (n != 0) {\\n            Count[n % 10]++;\\n            n /= 10;\\n        }\\n        return Count;\\n    }\\n\\n    private boolean Equal(int ar1[], int ar2[]) {\\n        for (int i = 0; i < ar2.length; i++) {\\n            if (ar1[i] != ar2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2482894,
                "title": "python-easily-understood-faster-than-96-fast",
                "content": "**Appreciate if you could upvote this solution**\\n\\nSince the maximun of `n` is 10^9 and the `len(str(10**9))` is 10 which is complicated to get all the combinations of the digits.\\n\\nThus, we resolved this questions to:\\n**If the digit combination of n match the digit combinations of all the power of 2**\\n\\nThen, it is much more easier as we need to compare n with 30 numbers only which are\\n```\\n2^0\\n2^1\\n... \\n2^30\\n```\\n\\nFor the digit combinations, there are 2 methons to handle:\\n\\n1) Dict: Count the occurrences of all digits\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        return sorted(str(n)) in [Counter(str(1 << i)) for i in range(30)] \\n```\\n\\n2) String: Sort all the digits\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        return sorted(str(n)) in [sorted(str(1 << i)) for i in range(30)] \\n```\\n\\n**Time Complexity**: \\n - Counter -  `O(n)`\\n - Sort - `O(nlogn)`\\n\\n**Space Complexity**: `O(1)`\\n<br />\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n2^0\\n2^1\\n... \\n2^30\\n```\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        return sorted(str(n)) in [Counter(str(1 << i)) for i in range(30)] \\n```\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        return sorted(str(n)) in [sorted(str(1 << i)) for i in range(30)] \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482392,
                "title": "python-one-liner-bit-shift-detailed-explain-beginner-friendly-easy-understand",
                "content": "**Main idea:**\\n1. We loop through 1 to 2^29 using Bit shift.\\n2. And using Counter() to check if every digit in n is in power of two.\\n\\n**One-liner code:**\\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        return Counter(str(n)) in [Counter(str(1 << i)) for i in range(30)]\\n```\\n\\nAnd here\\'s the code for better understand:\\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        digits = Counter(str(n))\\n        \\n        for i in range(30):\\n            if digits == Counter(str(1 << i)):\\n                return True\\n        return False\\n```\\n\\nFor those who don\\'t know bit shift:\\nThis is how power of 2 in binary looks like:\\nAnd we keep left shift the number to get every power of 2.\\n```\\n1  -> 1\\n2  -> 10\\n4  -> 100\\n8  -> 1000\\n16 -> 10000\\n32 -> 100000\\n64 -> 1000000\\n```\\n**Please UPVOTE if you LIKE!!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        return Counter(str(n)) in [Counter(str(1 << i)) for i in range(30)]\\n```\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        digits = Counter(str(n))\\n        \\n        for i in range(30):\\n            if digits == Counter(str(1 << i)):\\n                return True\\n        return False\\n```\n```\\n1  -> 1\\n2  -> 10\\n4  -> 100\\n8  -> 1000\\n16 -> 10000\\n32 -> 100000\\n64 -> 1000000\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120606,
                "title": "python-solution-detailed-explanation-with-example",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe know that in this question, the input n is less and equal to 10\\u2079 so the powers of 2 can be 1, 2, 4, and 8 all the way up to 2 to the power of 29 since 2\\xB2\\u2079 is less than 10\\u2079 and 10\\u2079 is less than 2\\xB3\\u2070.\\n\\n![image.png](https://assets.leetcode.com/users/images/19613664-10f3-4d4f-8440-7c0698bba38c_1675118248.3209496.png)\\n\\nSince We can reorder the digits in any order, input 218 can be reordered into 128 which is 2 to the power of 7. On the other hand, input 123 returns false since all the combinations of 123 [213, 123, 132, 231, 213, 312, 321] are not the power of 2.\\n\\nThe observation we can make is that reordering digits of a number in any order does not change the number of occurrences of its digits. So the main idea behind solving this question is that we want to count the occurrence of each digit in the input N and compare it with the occurrence of each digit in the powers of 2. If the occurrences are the same, it means that we can reorder the digits of N to have the resulting number as a power of 2. If the occurrence is not the same, it means we can\\u2019t reorder the digits to become a power of 2.\\n\\n![image.png](https://assets.leetcode.com/users/images/e85c5861-3926-4f48-8adc-f48a3336c06c_1675118345.1014912.png)\\n\\nIf we consider the previous example, 218 returns true since 218 and 128 = 2\\u2077 both have one 1, one 2, and one 8. 123 returns false since it does not match any powers of 2.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe start by converting the given number ```N``` to a string and then using the counter method to count the occurrences of each digit in ```N```. We use the variable ```occurrence``` to store the result. \\nNext, we will use a for loop to iterate through the range of 0 to 29. In each iteration, we compare the occurrence of each digit in 2 to the power of i to the occurrences of each digit of the given number ```N```. if they are the same, we return ```True```, otherwise, we increment i and keep comparing. \\nIf the loop completes and no match is found, it means the digits of ```N``` cannot be reordered to form a power of 2, we return ```False```.\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def reorderedPowerOf2(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: bool\\n        \"\"\"\\n        occurrence = Counter(str(n))\\n        for i in range(30):\\n            if (occurrence == Counter(str(2**i))):\\n                return True\\n        return False\\n\\n\\n```\\n\\nCheck out the video solution for this problem:\\nhttps://www.youtube.com/watch?v=4FAdMIoqRes\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```N```\n```N```\n```occurrence```\n```N```\n```True```\n```N```\n```False```\n```\\nclass Solution(object):\\n    def reorderedPowerOf2(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: bool\\n        \"\"\"\\n        occurrence = Counter(str(n))\\n        for i in range(30):\\n            if (occurrence == Counter(str(2**i))):\\n                return True\\n        return False\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120214,
                "title": "simple-easy-w-explanation-beats-100-shortest-clean-code",
                "content": "***Solution - I (Counting Digits Frequency)***\\n\\nA simple solution is to check if frequency of digits in N and all powers of 2 less than `10^9` are equal. In our case, we need to check for all powers of 2 from `2^0` to `2^29` and if any of them matches with digits in `N`, return true.\\n\\n```\\n// counts frequency of each digit in given number N and returns it as vector\\nvector<int> countDigits(int N){\\n\\tvector<int>digitsInN(10);\\n\\twhile(N)\\n\\t\\tdigitsInN[N % 10]++, N /= 10;\\n\\treturn digitsInN;\\n}\\nbool reorderedPowerOf2(int N) {\\n\\tvector<int> digitsInN = countDigits(N); // freq of digits in N\\n\\t// powOf2 goes from 2^0 to 2^29 and each time freq of digits in powOf2 is compared with digitsInN\\n\\tfor(int i = 0, powOf2 = 1; i < 30; i++, powOf2 <<= 1)\\n\\t\\tif(digitsInN == countDigits(powOf2)) return true;  // return true if both have same frequency of each digits\\n\\treturn false;\\n}\\n```\\n\\n**Time Complexity :** **`O(logn)`**, where `n` is maximum power of 2 for which digits are counted (2^30). More specifically the time complexity can be written as `O(logN + log2 + log4 + ... + log(2^30))` which after ignoring the constant factors and lower order terms comes out to `O(logn)`.\\n**Time Complexity :** **`O(1)`**. We are using vector to store digits of `N` and powers of 2 but they are taking constant space and don\\'t depend on the input `N`.\\n\\n---------\\n---------\\n\\n***Solution - II (Convert to string & sort)***\\n\\nWe can convert `N` to string, sort it and compare it with every power of 2 by converting and sorting that as well.\\n\\n```\\nbool reorderedPowerOf2(int N) {\\n\\tstring n = to_string(N);\\n\\tsort(begin(n), end(n));\\n\\tfor(int i = 0, powOf2 = 1; i < 30; i++, powOf2 <<= 1){\\n\\t\\tstring pow2_str = to_string(powOf2);\\n\\t\\tsort(begin(pow2_str), end(pow2_str));\\n\\t\\tif(n == pow2_str) return true;  \\n\\t}\\n\\treturn false;\\n}\\n```\\n\\n-------\\n\\nBoth solutions have the same run-time -\\n\\n![image](https://assets.leetcode.com/users/images/ec72eb4f-071d-4c4f-91b1-c6c098015f29_1616318669.6588662.png)\\n\\n-------\\n-------",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// counts frequency of each digit in given number N and returns it as vector\\nvector<int> countDigits(int N){\\n\\tvector<int>digitsInN(10);\\n\\twhile(N)\\n\\t\\tdigitsInN[N % 10]++, N /= 10;\\n\\treturn digitsInN;\\n}\\nbool reorderedPowerOf2(int N) {\\n\\tvector<int> digitsInN = countDigits(N); // freq of digits in N\\n\\t// powOf2 goes from 2^0 to 2^29 and each time freq of digits in powOf2 is compared with digitsInN\\n\\tfor(int i = 0, powOf2 = 1; i < 30; i++, powOf2 <<= 1)\\n\\t\\tif(digitsInN == countDigits(powOf2)) return true;  // return true if both have same frequency of each digits\\n\\treturn false;\\n}\\n```\n```\\nbool reorderedPowerOf2(int N) {\\n\\tstring n = to_string(N);\\n\\tsort(begin(n), end(n));\\n\\tfor(int i = 0, powOf2 = 1; i < 30; i++, powOf2 <<= 1){\\n\\t\\tstring pow2_str = to_string(powOf2);\\n\\t\\tsort(begin(pow2_str), end(pow2_str));\\n\\t\\tif(n == pow2_str) return true;  \\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1120130,
                "title": "python-find-anagram-explained",
                "content": "This is in fact question about anagrams: given string we need to find if we have another string from list of powers of too, which is anagram of original string. Let us iterate through all powers of two and check if count of this number is equal to count of given number `N`. \\n\\n**Complexity**: time complexity will be `O(log^2 N)`: we check `O(log N)` numbers, each of them have `O(log N)` digits at most. In fact it can be improved to `O(log^2N)`, because there can be at most `4` numbers with given number of digits, but here it just not worth it. Space complexity is `O(log N)`.\\n\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, N):\\n        cnt = Counter(str(N))\\n        return any(cnt == Counter(str(1<<i)) for i in range(30))\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reorderedPowerOf2(self, N):\\n        cnt = Counter(str(N))\\n        return any(cnt == Counter(str(1<<i)) for i in range(30))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120107,
                "title": "reordered-power-of-2-js-python-java-c-easy-short-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe easiest way to check if two things are shuffled versions of each other, which is what this problem is asking us to do, is to sort them both and the compare the result.\\n\\nIn that sense, the easiest solution here is to do exactly that: we can convert **N** to an array of its digits, sort it, then compare that result to the result of the same process on each power of **2**.\\n\\nSince the constraint upon **N** is **10e9**, we only need to check powers in the range **[0,29]**.\\n\\nTo make things easier to compare, we can always **join()** the resulting digit arrays into strings before comparison.\\n\\nThere are ways to very slightly improve the run time and memory here, but with an operation this small, it\\'s honestly not very necessary.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nPython can directly compare the lists and Java can directly compare the char arrays without needing to join them into strings. C++ can sort the strings in-place without needing to convert to an array.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 38.8MB** (beats 100% / 44).\\n```javascript\\nvar reorderedPowerOf2 = function(N) {\\n    let res = N.toString().split(\"\").sort().join(\"\")\\n    for (let i = 0; i < 30; i++)\\n        if ((1 << i).toString().split(\"\").sort().join(\"\") === res) return true\\n    return false\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **24ms / 14.1MB** (beats 98% / 76%).\\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        res = sorted([int(x) for x in str(N)])\\n        for i in range(30):\\n            if sorted([int(x) for x in str(1 << i)]) == res: return True\\n        return False\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **1ms / 35.8MB** (beats 97% / 88%).\\n```java\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        char[] res1 = String.valueOf(N).toCharArray();\\n        Arrays.sort(res1);\\n        for (int i = 0; i < 30; i++) {\\n            char[] res2 = String.valueOf(1 << i).toCharArray();\\n            Arrays.sort(res2);\\n            if (Arrays.equals(res1, res2)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 5.8MB** (beats 100% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        string res1 = to_string(N);\\n        sort(res1.begin(), res1.end());\\n        for (int i = 0; i < 30; i++) {\\n            string res2 = to_string(1 << i);\\n            sort(res2.begin(), res2.end());\\n            if (res1 == res2) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar reorderedPowerOf2 = function(N) {\\n    let res = N.toString().split(\"\").sort().join(\"\")\\n    for (let i = 0; i < 30; i++)\\n        if ((1 << i).toString().split(\"\").sort().join(\"\") === res) return true\\n    return false\\n};\\n```\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        res = sorted([int(x) for x in str(N)])\\n        for i in range(30):\\n            if sorted([int(x) for x in str(1 << i)]) == res: return True\\n        return False\\n```\n```java\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        char[] res1 = String.valueOf(N).toCharArray();\\n        Arrays.sort(res1);\\n        for (int i = 0; i < 30; i++) {\\n            char[] res2 = String.valueOf(1 << i).toCharArray();\\n            Arrays.sort(res2);\\n            if (Arrays.equals(res1, res2)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        string res1 = to_string(N);\\n        sort(res1.begin(), res1.end());\\n        for (int i = 0; i < 30; i++) {\\n            string res2 = to_string(1 << i);\\n            sort(res2.begin(), res2.end());\\n            if (res1 == res2) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481906,
                "title": "from-brute-force-to-optimziation-fully-explained",
                "content": "In this post, I shared my full thought process behind the question, and how I arrived at the optimal solution.\\n\\nIn contrast to just posting the answer, I try to teach and show how to tackle problems and arrive progressively at the optimal solution, instead of memorizing them :)\\n\\n<hr />\\n\\nThe problem states that we are given an integer `n` and we can rearrange it in any order, except leading zero. And we need to check whether we can arrive at a valid power of 2.\\n\\nIn such questions, it\\'s very important to look at the **constraints** because a lot of times it can contradict/hint toward specific solutions. In our case `1 <= n <= 10^9`\\n\\nGiven the constraints, we know that we can have at most 10 digits in n. So generating all permutations will cost us n!, which is **10!** => **3,628,800** (A little less because 0 is invalid in the first position. But that\\'s an upper bound)\\n\\nAlso, we know that a 32-bit integer has 31 powers of 2. You can just shift the active bit to the left. (1 bit it taken for the sign)\\n\\nSo the initial idea can be to generate a set containing all the powers of 2, and to generate a set of all the permutations, and then check whether there is an element that is intersecting between both sets.\\n\\n# Naive brute force\\n\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        int32_powers_of_two = set()\\n        for i in range(31):\\n            int32_powers_of_two.add(1<<i)\\n        \\n        n_numbers = []\\n        while n > 0:\\n            n_numbers.append(n % 10)\\n            n //= 10\\n        \\n        permutations = set()\\n        def generate_permutations(cur_permutation, options):\\n            if not options:\\n                permutations.add(int(cur_permutation))\\n                return\\n            \\n            for i in range(len(options)):\\n                if cur_permutation == \"\" and options[i] == 0: continue\\n                generate_permutations(cur_permutation + str(options[i]), [*options[:i], *options[i+1:]])\\n        \\n        generate_permutations(\"\", n_numbers)\\n        return permutations.intersection(int32_powers_of_two)\\n```\\n\\nThat will TLE on the last test cases. Let\\'s optimize\\n\\n# Optimization\\n\\nOne observation that we can make is that we don\\'t need to generate all the permutations for n. \\n\\nLet\\'s say `n` is `4210`\\n\\nIt\\'s enough for us to look at the powers of two that have 4 digits. i.e. [1024, 2048, 4096, 8192]\\n\\nTake a look, can `n` be reordered to a power of 2? how would you know that efficiently?\\n\\nWhenever you are asked about ordering/shuffling and equality, think about sorting. Sorting will represent the lexicographical order, and if both lexicographical orders are equal, you can reshuffle A to get B.\\n\\nIf we sort `n` = `4210` -> `0124`\\nIf we sort `1024` (a power of 2) -> `0124`\\n\\nBoth are equal, hence we can reorder n to get a power of two.\\n\\n# Algorithm\\n1. We will generate all permutations of 2 within the 32-bit integer range, but store them in buckets relevant to their digit count. This will allow us to look at the powers of 2 that have the same digit count as n\\n2. We will sort `n` (transform to string and sort) and compare against all powers of 2 with the same digit count sorted.\\n3. If we find the same lexicographical order, we can reorder to a valid power of 2. \\n4. If non-matched, we return false after the iteration.\\n\\n\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        buckets = [[] for _ in range(11)]\\n        for i in range(31):\\n            power_of_two = 1<<i\\n            digits_count = math.floor(math.log10(power_of_two)) + 1\\n            buckets[digits_count].append(power_of_two)\\n        \\n        n_str_sorted = \"\".join(sorted(str(n)))\\n        n_digits_count = math.floor(math.log10(n)) + 1\\n        for power_of_two in buckets[n_digits_count]:\\n            if n_str_sorted == \"\".join(sorted(str(power_of_two))):\\n                return True\\n        return False\\n```\\n\\n# Further notes\\n* Instead of sorting you could also count the character frequency and check whether any power of 2 has the same count character count as `n`\\n* Feel free to add a comment with the code in a different language so I\\'ll add them to the post and mention your name.\\n\\n<hr />\\nHave a great day!\\n\\nIf you found this read helpful, please upvote.\\nIt motivates me to do more of them, and also shows me that these posts are helpful for some folks.\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        int32_powers_of_two = set()\\n        for i in range(31):\\n            int32_powers_of_two.add(1<<i)\\n        \\n        n_numbers = []\\n        while n > 0:\\n            n_numbers.append(n % 10)\\n            n //= 10\\n        \\n        permutations = set()\\n        def generate_permutations(cur_permutation, options):\\n            if not options:\\n                permutations.add(int(cur_permutation))\\n                return\\n            \\n            for i in range(len(options)):\\n                if cur_permutation == \"\" and options[i] == 0: continue\\n                generate_permutations(cur_permutation + str(options[i]), [*options[:i], *options[i+1:]])\\n        \\n        generate_permutations(\"\", n_numbers)\\n        return permutations.intersection(int32_powers_of_two)\\n```\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        buckets = [[] for _ in range(11)]\\n        for i in range(31):\\n            power_of_two = 1<<i\\n            digits_count = math.floor(math.log10(power_of_two)) + 1\\n            buckets[digits_count].append(power_of_two)\\n        \\n        n_str_sorted = \"\".join(sorted(str(n)))\\n        n_digits_count = math.floor(math.log10(n)) + 1\\n        for power_of_two in buckets[n_digits_count]:\\n            if n_str_sorted == \"\".join(sorted(str(power_of_two))):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149825,
                "title": "java-naive-backtracking-15-lines",
                "content": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        char[] ca=(N+\"\").toCharArray();\\n        return helper(ca, 0, new boolean[ca.length]);\\n    }\\n    public boolean helper(char[] ca, int cur, boolean[] used){\\n        if (cur!=0 && (cur+\"\").length()==ca.length){\\n            if (Integer.bitCount(cur)==1) return true;\\n            return false;\\n        }\\n        for (int i=0; i<ca.length; i++){\\n            if (used[i]) continue;\\n            used[i]=true;\\n            if (helper(ca, cur*10+ca[i]-\\'0\\', used)) return true;\\n            used[i]=false;\\n        }\\n        return false;\\n    }\\n}\\n```\\nIt would be faster if you use memo to prune.\\n```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        char[] ca=(N+\"\").toCharArray();\\n        return helper(ca, 0, new boolean[ca.length], new HashSet<Integer>());\\n    }\\n    public boolean helper(char[] ca, int cur, boolean[] used, HashSet<Integer> vis){\\n        if (!vis.add(cur)) return false;\\n        if (cur!=0 && (cur+\"\").length()==ca.length){\\n            if (Integer.bitCount(cur)==1) return true;\\n            return false;\\n        }\\n        for (int i=0; i<ca.length; i++){\\n            if (used[i]) continue;\\n            used[i]=true;\\n            if (helper(ca, cur*10+ca[i]-\\'0\\', used, vis)) return true;\\n            used[i]=false;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        char[] ca=(N+\"\").toCharArray();\\n        return helper(ca, 0, new boolean[ca.length]);\\n    }\\n    public boolean helper(char[] ca, int cur, boolean[] used){\\n        if (cur!=0 && (cur+\"\").length()==ca.length){\\n            if (Integer.bitCount(cur)==1) return true;\\n            return false;\\n        }\\n        for (int i=0; i<ca.length; i++){\\n            if (used[i]) continue;\\n            used[i]=true;\\n            if (helper(ca, cur*10+ca[i]-\\'0\\', used)) return true;\\n            used[i]=false;\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        char[] ca=(N+\"\").toCharArray();\\n        return helper(ca, 0, new boolean[ca.length], new HashSet<Integer>());\\n    }\\n    public boolean helper(char[] ca, int cur, boolean[] used, HashSet<Integer> vis){\\n        if (!vis.add(cur)) return false;\\n        if (cur!=0 && (cur+\"\").length()==ca.length){\\n            if (Integer.bitCount(cur)==1) return true;\\n            return false;\\n        }\\n        for (int i=0; i<ca.length; i++){\\n            if (used[i]) continue;\\n            used[i]=true;\\n            if (helper(ca, cur*10+ca[i]-\\'0\\', used, vis)) return true;\\n            used[i]=false;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481202,
                "title": "java-easy-solution-using-hashset",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        Set<Long> two = new HashSet<>();\\n        for (int i = 1; i <= (int)1e9; i <<= 1){\\n            two.add(transform(i));\\n        }\\n\\n        return two.contains(transform(n));\\n    }\\n\\n    private long transform(int n){\\n        long sum = 0;\\n        while(n > 0){\\n            int d = n % 10;\\n            sum += 1L << (d*3);\\n            n /= 10;\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        Set<Long> two = new HashSet<>();\\n        for (int i = 1; i <= (int)1e9; i <<= 1){\\n            two.add(transform(i));\\n        }\\n\\n        return two.contains(transform(n));\\n    }\\n\\n    private long transform(int n){\\n        long sum = 0;\\n        while(n > 0){\\n            int d = n % 10;\\n            sum += 1L << (d*3);\\n            n /= 10;\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120407,
                "title": "clean-and-easy-to-understand-digits-anagram",
                "content": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        for(int i = 0, num = 1; i < 32; i++, num <<= 1)\\n            if(Arrays.equals(digitFreq(N), digitFreq(num)))\\n                return true;\\n        \\n        return false;\\n    }\\n    \\n    private int[] digitFreq(int N) {\\n        int[] f = new int[10];\\n        while(N > 0) {\\n            f[N % 10]++;\\n            N /= 10;\\n        }\\n        \\n        return f;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        for(int i = 0, num = 1; i < 32; i++, num <<= 1)\\n            if(Arrays.equals(digitFreq(N), digitFreq(num)))\\n                return true;\\n        \\n        return false;\\n    }\\n    \\n    private int[] digitFreq(int N) {\\n        int[] f = new int[10];\\n        while(N > 0) {\\n            f[N % 10]++;\\n            N /= 10;\\n        }\\n        \\n        return f;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149827,
                "title": "simple-python-check-upto-2-power-30",
                "content": "```\\n    def reorderedPowerOf2(self, N):\\n        c1 = Counter(str(N))\\n        for i in range(30):\\n            n = int(math.pow(2, i))\\n            if Counter(str(n)) == c1: return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\n    def reorderedPowerOf2(self, N):\\n        c1 = Counter(str(N))\\n        for i in range(30):\\n            n = int(math.pow(2, i))\\n            if Counter(str(n)) == c1: return True\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2481055,
                "title": "python-27-ms-faster-than-100-new-idea-to-improve-other-s-solutions",
                "content": "Like others solutions, i use the same idea of counting the digits and then compare with digits of candidates: ```1, 2, 4, 8, 16, 32, 64 ... 2^30```.\\nBut i noticed that if our input is for example ```251``` we need to compare it only with power of 2 numbers that have exact 3 digits: ```128, 256, 512```, but how can we find out what numbers we need?\\nLet\\'s look for numbers that are powers of 2, their length(number of digits) and their power:\\n```\\nnumbers: 1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192\\nlength:  1 1 1 1  2  2  2   3   3   3    4    4    4    4 \\npower:   0 1 2 3  4  5  6   7   8   9   10   11   12   13\\n```\\nLet\\'s see the pattern between ```length``` and ```power```:\\nIf length of number is 1, power lies between 0 and 3, if length is 2 , power lies between 4 and 6 and etc.\\nSo all we need is to find the formula to know in what boundaries numbers lie.\\nFirst of all what i thought is that power lies in ```((length - 1) * 3 + 1, length * 3 + 1)```, for example for ```length = 2``` range will be ```range(4, 7) = (4, 5, 6)``` is what we needed, but this formula doesn\\'t work for ```length = 1, 4, 7 etc```, because every third length(or every 10th power) there are 4 numbers with this length, that ruins the formula, so i thought \"okay, what if we will add 1 every time when we our numbers length reaches 1, 4, 7 etc...\", or in another words: ```add length // 3```, but now our length of range will always be 4, that is still better than 30.\\nSo now our formula for range is ```((length - 1) * 3 + length // 3, length * 3 + length // 3 + 1)```, maybe there\\'s a way to simplify the formula, but i think it\\'s fine, so the final code is:\\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        from collections import Counter\\n        length = len(str(n))\\n        c = Counter(str(n))\\n        for i in range((length-1) * 3 + length // 3, length * 3 + length // 3 + 1):\\n            candidate = str(1 << i)\\n            if c == Counter(candidate):\\n                return True\\n        return False\\n```\\n\\nIf we replace the Counter with sorted, it can be even faster:\\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        length = len(str(n))\\n        c = sorted(str(n))\\n        for i in range((length-1) * 3 + length // 3, length * 3 + length // 3 + 1):\\n            if c == sorted(str(1 << i)):\\n                return True\\n        return False\\n```\\n![image](https://assets.leetcode.com/users/images/4b1d106b-c511-4fc9-af8c-8c610e325fab_1661479742.4333918.png)\\n\\n```\\nP.S. The formula was obtained by trial and error, \\nbut i came up with the main idea with connection length and power.\\n```\\n\\n```\\nP.P.S. Feel free to ask about something if it\\'s unclear, \\nwrite an improve ment if you have an idea, \\nor point on mistakes(including english) :)\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Sorting"
                ],
                "code": "```1, 2, 4, 8, 16, 32, 64 ... 2^30```\n```251```\n```128, 256, 512```\n```\\nnumbers: 1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192\\nlength:  1 1 1 1  2  2  2   3   3   3    4    4    4    4 \\npower:   0 1 2 3  4  5  6   7   8   9   10   11   12   13\\n```\n```length```\n```power```\n```((length - 1) * 3 + 1, length * 3 + 1)```\n```length = 2```\n```range(4, 7) = (4, 5, 6)```\n```length = 1, 4, 7 etc```\n```add length // 3```\n```((length - 1) * 3 + length // 3, length * 3 + length // 3 + 1)```\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        from collections import Counter\\n        length = len(str(n))\\n        c = Counter(str(n))\\n        for i in range((length-1) * 3 + length // 3, length * 3 + length // 3 + 1):\\n            candidate = str(1 << i)\\n            if c == Counter(candidate):\\n                return True\\n        return False\\n```\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        length = len(str(n))\\n        c = sorted(str(n))\\n        for i in range((length-1) * 3 + length // 3, length * 3 + length // 3 + 1):\\n            if c == sorted(str(1 << i)):\\n                return True\\n        return False\\n```\n```\\nP.S. The formula was obtained by trial and error, \\nbut i came up with the main idea with connection length and power.\\n```\n```\\nP.P.S. Feel free to ask about something if it\\'s unclear, \\nwrite an improve ment if you have an idea, \\nor point on mistakes(including english) :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120140,
                "title": "python-go-o-log-n-by-digit-occurrence-mapping-w-comment",
                "content": "For example:\\n\\nGiven power of 2 = 2 ^ 6 = 64\\n\\n64 => {6: 1, 4: 1}\\n6 shows up one time\\n4 shows up one time\\n\\n---\\n\\nN=46 or N=64 return **true** because their **digit - occurrence mapping** are the same with 64\\n\\n46 => {4: 1, 6: 1}\\n4 shows up one time\\n6 shows up one time\\n\\n64 => {6: 1, 4: 1}\\n6 shows up one time\\n4 shows up one time\\n\\n---\\n\\n**Implementation** by digit - occurrence mapping\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        \\n        # digit <-> occurrence mapping of N\\n        signature_of_N = Counter(str(N))\\n        \\n        \\n        # check each possible power of 2\\n        for i in range(32):\\n            \\n            # get power of 2 by bitwise operation\\n            power_of_2 = 1 << i\\n                \\n            if Counter( str(power_of_2) ) == signature_of_N:\\n                \\n                # Accept if at least one power of 2\\'s mapping is the same with N\\'s mapping\\n                return True\\n        \\n        # Reject otherwise\\n        return False\\n```\\n\\n---\\n\\n**Implementation** by digit - occurrence mapping based on recursion and decimal representation\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        \\n        def make_signature(n: int):\\n            \\n\\t\\t\\t## base case\\n            if n == 0:\\n                return 0\\n            \\n\\t\\t\\t\\n\\t\\t\\t## general case\\n\\t\\t\\t\\n            leading, remaining = divmod(n, 10)\\n            return make_signature(leading) + ( 10 ** remaining )\\n        \\n        # ---------------------------------------------------------\\n        \\n        signature_of_N = make_signature(N)\\n        \\n\\t\\t# check each possible power of 2\\n        for i in range(32):\\n            \\n\\t\\t\\t# get power of 2 by bitwise operation, and check signature\\n            if make_signature( 1 << i ) == signature_of_N:\\n\\t\\t\\t\\n\\t\\t\\t\\t# Accept if at least one power of 2\\'s signature is the same with N\\'s signature\\n                return True\\n        \\n\\t\\t# Reject otherwise\\n        return False\\n```\\n\\n---\\n\\n**Implementation** by digit - occurrence mapping based on recursion and decimal representation\\n\\nGo:\\n\\n```\\nfunc reorderedPowerOf2(N int) bool {\\n \\n    var makeSignature func(n int) int\\n    \\n    makeSignature = func(n int) int {\\n        \\n        if n == 0{\\n            // base case\\n            return 0\\n        }\\n        \\n        // general case\\n        leading, remaining := n / 10, n % 10\\n        return makeSignature( leading ) + int( math.Pow(10, float64(remaining) ) )\\n        \\n    }\\n    \\n    // -----------------------------------------------------\\n    \\n    signatureN := makeSignature( N )\\n    \\n    // check each possible power of 2\\n    for i := 0 ; i < 32 ; i++ {\\n        \\n        if makeSignature( 1 << i ) == signatureN{\\n            \\n            // Accept if at least one power of 2\\'s signature is the smae with N\\'s\\n            return true\\n        }\\n        \\n    }\\n    \\n    // Reject otherwise\\n    return false\\n}\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about specialized dictionary Counter( ... )](https://docs.python.org/3/library/collections.html#collections.Counter)\\n\\n[2] [Python official docs about bitwise operation](https://wiki.python.org/moin/BitwiseOperators)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Go",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        \\n        # digit <-> occurrence mapping of N\\n        signature_of_N = Counter(str(N))\\n        \\n        \\n        # check each possible power of 2\\n        for i in range(32):\\n            \\n            # get power of 2 by bitwise operation\\n            power_of_2 = 1 << i\\n                \\n            if Counter( str(power_of_2) ) == signature_of_N:\\n                \\n                # Accept if at least one power of 2\\'s mapping is the same with N\\'s mapping\\n                return True\\n        \\n        # Reject otherwise\\n        return False\\n```\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        \\n        def make_signature(n: int):\\n            \\n\\t\\t\\t## base case\\n            if n == 0:\\n                return 0\\n            \\n\\t\\t\\t\\n\\t\\t\\t## general case\\n\\t\\t\\t\\n            leading, remaining = divmod(n, 10)\\n            return make_signature(leading) + ( 10 ** remaining )\\n        \\n        # ---------------------------------------------------------\\n        \\n        signature_of_N = make_signature(N)\\n        \\n\\t\\t# check each possible power of 2\\n        for i in range(32):\\n            \\n\\t\\t\\t# get power of 2 by bitwise operation, and check signature\\n            if make_signature( 1 << i ) == signature_of_N:\\n\\t\\t\\t\\n\\t\\t\\t\\t# Accept if at least one power of 2\\'s signature is the same with N\\'s signature\\n                return True\\n        \\n\\t\\t# Reject otherwise\\n        return False\\n```\n```\\nfunc reorderedPowerOf2(N int) bool {\\n \\n    var makeSignature func(n int) int\\n    \\n    makeSignature = func(n int) int {\\n        \\n        if n == 0{\\n            // base case\\n            return 0\\n        }\\n        \\n        // general case\\n        leading, remaining := n / 10, n % 10\\n        return makeSignature( leading ) + int( math.Pow(10, float64(remaining) ) )\\n        \\n    }\\n    \\n    // -----------------------------------------------------\\n    \\n    signatureN := makeSignature( N )\\n    \\n    // check each possible power of 2\\n    for i := 0 ; i < 32 ; i++ {\\n        \\n        if makeSignature( 1 << i ) == signatureN{\\n            \\n            // Accept if at least one power of 2\\'s signature is the smae with N\\'s\\n            return true\\n        }\\n        \\n    }\\n    \\n    // Reject otherwise\\n    return false\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159513,
                "title": "c-0ms-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        set<string> si = {\"1\", \"2\", \"4\", \"8\", \"16\", \"23\", \"46\", \"128\", \"256\", \"125\", \"0124\", \"0248\", \"0469\", \"1289\",\\n                          \"13468\", \"23678\", \"35566\", \"011237\", \"122446\", \"224588\", \"0145678\", \"0122579\", \"0134449\",\\n                          \"0368888\", \"11266777\", \"23334455\", \"01466788\", \"112234778\", \"234455668\", \"012356789\",\\n        };\\n        string t = to_string(N);\\n        sort(t.begin(), t.end());\\n        return si.count(t) > 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        set<string> si = {\"1\", \"2\", \"4\", \"8\", \"16\", \"23\", \"46\", \"128\", \"256\", \"125\", \"0124\", \"0248\", \"0469\", \"1289\",\\n                          \"13468\", \"23678\", \"35566\", \"011237\", \"122446\", \"224588\", \"0145678\", \"0122579\", \"0134449\",\\n                          \"0368888\", \"11266777\", \"23334455\", \"01466788\", \"112234778\", \"234455668\", \"012356789\",\\n        };\\n        string t = to_string(N);\\n        sort(t.begin(), t.end());\\n        return si.count(t) > 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481179,
                "title": "c-easy-solution-of-vector",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> Helper(long n){\\n        vector<int>num(10);\\n        \\n        while(n){\\n            num[n%10]++;\\n            n=n/10;\\n        }\\n        return num;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n        vector<int>v=Helper(n);\\n        for(int i=0;i<31;i++){\\n            if(v==Helper(1<<i)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n# **Please share and Upvote it keeps me motivated**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> Helper(long n){\\n        vector<int>num(10);\\n        \\n        while(n){\\n            num[n%10]++;\\n            n=n/10;\\n        }\\n        return num;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n        vector<int>v=Helper(n);\\n        for(int i=0;i<31;i++){\\n            if(v==Helper(1<<i)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150340,
                "title": "possibly-fastest-c-solution-using-multiset-0ms-runtime",
                "content": "**So, the idea is very simple:**\\n1. Convert `N` into a multiset of its digits, for an example, if `N = 426412` then the multiset will contain `{1, 2, 2, 4, 4, 6}`.\\n2. Now, we will generate some 2\\'s power and will convert them into another multiset as well, **if both multiset are same**, function will return **true**\\n3. To speed up the process we don\\'t need to find all `2`\\'s power. In fact, it will depent on `N`, if `N` has `6` digits, I compute `2^12 to 2^20`, the above number is `2^18`, when both set matches, we just return true.\\n\\n```\\nprivate:    \\n    multiset<int> convert(int num) {        //  this function converts a number into a multiset of its digit.\\n        multiset<int> allDigit;\\n        while(num) { allDigit.insert(num%10); num /= 10; }\\n        return allDigit;\\n    }\\n    \\npublic:\\n    bool reorderedPowerOf2(int N) {\\n    \\n        if(N<10) {                                          //  for single digit\\n            if (N==1 || N==2 || N==4 || N==8) return true;\\n            return false;\\n        }\\n\\n        multiset<int> digitN;\\n        int num = N, cc=0, powerOf2=8;\\n\\n        while(num) { digitN.insert(num%10); num /= 10; cc++;}\\n\\n        for(int i=4; i <= 4*cc; i++) {      //  number of digit in decimal <= 4 * number of digit in binary\\n            powerOf2 *= 2;\\n            multiset<int> digitNum = convert(powerOf2);\\n            if(digitNum == digitN) return true;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nprivate:    \\n    multiset<int> convert(int num) {        //  this function converts a number into a multiset of its digit.\\n        multiset<int> allDigit;\\n        while(num) { allDigit.insert(num%10); num /= 10; }\\n        return allDigit;\\n    }\\n    \\npublic:\\n    bool reorderedPowerOf2(int N) {\\n    \\n        if(N<10) {                                          //  for single digit\\n            if (N==1 || N==2 || N==4 || N==8) return true;\\n            return false;\\n        }\\n\\n        multiset<int> digitN;\\n        int num = N, cc=0, powerOf2=8;\\n\\n        while(num) { digitN.insert(num%10); num /= 10; cc++;}\\n\\n        for(int i=4; i <= 4*cc; i++) {      //  number of digit in decimal <= 4 * number of digit in binary\\n            powerOf2 *= 2;\\n            multiset<int> digitNum = convert(powerOf2);\\n            if(digitNum == digitN) return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2481234,
                "title": "leetcode-the-hard-way-easy-sorting-with-explanation",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string sortStr(int n) {\\n        // since the input is an integer,\\n        // we convert it to a string first\\n        string t = to_string(n);\\n        // use STL to sort\\n        sort(t.begin(), t.end());\\n        // return the string\\n        return t;\\n    }\\n    \\n    // the idea is to sort `n` and compare all sorted power of two\\n    // if they are matched, then it means they can be reordered to each other\\n    bool reorderedPowerOf2(int n) {\\n        // since the sorted string of n is always same\\n        // so we convert it here instead of doing it in the loop\\n        string s = sortStr(n);\\n        for (int i = 0; i < 30; i++) {\\n            // power of 2 = 1 << i\\n            // we sort each power of 2 string\\n            string t = sortStr(1 << i);\\n            // and compare with `s`\\n            // if they are matched, then return true\\n            if (s == t) return true;\\n        }\\n        // otherwise it is not possible to reorder to a power of 2\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string sortStr(int n) {\\n        // since the input is an integer,\\n        // we convert it to a string first\\n        string t = to_string(n);\\n        // use STL to sort\\n        sort(t.begin(), t.end());\\n        // return the string\\n        return t;\\n    }\\n    \\n    // the idea is to sort `n` and compare all sorted power of two\\n    // if they are matched, then it means they can be reordered to each other\\n    bool reorderedPowerOf2(int n) {\\n        // since the sorted string of n is always same\\n        // so we convert it here instead of doing it in the loop\\n        string s = sortStr(n);\\n        for (int i = 0; i < 30; i++) {\\n            // power of 2 = 1 << i\\n            // we sort each power of 2 string\\n            string t = sortStr(1 << i);\\n            // and compare with `s`\\n            // if they are matched, then return true\\n            if (s == t) return true;\\n        }\\n        // otherwise it is not possible to reorder to a power of 2\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121867,
                "title": "javascript-easy-to-understand-4-solutions",
                "content": "For this problem, there are 2 main strategies to solve it:\\n- One is following the rules in the description and try every possible option.\\n- Another one is to try to find a way to serialize the number and check whether the serialization for `N` matches any serialization of power of 2.\\n\\n## SOLUTION 1\\n\\nFirst, we try the most straight forward solution - validate every reordered sequence of `N` and check if it\\'s the power of 2.\\n\\n```js\\nconst set = new Set();\\nfor (let cur = 1; cur < 10 ** 9; cur <<= 1) {\\n  set.add(String(cur));\\n}\\n\\nconst validate = (left, cur = \"\") => {\\n  if (left.length === 1) return set.has(cur + left[0]);\\n  for (let i = 0; i < left.length; ++i) {\\n    const next = left.slice(0, i) + left.slice(i + 1);\\n    if (validate(next, cur + left[i])) return true;\\n  }\\n  return false;\\n};\\n\\nconst reorderedPowerOf2 = (n) => validate(String(n));\\n```\\n\\n## SOLUTION 2\\n\\nWe could find out all the possible sequences for the power of 2 between 1 and 10 ** 9 first. And then just check the mapping for the result.\\n\\n```js\\nconst set = new Set();\\n\\nconst permute = (left, cur = \"\") => {\\n  if (left.length === 1) {\\n    set.add(Number(cur + left[0]));\\n    return;\\n  }\\n  for (let i = 0; i < left.length; ++i) {\\n    if (left[i] === \"0\" && cur.length === 0) continue;\\n    const next = left.slice(0, i) + left.slice(i + 1);\\n    permute(next, cur + left[i]);\\n  }\\n};\\n\\nfor (let cur = 1; cur < 10 ** 9; cur <<= 1) {\\n  permute(String(cur));\\n}\\n\\nconst reorderedPowerOf2 = (n) => set.has(n);\\n```\\n\\n## SOLUTION 3\\n\\nThis solution follows the second strategy. We achieve serialization by counting the occurrences of each number.\\n\\n```js\\nconst set = new Set();\\n\\nconst serialize = str => {\\n  const count = new Uint8Array(10);\\n  const BASE = 48;\\n  for (let i = 0; i < str.length; ++i) {\\n    ++count[str.charCodeAt(i) - BASE];\\n  }\\n  return count.join(\\':\\');\\n};\\n\\nfor (let cur = 1; cur < 10 ** 9; cur <<= 1) {\\n  set.add(serialize(String(cur)));\\n}\\n\\nconst reorderedPowerOf2 = (n) => set.has(serialize(String(n)));\\n```\\n\\n## SOLUTION 4\\n\\nHere we use a more efficient serialization approach.\\nSince the range is `[1, 10 ** 9]`, so for every number, the occurrences must small than 10, which means we could use a number to represent the serialization value. For example, `4510` means there are 4 number 4, 5 number 3, 1 number 2 and 0 number 1.\\n\\n```js\\nconst set = new Set();\\n\\nconst serialize = num => {\\n  let val = 0;\\n  while (num >= 1) {\\n    val += 1 << num % 10;\\n    num /= 10;\\n  }\\n  return val;\\n};\\n\\nfor (let cur = 1; cur < 10 ** 9; cur <<= 1) {\\n  set.add(serialize(cur));\\n}\\n\\nconst reorderedPowerOf2 = (n) => set.has(serialize(n));\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst set = new Set();\\nfor (let cur = 1; cur < 10 ** 9; cur <<= 1) {\\n  set.add(String(cur));\\n}\\n\\nconst validate = (left, cur = \"\") => {\\n  if (left.length === 1) return set.has(cur + left[0]);\\n  for (let i = 0; i < left.length; ++i) {\\n    const next = left.slice(0, i) + left.slice(i + 1);\\n    if (validate(next, cur + left[i])) return true;\\n  }\\n  return false;\\n};\\n\\nconst reorderedPowerOf2 = (n) => validate(String(n));\\n```\n```js\\nconst set = new Set();\\n\\nconst permute = (left, cur = \"\") => {\\n  if (left.length === 1) {\\n    set.add(Number(cur + left[0]));\\n    return;\\n  }\\n  for (let i = 0; i < left.length; ++i) {\\n    if (left[i] === \"0\" && cur.length === 0) continue;\\n    const next = left.slice(0, i) + left.slice(i + 1);\\n    permute(next, cur + left[i]);\\n  }\\n};\\n\\nfor (let cur = 1; cur < 10 ** 9; cur <<= 1) {\\n  permute(String(cur));\\n}\\n\\nconst reorderedPowerOf2 = (n) => set.has(n);\\n```\n```js\\nconst set = new Set();\\n\\nconst serialize = str => {\\n  const count = new Uint8Array(10);\\n  const BASE = 48;\\n  for (let i = 0; i < str.length; ++i) {\\n    ++count[str.charCodeAt(i) - BASE];\\n  }\\n  return count.join(\\':\\');\\n};\\n\\nfor (let cur = 1; cur < 10 ** 9; cur <<= 1) {\\n  set.add(serialize(String(cur)));\\n}\\n\\nconst reorderedPowerOf2 = (n) => set.has(serialize(String(n)));\\n```\n```js\\nconst set = new Set();\\n\\nconst serialize = num => {\\n  let val = 0;\\n  while (num >= 1) {\\n    val += 1 << num % 10;\\n    num /= 10;\\n  }\\n  return val;\\n};\\n\\nfor (let cur = 1; cur < 10 ** 9; cur <<= 1) {\\n  set.add(serialize(cur));\\n}\\n\\nconst reorderedPowerOf2 = (n) => set.has(serialize(n));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2483824,
                "title": "c-efficient-solution-easy",
                "content": "```\\nbool reorderedPowerOf2(int n) {\\n        \\n    if(n==1)\\n        return true;\\n    \\n    string num = to_string(n);\\n    sort(num.begin(),num.end());\\n    \\n    unordered_map<string,int> powers;\\n    \\n    //creating all 0 to 29 possible powers of 2;\\n    for(int i =0 ; i<=29; i++){\\n        string str = to_string((int)pow(2,i));      //pow function returns float so we need to convert\\n        sort(str.begin(),str.end());\\n        powers[str] = 1;\\n    }        \\n    \\n    if(powers[num]==1)\\n        return 1;\\n    else\\n        return 0;\\n    \\n}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool reorderedPowerOf2(int n) {\\n        \\n    if(n==1)\\n        return true;\\n    \\n    string num = to_string(n);\\n    sort(num.begin(),num.end());\\n    \\n    unordered_map<string,int> powers;\\n    \\n    //creating all 0 to 29 possible powers of 2;\\n    for(int i =0 ; i<=29; i++){\\n        string str = to_string((int)pow(2,i));      //pow function returns float so we need to convert\\n        sort(str.begin(),str.end());\\n        powers[str] = 1;\\n    }        \\n    \\n    if(powers[num]==1)\\n        return 1;\\n    else\\n        return 0;\\n    \\n}\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2483623,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\nbool isPowerOfTwo(int n) {        \\n    if(n==0)\\n        return 0;\\n        \\n    if(ceil(log2(n)) == floor(log2(n)))\\n        return 1;\\n    else\\n        return 0;            \\n}\\n    \\n    \\nbool reorderedPowerOf2(int n) {\\n        \\n    string num = to_string(n);\\n    sort(num.begin(),num.end());\\n    \\n    do{ \\n        if(num[0]==\\'0\\')                //edge case\\n            continue;\\n\\t\\t\\t\\n        if(isPowerOfTwo(stoi(num)))\\n            return 1;        \\n    }while(next_permutation(num.begin(),num.end()));     \\n    \\n\\treturn 0;\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\nbool isPowerOfTwo(int n) {        \\n    if(n==0)\\n        return 0;\\n        \\n    if(ceil(log2(n)) == floor(log2(n)))\\n        return 1;\\n    else\\n        return 0;            \\n}\\n    \\n    \\nbool reorderedPowerOf2(int n) {\\n        \\n    string num = to_string(n);\\n    sort(num.begin(),num.end());\\n    \\n    do{ \\n        if(num[0]==\\'0\\')                //edge case\\n            continue;\\n\\t\\t\\t\\n        if(isPowerOfTwo(stoi(num)))\\n            return 1;        \\n    }while(next_permutation(num.begin(),num.end()));     \\n    \\n\\treturn 0;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2480861,
                "title": "daily-leetcoding-challenge-august-day-26",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reordered-power-of-2/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Permutations\n\n  \n**Approach 2:** Counting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reordered-power-of-2/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1011051,
                "title": "python-3",
                "content": "```\\ndef reorderedPowerOf2(self, N: int) -> bool:\\n        c, l = collections.Counter(str(N)), len(str(N))\\n        n = 1\\n        while len(str(n)) <= l:\\n            if collections.Counter(str(n)) == c:\\n                return True\\n            n *= 2\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\ndef reorderedPowerOf2(self, N: int) -> bool:\\n        c, l = collections.Counter(str(N)), len(str(N))\\n        n = 1\\n        while len(str(n)) <= l:\\n            if collections.Counter(str(n)) == c:\\n                return True\\n            n *= 2\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 172840,
                "title": "one-line-python-beats-70",
                "content": "```\\nclass Solution:\\n    def reorderedPowerOf2(self, N):\\n        return sorted(str(N)) in [sorted(str(1<<i)) for i in range(33)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reorderedPowerOf2(self, N):\\n        return sorted(str(N)) in [sorted(str(1<<i)) for i in range(33)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484879,
                "title": "lightining-fast-high-iq-marvel-approach",
                "content": "**Logic?**\\n\\nWe have used a special operation here  \" **<<** \" , which is know as **binary left operator**.  The left operands value is moved left by the number of bits specified by the right operand.\\n\\nSo ,\\n*1      = 00000000 00000000 00000000 00000001 = 1*\\n*1 << 1 = 00000000 00000000 00000000 00000010 = 2*\\n*1 << 8 = 00000000 00000000 00000001 00000000 = 256*\\n\\n***for e.g., 1<<6 will be 1(2^6)= 64***\\n\\n***So here we are just trying to store, 2 to the power i***\\n\\nHence, for each value of **i** in for loop it will give us the corresponding **power of 2** which we store in a string as digits!\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        \\n       //Create a string to store the number as individual digits\\n       string num = to_string(n);\\n       \\n       //Sort the string of digits\\n       sort(num.begin(), num.end());\\n        \\n        //It is given that n lies in range [ 1 <= n <= 10^9 ]\\n        //So, if n is a power of 2 it must exist between 2^0(=1) to 2^30(1073741824)\\n        \\n        //Hence, we loop from 0 to 29 and find all corresponding powers of 2\\n        \\n        for(int i = 0; i < 30; i++){\\n            \\n            //For each i, the respective power of 2 can be calculated as:\\n            //**Logic is discussed above**\\n            string powerOf2 = to_string(1 << i);\\n            \\n            //We again convert that number to string and sort its digits\\n            sort(powerOf2.begin(), powerOf2.end());\\n            \\n            //If the resulting sorted string of digits is equal to num string then return True\\n            if(num == powerOf2){\\n                \\n                return true;\\n            }\\n        }\\n        \\n        // Else, that number isn\\'t a power of 2 and so return False\\n        return false;\\n    }\\n};\\n```\\n\\n**@Credits to @rahulvarma5297 and @divyamRai for the original answers!**\\n\\n![image](https://assets.leetcode.com/users/images/eb61f3be-ac79-49cd-9415-6fa8dc469155_1661541899.0942814.jpeg)\\n\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        \\n       //Create a string to store the number as individual digits\\n       string num = to_string(n);\\n       \\n       //Sort the string of digits\\n       sort(num.begin(), num.end());\\n        \\n        //It is given that n lies in range [ 1 <= n <= 10^9 ]\\n        //So, if n is a power of 2 it must exist between 2^0(=1) to 2^30(1073741824)\\n        \\n        //Hence, we loop from 0 to 29 and find all corresponding powers of 2\\n        \\n        for(int i = 0; i < 30; i++){\\n            \\n            //For each i, the respective power of 2 can be calculated as:\\n            //**Logic is discussed above**\\n            string powerOf2 = to_string(1 << i);\\n            \\n            //We again convert that number to string and sort its digits\\n            sort(powerOf2.begin(), powerOf2.end());\\n            \\n            //If the resulting sorted string of digits is equal to num string then return True\\n            if(num == powerOf2){\\n                \\n                return true;\\n            }\\n        }\\n        \\n        // Else, that number isn\\'t a power of 2 and so return False\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484240,
                "title": "best-java-solution",
                "content": "\\n**TC : Calculating the frequency Count for a no would be O(no of digits in N). Also,there could a case where it matches with 2^31 (last power of 2).So the complexity would be O(32*length(2^32) + O(no of digits in N)**\\n```\\nclass Solution { \\n    \\n    public boolean reorderedPowerOf2(int n) \\n    {\\n\\t\\tint [] nFreq=digitFreq(n);\\n        \\n        for(int i=0;i<31;i++) //Within the integer range max power of 2 that lies is 2^31\\n        {\\n            int powerOf2=(int)Math.pow(2,i);\\n            int [] powerOf2FreqCount = digitFreq(powerOf2);            \\n            if(compareFreq(nFreq,powerOf2FreqCount)) \\n                return true;            \\n        }\\n        return false;\\n    }\\n    \\n    private boolean compareFreq (int []nFreq ,int []powerOf2FreqCount){\\n        boolean match=true;\\n        \\n        for(int i=0;i<10;i++){\\n            if(nFreq[i]!=powerOf2FreqCount[i])\\n                return false;            \\n        }\\n        return true;\\n    }\\n    \\n    private int [] digitFreq(int num){\\n        int [] digitFreq=new int [10];\\n        while(num>0){\\n            digitFreq[num%10]++;    //counting freq for each digit so here we extracted the last digit from number ( from right side )\\n            num /= 10; \\n        }\\n        return digitFreq;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution { \\n    \\n    public boolean reorderedPowerOf2(int n) \\n    {\\n\\t\\tint [] nFreq=digitFreq(n);\\n        \\n        for(int i=0;i<31;i++) //Within the integer range max power of 2 that lies is 2^31\\n        {\\n            int powerOf2=(int)Math.pow(2,i);\\n            int [] powerOf2FreqCount = digitFreq(powerOf2);            \\n            if(compareFreq(nFreq,powerOf2FreqCount)) \\n                return true;            \\n        }\\n        return false;\\n    }\\n    \\n    private boolean compareFreq (int []nFreq ,int []powerOf2FreqCount){\\n        boolean match=true;\\n        \\n        for(int i=0;i<10;i++){\\n            if(nFreq[i]!=powerOf2FreqCount[i])\\n                return false;            \\n        }\\n        return true;\\n    }\\n    \\n    private int [] digitFreq(int num){\\n        int [] digitFreq=new int [10];\\n        while(num>0){\\n            digitFreq[num%10]++;    //counting freq for each digit so here we extracted the last digit from number ( from right side )\\n            num /= 10; \\n        }\\n        return digitFreq;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2483526,
                "title": "one-easy-way-to-solve",
                "content": "```\\nvar reorderedPowerOf2 = function(n) {\\n    let str = n.toString();\\n   let initialString =  str.split(\\'\\').sort().join(\\'\\');\\n    \\n    \\n    for(let i=0; i<30; i++){\\n        let tempString = (1<<i).toString();\\n       let finalString = tempString.split(\\'\\').sort().join(\\'\\');\\n        if(initialString===finalString){\\n            return true\\n        }\\n    }\\n    return false\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reorderedPowerOf2 = function(n) {\\n    let str = n.toString();\\n   let initialString =  str.split(\\'\\').sort().join(\\'\\');\\n    \\n    \\n    for(let i=0; i<30; i++){\\n        let tempString = (1<<i).toString();\\n       let finalString = tempString.split(\\'\\').sort().join(\\'\\');\\n        if(initialString===finalString){\\n            return true\\n        }\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2482638,
                "title": "100-00-of-c-2-approach-using-map-and-sorting-optimise-space",
                "content": "**1st approach using only sorting function**\\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) { \\n        vector<string>v;\\n        \\n        for(int i=0;i<=30;i++){\\n            int p = pow(2 , i);\\n            v.push_back(to_string(p));\\n        }\\n        \\n        for(int i=0;i<=30;i++){\\n            sort(v[i].begin() , v[i].end());\\n        }\\n        \\n        string s = to_string(n);\\n        sort(s.begin() , s.end());\\n        \\n        for(int i=0;i<=30;i++){\\n            if(v[i]==s) return true;\\n        }\\n        return false;\\n    }\\n};   \\n```\\n\\n**2nd approach using map**\\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) { \\n\\n         int x = pow(10 , 9);\\n         map<int ,vector<int>>word;\\n         for(int i=1;i<=x;i=i*2){\\n             int k =i;\\n             vector<int>v(10 , 0);\\n             while(k){\\n                 int l = k%10;\\n                 v[l]++;\\n                 k=k/10;\\n             }\\n             word[i]=v;\\n         }\\n        \\n         vector<int> v(10 , 0);\\n         while(n){\\n             int l = n%10;\\n             v[l]++;\\n             n=n/10;\\n         }\\n        \\n         for(int i=1;i<=x;i=i*2){\\n            \\n             vector<int> m=word[i];\\n             bool flag=0;\\n             for(int j=0;j<=9;j++){\\n                if(v[j]!=m[j]){\\n                    flag=1;\\n                }\\n             }\\n             if(flag==0){\\n                 return 1;\\n             }\\n         }\\n         return 0; \\n    }\\n};   \\n```\\n\\n**If you found this solution helpful a upvote is highly appreciated**",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) { \\n        vector<string>v;\\n        \\n        for(int i=0;i<=30;i++){\\n            int p = pow(2 , i);\\n            v.push_back(to_string(p));\\n        }\\n        \\n        for(int i=0;i<=30;i++){\\n            sort(v[i].begin() , v[i].end());\\n        }\\n        \\n        string s = to_string(n);\\n        sort(s.begin() , s.end());\\n        \\n        for(int i=0;i<=30;i++){\\n            if(v[i]==s) return true;\\n        }\\n        return false;\\n    }\\n};   \\n```\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) { \\n\\n         int x = pow(10 , 9);\\n         map<int ,vector<int>>word;\\n         for(int i=1;i<=x;i=i*2){\\n             int k =i;\\n             vector<int>v(10 , 0);\\n             while(k){\\n                 int l = k%10;\\n                 v[l]++;\\n                 k=k/10;\\n             }\\n             word[i]=v;\\n         }\\n        \\n         vector<int> v(10 , 0);\\n         while(n){\\n             int l = n%10;\\n             v[l]++;\\n             n=n/10;\\n         }\\n        \\n         for(int i=1;i<=x;i=i*2){\\n            \\n             vector<int> m=word[i];\\n             bool flag=0;\\n             for(int j=0;j<=9;j++){\\n                if(v[j]!=m[j]){\\n                    flag=1;\\n                }\\n             }\\n             if(flag==0){\\n                 return 1;\\n             }\\n         }\\n         return 0; \\n    }\\n};   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482021,
                "title": "c-0-ms-faster-than-100-00",
                "content": "**C++:**\\n```\\nvector<string> arr = {\"0112344778\",\"011237\",\"0122579\",\\n\"012356789\",\"0124\",\"0134449\",\"0145678\",\"01466788\",\"0248\",\\n\"0368888\",\"0469\",\"1\",\"112234778\",\"11266777\",\"122446\",\\n\"125\",\"128\",\"1289\",\"13468\",\"16\",\"2\",\"224588\",\"23\",\"23334455\",\\n\"234455668\",\"23678\",\"256\",\"35566\",\"4\",\"46\",\"8\"};\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n       string s =  to_string(n);\\n       sort(s.begin(),s.end());\\n       return s == arr[lower_bound(arr.begin(),arr.end(),s)\\n\\t   - arr.begin()];\\n        \\n    }\\n};\\n```\\n\\nStep 1: Convert each power of 2 (upto 30) to string and sort all strings. \\nStep 2: Push the resultant strings to global vector `arr`  in the sorted fashion.\\n\\nYour vector will look like something like this -\\n```\\n[\"0112344778\",\"011237\",\"0122579\",\\n\"012356789\",\"0124\",\"0134449\",\"0145678\",\"01466788\",\"0248\",\\n\"0368888\",\"0469\",\"1\",\"112234778\",\"11266777\",\"122446\",\\n\"125\",\"128\",\"1289\",\"13468\",\"16\",\"2\",\"224588\",\"23\",\"23334455\",\\n\"234455668\",\"23678\",\"256\",\"35566\",\"4\",\"46\",\"8\"]\\n```\\n\\nNow simply convert `n` to string `s`, sort it and apply binary search to find  `s` in `arr`\\nEg - \\nn = 251\\ns = \"251\"\\nafter sorting : s = \"125\"\\nfind index of \"125\" in `arr` and retrive the index\\nhere index will be 16,\\nNow simply check whether string exists or not by `arr[index]==s`\\nreturn it ;)\\n\\n*Upvote if it helped you*\\n\\n",
                "solutionTags": [],
                "code": "```\\nvector<string> arr = {\"0112344778\",\"011237\",\"0122579\",\\n\"012356789\",\"0124\",\"0134449\",\"0145678\",\"01466788\",\"0248\",\\n\"0368888\",\"0469\",\"1\",\"112234778\",\"11266777\",\"122446\",\\n\"125\",\"128\",\"1289\",\"13468\",\"16\",\"2\",\"224588\",\"23\",\"23334455\",\\n\"234455668\",\"23678\",\"256\",\"35566\",\"4\",\"46\",\"8\"};\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n       string s =  to_string(n);\\n       sort(s.begin(),s.end());\\n       return s == arr[lower_bound(arr.begin(),arr.end(),s)\\n\\t   - arr.begin()];\\n        \\n    }\\n};\\n```\n```\\n[\"0112344778\",\"011237\",\"0122579\",\\n\"012356789\",\"0124\",\"0134449\",\"0145678\",\"01466788\",\"0248\",\\n\"0368888\",\"0469\",\"1\",\"112234778\",\"11266777\",\"122446\",\\n\"125\",\"128\",\"1289\",\"13468\",\"16\",\"2\",\"224588\",\"23\",\"23334455\",\\n\"234455668\",\"23678\",\"256\",\"35566\",\"4\",\"46\",\"8\"]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481482,
                "title": "javascript-easy-to-understand-fully-explained-power-of-2-simple",
                "content": "```\\n//Main function\\nvar reorderedPowerOf2 = function(n) {\\n let arr = FindDigitMapArray(n);\\n    \\n for(let i=0;i<31;i++){ //Till value of power of 2 is less than 10^9 or 2^32 find all such power of 2\\n      let num = Math.pow(2,i);\\n      let twoArray = FindDigitMapArray(num);\\n       if(CheckTwoArraysAreEqual(arr,twoArray)) return true;\\n }\\n    return false;\\n}\\n\\n//Function to generate digit map\\nvar FindDigitMapArray = function(n){ //For a given number it stores the count of digit on respective index.\\n    let arr = Array(10).fill(0);\\n    while(n>0){\\n        arr[n%10]+=1;\\n        n/=10;\\n        n=Math.floor(n);\\n    }\\n    return arr;\\n}\\n\\n//Function to check if two arrays are equal\\nvar CheckTwoArraysAreEqual = function(arr,twoArray){\\n     let count = 0;\\n    for(let i=0;i<10;i++){ //Check if digit map of both numbers are equal\\n     if(twoArray[i]==arr[i]){\\n            count++;\\n        }\\n    }\\n    if(count==10) return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n//Main function\\nvar reorderedPowerOf2 = function(n) {\\n let arr = FindDigitMapArray(n);\\n    \\n for(let i=0;i<31;i++){ //Till value of power of 2 is less than 10^9 or 2^32 find all such power of 2\\n      let num = Math.pow(2,i);\\n      let twoArray = FindDigitMapArray(num);\\n       if(CheckTwoArraysAreEqual(arr,twoArray)) return true;\\n }\\n    return false;\\n}\\n\\n//Function to generate digit map\\nvar FindDigitMapArray = function(n){ //For a given number it stores the count of digit on respective index.\\n    let arr = Array(10).fill(0);\\n    while(n>0){\\n        arr[n%10]+=1;\\n        n/=10;\\n        n=Math.floor(n);\\n    }\\n    return arr;\\n}\\n\\n//Function to check if two arrays are equal\\nvar CheckTwoArraysAreEqual = function(arr,twoArray){\\n     let count = 0;\\n    for(let i=0;i<10;i++){ //Check if digit map of both numbers are equal\\n     if(twoArray[i]==arr[i]){\\n            count++;\\n        }\\n    }\\n    if(count==10) return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2481467,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Hashmap***\\n\\n* ***Time Complexity :- O(Constant * logN)***\\n\\n* ***Space Complexity :- O(Constant)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // function for checking is two numbers have identiacal digits\\n    \\n    bool is_possible(int num1, int num2)\\n    {\\n        vector<int> mp(10, 0);\\n        \\n        // increment the count of digits by num1 \\n        \\n        while(num1)\\n        {\\n            int r = num1 % 10;\\n            \\n            mp[r]++;\\n            \\n            num1 = num1 / 10;\\n        }\\n        \\n        // decrement the count of digits by num2\\n        \\n        while(num2)\\n        {\\n            int r = num2 % 10;\\n            \\n            mp[r]--;\\n            \\n            num2 = num2 / 10;\\n        }\\n        \\n        // check if both are idenical of not\\n        \\n        for(int i = 0; i < 10; i++)\\n        {\\n            if(mp[i] != 0)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        \\n        // first of all find all the power of 2 <= 1e9 and store in power array\\n        \\n        int num = 1;\\n        \\n        vector<int> power;\\n        \\n        power.push_back(1);\\n        \\n        while(num * 2 <= 1e9)\\n        {\\n            power.push_back(num * 2);\\n            \\n            num = num * 2;\\n        }\\n        \\n        // compare the number with every element of power array, if any of them have the identical digits \\n        \\n        // then we can reorder the number to power of 2\\n        \\n        for(int i = 0; i < power.size(); i++)\\n        {\\n            if(is_possible(power[i], n))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // function for checking is two numbers have identiacal digits\\n    \\n    bool is_possible(int num1, int num2)\\n    {\\n        vector<int> mp(10, 0);\\n        \\n        // increment the count of digits by num1 \\n        \\n        while(num1)\\n        {\\n            int r = num1 % 10;\\n            \\n            mp[r]++;\\n            \\n            num1 = num1 / 10;\\n        }\\n        \\n        // decrement the count of digits by num2\\n        \\n        while(num2)\\n        {\\n            int r = num2 % 10;\\n            \\n            mp[r]--;\\n            \\n            num2 = num2 / 10;\\n        }\\n        \\n        // check if both are idenical of not\\n        \\n        for(int i = 0; i < 10; i++)\\n        {\\n            if(mp[i] != 0)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        \\n        // first of all find all the power of 2 <= 1e9 and store in power array\\n        \\n        int num = 1;\\n        \\n        vector<int> power;\\n        \\n        power.push_back(1);\\n        \\n        while(num * 2 <= 1e9)\\n        {\\n            power.push_back(num * 2);\\n            \\n            num = num * 2;\\n        }\\n        \\n        // compare the number with every element of power array, if any of them have the identical digits \\n        \\n        // then we can reorder the number to power of 2\\n        \\n        for(int i = 0; i < power.size(); i++)\\n        {\\n            if(is_possible(power[i], n))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481411,
                "title": "java-sort",
                "content": "We can do the hash thing or we can also just sort it.\\nI think sorting is easier. \\n```Java\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        for (int i = 0; i <= 30; i++){\\n            char[] a = (\"\"+(1<<i)).toCharArray();\\n            char[] b = (\"\"+n).toCharArray();\\n            Arrays.sort(a);\\n            Arrays.sort(b);\\n            if (Arrays.equals(a, b)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```Java\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        for (int i = 0; i <= 30; i++){\\n            char[] a = (\"\"+(1<<i)).toCharArray();\\n            char[] b = (\"\"+n).toCharArray();\\n            Arrays.sort(a);\\n            Arrays.sort(b);\\n            if (Arrays.equals(a, b)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481019,
                "title": "c-easy-to-understand-beginner-friendly",
                "content": "\\tbool check(string str)\\n\\t{\\n\\t\\tint x = 0;\\n\\t\\tfor(int i=0;i<str.size();i++)\\n\\t\\t{\\n\\t\\t\\tx=x*10+(str[i]-\\'0\\');\\n\\t\\t}\\n\\t\\tint z = (x&(x-1));\\n\\t\\tif(z==0)return true;\\n\\t\\treturn false;\\n\\t}\\n\\tvoid permute(string &str,int index,bool &ans)\\n\\t{\\n\\t\\tif(index==str.size())\\n\\t\\t{\\n\\t\\t\\tif(str[0]!=\\'0\\' && check(str))ans = true;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor(int i=index;i<str.size();i++)\\n\\t\\t{\\n\\t\\t\\tswap(str[i],str[index]);\\n\\t\\t\\tpermute(str,index+1,ans);\\n\\t\\t\\tswap(str[i],str[index]);\\n\\t\\t}\\n\\t}\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool reorderedPowerOf2(int n) \\n\\t\\t{\\n\\t\\t\\tbool ans = false;\\n\\t\\t\\tstring str = to_string(n);\\n\\t\\t\\tpermute(str,0,ans);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool reorderedPowerOf2(int n) \\n\\t\\t{\\n\\t\\t\\tbool ans = false;\\n\\t\\t\\tstring str = to_string(n);\\n\\t\\t\\tpermute(str,0,ans);\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2481005,
                "title": "python-my-soln",
                "content": "class Solution:\\n\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        n1 = sorted(str(n))\\n        \\n        for i in range(30):\\n            res = sorted(str(2 ** i))\\n            if res == n1:\\n                return True\\n            \\n            \\n        return False",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        n1 = sorted(str(n))\\n        \\n        for i in range(30):\\n            res = sorted(str(2 ** i))\\n            if res == n1:\\n                return True\\n            \\n            \\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 1120308,
                "title": "c-linear-time-constant-space-solution-explained-100-time-100-space",
                "content": "Great problem to tackle and, since it was pretty straightforward, I gave myself a few extra challenges:\\n* no conversion to string (that will not look cool to most interviewers anyway);\\n* no sorting;\\n* getting there with constant space.\\n\\nAnd it looks like I did it \\uD83C\\uDF8A !\\n\\nIn order to proceed, first of all I declared as a `static constexpr` a 2D array with all the powers of 2 up to the given limit (`9` digits), grouped by number of digits, so that I could have a smoother lookup later.\\n\\nIn the main function, we will declare 2 support variables:\\n* `digits` is an array of `9` elements (again, the maximum we might have to consider;\\n* `pos` is a pointer that will tell us where to write or up to where to read in `digits`, preset to `0`.\\n\\nWe will then proceed to destructure `n` into its base digits, proceeding until it is reduced to `0` and:\\n* assign its quotient and remainder to the aptly named `qr`;\\n* store the remainder in `digits`, while also increasing `pos` by `1`;\\n* update `n` to be the quotient - ie: functionally shaving off the least significant/leftmost digit that we just store.\\n\\nOnce done, we will call `verifyDigits` with all the non-`0` values that we have in `powers[pos]` (ie: all the powers of 2 we pre-stored), returning `true` if anyone of them matches the content of digits (ie: the initial number was an \"anagram\" of any power of 2 with the same amount of digits).\\n\\n`verifyDigits` takes 3 parameters (our array/pointer `digits`, `pos` which doubles now as the size of `digits` and `n`, the pre-stored power of 2 to verify) and:\\n* declare a support variable `check` as an array of `10` elements, all preset to `0`;\\n* increase each matching cell of `check` by `1` for each element in `digits` up to `pos` - so, for example, if we had `digits = {3, 5, 6, 6, 5}`, `check` would be `{0, 0, 0, 1, 0, 2, 2, 0, 0, 0}`;\\n* proceed to destructure `n` in a similar fashion to what we did before and:\\n\\t* put quotient and remainder into `qr`;\\n\\t* return `false` if any cell of `check` matching the remainder (ie: the least significant digits) ends up being reduced below `0`;\\n\\t* update `n` to be the quotient, shaving off again the least significant digit and moving on;\\n* return `true` if we reach the end of the loop, since we successfully reduced `pos` elements in `check` without any of them going below `0`, which implies a perfect match!\\n\\nIf we are back in the main function, we will then return `false` at this point, since all the `digits` from the original `n` could not be used to make any known power of 2.\\n\\nThe code:\\n\\n```cpp\\n// precomputed values of powers, grouped by number of digits\\nstatic constexpr int powers[10][4] = {{}, {1, 2, 4, 8}, {16, 32, 64}, {128, 256, 512}, {1024, 2048, 4096, 8192}, {16384, 32768, 65536}, {131072, 262144, 524288}, {1048576, 2097152, 4194304, 8388608}, {16777216, 33554432, 67108864}, {134217728, 268435456, 536870912}};\\n\\nclass Solution {\\n    bool verifyDigits(int *digits, int pos, int n) {\\n        // support variables\\n        int check[10] = {};\\n        // preparing check\\n        for (int i = 0; i < pos; i++) check[digits[i]]++;\\n        // destructuring n into its digits\\n        while (n) {\\n            auto qr = div(n, 10);\\n            // verifying if the matching least significant digit can be used\\n            if (--check[qr.rem] < 0) return false;\\n            // updating n\\n            n = qr.quot;\\n        }\\n        return true;\\n    }\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        // support variables\\n        int digits[9], pos = 0;\\n        // destructuring n into its digits\\n        while (n) {\\n            auto qr = div(n, 10);\\n            // storing the least significant digit of n\\n            digits[pos++] = qr.rem;\\n            // updating n\\n            n = qr.quot;\\n        }\\n        // checking if we have a match for any known power of 2 with the same amount of digits\\n        for (int n: powers[pos]) if (n && verifyDigits(digits, pos, n)) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n// precomputed values of powers, grouped by number of digits\\nstatic constexpr int powers[10][4] = {{}, {1, 2, 4, 8}, {16, 32, 64}, {128, 256, 512}, {1024, 2048, 4096, 8192}, {16384, 32768, 65536}, {131072, 262144, 524288}, {1048576, 2097152, 4194304, 8388608}, {16777216, 33554432, 67108864}, {134217728, 268435456, 536870912}};\\n\\nclass Solution {\\n    bool verifyDigits(int *digits, int pos, int n) {\\n        // support variables\\n        int check[10] = {};\\n        // preparing check\\n        for (int i = 0; i < pos; i++) check[digits[i]]++;\\n        // destructuring n into its digits\\n        while (n) {\\n            auto qr = div(n, 10);\\n            // verifying if the matching least significant digit can be used\\n            if (--check[qr.rem] < 0) return false;\\n            // updating n\\n            n = qr.quot;\\n        }\\n        return true;\\n    }\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        // support variables\\n        int digits[9], pos = 0;\\n        // destructuring n into its digits\\n        while (n) {\\n            auto qr = div(n, 10);\\n            // storing the least significant digit of n\\n            digits[pos++] = qr.rem;\\n            // updating n\\n            n = qr.quot;\\n        }\\n        // checking if we have a match for any known power of 2 with the same amount of digits\\n        for (int n: powers[pos]) if (n && verifyDigits(digits, pos, n)) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149975,
                "title": "a-java-solution-which-easy-understand",
                "content": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        for(int ans=1;ans<=Math.pow(10,9);ans*=2)\\n            if(equal(N,ans))\\n                return true;\\n        return false;\\n    }\\n    public boolean equal(int num1,int num2){\\n        char[] str1 = Integer.toString(num1).toCharArray(),str2 = Integer.toString(num2).toCharArray();\\n        int[] nums = new int[10];\\n        for(int i=0;i<str1.length;i++) nums[str1[i] - \\'0\\']--;\\n        for(int i=0;i<str2.length;i++) nums[str2[i] - \\'0\\']++;\\n        for(int i:nums)\\n            if(i!=0) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        for(int ans=1;ans<=Math.pow(10,9);ans*=2)\\n            if(equal(N,ans))\\n                return true;\\n        return false;\\n    }\\n    public boolean equal(int num1,int num2){\\n        char[] str1 = Integer.toString(num1).toCharArray(),str2 = Integer.toString(num2).toCharArray();\\n        int[] nums = new int[10];\\n        for(int i=0;i<str1.length;i++) nums[str1[i] - \\'0\\']--;\\n        for(int i=0;i<str2.length;i++) nums[str2[i] - \\'0\\']++;\\n        for(int i:nums)\\n            if(i!=0) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233498,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> Helper(long n){\\n        vector<int>num(10);\\n        while(n)\\n        {\\n            num[n%10]++;\\n            n=n/10;\\n        }\\n        return num;\\n    }\\n    bool reorderedPowerOf2(int n)\\n     {\\n        vector<int>v=Helper(n);\\n        for(int i=0;i<31;i++){\\n            if(v==Helper(1<<i)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> Helper(long n){\\n        vector<int>num(10);\\n        while(n)\\n        {\\n            num[n%10]++;\\n            n=n/10;\\n        }\\n        return num;\\n    }\\n    bool reorderedPowerOf2(int n)\\n     {\\n        vector<int>v=Helper(n);\\n        for(int i=0;i<31;i++){\\n            if(v==Helper(1<<i)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930717,
                "title": "c-clear-solution-with-explanation-runtime-0-ms-faster-than-100-00",
                "content": "1.**Brute force Approach:** Find all possible combinations of numbers that can be formed from the Given Target number\\'s digits  and for each combination check if it is a\\n power of 2 or not . (Hint :   Convert the number to string )\\n 2. **Optimised/Efficient Approach:** We can see the constraint for n is *1 <= n <= 10^9* \\n*   If somehow we can show that , with the given number\\'s digits we can form a number which is a power of 2 , then our job is done!\\n*   First of all , We will keep the count of the frequency of digits  of the given number and then we will check if the frequency count matches or not for every power of 2 within the given constraint.\\n*   Linear Time Complexity Solution \\n```\\nclass Solution {\\npublic:\\n    vector<int>nfreq;\\n    vector<int> util(int n)  // To find the freqeuncy of digits of a number\\n    {\\n        vector<int>digitFreq(10,0); \\n        \\n        while(n>0)\\n        {\\n            int rem = n%10;\\n            n = n/10;\\n            digitFreq[rem]++;\\n        }\\n        return digitFreq;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n     \\n        nfreq = util(n);\\n        for(int i= 0;i<32;++i)\\n        {\\n            if(nfreq == util(1<<i))   // Checking condition \\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>nfreq;\\n    vector<int> util(int n)  // To find the freqeuncy of digits of a number\\n    {\\n        vector<int>digitFreq(10,0); \\n        \\n        while(n>0)\\n        {\\n            int rem = n%10;\\n            n = n/10;\\n            digitFreq[rem]++;\\n        }\\n        return digitFreq;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n     \\n        nfreq = util(n);\\n        for(int i= 0;i<32;++i)\\n        {\\n            if(nfreq == util(1<<i))   // Checking condition \\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485025,
                "title": "python-short-and-precise-answer",
                "content": "```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        for i in range(32):\\n            if Counter(str(n))==Counter(str(2**i)):\\n                return True\\n        return False\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        for i in range(32):\\n            if Counter(str(n))==Counter(str(2**i)):\\n                return True\\n        return False\\n",
                "codeTag": "Java"
            },
            {
                "id": 2483872,
                "title": "easy-6-line-c-code-beginner-friendly-bitwise",
                "content": "class Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n      string s=to_string(n);\\n        sort(s.begin(),s.end());\\n        do{\\n            if( s[0]==\\'0\\') continue;\\n          int k=stoi(s);\\n            if(!(k&k-1)) return true;\\n        }while(next_permutation(s.begin(),s.end()) );\\n            return false;\\n    }\\n};\\n*Upvote if you liked the solution*",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n      string s=to_string(n);\\n        sort(s.begin(),s.end());\\n        do{\\n            if( s[0]==\\'0\\') continue;\\n          int k=stoi(s);\\n            if(!(k&k-1)) return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2483557,
                "title": "python-o-log-n-time-o-1-space-faster-than-100-explained-and-compared",
                "content": "# Approach\\nFor all the solutions presented here, the general approach is as follows:\\n- **Step #1**: Identify the digits `n` is made of.\\n- **Step #2**: Identify the powers of 2 that have the same number of digits as `n`; there are maximum four of them.\\n- **Step #3**: Check whether any of the powers of 2 from step **#2** are made of the same digits as identified in step **#1**.\\n\\n# Solution with the lowest time and space theoretical complexity\\n**Description**\\nThis solution uses:\\n- Integer division by 10 and modulo base 10 to identify the digits making up a given integer value.\\n- A `dict` to count the number of occurrences of each digit in a given integer value.\\n  Such a dict has maximum 10 entries.\\n- The comparison between such `dict` instances to check whether two integer values are made up the same digits.\\n\\n**Complexity**\\n- Time: `O(log(n))`\\n- Space: `O(1)`\\n\\n**Code**\\nThe code below gave me: `Runtime: 26 ms, faster than 100.00% of Python3 online submissions`\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        # Step #1: Get the digits of `n` and count their occurrences\\n        # - Time: O(log(n))\\n        # - Space: O(1), as `digitCounts` has maximum 10 entries\\n        tmpValue, numDigits, digitCounts = n, 0, defaultdict(int)\\n        while tmpValue != 0:\\n            numDigits += 1\\n            tmpValue, digit = divmod(tmpValue, 10)\\n            digitCounts[digit] += 1\\n\\n        # Step #2: Identify the smallest power of 2 that has the same number of digits as `n`\\n        # - Time: O(log(n))\\n        # - Space: O(1)\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        # Step #3: Out of the powers of 2 that have the same number of digits as `n` (there are maximum four), check if any has the same digits as `n`\\n        # For this, we count digit occurrences and compare to the ones from step #1\\n        # - Time: O(log(n))\\n        # - Space: O(1), as `powerOf2DigitCounts` has maximum 10 entries\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            tmpValue, powerOf2DigitCounts = powerOf2, defaultdict(int)\\n            while tmpValue != 0:\\n                numDigits += 1\\n                tmpValue, digit = divmod(tmpValue, 10)\\n                powerOf2DigitCounts[digit] += 1\\n            if powerOf2DigitCounts == digitCounts:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n```\\n\\n# Faster solution: Use string conversion to get the digits\\n**Description**\\nThis solution uses:\\n- String conversion to identify the digits making up a given integer value.\\n- A `dict` to count the number of occurrences of each digit in a given integer value.\\n  Such a dict has maximum 10 entries.\\n- The comparison between such `dict` instances to check whether two integer values are made up the same digits.\\n\\n**Complexity**\\n- Time: `O(log(n))`\\n- Space: `O(log(n))`\\n\\n**Code**\\nThe code below gave me: `Runtime: 28 ms, faster than 100.00% of Python3 online submissions`\\nAgainst LeetCode\\'s test suite, this timing does not look as good as the previous solution, **BUT** this is due to LeetCode\\'s:\\n- Huge variance in running times, even for the exact same code.\\n- Test suites often no being comprehensive enough to properly differentiate algorithms.\\n\\nPlease see the *comparison* section at the end of this post to get a clear picture that this solution is globally faster than the previous one.\\n\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        # Step #1: Get the digits of `n` and count their occurrences\\n        # - Time: O(log(n))\\n        # - Space: O(log(n)) for the intermediate string\\n        nStr = str(n)\\n        numDigits = len(nStr)\\n        digitCounts = defaultdict(int)\\n        for digit in nStr:\\n            digitCounts[digit] += 1\\n\\n        # Step #2: Identify the smallest power of 2 that has the same number of digits as `n`\\n        # - Time: O(log(n))\\n        # - Space: O(1)\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        # Step #3: Out of the powers of 2 that have the same number of digits as `n` (there are maximum four), check if any has the same digits as `n`\\n        # For this, we count digit occurrences and compare to the ones from step #1\\n        # - Time: O(log(n))\\n        # - Space: O(log(n)) for the intermediate strings\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            powerOf2Str = str(powerOf2)\\n            powerOf2DigitCounts = defaultdict(int)\\n            for digit in powerOf2Str:\\n                powerOf2DigitCounts[digit] += 1\\n            if powerOf2DigitCounts == digitCounts:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n```\\n\\n# Fastest solution: Sort the digits rather than counting their occurrences\\n**Description**\\nThis solution uses:\\n- String conversion to identify the digits making up a given integer value.\\n- Sorting of the digits.\\n- The comparison between such sorted lists to check whether two integer values are made up the same digits.\\n\\n**Complexity**\\n- Time: `O(log(n)*log(log(n)))`\\n- Space: `O(log(n))`\\n\\nAlthough the theoretical time complexity is worse than the previous solutions, in practice this performs noticeable faster, as:\\n- We are talking about a relatively small number of digits, so the sorting is actually very fast.\\n- The building of a list structure is much faster than the building of a counter dictionary structure.\\n\\n**Code**\\nThe code below gave me: `Runtime: 23 ms, faster than 100.00% of Python3 online submissions`\\nPlease see the *comparison* section at the end of this post to get a better sense of how much faster this solution actually is.\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        # Step #1: Get the digits of `n` and sort them\\n        # - Time: O(log(n)*log(log(n)))\\n        # - Space: O(log(n))\\n        nStr = str(n)\\n        numDigits, sortedDigits = len(nStr), sorted(nStr)\\n\\n        # Step #2: Identify the smallest power of 2 that has the same number of digits as `n`\\n        # - Time: O(log(n))\\n        # - Space: O(1)\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        # Step #3: Out of the powers of 2 that have the same number of digits as `n` (there are maximum four), check if any has the same digits as `n`\\n        # For this, we sort the digits and compare to the ones from step #1\\n        # - Time: O(log(n)*log(log(n)))\\n        # - Space: O(log(n))\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            powerOf2Str = str(powerOf2)\\n            if sorted(powerOf2Str) == sortedDigits:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n```\\n\\n# Timings comparison\\nAs mentioned previously, one cannot rely on LeetCode\\'s test suites or LeetCode\\'s inconsistent running times to get a proper picture of how different algorithms actually compare.\\n\\nSo, here is some code that compares the 3 solutions presented above, and that anyone can run on their own machine.\\nIt generates 1,000,000 test cases with integers of varying sizes; out of these, 332 can be reordered into a power of 2.\\n\\n**Code**\\n```\\n# ==================================================================================================\\n# Solution with the lowest time and space theoretical complexity\\n# ==================================================================================================\\n\\nfrom collections import defaultdict\\nfrom math import ceil, log2\\n\\nclass Solution_1:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        tmpValue, numDigits, digitCounts = n, 0, defaultdict(int)\\n        while tmpValue != 0:\\n            numDigits += 1\\n            tmpValue, digit = divmod(tmpValue, 10)\\n            digitCounts[digit] += 1\\n\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            tmpValue, powerOf2DigitCounts = powerOf2, defaultdict(int)\\n            while tmpValue != 0:\\n                numDigits += 1\\n                tmpValue, digit = divmod(tmpValue, 10)\\n                powerOf2DigitCounts[digit] += 1\\n            if powerOf2DigitCounts == digitCounts:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n\\n# ==================================================================================================\\n# Faster solution: Use string conversion to get the digits\\n# ==================================================================================================\\n\\nfrom collections import defaultdict\\nfrom math import ceil, log2\\n\\nclass Solution_2:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        nStr = str(n)\\n        numDigits = len(nStr)\\n        digitCounts = defaultdict(int)\\n        for digit in nStr:\\n            digitCounts[digit] += 1\\n\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            powerOf2Str = str(powerOf2)\\n            powerOf2DigitCounts = defaultdict(int)\\n            for digit in powerOf2Str:\\n                powerOf2DigitCounts[digit] += 1\\n            if powerOf2DigitCounts == digitCounts:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n\\n# ==================================================================================================\\n# Fastest solution: Sort the digits rather than counting their occurrences\\n# ==================================================================================================\\n\\nfrom math import ceil, log2\\n\\nclass Solution_3:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        nStr = str(n)\\n        numDigits, sortedDigits = len(nStr), sorted(nStr)\\n\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            powerOf2Str = str(powerOf2)\\n            if sorted(powerOf2Str) == sortedDigits:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n\\n# ==================================================================================================\\n# Testing\\n# ==================================================================================================\\n\\nfrom time import perf_counter\\n\\npowersOf2sortedDigits = frozenset(tuple(sorted(str(powerOf2))) for powerOf2 in (2 ** i for i in range(31)))\\ntestCases = [(n, tuple(sorted(str(n))) in powersOf2sortedDigits) for n in (137 * i for i in range(1, 1000001))]\\nprint(f\"{len(testCases)} test cases out of which {sum(1 for _, expected in testCases if expected is True)} return `True`\")\\n\\nfor Solution in [Solution_1, Solution_2, Solution_3]:\\n    print(f\"*** {Solution.__name__} ***\")\\n    startPerfCounter = perf_counter()\\n    for n, expected in testCases:\\n        actual = Solution().reorderedPowerOf2(n)\\n        assert actual == expected, f\"ERROR for arg {n}:\\\\n- Expected: {expected}\\\\n- Got: {actual}\"\\n    else:\\n        endPerfCounter = perf_counter()\\n        print(f\"Completed in {(endPerfCounter - startPerfCounter)}s\")\\n```\\n\\n**Results**\\nRunning this code on my laptop, I got:\\n```\\n1000000 test cases out of which 332 return `True`\\n*** Solution_1 ***\\nCompleted in 10.228865999999925s\\n*** Solution_2 ***\\nCompleted in 7.209750700000313s\\n*** Solution_3 ***\\nCompleted in 3.2113036999999167s\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        # Step #1: Get the digits of `n` and count their occurrences\\n        # - Time: O(log(n))\\n        # - Space: O(1), as `digitCounts` has maximum 10 entries\\n        tmpValue, numDigits, digitCounts = n, 0, defaultdict(int)\\n        while tmpValue != 0:\\n            numDigits += 1\\n            tmpValue, digit = divmod(tmpValue, 10)\\n            digitCounts[digit] += 1\\n\\n        # Step #2: Identify the smallest power of 2 that has the same number of digits as `n`\\n        # - Time: O(log(n))\\n        # - Space: O(1)\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        # Step #3: Out of the powers of 2 that have the same number of digits as `n` (there are maximum four), check if any has the same digits as `n`\\n        # For this, we count digit occurrences and compare to the ones from step #1\\n        # - Time: O(log(n))\\n        # - Space: O(1), as `powerOf2DigitCounts` has maximum 10 entries\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            tmpValue, powerOf2DigitCounts = powerOf2, defaultdict(int)\\n            while tmpValue != 0:\\n                numDigits += 1\\n                tmpValue, digit = divmod(tmpValue, 10)\\n                powerOf2DigitCounts[digit] += 1\\n            if powerOf2DigitCounts == digitCounts:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n```\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        # Step #1: Get the digits of `n` and count their occurrences\\n        # - Time: O(log(n))\\n        # - Space: O(log(n)) for the intermediate string\\n        nStr = str(n)\\n        numDigits = len(nStr)\\n        digitCounts = defaultdict(int)\\n        for digit in nStr:\\n            digitCounts[digit] += 1\\n\\n        # Step #2: Identify the smallest power of 2 that has the same number of digits as `n`\\n        # - Time: O(log(n))\\n        # - Space: O(1)\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        # Step #3: Out of the powers of 2 that have the same number of digits as `n` (there are maximum four), check if any has the same digits as `n`\\n        # For this, we count digit occurrences and compare to the ones from step #1\\n        # - Time: O(log(n))\\n        # - Space: O(log(n)) for the intermediate strings\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            powerOf2Str = str(powerOf2)\\n            powerOf2DigitCounts = defaultdict(int)\\n            for digit in powerOf2Str:\\n                powerOf2DigitCounts[digit] += 1\\n            if powerOf2DigitCounts == digitCounts:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n```\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        # Step #1: Get the digits of `n` and sort them\\n        # - Time: O(log(n)*log(log(n)))\\n        # - Space: O(log(n))\\n        nStr = str(n)\\n        numDigits, sortedDigits = len(nStr), sorted(nStr)\\n\\n        # Step #2: Identify the smallest power of 2 that has the same number of digits as `n`\\n        # - Time: O(log(n))\\n        # - Space: O(1)\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        # Step #3: Out of the powers of 2 that have the same number of digits as `n` (there are maximum four), check if any has the same digits as `n`\\n        # For this, we sort the digits and compare to the ones from step #1\\n        # - Time: O(log(n)*log(log(n)))\\n        # - Space: O(log(n))\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            powerOf2Str = str(powerOf2)\\n            if sorted(powerOf2Str) == sortedDigits:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n```\n```\\n# ==================================================================================================\\n# Solution with the lowest time and space theoretical complexity\\n# ==================================================================================================\\n\\nfrom collections import defaultdict\\nfrom math import ceil, log2\\n\\nclass Solution_1:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        tmpValue, numDigits, digitCounts = n, 0, defaultdict(int)\\n        while tmpValue != 0:\\n            numDigits += 1\\n            tmpValue, digit = divmod(tmpValue, 10)\\n            digitCounts[digit] += 1\\n\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            tmpValue, powerOf2DigitCounts = powerOf2, defaultdict(int)\\n            while tmpValue != 0:\\n                numDigits += 1\\n                tmpValue, digit = divmod(tmpValue, 10)\\n                powerOf2DigitCounts[digit] += 1\\n            if powerOf2DigitCounts == digitCounts:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n\\n# ==================================================================================================\\n# Faster solution: Use string conversion to get the digits\\n# ==================================================================================================\\n\\nfrom collections import defaultdict\\nfrom math import ceil, log2\\n\\nclass Solution_2:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        nStr = str(n)\\n        numDigits = len(nStr)\\n        digitCounts = defaultdict(int)\\n        for digit in nStr:\\n            digitCounts[digit] += 1\\n\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            powerOf2Str = str(powerOf2)\\n            powerOf2DigitCounts = defaultdict(int)\\n            for digit in powerOf2Str:\\n                powerOf2DigitCounts[digit] += 1\\n            if powerOf2DigitCounts == digitCounts:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n\\n# ==================================================================================================\\n# Fastest solution: Sort the digits rather than counting their occurrences\\n# ==================================================================================================\\n\\nfrom math import ceil, log2\\n\\nclass Solution_3:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        nStr = str(n)\\n        numDigits, sortedDigits = len(nStr), sorted(nStr)\\n\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            powerOf2Str = str(powerOf2)\\n            if sorted(powerOf2Str) == sortedDigits:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n\\n# ==================================================================================================\\n# Testing\\n# ==================================================================================================\\n\\nfrom time import perf_counter\\n\\npowersOf2sortedDigits = frozenset(tuple(sorted(str(powerOf2))) for powerOf2 in (2 ** i for i in range(31)))\\ntestCases = [(n, tuple(sorted(str(n))) in powersOf2sortedDigits) for n in (137 * i for i in range(1, 1000001))]\\nprint(f\"{len(testCases)} test cases out of which {sum(1 for _, expected in testCases if expected is True)} return `True`\")\\n\\nfor Solution in [Solution_1, Solution_2, Solution_3]:\\n    print(f\"*** {Solution.__name__} ***\")\\n    startPerfCounter = perf_counter()\\n    for n, expected in testCases:\\n        actual = Solution().reorderedPowerOf2(n)\\n        assert actual == expected, f\"ERROR for arg {n}:\\\\n- Expected: {expected}\\\\n- Got: {actual}\"\\n    else:\\n        endPerfCounter = perf_counter()\\n        print(f\"Completed in {(endPerfCounter - startPerfCounter)}s\")\\n```\n```\\n1000000 test cases out of which 332 return `True`\\n*** Solution_1 ***\\nCompleted in 10.228865999999925s\\n*** Solution_2 ***\\nCompleted in 7.209750700000313s\\n*** Solution_3 ***\\nCompleted in 3.2113036999999167s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482545,
                "title": "c-10-4bit-counters-packet-into-64bit-integer-fast-0ms",
                "content": "**Please upvote if you like the solution, it motivates me to post more of them**\\n\\n**Solution 1: 10 4bit counters packet into a 64bit integer**\\n\\nThis solution is basically do a frequency count. Since any digit (0 to 9) is for sure less frequent than 16 in a 32bit integer we can use 4 bits to count the frequency the digitis. With that we can pack 10 4bit counters easily into a 64bit integer. The solution has to functions:\\n\\nWe just need to compare the signature of ```n``` with the signature of all powers of 2.\\n\\n```\\n    bool reorderedPowerOf2(int n) {\\n        const uint64_t sig_n = signatur(n);\\n        // Compare to all powers of 2.\\n        for (int i = 0; i < 32; ++i) {\\n            if (sig_n == signatur(1 << i)) return true;\\n        }\\n        return false;\\n    }\\n```\\n\\nThe more interesting part is to compute the singatures:\\n\\n```\\n    // We use 4 bits to count each digit.\\n    static uint64_t signatur(uint32_t n) {\\n        uint64_t sig = 0;\\n        while (n) {\\n            sig += 1UL << ((n % 10) * 4);\\n            n /= 10;\\n        }\\n        return sig;\\n    }\\n```\\n\\nAlternative to an ```uint64_t``` signature we could have used an ```array<char, 10>``` (or a similar structure) or just use a ```string``` and just sort the digits.\\n\\nAs always feedback is welcome.",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```n```\n```\\n    bool reorderedPowerOf2(int n) {\\n        const uint64_t sig_n = signatur(n);\\n        // Compare to all powers of 2.\\n        for (int i = 0; i < 32; ++i) {\\n            if (sig_n == signatur(1 << i)) return true;\\n        }\\n        return false;\\n    }\\n```\n```\\n    // We use 4 bits to count each digit.\\n    static uint64_t signatur(uint32_t n) {\\n        uint64_t sig = 0;\\n        while (n) {\\n            sig += 1UL << ((n % 10) * 4);\\n            n /= 10;\\n        }\\n        return sig;\\n    }\\n```\n```uint64_t```\n```array<char, 10>```\n```string```",
                "codeTag": "Unknown"
            },
            {
                "id": 2482451,
                "title": "java-simplest-solution-so-far-no-bitwise",
                "content": "```\\npublic boolean reorderedPowerOf2(int n) {\\n        char[] num = String.valueOf(n).toCharArray();\\n        Arrays.sort(num);\\n        for(int i=0;i<30;i++){\\n            int intCur = (int)Math.pow(2,i);\\n            char[] charCur = String.valueOf(intCur).toCharArray();\\n            Arrays.sort(charCur);\\n            if(Arrays.equals(num,charCur))\\n                return true;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\npublic boolean reorderedPowerOf2(int n) {\\n        char[] num = String.valueOf(n).toCharArray();\\n        Arrays.sort(num);\\n        for(int i=0;i<30;i++){\\n            int intCur = (int)Math.pow(2,i);\\n            char[] charCur = String.valueOf(intCur).toCharArray();\\n            Arrays.sort(charCur);\\n            if(Arrays.equals(num,charCur))\\n                return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2481969,
                "title": "daily-challenge-c-100-faster-easy-hashing",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        int arr[10];\\n        memset(arr,0,sizeof(arr));\\n        \\n        int x =n;\\n        for(;x>0;){\\n            int rem = x%10;\\n            arr[rem]++;\\n            x = x/10;\\n        }\\n        for(int i=0; i<31; i++){\\n            int check[10];\\n            memset(check,0,sizeof(check));\\n            int y = pow(2,i);\\n            while(y>0){\\n                int rem = y%10;\\n                check[rem]++;\\n                y = y/10;\\n            }\\n            bool flag = true;\\n            for(int j=0; j<10; j++){\\n                if(arr[j]!=check[j]){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        int arr[10];\\n        memset(arr,0,sizeof(arr));\\n        \\n        int x =n;\\n        for(;x>0;){\\n            int rem = x%10;\\n            arr[rem]++;\\n            x = x/10;\\n        }\\n        for(int i=0; i<31; i++){\\n            int check[10];\\n            memset(check,0,sizeof(check));\\n            int y = pow(2,i);\\n            while(y>0){\\n                int rem = y%10;\\n                check[rem]++;\\n                y = y/10;\\n            }\\n            bool flag = true;\\n            for(int j=0; j<10; j++){\\n                if(arr[j]!=check[j]){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481830,
                "title": "c-easy-understand",
                "content": "# core concept\\nWe can use `2147483648%num`to determine` num` is power of 2 or not.\\nI hope this concept can help you~~~\\nif you think this is useful, please upvoted it to let more people see this article.\\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        string s=to_string(n);\\n        sort(s.begin(),s.end());\\n        do{\\n            if(2147483648%stoi(s)==0&&s[0]!=\\'0\\') return 1;\\n        }while(next_permutation(s.begin(), s.end()));\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        string s=to_string(n);\\n        sort(s.begin(),s.end());\\n        do{\\n            if(2147483648%stoi(s)==0&&s[0]!=\\'0\\') return 1;\\n        }while(next_permutation(s.begin(), s.end()));\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481280,
                "title": "c-simple-solution",
                "content": "1.  Convert our given number to string (`to_string()`)\\n2.  Sort it (`sort()`)\\n3.  Compare it will all sorted string forms of 2 power numbers upto 30 ( 2^31 > 10^9)\\n4.  If equals to anyone return `true`\\n5.  else if no-match found return `false`\\n\\n**PLEASE UPVOTE IF YOU LIKED THIS \\uD83D\\uDE09\\uD83D\\uDE4C**\\n\\n\\n\\n\\n\\n```\\nbool reorderedPowerOf2(int n) {\\n\\tstring s = sortedString(n);\\n\\tfor(int i = 0; i < 30; ++i){\\n\\t\\tif(s == sortedString(1<<i)) return true;\\n\\t}\\n\\treturn false;\\n}\\nstring sortedString(int n){\\n\\tstring s = to_string(n);\\n\\tsort(s.begin(),s.end());\\n\\treturn s;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nbool reorderedPowerOf2(int n) {\\n\\tstring s = sortedString(n);\\n\\tfor(int i = 0; i < 30; ++i){\\n\\t\\tif(s == sortedString(1<<i)) return true;\\n\\t}\\n\\treturn false;\\n}\\nstring sortedString(int n){\\n\\tstring s = to_string(n);\\n\\tsort(s.begin(),s.end());\\n\\treturn s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2481061,
                "title": "python3-easy-understanding-sort",
                "content": "```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        i, arr = 0, []\\n        v = 2**i\\n        while v <= 10**9: arr.append(sorted(str(v))); i+=1; v = 2**i\\n        return sorted(str(n)) in arr\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        i, arr = 0, []\\n        v = 2**i\\n        while v <= 10**9: arr.append(sorted(str(v))); i+=1; v = 2**i\\n        return sorted(str(n)) in arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481013,
                "title": "go-golang-solution",
                "content": "```\\nfunc reorderedPowerOf2(n int) bool {\\n\\tstr := strconv.Itoa(n)\\n\\tstrByte := []byte(str)\\n\\tsort.Slice(strByte, func(i, j int) bool { return strByte[i] < strByte[j] })\\n\\tfor i := 0; i < 31; i++ {\\n\\t\\ttmp := strconv.Itoa(1 << i)\\n\\t\\ttmpByte := []byte(tmp)\\n\\t\\tsort.Slice(tmpByte, func(i, j int) bool { return tmpByte[i] < tmpByte[j] })\\n\\t\\tif string(strByte) == string(tmpByte) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```\\n\\nuse slice as counter (can\\'t use == to compare two slice)\\n```\\nfunc reorderedPowerOf2(n int) bool {\\n\\tcount := func(n int) []int {\\n\\t\\tresult := make([]int, 10)\\n\\t\\tfor n > 0 {\\n\\t\\t\\tresult[n%10]++\\n\\t\\t\\tn /= 10\\n\\t\\t}\\n\\t\\treturn result\\n\\t}\\n\\tcompare := func(s1, s2 []int) bool {\\n\\t\\tfor i := 0; i < 10; i++ {\\n\\t\\t\\tif s1[i] != s2[i] {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true\\n\\t}\\n\\tnCnt := count(n)\\n\\tfor i := 0; i < 31; i++ {\\n\\t\\tif compare(nCnt, count(1<<i)) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```\\n\\nuse array as counter (can use == to compare two array)\\n```\\nfunc reorderedPowerOf2(n int) bool {\\n\\tcount := func(n int) [10]int {\\n\\t\\tvar result [10]int\\n\\t\\tfor n > 0 {\\n\\t\\t\\tresult[n%10]++\\n\\t\\t\\tn /= 10\\n\\t\\t}\\n\\t\\treturn result\\n\\t}\\n\\tnCnt := count(n)\\n\\tfor i := 0; i < 31; i++ {\\n\\t\\tif nCnt == count(1<<i) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc reorderedPowerOf2(n int) bool {\\n\\tstr := strconv.Itoa(n)\\n\\tstrByte := []byte(str)\\n\\tsort.Slice(strByte, func(i, j int) bool { return strByte[i] < strByte[j] })\\n\\tfor i := 0; i < 31; i++ {\\n\\t\\ttmp := strconv.Itoa(1 << i)\\n\\t\\ttmpByte := []byte(tmp)\\n\\t\\tsort.Slice(tmpByte, func(i, j int) bool { return tmpByte[i] < tmpByte[j] })\\n\\t\\tif string(strByte) == string(tmpByte) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```\n```\\nfunc reorderedPowerOf2(n int) bool {\\n\\tcount := func(n int) []int {\\n\\t\\tresult := make([]int, 10)\\n\\t\\tfor n > 0 {\\n\\t\\t\\tresult[n%10]++\\n\\t\\t\\tn /= 10\\n\\t\\t}\\n\\t\\treturn result\\n\\t}\\n\\tcompare := func(s1, s2 []int) bool {\\n\\t\\tfor i := 0; i < 10; i++ {\\n\\t\\t\\tif s1[i] != s2[i] {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true\\n\\t}\\n\\tnCnt := count(n)\\n\\tfor i := 0; i < 31; i++ {\\n\\t\\tif compare(nCnt, count(1<<i)) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```\n```\\nfunc reorderedPowerOf2(n int) bool {\\n\\tcount := func(n int) [10]int {\\n\\t\\tvar result [10]int\\n\\t\\tfor n > 0 {\\n\\t\\t\\tresult[n%10]++\\n\\t\\t\\tn /= 10\\n\\t\\t}\\n\\t\\treturn result\\n\\t}\\n\\tnCnt := count(n)\\n\\tfor i := 0; i < 31; i++ {\\n\\t\\tif nCnt == count(1<<i) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1824308,
                "title": "track-with-hashmap-easy-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        vector<int> powers;\\n        for(int i=1;i<=1e9;i*=2){\\n            powers.push_back(i);\\n        }\\n        \\n        map<int,int> demand;\\n        while(n>0){\\n            demand[n%10]++;\\n            n/=10;\\n        }\\n        \\n        for(auto& num:powers){\\n            map<int,int> curr;\\n            while(num>0){\\n                curr[num%10]++;\\n                num/=10;\\n            }\\n            \\n            if(curr==demand){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        vector<int> powers;\\n        for(int i=1;i<=1e9;i*=2){\\n            powers.push_back(i);\\n        }\\n        \\n        map<int,int> demand;\\n        while(n>0){\\n            demand[n%10]++;\\n            n/=10;\\n        }\\n        \\n        for(auto& num:powers){\\n            map<int,int> curr;\\n            while(num>0){\\n                curr[num%10]++;\\n                num/=10;\\n            }\\n            \\n            if(curr==demand){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617077,
                "title": "easy-to-understand-python-solution",
                "content": "```\\n\\t\\tl = sorted(list(str(n)))\\n        for i in range(30):\\n            a = 2**i\\n            b = sorted(list(str(a)))\\n            if l == b:\\n                return True\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\t\\tl = sorted(list(str(n)))\\n        for i in range(30):\\n            a = 2**i\\n            b = sorted(list(str(a)))\\n            if l == b:\\n                return True\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1545432,
                "title": "java-1ms-97-25-faster",
                "content": "**Explanation**\\n1) Store the count of digits of given n in an array.\\n2) Store the count of digits of every power of 2 from 1 to 30.\\n3) If the count of digits in any of the power of 2 matches with the count of digits of given n, then return true. \\n4) If a match is not found after all iterations, that means the given number cannot be arranged in the form of a power of 2. Hence, return false.\\n```\\nclass Solution \\n{\\n    public boolean reorderedPowerOf2(int n) \\n    {\\n        int[] cnt = new int[10];\\n        int num = n;\\n        while(num != 0)\\n        {\\n            cnt[num % 10]++;\\n            num /= 10;\\n        }\\n        \\n        int two = 1;\\n        int pow = 1;\\n        while(pow <= 30)\\n        {\\n            int cur[] = new int[10];\\n            num = two;\\n            while(num != 0)\\n            {\\n                cur[num % 10]++;\\n                num /= 10;\\n            }\\n            \\n            boolean powOfTwo = true;\\n            for(int i=0; i<10; i++)\\n            {\\n                if(cnt[i] != cur[i])\\n                {\\n                    powOfTwo = false;\\n                    break;\\n                }\\n            }\\n            if(powOfTwo)\\n                return true;\\n            two *= 2;\\n            pow++;\\n        }\\n        return false;\\n    }   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public boolean reorderedPowerOf2(int n) \\n    {\\n        int[] cnt = new int[10];\\n        int num = n;\\n        while(num != 0)\\n        {\\n            cnt[num % 10]++;\\n            num /= 10;\\n        }\\n        \\n        int two = 1;\\n        int pow = 1;\\n        while(pow <= 30)\\n        {\\n            int cur[] = new int[10];\\n            num = two;\\n            while(num != 0)\\n            {\\n                cur[num % 10]++;\\n                num /= 10;\\n            }\\n            \\n            boolean powOfTwo = true;\\n            for(int i=0; i<10; i++)\\n            {\\n                if(cnt[i] != cur[i])\\n                {\\n                    powOfTwo = false;\\n                    break;\\n                }\\n            }\\n            if(powOfTwo)\\n                return true;\\n            two *= 2;\\n            pow++;\\n        }\\n        return false;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121404,
                "title": "java-simple-and-easy-solution-1-ms-faster-than-96-64-t-o-1-s-o-1-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass Solution {\\n    //store all the power of 2 digits,\\n    //only do this operation 1 time\\n    static PowerOfTwo powerOfTwo = new PowerOfTwo();\\n    \\n    public boolean reorderedPowerOf2(int N) {\\n        String numDigit = String.valueOf(N);\\n        \\n        /*\\n            Approach\\n            1. calculate one time only, power of 2\\n               and store \\n            2. for given number, if its digit is anagram of any\\n               stored power of 2 digits, return true otherwise false\\n            3. Time O(1), Space O(1)\\n        */\\n        \\n        \\n        for(String power : powerOfTwo.digits){\\n            if(isAnagrams(power, numDigit)){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    \\n    private boolean isAnagrams(String str1, String str2){\\n        if(str1.length() != str2.length()) return false;\\n        \\n        int[] counts = new int[10];\\n        \\n        for(char digit : str1.toCharArray()){\\n            counts[digit - \\'0\\']++;\\n        }\\n        \\n        for(char digit : str2.toCharArray()){\\n            counts[digit - \\'0\\']--;\\n        }\\n        \\n        for(int count : counts){\\n            if(count != 0) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n\\nclass PowerOfTwo{\\n    String[]  digits;\\n    \\n    public PowerOfTwo(){\\n        digits = new String[30];\\n        \\n        for(int i = 0; i < digits.length; i++){\\n            digits[i] = String.valueOf((1 << i));\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //store all the power of 2 digits,\\n    //only do this operation 1 time\\n    static PowerOfTwo powerOfTwo = new PowerOfTwo();\\n    \\n    public boolean reorderedPowerOf2(int N) {\\n        String numDigit = String.valueOf(N);\\n        \\n        /*\\n            Approach\\n            1. calculate one time only, power of 2\\n               and store \\n            2. for given number, if its digit is anagram of any\\n               stored power of 2 digits, return true otherwise false\\n            3. Time O(1), Space O(1)\\n        */\\n        \\n        \\n        for(String power : powerOfTwo.digits){\\n            if(isAnagrams(power, numDigit)){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    \\n    private boolean isAnagrams(String str1, String str2){\\n        if(str1.length() != str2.length()) return false;\\n        \\n        int[] counts = new int[10];\\n        \\n        for(char digit : str1.toCharArray()){\\n            counts[digit - \\'0\\']++;\\n        }\\n        \\n        for(char digit : str2.toCharArray()){\\n            counts[digit - \\'0\\']--;\\n        }\\n        \\n        for(int count : counts){\\n            if(count != 0) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n\\nclass PowerOfTwo{\\n    String[]  digits;\\n    \\n    public PowerOfTwo(){\\n        digits = new String[30];\\n        \\n        for(int i = 0; i < digits.length; i++){\\n            digits[i] = String.valueOf((1 << i));\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120965,
                "title": "simplest-explaned-solution",
                "content": "\\nlet say we are given a number 46. So we need to check for 46 or 64 . If anyone of them is power of two then we will return true that there exist a permutation who is Power of 2.\\n\\nDoes we need to **calculate every Permutaion :( ?**\\n**NO :)** we just need to make a digit frequency map. and then compare that to power of two\\'s .\\n As digit can have only value 0 to 9 .  So instead of map can have a array of length 10.(0 to 9)\\nTry to **understand through example :**\\nLet say N=46 \\n`InputDigit= [0,0,0,0,1,0,1,0,0,0]`\\n**Start comparing it with Powers of 2.**\\n2^0 =1 \\n`digitArray=[0,1,0,0,0,0,0,0,0,0]`\\n\\n2^1=2\\n`digitArray=[0,0,1,0,0,0,0,0,0,0]`\\n\\n2^2=4\\n`digitArray=[0,0,0,0,1,0,0,0,0,0]`\\n\\n2^3=8\\n`digitArray=[0,0,0,0,0,0,0,0,1,0]`\\n\\n2^4=16\\n`digitArray=[0,1,0,0,0,0,1,0,0,0]`\\n\\n2^5=32\\n`digitArray=[0,0,1,1,0,0,0,0,0,0]`\\n\\n2^6=64\\n`digitArray=[0,0,0,0,1,0,1,0,0,0]`**SAME AS OF INPUT DIGITS ARRAY** return true\\n\\n\\n```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        int[] InputDigits=count(N);\\n         \\n        int powerOfTwo=1;\\n        for(int i=0;i<31;i++){\\n            int[] powerDigits=count(powerOfTwo);\\n            if(isEqual(InputDigits,powerDigits)) return true;\\n            powerOfTwo<<=1;  // leftShift basically multiplying by 2\\n        }\\n        return false;\\n    }\\n    \\n    private boolean isEqual(int[] arr1,int[] arr2){\\n        for(int i=0;i<arr1.length;i++){\\n            if(arr1[i]!=arr2[i]) return false;\\n        }\\n        return true;\\n    }\\n    \\n    private int[] count(int n){\\n        int[] digitMap=new int[10];\\n        while(n>0){\\n            digitMap[n%10]++;\\n            n/=10;\\n        }\\n        return digitMap;\\n    }\\n}\\n```\\nPlease **UPVOTE** if found it helpful :)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Bit Manipulation",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        int[] InputDigits=count(N);\\n         \\n        int powerOfTwo=1;\\n        for(int i=0;i<31;i++){\\n            int[] powerDigits=count(powerOfTwo);\\n            if(isEqual(InputDigits,powerDigits)) return true;\\n            powerOfTwo<<=1;  // leftShift basically multiplying by 2\\n        }\\n        return false;\\n    }\\n    \\n    private boolean isEqual(int[] arr1,int[] arr2){\\n        for(int i=0;i<arr1.length;i++){\\n            if(arr1[i]!=arr2[i]) return false;\\n        }\\n        return true;\\n    }\\n    \\n    private int[] count(int n){\\n        int[] digitMap=new int[10];\\n        while(n>0){\\n            digitMap[n%10]++;\\n            n/=10;\\n        }\\n        return digitMap;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120773,
                "title": "c-python-direct-simulation-indirect-checking-all-possibilities-of-power-of-2",
                "content": "Idea1:  Direct simulation of Permutations [1]\\nIntuition\\n\\nFor each permutation of the digits of N, let\\'s check if that permutation is a power of 2.\\n\\nAlgorithm\\n\\nThis approach has two steps: how will we generate the permutations of the digits, and how will we check that the permutation represents a power of 2?\\n\\nTo generate permutations of the digits, we place any digit into the first position (start = 0), then any of the remaining digits into the second position (start = 1), and so on. In Python, we can use the builtin function itertools.permutations.\\n\\nTo check whether a permutation represents a power of 2, we check that there is no leading zero, and divide out all factors of 2. If the result is 1 (that is, it contained no other factors besides 2), then it was a power of 2. In Python, we can use the check bin(N).count(\\'1\\') == 1.\\n\\n```\\nTime Complexity: O((logN)!\\u2217logN). Note that logN is the number of digits in the binary representation of N. For each of (logN)! permutations of the digits of N, we need to check that it is a power of 2 in O(logN) time.\\n\\nSpace Complexity: O(logN), the space used by A (or cand in Python).\\n```\\n\\nApproach 1: C++\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        vector<int> digits;\\n        while(N>0){\\n            digits.push_back(N%10);\\n            N /= 10;\\n        }\\n        \\n        sort(digits.begin(), digits.end());        \\n        do{\\n            if( digits[0] != 0 && __builtin_popcount(digit2num(digits)) == 1)\\n                return true;\\n        }while(next_permutation(digits.begin(), digits.end()));\\n        return false;\\n    }\\n    \\nprivate:\\n    int digit2num(vector<int>& digits){\\n        int ans = 0;\\n        for(auto digit: digits)\\n            ans = ans * 10 + digit;\\n        return ans;\\n    }\\n};\\n```\\n\\nApproach 2: Python\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        for cand in itertools.permutations(str(N)):\\n            if cand[0]!=\\'0\\' and bin(int(\"\".join(cand))).count(\\'1\\') ==1:\\n                return True\\n        return False\\n        #return any( cand[0]!=\\'0\\' and bin(int(\"\".join(cand))).count(\\'1\\') ==1\\n        #           for cand in itertools.permutations(str(N)))\\n            #for cand in iterationtools.permutation(str(N)))\\n```\\n\\n\\n\\nIdea2: Counting\\nIntuition and Algorithm\\n\\nWe can check whether two numbers have the same digits by comparing the count of their digits. For example, 338 and 833 have the same digits because they both have exactly two 3\\'s and one 8.\\nSince NN could only be a power of 2 with 9 digits or less (namely, 2^0, 2^1, 2^31), we can just check whether NN has the same digits as any of these possibilities.\\n\\nComplexity Analysis\\n\\nTime Complexity: O( (logN)^2). There are logN different candidate powers of 2, and each comparison has O(logN) time complexity.\\nSpace Complexity: O(logN).\\n\\n\\n```\\nclass Solution(object):\\n    def reorderedPowerOf2(self, N):\\n        count = collections.Counter(str(N))\\n        return any(count == collections.Counter(str(1 << b))\\n                   for b in xrange(31))\\n```\\n\\nReference:\\n[1] https://leetcode.com/problems/reordered-power-of-2/solution/\\n[2] itertools.permutations:\\nIllustration:\\n\\nN=128\\n\\n>>> for cand in itertools.permutations(str(N)):print(cand)\\n...\\n(\\'1\\', \\'2\\', \\'8\\')\\n(\\'1\\', \\'8\\', \\'2\\')\\n(\\'2\\', \\'1\\', \\'8\\')\\n(\\'2\\', \\'8\\', \\'1\\')\\n(\\'8\\', \\'1\\', \\'2\\')\\n(\\'8\\', \\'2\\', \\'1\\')\\n>>> for cand in itertools.permutations([1,2,8]):print(cand)\\n...\\n(1, 2, 8)\\n(1, 8, 2)\\n(2, 1, 8)\\n(2, 8, 1)\\n(8, 1, 2)\\n(8, 2, 1)",
                "solutionTags": [
                    "Python",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nTime Complexity: O((logN)!\\u2217logN). Note that logN is the number of digits in the binary representation of N. For each of (logN)! permutations of the digits of N, we need to check that it is a power of 2 in O(logN) time.\\n\\nSpace Complexity: O(logN), the space used by A (or cand in Python).\\n```\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        vector<int> digits;\\n        while(N>0){\\n            digits.push_back(N%10);\\n            N /= 10;\\n        }\\n        \\n        sort(digits.begin(), digits.end());        \\n        do{\\n            if( digits[0] != 0 && __builtin_popcount(digit2num(digits)) == 1)\\n                return true;\\n        }while(next_permutation(digits.begin(), digits.end()));\\n        return false;\\n    }\\n    \\nprivate:\\n    int digit2num(vector<int>& digits){\\n        int ans = 0;\\n        for(auto digit: digits)\\n            ans = ans * 10 + digit;\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        for cand in itertools.permutations(str(N)):\\n            if cand[0]!=\\'0\\' and bin(int(\"\".join(cand))).count(\\'1\\') ==1:\\n                return True\\n        return False\\n        #return any( cand[0]!=\\'0\\' and bin(int(\"\".join(cand))).count(\\'1\\') ==1\\n        #           for cand in itertools.permutations(str(N)))\\n            #for cand in iterationtools.permutation(str(N)))\\n```\n```\\nclass Solution(object):\\n    def reorderedPowerOf2(self, N):\\n        count = collections.Counter(str(N))\\n        return any(count == collections.Counter(str(1 << b))\\n                   for b in xrange(31))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120255,
                "title": "reordered-power-of-2-beats-100-c",
                "content": "The steps for solution to this problem are :\\n* Store all the powers of 2 in a vector\\n* Compare each numbner in vector with the given number to check if both have same digits .\\n* If both have same digits , return true\\n* else return false .\\nPls upvote if u feel it is correct and suggest if it can be improved .\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int comp(int a,int b)\\n    {\\n        bool A[10]={0},B[10]={0};\\n        int lena=0,lenb=0;\\n        while(a>0 || b>0)\\n        {\\n            if(a>0)\\n            {\\n                A[a%10]=1;\\n                a/=10;\\n                lena++;\\n            }\\n            if(b>0)\\n            {\\n                B[b%10]=1;\\n                b/=10;\\n                lenb++;\\n            }\\n        }\\n        \\n        if(lena!=lenb)\\n            return false;\\n        \\n        for(int i=0 ;i<10 ;i++)\\n            if(A[i]!=B[i])\\n                return false;\\n        return true;\\n    }\\n    \\n    bool reorderedPowerOf2(int N) {\\n        int k=1;\\n        vector<int> v;\\n        for(int i=0 ;i<30 ;i++)\\n        {\\n            v.push_back(k);\\n            k*=2;\\n        }\\n        \\n        for(int i=0 ;i<=30 ;i++)\\n        {\\n            if(comp(N,v[i]))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int comp(int a,int b)\\n    {\\n        bool A[10]={0},B[10]={0};\\n        int lena=0,lenb=0;\\n        while(a>0 || b>0)\\n        {\\n            if(a>0)\\n            {\\n                A[a%10]=1;\\n                a/=10;\\n                lena++;\\n            }\\n            if(b>0)\\n            {\\n                B[b%10]=1;\\n                b/=10;\\n                lenb++;\\n            }\\n        }\\n        \\n        if(lena!=lenb)\\n            return false;\\n        \\n        for(int i=0 ;i<10 ;i++)\\n            if(A[i]!=B[i])\\n                return false;\\n        return true;\\n    }\\n    \\n    bool reorderedPowerOf2(int N) {\\n        int k=1;\\n        vector<int> v;\\n        for(int i=0 ;i<30 ;i++)\\n        {\\n            v.push_back(k);\\n            k*=2;\\n        }\\n        \\n        for(int i=0 ;i<=30 ;i++)\\n        {\\n            if(comp(N,v[i]))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120112,
                "title": "rust-counting-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn reordered_power_of2(n: i32) -> bool {\\n        let digit_counts = |n: i32| -> [usize; 10] {\\n            let mut n = n;\\n            let mut d = [0; 10];\\n            while n > 0 {\\n                d[(n % 10) as usize] += 1;\\n                n /= 10;\\n            }\\n            d\\n        };\\n        let counts = digit_counts(n);\\n        (0..31).any(|i| digit_counts(1 << i) == counts)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn reordered_power_of2(n: i32) -> bool {\\n        let digit_counts = |n: i32| -> [usize; 10] {\\n            let mut n = n;\\n            let mut d = [0; 10];\\n            while n > 0 {\\n                d[(n % 10) as usize] += 1;\\n                n /= 10;\\n            }\\n            d\\n        };\\n        let counts = digit_counts(n);\\n        (0..31).any(|i| digit_counts(1 << i) == counts)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1120035,
                "title": "python",
                "content": "As `N` is bounded by 10^9 we need to check at most the 30-th power of 2. For each power of 2 we count the occurrence of every digit and store it in an array of size 10 (from 0,...,9). If for any power of 2 the count matches that of `N` we return True. Else return False.\\n\\nTime: `O(1)`\\nSpace: `O(1)`\\n\\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, N):\\n        def is_equal(c1, c2):\\n            return sum(abs(x-y) for x,y in zip(c1,c2))==0\\n        \\n        \\n        def count(n):\\n            c = [0]*10\\n            while n:\\n                c[n % 10] += 1\\n                n //= 10\\n            return c\\n        \\n        \\n        c1 = count(N)\\n        for i in range(31):\\n            c2 = count(2**i)\\n            if is_equal(c1, c2):\\n                return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def reorderedPowerOf2(self, N):\\n        def is_equal(c1, c2):\\n            return sum(abs(x-y) for x,y in zip(c1,c2))==0\\n        \\n        \\n        def count(n):\\n            c = [0]*10\\n            while n:\\n                c[n % 10] += 1\\n                n //= 10\\n            return c\\n        \\n        \\n        c1 = count(N)\\n        for i in range(31):\\n            c2 = count(2**i)\\n            if is_equal(c1, c2):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 980748,
                "title": "easy-short-understandable-code-in-c",
                "content": "#using compare function for removing 0 as first digit\\n```\\nstatic bool com(char a,char b){\\n        return a>b;\\n    }\\n    bool reorderedPowerOf2(int N) {\\n       string s= to_string(N);\\n        int n=s.size();\\n        int k=1;\\n        string p;\\n        sort(s.begin(),s.end(),com);\\n        while(n>=p.size())\\n        {\\n            p=to_string(k);\\n            sort(p.begin(),p.end(),com);  //sort every power of twofor checking \\n            if(s==p)\\n                return 1;\\n            k=k<<1; //using for finding next power of two\\n        }\\n        return 0;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstatic bool com(char a,char b){\\n        return a>b;\\n    }\\n    bool reorderedPowerOf2(int N) {\\n       string s= to_string(N);\\n        int n=s.size();\\n        int k=1;\\n        string p;\\n        sort(s.begin(),s.end(),com);\\n        while(n>=p.size())\\n        {\\n            p=to_string(k);\\n            sort(p.begin(),p.end(),com);  //sort every power of twofor checking \\n            if(s==p)\\n                return 1;\\n            k=k<<1; //using for finding next power of two\\n        }\\n        return 0;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 149928,
                "title": "python-easy-to-understand-with-explanation",
                "content": "Since the leading digit is not zero, the reordered number shares the same number of digits with original one.\\nThe search base can be greatly reduced.\\nReturn true if `Counter(N) == Counter(power of 2) and NumberOfDigits(N) == NumberOfDigits(power of 2)`\\n\\n```python\\n    def reorderedPowerOf2(self, N):\\n        from collections import Counter\\n\\n        digits_of_n = len(str(N))\\n        counter = Counter(str(N))\\n        power = 1\\n\\n        while True:\\n            digits_of_power = len(str(power))\\n\\n            if digits_of_power > digits_of_n:\\n                break\\n            \\n            if digits_of_power == digits_of_n and Counter(str(power)) == counter:\\n                return True\\n\\n            power = power*2\\n\\n        return False\\n```",
                "solutionTags": [],
                "code": "```python\\n    def reorderedPowerOf2(self, N):\\n        from collections import Counter\\n\\n        digits_of_n = len(str(N))\\n        counter = Counter(str(N))\\n        power = 1\\n\\n        while True:\\n            digits_of_power = len(str(power))\\n\\n            if digits_of_power > digits_of_n:\\n                break\\n            \\n            if digits_of_power == digits_of_n and Counter(str(power)) == counter:\\n                return True\\n\\n            power = power*2\\n\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2952889,
                "title": "js-easiest-to-follow-one-glance-you-will-get-it-fastest",
                "content": "Have fun :)\\n\\n# Intuition\\nhttps://onlinenumbertools.com/sort-digits\\n\\n\\n# Code\\n```\\nvar reorderedPowerOf2 = function (n) {\\n  const vals = new Set([\"1\",\"2\",\"4\",\"8\",\"16\",\"23\",\"46\",\"128\",\"256\",\"125\",\"0124\",\"0248\",\"0469\",\"1289\",\"13468\",\"23678\",\"35566\",\"011237\",\"122446\",\"224588\",\"0145678\",\"0122579\",\"0134449\",\"0368888\",\"11266777\",\"23334455\",\"01466788\",\"112234778\",\"234455668\",\"012356789\",]);\\n   return vals.has((\"\" + n).split(\"\").sort((a, b) => a - b).join(\"\"))\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reorderedPowerOf2 = function (n) {\\n  const vals = new Set([\"1\",\"2\",\"4\",\"8\",\"16\",\"23\",\"46\",\"128\",\"256\",\"125\",\"0124\",\"0248\",\"0469\",\"1289\",\"13468\",\"23678\",\"35566\",\"011237\",\"122446\",\"224588\",\"0145678\",\"0122579\",\"0134449\",\"0368888\",\"11266777\",\"23334455\",\"01466788\",\"112234778\",\"234455668\",\"012356789\",]);\\n   return vals.has((\"\" + n).split(\"\").sort((a, b) => a - b).join(\"\"))\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2827694,
                "title": "java-100-faster-1-ms-solution-explained",
                "content": "# Approach\\nExplanation.\\n\\n**Occur** is an 2d array which stores occurrences of all digits of each number (power of 2). \\n\\nExample: 2^16 = 65536, array with occurences of digits for it will be: [0,0,0,1,0,2,2,0,0,0], because we have one occurence of 3, two occurences of 5, and two occurences of 6.\\n\\n**Occur** is $$static$$ because I fill it only once and use for each test case.\\n\\nThe names of methods are self explainable.\\n\\n# Code\\n```\\nclass Solution {\\n\\n    static byte[][] ocurr;\\n\\n    public boolean reorderedPowerOf2(int n) {\\n        if (n == 1) return true;\\n        if (ocurr == null) {\\n            ocurr = fillOccurencesForEachPowerOf2();\\n        }\\n\\n        byte[] freq = countFreqs(n);\\n        for (byte[] oc : ocurr) {\\n            if (areSame(oc, freq)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private byte[][] fillOccurencesForEachPowerOf2() {\\n        byte[][] res = new byte[30][10];\\n        for (int i = 0; i < res.length; i++) {\\n            int pow = (int) Math.pow(2, i);\\n            res[i] = countFreqs(pow);\\n        }\\n        return res;\\n    }\\n\\n    private byte[] countFreqs(int pow) {\\n        byte[] freq = new byte[10];\\n        while (pow > 0) {\\n            int digit = pow % 10;\\n            //increment digits frequency for number pow\\n            freq[digit]++;\\n            pow /= 10;\\n        }\\n        return freq;\\n    }\\n\\n    private boolean areSame(byte[] oc, byte[] freq) {\\n        for (int i = 0; i < oc.length; i++) {\\n            if (oc[i] != freq[i]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    static byte[][] ocurr;\\n\\n    public boolean reorderedPowerOf2(int n) {\\n        if (n == 1) return true;\\n        if (ocurr == null) {\\n            ocurr = fillOccurencesForEachPowerOf2();\\n        }\\n\\n        byte[] freq = countFreqs(n);\\n        for (byte[] oc : ocurr) {\\n            if (areSame(oc, freq)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private byte[][] fillOccurencesForEachPowerOf2() {\\n        byte[][] res = new byte[30][10];\\n        for (int i = 0; i < res.length; i++) {\\n            int pow = (int) Math.pow(2, i);\\n            res[i] = countFreqs(pow);\\n        }\\n        return res;\\n    }\\n\\n    private byte[] countFreqs(int pow) {\\n        byte[] freq = new byte[10];\\n        while (pow > 0) {\\n            int digit = pow % 10;\\n            //increment digits frequency for number pow\\n            freq[digit]++;\\n            pow /= 10;\\n        }\\n        return freq;\\n    }\\n\\n    private boolean areSame(byte[] oc, byte[] freq) {\\n        for (int i = 0; i < oc.length; i++) {\\n            if (oc[i] != freq[i]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783380,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool reorderedPowerOf2(int n) {\\n        string s = to_string(n);\\n        sort(s.begin(),s.end());\\n\\t\\t\\n        vector<string> power;\\n        for(int i=0;i<=30;i++){\\n            int p = pow(2,i);\\n            power.push_back(to_string(p));\\n        }\\n        \\n        for(int i=0;i<=30;i++){\\n            sort(power[i].begin(),power[i].end());\\n        }\\n        \\n        for(int i=0;i<=30;i++){\\n            if(power[i] == s ) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool reorderedPowerOf2(int n) {\\n        string s = to_string(n);\\n        sort(s.begin(),s.end());\\n\\t\\t\\n        vector<string> power;\\n        for(int i=0;i<=30;i++){\\n            int p = pow(2,i);\\n            power.push_back(to_string(p));\\n        }\\n        \\n        for(int i=0;i<=30;i++){\\n            sort(power[i].begin(),power[i].end());\\n        }\\n        \\n        for(int i=0;i<=30;i++){\\n            if(power[i] == s ) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2516026,
                "title": "understanding-reordered-power-of-2-in-3-basic-steps",
                "content": "I broke it down into 3 core parts:\\n1. Identify individual digits of the number\\n2. Identify valid permutations of the digits\\n3. Test to see if a permutation is a power of 2.\\n\\n**Step 1:  Identify the Digits**\\nIf I as a human see the number 1,024, I\\'ll list the digits from left-to-right:  1, 0, 2, 4.  But if I want a computer to do it, I\\'m better off going from right-to-left:  4, 2, 0, 1.  How can we make the computer do this?  How can we ask it to tell us, \"What\\'s in the 1\\'s column?\"\\n\\n1. Divide the number by 10:  `1024 / 10 = 102`\\n2. Multiply by it by 10:  `102 * 10 = 1020`\\n3. Subtract this result from the original value:  `1024 - 1020 = 4`\\n\\nJust divide the original number by 10 and repeat the process until you run out of digits!\\n\\n**Step 2:  Identify Valid Permutations**\\nHow many different ways can we arrange these digits, and what are they?  Well, do we actually care?  We don\\'t really need to *enumerate* the permutations, we just need to *identify* them.  That\\'s a boolean test.  If I ask you, \"Is 4210 a permutation of the digits in 1024?\" how do you answer that question?  If you\\'re like me, you just check to see if all digits have been used. \\n\\nYou can use an integer array of length 10 to count the digits in the input number.  For each digit observed in step 1, increment the corresponding index in the array.  Using 1024 (or 4210!) as our example, the resulting array should be:  `[1, 1, 1, 0, 1, 0, 0, 0, 0, 0]`\\n\\nIf our input number was `55,963,220`, the array would be:   `[1, 0, 2, 1, 0, 2, 1, 0, 0, 1]`\\n\\nIf two numbers\\' arrays are equal, then the digits of one number can be rearranged to make the other!\\n\\n**Step 3: Test Powers of 2**\\nWho remembers their big O times?  What grows faster:  `O(x^2)`, or `O(2^x)`?  The anwer is the latter. `2^x` grows pretty quickly.  In fact, `2^30 == 1,073,741,824`, and that\\'s greater than a billion.  The problem statement says that n will be less than 10 to the 9th, which means we only have 30 dfferent powers of 2 that we\\'d need to test.  That\\'s a pretty small data set to test!  Just generate powers of 2, and extract their digits into an array, and compare to the array of digits for our given number.  If they match, it means our number can be rearranged to make a power of 2.",
                "solutionTags": [],
                "code": "I broke it down into 3 core parts:\\n1. Identify individual digits of the number\\n2. Identify valid permutations of the digits\\n3. Test to see if a permutation is a power of 2.\\n\\n**Step 1:  Identify the Digits**\\nIf I as a human see the number 1,024, I\\'ll list the digits from left-to-right:  1, 0, 2, 4.  But if I want a computer to do it, I\\'m better off going from right-to-left:  4, 2, 0, 1.  How can we make the computer do this?  How can we ask it to tell us, \"What\\'s in the 1\\'s column?\"\\n\\n1. Divide the number by 10:  `1024 / 10 = 102`\\n2. Multiply by it by 10:  `102 * 10 = 1020`\\n3. Subtract this result from the original value:  `1024 - 1020 = 4`\\n\\nJust divide the original number by 10 and repeat the process until you run out of digits!\\n\\n**Step 2:  Identify Valid Permutations**\\nHow many different ways can we arrange these digits, and what are they?  Well, do we actually care?  We don\\'t really need to *enumerate* the permutations, we just need to *identify* them.  That\\'s a boolean test.  If I ask you, \"Is 4210 a permutation of the digits in 1024?\" how do you answer that question?  If you\\'re like me, you just check to see if all digits have been used. \\n\\nYou can use an integer array of length 10 to count the digits in the input number.  For each digit observed in step 1, increment the corresponding index in the array.  Using 1024 (or 4210!) as our example, the resulting array should be:  `[1, 1, 1, 0, 1, 0, 0, 0, 0, 0]`\\n\\nIf our input number was `55,963,220`, the array would be:   `[1, 0, 2, 1, 0, 2, 1, 0, 0, 1]`\\n\\nIf two numbers\\' arrays are equal, then the digits of one number can be rearranged to make the other!\\n\\n**Step 3: Test Powers of 2**\\nWho remembers their big O times?  What grows faster:  `O(x^2)`, or `O(2^x)`?  The anwer is the latter. `2^x` grows pretty quickly.  In fact, `2^30 == 1,073,741,824`, and that\\'s greater than a billion.  The problem statement says that n will be less than 10 to the 9th, which means we only have 30 dfferent powers of 2 that we\\'d need to test.  That\\'s a pretty small data set to test!  Just generate powers of 2, and extract their digits into an array, and compare to the array of digits for our given number.  If they match, it means our number can be rearranged to make a power of 2.",
                "codeTag": "Unknown"
            },
            {
                "id": 2484929,
                "title": "simple-solution-using-next-permutation-to-find-the-answer",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> tovector(int n){\\n        vector<int> ans;\\n        while(n!=0){\\n            ans.push_back(n%10);\\n            n = n/10;\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    // [5,2,1]\\n    \\n    int toInteger(vector<int> &ans){\\n        int nums = 0;\\n        for(auto x : ans){\\n            nums = nums*10 + x;\\n        }\\n        return nums;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n      vector<int> vec = tovector(n);\\n      do{\\n          if(vec.size() == 1 && vec[0] == 1) return true;\\n          if(vec[0] == 0 ||((vec[vec.size()-1]%2 ==1))){\\n              continue;\\n          }\\n          int n = toInteger(vec);\\n          if((n &(n-1)) == 0) return true;\\n          \\n      }while(next_permutation(vec.begin(),vec.end()));\\n      return false;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> tovector(int n){\\n        vector<int> ans;\\n        while(n!=0){\\n            ans.push_back(n%10);\\n            n = n/10;\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    // [5,2,1]\\n    \\n    int toInteger(vector<int> &ans){\\n        int nums = 0;\\n        for(auto x : ans){\\n            nums = nums*10 + x;\\n        }\\n        return nums;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n      vector<int> vec = tovector(n);\\n      do{\\n          if(vec.size() == 1 && vec[0] == 1) return true;\\n          if(vec[0] == 0 ||((vec[vec.size()-1]%2 ==1))){\\n              continue;\\n          }\\n          int n = toInteger(vec);\\n          if((n &(n-1)) == 0) return true;\\n          \\n      }while(next_permutation(vec.begin(),vec.end()));\\n      return false;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484157,
                "title": "ruby-set-of-strings",
                "content": "## Leetcode: 869. Reordered Power of 2.\\n\\n\\n**Ruby: Set of strings.**\\n\\n1. Need to get an array of powers of two till `10**9`.\\n2. Convert these numbers to strings and sort chars. Create a set from the array.\\n3. Convert inpur to string sort chars join and check does in include in the set.\\n\\nLet\\'s try.\\n\\nRuby code:\\n```Ruby\\n# Leetcode: 869. Reordered Power of 2.\\n# https://leetcode.com/problems/reordered-power-of-2/\\n# = = = = = = = = = = = = = =\\n# Accepted.\\n# Thanks God, Jesus Christ!\\n# = = = = = = = = = = = = = =\\n# Runtime: 82 ms, faster than 100.00% of Ruby online submissions for Reordered Power of 2.\\n# Memory Usage: 210.9 MB, less than 100.00% of Ruby online submissions for Reordered Power of 2.\\n# @param {Integer} n\\n# @return {Boolean}\\ndef reordered_power_of2(n)\\n  require \"set\"\\n  @two ||= get_powers_of_2()\\n    .map{|x| x.to_s.chars.sort.join}.to_set\\n  @two.include?(n.to_s.chars.sort.join)\\nend\\n\\ndef get_powers_of_2()\\n  answer = []\\n  value = 1\\n  border = 10**9 \\n  while value <= border\\n    answer.push value\\n    value *= 2\\n  end\\n  answer\\nend\\n\\n```\\n",
                "solutionTags": [
                    "Ruby",
                    "Ordered Set"
                ],
                "code": "```Ruby\\n# Leetcode: 869. Reordered Power of 2.\\n# https://leetcode.com/problems/reordered-power-of-2/\\n# = = = = = = = = = = = = = =\\n# Accepted.\\n# Thanks God, Jesus Christ!\\n# = = = = = = = = = = = = = =\\n# Runtime: 82 ms, faster than 100.00% of Ruby online submissions for Reordered Power of 2.\\n# Memory Usage: 210.9 MB, less than 100.00% of Ruby online submissions for Reordered Power of 2.\\n# @param {Integer} n\\n# @return {Boolean}\\ndef reordered_power_of2(n)\\n  require \"set\"\\n  @two ||= get_powers_of_2()\\n    .map{|x| x.to_s.chars.sort.join}.to_set\\n  @two.include?(n.to_s.chars.sort.join)\\nend\\n\\ndef get_powers_of_2()\\n  answer = []\\n  value = 1\\n  border = 10**9 \\n  while value <= border\\n    answer.push value\\n    value *= 2\\n  end\\n  answer\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2484091,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        char[] num = getArr(n);\\n        for (int i = 0; i < 30; ++i) {\\n            char[] powerOfTwo = getArr(1 << i);\\n            if (Arrays.equals(num, powerOfTwo))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    public char[] getArr(int n) {\\n        char[] digits = String.valueOf(n).toCharArray();\\n        Arrays.sort(digits);\\n        return digits;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        char[] num = getArr(n);\\n        for (int i = 0; i < 30; ++i) {\\n            char[] powerOfTwo = getArr(1 << i);\\n            if (Arrays.equals(num, powerOfTwo))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    public char[] getArr(int n) {\\n        char[] digits = String.valueOf(n).toCharArray();\\n        Arrays.sort(digits);\\n        return digits;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484063,
                "title": "c-0ms-solution-easy-to-understand-short-code",
                "content": "1) Create a vector of strings \"v\" of size 30 where each string represents a power of 2 (from 0 to 30) with its digits in sorted form.\\n2) Convert the given number to string \"s\" and sort its digits as well.\\n3) Compare the resultant string \"s\" with each element of the vector of strings \"v\".\\n4) Return true if a match is found else return false.\\n\\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        vector<string> v;\\n        for(int i=0;i<30;i++)\\n        {\\n            int k=pow(2,i);\\n            string c=to_string(k);\\n            sort(c.begin(),c.end());\\n            v.push_back(c);\\n        }\\n        string s=to_string(n);\\n        sort(s.begin(),s.end());\\n        for(auto it:v)\\n        {\\n            if(s==it)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Math",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        vector<string> v;\\n        for(int i=0;i<30;i++)\\n        {\\n            int k=pow(2,i);\\n            string c=to_string(k);\\n            sort(c.begin(),c.end());\\n            v.push_back(c);\\n        }\\n        string s=to_string(n);\\n        sort(s.begin(),s.end());\\n        for(auto it:v)\\n        {\\n            if(s==it)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482968,
                "title": "rust-solution",
                "content": "```\\n\\nimpl Solution {\\n    pub fn reordered_power_of2(n: i32) -> bool {\\n\\n        let mut log = (n as f32).log2();\\n        if n == i32::pow(2, log as u32) {\\n            return true;\\n        }\\n\\n        let mut n_s = n.to_string().chars().collect::<Vec<char>>();\\n\\n        n_s.sort();\\n\\n        for i in 0..30 {\\n            let pow_2 = i64::pow(2, i);\\n            \\n\\n            let mut pow_2_s = pow_2.to_string().chars().collect::<Vec<char>>();\\n\\n            pow_2_s.sort();\\n\\n            if pow_2_s == n_s {\\n                println!(\"found at {}\", pow_2);\\n                return true;\\n            }\\n            \\n            \\n        }\\n\\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nimpl Solution {\\n    pub fn reordered_power_of2(n: i32) -> bool {\\n\\n        let mut log = (n as f32).log2();\\n        if n == i32::pow(2, log as u32) {\\n            return true;\\n        }\\n\\n        let mut n_s = n.to_string().chars().collect::<Vec<char>>();\\n\\n        n_s.sort();\\n\\n        for i in 0..30 {\\n            let pow_2 = i64::pow(2, i);\\n            \\n\\n            let mut pow_2_s = pow_2.to_string().chars().collect::<Vec<char>>();\\n\\n            pow_2_s.sort();\\n\\n            if pow_2_s == n_s {\\n                println!(\"found at {}\", pow_2);\\n                return true;\\n            }\\n            \\n            \\n        }\\n\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2482867,
                "title": "python-simple-python-solution-using-two-different-approach",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# 1. First Apporach Using Permutation Concept : \\n# Runtime: 8288 ms, faster than 5.35% of Python3 online submissions for Reordered Power of 2.\\n# Memory Usage: 28.1 MB, less than 11.23% of Python3 online submissions for Reordered Power of 2.\\n\\tclass Solution:\\n\\t\\tdef reorderedPowerOf2(self, n: int) -> bool:\\n\\n\\t\\t\\tall_permutations = [] \\n\\n\\t\\t\\tfor single_number in itertools.permutations(str(n)):\\n\\n\\t\\t\\t\\tif single_number[0] != \\'0\\':\\n\\n\\t\\t\\t\\t\\tnum = int(\\'\\'.join(single_number))\\n\\n\\t\\t\\t\\t\\tall_permutations.append(num)\\n\\n\\t\\t\\tfor i in range(32):\\n\\n\\t\\t\\t\\tif 2**i in all_permutations:\\n\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\treturn False\\n# 2. Second Approach With HashMap Or Dictionary with Sorting : \\n# Runtime: 56 ms, faster than 60.96% of Python3 online submissions for Reordered Power of 2.\\n# Memory Usage: 13.7 MB, less than 96.79% of Python3 online submissions for Reordered Power of 2.\\n\\n\\tclass Solution:\\n\\t\\tdef reorderedPowerOf2(self, n: int) -> bool:\\n\\n\\t\\t\\tnum = sorted(str(n))\\n\\n\\t\\t\\tfor i in range(32):\\n\\n\\t\\t\\t\\tcurrent_num = sorted(str(2**i))\\n\\n\\t\\t\\t\\tif num == current_num:\\n\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\treturn False\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting",
                    "Probability and Statistics"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# 1. First Apporach Using Permutation Concept : \\n# Runtime: 8288 ms, faster than 5.35% of Python3 online submissions for Reordered Power of 2.\\n# Memory Usage: 28.1 MB, less than 11.23% of Python3 online submissions for Reordered Power of 2.\\n\\tclass Solution:\\n\\t\\tdef reorderedPowerOf2(self, n: int) -> bool:\\n\\n\\t\\t\\tall_permutations = [] \\n\\n\\t\\t\\tfor single_number in itertools.permutations(str(n)):\\n\\n\\t\\t\\t\\tif single_number[0] != \\'0\\':\\n\\n\\t\\t\\t\\t\\tnum = int(\\'\\'.join(single_number))\\n\\n\\t\\t\\t\\t\\tall_permutations.append(num)\\n\\n\\t\\t\\tfor i in range(32):\\n\\n\\t\\t\\t\\tif 2**i in all_permutations:\\n\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\treturn False\\n# 2. Second Approach With HashMap Or Dictionary with Sorting : \\n# Runtime: 56 ms, faster than 60.96% of Python3 online submissions for Reordered Power of 2.\\n# Memory Usage: 13.7 MB, less than 96.79% of Python3 online submissions for Reordered Power of 2.\\n\\n\\tclass Solution:\\n\\t\\tdef reorderedPowerOf2(self, n: int) -> bool:\\n\\n\\t\\t\\tnum = sorted(str(n))\\n\\n\\t\\t\\tfor i in range(32):\\n\\n\\t\\t\\t\\tcurrent_num = sorted(str(2**i))\\n\\n\\t\\t\\t\\tif num == current_num:\\n\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\treturn False\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 2482646,
                "title": "easy-fast-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```\\n```\\n        char[] car1 = (\"\" + n).toCharArray(); \\n\\t\\tArrays.sort(car1);\\n\\n        for(int i = 0; i < 30;i++){\\n            char[] car2 = (\"\" + (1 << i)).toCharArray(); \\n\\t\\t\\tArrays.sort(car2);\\n            if(Arrays.equals(car1, car2)) return true;\\n        }\\n\\n        return false;",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2482476,
                "title": "asymptotic-o-1-constant-time-solution-faster-than-100-explanation",
                "content": "```\\nclass Solution { // 0ms - 100.00% Faster \\n    static HashSet<String> set;\\n    Solution(){ // this checks if the set is null, or it computes all the powers of 2 and stores it in the set(this operation occurs only once)\\n        if(set==null){\\n            set = new HashSet<String>();\\n            for(long i=1;i<=1000000000;i=i<<1){\\n                String s = getFrequencyChart(i);\\n                set.add(s);\\n            }\\n        }\\n    }\\n    private String getFrequencyChart(long n){ // this is the function to calculate the frequency of all the digits in the array\\n        int[] freq = new int[10];\\n        while(n>0){\\n            freq[(int)n%10]++;\\n            n/=10;\\n        }\\n        return Arrays.toString(freq);\\n    }\\n    \\n    public boolean reorderedPowerOf2(int n) {\\n        return set.contains(getFrequencyChart((long)n));\\n    }\\n}\\n```\\nExplanation:\\n* Which we are setting the map as static, it creates only one `set` map object for all the object of the Solution class. Thus reducing the time to recalculate the set\\n* `getFrequencyChart generates a frequency map of a number\\'s digits and returns it which is used as a hashset key\\n* In the Main Function we are just checking if the frequencies of the given numbers matches with the any power of 2.\\n\\n`Please Upvote if you find it helpful` \\uD83D\\uDE4F\\uD83D\\uDE4F",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution { // 0ms - 100.00% Faster \\n    static HashSet<String> set;\\n    Solution(){ // this checks if the set is null, or it computes all the powers of 2 and stores it in the set(this operation occurs only once)\\n        if(set==null){\\n            set = new HashSet<String>();\\n            for(long i=1;i<=1000000000;i=i<<1){\\n                String s = getFrequencyChart(i);\\n                set.add(s);\\n            }\\n        }\\n    }\\n    private String getFrequencyChart(long n){ // this is the function to calculate the frequency of all the digits in the array\\n        int[] freq = new int[10];\\n        while(n>0){\\n            freq[(int)n%10]++;\\n            n/=10;\\n        }\\n        return Arrays.toString(freq);\\n    }\\n    \\n    public boolean reorderedPowerOf2(int n) {\\n        return set.contains(getFrequencyChart((long)n));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482244,
                "title": "100-faster-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n\\n    bool equal(vector<int>&a,vector<int>&b ){\\n        for(int i=0;i<10;i++){\\n            if(a[i]!=b[i])return false;\\n        }\\n        return true;\\n    }\\n    vector<int> freq(int n){\\n        vector<int>f(10,0);\\n        while(n>0){\\n            f[n%10]++;\\n            n/=10;\\n        }\\n        return f;\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        vector<int>a(10,0);\\n        vector<int>b(10,0);\\n        a=freq(n);\\n        for(int i=0;i<31;i++){\\n            b=freq(pow(2,i));\\n            if(equal(a,b))return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool equal(vector<int>&a,vector<int>&b ){\\n        for(int i=0;i<10;i++){\\n            if(a[i]!=b[i])return false;\\n        }\\n        return true;\\n    }\\n    vector<int> freq(int n){\\n        vector<int>f(10,0);\\n        while(n>0){\\n            f[n%10]++;\\n            n/=10;\\n        }\\n        return f;\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        vector<int>a(10,0);\\n        vector<int>b(10,0);\\n        a=freq(n);\\n        for(int i=0;i<31;i++){\\n            b=freq(pow(2,i));\\n            if(equal(a,b))return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482202,
                "title": "rust-run-time-one-liner-and-the-nerdiest-approach-you-will-ever-see-p-with-comments",
                "content": "So I wasn\\'t the only one to think about precomputation here... Anyway, my \"standard\" solution is below, and then we\\'ll go really crazy with an idea I had below that, which you really don\\'t want to miss :D.\\n\\nI love how easy it is to compute things at compile time in Rust compared to C++\\'s `constexpr`. So for the \"standard\" solution I use that to build a look-up table with the digit histograms of all the powers of two <= 10^9 (there are 30). At runtime, I only have to build the histogram of the given number, and check if it is in the lookup table.\\n\\n**\"Standard\" Solution**\\n\\n```\\nconst N_DIGITS: usize = 10;\\n\\nconst fn build_histogram(mut n: i32) -> [u8; N_DIGITS] {\\n    let mut rez = [0; N_DIGITS];\\n    while n > 0 {\\n        rez[(n % 10) as usize] += 1;\\n        n /= 10;\\n    }\\n    rez\\n}\\n\\nconst N_POWERS: usize = 30;\\n\\nconst fn compute_power_histograms() -> [[u8; N_DIGITS]; N_POWERS] {\\n    let mut i = 0;\\n    let mut rez = [[0; N_DIGITS]; N_POWERS];\\n    while i < N_POWERS {\\n        rez[i] = build_histogram(1 << i);\\n        i += 1;\\n    }\\n    rez\\n}\\n\\nconst POWER_HISTOGRAMS: [[u8; N_DIGITS]; N_POWERS] = compute_power_histograms();\\n\\nimpl Solution {\\n    pub fn reordered_power_of2(n: i32) -> bool {\\n        POWER_HISTOGRAMS.contains(&build_histogram(n))\\n    }\\n}\\n```\\n\\n**Graph Solution**\\n\\nSo, what if we build a graph of all the valid paths we can take given the digits as edges? We\\'ll mark whether each node is a valid leaf or not. The result is that when we traverse the graph e.g. 64 and 46 both end up at the same leaf node. The benefit of this approach is that we will be able to weed out a number as soon as we encounter a digit that is not on a valid path, since the tail node won\\'t have an edge for the next digit. Compare that to the \"standard\" solution where we *have* to have all the digits of `n` before checking if it\\'s a valid power of two (yeah, yeah, big-O time complexities are the same, but let\\'s have some fun :) ) We\\'ll use a separate program to compute the graph (I have pasted that in at the very bottom of this post), and we\\'ll use the computed graph as a constant that gets compiled into our program for solving the problem. Here is the finished solution (it\\'s long :) ):\\n\\n```\\nconst N_DIGITS: usize = 10;\\n\\nimpl Solution {\\n    pub fn reordered_power_of2(mut n: i32) -> bool {\\n        let mut node = 0;\\n        while n > 0 {\\n            let digit = (n % 10) as usize;\\n            match GRAPH[node].0[digit] {\\n                0 => return false,\\n                next_node => node = next_node,\\n            }\\n            n /= 10;\\n        }\\n        GRAPH[node].1\\n    }\\n}\\n\\nconst GRAPH: [([usize; N_DIGITS], bool); 1203] = [\\n    ([31, 1, 2, 7, 3, 17, 5, 87, 4, 38], false),\\n    ([30, 139, 13, 75, 25, 20, 6, 123, 12, 54], true),\\n    ([29, 13, 162, 8, 21, 18, 16, 94, 10, 52], true),\\n    ([27, 25, 21, 73, 154, 184, 9, 261, 32, 43], true),\\n    ([37, 12, 10, 66, 32, 176, 55, 76, 164, 48], true),\\n    ([47, 6, 16, 71, 9, 14, 96, 88, 55, 39], false),\\n    ([273, 460, 153, 72, 70, 269, 457, 250, 62, 1072], true),\\n    ([136, 75, 8, 512, 73, 107, 71, 92, 66, 363], false),\\n    ([132, 128, 733, 515, 511, 501, 95, 93, 86, 1082], true),\\n    ([46, 70, 147, 68, 141, 265, 581, 246, 56, 40], true),\\n    ([36, 11, 183, 86, 33, 180, 85, 83, 174, 49], false),\\n    ([1153, 672, 670, 667, 661, 1147, 1138, 649, 0, 50], true),\\n    ([237, 673, 11, 67, 65, 233, 62, 215, 557, 51], false),\\n    ([28, 137, 163, 128, 22, 19, 153, 118, 11, 53], false),\\n    ([271, 269, 15, 104, 265, 102, 97, 238, 218, 1044], false),\\n    ([1190, 1188, 0, 868, 867, 860, 842, 1162, 792, 1053], true),\\n    ([1196, 153, 151, 95, 147, 15, 454, 91, 85, 1068], false),\\n    ([278, 20, 18, 107, 184, 105, 14, 253, 176, 303], false),\\n    ([338, 19, 187, 501, 185, 482, 15, 322, 180, 304], false),\\n    ([337, 0, 334, 1197, 0, 0, 1188, 327, 1147, 309], true),\\n    ([277, 0, 19, 1200, 274, 0, 269, 258, 233, 312], false),\\n    ([24, 22, 160, 511, 155, 185, 147, 713, 33, 0], false),\\n    ([23, 731, 161, 727, 158, 0, 150, 717, 661, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 23, 0, 0, 0, 0, 0, 0, 34, 0], false),\\n    ([26, 732, 22, 74, 159, 274, 70, 262, 65, 361], false),\\n    ([0, 0, 23, 381, 379, 275, 272, 263, 236, 362], false),\\n    ([0, 26, 24, 382, 380, 276, 46, 264, 35, 44], false),\\n    ([0, 138, 339, 131, 23, 337, 1195, 121, 1153, 319], false),\\n    ([0, 28, 340, 132, 24, 338, 1196, 122, 36, 320], false),\\n    ([0, 140, 28, 135, 26, 277, 273, 126, 237, 321], false),\\n    ([0, 30, 29, 136, 27, 278, 47, 127, 37, 45], false),\\n    ([35, 65, 33, 63, 819, 177, 56, 211, 171, 0], false),\\n    ([34, 661, 182, 652, 822, 178, 798, 632, 172, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 236, 34, 0, 0, 232, 227, 214, 556, 0], false),\\n    ([0, 1153, 0, 1151, 34, 1149, 1140, 1124, 0, 993], false),\\n    ([0, 237, 36, 407, 35, 235, 229, 217, 405, 995], false),\\n    ([45, 54, 52, 363, 43, 303, 39, 279, 48, 0], false),\\n    ([42, 1072, 1068, 1060, 40, 1044, 0, 996, 936, 0], false),\\n    ([41, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 1073, 1071, 1067, 41, 1059, 0, 1027, 967, 0], false),\\n    ([44, 361, 0, 357, 341, 0, 40, 0, 0, 0], false),\\n    ([0, 362, 0, 360, 356, 0, 41, 0, 0, 0], false),\\n    ([0, 321, 320, 366, 44, 314, 42, 302, 995, 0], false),\\n    ([0, 272, 0, 0, 0, 268, 584, 249, 227, 41], false),\\n    ([0, 273, 1196, 408, 46, 271, 586, 252, 229, 42], false),\\n    ([995, 51, 49, 984, 0, 968, 936, 872, 0, 0], false),\\n    ([993, 50, 0, 985, 0, 977, 961, 929, 0, 0], false),\\n    ([992, 0, 0, 986, 0, 978, 962, 930, 0, 0], true),\\n    ([994, 0, 50, 989, 0, 981, 965, 933, 0, 0], false),\\n    ([320, 53, 315, 1082, 0, 304, 1068, 292, 49, 0], false),\\n    ([319, 0, 316, 1083, 0, 309, 1069, 297, 50, 0], false),\\n    ([321, 0, 53, 364, 361, 312, 1072, 300, 51, 0], false),\\n    ([229, 62, 85, 60, 56, 218, 567, 77, 399, 936], false),\\n    ([227, 59, 798, 57, 793, 219, 568, 196, 548, 0], false),\\n    ([0, 58, 797, 0, 794, 787, 765, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([226, 0, 0, 58, 0, 220, 569, 197, 549, 0], false),\\n    ([406, 61, 84, 0, 57, 790, 768, 78, 400, 953], false),\\n    ([1137, 0, 1134, 0, 58, 1128, 0, 1101, 0, 958], false),\\n    ([228, 0, 1138, 61, 59, 223, 572, 200, 552, 965], false),\\n    ([0, 64, 652, 0, 820, 815, 57, 623, 0, 0], false),\\n    ([0, 658, 656, 0, 0, 0, 58, 630, 0, 0], false),\\n    ([236, 663, 661, 64, 0, 230, 59, 212, 554, 0], false),\\n    ([407, 67, 86, 0, 63, 817, 60, 81, 403, 984], false),\\n    ([1152, 669, 667, 0, 64, 1144, 61, 644, 0, 989], false),\\n    ([0, 69, 871, 0, 869, 865, 847, 0, 57, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 58, 0], false),\\n    ([272, 0, 150, 69, 146, 266, 582, 247, 59, 0], false),\\n    ([408, 72, 95, 0, 68, 104, 101, 89, 60, 1060], false),\\n    ([1194, 0, 1191, 0, 69, 1185, 0, 1169, 61, 1065], false),\\n    ([382, 74, 511, 507, 375, 491, 68, 704, 63, 357], false),\\n    ([381, 729, 727, 0, 376, 0, 69, 711, 64, 358], false),\\n    ([135, 133, 128, 0, 74, 1200, 72, 113, 67, 364], false),\\n    ([217, 215, 83, 81, 211, 203, 77, 587, 516, 872], false),\\n    ([202, 200, 80, 78, 196, 188, 559, 0, 517, 873], false),\\n    ([1103, 1101, 79, 0, 0, 1086, 0, 0, 0, 890], false),\\n    ([1100, 1098, 0, 0, 0, 1087, 0, 0, 0, 891], true),\\n    ([1106, 1104, 0, 79, 0, 1094, 0, 0, 0, 898], false),\\n    ([1122, 644, 82, 0, 623, 1107, 78, 606, 0, 921], false),\\n    ([1120, 642, 639, 0, 624, 1108, 79, 607, 0, 922], false),\\n    ([1124, 649, 646, 82, 632, 1115, 80, 615, 0, 929], false),\\n    ([1136, 1134, 0, 0, 797, 791, 769, 79, 0, 954], false),\\n    ([1140, 1138, 0, 84, 798, 792, 770, 80, 0, 961], false),\\n    ([1151, 667, 664, 0, 652, 818, 84, 82, 0, 985], false),\\n    ([127, 123, 94, 92, 261, 253, 88, 409, 76, 279], false),\\n    ([252, 250, 91, 89, 246, 238, 445, 428, 77, 996], false),\\n    ([1171, 1169, 90, 0, 0, 1154, 0, 0, 78, 1013], false),\\n    ([1168, 1166, 0, 0, 0, 1155, 0, 0, 79, 1014], false),\\n    ([1173, 451, 0, 90, 0, 1162, 446, 435, 80, 1021], false),\\n    ([117, 113, 93, 0, 704, 1174, 89, 692, 81, 1036], false),\\n    ([112, 108, 720, 0, 705, 1175, 90, 693, 82, 1037], false),\\n    ([122, 118, 330, 93, 713, 322, 91, 440, 83, 292], false),\\n    ([1193, 1191, 0, 0, 871, 868, 850, 90, 84, 1061], false),\\n    ([586, 457, 454, 101, 581, 97, 0, 445, 567, 0], false),\\n    ([0, 0, 842, 100, 833, 98, 0, 0, 737, 0], false),\\n    ([0, 0, 832, 99, 823, 0, 0, 0, 738, 0], false),\\n    ([0, 0, 831, 0, 828, 0, 0, 0, 747, 0], true),\\n    ([0, 0, 841, 0, 838, 99, 0, 0, 758, 0], false),\\n    ([0, 0, 850, 0, 847, 100, 0, 0, 768, 0], false),\\n    ([0, 0, 860, 103, 851, 0, 98, 0, 771, 0], false),\\n    ([0, 0, 859, 0, 856, 0, 99, 0, 780, 0], false),\\n    ([1187, 1185, 868, 0, 865, 103, 100, 1154, 790, 1045], false),\\n    ([0, 0, 482, 106, 461, 0, 102, 0, 799, 0], false),\\n    ([0, 0, 481, 477, 470, 0, 103, 0, 808, 0], false),\\n    (\\n        [1202, 1200, 501, 497, 491, 106, 104, 1174, 817, 1074],\\n        false,\\n    ),\\n    ([111, 109, 721, 0, 709, 1176, 1166, 697, 642, 1038], false),\\n    ([110, 0, 722, 0, 710, 0, 0, 698, 643, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 110, 0, 0, 0, 1177, 1167, 0, 1119, 1039], false),\\n    ([0, 111, 0, 0, 0, 1178, 1168, 0, 1120, 1040], false),\\n    ([116, 114, 108, 0, 711, 1179, 1169, 699, 644, 1041], false),\\n    ([115, 0, 109, 0, 712, 0, 0, 700, 645, 0], false),\\n    ([0, 0, 110, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 115, 111, 0, 0, 1180, 1170, 0, 1121, 1042], false),\\n    ([0, 116, 112, 0, 0, 1181, 1171, 0, 1122, 1043], false),\\n    ([121, 119, 331, 108, 717, 327, 451, 441, 649, 297], false),\\n    ([120, 0, 723, 109, 718, 0, 452, 442, 650, 0], false),\\n    ([0, 0, 0, 110, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 120, 332, 111, 0, 328, 1172, 0, 1123, 298], false),\\n    ([0, 121, 333, 112, 0, 329, 1173, 0, 1124, 299], false),\\n    ([126, 124, 118, 113, 262, 258, 250, 443, 215, 300], false),\\n    ([125, 0, 119, 114, 719, 0, 453, 444, 651, 0], false),\\n    ([0, 0, 120, 115, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 125, 121, 116, 263, 259, 251, 0, 216, 301], false),\\n    ([0, 126, 122, 117, 264, 260, 252, 0, 217, 302], false),\\n    ([131, 129, 734, 0, 727, 1197, 1191, 108, 667, 1083], false),\\n    ([130, 0, 735, 0, 728, 0, 0, 109, 668, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 110, 0, 0], false),\\n    ([0, 130, 0, 0, 0, 1198, 1192, 111, 1150, 1084], false),\\n    ([0, 131, 0, 0, 0, 1199, 1193, 112, 1151, 1085], false),\\n    ([134, 0, 129, 0, 729, 0, 0, 114, 669, 0], false),\\n    ([0, 0, 130, 0, 0, 0, 0, 115, 0, 0], false),\\n    ([0, 134, 131, 0, 381, 1201, 1194, 116, 1152, 365], false),\\n    ([0, 135, 132, 0, 382, 1202, 408, 117, 407, 366], false),\\n    ([138, 0, 736, 129, 731, 0, 459, 119, 672, 0], false),\\n    ([0, 0, 0, 130, 0, 0, 0, 120, 0, 0], false),\\n    ([140, 0, 137, 133, 732, 0, 460, 124, 673, 0], false),\\n    ([0, 0, 138, 134, 0, 0, 0, 125, 0, 0], false),\\n    ([0, 146, 142, 869, 0, 861, 843, 0, 793, 0], false),\\n    ([0, 145, 143, 870, 0, 864, 846, 0, 796, 0], false),\\n    ([0, 144, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 0, 144, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 145, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 150, 148, 871, 142, 867, 849, 0, 798, 0], false),\\n    ([0, 149, 0, 0, 143, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 144, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 149, 0, 145, 0, 0, 0, 0, 0], false),\\n    ([0, 152, 0, 0, 148, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 149, 0, 0, 0, 0, 0], false),\\n    (\\n        [1195, 459, 152, 1191, 150, 1188, 455, 451, 1138, 1069],\\n        false,\\n    ),\\n    ([380, 159, 155, 375, 367, 483, 141, 0, 819, 341], false),\\n    ([0, 158, 156, 506, 0, 490, 142, 0, 822, 0], false),\\n    ([0, 157, 0, 0, 0, 0, 143, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 144, 0, 0, 0], false),\\n    ([0, 0, 157, 0, 0, 0, 145, 0, 0, 0], false),\\n    ([379, 0, 158, 376, 372, 0, 146, 0, 0, 354], false),\\n    ([0, 161, 0, 724, 156, 186, 148, 714, 182, 0], false),\\n    ([0, 730, 0, 725, 157, 0, 149, 715, 659, 0], false),\\n    ([340, 163, 0, 733, 160, 187, 151, 330, 183, 315], false),\\n    ([339, 736, 0, 734, 161, 334, 152, 331, 670, 316], false),\\n    ([405, 557, 174, 403, 171, 165, 399, 516, 383, 0], false),\\n    ([0, 0, 169, 0, 166, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 167, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 168, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 0, 170, 0, 167, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 168, 0, 0, 0, 0, 0], false),\\n    ([556, 554, 172, 0, 0, 166, 548, 533, 0, 0], false),\\n    ([0, 0, 173, 0, 0, 167, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 168, 0, 0, 0, 0], false),\\n    ([0, 0, 175, 0, 172, 169, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 173, 170, 0, 0, 0, 0], false),\\n    ([235, 233, 180, 817, 177, 799, 218, 203, 165, 968], false),\\n    ([232, 230, 178, 815, 811, 800, 219, 204, 166, 0], false),\\n    ([0, 0, 179, 816, 814, 807, 789, 0, 167, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 168, 0], false),\\n    ([1149, 1147, 181, 818, 178, 810, 792, 1115, 169, 977], false),\\n    ([0, 0, 0, 0, 179, 0, 0, 0, 170, 0], false),\\n    ([0, 659, 0, 653, 0, 179, 0, 633, 173, 0], false),\\n    ([0, 670, 0, 664, 182, 181, 0, 646, 175, 0], false),\\n    ([276, 274, 185, 491, 483, 461, 265, 254, 177, 0], false),\\n    ([0, 0, 186, 496, 490, 476, 867, 0, 178, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 179, 0], false),\\n    ([336, 334, 0, 0, 186, 0, 0, 323, 181, 305], false),\\n    ([195, 193, 1094, 1086, 189, 0, 0, 0, 0, 874], false),\\n    ([192, 190, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([191, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 191, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([194, 0, 1095, 1091, 190, 0, 0, 0, 0, 887], false),\\n    ([0, 0, 1096, 1092, 191, 0, 0, 0, 0, 888], false),\\n    ([0, 194, 1097, 1093, 192, 0, 0, 0, 0, 889], false),\\n    ([199, 197, 0, 0, 0, 189, 560, 0, 526, 0], false),\\n    ([198, 0, 0, 0, 0, 190, 561, 0, 527, 0], false),\\n    ([0, 0, 0, 0, 0, 191, 562, 0, 528, 0], false),\\n    ([0, 198, 0, 0, 0, 192, 563, 0, 529, 0], false),\\n    ([201, 0, 1104, 1101, 197, 193, 564, 0, 530, 902], false),\\n    ([0, 0, 1105, 1102, 198, 194, 565, 0, 531, 903], false),\\n    ([0, 201, 1106, 1103, 199, 195, 566, 0, 532, 904], false),\\n    ([210, 208, 1115, 1107, 204, 0, 188, 0, 0, 905], false),\\n    ([207, 205, 0, 0, 0, 0, 189, 0, 0, 0], false),\\n    ([206, 0, 0, 0, 0, 0, 190, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 191, 0, 0, 0], false),\\n    ([0, 206, 0, 0, 0, 0, 192, 0, 0, 0], false),\\n    ([209, 0, 1116, 1112, 205, 0, 193, 0, 0, 918], false),\\n    ([0, 0, 1117, 1113, 206, 0, 194, 0, 0, 919], false),\\n    ([0, 209, 1118, 1114, 207, 0, 195, 0, 0, 920], false),\\n    ([214, 212, 632, 623, 0, 204, 196, 588, 533, 0], false),\\n    ([213, 638, 636, 630, 0, 205, 197, 604, 534, 0], false),\\n    ([0, 0, 0, 0, 0, 206, 198, 0, 535, 0], false),\\n    ([0, 213, 0, 0, 0, 207, 199, 0, 536, 0], false),\\n    ([216, 651, 649, 644, 212, 208, 200, 621, 537, 933], false),\\n    ([0, 0, 1123, 1121, 213, 209, 201, 0, 538, 934], false),\\n    ([0, 216, 1124, 1122, 214, 210, 202, 0, 539, 935], false),\\n    ([225, 223, 792, 790, 219, 771, 737, 188, 0, 937], false),\\n    ([222, 220, 789, 787, 783, 772, 750, 189, 0, 0], false),\\n    ([221, 0, 0, 0, 0, 0, 0, 190, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 191, 0, 0], false),\\n    ([0, 221, 0, 0, 0, 0, 0, 192, 0, 0], false),\\n    ([224, 0, 1131, 1128, 220, 0, 0, 193, 0, 950], false),\\n    ([0, 0, 1132, 1129, 221, 0, 0, 194, 0, 951], false),\\n    ([0, 224, 1133, 1130, 222, 0, 0, 195, 0, 952], false),\\n    ([0, 0, 0, 0, 0, 221, 570, 198, 550, 0], false),\\n    ([0, 226, 0, 0, 0, 222, 571, 199, 551, 0], false),\\n    ([0, 0, 1139, 1137, 226, 224, 573, 201, 553, 966], false),\\n    ([0, 228, 1140, 406, 227, 225, 574, 202, 402, 967], false),\\n    ([231, 0, 0, 0, 0, 0, 220, 205, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 221, 206, 0, 0], false),\\n    ([0, 231, 0, 0, 0, 0, 222, 207, 0, 0], false),\\n    ([234, 0, 1147, 1144, 230, 0, 223, 208, 0, 981], false),\\n    ([0, 0, 1148, 1145, 231, 0, 224, 209, 0, 982], false),\\n    ([0, 234, 1149, 1146, 232, 0, 225, 210, 0, 983], false),\\n    ([0, 0, 0, 0, 0, 231, 226, 213, 555, 0], false),\\n    ([0, 0, 1153, 1152, 236, 234, 228, 216, 558, 994], false),\\n    ([245, 243, 1162, 1154, 239, 0, 0, 0, 188, 997], false),\\n    ([242, 240, 0, 0, 0, 0, 0, 0, 189, 0], false),\\n    ([241, 0, 0, 0, 0, 0, 0, 0, 190, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 191, 0], false),\\n    ([0, 241, 0, 0, 0, 0, 0, 0, 192, 0], false),\\n    ([244, 0, 1163, 1159, 240, 0, 0, 0, 193, 1010], false),\\n    ([0, 0, 1164, 1160, 241, 0, 0, 0, 194, 1011], false),\\n    ([0, 244, 1165, 1161, 242, 0, 0, 0, 195, 1012], false),\\n    ([249, 247, 0, 0, 0, 239, 575, 0, 196, 0], false),\\n    ([248, 0, 0, 0, 0, 240, 576, 0, 197, 0], false),\\n    ([0, 0, 0, 0, 0, 241, 577, 0, 198, 0], false),\\n    ([0, 248, 0, 0, 0, 242, 578, 0, 199, 0], false),\\n    ([251, 453, 451, 1169, 247, 243, 449, 438, 200, 1025], false),\\n    ([0, 0, 1172, 1170, 248, 244, 579, 0, 201, 1026], false),\\n    ([0, 251, 1173, 1171, 249, 245, 580, 0, 202, 1027], false),\\n    ([260, 258, 322, 1174, 254, 0, 238, 0, 203, 280], false),\\n    ([257, 255, 0, 0, 0, 0, 239, 0, 204, 0], false),\\n    ([256, 0, 0, 0, 0, 0, 240, 0, 205, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 241, 0, 206, 0], false),\\n    ([0, 256, 0, 0, 0, 0, 242, 0, 207, 0], false),\\n    ([259, 0, 327, 1179, 255, 0, 243, 0, 208, 289], false),\\n    ([0, 0, 328, 1180, 256, 0, 244, 0, 209, 290], false),\\n    ([0, 259, 329, 1181, 257, 0, 245, 0, 210, 291], false),\\n    ([264, 262, 713, 704, 0, 254, 246, 674, 211, 0], false),\\n    ([263, 719, 717, 711, 0, 255, 247, 690, 212, 0], false),\\n    ([0, 0, 0, 0, 0, 256, 248, 0, 213, 0], false),\\n    ([0, 263, 0, 0, 0, 257, 249, 0, 214, 0], false),\\n    ([268, 266, 867, 865, 861, 851, 833, 239, 219, 0], false),\\n    ([267, 0, 0, 0, 0, 0, 0, 240, 220, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 241, 221, 0], false),\\n    ([0, 267, 0, 0, 0, 0, 0, 242, 222, 0], false),\\n    ([270, 0, 1188, 1185, 266, 0, 0, 243, 223, 1057], false),\\n    ([0, 0, 1189, 1186, 267, 0, 0, 244, 224, 1058], false),\\n    ([0, 270, 1190, 1187, 268, 0, 0, 245, 225, 1059], false),\\n    ([0, 0, 0, 0, 0, 267, 583, 248, 226, 0], false),\\n    ([0, 0, 1195, 1194, 272, 270, 585, 251, 228, 1073], false),\\n    ([275, 0, 0, 0, 0, 0, 266, 255, 230, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 267, 256, 231, 0], false),\\n    ([0, 275, 0, 0, 0, 0, 268, 257, 232, 0], false),\\n    ([0, 0, 337, 1201, 275, 0, 270, 259, 234, 313], false),\\n    ([0, 277, 338, 1202, 276, 0, 271, 260, 235, 314], false),\\n    ([302, 300, 292, 1036, 0, 280, 996, 0, 872, 0], false),\\n    ([291, 289, 281, 1028, 0, 0, 997, 0, 905, 0], false),\\n    ([288, 286, 282, 1029, 0, 0, 1006, 0, 914, 0], false),\\n    ([285, 283, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([284, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 284, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([287, 0, 283, 1030, 0, 0, 1007, 0, 915, 0], false),\\n    ([0, 0, 284, 1031, 0, 0, 1008, 0, 916, 0], false),\\n    ([0, 287, 285, 1032, 0, 0, 1009, 0, 917, 0], false),\\n    ([290, 0, 286, 1033, 0, 0, 1010, 0, 918, 0], false),\\n    ([0, 0, 287, 1034, 0, 0, 1011, 0, 919, 0], false),\\n    ([0, 290, 288, 1035, 0, 0, 1012, 0, 920, 0], false),\\n    ([299, 297, 293, 1037, 0, 281, 1021, 0, 929, 0], false),\\n    ([296, 294, 0, 0, 0, 282, 0, 0, 0, 0], false),\\n    ([295, 0, 0, 0, 0, 283, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 284, 0, 0, 0, 0], false),\\n    ([0, 295, 0, 0, 0, 285, 0, 0, 0, 0], false),\\n    ([298, 0, 294, 1038, 0, 286, 1022, 0, 930, 0], false),\\n    ([0, 0, 295, 1039, 0, 287, 1023, 0, 931, 0], false),\\n    ([0, 298, 296, 1040, 0, 288, 1024, 0, 932, 0], false),\\n    ([301, 0, 297, 1041, 0, 289, 1025, 0, 933, 0], false),\\n    ([0, 0, 298, 1042, 0, 290, 1026, 0, 934, 0], false),\\n    ([0, 301, 299, 1043, 0, 291, 1027, 0, 935, 0], false),\\n    ([314, 312, 304, 1074, 0, 0, 1044, 280, 968, 0], false),\\n    ([311, 309, 305, 1075, 0, 0, 1053, 281, 977, 0], false),\\n    ([308, 306, 0, 0, 0, 0, 0, 282, 0, 0], false),\\n    ([307, 0, 0, 0, 0, 0, 0, 283, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 284, 0, 0], false),\\n    ([0, 307, 0, 0, 0, 0, 0, 285, 0, 0], false),\\n    ([310, 0, 306, 1076, 0, 0, 1054, 286, 978, 0], false),\\n    ([0, 0, 307, 1077, 0, 0, 1055, 287, 979, 0], false),\\n    ([0, 310, 308, 1078, 0, 0, 1056, 288, 980, 0], false),\\n    ([313, 0, 309, 1079, 0, 0, 1057, 289, 981, 0], false),\\n    ([0, 0, 310, 1080, 0, 0, 1058, 290, 982, 0], false),\\n    ([0, 313, 311, 1081, 0, 0, 1059, 291, 983, 0], false),\\n    ([318, 316, 0, 0, 0, 305, 0, 293, 0, 0], false),\\n    ([317, 0, 0, 0, 0, 306, 0, 294, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 307, 0, 295, 0, 0], false),\\n    ([0, 317, 0, 0, 0, 308, 0, 296, 0, 0], false),\\n    ([0, 0, 317, 1084, 0, 310, 1070, 298, 992, 0], false),\\n    ([0, 319, 318, 1085, 0, 311, 1071, 299, 993, 0], false),\\n    ([0, 0, 319, 365, 362, 313, 1073, 301, 994, 0], false),\\n    ([329, 327, 323, 1175, 0, 0, 1162, 0, 1115, 281], false),\\n    ([326, 324, 0, 0, 0, 0, 0, 0, 0, 282], false),\\n    ([325, 0, 0, 0, 0, 0, 0, 0, 0, 283], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 284], false),\\n    ([0, 325, 0, 0, 0, 0, 0, 0, 0, 285], false),\\n    ([328, 0, 324, 1176, 0, 0, 1163, 0, 1116, 286], false),\\n    ([0, 0, 325, 1177, 0, 0, 1164, 0, 1117, 287], false),\\n    ([0, 328, 326, 1178, 0, 0, 1165, 0, 1118, 288], false),\\n    ([333, 331, 0, 720, 714, 323, 0, 701, 646, 293], false),\\n    ([332, 723, 0, 721, 715, 324, 0, 702, 647, 294], false),\\n    ([0, 0, 0, 0, 0, 325, 0, 0, 0, 295], false),\\n    ([0, 332, 0, 0, 0, 326, 0, 0, 0, 296], false),\\n    ([335, 0, 0, 0, 0, 0, 0, 324, 0, 306], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 325, 0, 307], false),\\n    ([0, 335, 0, 0, 0, 0, 0, 326, 0, 308], false),\\n    ([0, 0, 335, 1198, 0, 0, 1189, 328, 1148, 310], false),\\n    ([0, 337, 336, 1199, 0, 0, 1190, 329, 1149, 311], false),\\n    ([0, 0, 0, 0, 0, 335, 0, 332, 0, 317], false),\\n    ([0, 339, 0, 0, 0, 336, 0, 333, 0, 318], false),\\n    ([356, 354, 0, 350, 342, 0, 0, 0, 0, 0], false),\\n    ([349, 347, 0, 343, 0, 0, 0, 0, 0, 0], false),\\n    ([346, 344, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([345, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 345, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([348, 0, 0, 344, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 345, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 348, 0, 346, 0, 0, 0, 0, 0, 0], false),\\n    ([353, 351, 0, 0, 343, 0, 0, 0, 0, 0], false),\\n    ([352, 0, 0, 0, 344, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 345, 0, 0, 0, 0, 0], false),\\n    ([0, 352, 0, 0, 346, 0, 0, 0, 0, 0], false),\\n    ([355, 0, 0, 351, 347, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 352, 348, 0, 0, 0, 0, 0], false),\\n    ([0, 355, 0, 353, 349, 0, 0, 0, 0, 0], false),\\n    ([360, 358, 0, 0, 350, 0, 0, 0, 0, 0], false),\\n    ([359, 0, 0, 0, 351, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 352, 0, 0, 0, 0, 0], false),\\n    ([0, 359, 0, 0, 353, 0, 0, 0, 0, 0], false),\\n    ([362, 0, 0, 358, 354, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 359, 355, 0, 0, 0, 0, 0], false),\\n    ([366, 364, 1082, 0, 357, 1074, 1060, 1036, 984, 0], false),\\n    ([365, 0, 1083, 0, 358, 1079, 1065, 1041, 989, 0], false),\\n    ([0, 0, 1084, 0, 359, 1080, 1066, 1042, 990, 0], false),\\n    ([0, 365, 1085, 0, 360, 1081, 1067, 1043, 991, 0], false),\\n    ([374, 372, 0, 368, 0, 0, 0, 0, 0, 342], false),\\n    ([371, 369, 0, 0, 0, 0, 0, 0, 0, 343], false),\\n    ([370, 0, 0, 0, 0, 0, 0, 0, 0, 344], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 345], false),\\n    ([0, 370, 0, 0, 0, 0, 0, 0, 0, 346], false),\\n    ([373, 0, 0, 369, 0, 0, 0, 0, 0, 347], false),\\n    ([0, 0, 0, 370, 0, 0, 0, 0, 0, 348], false),\\n    ([0, 373, 0, 371, 0, 0, 0, 0, 0, 349], false),\\n    ([378, 376, 506, 502, 368, 484, 869, 0, 820, 350], false),\\n    ([377, 0, 0, 0, 369, 0, 0, 0, 0, 351], false),\\n    ([0, 0, 0, 0, 370, 0, 0, 0, 0, 352], false),\\n    ([0, 377, 0, 0, 371, 0, 0, 0, 0, 353], false),\\n    ([0, 0, 0, 377, 373, 0, 0, 0, 0, 355], false),\\n    ([0, 379, 0, 378, 374, 0, 0, 0, 0, 356], false),\\n    ([0, 0, 0, 0, 377, 0, 0, 0, 0, 359], false),\\n    ([0, 381, 0, 0, 378, 0, 0, 0, 0, 360], false),\\n    ([398, 0, 0, 396, 0, 0, 392, 0, 384, 0], false),\\n    ([391, 0, 0, 389, 0, 0, 385, 0, 0, 0], false),\\n    ([388, 0, 0, 386, 0, 0, 0, 0, 0, 0], false),\\n    ([387, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 0, 0, 387, 0, 0, 0, 0, 0, 0], false),\\n    ([390, 0, 0, 0, 0, 0, 386, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 387, 0, 0, 0], false),\\n    ([0, 0, 0, 390, 0, 0, 388, 0, 0, 0], false),\\n    ([395, 0, 0, 393, 0, 0, 0, 0, 385, 0], false),\\n    ([394, 0, 0, 0, 0, 0, 0, 0, 386, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 387, 0], false),\\n    ([0, 0, 0, 394, 0, 0, 0, 0, 388, 0], false),\\n    ([397, 0, 0, 0, 0, 0, 393, 0, 389, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 394, 0, 390, 0], false),\\n    ([0, 0, 0, 397, 0, 0, 395, 0, 391, 0], false),\\n    ([402, 552, 0, 400, 548, 0, 540, 517, 392, 0], false),\\n    ([401, 0, 0, 0, 0, 0, 0, 0, 393, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 394, 0], false),\\n    ([0, 553, 0, 401, 551, 0, 547, 532, 395, 0], false),\\n    ([404, 0, 0, 0, 0, 0, 400, 0, 396, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 401, 0, 397, 0], false),\\n    ([0, 558, 0, 404, 556, 0, 402, 539, 398, 0], false),\\n    ([0, 1137, 1136, 0, 0, 1130, 0, 1103, 401, 960], false),\\n    ([0, 1152, 1151, 0, 0, 1146, 406, 1122, 404, 991], false),\\n    ([0, 1194, 1193, 0, 0, 1187, 0, 1171, 406, 1067], false),\\n    ([0, 443, 440, 692, 674, 0, 428, 410, 587, 0], false),\\n    ([0, 426, 423, 0, 0, 0, 411, 0, 0, 0], false),\\n    ([0, 421, 418, 0, 0, 0, 412, 0, 0, 0], false),\\n    ([0, 416, 413, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 414, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 415, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 417, 414, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 415, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 419, 0, 0, 0, 0, 413, 0, 0, 0], false),\\n    ([0, 420, 0, 0, 0, 0, 414, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 415, 0, 0, 0], false),\\n    ([0, 422, 419, 0, 0, 0, 416, 0, 0, 0], false),\\n    ([0, 0, 420, 0, 0, 0, 417, 0, 0, 0], false),\\n    ([0, 424, 0, 0, 0, 0, 418, 0, 0, 0], false),\\n    ([0, 425, 0, 0, 0, 0, 419, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 420, 0, 0, 0], false),\\n    ([0, 427, 424, 0, 0, 0, 421, 0, 0, 0], false),\\n    ([0, 0, 425, 0, 0, 0, 422, 0, 0, 0], false),\\n    ([0, 438, 435, 0, 0, 0, 429, 411, 0, 0], false),\\n    ([0, 433, 430, 0, 0, 0, 0, 412, 0, 0], false),\\n    ([0, 431, 0, 0, 0, 0, 0, 413, 0, 0], false),\\n    ([0, 432, 0, 0, 0, 0, 0, 414, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 415, 0, 0], false),\\n    ([0, 434, 431, 0, 0, 0, 0, 416, 0, 0], false),\\n    ([0, 0, 432, 0, 0, 0, 0, 417, 0, 0], false),\\n    ([0, 436, 0, 0, 0, 0, 430, 418, 0, 0], false),\\n    ([0, 437, 0, 0, 0, 0, 431, 419, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 432, 420, 0, 0], false),\\n    ([0, 439, 436, 0, 0, 0, 433, 421, 0, 0], false),\\n    ([0, 0, 437, 0, 0, 0, 434, 422, 0, 0], false),\\n    ([0, 441, 701, 693, 684, 0, 435, 423, 615, 0], false),\\n    ([0, 442, 702, 697, 688, 0, 436, 424, 619, 0], false),\\n    ([0, 0, 703, 698, 689, 0, 437, 425, 620, 0], false),\\n    ([0, 444, 441, 699, 690, 0, 438, 426, 621, 0], false),\\n    ([0, 0, 442, 700, 691, 0, 439, 427, 622, 0], false),\\n    ([580, 449, 446, 0, 575, 0, 0, 429, 559, 0], false),\\n    ([0, 447, 0, 0, 0, 0, 0, 430, 0, 0], false),\\n    ([0, 448, 0, 0, 0, 0, 0, 431, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 432, 0, 0], false),\\n    ([579, 450, 447, 0, 576, 0, 0, 433, 564, 0], false),\\n    ([0, 0, 448, 0, 0, 0, 0, 434, 0, 0], false),\\n    ([1172, 452, 0, 1166, 0, 1163, 447, 436, 1104, 1022], false),\\n    ([0, 0, 0, 0, 0, 0, 448, 437, 0, 0], false),\\n    ([0, 0, 452, 0, 0, 0, 450, 439, 0, 0], false),\\n    ([0, 455, 0, 850, 849, 842, 0, 446, 770, 0], false),\\n    ([0, 456, 0, 0, 0, 0, 0, 447, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 448, 0, 0], false),\\n    ([585, 458, 455, 0, 582, 0, 0, 449, 572, 0], false),\\n    ([0, 0, 456, 0, 0, 0, 0, 450, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 456, 452, 0, 0], false),\\n    ([0, 0, 459, 0, 0, 0, 458, 453, 0, 0], false),\\n    ([0, 0, 476, 470, 462, 0, 851, 0, 800, 0], false),\\n    ([0, 0, 469, 463, 0, 0, 852, 0, 801, 0], false),\\n    ([0, 0, 468, 464, 0, 0, 853, 0, 802, 0], false),\\n    ([0, 0, 467, 465, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 466, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 0, 0, 466, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 467, 0, 0, 854, 0, 803, 0], false),\\n    ([0, 0, 0, 468, 0, 0, 855, 0, 804, 0], false),\\n    ([0, 0, 475, 471, 463, 0, 856, 0, 805, 0], false),\\n    ([0, 0, 474, 472, 464, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 473, 0, 465, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 466, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 473, 467, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 474, 468, 0, 857, 0, 806, 0], false),\\n    ([0, 0, 0, 475, 469, 0, 858, 0, 807, 0], false),\\n    ([0, 0, 480, 478, 471, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 479, 0, 472, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 473, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 479, 474, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 480, 475, 0, 859, 0, 809, 0], false),\\n    ([0, 0, 0, 481, 476, 0, 860, 0, 810, 0], false),\\n    ([0, 0, 490, 484, 0, 462, 861, 0, 811, 0], false),\\n    ([0, 0, 489, 485, 0, 463, 862, 0, 812, 0], false),\\n    ([0, 0, 488, 486, 0, 464, 0, 0, 0, 0], false),\\n    ([0, 0, 487, 0, 0, 465, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 466, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 487, 0, 467, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 488, 0, 468, 863, 0, 813, 0], false),\\n    ([0, 0, 0, 489, 0, 469, 864, 0, 814, 0], false),\\n    ([0, 0, 496, 492, 484, 470, 865, 0, 815, 0], false),\\n    ([0, 0, 495, 493, 485, 471, 0, 0, 0, 0], false),\\n    ([0, 0, 494, 0, 486, 472, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 487, 473, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 494, 488, 474, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 495, 489, 475, 866, 0, 816, 0], false),\\n    ([0, 0, 500, 498, 492, 477, 0, 0, 0, 0], false),\\n    ([0, 0, 499, 0, 493, 478, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 494, 479, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 499, 495, 480, 0, 0, 0, 0], false),\\n    ([1199, 1197, 0, 500, 496, 481, 868, 1175, 818, 1075], false),\\n    ([0, 0, 505, 503, 0, 485, 0, 0, 0, 0], false),\\n    ([0, 0, 504, 0, 0, 486, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 487, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 504, 0, 488, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 505, 0, 489, 870, 0, 821, 0], false),\\n    ([0, 0, 510, 508, 502, 492, 0, 0, 0, 0], false),\\n    ([0, 0, 509, 0, 503, 493, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 504, 494, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 509, 505, 495, 0, 0, 0, 0], false),\\n    ([0, 727, 724, 510, 506, 496, 871, 705, 652, 0], false),\\n    ([0, 0, 515, 513, 507, 497, 0, 0, 0, 0], false),\\n    ([0, 0, 514, 0, 508, 498, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 509, 499, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 514, 510, 500, 0, 0, 0, 0], false),\\n    ([539, 537, 0, 0, 533, 0, 517, 0, 0, 0], false),\\n    ([532, 530, 0, 0, 526, 0, 518, 0, 0, 0], false),\\n    ([525, 523, 0, 0, 519, 0, 0, 0, 0, 0], false),\\n    ([522, 520, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([521, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 521, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([524, 0, 0, 0, 520, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 521, 0, 0, 0, 0, 0], false),\\n    ([0, 524, 0, 0, 522, 0, 0, 0, 0, 0], false),\\n    ([529, 527, 0, 0, 0, 0, 519, 0, 0, 0], false),\\n    ([528, 0, 0, 0, 0, 0, 520, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 521, 0, 0, 0], false),\\n    ([0, 528, 0, 0, 0, 0, 522, 0, 0, 0], false),\\n    ([531, 0, 0, 0, 527, 0, 523, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 528, 0, 524, 0, 0, 0], false),\\n    ([0, 531, 0, 0, 529, 0, 525, 0, 0, 0], false),\\n    ([536, 534, 0, 0, 0, 0, 526, 0, 0, 0], false),\\n    ([535, 0, 0, 0, 0, 0, 527, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 528, 0, 0, 0], false),\\n    ([0, 535, 0, 0, 0, 0, 529, 0, 0, 0], false),\\n    ([538, 0, 0, 0, 534, 0, 530, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 535, 0, 531, 0, 0, 0], false),\\n    ([0, 538, 0, 0, 536, 0, 532, 0, 0, 0], false),\\n    ([547, 545, 0, 0, 541, 0, 0, 518, 0, 0], false),\\n    ([544, 542, 0, 0, 0, 0, 0, 519, 0, 0], false),\\n    ([543, 0, 0, 0, 0, 0, 0, 520, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 521, 0, 0], false),\\n    ([0, 543, 0, 0, 0, 0, 0, 522, 0, 0], false),\\n    ([546, 0, 0, 0, 542, 0, 0, 523, 0, 0], false),\\n    ([0, 0, 0, 0, 543, 0, 0, 524, 0, 0], false),\\n    ([0, 546, 0, 0, 544, 0, 0, 525, 0, 0], false),\\n    ([551, 549, 0, 0, 0, 0, 541, 526, 0, 0], false),\\n    ([550, 0, 0, 0, 0, 0, 542, 527, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 543, 528, 0, 0], false),\\n    ([0, 550, 0, 0, 0, 0, 544, 529, 0, 0], false),\\n    ([553, 0, 0, 0, 549, 0, 545, 530, 0, 0], false),\\n    ([0, 0, 0, 0, 550, 0, 546, 531, 0, 0], false),\\n    ([555, 0, 0, 0, 0, 0, 549, 534, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 550, 535, 0, 0], false),\\n    ([0, 555, 0, 0, 0, 0, 551, 536, 0, 0], false),\\n    ([558, 0, 0, 0, 554, 0, 552, 537, 0, 0], false),\\n    ([0, 0, 0, 0, 555, 0, 553, 538, 0, 0], false),\\n    ([566, 564, 0, 0, 560, 0, 0, 0, 518, 0], false),\\n    ([563, 561, 0, 0, 0, 0, 0, 0, 519, 0], false),\\n    ([562, 0, 0, 0, 0, 0, 0, 0, 520, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 521, 0], false),\\n    ([0, 562, 0, 0, 0, 0, 0, 0, 522, 0], false),\\n    ([565, 0, 0, 0, 561, 0, 0, 0, 523, 0], false),\\n    ([0, 0, 0, 0, 562, 0, 0, 0, 524, 0], false),\\n    ([0, 565, 0, 0, 563, 0, 0, 0, 525, 0], false),\\n    ([574, 572, 770, 768, 568, 737, 0, 559, 540, 0], false),\\n    ([571, 569, 767, 765, 761, 750, 0, 560, 541, 0], false),\\n    ([570, 0, 0, 0, 0, 0, 0, 561, 542, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 562, 543, 0], false),\\n    ([0, 570, 0, 0, 0, 0, 0, 563, 544, 0], false),\\n    ([573, 0, 0, 0, 569, 0, 0, 564, 545, 0], false),\\n    ([0, 0, 0, 0, 570, 0, 0, 565, 546, 0], false),\\n    ([0, 573, 0, 0, 571, 0, 0, 566, 547, 0], false),\\n    ([578, 576, 0, 0, 0, 0, 0, 0, 560, 0], false),\\n    ([577, 0, 0, 0, 0, 0, 0, 0, 561, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 562, 0], false),\\n    ([0, 577, 0, 0, 0, 0, 0, 0, 563, 0], false),\\n    ([0, 0, 0, 0, 577, 0, 0, 0, 565, 0], false),\\n    ([0, 579, 0, 0, 578, 0, 0, 0, 566, 0], false),\\n    ([584, 582, 849, 847, 843, 833, 0, 575, 568, 0], false),\\n    ([583, 0, 0, 0, 0, 0, 0, 576, 569, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 577, 570, 0], false),\\n    ([0, 583, 0, 0, 0, 0, 0, 578, 571, 0], false),\\n    ([0, 0, 0, 0, 583, 0, 0, 579, 573, 0], false),\\n    ([0, 585, 0, 0, 584, 0, 0, 580, 574, 0], false),\\n    ([0, 621, 615, 606, 588, 0, 0, 0, 0, 0], false),\\n    ([0, 604, 598, 589, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 596, 590, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 594, 591, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 592, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 593, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 595, 592, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 593, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 597, 594, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 595, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 602, 599, 590, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 600, 0, 591, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 601, 0, 592, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 593, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 603, 600, 594, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 601, 595, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 605, 602, 596, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 603, 597, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 613, 607, 0, 589, 0, 0, 0, 0, 0], false),\\n    ([0, 611, 608, 0, 590, 0, 0, 0, 0, 0], false),\\n    ([0, 609, 0, 0, 591, 0, 0, 0, 0, 0], false),\\n    ([0, 610, 0, 0, 592, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 593, 0, 0, 0, 0, 0], false),\\n    ([0, 612, 609, 0, 594, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 610, 0, 595, 0, 0, 0, 0, 0], false),\\n    ([0, 614, 611, 0, 596, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 612, 0, 597, 0, 0, 0, 0, 0], false),\\n    ([0, 619, 616, 607, 598, 0, 0, 0, 0, 0], false),\\n    ([0, 617, 0, 608, 599, 0, 0, 0, 0, 0], false),\\n    ([0, 618, 0, 609, 600, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 610, 601, 0, 0, 0, 0, 0], false),\\n    ([0, 620, 617, 611, 602, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 618, 612, 603, 0, 0, 0, 0, 0], false),\\n    ([0, 622, 619, 613, 604, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 620, 614, 605, 0, 0, 0, 0, 0], false),\\n    ([0, 630, 624, 0, 0, 0, 0, 589, 0, 0], false),\\n    ([0, 628, 625, 0, 0, 0, 0, 590, 0, 0], false),\\n    ([0, 626, 0, 0, 0, 0, 0, 591, 0, 0], false),\\n    ([0, 627, 0, 0, 0, 0, 0, 592, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 593, 0, 0], false),\\n    ([0, 629, 626, 0, 0, 0, 0, 594, 0, 0], false),\\n    ([0, 0, 627, 0, 0, 0, 0, 595, 0, 0], false),\\n    ([0, 631, 628, 0, 0, 0, 0, 596, 0, 0], false),\\n    ([0, 0, 629, 0, 0, 0, 0, 597, 0, 0], false),\\n    ([0, 636, 633, 624, 0, 0, 0, 598, 0, 0], false),\\n    ([0, 634, 0, 625, 0, 0, 0, 599, 0, 0], false),\\n    ([0, 635, 0, 626, 0, 0, 0, 600, 0, 0], false),\\n    ([0, 0, 0, 627, 0, 0, 0, 601, 0, 0], false),\\n    ([0, 637, 634, 628, 0, 0, 0, 602, 0, 0], false),\\n    ([0, 0, 635, 629, 0, 0, 0, 603, 0, 0], false),\\n    ([0, 0, 637, 631, 0, 0, 0, 605, 0, 0], false),\\n    ([0, 640, 0, 0, 625, 0, 0, 608, 0, 0], false),\\n    ([0, 641, 0, 0, 626, 0, 0, 609, 0, 0], false),\\n    ([0, 0, 0, 0, 627, 0, 0, 610, 0, 0], false),\\n    ([1119, 643, 640, 0, 628, 1109, 1098, 611, 0, 923], false),\\n    ([0, 0, 641, 0, 629, 0, 0, 612, 0, 0], false),\\n    ([1121, 645, 642, 0, 630, 1112, 1101, 613, 0, 926], false),\\n    ([0, 0, 643, 0, 631, 0, 0, 614, 0, 0], false),\\n    ([0, 647, 0, 639, 633, 0, 0, 616, 0, 0], false),\\n    ([0, 648, 0, 640, 634, 0, 0, 617, 0, 0], false),\\n    ([0, 0, 0, 641, 635, 0, 0, 618, 0, 0], false),\\n    ([1123, 650, 647, 642, 636, 1116, 1104, 619, 0, 930], false),\\n    ([0, 0, 648, 643, 637, 0, 0, 620, 0, 0], false),\\n    ([0, 0, 650, 645, 638, 0, 0, 622, 0, 0], false),\\n    ([0, 656, 653, 0, 821, 816, 797, 624, 0, 0], false),\\n    ([0, 654, 0, 0, 0, 0, 0, 625, 0, 0], false),\\n    ([0, 655, 0, 0, 0, 0, 0, 626, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 627, 0, 0], false),\\n    ([0, 657, 654, 0, 0, 0, 0, 628, 0, 0], false),\\n    ([0, 0, 655, 0, 0, 0, 0, 629, 0, 0], false),\\n    ([0, 0, 657, 0, 0, 0, 0, 631, 0, 0], false),\\n    ([0, 660, 0, 654, 0, 0, 0, 634, 0, 0], false),\\n    ([0, 0, 0, 655, 0, 0, 0, 635, 0, 0], false),\\n    ([0, 662, 659, 656, 0, 0, 0, 636, 0, 0], false),\\n    ([0, 0, 660, 657, 0, 0, 0, 637, 0, 0], false),\\n    ([0, 0, 662, 658, 0, 0, 0, 638, 0, 0], false),\\n    ([0, 665, 0, 0, 653, 0, 0, 639, 0, 0], false),\\n    ([0, 666, 0, 0, 654, 0, 0, 640, 0, 0], false),\\n    ([0, 0, 0, 0, 655, 0, 0, 641, 0, 0], false),\\n    ([1150, 668, 665, 0, 656, 1141, 1134, 642, 0, 986], false),\\n    ([0, 0, 666, 0, 657, 0, 0, 643, 0, 0], false),\\n    ([0, 0, 668, 0, 658, 0, 0, 645, 0, 0], false),\\n    ([0, 671, 0, 665, 659, 0, 0, 647, 0, 0], false),\\n    ([0, 0, 0, 666, 660, 0, 0, 648, 0, 0], false),\\n    ([0, 0, 671, 668, 662, 0, 0, 650, 0, 0], false),\\n    ([0, 0, 672, 669, 663, 0, 0, 651, 0, 0], false),\\n    ([0, 690, 684, 675, 0, 0, 0, 0, 588, 0], false),\\n    ([0, 682, 676, 0, 0, 0, 0, 0, 589, 0], false),\\n    ([0, 680, 677, 0, 0, 0, 0, 0, 590, 0], false),\\n    ([0, 678, 0, 0, 0, 0, 0, 0, 591, 0], false),\\n    ([0, 679, 0, 0, 0, 0, 0, 0, 592, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 593, 0], false),\\n    ([0, 681, 678, 0, 0, 0, 0, 0, 594, 0], false),\\n    ([0, 0, 679, 0, 0, 0, 0, 0, 595, 0], false),\\n    ([0, 683, 680, 0, 0, 0, 0, 0, 596, 0], false),\\n    ([0, 0, 681, 0, 0, 0, 0, 0, 597, 0], false),\\n    ([0, 688, 685, 676, 0, 0, 0, 0, 598, 0], false),\\n    ([0, 686, 0, 677, 0, 0, 0, 0, 599, 0], false),\\n    ([0, 687, 0, 678, 0, 0, 0, 0, 600, 0], false),\\n    ([0, 0, 0, 679, 0, 0, 0, 0, 601, 0], false),\\n    ([0, 689, 686, 680, 0, 0, 0, 0, 602, 0], false),\\n    ([0, 0, 687, 681, 0, 0, 0, 0, 603, 0], false),\\n    ([0, 691, 688, 682, 0, 0, 0, 0, 604, 0], false),\\n    ([0, 0, 689, 683, 0, 0, 0, 0, 605, 0], false),\\n    ([0, 699, 693, 0, 675, 0, 0, 0, 606, 0], false),\\n    ([0, 697, 694, 0, 676, 0, 0, 0, 607, 0], false),\\n    ([0, 695, 0, 0, 677, 0, 0, 0, 608, 0], false),\\n    ([0, 696, 0, 0, 678, 0, 0, 0, 609, 0], false),\\n    ([0, 0, 0, 0, 679, 0, 0, 0, 610, 0], false),\\n    ([0, 698, 695, 0, 680, 0, 0, 0, 611, 0], false),\\n    ([0, 0, 696, 0, 681, 0, 0, 0, 612, 0], false),\\n    ([0, 700, 697, 0, 682, 0, 0, 0, 613, 0], false),\\n    ([0, 0, 698, 0, 683, 0, 0, 0, 614, 0], false),\\n    ([0, 702, 0, 694, 685, 0, 0, 0, 616, 0], false),\\n    ([0, 703, 0, 695, 686, 0, 0, 0, 617, 0], false),\\n    ([0, 0, 0, 696, 687, 0, 0, 0, 618, 0], false),\\n    ([0, 711, 705, 0, 0, 0, 0, 675, 623, 0], false),\\n    ([0, 709, 706, 0, 0, 0, 0, 676, 624, 0], false),\\n    ([0, 707, 0, 0, 0, 0, 0, 677, 625, 0], false),\\n    ([0, 708, 0, 0, 0, 0, 0, 678, 626, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 679, 627, 0], false),\\n    ([0, 710, 707, 0, 0, 0, 0, 680, 628, 0], false),\\n    ([0, 0, 708, 0, 0, 0, 0, 681, 629, 0], false),\\n    ([0, 712, 709, 0, 0, 0, 0, 682, 630, 0], false),\\n    ([0, 0, 710, 0, 0, 0, 0, 683, 631, 0], false),\\n    ([0, 717, 714, 705, 0, 0, 0, 684, 632, 0], false),\\n    ([0, 715, 0, 706, 0, 0, 0, 685, 633, 0], false),\\n    ([0, 716, 0, 707, 0, 0, 0, 686, 634, 0], false),\\n    ([0, 0, 0, 708, 0, 0, 0, 687, 635, 0], false),\\n    ([0, 718, 715, 709, 0, 0, 0, 688, 636, 0], false),\\n    ([0, 0, 716, 710, 0, 0, 0, 689, 637, 0], false),\\n    ([0, 0, 718, 712, 0, 0, 0, 691, 638, 0], false),\\n    ([0, 721, 0, 0, 706, 0, 0, 694, 639, 0], false),\\n    ([0, 722, 0, 0, 707, 0, 0, 695, 640, 0], false),\\n    ([0, 0, 0, 0, 708, 0, 0, 696, 641, 0], false),\\n    ([0, 0, 0, 722, 716, 0, 0, 703, 648, 0], false),\\n    ([0, 725, 0, 0, 0, 0, 0, 706, 653, 0], false),\\n    ([0, 726, 0, 0, 0, 0, 0, 707, 654, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 708, 655, 0], false),\\n    ([0, 728, 725, 0, 0, 0, 0, 709, 656, 0], false),\\n    ([0, 0, 726, 0, 0, 0, 0, 710, 657, 0], false),\\n    ([0, 0, 728, 0, 0, 0, 0, 712, 658, 0], false),\\n    ([0, 0, 0, 726, 0, 0, 0, 716, 660, 0], false),\\n    ([0, 0, 730, 728, 0, 0, 0, 718, 662, 0], false),\\n    ([0, 0, 731, 729, 0, 0, 0, 719, 663, 0], false),\\n    ([0, 734, 0, 0, 724, 0, 0, 720, 664, 0], false),\\n    ([0, 735, 0, 0, 725, 0, 0, 721, 665, 0], false),\\n    ([0, 0, 0, 0, 726, 0, 0, 722, 666, 0], false),\\n    ([0, 0, 0, 735, 730, 0, 0, 723, 671, 0], false),\\n    ([0, 0, 760, 758, 750, 738, 0, 0, 0, 0], false),\\n    ([0, 0, 749, 747, 739, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 746, 744, 740, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 743, 741, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 742, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 0, 0, 742, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 745, 0, 741, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 742, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 745, 743, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 748, 0, 744, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 745, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 748, 746, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 757, 755, 751, 739, 0, 0, 0, 0], false),\\n    ([0, 0, 754, 752, 0, 740, 0, 0, 0, 0], false),\\n    ([0, 0, 753, 0, 0, 741, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 742, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 753, 0, 743, 0, 0, 0, 0], false),\\n    ([0, 0, 756, 0, 752, 744, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 753, 745, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 756, 754, 746, 0, 0, 0, 0], false),\\n    ([0, 0, 759, 0, 755, 747, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 756, 748, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 759, 757, 749, 0, 0, 0, 0], false),\\n    ([0, 0, 764, 762, 0, 751, 0, 0, 0, 0], false),\\n    ([0, 0, 763, 0, 0, 752, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 753, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 763, 0, 754, 0, 0, 0, 0], false),\\n    ([0, 0, 766, 0, 762, 755, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 763, 756, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 766, 764, 757, 0, 0, 0, 0], false),\\n    ([0, 0, 769, 0, 765, 758, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 766, 759, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 769, 767, 760, 0, 0, 0, 0], false),\\n    ([0, 0, 782, 780, 772, 0, 738, 0, 0, 0], false),\\n    ([0, 0, 779, 777, 773, 0, 739, 0, 0, 0], false),\\n    ([0, 0, 776, 774, 0, 0, 740, 0, 0, 0], false),\\n    ([0, 0, 775, 0, 0, 0, 741, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 742, 0, 0, 0], false),\\n    ([0, 0, 0, 775, 0, 0, 743, 0, 0, 0], false),\\n    ([0, 0, 778, 0, 774, 0, 744, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 775, 0, 745, 0, 0, 0], false),\\n    ([0, 0, 0, 778, 776, 0, 746, 0, 0, 0], false),\\n    ([0, 0, 781, 0, 777, 0, 747, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 778, 0, 748, 0, 0, 0], false),\\n    ([0, 0, 0, 781, 779, 0, 749, 0, 0, 0], false),\\n    ([0, 0, 786, 784, 0, 773, 751, 0, 0, 0], false),\\n    ([0, 0, 785, 0, 0, 774, 752, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 775, 753, 0, 0, 0], false),\\n    ([0, 0, 0, 785, 0, 776, 754, 0, 0, 0], false),\\n    ([0, 0, 788, 0, 784, 777, 755, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 785, 778, 756, 0, 0, 0], false),\\n    ([0, 0, 0, 788, 786, 779, 757, 0, 0, 0], false),\\n    ([1130, 1128, 791, 0, 787, 780, 758, 1086, 0, 938], false),\\n    ([1127, 1125, 0, 0, 788, 781, 759, 1087, 0, 939], false),\\n    ([1133, 1131, 0, 791, 789, 782, 760, 1094, 0, 946], false),\\n    ([0, 0, 796, 794, 0, 783, 761, 0, 0, 0], false),\\n    ([0, 0, 795, 0, 0, 784, 762, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 785, 763, 0, 0, 0], false),\\n    ([0, 0, 0, 795, 0, 786, 764, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 795, 788, 766, 0, 0, 0], false),\\n    ([0, 0, 0, 797, 796, 789, 767, 0, 0, 0], false),\\n    ([0, 0, 810, 808, 800, 0, 771, 0, 0, 0], false),\\n    ([0, 0, 807, 805, 801, 0, 772, 0, 0, 0], false),\\n    ([0, 0, 804, 802, 0, 0, 773, 0, 0, 0], false),\\n    ([0, 0, 803, 0, 0, 0, 774, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 775, 0, 0, 0], false),\\n    ([0, 0, 0, 803, 0, 0, 776, 0, 0, 0], false),\\n    ([0, 0, 806, 0, 802, 0, 777, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 803, 0, 778, 0, 0, 0], false),\\n    ([0, 0, 0, 806, 804, 0, 779, 0, 0, 0], false),\\n    ([0, 0, 809, 0, 805, 0, 780, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 806, 0, 781, 0, 0, 0], false),\\n    ([0, 0, 0, 809, 807, 0, 782, 0, 0, 0], false),\\n    ([0, 0, 814, 812, 0, 801, 783, 0, 0, 0], false),\\n    ([0, 0, 813, 0, 0, 802, 784, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 803, 785, 0, 0, 0], false),\\n    ([0, 0, 0, 813, 0, 804, 786, 0, 0, 0], false),\\n    ([0, 0, 816, 0, 812, 805, 787, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 813, 806, 788, 0, 0, 0], false),\\n    ([1146, 1144, 818, 0, 815, 808, 790, 1107, 0, 969], false),\\n    ([1143, 1141, 0, 0, 816, 809, 791, 1108, 0, 970], false),\\n    ([0, 0, 822, 820, 0, 811, 793, 0, 0, 0], false),\\n    ([0, 0, 821, 0, 0, 812, 794, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 813, 795, 0, 0, 0], false),\\n    ([0, 0, 0, 821, 0, 814, 796, 0, 0, 0], false),\\n    ([0, 0, 830, 828, 824, 0, 0, 0, 739, 0], false),\\n    ([0, 0, 827, 825, 0, 0, 0, 0, 740, 0], false),\\n    ([0, 0, 826, 0, 0, 0, 0, 0, 741, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 742, 0], false),\\n    ([0, 0, 0, 826, 0, 0, 0, 0, 743, 0], false),\\n    ([0, 0, 829, 0, 825, 0, 0, 0, 744, 0], false),\\n    ([0, 0, 0, 0, 826, 0, 0, 0, 745, 0], false),\\n    ([0, 0, 0, 829, 827, 0, 0, 0, 746, 0], false),\\n    ([0, 0, 0, 0, 829, 0, 0, 0, 748, 0], false),\\n    ([0, 0, 0, 831, 830, 0, 0, 0, 749, 0], false),\\n    ([0, 0, 840, 838, 834, 823, 0, 0, 750, 0], false),\\n    ([0, 0, 837, 835, 0, 824, 0, 0, 751, 0], false),\\n    ([0, 0, 836, 0, 0, 825, 0, 0, 752, 0], false),\\n    ([0, 0, 0, 0, 0, 826, 0, 0, 753, 0], false),\\n    ([0, 0, 0, 836, 0, 827, 0, 0, 754, 0], false),\\n    ([0, 0, 839, 0, 835, 828, 0, 0, 755, 0], false),\\n    ([0, 0, 0, 0, 836, 829, 0, 0, 756, 0], false),\\n    ([0, 0, 0, 839, 837, 830, 0, 0, 757, 0], false),\\n    ([0, 0, 0, 0, 839, 831, 0, 0, 759, 0], false),\\n    ([0, 0, 0, 841, 840, 832, 0, 0, 760, 0], false),\\n    ([0, 0, 846, 844, 0, 834, 0, 0, 761, 0], false),\\n    ([0, 0, 845, 0, 0, 835, 0, 0, 762, 0], false),\\n    ([0, 0, 0, 0, 0, 836, 0, 0, 763, 0], false),\\n    ([0, 0, 0, 845, 0, 837, 0, 0, 764, 0], false),\\n    ([0, 0, 848, 0, 844, 838, 0, 0, 765, 0], false),\\n    ([0, 0, 0, 0, 845, 839, 0, 0, 766, 0], false),\\n    ([0, 0, 0, 848, 846, 840, 0, 0, 767, 0], false),\\n    ([0, 0, 0, 0, 848, 841, 0, 0, 769, 0], false),\\n    ([0, 0, 858, 856, 852, 0, 823, 0, 772, 0], false),\\n    ([0, 0, 855, 853, 0, 0, 824, 0, 773, 0], false),\\n    ([0, 0, 854, 0, 0, 0, 825, 0, 774, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 826, 0, 775, 0], false),\\n    ([0, 0, 0, 854, 0, 0, 827, 0, 776, 0], false),\\n    ([0, 0, 857, 0, 853, 0, 828, 0, 777, 0], false),\\n    ([0, 0, 0, 0, 854, 0, 829, 0, 778, 0], false),\\n    ([0, 0, 0, 857, 855, 0, 830, 0, 779, 0], false),\\n    ([0, 0, 0, 0, 857, 0, 831, 0, 781, 0], false),\\n    ([0, 0, 0, 859, 858, 0, 832, 0, 782, 0], false),\\n    ([0, 0, 864, 862, 0, 852, 834, 0, 783, 0], false),\\n    ([0, 0, 863, 0, 0, 853, 835, 0, 784, 0], false),\\n    ([0, 0, 0, 0, 0, 854, 836, 0, 785, 0], false),\\n    ([0, 0, 0, 863, 0, 855, 837, 0, 786, 0], false),\\n    ([0, 0, 866, 0, 862, 856, 838, 0, 787, 0], false),\\n    ([0, 0, 0, 0, 863, 857, 839, 0, 788, 0], false),\\n    ([0, 0, 0, 866, 864, 858, 840, 0, 789, 0], false),\\n    ([1184, 1182, 0, 0, 866, 859, 841, 1155, 791, 1046], false),\\n    ([0, 0, 870, 0, 0, 862, 844, 0, 794, 0], false),\\n    ([0, 0, 0, 0, 0, 863, 845, 0, 795, 0], false),\\n    ([0, 0, 0, 0, 870, 866, 848, 0, 797, 0], false),\\n    ([935, 933, 929, 921, 0, 905, 873, 0, 0, 0], false),\\n    ([904, 902, 898, 890, 0, 874, 0, 0, 0, 0], false),\\n    ([889, 887, 883, 875, 0, 0, 0, 0, 0, 0], false),\\n    ([882, 880, 876, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([879, 877, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([878, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 878, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([881, 0, 877, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 878, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 881, 879, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([886, 884, 0, 876, 0, 0, 0, 0, 0, 0], false),\\n    ([885, 0, 0, 877, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 878, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 885, 0, 879, 0, 0, 0, 0, 0, 0], false),\\n    ([888, 0, 884, 880, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 885, 881, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 888, 886, 882, 0, 0, 0, 0, 0, 0], false),\\n    ([897, 895, 891, 0, 0, 875, 0, 0, 0, 0], false),\\n    ([894, 892, 0, 0, 0, 876, 0, 0, 0, 0], false),\\n    ([893, 0, 0, 0, 0, 877, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 878, 0, 0, 0, 0], false),\\n    ([0, 893, 0, 0, 0, 879, 0, 0, 0, 0], false),\\n    ([896, 0, 892, 0, 0, 880, 0, 0, 0, 0], false),\\n    ([0, 0, 893, 0, 0, 881, 0, 0, 0, 0], false),\\n    ([0, 896, 894, 0, 0, 882, 0, 0, 0, 0], false),\\n    ([901, 899, 0, 891, 0, 883, 0, 0, 0, 0], false),\\n    ([900, 0, 0, 892, 0, 884, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 893, 0, 885, 0, 0, 0, 0], false),\\n    ([0, 900, 0, 894, 0, 886, 0, 0, 0, 0], false),\\n    ([903, 0, 899, 895, 0, 887, 0, 0, 0, 0], false),\\n    ([0, 0, 900, 896, 0, 888, 0, 0, 0, 0], false),\\n    ([0, 903, 901, 897, 0, 889, 0, 0, 0, 0], false),\\n    ([920, 918, 914, 906, 0, 0, 874, 0, 0, 0], false),\\n    ([913, 911, 907, 0, 0, 0, 875, 0, 0, 0], false),\\n    ([910, 908, 0, 0, 0, 0, 876, 0, 0, 0], false),\\n    ([909, 0, 0, 0, 0, 0, 877, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 878, 0, 0, 0], false),\\n    ([0, 909, 0, 0, 0, 0, 879, 0, 0, 0], false),\\n    ([912, 0, 908, 0, 0, 0, 880, 0, 0, 0], false),\\n    ([0, 0, 909, 0, 0, 0, 881, 0, 0, 0], false),\\n    ([0, 912, 910, 0, 0, 0, 882, 0, 0, 0], false),\\n    ([917, 915, 0, 907, 0, 0, 883, 0, 0, 0], false),\\n    ([916, 0, 0, 908, 0, 0, 884, 0, 0, 0], false),\\n    ([0, 0, 0, 909, 0, 0, 885, 0, 0, 0], false),\\n    ([0, 916, 0, 910, 0, 0, 886, 0, 0, 0], false),\\n    ([919, 0, 915, 911, 0, 0, 887, 0, 0, 0], false),\\n    ([0, 0, 916, 912, 0, 0, 888, 0, 0, 0], false),\\n    ([0, 919, 917, 913, 0, 0, 889, 0, 0, 0], false),\\n    ([928, 926, 922, 0, 0, 906, 890, 0, 0, 0], false),\\n    ([925, 923, 0, 0, 0, 907, 891, 0, 0, 0], false),\\n    ([924, 0, 0, 0, 0, 908, 892, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 909, 893, 0, 0, 0], false),\\n    ([0, 924, 0, 0, 0, 910, 894, 0, 0, 0], false),\\n    ([927, 0, 923, 0, 0, 911, 895, 0, 0, 0], false),\\n    ([0, 0, 924, 0, 0, 912, 896, 0, 0, 0], false),\\n    ([0, 927, 925, 0, 0, 913, 897, 0, 0, 0], false),\\n    ([932, 930, 0, 922, 0, 914, 898, 0, 0, 0], false),\\n    ([931, 0, 0, 923, 0, 915, 899, 0, 0, 0], false),\\n    ([0, 0, 0, 924, 0, 916, 900, 0, 0, 0], false),\\n    ([0, 931, 0, 925, 0, 917, 901, 0, 0, 0], false),\\n    ([934, 0, 930, 926, 0, 918, 902, 0, 0, 0], false),\\n    ([0, 0, 931, 927, 0, 919, 903, 0, 0, 0], false),\\n    ([0, 934, 932, 928, 0, 920, 904, 0, 0, 0], false),\\n    ([967, 965, 961, 953, 0, 937, 0, 873, 0, 0], false),\\n    ([952, 950, 946, 938, 0, 0, 0, 874, 0, 0], false),\\n    ([945, 943, 939, 0, 0, 0, 0, 875, 0, 0], false),\\n    ([942, 940, 0, 0, 0, 0, 0, 876, 0, 0], false),\\n    ([941, 0, 0, 0, 0, 0, 0, 877, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 878, 0, 0], false),\\n    ([0, 941, 0, 0, 0, 0, 0, 879, 0, 0], false),\\n    ([944, 0, 940, 0, 0, 0, 0, 880, 0, 0], false),\\n    ([0, 0, 941, 0, 0, 0, 0, 881, 0, 0], false),\\n    ([0, 944, 942, 0, 0, 0, 0, 882, 0, 0], false),\\n    ([949, 947, 0, 939, 0, 0, 0, 883, 0, 0], false),\\n    ([948, 0, 0, 940, 0, 0, 0, 884, 0, 0], false),\\n    ([0, 0, 0, 941, 0, 0, 0, 885, 0, 0], false),\\n    ([0, 948, 0, 942, 0, 0, 0, 886, 0, 0], false),\\n    ([951, 0, 947, 943, 0, 0, 0, 887, 0, 0], false),\\n    ([0, 0, 948, 944, 0, 0, 0, 888, 0, 0], false),\\n    ([0, 951, 949, 945, 0, 0, 0, 889, 0, 0], false),\\n    ([960, 958, 954, 0, 0, 938, 0, 890, 0, 0], false),\\n    ([957, 955, 0, 0, 0, 939, 0, 891, 0, 0], false),\\n    ([956, 0, 0, 0, 0, 940, 0, 892, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 941, 0, 893, 0, 0], false),\\n    ([0, 956, 0, 0, 0, 942, 0, 894, 0, 0], false),\\n    ([959, 0, 955, 0, 0, 943, 0, 895, 0, 0], false),\\n    ([0, 0, 956, 0, 0, 944, 0, 896, 0, 0], false),\\n    ([0, 959, 957, 0, 0, 945, 0, 897, 0, 0], false),\\n    ([964, 962, 0, 954, 0, 946, 0, 898, 0, 0], false),\\n    ([963, 0, 0, 955, 0, 947, 0, 899, 0, 0], false),\\n    ([0, 0, 0, 956, 0, 948, 0, 900, 0, 0], false),\\n    ([0, 963, 0, 957, 0, 949, 0, 901, 0, 0], false),\\n    ([966, 0, 962, 958, 0, 950, 0, 902, 0, 0], false),\\n    ([0, 0, 963, 959, 0, 951, 0, 903, 0, 0], false),\\n    ([0, 966, 964, 960, 0, 952, 0, 904, 0, 0], false),\\n    ([983, 981, 977, 969, 0, 0, 937, 905, 0, 0], false),\\n    ([976, 974, 970, 0, 0, 0, 938, 906, 0, 0], false),\\n    ([973, 971, 0, 0, 0, 0, 939, 907, 0, 0], false),\\n    ([972, 0, 0, 0, 0, 0, 940, 908, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 941, 909, 0, 0], false),\\n    ([0, 972, 0, 0, 0, 0, 942, 910, 0, 0], false),\\n    ([975, 0, 971, 0, 0, 0, 943, 911, 0, 0], false),\\n    ([0, 0, 972, 0, 0, 0, 944, 912, 0, 0], false),\\n    ([0, 975, 973, 0, 0, 0, 945, 913, 0, 0], false),\\n    ([980, 978, 0, 970, 0, 0, 946, 914, 0, 0], false),\\n    ([979, 0, 0, 971, 0, 0, 947, 915, 0, 0], false),\\n    ([0, 0, 0, 972, 0, 0, 948, 916, 0, 0], false),\\n    ([0, 979, 0, 973, 0, 0, 949, 917, 0, 0], false),\\n    ([982, 0, 978, 974, 0, 0, 950, 918, 0, 0], false),\\n    ([0, 0, 979, 975, 0, 0, 951, 919, 0, 0], false),\\n    ([0, 982, 980, 976, 0, 0, 952, 920, 0, 0], false),\\n    ([991, 989, 985, 0, 0, 969, 953, 921, 0, 0], false),\\n    ([988, 986, 0, 0, 0, 970, 954, 922, 0, 0], false),\\n    ([987, 0, 0, 0, 0, 971, 955, 923, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 972, 956, 924, 0, 0], false),\\n    ([0, 987, 0, 0, 0, 973, 957, 925, 0, 0], false),\\n    ([990, 0, 986, 0, 0, 974, 958, 926, 0, 0], false),\\n    ([0, 0, 987, 0, 0, 975, 959, 927, 0, 0], false),\\n    ([0, 990, 988, 0, 0, 976, 960, 928, 0, 0], false),\\n    ([0, 0, 0, 987, 0, 979, 963, 931, 0, 0], false),\\n    ([0, 992, 0, 988, 0, 980, 964, 932, 0, 0], false),\\n    ([0, 0, 992, 990, 0, 982, 966, 934, 0, 0], false),\\n    ([0, 994, 993, 991, 0, 983, 967, 935, 0, 0], false),\\n    ([1027, 1025, 1021, 1013, 0, 997, 0, 0, 873, 0], false),\\n    ([1012, 1010, 1006, 998, 0, 0, 0, 0, 874, 0], false),\\n    ([1005, 1003, 999, 0, 0, 0, 0, 0, 875, 0], false),\\n    ([1002, 1000, 0, 0, 0, 0, 0, 0, 876, 0], false),\\n    ([1001, 0, 0, 0, 0, 0, 0, 0, 877, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 878, 0], false),\\n    ([0, 1001, 0, 0, 0, 0, 0, 0, 879, 0], false),\\n    ([1004, 0, 1000, 0, 0, 0, 0, 0, 880, 0], false),\\n    ([0, 0, 1001, 0, 0, 0, 0, 0, 881, 0], false),\\n    ([0, 1004, 1002, 0, 0, 0, 0, 0, 882, 0], false),\\n    ([1009, 1007, 0, 999, 0, 0, 0, 0, 883, 0], false),\\n    ([1008, 0, 0, 1000, 0, 0, 0, 0, 884, 0], false),\\n    ([0, 0, 0, 1001, 0, 0, 0, 0, 885, 0], false),\\n    ([0, 1008, 0, 1002, 0, 0, 0, 0, 886, 0], false),\\n    ([1011, 0, 1007, 1003, 0, 0, 0, 0, 887, 0], false),\\n    ([0, 0, 1008, 1004, 0, 0, 0, 0, 888, 0], false),\\n    ([0, 1011, 1009, 1005, 0, 0, 0, 0, 889, 0], false),\\n    ([1020, 1018, 1014, 0, 0, 998, 0, 0, 890, 0], false),\\n    ([1017, 1015, 0, 0, 0, 999, 0, 0, 891, 0], false),\\n    ([1016, 0, 0, 0, 0, 1000, 0, 0, 892, 0], false),\\n    ([0, 0, 0, 0, 0, 1001, 0, 0, 893, 0], false),\\n    ([0, 1016, 0, 0, 0, 1002, 0, 0, 894, 0], false),\\n    ([1019, 0, 1015, 0, 0, 1003, 0, 0, 895, 0], false),\\n    ([0, 0, 1016, 0, 0, 1004, 0, 0, 896, 0], false),\\n    ([0, 1019, 1017, 0, 0, 1005, 0, 0, 897, 0], false),\\n    ([1024, 1022, 0, 1014, 0, 1006, 0, 0, 898, 0], false),\\n    ([1023, 0, 0, 1015, 0, 1007, 0, 0, 899, 0], false),\\n    ([0, 0, 0, 1016, 0, 1008, 0, 0, 900, 0], false),\\n    ([0, 1023, 0, 1017, 0, 1009, 0, 0, 901, 0], false),\\n    ([1026, 0, 1022, 1018, 0, 1010, 0, 0, 902, 0], false),\\n    ([0, 0, 1023, 1019, 0, 1011, 0, 0, 903, 0], false),\\n    ([0, 1026, 1024, 1020, 0, 1012, 0, 0, 904, 0], false),\\n    ([1035, 1033, 1029, 0, 0, 0, 998, 0, 906, 0], false),\\n    ([1032, 1030, 0, 0, 0, 0, 999, 0, 907, 0], false),\\n    ([1031, 0, 0, 0, 0, 0, 1000, 0, 908, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 1001, 0, 909, 0], false),\\n    ([0, 1031, 0, 0, 0, 0, 1002, 0, 910, 0], false),\\n    ([1034, 0, 1030, 0, 0, 0, 1003, 0, 911, 0], false),\\n    ([0, 0, 1031, 0, 0, 0, 1004, 0, 912, 0], false),\\n    ([0, 1034, 1032, 0, 0, 0, 1005, 0, 913, 0], false),\\n    ([1043, 1041, 1037, 0, 0, 1028, 1013, 0, 921, 0], false),\\n    ([1040, 1038, 0, 0, 0, 1029, 1014, 0, 922, 0], false),\\n    ([1039, 0, 0, 0, 0, 1030, 1015, 0, 923, 0], false),\\n    ([0, 0, 0, 0, 0, 1031, 1016, 0, 924, 0], false),\\n    ([0, 1039, 0, 0, 0, 1032, 1017, 0, 925, 0], false),\\n    ([1042, 0, 1038, 0, 0, 1033, 1018, 0, 926, 0], false),\\n    ([0, 0, 1039, 0, 0, 1034, 1019, 0, 927, 0], false),\\n    ([0, 1042, 1040, 0, 0, 1035, 1020, 0, 928, 0], false),\\n    ([1059, 1057, 1053, 1045, 0, 0, 0, 997, 937, 0], false),\\n    ([1052, 1050, 1046, 0, 0, 0, 0, 998, 938, 0], false),\\n    ([1049, 1047, 0, 0, 0, 0, 0, 999, 939, 0], false),\\n    ([1048, 0, 0, 0, 0, 0, 0, 1000, 940, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 1001, 941, 0], false),\\n    ([0, 1048, 0, 0, 0, 0, 0, 1002, 942, 0], false),\\n    ([1051, 0, 1047, 0, 0, 0, 0, 1003, 943, 0], false),\\n    ([0, 0, 1048, 0, 0, 0, 0, 1004, 944, 0], false),\\n    ([0, 1051, 1049, 0, 0, 0, 0, 1005, 945, 0], false),\\n    ([1056, 1054, 0, 1046, 0, 0, 0, 1006, 946, 0], false),\\n    ([1055, 0, 0, 1047, 0, 0, 0, 1007, 947, 0], false),\\n    ([0, 0, 0, 1048, 0, 0, 0, 1008, 948, 0], false),\\n    ([0, 1055, 0, 1049, 0, 0, 0, 1009, 949, 0], false),\\n    ([1058, 0, 1054, 1050, 0, 0, 0, 1010, 950, 0], false),\\n    ([0, 0, 1055, 1051, 0, 0, 0, 1011, 951, 0], false),\\n    ([0, 1058, 1056, 1052, 0, 0, 0, 1012, 952, 0], false),\\n    ([1067, 1065, 1061, 0, 0, 1045, 0, 1013, 953, 0], false),\\n    ([1064, 1062, 0, 0, 0, 1046, 0, 1014, 954, 0], false),\\n    ([1063, 0, 0, 0, 0, 1047, 0, 1015, 955, 0], false),\\n    ([0, 0, 0, 0, 0, 1048, 0, 1016, 956, 0], false),\\n    ([0, 1063, 0, 0, 0, 1049, 0, 1017, 957, 0], false),\\n    ([1066, 0, 1062, 0, 0, 1050, 0, 1018, 958, 0], false),\\n    ([0, 0, 1063, 0, 0, 1051, 0, 1019, 959, 0], false),\\n    ([0, 1066, 1064, 0, 0, 1052, 0, 1020, 960, 0], false),\\n    ([1071, 1069, 0, 1061, 0, 1053, 0, 1021, 961, 0], false),\\n    ([1070, 0, 0, 1062, 0, 1054, 0, 1022, 962, 0], false),\\n    ([0, 0, 0, 1063, 0, 1055, 0, 1023, 963, 0], false),\\n    ([0, 1070, 0, 1064, 0, 1056, 0, 1024, 964, 0], false),\\n    ([1073, 0, 1069, 1065, 0, 1057, 0, 1025, 965, 0], false),\\n    ([0, 0, 1070, 1066, 0, 1058, 0, 1026, 966, 0], false),\\n    ([1081, 1079, 1075, 0, 0, 0, 1045, 1028, 969, 0], false),\\n    ([1078, 1076, 0, 0, 0, 0, 1046, 1029, 970, 0], false),\\n    ([1077, 0, 0, 0, 0, 0, 1047, 1030, 971, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 1048, 1031, 972, 0], false),\\n    ([0, 1077, 0, 0, 0, 0, 1049, 1032, 973, 0], false),\\n    ([1080, 0, 1076, 0, 0, 0, 1050, 1033, 974, 0], false),\\n    ([0, 0, 1077, 0, 0, 0, 1051, 1034, 975, 0], false),\\n    ([0, 1080, 1078, 0, 0, 0, 1052, 1035, 976, 0], false),\\n    ([1085, 1083, 0, 0, 0, 1075, 1061, 1037, 985, 0], false),\\n    ([1084, 0, 0, 0, 0, 1076, 1062, 1038, 986, 0], false),\\n    ([0, 0, 0, 0, 0, 1077, 1063, 1039, 987, 0], false),\\n    ([0, 1084, 0, 0, 0, 1078, 1064, 1040, 988, 0], false),\\n    ([1093, 1091, 1087, 0, 0, 0, 0, 0, 0, 875], false),\\n    ([1090, 1088, 0, 0, 0, 0, 0, 0, 0, 876], false),\\n    ([1089, 0, 0, 0, 0, 0, 0, 0, 0, 877], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 878], false),\\n    ([0, 1089, 0, 0, 0, 0, 0, 0, 0, 879], false),\\n    ([1092, 0, 1088, 0, 0, 0, 0, 0, 0, 880], false),\\n    ([0, 0, 1089, 0, 0, 0, 0, 0, 0, 881], false),\\n    ([0, 1092, 1090, 0, 0, 0, 0, 0, 0, 882], false),\\n    ([1097, 1095, 0, 1087, 0, 0, 0, 0, 0, 883], false),\\n    ([1096, 0, 0, 1088, 0, 0, 0, 0, 0, 884], false),\\n    ([0, 0, 0, 1089, 0, 0, 0, 0, 0, 885], false),\\n    ([0, 1096, 0, 1090, 0, 0, 0, 0, 0, 886], false),\\n    ([1099, 0, 0, 0, 0, 1088, 0, 0, 0, 892], false),\\n    ([0, 0, 0, 0, 0, 1089, 0, 0, 0, 893], false),\\n    ([0, 1099, 0, 0, 0, 1090, 0, 0, 0, 894], false),\\n    ([1102, 0, 1098, 0, 0, 1091, 0, 0, 0, 895], false),\\n    ([0, 0, 1099, 0, 0, 1092, 0, 0, 0, 896], false),\\n    ([0, 1102, 1100, 0, 0, 1093, 0, 0, 0, 897], false),\\n    ([1105, 0, 0, 1098, 0, 1095, 0, 0, 0, 899], false),\\n    ([0, 0, 0, 1099, 0, 1096, 0, 0, 0, 900], false),\\n    ([0, 1105, 0, 1100, 0, 1097, 0, 0, 0, 901], false),\\n    ([1114, 1112, 1108, 0, 0, 0, 1086, 0, 0, 906], false),\\n    ([1111, 1109, 0, 0, 0, 0, 1087, 0, 0, 907], false),\\n    ([1110, 0, 0, 0, 0, 0, 1088, 0, 0, 908], false),\\n    ([0, 0, 0, 0, 0, 0, 1089, 0, 0, 909], false),\\n    ([0, 1110, 0, 0, 0, 0, 1090, 0, 0, 910], false),\\n    ([1113, 0, 1109, 0, 0, 0, 1091, 0, 0, 911], false),\\n    ([0, 0, 1110, 0, 0, 0, 1092, 0, 0, 912], false),\\n    ([0, 1113, 1111, 0, 0, 0, 1093, 0, 0, 913], false),\\n    ([1118, 1116, 0, 1108, 0, 0, 1094, 0, 0, 914], false),\\n    ([1117, 0, 0, 1109, 0, 0, 1095, 0, 0, 915], false),\\n    ([0, 0, 0, 1110, 0, 0, 1096, 0, 0, 916], false),\\n    ([0, 1117, 0, 1111, 0, 0, 1097, 0, 0, 917], false),\\n    ([0, 0, 0, 0, 0, 1110, 1099, 0, 0, 924], false),\\n    ([0, 1119, 0, 0, 0, 1111, 1100, 0, 0, 925], false),\\n    ([0, 0, 1119, 0, 0, 1113, 1102, 0, 0, 927], false),\\n    ([0, 1121, 1120, 0, 0, 1114, 1103, 0, 0, 928], false),\\n    ([0, 0, 0, 1119, 0, 1117, 1105, 0, 0, 931], false),\\n    ([0, 1123, 0, 1120, 0, 1118, 1106, 0, 0, 932], false),\\n    ([1126, 0, 0, 0, 0, 0, 0, 1088, 0, 940], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 1089, 0, 941], false),\\n    ([0, 1126, 0, 0, 0, 0, 0, 1090, 0, 942], false),\\n    ([1129, 0, 1125, 0, 0, 0, 0, 1091, 0, 943], false),\\n    ([0, 0, 1126, 0, 0, 0, 0, 1092, 0, 944], false),\\n    ([0, 1129, 1127, 0, 0, 0, 0, 1093, 0, 945], false),\\n    ([1132, 0, 0, 1125, 0, 0, 0, 1095, 0, 947], false),\\n    ([0, 0, 0, 1126, 0, 0, 0, 1096, 0, 948], false),\\n    ([0, 1132, 0, 1127, 0, 0, 0, 1097, 0, 949], false),\\n    ([1135, 0, 0, 0, 0, 1125, 0, 1098, 0, 955], false),\\n    ([0, 0, 0, 0, 0, 1126, 0, 1099, 0, 956], false),\\n    ([0, 1135, 0, 0, 0, 1127, 0, 1100, 0, 957], false),\\n    ([0, 0, 1135, 0, 0, 1129, 0, 1102, 0, 959], false),\\n    ([1139, 0, 0, 1134, 0, 1131, 0, 1104, 0, 962], false),\\n    ([0, 0, 0, 1135, 0, 1132, 0, 1105, 0, 963], false),\\n    ([0, 1139, 0, 1136, 0, 1133, 0, 1106, 0, 964], false),\\n    ([1142, 0, 0, 0, 0, 0, 1125, 1109, 0, 971], false),\\n    ([0, 0, 0, 0, 0, 0, 1126, 1110, 0, 972], false),\\n    ([0, 1142, 0, 0, 0, 0, 1127, 1111, 0, 973], false),\\n    ([1145, 0, 1141, 0, 0, 0, 1128, 1112, 0, 974], false),\\n    ([0, 0, 1142, 0, 0, 0, 1129, 1113, 0, 975], false),\\n    ([0, 1145, 1143, 0, 0, 0, 1130, 1114, 0, 976], false),\\n    ([1148, 0, 0, 1141, 0, 0, 1131, 1116, 0, 978], false),\\n    ([0, 0, 0, 1142, 0, 0, 1132, 1117, 0, 979], false),\\n    ([0, 1148, 0, 1143, 0, 0, 1133, 1118, 0, 980], false),\\n    ([0, 0, 0, 0, 0, 1142, 1135, 1119, 0, 987], false),\\n    ([0, 1150, 0, 0, 0, 1143, 1136, 1120, 0, 988], false),\\n    ([0, 0, 1150, 0, 0, 1145, 1137, 1121, 0, 990], false),\\n    ([0, 0, 0, 1150, 0, 1148, 1139, 1123, 0, 992], false),\\n    ([1161, 1159, 1155, 0, 0, 0, 0, 0, 1086, 998], false),\\n    ([1158, 1156, 0, 0, 0, 0, 0, 0, 1087, 999], false),\\n    ([1157, 0, 0, 0, 0, 0, 0, 0, 1088, 1000], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 1089, 1001], false),\\n    ([0, 1157, 0, 0, 0, 0, 0, 0, 1090, 1002], false),\\n    ([1160, 0, 1156, 0, 0, 0, 0, 0, 1091, 1003], false),\\n    ([0, 0, 1157, 0, 0, 0, 0, 0, 1092, 1004], false),\\n    ([0, 1160, 1158, 0, 0, 0, 0, 0, 1093, 1005], false),\\n    ([1165, 1163, 0, 1155, 0, 0, 0, 0, 1094, 1006], false),\\n    ([1164, 0, 0, 1156, 0, 0, 0, 0, 1095, 1007], false),\\n    ([0, 0, 0, 1157, 0, 0, 0, 0, 1096, 1008], false),\\n    ([0, 1164, 0, 1158, 0, 0, 0, 0, 1097, 1009], false),\\n    ([1167, 0, 0, 0, 0, 1156, 0, 0, 1098, 1015], false),\\n    ([0, 0, 0, 0, 0, 1157, 0, 0, 1099, 1016], false),\\n    ([0, 1167, 0, 0, 0, 1158, 0, 0, 1100, 1017], false),\\n    ([1170, 0, 1166, 0, 0, 1159, 0, 0, 1101, 1018], false),\\n    ([0, 0, 1167, 0, 0, 1160, 0, 0, 1102, 1019], false),\\n    ([0, 1170, 1168, 0, 0, 1161, 0, 0, 1103, 1020], false),\\n    ([0, 0, 0, 1167, 0, 1164, 0, 0, 1105, 1023], false),\\n    ([0, 1172, 0, 1168, 0, 1165, 0, 0, 1106, 1024], false),\\n    ([1181, 1179, 1175, 0, 0, 0, 1154, 0, 1107, 1028], false),\\n    ([1178, 1176, 0, 0, 0, 0, 1155, 0, 1108, 1029], false),\\n    ([1177, 0, 0, 0, 0, 0, 1156, 0, 1109, 1030], false),\\n    ([0, 0, 0, 0, 0, 0, 1157, 0, 1110, 1031], false),\\n    ([0, 1177, 0, 0, 0, 0, 1158, 0, 1111, 1032], false),\\n    ([1180, 0, 1176, 0, 0, 0, 1159, 0, 1112, 1033], false),\\n    ([0, 0, 1177, 0, 0, 0, 1160, 0, 1113, 1034], false),\\n    ([0, 1180, 1178, 0, 0, 0, 1161, 0, 1114, 1035], false),\\n    ([1183, 0, 0, 0, 0, 0, 0, 1156, 1125, 1047], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 1157, 1126, 1048], false),\\n    ([0, 1183, 0, 0, 0, 0, 0, 1158, 1127, 1049], false),\\n    ([1186, 0, 1182, 0, 0, 0, 0, 1159, 1128, 1050], false),\\n    ([0, 0, 1183, 0, 0, 0, 0, 1160, 1129, 1051], false),\\n    ([0, 1186, 1184, 0, 0, 0, 0, 1161, 1130, 1052], false),\\n    ([1189, 0, 0, 1182, 0, 0, 0, 1163, 1131, 1054], false),\\n    ([0, 0, 0, 1183, 0, 0, 0, 1164, 1132, 1055], false),\\n    ([0, 1189, 0, 1184, 0, 0, 0, 1165, 1133, 1056], false),\\n    ([1192, 0, 0, 0, 0, 1182, 0, 1166, 1134, 1062], false),\\n    ([0, 0, 0, 0, 0, 1183, 0, 1167, 1135, 1063], false),\\n    ([0, 1192, 0, 0, 0, 1184, 0, 1168, 1136, 1064], false),\\n    ([0, 0, 1192, 0, 0, 1186, 0, 1170, 1137, 1066], false),\\n    ([0, 0, 0, 1192, 0, 1189, 0, 1172, 1139, 1070], false),\\n    ([0, 1195, 0, 1193, 0, 1190, 0, 1173, 1140, 1071], false),\\n    ([1198, 0, 0, 0, 0, 0, 1182, 1176, 1141, 1076], false),\\n    ([0, 0, 0, 0, 0, 0, 1183, 1177, 1142, 1077], false),\\n    ([0, 1198, 0, 0, 0, 0, 1184, 1178, 1143, 1078], false),\\n    ([1201, 0, 1197, 0, 0, 0, 1185, 1179, 1144, 1079], false),\\n    ([0, 0, 1198, 0, 0, 0, 1186, 1180, 1145, 1080], false),\\n    ([0, 1201, 1199, 0, 0, 0, 1187, 1181, 1146, 1081], false),\\n];\\n```\\n\\nIf you scrolled all the way here, you might as well enjoy reading the program that generates the graph:\\n\\n```\\nconst N_DIGITS: usize = 10;\\n\\nuse std::collections::HashMap;\\n\\nfn get_node_id(digits: &[usize], visited: &mut [bool], n_visited: usize) -> usize {\\n    if n_visited == 0 {\\n        usize::MAX\\n    } else {\\n        digits\\n            .iter()\\n            .zip(visited.iter())\\n            .fold(0, |id, (d, v)| if *v { id * 10 + *d } else { id })\\n    }\\n}\\n\\nfn backtrack(\\n    digits: &[usize],\\n    visited: &mut [bool],\\n    depth: usize,\\n    graph: &mut HashMap<usize, (usize, [usize; N_DIGITS], bool)>,\\n    node_number: &mut usize,\\n) {\\n    let curr_id = get_node_id(digits, visited, depth);\\n    if depth == digits.len() {\\n        graph.get_mut(&curr_id).unwrap().2 = true;\\n    } else {\\n        graph.entry(curr_id).or_insert_with(|| {\\n            let nn = *node_number;\\n            *node_number += 1;\\n            (nn, [0; N_DIGITS], false)\\n        });\\n\\n        for i in 0..digits.len() {\\n            if !visited[i] {\\n                visited[i] = true;\\n                let next_id = get_node_id(digits, visited, depth + 1);\\n                let next_node_number = graph\\n                    .entry(next_id)\\n                    .or_insert_with(|| {\\n                        let nn = *node_number;\\n                        *node_number += 1;\\n                        (nn, [0; N_DIGITS], false)\\n                    })\\n                    .0;\\n                graph.get_mut(&curr_id).unwrap().1[digits[i]] = next_node_number;\\n                backtrack(digits, visited, depth + 1, graph, node_number);\\n                visited[i] = false;\\n            }\\n        }\\n    }\\n}\\n\\nfn get_digits(mut n: i32) -> Vec<usize> {\\n    if n == 0 {\\n        vec![0]\\n    } else {\\n        let mut rez = vec![];\\n        while n > 0 {\\n            rez.push((n % 10) as usize);\\n            n /= 10;\\n        }\\n        rez.sort_unstable_by(|d1, d2| d2.cmp(d1));\\n        rez\\n    }\\n}\\n\\nfn insert(\\n    n: i32,\\n    graph: &mut HashMap<usize, (usize, [usize; N_DIGITS], bool)>,\\n    node_number: &mut usize,\\n) {\\n    let digits = get_digits(n);\\n    let mut visited = vec![false; digits.len()];\\n    backtrack(&digits, &mut visited, 0, graph, node_number);\\n}\\n\\nfn main() {\\n    let mut node_number = 0;\\n    let mut graph_map = HashMap::new();\\n    for shift in 0..30 {\\n        insert(1 << shift, &mut graph_map, &mut node_number);\\n    }\\n    let mut graph = graph_map.values().copied().collect::<Vec<_>>();\\n    graph.sort_unstable_by_key(|(node_number, _, _)| *node_number);\\n    let graph = graph\\n        .into_iter()\\n        .map(|(_, edges, leaf)| (edges, leaf))\\n        .collect::<Vec<_>>();\\n    println!(\"{:?}\", graph);\\n    println!(\"{:?}\", graph.len());\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nconst N_DIGITS: usize = 10;\\n\\nconst fn build_histogram(mut n: i32) -> [u8; N_DIGITS] {\\n    let mut rez = [0; N_DIGITS];\\n    while n > 0 {\\n        rez[(n % 10) as usize] += 1;\\n        n /= 10;\\n    }\\n    rez\\n}\\n\\nconst N_POWERS: usize = 30;\\n\\nconst fn compute_power_histograms() -> [[u8; N_DIGITS]; N_POWERS] {\\n    let mut i = 0;\\n    let mut rez = [[0; N_DIGITS]; N_POWERS];\\n    while i < N_POWERS {\\n        rez[i] = build_histogram(1 << i);\\n        i += 1;\\n    }\\n    rez\\n}\\n\\nconst POWER_HISTOGRAMS: [[u8; N_DIGITS]; N_POWERS] = compute_power_histograms();\\n\\nimpl Solution {\\n    pub fn reordered_power_of2(n: i32) -> bool {\\n        POWER_HISTOGRAMS.contains(&build_histogram(n))\\n    }\\n}\\n```\n```\\nconst N_DIGITS: usize = 10;\\n\\nimpl Solution {\\n    pub fn reordered_power_of2(mut n: i32) -> bool {\\n        let mut node = 0;\\n        while n > 0 {\\n            let digit = (n % 10) as usize;\\n            match GRAPH[node].0[digit] {\\n                0 => return false,\\n                next_node => node = next_node,\\n            }\\n            n /= 10;\\n        }\\n        GRAPH[node].1\\n    }\\n}\\n\\nconst GRAPH: [([usize; N_DIGITS], bool); 1203] = [\\n    ([31, 1, 2, 7, 3, 17, 5, 87, 4, 38], false),\\n    ([30, 139, 13, 75, 25, 20, 6, 123, 12, 54], true),\\n    ([29, 13, 162, 8, 21, 18, 16, 94, 10, 52], true),\\n    ([27, 25, 21, 73, 154, 184, 9, 261, 32, 43], true),\\n    ([37, 12, 10, 66, 32, 176, 55, 76, 164, 48], true),\\n    ([47, 6, 16, 71, 9, 14, 96, 88, 55, 39], false),\\n    ([273, 460, 153, 72, 70, 269, 457, 250, 62, 1072], true),\\n    ([136, 75, 8, 512, 73, 107, 71, 92, 66, 363], false),\\n    ([132, 128, 733, 515, 511, 501, 95, 93, 86, 1082], true),\\n    ([46, 70, 147, 68, 141, 265, 581, 246, 56, 40], true),\\n    ([36, 11, 183, 86, 33, 180, 85, 83, 174, 49], false),\\n    ([1153, 672, 670, 667, 661, 1147, 1138, 649, 0, 50], true),\\n    ([237, 673, 11, 67, 65, 233, 62, 215, 557, 51], false),\\n    ([28, 137, 163, 128, 22, 19, 153, 118, 11, 53], false),\\n    ([271, 269, 15, 104, 265, 102, 97, 238, 218, 1044], false),\\n    ([1190, 1188, 0, 868, 867, 860, 842, 1162, 792, 1053], true),\\n    ([1196, 153, 151, 95, 147, 15, 454, 91, 85, 1068], false),\\n    ([278, 20, 18, 107, 184, 105, 14, 253, 176, 303], false),\\n    ([338, 19, 187, 501, 185, 482, 15, 322, 180, 304], false),\\n    ([337, 0, 334, 1197, 0, 0, 1188, 327, 1147, 309], true),\\n    ([277, 0, 19, 1200, 274, 0, 269, 258, 233, 312], false),\\n    ([24, 22, 160, 511, 155, 185, 147, 713, 33, 0], false),\\n    ([23, 731, 161, 727, 158, 0, 150, 717, 661, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 23, 0, 0, 0, 0, 0, 0, 34, 0], false),\\n    ([26, 732, 22, 74, 159, 274, 70, 262, 65, 361], false),\\n    ([0, 0, 23, 381, 379, 275, 272, 263, 236, 362], false),\\n    ([0, 26, 24, 382, 380, 276, 46, 264, 35, 44], false),\\n    ([0, 138, 339, 131, 23, 337, 1195, 121, 1153, 319], false),\\n    ([0, 28, 340, 132, 24, 338, 1196, 122, 36, 320], false),\\n    ([0, 140, 28, 135, 26, 277, 273, 126, 237, 321], false),\\n    ([0, 30, 29, 136, 27, 278, 47, 127, 37, 45], false),\\n    ([35, 65, 33, 63, 819, 177, 56, 211, 171, 0], false),\\n    ([34, 661, 182, 652, 822, 178, 798, 632, 172, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 236, 34, 0, 0, 232, 227, 214, 556, 0], false),\\n    ([0, 1153, 0, 1151, 34, 1149, 1140, 1124, 0, 993], false),\\n    ([0, 237, 36, 407, 35, 235, 229, 217, 405, 995], false),\\n    ([45, 54, 52, 363, 43, 303, 39, 279, 48, 0], false),\\n    ([42, 1072, 1068, 1060, 40, 1044, 0, 996, 936, 0], false),\\n    ([41, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 1073, 1071, 1067, 41, 1059, 0, 1027, 967, 0], false),\\n    ([44, 361, 0, 357, 341, 0, 40, 0, 0, 0], false),\\n    ([0, 362, 0, 360, 356, 0, 41, 0, 0, 0], false),\\n    ([0, 321, 320, 366, 44, 314, 42, 302, 995, 0], false),\\n    ([0, 272, 0, 0, 0, 268, 584, 249, 227, 41], false),\\n    ([0, 273, 1196, 408, 46, 271, 586, 252, 229, 42], false),\\n    ([995, 51, 49, 984, 0, 968, 936, 872, 0, 0], false),\\n    ([993, 50, 0, 985, 0, 977, 961, 929, 0, 0], false),\\n    ([992, 0, 0, 986, 0, 978, 962, 930, 0, 0], true),\\n    ([994, 0, 50, 989, 0, 981, 965, 933, 0, 0], false),\\n    ([320, 53, 315, 1082, 0, 304, 1068, 292, 49, 0], false),\\n    ([319, 0, 316, 1083, 0, 309, 1069, 297, 50, 0], false),\\n    ([321, 0, 53, 364, 361, 312, 1072, 300, 51, 0], false),\\n    ([229, 62, 85, 60, 56, 218, 567, 77, 399, 936], false),\\n    ([227, 59, 798, 57, 793, 219, 568, 196, 548, 0], false),\\n    ([0, 58, 797, 0, 794, 787, 765, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([226, 0, 0, 58, 0, 220, 569, 197, 549, 0], false),\\n    ([406, 61, 84, 0, 57, 790, 768, 78, 400, 953], false),\\n    ([1137, 0, 1134, 0, 58, 1128, 0, 1101, 0, 958], false),\\n    ([228, 0, 1138, 61, 59, 223, 572, 200, 552, 965], false),\\n    ([0, 64, 652, 0, 820, 815, 57, 623, 0, 0], false),\\n    ([0, 658, 656, 0, 0, 0, 58, 630, 0, 0], false),\\n    ([236, 663, 661, 64, 0, 230, 59, 212, 554, 0], false),\\n    ([407, 67, 86, 0, 63, 817, 60, 81, 403, 984], false),\\n    ([1152, 669, 667, 0, 64, 1144, 61, 644, 0, 989], false),\\n    ([0, 69, 871, 0, 869, 865, 847, 0, 57, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 58, 0], false),\\n    ([272, 0, 150, 69, 146, 266, 582, 247, 59, 0], false),\\n    ([408, 72, 95, 0, 68, 104, 101, 89, 60, 1060], false),\\n    ([1194, 0, 1191, 0, 69, 1185, 0, 1169, 61, 1065], false),\\n    ([382, 74, 511, 507, 375, 491, 68, 704, 63, 357], false),\\n    ([381, 729, 727, 0, 376, 0, 69, 711, 64, 358], false),\\n    ([135, 133, 128, 0, 74, 1200, 72, 113, 67, 364], false),\\n    ([217, 215, 83, 81, 211, 203, 77, 587, 516, 872], false),\\n    ([202, 200, 80, 78, 196, 188, 559, 0, 517, 873], false),\\n    ([1103, 1101, 79, 0, 0, 1086, 0, 0, 0, 890], false),\\n    ([1100, 1098, 0, 0, 0, 1087, 0, 0, 0, 891], true),\\n    ([1106, 1104, 0, 79, 0, 1094, 0, 0, 0, 898], false),\\n    ([1122, 644, 82, 0, 623, 1107, 78, 606, 0, 921], false),\\n    ([1120, 642, 639, 0, 624, 1108, 79, 607, 0, 922], false),\\n    ([1124, 649, 646, 82, 632, 1115, 80, 615, 0, 929], false),\\n    ([1136, 1134, 0, 0, 797, 791, 769, 79, 0, 954], false),\\n    ([1140, 1138, 0, 84, 798, 792, 770, 80, 0, 961], false),\\n    ([1151, 667, 664, 0, 652, 818, 84, 82, 0, 985], false),\\n    ([127, 123, 94, 92, 261, 253, 88, 409, 76, 279], false),\\n    ([252, 250, 91, 89, 246, 238, 445, 428, 77, 996], false),\\n    ([1171, 1169, 90, 0, 0, 1154, 0, 0, 78, 1013], false),\\n    ([1168, 1166, 0, 0, 0, 1155, 0, 0, 79, 1014], false),\\n    ([1173, 451, 0, 90, 0, 1162, 446, 435, 80, 1021], false),\\n    ([117, 113, 93, 0, 704, 1174, 89, 692, 81, 1036], false),\\n    ([112, 108, 720, 0, 705, 1175, 90, 693, 82, 1037], false),\\n    ([122, 118, 330, 93, 713, 322, 91, 440, 83, 292], false),\\n    ([1193, 1191, 0, 0, 871, 868, 850, 90, 84, 1061], false),\\n    ([586, 457, 454, 101, 581, 97, 0, 445, 567, 0], false),\\n    ([0, 0, 842, 100, 833, 98, 0, 0, 737, 0], false),\\n    ([0, 0, 832, 99, 823, 0, 0, 0, 738, 0], false),\\n    ([0, 0, 831, 0, 828, 0, 0, 0, 747, 0], true),\\n    ([0, 0, 841, 0, 838, 99, 0, 0, 758, 0], false),\\n    ([0, 0, 850, 0, 847, 100, 0, 0, 768, 0], false),\\n    ([0, 0, 860, 103, 851, 0, 98, 0, 771, 0], false),\\n    ([0, 0, 859, 0, 856, 0, 99, 0, 780, 0], false),\\n    ([1187, 1185, 868, 0, 865, 103, 100, 1154, 790, 1045], false),\\n    ([0, 0, 482, 106, 461, 0, 102, 0, 799, 0], false),\\n    ([0, 0, 481, 477, 470, 0, 103, 0, 808, 0], false),\\n    (\\n        [1202, 1200, 501, 497, 491, 106, 104, 1174, 817, 1074],\\n        false,\\n    ),\\n    ([111, 109, 721, 0, 709, 1176, 1166, 697, 642, 1038], false),\\n    ([110, 0, 722, 0, 710, 0, 0, 698, 643, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 110, 0, 0, 0, 1177, 1167, 0, 1119, 1039], false),\\n    ([0, 111, 0, 0, 0, 1178, 1168, 0, 1120, 1040], false),\\n    ([116, 114, 108, 0, 711, 1179, 1169, 699, 644, 1041], false),\\n    ([115, 0, 109, 0, 712, 0, 0, 700, 645, 0], false),\\n    ([0, 0, 110, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 115, 111, 0, 0, 1180, 1170, 0, 1121, 1042], false),\\n    ([0, 116, 112, 0, 0, 1181, 1171, 0, 1122, 1043], false),\\n    ([121, 119, 331, 108, 717, 327, 451, 441, 649, 297], false),\\n    ([120, 0, 723, 109, 718, 0, 452, 442, 650, 0], false),\\n    ([0, 0, 0, 110, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 120, 332, 111, 0, 328, 1172, 0, 1123, 298], false),\\n    ([0, 121, 333, 112, 0, 329, 1173, 0, 1124, 299], false),\\n    ([126, 124, 118, 113, 262, 258, 250, 443, 215, 300], false),\\n    ([125, 0, 119, 114, 719, 0, 453, 444, 651, 0], false),\\n    ([0, 0, 120, 115, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 125, 121, 116, 263, 259, 251, 0, 216, 301], false),\\n    ([0, 126, 122, 117, 264, 260, 252, 0, 217, 302], false),\\n    ([131, 129, 734, 0, 727, 1197, 1191, 108, 667, 1083], false),\\n    ([130, 0, 735, 0, 728, 0, 0, 109, 668, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 110, 0, 0], false),\\n    ([0, 130, 0, 0, 0, 1198, 1192, 111, 1150, 1084], false),\\n    ([0, 131, 0, 0, 0, 1199, 1193, 112, 1151, 1085], false),\\n    ([134, 0, 129, 0, 729, 0, 0, 114, 669, 0], false),\\n    ([0, 0, 130, 0, 0, 0, 0, 115, 0, 0], false),\\n    ([0, 134, 131, 0, 381, 1201, 1194, 116, 1152, 365], false),\\n    ([0, 135, 132, 0, 382, 1202, 408, 117, 407, 366], false),\\n    ([138, 0, 736, 129, 731, 0, 459, 119, 672, 0], false),\\n    ([0, 0, 0, 130, 0, 0, 0, 120, 0, 0], false),\\n    ([140, 0, 137, 133, 732, 0, 460, 124, 673, 0], false),\\n    ([0, 0, 138, 134, 0, 0, 0, 125, 0, 0], false),\\n    ([0, 146, 142, 869, 0, 861, 843, 0, 793, 0], false),\\n    ([0, 145, 143, 870, 0, 864, 846, 0, 796, 0], false),\\n    ([0, 144, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 0, 144, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 145, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 150, 148, 871, 142, 867, 849, 0, 798, 0], false),\\n    ([0, 149, 0, 0, 143, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 144, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 149, 0, 145, 0, 0, 0, 0, 0], false),\\n    ([0, 152, 0, 0, 148, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 149, 0, 0, 0, 0, 0], false),\\n    (\\n        [1195, 459, 152, 1191, 150, 1188, 455, 451, 1138, 1069],\\n        false,\\n    ),\\n    ([380, 159, 155, 375, 367, 483, 141, 0, 819, 341], false),\\n    ([0, 158, 156, 506, 0, 490, 142, 0, 822, 0], false),\\n    ([0, 157, 0, 0, 0, 0, 143, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 144, 0, 0, 0], false),\\n    ([0, 0, 157, 0, 0, 0, 145, 0, 0, 0], false),\\n    ([379, 0, 158, 376, 372, 0, 146, 0, 0, 354], false),\\n    ([0, 161, 0, 724, 156, 186, 148, 714, 182, 0], false),\\n    ([0, 730, 0, 725, 157, 0, 149, 715, 659, 0], false),\\n    ([340, 163, 0, 733, 160, 187, 151, 330, 183, 315], false),\\n    ([339, 736, 0, 734, 161, 334, 152, 331, 670, 316], false),\\n    ([405, 557, 174, 403, 171, 165, 399, 516, 383, 0], false),\\n    ([0, 0, 169, 0, 166, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 167, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 168, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 0, 170, 0, 167, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 168, 0, 0, 0, 0, 0], false),\\n    ([556, 554, 172, 0, 0, 166, 548, 533, 0, 0], false),\\n    ([0, 0, 173, 0, 0, 167, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 168, 0, 0, 0, 0], false),\\n    ([0, 0, 175, 0, 172, 169, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 173, 170, 0, 0, 0, 0], false),\\n    ([235, 233, 180, 817, 177, 799, 218, 203, 165, 968], false),\\n    ([232, 230, 178, 815, 811, 800, 219, 204, 166, 0], false),\\n    ([0, 0, 179, 816, 814, 807, 789, 0, 167, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 168, 0], false),\\n    ([1149, 1147, 181, 818, 178, 810, 792, 1115, 169, 977], false),\\n    ([0, 0, 0, 0, 179, 0, 0, 0, 170, 0], false),\\n    ([0, 659, 0, 653, 0, 179, 0, 633, 173, 0], false),\\n    ([0, 670, 0, 664, 182, 181, 0, 646, 175, 0], false),\\n    ([276, 274, 185, 491, 483, 461, 265, 254, 177, 0], false),\\n    ([0, 0, 186, 496, 490, 476, 867, 0, 178, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 179, 0], false),\\n    ([336, 334, 0, 0, 186, 0, 0, 323, 181, 305], false),\\n    ([195, 193, 1094, 1086, 189, 0, 0, 0, 0, 874], false),\\n    ([192, 190, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([191, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 191, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([194, 0, 1095, 1091, 190, 0, 0, 0, 0, 887], false),\\n    ([0, 0, 1096, 1092, 191, 0, 0, 0, 0, 888], false),\\n    ([0, 194, 1097, 1093, 192, 0, 0, 0, 0, 889], false),\\n    ([199, 197, 0, 0, 0, 189, 560, 0, 526, 0], false),\\n    ([198, 0, 0, 0, 0, 190, 561, 0, 527, 0], false),\\n    ([0, 0, 0, 0, 0, 191, 562, 0, 528, 0], false),\\n    ([0, 198, 0, 0, 0, 192, 563, 0, 529, 0], false),\\n    ([201, 0, 1104, 1101, 197, 193, 564, 0, 530, 902], false),\\n    ([0, 0, 1105, 1102, 198, 194, 565, 0, 531, 903], false),\\n    ([0, 201, 1106, 1103, 199, 195, 566, 0, 532, 904], false),\\n    ([210, 208, 1115, 1107, 204, 0, 188, 0, 0, 905], false),\\n    ([207, 205, 0, 0, 0, 0, 189, 0, 0, 0], false),\\n    ([206, 0, 0, 0, 0, 0, 190, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 191, 0, 0, 0], false),\\n    ([0, 206, 0, 0, 0, 0, 192, 0, 0, 0], false),\\n    ([209, 0, 1116, 1112, 205, 0, 193, 0, 0, 918], false),\\n    ([0, 0, 1117, 1113, 206, 0, 194, 0, 0, 919], false),\\n    ([0, 209, 1118, 1114, 207, 0, 195, 0, 0, 920], false),\\n    ([214, 212, 632, 623, 0, 204, 196, 588, 533, 0], false),\\n    ([213, 638, 636, 630, 0, 205, 197, 604, 534, 0], false),\\n    ([0, 0, 0, 0, 0, 206, 198, 0, 535, 0], false),\\n    ([0, 213, 0, 0, 0, 207, 199, 0, 536, 0], false),\\n    ([216, 651, 649, 644, 212, 208, 200, 621, 537, 933], false),\\n    ([0, 0, 1123, 1121, 213, 209, 201, 0, 538, 934], false),\\n    ([0, 216, 1124, 1122, 214, 210, 202, 0, 539, 935], false),\\n    ([225, 223, 792, 790, 219, 771, 737, 188, 0, 937], false),\\n    ([222, 220, 789, 787, 783, 772, 750, 189, 0, 0], false),\\n    ([221, 0, 0, 0, 0, 0, 0, 190, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 191, 0, 0], false),\\n    ([0, 221, 0, 0, 0, 0, 0, 192, 0, 0], false),\\n    ([224, 0, 1131, 1128, 220, 0, 0, 193, 0, 950], false),\\n    ([0, 0, 1132, 1129, 221, 0, 0, 194, 0, 951], false),\\n    ([0, 224, 1133, 1130, 222, 0, 0, 195, 0, 952], false),\\n    ([0, 0, 0, 0, 0, 221, 570, 198, 550, 0], false),\\n    ([0, 226, 0, 0, 0, 222, 571, 199, 551, 0], false),\\n    ([0, 0, 1139, 1137, 226, 224, 573, 201, 553, 966], false),\\n    ([0, 228, 1140, 406, 227, 225, 574, 202, 402, 967], false),\\n    ([231, 0, 0, 0, 0, 0, 220, 205, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 221, 206, 0, 0], false),\\n    ([0, 231, 0, 0, 0, 0, 222, 207, 0, 0], false),\\n    ([234, 0, 1147, 1144, 230, 0, 223, 208, 0, 981], false),\\n    ([0, 0, 1148, 1145, 231, 0, 224, 209, 0, 982], false),\\n    ([0, 234, 1149, 1146, 232, 0, 225, 210, 0, 983], false),\\n    ([0, 0, 0, 0, 0, 231, 226, 213, 555, 0], false),\\n    ([0, 0, 1153, 1152, 236, 234, 228, 216, 558, 994], false),\\n    ([245, 243, 1162, 1154, 239, 0, 0, 0, 188, 997], false),\\n    ([242, 240, 0, 0, 0, 0, 0, 0, 189, 0], false),\\n    ([241, 0, 0, 0, 0, 0, 0, 0, 190, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 191, 0], false),\\n    ([0, 241, 0, 0, 0, 0, 0, 0, 192, 0], false),\\n    ([244, 0, 1163, 1159, 240, 0, 0, 0, 193, 1010], false),\\n    ([0, 0, 1164, 1160, 241, 0, 0, 0, 194, 1011], false),\\n    ([0, 244, 1165, 1161, 242, 0, 0, 0, 195, 1012], false),\\n    ([249, 247, 0, 0, 0, 239, 575, 0, 196, 0], false),\\n    ([248, 0, 0, 0, 0, 240, 576, 0, 197, 0], false),\\n    ([0, 0, 0, 0, 0, 241, 577, 0, 198, 0], false),\\n    ([0, 248, 0, 0, 0, 242, 578, 0, 199, 0], false),\\n    ([251, 453, 451, 1169, 247, 243, 449, 438, 200, 1025], false),\\n    ([0, 0, 1172, 1170, 248, 244, 579, 0, 201, 1026], false),\\n    ([0, 251, 1173, 1171, 249, 245, 580, 0, 202, 1027], false),\\n    ([260, 258, 322, 1174, 254, 0, 238, 0, 203, 280], false),\\n    ([257, 255, 0, 0, 0, 0, 239, 0, 204, 0], false),\\n    ([256, 0, 0, 0, 0, 0, 240, 0, 205, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 241, 0, 206, 0], false),\\n    ([0, 256, 0, 0, 0, 0, 242, 0, 207, 0], false),\\n    ([259, 0, 327, 1179, 255, 0, 243, 0, 208, 289], false),\\n    ([0, 0, 328, 1180, 256, 0, 244, 0, 209, 290], false),\\n    ([0, 259, 329, 1181, 257, 0, 245, 0, 210, 291], false),\\n    ([264, 262, 713, 704, 0, 254, 246, 674, 211, 0], false),\\n    ([263, 719, 717, 711, 0, 255, 247, 690, 212, 0], false),\\n    ([0, 0, 0, 0, 0, 256, 248, 0, 213, 0], false),\\n    ([0, 263, 0, 0, 0, 257, 249, 0, 214, 0], false),\\n    ([268, 266, 867, 865, 861, 851, 833, 239, 219, 0], false),\\n    ([267, 0, 0, 0, 0, 0, 0, 240, 220, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 241, 221, 0], false),\\n    ([0, 267, 0, 0, 0, 0, 0, 242, 222, 0], false),\\n    ([270, 0, 1188, 1185, 266, 0, 0, 243, 223, 1057], false),\\n    ([0, 0, 1189, 1186, 267, 0, 0, 244, 224, 1058], false),\\n    ([0, 270, 1190, 1187, 268, 0, 0, 245, 225, 1059], false),\\n    ([0, 0, 0, 0, 0, 267, 583, 248, 226, 0], false),\\n    ([0, 0, 1195, 1194, 272, 270, 585, 251, 228, 1073], false),\\n    ([275, 0, 0, 0, 0, 0, 266, 255, 230, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 267, 256, 231, 0], false),\\n    ([0, 275, 0, 0, 0, 0, 268, 257, 232, 0], false),\\n    ([0, 0, 337, 1201, 275, 0, 270, 259, 234, 313], false),\\n    ([0, 277, 338, 1202, 276, 0, 271, 260, 235, 314], false),\\n    ([302, 300, 292, 1036, 0, 280, 996, 0, 872, 0], false),\\n    ([291, 289, 281, 1028, 0, 0, 997, 0, 905, 0], false),\\n    ([288, 286, 282, 1029, 0, 0, 1006, 0, 914, 0], false),\\n    ([285, 283, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([284, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 284, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([287, 0, 283, 1030, 0, 0, 1007, 0, 915, 0], false),\\n    ([0, 0, 284, 1031, 0, 0, 1008, 0, 916, 0], false),\\n    ([0, 287, 285, 1032, 0, 0, 1009, 0, 917, 0], false),\\n    ([290, 0, 286, 1033, 0, 0, 1010, 0, 918, 0], false),\\n    ([0, 0, 287, 1034, 0, 0, 1011, 0, 919, 0], false),\\n    ([0, 290, 288, 1035, 0, 0, 1012, 0, 920, 0], false),\\n    ([299, 297, 293, 1037, 0, 281, 1021, 0, 929, 0], false),\\n    ([296, 294, 0, 0, 0, 282, 0, 0, 0, 0], false),\\n    ([295, 0, 0, 0, 0, 283, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 284, 0, 0, 0, 0], false),\\n    ([0, 295, 0, 0, 0, 285, 0, 0, 0, 0], false),\\n    ([298, 0, 294, 1038, 0, 286, 1022, 0, 930, 0], false),\\n    ([0, 0, 295, 1039, 0, 287, 1023, 0, 931, 0], false),\\n    ([0, 298, 296, 1040, 0, 288, 1024, 0, 932, 0], false),\\n    ([301, 0, 297, 1041, 0, 289, 1025, 0, 933, 0], false),\\n    ([0, 0, 298, 1042, 0, 290, 1026, 0, 934, 0], false),\\n    ([0, 301, 299, 1043, 0, 291, 1027, 0, 935, 0], false),\\n    ([314, 312, 304, 1074, 0, 0, 1044, 280, 968, 0], false),\\n    ([311, 309, 305, 1075, 0, 0, 1053, 281, 977, 0], false),\\n    ([308, 306, 0, 0, 0, 0, 0, 282, 0, 0], false),\\n    ([307, 0, 0, 0, 0, 0, 0, 283, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 284, 0, 0], false),\\n    ([0, 307, 0, 0, 0, 0, 0, 285, 0, 0], false),\\n    ([310, 0, 306, 1076, 0, 0, 1054, 286, 978, 0], false),\\n    ([0, 0, 307, 1077, 0, 0, 1055, 287, 979, 0], false),\\n    ([0, 310, 308, 1078, 0, 0, 1056, 288, 980, 0], false),\\n    ([313, 0, 309, 1079, 0, 0, 1057, 289, 981, 0], false),\\n    ([0, 0, 310, 1080, 0, 0, 1058, 290, 982, 0], false),\\n    ([0, 313, 311, 1081, 0, 0, 1059, 291, 983, 0], false),\\n    ([318, 316, 0, 0, 0, 305, 0, 293, 0, 0], false),\\n    ([317, 0, 0, 0, 0, 306, 0, 294, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 307, 0, 295, 0, 0], false),\\n    ([0, 317, 0, 0, 0, 308, 0, 296, 0, 0], false),\\n    ([0, 0, 317, 1084, 0, 310, 1070, 298, 992, 0], false),\\n    ([0, 319, 318, 1085, 0, 311, 1071, 299, 993, 0], false),\\n    ([0, 0, 319, 365, 362, 313, 1073, 301, 994, 0], false),\\n    ([329, 327, 323, 1175, 0, 0, 1162, 0, 1115, 281], false),\\n    ([326, 324, 0, 0, 0, 0, 0, 0, 0, 282], false),\\n    ([325, 0, 0, 0, 0, 0, 0, 0, 0, 283], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 284], false),\\n    ([0, 325, 0, 0, 0, 0, 0, 0, 0, 285], false),\\n    ([328, 0, 324, 1176, 0, 0, 1163, 0, 1116, 286], false),\\n    ([0, 0, 325, 1177, 0, 0, 1164, 0, 1117, 287], false),\\n    ([0, 328, 326, 1178, 0, 0, 1165, 0, 1118, 288], false),\\n    ([333, 331, 0, 720, 714, 323, 0, 701, 646, 293], false),\\n    ([332, 723, 0, 721, 715, 324, 0, 702, 647, 294], false),\\n    ([0, 0, 0, 0, 0, 325, 0, 0, 0, 295], false),\\n    ([0, 332, 0, 0, 0, 326, 0, 0, 0, 296], false),\\n    ([335, 0, 0, 0, 0, 0, 0, 324, 0, 306], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 325, 0, 307], false),\\n    ([0, 335, 0, 0, 0, 0, 0, 326, 0, 308], false),\\n    ([0, 0, 335, 1198, 0, 0, 1189, 328, 1148, 310], false),\\n    ([0, 337, 336, 1199, 0, 0, 1190, 329, 1149, 311], false),\\n    ([0, 0, 0, 0, 0, 335, 0, 332, 0, 317], false),\\n    ([0, 339, 0, 0, 0, 336, 0, 333, 0, 318], false),\\n    ([356, 354, 0, 350, 342, 0, 0, 0, 0, 0], false),\\n    ([349, 347, 0, 343, 0, 0, 0, 0, 0, 0], false),\\n    ([346, 344, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([345, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 345, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([348, 0, 0, 344, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 345, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 348, 0, 346, 0, 0, 0, 0, 0, 0], false),\\n    ([353, 351, 0, 0, 343, 0, 0, 0, 0, 0], false),\\n    ([352, 0, 0, 0, 344, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 345, 0, 0, 0, 0, 0], false),\\n    ([0, 352, 0, 0, 346, 0, 0, 0, 0, 0], false),\\n    ([355, 0, 0, 351, 347, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 352, 348, 0, 0, 0, 0, 0], false),\\n    ([0, 355, 0, 353, 349, 0, 0, 0, 0, 0], false),\\n    ([360, 358, 0, 0, 350, 0, 0, 0, 0, 0], false),\\n    ([359, 0, 0, 0, 351, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 352, 0, 0, 0, 0, 0], false),\\n    ([0, 359, 0, 0, 353, 0, 0, 0, 0, 0], false),\\n    ([362, 0, 0, 358, 354, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 359, 355, 0, 0, 0, 0, 0], false),\\n    ([366, 364, 1082, 0, 357, 1074, 1060, 1036, 984, 0], false),\\n    ([365, 0, 1083, 0, 358, 1079, 1065, 1041, 989, 0], false),\\n    ([0, 0, 1084, 0, 359, 1080, 1066, 1042, 990, 0], false),\\n    ([0, 365, 1085, 0, 360, 1081, 1067, 1043, 991, 0], false),\\n    ([374, 372, 0, 368, 0, 0, 0, 0, 0, 342], false),\\n    ([371, 369, 0, 0, 0, 0, 0, 0, 0, 343], false),\\n    ([370, 0, 0, 0, 0, 0, 0, 0, 0, 344], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 345], false),\\n    ([0, 370, 0, 0, 0, 0, 0, 0, 0, 346], false),\\n    ([373, 0, 0, 369, 0, 0, 0, 0, 0, 347], false),\\n    ([0, 0, 0, 370, 0, 0, 0, 0, 0, 348], false),\\n    ([0, 373, 0, 371, 0, 0, 0, 0, 0, 349], false),\\n    ([378, 376, 506, 502, 368, 484, 869, 0, 820, 350], false),\\n    ([377, 0, 0, 0, 369, 0, 0, 0, 0, 351], false),\\n    ([0, 0, 0, 0, 370, 0, 0, 0, 0, 352], false),\\n    ([0, 377, 0, 0, 371, 0, 0, 0, 0, 353], false),\\n    ([0, 0, 0, 377, 373, 0, 0, 0, 0, 355], false),\\n    ([0, 379, 0, 378, 374, 0, 0, 0, 0, 356], false),\\n    ([0, 0, 0, 0, 377, 0, 0, 0, 0, 359], false),\\n    ([0, 381, 0, 0, 378, 0, 0, 0, 0, 360], false),\\n    ([398, 0, 0, 396, 0, 0, 392, 0, 384, 0], false),\\n    ([391, 0, 0, 389, 0, 0, 385, 0, 0, 0], false),\\n    ([388, 0, 0, 386, 0, 0, 0, 0, 0, 0], false),\\n    ([387, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 0, 0, 387, 0, 0, 0, 0, 0, 0], false),\\n    ([390, 0, 0, 0, 0, 0, 386, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 387, 0, 0, 0], false),\\n    ([0, 0, 0, 390, 0, 0, 388, 0, 0, 0], false),\\n    ([395, 0, 0, 393, 0, 0, 0, 0, 385, 0], false),\\n    ([394, 0, 0, 0, 0, 0, 0, 0, 386, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 387, 0], false),\\n    ([0, 0, 0, 394, 0, 0, 0, 0, 388, 0], false),\\n    ([397, 0, 0, 0, 0, 0, 393, 0, 389, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 394, 0, 390, 0], false),\\n    ([0, 0, 0, 397, 0, 0, 395, 0, 391, 0], false),\\n    ([402, 552, 0, 400, 548, 0, 540, 517, 392, 0], false),\\n    ([401, 0, 0, 0, 0, 0, 0, 0, 393, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 394, 0], false),\\n    ([0, 553, 0, 401, 551, 0, 547, 532, 395, 0], false),\\n    ([404, 0, 0, 0, 0, 0, 400, 0, 396, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 401, 0, 397, 0], false),\\n    ([0, 558, 0, 404, 556, 0, 402, 539, 398, 0], false),\\n    ([0, 1137, 1136, 0, 0, 1130, 0, 1103, 401, 960], false),\\n    ([0, 1152, 1151, 0, 0, 1146, 406, 1122, 404, 991], false),\\n    ([0, 1194, 1193, 0, 0, 1187, 0, 1171, 406, 1067], false),\\n    ([0, 443, 440, 692, 674, 0, 428, 410, 587, 0], false),\\n    ([0, 426, 423, 0, 0, 0, 411, 0, 0, 0], false),\\n    ([0, 421, 418, 0, 0, 0, 412, 0, 0, 0], false),\\n    ([0, 416, 413, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 414, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 415, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 417, 414, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 415, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 419, 0, 0, 0, 0, 413, 0, 0, 0], false),\\n    ([0, 420, 0, 0, 0, 0, 414, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 415, 0, 0, 0], false),\\n    ([0, 422, 419, 0, 0, 0, 416, 0, 0, 0], false),\\n    ([0, 0, 420, 0, 0, 0, 417, 0, 0, 0], false),\\n    ([0, 424, 0, 0, 0, 0, 418, 0, 0, 0], false),\\n    ([0, 425, 0, 0, 0, 0, 419, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 420, 0, 0, 0], false),\\n    ([0, 427, 424, 0, 0, 0, 421, 0, 0, 0], false),\\n    ([0, 0, 425, 0, 0, 0, 422, 0, 0, 0], false),\\n    ([0, 438, 435, 0, 0, 0, 429, 411, 0, 0], false),\\n    ([0, 433, 430, 0, 0, 0, 0, 412, 0, 0], false),\\n    ([0, 431, 0, 0, 0, 0, 0, 413, 0, 0], false),\\n    ([0, 432, 0, 0, 0, 0, 0, 414, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 415, 0, 0], false),\\n    ([0, 434, 431, 0, 0, 0, 0, 416, 0, 0], false),\\n    ([0, 0, 432, 0, 0, 0, 0, 417, 0, 0], false),\\n    ([0, 436, 0, 0, 0, 0, 430, 418, 0, 0], false),\\n    ([0, 437, 0, 0, 0, 0, 431, 419, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 432, 420, 0, 0], false),\\n    ([0, 439, 436, 0, 0, 0, 433, 421, 0, 0], false),\\n    ([0, 0, 437, 0, 0, 0, 434, 422, 0, 0], false),\\n    ([0, 441, 701, 693, 684, 0, 435, 423, 615, 0], false),\\n    ([0, 442, 702, 697, 688, 0, 436, 424, 619, 0], false),\\n    ([0, 0, 703, 698, 689, 0, 437, 425, 620, 0], false),\\n    ([0, 444, 441, 699, 690, 0, 438, 426, 621, 0], false),\\n    ([0, 0, 442, 700, 691, 0, 439, 427, 622, 0], false),\\n    ([580, 449, 446, 0, 575, 0, 0, 429, 559, 0], false),\\n    ([0, 447, 0, 0, 0, 0, 0, 430, 0, 0], false),\\n    ([0, 448, 0, 0, 0, 0, 0, 431, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 432, 0, 0], false),\\n    ([579, 450, 447, 0, 576, 0, 0, 433, 564, 0], false),\\n    ([0, 0, 448, 0, 0, 0, 0, 434, 0, 0], false),\\n    ([1172, 452, 0, 1166, 0, 1163, 447, 436, 1104, 1022], false),\\n    ([0, 0, 0, 0, 0, 0, 448, 437, 0, 0], false),\\n    ([0, 0, 452, 0, 0, 0, 450, 439, 0, 0], false),\\n    ([0, 455, 0, 850, 849, 842, 0, 446, 770, 0], false),\\n    ([0, 456, 0, 0, 0, 0, 0, 447, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 448, 0, 0], false),\\n    ([585, 458, 455, 0, 582, 0, 0, 449, 572, 0], false),\\n    ([0, 0, 456, 0, 0, 0, 0, 450, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 456, 452, 0, 0], false),\\n    ([0, 0, 459, 0, 0, 0, 458, 453, 0, 0], false),\\n    ([0, 0, 476, 470, 462, 0, 851, 0, 800, 0], false),\\n    ([0, 0, 469, 463, 0, 0, 852, 0, 801, 0], false),\\n    ([0, 0, 468, 464, 0, 0, 853, 0, 802, 0], false),\\n    ([0, 0, 467, 465, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 466, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 0, 0, 466, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 467, 0, 0, 854, 0, 803, 0], false),\\n    ([0, 0, 0, 468, 0, 0, 855, 0, 804, 0], false),\\n    ([0, 0, 475, 471, 463, 0, 856, 0, 805, 0], false),\\n    ([0, 0, 474, 472, 464, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 473, 0, 465, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 466, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 473, 467, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 474, 468, 0, 857, 0, 806, 0], false),\\n    ([0, 0, 0, 475, 469, 0, 858, 0, 807, 0], false),\\n    ([0, 0, 480, 478, 471, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 479, 0, 472, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 473, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 479, 474, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 480, 475, 0, 859, 0, 809, 0], false),\\n    ([0, 0, 0, 481, 476, 0, 860, 0, 810, 0], false),\\n    ([0, 0, 490, 484, 0, 462, 861, 0, 811, 0], false),\\n    ([0, 0, 489, 485, 0, 463, 862, 0, 812, 0], false),\\n    ([0, 0, 488, 486, 0, 464, 0, 0, 0, 0], false),\\n    ([0, 0, 487, 0, 0, 465, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 466, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 487, 0, 467, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 488, 0, 468, 863, 0, 813, 0], false),\\n    ([0, 0, 0, 489, 0, 469, 864, 0, 814, 0], false),\\n    ([0, 0, 496, 492, 484, 470, 865, 0, 815, 0], false),\\n    ([0, 0, 495, 493, 485, 471, 0, 0, 0, 0], false),\\n    ([0, 0, 494, 0, 486, 472, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 487, 473, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 494, 488, 474, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 495, 489, 475, 866, 0, 816, 0], false),\\n    ([0, 0, 500, 498, 492, 477, 0, 0, 0, 0], false),\\n    ([0, 0, 499, 0, 493, 478, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 494, 479, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 499, 495, 480, 0, 0, 0, 0], false),\\n    ([1199, 1197, 0, 500, 496, 481, 868, 1175, 818, 1075], false),\\n    ([0, 0, 505, 503, 0, 485, 0, 0, 0, 0], false),\\n    ([0, 0, 504, 0, 0, 486, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 487, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 504, 0, 488, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 505, 0, 489, 870, 0, 821, 0], false),\\n    ([0, 0, 510, 508, 502, 492, 0, 0, 0, 0], false),\\n    ([0, 0, 509, 0, 503, 493, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 504, 494, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 509, 505, 495, 0, 0, 0, 0], false),\\n    ([0, 727, 724, 510, 506, 496, 871, 705, 652, 0], false),\\n    ([0, 0, 515, 513, 507, 497, 0, 0, 0, 0], false),\\n    ([0, 0, 514, 0, 508, 498, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 509, 499, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 514, 510, 500, 0, 0, 0, 0], false),\\n    ([539, 537, 0, 0, 533, 0, 517, 0, 0, 0], false),\\n    ([532, 530, 0, 0, 526, 0, 518, 0, 0, 0], false),\\n    ([525, 523, 0, 0, 519, 0, 0, 0, 0, 0], false),\\n    ([522, 520, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([521, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 521, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([524, 0, 0, 0, 520, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 521, 0, 0, 0, 0, 0], false),\\n    ([0, 524, 0, 0, 522, 0, 0, 0, 0, 0], false),\\n    ([529, 527, 0, 0, 0, 0, 519, 0, 0, 0], false),\\n    ([528, 0, 0, 0, 0, 0, 520, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 521, 0, 0, 0], false),\\n    ([0, 528, 0, 0, 0, 0, 522, 0, 0, 0], false),\\n    ([531, 0, 0, 0, 527, 0, 523, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 528, 0, 524, 0, 0, 0], false),\\n    ([0, 531, 0, 0, 529, 0, 525, 0, 0, 0], false),\\n    ([536, 534, 0, 0, 0, 0, 526, 0, 0, 0], false),\\n    ([535, 0, 0, 0, 0, 0, 527, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 528, 0, 0, 0], false),\\n    ([0, 535, 0, 0, 0, 0, 529, 0, 0, 0], false),\\n    ([538, 0, 0, 0, 534, 0, 530, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 535, 0, 531, 0, 0, 0], false),\\n    ([0, 538, 0, 0, 536, 0, 532, 0, 0, 0], false),\\n    ([547, 545, 0, 0, 541, 0, 0, 518, 0, 0], false),\\n    ([544, 542, 0, 0, 0, 0, 0, 519, 0, 0], false),\\n    ([543, 0, 0, 0, 0, 0, 0, 520, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 521, 0, 0], false),\\n    ([0, 543, 0, 0, 0, 0, 0, 522, 0, 0], false),\\n    ([546, 0, 0, 0, 542, 0, 0, 523, 0, 0], false),\\n    ([0, 0, 0, 0, 543, 0, 0, 524, 0, 0], false),\\n    ([0, 546, 0, 0, 544, 0, 0, 525, 0, 0], false),\\n    ([551, 549, 0, 0, 0, 0, 541, 526, 0, 0], false),\\n    ([550, 0, 0, 0, 0, 0, 542, 527, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 543, 528, 0, 0], false),\\n    ([0, 550, 0, 0, 0, 0, 544, 529, 0, 0], false),\\n    ([553, 0, 0, 0, 549, 0, 545, 530, 0, 0], false),\\n    ([0, 0, 0, 0, 550, 0, 546, 531, 0, 0], false),\\n    ([555, 0, 0, 0, 0, 0, 549, 534, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 550, 535, 0, 0], false),\\n    ([0, 555, 0, 0, 0, 0, 551, 536, 0, 0], false),\\n    ([558, 0, 0, 0, 554, 0, 552, 537, 0, 0], false),\\n    ([0, 0, 0, 0, 555, 0, 553, 538, 0, 0], false),\\n    ([566, 564, 0, 0, 560, 0, 0, 0, 518, 0], false),\\n    ([563, 561, 0, 0, 0, 0, 0, 0, 519, 0], false),\\n    ([562, 0, 0, 0, 0, 0, 0, 0, 520, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 521, 0], false),\\n    ([0, 562, 0, 0, 0, 0, 0, 0, 522, 0], false),\\n    ([565, 0, 0, 0, 561, 0, 0, 0, 523, 0], false),\\n    ([0, 0, 0, 0, 562, 0, 0, 0, 524, 0], false),\\n    ([0, 565, 0, 0, 563, 0, 0, 0, 525, 0], false),\\n    ([574, 572, 770, 768, 568, 737, 0, 559, 540, 0], false),\\n    ([571, 569, 767, 765, 761, 750, 0, 560, 541, 0], false),\\n    ([570, 0, 0, 0, 0, 0, 0, 561, 542, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 562, 543, 0], false),\\n    ([0, 570, 0, 0, 0, 0, 0, 563, 544, 0], false),\\n    ([573, 0, 0, 0, 569, 0, 0, 564, 545, 0], false),\\n    ([0, 0, 0, 0, 570, 0, 0, 565, 546, 0], false),\\n    ([0, 573, 0, 0, 571, 0, 0, 566, 547, 0], false),\\n    ([578, 576, 0, 0, 0, 0, 0, 0, 560, 0], false),\\n    ([577, 0, 0, 0, 0, 0, 0, 0, 561, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 562, 0], false),\\n    ([0, 577, 0, 0, 0, 0, 0, 0, 563, 0], false),\\n    ([0, 0, 0, 0, 577, 0, 0, 0, 565, 0], false),\\n    ([0, 579, 0, 0, 578, 0, 0, 0, 566, 0], false),\\n    ([584, 582, 849, 847, 843, 833, 0, 575, 568, 0], false),\\n    ([583, 0, 0, 0, 0, 0, 0, 576, 569, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 577, 570, 0], false),\\n    ([0, 583, 0, 0, 0, 0, 0, 578, 571, 0], false),\\n    ([0, 0, 0, 0, 583, 0, 0, 579, 573, 0], false),\\n    ([0, 585, 0, 0, 584, 0, 0, 580, 574, 0], false),\\n    ([0, 621, 615, 606, 588, 0, 0, 0, 0, 0], false),\\n    ([0, 604, 598, 589, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 596, 590, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 594, 591, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 592, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 593, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 595, 592, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 593, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 597, 594, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 595, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 602, 599, 590, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 600, 0, 591, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 601, 0, 592, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 593, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 603, 600, 594, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 601, 595, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 605, 602, 596, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 603, 597, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 613, 607, 0, 589, 0, 0, 0, 0, 0], false),\\n    ([0, 611, 608, 0, 590, 0, 0, 0, 0, 0], false),\\n    ([0, 609, 0, 0, 591, 0, 0, 0, 0, 0], false),\\n    ([0, 610, 0, 0, 592, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 593, 0, 0, 0, 0, 0], false),\\n    ([0, 612, 609, 0, 594, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 610, 0, 595, 0, 0, 0, 0, 0], false),\\n    ([0, 614, 611, 0, 596, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 612, 0, 597, 0, 0, 0, 0, 0], false),\\n    ([0, 619, 616, 607, 598, 0, 0, 0, 0, 0], false),\\n    ([0, 617, 0, 608, 599, 0, 0, 0, 0, 0], false),\\n    ([0, 618, 0, 609, 600, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 610, 601, 0, 0, 0, 0, 0], false),\\n    ([0, 620, 617, 611, 602, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 618, 612, 603, 0, 0, 0, 0, 0], false),\\n    ([0, 622, 619, 613, 604, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 620, 614, 605, 0, 0, 0, 0, 0], false),\\n    ([0, 630, 624, 0, 0, 0, 0, 589, 0, 0], false),\\n    ([0, 628, 625, 0, 0, 0, 0, 590, 0, 0], false),\\n    ([0, 626, 0, 0, 0, 0, 0, 591, 0, 0], false),\\n    ([0, 627, 0, 0, 0, 0, 0, 592, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 593, 0, 0], false),\\n    ([0, 629, 626, 0, 0, 0, 0, 594, 0, 0], false),\\n    ([0, 0, 627, 0, 0, 0, 0, 595, 0, 0], false),\\n    ([0, 631, 628, 0, 0, 0, 0, 596, 0, 0], false),\\n    ([0, 0, 629, 0, 0, 0, 0, 597, 0, 0], false),\\n    ([0, 636, 633, 624, 0, 0, 0, 598, 0, 0], false),\\n    ([0, 634, 0, 625, 0, 0, 0, 599, 0, 0], false),\\n    ([0, 635, 0, 626, 0, 0, 0, 600, 0, 0], false),\\n    ([0, 0, 0, 627, 0, 0, 0, 601, 0, 0], false),\\n    ([0, 637, 634, 628, 0, 0, 0, 602, 0, 0], false),\\n    ([0, 0, 635, 629, 0, 0, 0, 603, 0, 0], false),\\n    ([0, 0, 637, 631, 0, 0, 0, 605, 0, 0], false),\\n    ([0, 640, 0, 0, 625, 0, 0, 608, 0, 0], false),\\n    ([0, 641, 0, 0, 626, 0, 0, 609, 0, 0], false),\\n    ([0, 0, 0, 0, 627, 0, 0, 610, 0, 0], false),\\n    ([1119, 643, 640, 0, 628, 1109, 1098, 611, 0, 923], false),\\n    ([0, 0, 641, 0, 629, 0, 0, 612, 0, 0], false),\\n    ([1121, 645, 642, 0, 630, 1112, 1101, 613, 0, 926], false),\\n    ([0, 0, 643, 0, 631, 0, 0, 614, 0, 0], false),\\n    ([0, 647, 0, 639, 633, 0, 0, 616, 0, 0], false),\\n    ([0, 648, 0, 640, 634, 0, 0, 617, 0, 0], false),\\n    ([0, 0, 0, 641, 635, 0, 0, 618, 0, 0], false),\\n    ([1123, 650, 647, 642, 636, 1116, 1104, 619, 0, 930], false),\\n    ([0, 0, 648, 643, 637, 0, 0, 620, 0, 0], false),\\n    ([0, 0, 650, 645, 638, 0, 0, 622, 0, 0], false),\\n    ([0, 656, 653, 0, 821, 816, 797, 624, 0, 0], false),\\n    ([0, 654, 0, 0, 0, 0, 0, 625, 0, 0], false),\\n    ([0, 655, 0, 0, 0, 0, 0, 626, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 627, 0, 0], false),\\n    ([0, 657, 654, 0, 0, 0, 0, 628, 0, 0], false),\\n    ([0, 0, 655, 0, 0, 0, 0, 629, 0, 0], false),\\n    ([0, 0, 657, 0, 0, 0, 0, 631, 0, 0], false),\\n    ([0, 660, 0, 654, 0, 0, 0, 634, 0, 0], false),\\n    ([0, 0, 0, 655, 0, 0, 0, 635, 0, 0], false),\\n    ([0, 662, 659, 656, 0, 0, 0, 636, 0, 0], false),\\n    ([0, 0, 660, 657, 0, 0, 0, 637, 0, 0], false),\\n    ([0, 0, 662, 658, 0, 0, 0, 638, 0, 0], false),\\n    ([0, 665, 0, 0, 653, 0, 0, 639, 0, 0], false),\\n    ([0, 666, 0, 0, 654, 0, 0, 640, 0, 0], false),\\n    ([0, 0, 0, 0, 655, 0, 0, 641, 0, 0], false),\\n    ([1150, 668, 665, 0, 656, 1141, 1134, 642, 0, 986], false),\\n    ([0, 0, 666, 0, 657, 0, 0, 643, 0, 0], false),\\n    ([0, 0, 668, 0, 658, 0, 0, 645, 0, 0], false),\\n    ([0, 671, 0, 665, 659, 0, 0, 647, 0, 0], false),\\n    ([0, 0, 0, 666, 660, 0, 0, 648, 0, 0], false),\\n    ([0, 0, 671, 668, 662, 0, 0, 650, 0, 0], false),\\n    ([0, 0, 672, 669, 663, 0, 0, 651, 0, 0], false),\\n    ([0, 690, 684, 675, 0, 0, 0, 0, 588, 0], false),\\n    ([0, 682, 676, 0, 0, 0, 0, 0, 589, 0], false),\\n    ([0, 680, 677, 0, 0, 0, 0, 0, 590, 0], false),\\n    ([0, 678, 0, 0, 0, 0, 0, 0, 591, 0], false),\\n    ([0, 679, 0, 0, 0, 0, 0, 0, 592, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 593, 0], false),\\n    ([0, 681, 678, 0, 0, 0, 0, 0, 594, 0], false),\\n    ([0, 0, 679, 0, 0, 0, 0, 0, 595, 0], false),\\n    ([0, 683, 680, 0, 0, 0, 0, 0, 596, 0], false),\\n    ([0, 0, 681, 0, 0, 0, 0, 0, 597, 0], false),\\n    ([0, 688, 685, 676, 0, 0, 0, 0, 598, 0], false),\\n    ([0, 686, 0, 677, 0, 0, 0, 0, 599, 0], false),\\n    ([0, 687, 0, 678, 0, 0, 0, 0, 600, 0], false),\\n    ([0, 0, 0, 679, 0, 0, 0, 0, 601, 0], false),\\n    ([0, 689, 686, 680, 0, 0, 0, 0, 602, 0], false),\\n    ([0, 0, 687, 681, 0, 0, 0, 0, 603, 0], false),\\n    ([0, 691, 688, 682, 0, 0, 0, 0, 604, 0], false),\\n    ([0, 0, 689, 683, 0, 0, 0, 0, 605, 0], false),\\n    ([0, 699, 693, 0, 675, 0, 0, 0, 606, 0], false),\\n    ([0, 697, 694, 0, 676, 0, 0, 0, 607, 0], false),\\n    ([0, 695, 0, 0, 677, 0, 0, 0, 608, 0], false),\\n    ([0, 696, 0, 0, 678, 0, 0, 0, 609, 0], false),\\n    ([0, 0, 0, 0, 679, 0, 0, 0, 610, 0], false),\\n    ([0, 698, 695, 0, 680, 0, 0, 0, 611, 0], false),\\n    ([0, 0, 696, 0, 681, 0, 0, 0, 612, 0], false),\\n    ([0, 700, 697, 0, 682, 0, 0, 0, 613, 0], false),\\n    ([0, 0, 698, 0, 683, 0, 0, 0, 614, 0], false),\\n    ([0, 702, 0, 694, 685, 0, 0, 0, 616, 0], false),\\n    ([0, 703, 0, 695, 686, 0, 0, 0, 617, 0], false),\\n    ([0, 0, 0, 696, 687, 0, 0, 0, 618, 0], false),\\n    ([0, 711, 705, 0, 0, 0, 0, 675, 623, 0], false),\\n    ([0, 709, 706, 0, 0, 0, 0, 676, 624, 0], false),\\n    ([0, 707, 0, 0, 0, 0, 0, 677, 625, 0], false),\\n    ([0, 708, 0, 0, 0, 0, 0, 678, 626, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 679, 627, 0], false),\\n    ([0, 710, 707, 0, 0, 0, 0, 680, 628, 0], false),\\n    ([0, 0, 708, 0, 0, 0, 0, 681, 629, 0], false),\\n    ([0, 712, 709, 0, 0, 0, 0, 682, 630, 0], false),\\n    ([0, 0, 710, 0, 0, 0, 0, 683, 631, 0], false),\\n    ([0, 717, 714, 705, 0, 0, 0, 684, 632, 0], false),\\n    ([0, 715, 0, 706, 0, 0, 0, 685, 633, 0], false),\\n    ([0, 716, 0, 707, 0, 0, 0, 686, 634, 0], false),\\n    ([0, 0, 0, 708, 0, 0, 0, 687, 635, 0], false),\\n    ([0, 718, 715, 709, 0, 0, 0, 688, 636, 0], false),\\n    ([0, 0, 716, 710, 0, 0, 0, 689, 637, 0], false),\\n    ([0, 0, 718, 712, 0, 0, 0, 691, 638, 0], false),\\n    ([0, 721, 0, 0, 706, 0, 0, 694, 639, 0], false),\\n    ([0, 722, 0, 0, 707, 0, 0, 695, 640, 0], false),\\n    ([0, 0, 0, 0, 708, 0, 0, 696, 641, 0], false),\\n    ([0, 0, 0, 722, 716, 0, 0, 703, 648, 0], false),\\n    ([0, 725, 0, 0, 0, 0, 0, 706, 653, 0], false),\\n    ([0, 726, 0, 0, 0, 0, 0, 707, 654, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 708, 655, 0], false),\\n    ([0, 728, 725, 0, 0, 0, 0, 709, 656, 0], false),\\n    ([0, 0, 726, 0, 0, 0, 0, 710, 657, 0], false),\\n    ([0, 0, 728, 0, 0, 0, 0, 712, 658, 0], false),\\n    ([0, 0, 0, 726, 0, 0, 0, 716, 660, 0], false),\\n    ([0, 0, 730, 728, 0, 0, 0, 718, 662, 0], false),\\n    ([0, 0, 731, 729, 0, 0, 0, 719, 663, 0], false),\\n    ([0, 734, 0, 0, 724, 0, 0, 720, 664, 0], false),\\n    ([0, 735, 0, 0, 725, 0, 0, 721, 665, 0], false),\\n    ([0, 0, 0, 0, 726, 0, 0, 722, 666, 0], false),\\n    ([0, 0, 0, 735, 730, 0, 0, 723, 671, 0], false),\\n    ([0, 0, 760, 758, 750, 738, 0, 0, 0, 0], false),\\n    ([0, 0, 749, 747, 739, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 746, 744, 740, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 743, 741, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 742, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 0, 0, 742, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 745, 0, 741, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 742, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 745, 743, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 748, 0, 744, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 745, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 748, 746, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 757, 755, 751, 739, 0, 0, 0, 0], false),\\n    ([0, 0, 754, 752, 0, 740, 0, 0, 0, 0], false),\\n    ([0, 0, 753, 0, 0, 741, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 742, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 753, 0, 743, 0, 0, 0, 0], false),\\n    ([0, 0, 756, 0, 752, 744, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 753, 745, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 756, 754, 746, 0, 0, 0, 0], false),\\n    ([0, 0, 759, 0, 755, 747, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 756, 748, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 759, 757, 749, 0, 0, 0, 0], false),\\n    ([0, 0, 764, 762, 0, 751, 0, 0, 0, 0], false),\\n    ([0, 0, 763, 0, 0, 752, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 753, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 763, 0, 754, 0, 0, 0, 0], false),\\n    ([0, 0, 766, 0, 762, 755, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 763, 756, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 766, 764, 757, 0, 0, 0, 0], false),\\n    ([0, 0, 769, 0, 765, 758, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 766, 759, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 769, 767, 760, 0, 0, 0, 0], false),\\n    ([0, 0, 782, 780, 772, 0, 738, 0, 0, 0], false),\\n    ([0, 0, 779, 777, 773, 0, 739, 0, 0, 0], false),\\n    ([0, 0, 776, 774, 0, 0, 740, 0, 0, 0], false),\\n    ([0, 0, 775, 0, 0, 0, 741, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 742, 0, 0, 0], false),\\n    ([0, 0, 0, 775, 0, 0, 743, 0, 0, 0], false),\\n    ([0, 0, 778, 0, 774, 0, 744, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 775, 0, 745, 0, 0, 0], false),\\n    ([0, 0, 0, 778, 776, 0, 746, 0, 0, 0], false),\\n    ([0, 0, 781, 0, 777, 0, 747, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 778, 0, 748, 0, 0, 0], false),\\n    ([0, 0, 0, 781, 779, 0, 749, 0, 0, 0], false),\\n    ([0, 0, 786, 784, 0, 773, 751, 0, 0, 0], false),\\n    ([0, 0, 785, 0, 0, 774, 752, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 775, 753, 0, 0, 0], false),\\n    ([0, 0, 0, 785, 0, 776, 754, 0, 0, 0], false),\\n    ([0, 0, 788, 0, 784, 777, 755, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 785, 778, 756, 0, 0, 0], false),\\n    ([0, 0, 0, 788, 786, 779, 757, 0, 0, 0], false),\\n    ([1130, 1128, 791, 0, 787, 780, 758, 1086, 0, 938], false),\\n    ([1127, 1125, 0, 0, 788, 781, 759, 1087, 0, 939], false),\\n    ([1133, 1131, 0, 791, 789, 782, 760, 1094, 0, 946], false),\\n    ([0, 0, 796, 794, 0, 783, 761, 0, 0, 0], false),\\n    ([0, 0, 795, 0, 0, 784, 762, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 785, 763, 0, 0, 0], false),\\n    ([0, 0, 0, 795, 0, 786, 764, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 795, 788, 766, 0, 0, 0], false),\\n    ([0, 0, 0, 797, 796, 789, 767, 0, 0, 0], false),\\n    ([0, 0, 810, 808, 800, 0, 771, 0, 0, 0], false),\\n    ([0, 0, 807, 805, 801, 0, 772, 0, 0, 0], false),\\n    ([0, 0, 804, 802, 0, 0, 773, 0, 0, 0], false),\\n    ([0, 0, 803, 0, 0, 0, 774, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 775, 0, 0, 0], false),\\n    ([0, 0, 0, 803, 0, 0, 776, 0, 0, 0], false),\\n    ([0, 0, 806, 0, 802, 0, 777, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 803, 0, 778, 0, 0, 0], false),\\n    ([0, 0, 0, 806, 804, 0, 779, 0, 0, 0], false),\\n    ([0, 0, 809, 0, 805, 0, 780, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 806, 0, 781, 0, 0, 0], false),\\n    ([0, 0, 0, 809, 807, 0, 782, 0, 0, 0], false),\\n    ([0, 0, 814, 812, 0, 801, 783, 0, 0, 0], false),\\n    ([0, 0, 813, 0, 0, 802, 784, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 803, 785, 0, 0, 0], false),\\n    ([0, 0, 0, 813, 0, 804, 786, 0, 0, 0], false),\\n    ([0, 0, 816, 0, 812, 805, 787, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 813, 806, 788, 0, 0, 0], false),\\n    ([1146, 1144, 818, 0, 815, 808, 790, 1107, 0, 969], false),\\n    ([1143, 1141, 0, 0, 816, 809, 791, 1108, 0, 970], false),\\n    ([0, 0, 822, 820, 0, 811, 793, 0, 0, 0], false),\\n    ([0, 0, 821, 0, 0, 812, 794, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 813, 795, 0, 0, 0], false),\\n    ([0, 0, 0, 821, 0, 814, 796, 0, 0, 0], false),\\n    ([0, 0, 830, 828, 824, 0, 0, 0, 739, 0], false),\\n    ([0, 0, 827, 825, 0, 0, 0, 0, 740, 0], false),\\n    ([0, 0, 826, 0, 0, 0, 0, 0, 741, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 742, 0], false),\\n    ([0, 0, 0, 826, 0, 0, 0, 0, 743, 0], false),\\n    ([0, 0, 829, 0, 825, 0, 0, 0, 744, 0], false),\\n    ([0, 0, 0, 0, 826, 0, 0, 0, 745, 0], false),\\n    ([0, 0, 0, 829, 827, 0, 0, 0, 746, 0], false),\\n    ([0, 0, 0, 0, 829, 0, 0, 0, 748, 0], false),\\n    ([0, 0, 0, 831, 830, 0, 0, 0, 749, 0], false),\\n    ([0, 0, 840, 838, 834, 823, 0, 0, 750, 0], false),\\n    ([0, 0, 837, 835, 0, 824, 0, 0, 751, 0], false),\\n    ([0, 0, 836, 0, 0, 825, 0, 0, 752, 0], false),\\n    ([0, 0, 0, 0, 0, 826, 0, 0, 753, 0], false),\\n    ([0, 0, 0, 836, 0, 827, 0, 0, 754, 0], false),\\n    ([0, 0, 839, 0, 835, 828, 0, 0, 755, 0], false),\\n    ([0, 0, 0, 0, 836, 829, 0, 0, 756, 0], false),\\n    ([0, 0, 0, 839, 837, 830, 0, 0, 757, 0], false),\\n    ([0, 0, 0, 0, 839, 831, 0, 0, 759, 0], false),\\n    ([0, 0, 0, 841, 840, 832, 0, 0, 760, 0], false),\\n    ([0, 0, 846, 844, 0, 834, 0, 0, 761, 0], false),\\n    ([0, 0, 845, 0, 0, 835, 0, 0, 762, 0], false),\\n    ([0, 0, 0, 0, 0, 836, 0, 0, 763, 0], false),\\n    ([0, 0, 0, 845, 0, 837, 0, 0, 764, 0], false),\\n    ([0, 0, 848, 0, 844, 838, 0, 0, 765, 0], false),\\n    ([0, 0, 0, 0, 845, 839, 0, 0, 766, 0], false),\\n    ([0, 0, 0, 848, 846, 840, 0, 0, 767, 0], false),\\n    ([0, 0, 0, 0, 848, 841, 0, 0, 769, 0], false),\\n    ([0, 0, 858, 856, 852, 0, 823, 0, 772, 0], false),\\n    ([0, 0, 855, 853, 0, 0, 824, 0, 773, 0], false),\\n    ([0, 0, 854, 0, 0, 0, 825, 0, 774, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 826, 0, 775, 0], false),\\n    ([0, 0, 0, 854, 0, 0, 827, 0, 776, 0], false),\\n    ([0, 0, 857, 0, 853, 0, 828, 0, 777, 0], false),\\n    ([0, 0, 0, 0, 854, 0, 829, 0, 778, 0], false),\\n    ([0, 0, 0, 857, 855, 0, 830, 0, 779, 0], false),\\n    ([0, 0, 0, 0, 857, 0, 831, 0, 781, 0], false),\\n    ([0, 0, 0, 859, 858, 0, 832, 0, 782, 0], false),\\n    ([0, 0, 864, 862, 0, 852, 834, 0, 783, 0], false),\\n    ([0, 0, 863, 0, 0, 853, 835, 0, 784, 0], false),\\n    ([0, 0, 0, 0, 0, 854, 836, 0, 785, 0], false),\\n    ([0, 0, 0, 863, 0, 855, 837, 0, 786, 0], false),\\n    ([0, 0, 866, 0, 862, 856, 838, 0, 787, 0], false),\\n    ([0, 0, 0, 0, 863, 857, 839, 0, 788, 0], false),\\n    ([0, 0, 0, 866, 864, 858, 840, 0, 789, 0], false),\\n    ([1184, 1182, 0, 0, 866, 859, 841, 1155, 791, 1046], false),\\n    ([0, 0, 870, 0, 0, 862, 844, 0, 794, 0], false),\\n    ([0, 0, 0, 0, 0, 863, 845, 0, 795, 0], false),\\n    ([0, 0, 0, 0, 870, 866, 848, 0, 797, 0], false),\\n    ([935, 933, 929, 921, 0, 905, 873, 0, 0, 0], false),\\n    ([904, 902, 898, 890, 0, 874, 0, 0, 0, 0], false),\\n    ([889, 887, 883, 875, 0, 0, 0, 0, 0, 0], false),\\n    ([882, 880, 876, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([879, 877, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([878, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 878, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([881, 0, 877, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 878, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 881, 879, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([886, 884, 0, 876, 0, 0, 0, 0, 0, 0], false),\\n    ([885, 0, 0, 877, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 878, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 885, 0, 879, 0, 0, 0, 0, 0, 0], false),\\n    ([888, 0, 884, 880, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 885, 881, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 888, 886, 882, 0, 0, 0, 0, 0, 0], false),\\n    ([897, 895, 891, 0, 0, 875, 0, 0, 0, 0], false),\\n    ([894, 892, 0, 0, 0, 876, 0, 0, 0, 0], false),\\n    ([893, 0, 0, 0, 0, 877, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 878, 0, 0, 0, 0], false),\\n    ([0, 893, 0, 0, 0, 879, 0, 0, 0, 0], false),\\n    ([896, 0, 892, 0, 0, 880, 0, 0, 0, 0], false),\\n    ([0, 0, 893, 0, 0, 881, 0, 0, 0, 0], false),\\n    ([0, 896, 894, 0, 0, 882, 0, 0, 0, 0], false),\\n    ([901, 899, 0, 891, 0, 883, 0, 0, 0, 0], false),\\n    ([900, 0, 0, 892, 0, 884, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 893, 0, 885, 0, 0, 0, 0], false),\\n    ([0, 900, 0, 894, 0, 886, 0, 0, 0, 0], false),\\n    ([903, 0, 899, 895, 0, 887, 0, 0, 0, 0], false),\\n    ([0, 0, 900, 896, 0, 888, 0, 0, 0, 0], false),\\n    ([0, 903, 901, 897, 0, 889, 0, 0, 0, 0], false),\\n    ([920, 918, 914, 906, 0, 0, 874, 0, 0, 0], false),\\n    ([913, 911, 907, 0, 0, 0, 875, 0, 0, 0], false),\\n    ([910, 908, 0, 0, 0, 0, 876, 0, 0, 0], false),\\n    ([909, 0, 0, 0, 0, 0, 877, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 878, 0, 0, 0], false),\\n    ([0, 909, 0, 0, 0, 0, 879, 0, 0, 0], false),\\n    ([912, 0, 908, 0, 0, 0, 880, 0, 0, 0], false),\\n    ([0, 0, 909, 0, 0, 0, 881, 0, 0, 0], false),\\n    ([0, 912, 910, 0, 0, 0, 882, 0, 0, 0], false),\\n    ([917, 915, 0, 907, 0, 0, 883, 0, 0, 0], false),\\n    ([916, 0, 0, 908, 0, 0, 884, 0, 0, 0], false),\\n    ([0, 0, 0, 909, 0, 0, 885, 0, 0, 0], false),\\n    ([0, 916, 0, 910, 0, 0, 886, 0, 0, 0], false),\\n    ([919, 0, 915, 911, 0, 0, 887, 0, 0, 0], false),\\n    ([0, 0, 916, 912, 0, 0, 888, 0, 0, 0], false),\\n    ([0, 919, 917, 913, 0, 0, 889, 0, 0, 0], false),\\n    ([928, 926, 922, 0, 0, 906, 890, 0, 0, 0], false),\\n    ([925, 923, 0, 0, 0, 907, 891, 0, 0, 0], false),\\n    ([924, 0, 0, 0, 0, 908, 892, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 909, 893, 0, 0, 0], false),\\n    ([0, 924, 0, 0, 0, 910, 894, 0, 0, 0], false),\\n    ([927, 0, 923, 0, 0, 911, 895, 0, 0, 0], false),\\n    ([0, 0, 924, 0, 0, 912, 896, 0, 0, 0], false),\\n    ([0, 927, 925, 0, 0, 913, 897, 0, 0, 0], false),\\n    ([932, 930, 0, 922, 0, 914, 898, 0, 0, 0], false),\\n    ([931, 0, 0, 923, 0, 915, 899, 0, 0, 0], false),\\n    ([0, 0, 0, 924, 0, 916, 900, 0, 0, 0], false),\\n    ([0, 931, 0, 925, 0, 917, 901, 0, 0, 0], false),\\n    ([934, 0, 930, 926, 0, 918, 902, 0, 0, 0], false),\\n    ([0, 0, 931, 927, 0, 919, 903, 0, 0, 0], false),\\n    ([0, 934, 932, 928, 0, 920, 904, 0, 0, 0], false),\\n    ([967, 965, 961, 953, 0, 937, 0, 873, 0, 0], false),\\n    ([952, 950, 946, 938, 0, 0, 0, 874, 0, 0], false),\\n    ([945, 943, 939, 0, 0, 0, 0, 875, 0, 0], false),\\n    ([942, 940, 0, 0, 0, 0, 0, 876, 0, 0], false),\\n    ([941, 0, 0, 0, 0, 0, 0, 877, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 878, 0, 0], false),\\n    ([0, 941, 0, 0, 0, 0, 0, 879, 0, 0], false),\\n    ([944, 0, 940, 0, 0, 0, 0, 880, 0, 0], false),\\n    ([0, 0, 941, 0, 0, 0, 0, 881, 0, 0], false),\\n    ([0, 944, 942, 0, 0, 0, 0, 882, 0, 0], false),\\n    ([949, 947, 0, 939, 0, 0, 0, 883, 0, 0], false),\\n    ([948, 0, 0, 940, 0, 0, 0, 884, 0, 0], false),\\n    ([0, 0, 0, 941, 0, 0, 0, 885, 0, 0], false),\\n    ([0, 948, 0, 942, 0, 0, 0, 886, 0, 0], false),\\n    ([951, 0, 947, 943, 0, 0, 0, 887, 0, 0], false),\\n    ([0, 0, 948, 944, 0, 0, 0, 888, 0, 0], false),\\n    ([0, 951, 949, 945, 0, 0, 0, 889, 0, 0], false),\\n    ([960, 958, 954, 0, 0, 938, 0, 890, 0, 0], false),\\n    ([957, 955, 0, 0, 0, 939, 0, 891, 0, 0], false),\\n    ([956, 0, 0, 0, 0, 940, 0, 892, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 941, 0, 893, 0, 0], false),\\n    ([0, 956, 0, 0, 0, 942, 0, 894, 0, 0], false),\\n    ([959, 0, 955, 0, 0, 943, 0, 895, 0, 0], false),\\n    ([0, 0, 956, 0, 0, 944, 0, 896, 0, 0], false),\\n    ([0, 959, 957, 0, 0, 945, 0, 897, 0, 0], false),\\n    ([964, 962, 0, 954, 0, 946, 0, 898, 0, 0], false),\\n    ([963, 0, 0, 955, 0, 947, 0, 899, 0, 0], false),\\n    ([0, 0, 0, 956, 0, 948, 0, 900, 0, 0], false),\\n    ([0, 963, 0, 957, 0, 949, 0, 901, 0, 0], false),\\n    ([966, 0, 962, 958, 0, 950, 0, 902, 0, 0], false),\\n    ([0, 0, 963, 959, 0, 951, 0, 903, 0, 0], false),\\n    ([0, 966, 964, 960, 0, 952, 0, 904, 0, 0], false),\\n    ([983, 981, 977, 969, 0, 0, 937, 905, 0, 0], false),\\n    ([976, 974, 970, 0, 0, 0, 938, 906, 0, 0], false),\\n    ([973, 971, 0, 0, 0, 0, 939, 907, 0, 0], false),\\n    ([972, 0, 0, 0, 0, 0, 940, 908, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 941, 909, 0, 0], false),\\n    ([0, 972, 0, 0, 0, 0, 942, 910, 0, 0], false),\\n    ([975, 0, 971, 0, 0, 0, 943, 911, 0, 0], false),\\n    ([0, 0, 972, 0, 0, 0, 944, 912, 0, 0], false),\\n    ([0, 975, 973, 0, 0, 0, 945, 913, 0, 0], false),\\n    ([980, 978, 0, 970, 0, 0, 946, 914, 0, 0], false),\\n    ([979, 0, 0, 971, 0, 0, 947, 915, 0, 0], false),\\n    ([0, 0, 0, 972, 0, 0, 948, 916, 0, 0], false),\\n    ([0, 979, 0, 973, 0, 0, 949, 917, 0, 0], false),\\n    ([982, 0, 978, 974, 0, 0, 950, 918, 0, 0], false),\\n    ([0, 0, 979, 975, 0, 0, 951, 919, 0, 0], false),\\n    ([0, 982, 980, 976, 0, 0, 952, 920, 0, 0], false),\\n    ([991, 989, 985, 0, 0, 969, 953, 921, 0, 0], false),\\n    ([988, 986, 0, 0, 0, 970, 954, 922, 0, 0], false),\\n    ([987, 0, 0, 0, 0, 971, 955, 923, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 972, 956, 924, 0, 0], false),\\n    ([0, 987, 0, 0, 0, 973, 957, 925, 0, 0], false),\\n    ([990, 0, 986, 0, 0, 974, 958, 926, 0, 0], false),\\n    ([0, 0, 987, 0, 0, 975, 959, 927, 0, 0], false),\\n    ([0, 990, 988, 0, 0, 976, 960, 928, 0, 0], false),\\n    ([0, 0, 0, 987, 0, 979, 963, 931, 0, 0], false),\\n    ([0, 992, 0, 988, 0, 980, 964, 932, 0, 0], false),\\n    ([0, 0, 992, 990, 0, 982, 966, 934, 0, 0], false),\\n    ([0, 994, 993, 991, 0, 983, 967, 935, 0, 0], false),\\n    ([1027, 1025, 1021, 1013, 0, 997, 0, 0, 873, 0], false),\\n    ([1012, 1010, 1006, 998, 0, 0, 0, 0, 874, 0], false),\\n    ([1005, 1003, 999, 0, 0, 0, 0, 0, 875, 0], false),\\n    ([1002, 1000, 0, 0, 0, 0, 0, 0, 876, 0], false),\\n    ([1001, 0, 0, 0, 0, 0, 0, 0, 877, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 878, 0], false),\\n    ([0, 1001, 0, 0, 0, 0, 0, 0, 879, 0], false),\\n    ([1004, 0, 1000, 0, 0, 0, 0, 0, 880, 0], false),\\n    ([0, 0, 1001, 0, 0, 0, 0, 0, 881, 0], false),\\n    ([0, 1004, 1002, 0, 0, 0, 0, 0, 882, 0], false),\\n    ([1009, 1007, 0, 999, 0, 0, 0, 0, 883, 0], false),\\n    ([1008, 0, 0, 1000, 0, 0, 0, 0, 884, 0], false),\\n    ([0, 0, 0, 1001, 0, 0, 0, 0, 885, 0], false),\\n    ([0, 1008, 0, 1002, 0, 0, 0, 0, 886, 0], false),\\n    ([1011, 0, 1007, 1003, 0, 0, 0, 0, 887, 0], false),\\n    ([0, 0, 1008, 1004, 0, 0, 0, 0, 888, 0], false),\\n    ([0, 1011, 1009, 1005, 0, 0, 0, 0, 889, 0], false),\\n    ([1020, 1018, 1014, 0, 0, 998, 0, 0, 890, 0], false),\\n    ([1017, 1015, 0, 0, 0, 999, 0, 0, 891, 0], false),\\n    ([1016, 0, 0, 0, 0, 1000, 0, 0, 892, 0], false),\\n    ([0, 0, 0, 0, 0, 1001, 0, 0, 893, 0], false),\\n    ([0, 1016, 0, 0, 0, 1002, 0, 0, 894, 0], false),\\n    ([1019, 0, 1015, 0, 0, 1003, 0, 0, 895, 0], false),\\n    ([0, 0, 1016, 0, 0, 1004, 0, 0, 896, 0], false),\\n    ([0, 1019, 1017, 0, 0, 1005, 0, 0, 897, 0], false),\\n    ([1024, 1022, 0, 1014, 0, 1006, 0, 0, 898, 0], false),\\n    ([1023, 0, 0, 1015, 0, 1007, 0, 0, 899, 0], false),\\n    ([0, 0, 0, 1016, 0, 1008, 0, 0, 900, 0], false),\\n    ([0, 1023, 0, 1017, 0, 1009, 0, 0, 901, 0], false),\\n    ([1026, 0, 1022, 1018, 0, 1010, 0, 0, 902, 0], false),\\n    ([0, 0, 1023, 1019, 0, 1011, 0, 0, 903, 0], false),\\n    ([0, 1026, 1024, 1020, 0, 1012, 0, 0, 904, 0], false),\\n    ([1035, 1033, 1029, 0, 0, 0, 998, 0, 906, 0], false),\\n    ([1032, 1030, 0, 0, 0, 0, 999, 0, 907, 0], false),\\n    ([1031, 0, 0, 0, 0, 0, 1000, 0, 908, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 1001, 0, 909, 0], false),\\n    ([0, 1031, 0, 0, 0, 0, 1002, 0, 910, 0], false),\\n    ([1034, 0, 1030, 0, 0, 0, 1003, 0, 911, 0], false),\\n    ([0, 0, 1031, 0, 0, 0, 1004, 0, 912, 0], false),\\n    ([0, 1034, 1032, 0, 0, 0, 1005, 0, 913, 0], false),\\n    ([1043, 1041, 1037, 0, 0, 1028, 1013, 0, 921, 0], false),\\n    ([1040, 1038, 0, 0, 0, 1029, 1014, 0, 922, 0], false),\\n    ([1039, 0, 0, 0, 0, 1030, 1015, 0, 923, 0], false),\\n    ([0, 0, 0, 0, 0, 1031, 1016, 0, 924, 0], false),\\n    ([0, 1039, 0, 0, 0, 1032, 1017, 0, 925, 0], false),\\n    ([1042, 0, 1038, 0, 0, 1033, 1018, 0, 926, 0], false),\\n    ([0, 0, 1039, 0, 0, 1034, 1019, 0, 927, 0], false),\\n    ([0, 1042, 1040, 0, 0, 1035, 1020, 0, 928, 0], false),\\n    ([1059, 1057, 1053, 1045, 0, 0, 0, 997, 937, 0], false),\\n    ([1052, 1050, 1046, 0, 0, 0, 0, 998, 938, 0], false),\\n    ([1049, 1047, 0, 0, 0, 0, 0, 999, 939, 0], false),\\n    ([1048, 0, 0, 0, 0, 0, 0, 1000, 940, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 1001, 941, 0], false),\\n    ([0, 1048, 0, 0, 0, 0, 0, 1002, 942, 0], false),\\n    ([1051, 0, 1047, 0, 0, 0, 0, 1003, 943, 0], false),\\n    ([0, 0, 1048, 0, 0, 0, 0, 1004, 944, 0], false),\\n    ([0, 1051, 1049, 0, 0, 0, 0, 1005, 945, 0], false),\\n    ([1056, 1054, 0, 1046, 0, 0, 0, 1006, 946, 0], false),\\n    ([1055, 0, 0, 1047, 0, 0, 0, 1007, 947, 0], false),\\n    ([0, 0, 0, 1048, 0, 0, 0, 1008, 948, 0], false),\\n    ([0, 1055, 0, 1049, 0, 0, 0, 1009, 949, 0], false),\\n    ([1058, 0, 1054, 1050, 0, 0, 0, 1010, 950, 0], false),\\n    ([0, 0, 1055, 1051, 0, 0, 0, 1011, 951, 0], false),\\n    ([0, 1058, 1056, 1052, 0, 0, 0, 1012, 952, 0], false),\\n    ([1067, 1065, 1061, 0, 0, 1045, 0, 1013, 953, 0], false),\\n    ([1064, 1062, 0, 0, 0, 1046, 0, 1014, 954, 0], false),\\n    ([1063, 0, 0, 0, 0, 1047, 0, 1015, 955, 0], false),\\n    ([0, 0, 0, 0, 0, 1048, 0, 1016, 956, 0], false),\\n    ([0, 1063, 0, 0, 0, 1049, 0, 1017, 957, 0], false),\\n    ([1066, 0, 1062, 0, 0, 1050, 0, 1018, 958, 0], false),\\n    ([0, 0, 1063, 0, 0, 1051, 0, 1019, 959, 0], false),\\n    ([0, 1066, 1064, 0, 0, 1052, 0, 1020, 960, 0], false),\\n    ([1071, 1069, 0, 1061, 0, 1053, 0, 1021, 961, 0], false),\\n    ([1070, 0, 0, 1062, 0, 1054, 0, 1022, 962, 0], false),\\n    ([0, 0, 0, 1063, 0, 1055, 0, 1023, 963, 0], false),\\n    ([0, 1070, 0, 1064, 0, 1056, 0, 1024, 964, 0], false),\\n    ([1073, 0, 1069, 1065, 0, 1057, 0, 1025, 965, 0], false),\\n    ([0, 0, 1070, 1066, 0, 1058, 0, 1026, 966, 0], false),\\n    ([1081, 1079, 1075, 0, 0, 0, 1045, 1028, 969, 0], false),\\n    ([1078, 1076, 0, 0, 0, 0, 1046, 1029, 970, 0], false),\\n    ([1077, 0, 0, 0, 0, 0, 1047, 1030, 971, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 1048, 1031, 972, 0], false),\\n    ([0, 1077, 0, 0, 0, 0, 1049, 1032, 973, 0], false),\\n    ([1080, 0, 1076, 0, 0, 0, 1050, 1033, 974, 0], false),\\n    ([0, 0, 1077, 0, 0, 0, 1051, 1034, 975, 0], false),\\n    ([0, 1080, 1078, 0, 0, 0, 1052, 1035, 976, 0], false),\\n    ([1085, 1083, 0, 0, 0, 1075, 1061, 1037, 985, 0], false),\\n    ([1084, 0, 0, 0, 0, 1076, 1062, 1038, 986, 0], false),\\n    ([0, 0, 0, 0, 0, 1077, 1063, 1039, 987, 0], false),\\n    ([0, 1084, 0, 0, 0, 1078, 1064, 1040, 988, 0], false),\\n    ([1093, 1091, 1087, 0, 0, 0, 0, 0, 0, 875], false),\\n    ([1090, 1088, 0, 0, 0, 0, 0, 0, 0, 876], false),\\n    ([1089, 0, 0, 0, 0, 0, 0, 0, 0, 877], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 878], false),\\n    ([0, 1089, 0, 0, 0, 0, 0, 0, 0, 879], false),\\n    ([1092, 0, 1088, 0, 0, 0, 0, 0, 0, 880], false),\\n    ([0, 0, 1089, 0, 0, 0, 0, 0, 0, 881], false),\\n    ([0, 1092, 1090, 0, 0, 0, 0, 0, 0, 882], false),\\n    ([1097, 1095, 0, 1087, 0, 0, 0, 0, 0, 883], false),\\n    ([1096, 0, 0, 1088, 0, 0, 0, 0, 0, 884], false),\\n    ([0, 0, 0, 1089, 0, 0, 0, 0, 0, 885], false),\\n    ([0, 1096, 0, 1090, 0, 0, 0, 0, 0, 886], false),\\n    ([1099, 0, 0, 0, 0, 1088, 0, 0, 0, 892], false),\\n    ([0, 0, 0, 0, 0, 1089, 0, 0, 0, 893], false),\\n    ([0, 1099, 0, 0, 0, 1090, 0, 0, 0, 894], false),\\n    ([1102, 0, 1098, 0, 0, 1091, 0, 0, 0, 895], false),\\n    ([0, 0, 1099, 0, 0, 1092, 0, 0, 0, 896], false),\\n    ([0, 1102, 1100, 0, 0, 1093, 0, 0, 0, 897], false),\\n    ([1105, 0, 0, 1098, 0, 1095, 0, 0, 0, 899], false),\\n    ([0, 0, 0, 1099, 0, 1096, 0, 0, 0, 900], false),\\n    ([0, 1105, 0, 1100, 0, 1097, 0, 0, 0, 901], false),\\n    ([1114, 1112, 1108, 0, 0, 0, 1086, 0, 0, 906], false),\\n    ([1111, 1109, 0, 0, 0, 0, 1087, 0, 0, 907], false),\\n    ([1110, 0, 0, 0, 0, 0, 1088, 0, 0, 908], false),\\n    ([0, 0, 0, 0, 0, 0, 1089, 0, 0, 909], false),\\n    ([0, 1110, 0, 0, 0, 0, 1090, 0, 0, 910], false),\\n    ([1113, 0, 1109, 0, 0, 0, 1091, 0, 0, 911], false),\\n    ([0, 0, 1110, 0, 0, 0, 1092, 0, 0, 912], false),\\n    ([0, 1113, 1111, 0, 0, 0, 1093, 0, 0, 913], false),\\n    ([1118, 1116, 0, 1108, 0, 0, 1094, 0, 0, 914], false),\\n    ([1117, 0, 0, 1109, 0, 0, 1095, 0, 0, 915], false),\\n    ([0, 0, 0, 1110, 0, 0, 1096, 0, 0, 916], false),\\n    ([0, 1117, 0, 1111, 0, 0, 1097, 0, 0, 917], false),\\n    ([0, 0, 0, 0, 0, 1110, 1099, 0, 0, 924], false),\\n    ([0, 1119, 0, 0, 0, 1111, 1100, 0, 0, 925], false),\\n    ([0, 0, 1119, 0, 0, 1113, 1102, 0, 0, 927], false),\\n    ([0, 1121, 1120, 0, 0, 1114, 1103, 0, 0, 928], false),\\n    ([0, 0, 0, 1119, 0, 1117, 1105, 0, 0, 931], false),\\n    ([0, 1123, 0, 1120, 0, 1118, 1106, 0, 0, 932], false),\\n    ([1126, 0, 0, 0, 0, 0, 0, 1088, 0, 940], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 1089, 0, 941], false),\\n    ([0, 1126, 0, 0, 0, 0, 0, 1090, 0, 942], false),\\n    ([1129, 0, 1125, 0, 0, 0, 0, 1091, 0, 943], false),\\n    ([0, 0, 1126, 0, 0, 0, 0, 1092, 0, 944], false),\\n    ([0, 1129, 1127, 0, 0, 0, 0, 1093, 0, 945], false),\\n    ([1132, 0, 0, 1125, 0, 0, 0, 1095, 0, 947], false),\\n    ([0, 0, 0, 1126, 0, 0, 0, 1096, 0, 948], false),\\n    ([0, 1132, 0, 1127, 0, 0, 0, 1097, 0, 949], false),\\n    ([1135, 0, 0, 0, 0, 1125, 0, 1098, 0, 955], false),\\n    ([0, 0, 0, 0, 0, 1126, 0, 1099, 0, 956], false),\\n    ([0, 1135, 0, 0, 0, 1127, 0, 1100, 0, 957], false),\\n    ([0, 0, 1135, 0, 0, 1129, 0, 1102, 0, 959], false),\\n    ([1139, 0, 0, 1134, 0, 1131, 0, 1104, 0, 962], false),\\n    ([0, 0, 0, 1135, 0, 1132, 0, 1105, 0, 963], false),\\n    ([0, 1139, 0, 1136, 0, 1133, 0, 1106, 0, 964], false),\\n    ([1142, 0, 0, 0, 0, 0, 1125, 1109, 0, 971], false),\\n    ([0, 0, 0, 0, 0, 0, 1126, 1110, 0, 972], false),\\n    ([0, 1142, 0, 0, 0, 0, 1127, 1111, 0, 973], false),\\n    ([1145, 0, 1141, 0, 0, 0, 1128, 1112, 0, 974], false),\\n    ([0, 0, 1142, 0, 0, 0, 1129, 1113, 0, 975], false),\\n    ([0, 1145, 1143, 0, 0, 0, 1130, 1114, 0, 976], false),\\n    ([1148, 0, 0, 1141, 0, 0, 1131, 1116, 0, 978], false),\\n    ([0, 0, 0, 1142, 0, 0, 1132, 1117, 0, 979], false),\\n    ([0, 1148, 0, 1143, 0, 0, 1133, 1118, 0, 980], false),\\n    ([0, 0, 0, 0, 0, 1142, 1135, 1119, 0, 987], false),\\n    ([0, 1150, 0, 0, 0, 1143, 1136, 1120, 0, 988], false),\\n    ([0, 0, 1150, 0, 0, 1145, 1137, 1121, 0, 990], false),\\n    ([0, 0, 0, 1150, 0, 1148, 1139, 1123, 0, 992], false),\\n    ([1161, 1159, 1155, 0, 0, 0, 0, 0, 1086, 998], false),\\n    ([1158, 1156, 0, 0, 0, 0, 0, 0, 1087, 999], false),\\n    ([1157, 0, 0, 0, 0, 0, 0, 0, 1088, 1000], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 1089, 1001], false),\\n    ([0, 1157, 0, 0, 0, 0, 0, 0, 1090, 1002], false),\\n    ([1160, 0, 1156, 0, 0, 0, 0, 0, 1091, 1003], false),\\n    ([0, 0, 1157, 0, 0, 0, 0, 0, 1092, 1004], false),\\n    ([0, 1160, 1158, 0, 0, 0, 0, 0, 1093, 1005], false),\\n    ([1165, 1163, 0, 1155, 0, 0, 0, 0, 1094, 1006], false),\\n    ([1164, 0, 0, 1156, 0, 0, 0, 0, 1095, 1007], false),\\n    ([0, 0, 0, 1157, 0, 0, 0, 0, 1096, 1008], false),\\n    ([0, 1164, 0, 1158, 0, 0, 0, 0, 1097, 1009], false),\\n    ([1167, 0, 0, 0, 0, 1156, 0, 0, 1098, 1015], false),\\n    ([0, 0, 0, 0, 0, 1157, 0, 0, 1099, 1016], false),\\n    ([0, 1167, 0, 0, 0, 1158, 0, 0, 1100, 1017], false),\\n    ([1170, 0, 1166, 0, 0, 1159, 0, 0, 1101, 1018], false),\\n    ([0, 0, 1167, 0, 0, 1160, 0, 0, 1102, 1019], false),\\n    ([0, 1170, 1168, 0, 0, 1161, 0, 0, 1103, 1020], false),\\n    ([0, 0, 0, 1167, 0, 1164, 0, 0, 1105, 1023], false),\\n    ([0, 1172, 0, 1168, 0, 1165, 0, 0, 1106, 1024], false),\\n    ([1181, 1179, 1175, 0, 0, 0, 1154, 0, 1107, 1028], false),\\n    ([1178, 1176, 0, 0, 0, 0, 1155, 0, 1108, 1029], false),\\n    ([1177, 0, 0, 0, 0, 0, 1156, 0, 1109, 1030], false),\\n    ([0, 0, 0, 0, 0, 0, 1157, 0, 1110, 1031], false),\\n    ([0, 1177, 0, 0, 0, 0, 1158, 0, 1111, 1032], false),\\n    ([1180, 0, 1176, 0, 0, 0, 1159, 0, 1112, 1033], false),\\n    ([0, 0, 1177, 0, 0, 0, 1160, 0, 1113, 1034], false),\\n    ([0, 1180, 1178, 0, 0, 0, 1161, 0, 1114, 1035], false),\\n    ([1183, 0, 0, 0, 0, 0, 0, 1156, 1125, 1047], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 1157, 1126, 1048], false),\\n    ([0, 1183, 0, 0, 0, 0, 0, 1158, 1127, 1049], false),\\n    ([1186, 0, 1182, 0, 0, 0, 0, 1159, 1128, 1050], false),\\n    ([0, 0, 1183, 0, 0, 0, 0, 1160, 1129, 1051], false),\\n    ([0, 1186, 1184, 0, 0, 0, 0, 1161, 1130, 1052], false),\\n    ([1189, 0, 0, 1182, 0, 0, 0, 1163, 1131, 1054], false),\\n    ([0, 0, 0, 1183, 0, 0, 0, 1164, 1132, 1055], false),\\n    ([0, 1189, 0, 1184, 0, 0, 0, 1165, 1133, 1056], false),\\n    ([1192, 0, 0, 0, 0, 1182, 0, 1166, 1134, 1062], false),\\n    ([0, 0, 0, 0, 0, 1183, 0, 1167, 1135, 1063], false),\\n    ([0, 1192, 0, 0, 0, 1184, 0, 1168, 1136, 1064], false),\\n    ([0, 0, 1192, 0, 0, 1186, 0, 1170, 1137, 1066], false),\\n    ([0, 0, 0, 1192, 0, 1189, 0, 1172, 1139, 1070], false),\\n    ([0, 1195, 0, 1193, 0, 1190, 0, 1173, 1140, 1071], false),\\n    ([1198, 0, 0, 0, 0, 0, 1182, 1176, 1141, 1076], false),\\n    ([0, 0, 0, 0, 0, 0, 1183, 1177, 1142, 1077], false),\\n    ([0, 1198, 0, 0, 0, 0, 1184, 1178, 1143, 1078], false),\\n    ([1201, 0, 1197, 0, 0, 0, 1185, 1179, 1144, 1079], false),\\n    ([0, 0, 1198, 0, 0, 0, 1186, 1180, 1145, 1080], false),\\n    ([0, 1201, 1199, 0, 0, 0, 1187, 1181, 1146, 1081], false),\\n];\\n```\n```\\nconst N_DIGITS: usize = 10;\\n\\nuse std::collections::HashMap;\\n\\nfn get_node_id(digits: &[usize], visited: &mut [bool], n_visited: usize) -> usize {\\n    if n_visited == 0 {\\n        usize::MAX\\n    } else {\\n        digits\\n            .iter()\\n            .zip(visited.iter())\\n            .fold(0, |id, (d, v)| if *v { id * 10 + *d } else { id })\\n    }\\n}\\n\\nfn backtrack(\\n    digits: &[usize],\\n    visited: &mut [bool],\\n    depth: usize,\\n    graph: &mut HashMap<usize, (usize, [usize; N_DIGITS], bool)>,\\n    node_number: &mut usize,\\n) {\\n    let curr_id = get_node_id(digits, visited, depth);\\n    if depth == digits.len() {\\n        graph.get_mut(&curr_id).unwrap().2 = true;\\n    } else {\\n        graph.entry(curr_id).or_insert_with(|| {\\n            let nn = *node_number;\\n            *node_number += 1;\\n            (nn, [0; N_DIGITS], false)\\n        });\\n\\n        for i in 0..digits.len() {\\n            if !visited[i] {\\n                visited[i] = true;\\n                let next_id = get_node_id(digits, visited, depth + 1);\\n                let next_node_number = graph\\n                    .entry(next_id)\\n                    .or_insert_with(|| {\\n                        let nn = *node_number;\\n                        *node_number += 1;\\n                        (nn, [0; N_DIGITS], false)\\n                    })\\n                    .0;\\n                graph.get_mut(&curr_id).unwrap().1[digits[i]] = next_node_number;\\n                backtrack(digits, visited, depth + 1, graph, node_number);\\n                visited[i] = false;\\n            }\\n        }\\n    }\\n}\\n\\nfn get_digits(mut n: i32) -> Vec<usize> {\\n    if n == 0 {\\n        vec![0]\\n    } else {\\n        let mut rez = vec![];\\n        while n > 0 {\\n            rez.push((n % 10) as usize);\\n            n /= 10;\\n        }\\n        rez.sort_unstable_by(|d1, d2| d2.cmp(d1));\\n        rez\\n    }\\n}\\n\\nfn insert(\\n    n: i32,\\n    graph: &mut HashMap<usize, (usize, [usize; N_DIGITS], bool)>,\\n    node_number: &mut usize,\\n) {\\n    let digits = get_digits(n);\\n    let mut visited = vec![false; digits.len()];\\n    backtrack(&digits, &mut visited, 0, graph, node_number);\\n}\\n\\nfn main() {\\n    let mut node_number = 0;\\n    let mut graph_map = HashMap::new();\\n    for shift in 0..30 {\\n        insert(1 << shift, &mut graph_map, &mut node_number);\\n    }\\n    let mut graph = graph_map.values().copied().collect::<Vec<_>>();\\n    graph.sort_unstable_by_key(|(node_number, _, _)| *node_number);\\n    let graph = graph\\n        .into_iter()\\n        .map(|(_, edges, leaf)| (edges, leaf))\\n        .collect::<Vec<_>>();\\n    println!(\"{:?}\", graph);\\n    println!(\"{:?}\", graph.len());\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2482080,
                "title": "c-python-simple-fastest-solution-with-explanation",
                "content": "**Idea:**\\nThe easiest way to check if two things are shuffled versions of each other, which is what this problem is asking us to do, is to sort them both and the compare the result.\\n\\nIn that sense, the easiest solution here is to do exactly that: we can convert **N** to an array of its digits, sort it, then compare that result to the result of the same process on each power of **2**.\\n\\nSince the constraint upon **N** is **10e9**, we only need to check powers in the range **[0,29]**.\\n\\nTo make things easier to compare, we can always **join()** the resulting digit arrays into strings before comparison.\\n\\n**C++ Code:**\\nThe best result for the code below is 0ms / 5.9MB (beats 100% / 83.90%).\\n```\\nclass Solution {\\npublic:\\n    string convert(int n) {\\n        string s = to_string(n);\\n        sort(s.begin(), s.end());\\n        return s;\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        string s = convert(n);\\n        for (int i = 0; i < 30; i++) {\\n            if (s == convert(1 << i)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n**Python Code:**\\nThe best result for the code below is 33ms / 14MB (beats 98.93% / 26.74%).\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        def getConvert(n):\\n            return \"\".join(sorted([x for x in str(n)]))\\n        s = getConvert(n)\\n        for i in range(30):\\n            if s == getConvert(1<<i): return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convert(int n) {\\n        string s = to_string(n);\\n        sort(s.begin(), s.end());\\n        return s;\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        string s = convert(n);\\n        for (int i = 0; i < 30; i++) {\\n            if (s == convert(1 << i)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        def getConvert(n):\\n            return \"\".join(sorted([x for x in str(n)]))\\n        s = getConvert(n)\\n        for i in range(30):\\n            if s == getConvert(1<<i): return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482051,
                "title": "q869-c-100-time-space-fast-easy",
                "content": "C++ Code:\\n```\\n    bool isEqual(int arr1[10], int arr2[10]) {\\n        for (int i = 0; i < 10; i++) if (arr1[i] != arr2[i]) return 0;\\n        return 1;\\n    }\\n\\n    int countDigits(int num, int digits[10]) {\\n        int cnt = 0;\\n        while (num > 0) digits[num % 10]++, num /= 10, cnt++;\\n        return cnt;\\n    }\\n\\n    bool reorderedPowerOf2(int num) {\\n        if (num > 0) {\\n            int numDigits[10] = { 0 }, numCnt = countDigits(num, numDigits);\\n            long po2 = 1; // po2: Power of 2\\n            while (1) {\\n                int po2Digits[10] = { 0 }, po2Cnt = countDigits(po2, po2Digits);\\n                po2 <<= 1; // same as (po2 = po2 * 2;)\\n                if (po2Cnt < numCnt) continue;\\n                if (po2Cnt > numCnt || po2 > INT_MAX) break;\\n                if (isEqual(numDigits, po2Digits)) return 1;\\n            }\\n        }\\n        return 0;\\n    }\\n```\\n**The complexity of this solution:**\\n-\\tTime: O( n^2 ) // depend on the size of num and po2\\n-\\tSpace: O( 1 ) // constant array size\\n\\nResult: \\n![image](https://assets.leetcode.com/users/images/bceeb8be-3eb7-4c31-8d01-2517b3102621_1661493958.3626537.png)\\n**If you loved this solution please up vote, enjoy your coding \\uD83D\\uDE0A\\uD83D\\uDE0A**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    bool isEqual(int arr1[10], int arr2[10]) {\\n        for (int i = 0; i < 10; i++) if (arr1[i] != arr2[i]) return 0;\\n        return 1;\\n    }\\n\\n    int countDigits(int num, int digits[10]) {\\n        int cnt = 0;\\n        while (num > 0) digits[num % 10]++, num /= 10, cnt++;\\n        return cnt;\\n    }\\n\\n    bool reorderedPowerOf2(int num) {\\n        if (num > 0) {\\n            int numDigits[10] = { 0 }, numCnt = countDigits(num, numDigits);\\n            long po2 = 1; // po2: Power of 2\\n            while (1) {\\n                int po2Digits[10] = { 0 }, po2Cnt = countDigits(po2, po2Digits);\\n                po2 <<= 1; // same as (po2 = po2 * 2;)\\n                if (po2Cnt < numCnt) continue;\\n                if (po2Cnt > numCnt || po2 > INT_MAX) break;\\n                if (isEqual(numDigits, po2Digits)) return 1;\\n            }\\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2481945,
                "title": "90-tc-and-78-sc-python-magic",
                "content": "```\\ndef reorderedPowerOf2(self, n: int) -> bool:\\n\\tnum = set(\"\".join(sorted(str(2**i))) for i in range(0, 32))\\n\\tn = \\'\\'.join(sorted(str(n)))\\n\\treturn n in num\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\ndef reorderedPowerOf2(self, n: int) -> bool:\\n\\tnum = set(\"\".join(sorted(str(2**i))) for i in range(0, 32))\\n\\tn = \\'\\'.join(sorted(str(n)))\\n\\treturn n in num\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2481937,
                "title": "c-100-faster-0ms-solution-by-hash",
                "content": "# **Workaround**\\n\\nAccording to the question, we need to reorder the target number `n` to indicate whether the number is power of 2. That is, the count of each digit in `n` must be same as the certain number which is power of 2. Therefore, we can use a custom hash function to count the digits:\\n\\n``` cpp\\nint hashNumber(int n) {\\n  auto res = int(0);              /// our result hash value.\\n  while (n != 0) {                /// loop the number by taking its last digit until it becomes zero. \\n    res += int(pow(10, n % 10));  /// take digit and add res by 10 ^ n.\\n    n /= 10;                      /// iterate to next digit.\\n  }\\n  return res;\\n}\\n```\\n\\nNote for the argument `n` of function. We have constraints from the question `1 <= n <= 10^9` hence there is impossible to have a number with the count of certain digit more than `9`. We can add our result `res` by `pow(10, n%10*m)` if the count of certain digit can be increased to `m`-digits.\\n\\n---\\n# **Constant Variable**\\n\\nWhen it comes to the hash values of the power of 2, it always calculate the same hash value of `1`, `2`, `4`, `8` ... etc. Hence we can memorize the hash value of these number by  `hashNumber(m)` where `1 <= m <= 10^9` and `m` is power of 2, that is, we can construct a `unordered_set` :\\n\\n```cpp\\nauto mp     = unordered_set<int>(); /// our map which is used to store the hash value.\\nauto number = int(1);               /// our iteration of power of 2.\\nwhile (number <= 1e9) {             /// loop the number until it is bigger than 10^9.\\n  mp.emplace(hashNumber(number));   /// insert a hash value of number into our map.\\n  number <<= 1;                     /// iterate the number by multipling it by 2\\n}\\n```\\n\\nFinally, we have a constant `unordered_set`:\\n``` cpp\\nunordered_set<int> hashes{\\n  10,         100,        10000,     100000000,  1000010,    1100,\\n  1010000,    100000110,  1100100,   100110,     10111,      100010101,\\n  1001010001, 1100000110, 101011010, 111001100,  2201000,    10001121,\\n  1020210,    200110200,  111110011, 1010100211, 1000031011, 401001001,\\n  32000120,   223100,     212010011, 120011220,  102221100,  1111101111};\\n```\\n\\n---\\n\\n# **Source Code**\\n\\n``` cpp\\nclass Solution {\\nprivate:\\n  inline const static unordered_set<int> hashes{\\n    10,         100,        10000,     100000000,  1000010,    1100,\\n    1010000,    100000110,  1100100,   100110,     10111,      100010101,\\n    1001010001, 1100000110, 101011010, 111001100,  2201000,    10001121,\\n    1020210,    200110200,  111110011, 1010100211, 1000031011, 401001001,\\n    32000120,   223100,     212010011, 120011220,  102221100,  1111101111};\\n\\n  int hashNumber(int n) {\\n    auto res = int(0);\\n    while (n != 0) {\\n      res += int(pow(10, n % 10));\\n      n /= 10;\\n    }\\n    return res;\\n  }\\n\\npublic:\\n  bool reorderedPowerOf2(int n) {\\n    return hashes.find(hashNumber(n)) != hashes.end();\\n  }\\n};\\n```\\n# **Complexity**\\n\\n- **Time**: `O(number_of_digits(n))`\\n- **Space**: `O(1)`\\n\\n![image](https://assets.leetcode.com/users/images/24a1f710-c749-478e-9fc9-49c0285789f9_1661494383.20038.png)\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "``` cpp\\nint hashNumber(int n) {\\n  auto res = int(0);              /// our result hash value.\\n  while (n != 0) {                /// loop the number by taking its last digit until it becomes zero. \\n    res += int(pow(10, n % 10));  /// take digit and add res by 10 ^ n.\\n    n /= 10;                      /// iterate to next digit.\\n  }\\n  return res;\\n}\\n```\n```cpp\\nauto mp     = unordered_set<int>(); /// our map which is used to store the hash value.\\nauto number = int(1);               /// our iteration of power of 2.\\nwhile (number <= 1e9) {             /// loop the number until it is bigger than 10^9.\\n  mp.emplace(hashNumber(number));   /// insert a hash value of number into our map.\\n  number <<= 1;                     /// iterate the number by multipling it by 2\\n}\\n```\n``` cpp\\nunordered_set<int> hashes{\\n  10,         100,        10000,     100000000,  1000010,    1100,\\n  1010000,    100000110,  1100100,   100110,     10111,      100010101,\\n  1001010001, 1100000110, 101011010, 111001100,  2201000,    10001121,\\n  1020210,    200110200,  111110011, 1010100211, 1000031011, 401001001,\\n  32000120,   223100,     212010011, 120011220,  102221100,  1111101111};\\n```\n``` cpp\\nclass Solution {\\nprivate:\\n  inline const static unordered_set<int> hashes{\\n    10,         100,        10000,     100000000,  1000010,    1100,\\n    1010000,    100000110,  1100100,   100110,     10111,      100010101,\\n    1001010001, 1100000110, 101011010, 111001100,  2201000,    10001121,\\n    1020210,    200110200,  111110011, 1010100211, 1000031011, 401001001,\\n    32000120,   223100,     212010011, 120011220,  102221100,  1111101111};\\n\\n  int hashNumber(int n) {\\n    auto res = int(0);\\n    while (n != 0) {\\n      res += int(pow(10, n % 10));\\n      n /= 10;\\n    }\\n    return res;\\n  }\\n\\npublic:\\n  bool reorderedPowerOf2(int n) {\\n    return hashes.find(hashNumber(n)) != hashes.end();\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481868,
                "title": "c-simple-straight-forward-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkdigits(int n,vector<int>&v)\\n    {\\n        vector<int>v1(10,-1);\\n        while(n)\\n        {\\n            v1[n%10]++;\\n            n=n/10;\\n        }\\n        if(v1==v)\\n            return true;\\n        return false;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n        vector<int>v(10,-1);\\n        while(n)\\n        {\\n            v[n%10]++;\\n            n=n/10;\\n        }\\n        int num=1;\\n        for(int i=1;i<=30;i++)\\n        {\\n            if(checkdigits(num,v))\\n                return true;\\n            num=num*2;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkdigits(int n,vector<int>&v)\\n    {\\n        vector<int>v1(10,-1);\\n        while(n)\\n        {\\n            v1[n%10]++;\\n            n=n/10;\\n        }\\n        if(v1==v)\\n            return true;\\n        return false;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n        vector<int>v(10,-1);\\n        while(n)\\n        {\\n            v[n%10]++;\\n            n=n/10;\\n        }\\n        int num=1;\\n        for(int i=1;i<=30;i++)\\n        {\\n            if(checkdigits(num,v))\\n                return true;\\n            num=num*2;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481815,
                "title": "100-faster-c-solution-easy-understanding-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n        vector<int> gem(long int n) {\\n        vector<int>nums(10);\\n        \\n        while(n){\\n            nums[n%10]++;\\n            n=n/10;\\n        }\\n        return nums;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n        vector<int>arr=gem(n);\\n        for(int i=0;i<31;i++){\\n            if(arr==gem(1<<i)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n        vector<int> gem(long int n) {\\n        vector<int>nums(10);\\n        \\n        while(n){\\n            nums[n%10]++;\\n            n=n/10;\\n        }\\n        return nums;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n        vector<int>arr=gem(n);\\n        for(int i=0;i<31;i++){\\n            if(arr==gem(1<<i)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481805,
                "title": "approach-converting-into-string-max-tc-o-33-9-log-9-i-e-o-1-constant-time",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool reorderedPowerOf2(int n) {\\n        string s = to_string(n);\\n        sort(s.begin(),s.end());\\n        for(int i=0;i<33;i++){\\n            string x = to_string((long long)pow(2,i));\\n            sort(x.begin(),x.end());\\n            if(s==x){\\n                // cout<<s<<\" \"<<x<<endl;\\n                return true;\\n            }\\n                        \\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool reorderedPowerOf2(int n) {\\n        string s = to_string(n);\\n        sort(s.begin(),s.end());\\n        for(int i=0;i<33;i++){\\n            string x = to_string((long long)pow(2,i));\\n            sort(x.begin(),x.end());\\n            if(s==x){\\n                // cout<<s<<\" \"<<x<<endl;\\n                return true;\\n            }\\n                        \\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2481586,
                "title": "c",
                "content": "first we convert the given number to string and sort it. Then we compare the sorted string to every power of 2 till 30(as constraint is 10^9, so it can not exceed 2^30). If we find that n==2^x the we return true.\\n\\n bool reorderedPowerOf2(int n) {\\n       \\n        string s = to_string(n);\\n        sort(s.begin(),s.end());\\n        for(int i=0;i<31;i++)\\n        {\\n            int n= pow(2,i);\\n            string s2 = to_string(n);\\n            sort(s2.begin(),s2.end());\\n            if(s2==s) return true;\\n        }\\n        return false;\\n        \\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "first we convert the given number to string and sort it. Then we compare the sorted string to every power of 2 till 30(as constraint is 10^9, so it can not exceed 2^30). If we find that n==2^x the we return true.\\n\\n bool reorderedPowerOf2(int n) {\\n       \\n        string s = to_string(n);\\n        sort(s.begin(),s.end());\\n        for(int i=0;i<31;i++)\\n        {\\n            int n= pow(2,i);\\n            string s2 = to_string(n);\\n            sort(s2.begin(),s2.end());\\n            if(s2==s) return true;\\n        }\\n        return false;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2481585,
                "title": "c-solution-using-sorting",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        string x = to_string(n);\\n        sort(x.begin(),x.end());\\n        for(int i=0;i<32;i++){\\n            string temp = to_string(1<<i);\\n            sort(temp.begin(),temp.end());\\n            if(x==temp) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        string x = to_string(n);\\n        sort(x.begin(),x.end());\\n        for(int i=0;i<32;i++){\\n            string temp = to_string(1<<i);\\n            sort(temp.begin(),temp.end());\\n            if(x==temp) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481490,
                "title": "c-easy-solution-100-fast",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    bool reorderedPowerOf2(int n)\\n    {\\n        string s = to_string(n);\\n        sort(s.begin(), s.end());\\n        for (int i = 0; i <= 30; i++)\\n        {\\n            int p = pow(2, i);\\n            string t = to_string(p);\\n            sort(t.begin(), t.end());\\n            if (t == s)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool reorderedPowerOf2(int n)\\n    {\\n        string s = to_string(n);\\n        sort(s.begin(), s.end());\\n        for (int i = 0; i <= 30; i++)\\n        {\\n            int p = pow(2, i);\\n            string t = to_string(p);\\n            sort(t.begin(), t.end());\\n            if (t == s)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481455,
                "title": "string-based-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        \\n        int i = 1;\\n        int lenOfN = floor(log10(n)+1);\\n        int lenOfI = floor(log10(i)+1);\\n        string sn = to_string(n);\\n        sort(sn.begin(), sn.end());\\n        while(lenOfI<=lenOfN){\\n            \\n            string si = to_string(i);\\n            sort(si.begin(), si.end());\\n            \\n            if(lenOfN==lenOfI){\\n                    \\n                if(sn.compare(si)==0) return true;\\n            }\\n            \\n            i = i*2;\\n            lenOfI = floor(log10(i)+1);\\n      \\n        }\\n        return false;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        \\n        int i = 1;\\n        int lenOfN = floor(log10(n)+1);\\n        int lenOfI = floor(log10(i)+1);\\n        string sn = to_string(n);\\n        sort(sn.begin(), sn.end());\\n        while(lenOfI<=lenOfN){\\n            \\n            string si = to_string(i);\\n            sort(si.begin(), si.end());\\n            \\n            if(lenOfN==lenOfI){\\n                    \\n                if(sn.compare(si)==0) return true;\\n            }\\n            \\n            i = i*2;\\n            lenOfI = floor(log10(i)+1);\\n      \\n        }\\n        return false;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481415,
                "title": "c-good-code-quality-next-permutation-solution",
                "content": "We are generating each permutation from the string converting it back to integer and checking if it is a power of 2 or not. The runtime is not good it beats 10% but it is a different solution than the rest of discuss.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool LeadingDigitZero(string s){\\n        return s[0] == \\'0\\';\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        \\n        if(ceil(log2(n)) == floor(log2(n))){\\n            return true;\\n        }\\n        \\n        string s = to_string(n);\\n        sort(s.begin(),s.end());\\n        \\n        do{\\n            n = stoi(s);\\n            if(!LeadingDigitZero(s) && ceil(log2(n)) == floor(log2(n))){\\n                return true;\\n            }\\n        }while(next_permutation(s.begin(),s.end()));\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool LeadingDigitZero(string s){\\n        return s[0] == \\'0\\';\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        \\n        if(ceil(log2(n)) == floor(log2(n))){\\n            return true;\\n        }\\n        \\n        string s = to_string(n);\\n        sort(s.begin(),s.end());\\n        \\n        do{\\n            n = stoi(s);\\n            if(!LeadingDigitZero(s) && ceil(log2(n)) == floor(log2(n))){\\n                return true;\\n            }\\n        }while(next_permutation(s.begin(),s.end()));\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481395,
                "title": "java-solution-easy-counting-with-comments",
                "content": "### **Approach:**\\n##### *The Approach is to check whether the given number n is an anagram of another number m, where m is a power of two 1<=m<=Math.pow(2,30).*\\n```java \\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        String s=n+\"\";\\n        int[] a = new int[10];   // frequency of digits in number s, s=n\\n        for(int i=0;i<s.length();i++)\\n            a[s.charAt(i)-\\'0\\']++;\\n\\n        int i=1;\\n        String t = \"1\";   //Math.pow(2,0) =1\\n        while(s.length()>=t.length())\\n        {\\n            if(s.length()==t.length()){\\n            int[] b = new int[10];     // frequency of digits in number t, where t = Math.pow(2,i)\\n                \\n            for(int j=0;j<t.length();j++)\\n                b[t.charAt(j)-\\'0\\']++;\\n                \\n            if(Arrays.equals(a,b))   //Checking whether String s is Anagram of String t\\n                return true;\\n            }\\n            t = (int)Math.pow(2,i++)+\"\";\\n        }\\n        return false;\\n    }  \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        String s=n+\"\";\\n        int[] a = new int[10];   // frequency of digits in number s, s=n\\n        for(int i=0;i<s.length();i++)\\n            a[s.charAt(i)-\\'0\\']++;\\n\\n        int i=1;\\n        String t = \"1\";   //Math.pow(2,0) =1\\n        while(s.length()>=t.length())\\n        {\\n            if(s.length()==t.length()){\\n            int[] b = new int[10];     // frequency of digits in number t, where t = Math.pow(2,i)\\n                \\n            for(int j=0;j<t.length();j++)\\n                b[t.charAt(j)-\\'0\\']++;\\n                \\n            if(Arrays.equals(a,b))   //Checking whether String s is Anagram of String t\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2481394,
                "title": "c-stirng-solution",
                "content": "```\\n    bool reorderedPowerOf2(int n) {\\n        int i=0;\\n        string s1=to_string(n);\\n        sort(s1.begin(),s1.end());\\n        while(true)\\n        {\\n            int temp = pow(2,i);\\n            int digits= floor(log10(temp) + 1);\\n            int n_digits= floor(log10(n)+1);\\n            if(digits==n_digits)\\n            {\\n                string s=to_string(temp);\\n                sort(s.begin(),s.end());\\n                if(s.compare(s1)==0){\\n                    // cout<<s<<\" \"<<s1<<endl;\\n                    return true;\\n                }\\n            }\\n            if(digits>n_digits)\\n                return false;\\n            i++;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\n    bool reorderedPowerOf2(int n) {\\n        int i=0;\\n        string s1=to_string(n);\\n        sort(s1.begin(),s1.end());\\n        while(true)\\n        {\\n            int temp = pow(2,i);\\n            int digits= floor(log10(temp) + 1);\\n            int n_digits= floor(log10(n)+1);\\n            if(digits==n_digits)\\n            {\\n                string s=to_string(temp);\\n                sort(s.begin(),s.end());\\n                if(s.compare(s1)==0){\\n                    // cout<<s<<\" \"<<s1<<endl;\\n                    return true;\\n                }\\n            }\\n            if(digits>n_digits)\\n                return false;\\n            i++;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2481356,
                "title": "simple-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> func(int n){\\n        vector<int>ans(10);\\n        \\n        while(n){\\n            ans[n%10]++;\\n            n/=10;\\n        }\\n        \\n        return ans;\\n    }   \\n    \\n    bool reorderedPowerOf2(int n) {\\n                \\n        if((n&(n-1))==0)return true;\\n        \\n        vector<int>ans=func(n);\\n        \\n        for(int i=1;i<31;i++){\\n            vector<int>v=func(1<<i);\\n            if(v==ans)return true;\\n        }\\n        \\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> func(int n){\\n        vector<int>ans(10);\\n        \\n        while(n){\\n            ans[n%10]++;\\n            n/=10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2481355,
                "title": "c-easy-string-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        long long x = 1;\\n        vector<string> arr;\\n        while(x <= 1000000000){\\n            arr.push_back(to_string(x)); // store all the power of 2s less than 1e9 in a vector\\n            x *= 2;\\n        }\\n        for(auto &i : arr){\\n            sort(i.begin(), i.end()); // sort each power of 2 \\n        }\\n        string s = to_string(n);\\n        sort(s.begin(), s.end()); // sort given number\\n        for(auto i : arr){\\n            if(i == s) // if our number matches with any of the number which is of power two, then we can re-arrange our number.\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        long long x = 1;\\n        vector<string> arr;\\n        while(x <= 1000000000){\\n            arr.push_back(to_string(x)); // store all the power of 2s less than 1e9 in a vector\\n            x *= 2;\\n        }\\n        for(auto &i : arr){\\n            sort(i.begin(), i.end()); // sort each power of 2 \\n        }\\n        string s = to_string(n);\\n        sort(s.begin(), s.end()); // sort given number\\n        for(auto i : arr){\\n            if(i == s) // if our number matches with any of the number which is of power two, then we can re-arrange our number.\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481253,
                "title": "javascript-easy-understanding-with-explanation",
                "content": "Instead of shuffling we can sort the the input value and do the comparison of sorted values of pow of i \\nPlease upvote the solution \\n```\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar reorderedPowerOf2 = function(n) {\\n// If the value is 1 return true\\n    if(n===1) return true;\\n    let total = 1;\\n    let i = 1;\\n\\t// coverting the given number and sorted that with any order(ASC/DESC) \\n    let nTemp = n.toString().split(\\'\\').sort((a,b)=>a-b).join(\\'\\');\\n\\t// If the length of the string is more than the given one means we can break the loop and return false \\n    while(total.toString().length<=n.toString().length){\\n        total = Math.pow(2,i);\\n        let tTemp = total.toString().split(\\'\\').sort((a,b)=>a-b).join(\\'\\');\\n\\t\\t// Comparing the pow of 2 and the given number\\n        if(tTemp===nTemp) return true;\\n        i++;\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar reorderedPowerOf2 = function(n) {\\n// If the value is 1 return true\\n    if(n===1) return true;\\n    let total = 1;\\n    let i = 1;\\n\\t// coverting the given number and sorted that with any order(ASC/DESC) \\n    let nTemp = n.toString().split(\\'\\').sort((a,b)=>a-b).join(\\'\\');\\n\\t// If the length of the string is more than the given one means we can break the loop and return false \\n    while(total.toString().length<=n.toString().length){\\n        total = Math.pow(2,i);\\n        let tTemp = total.toString().split(\\'\\').sort((a,b)=>a-b).join(\\'\\');\\n\\t\\t// Comparing the pow of 2 and the given number\\n        if(tTemp===nTemp) return true;\\n        i++;\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2481233,
                "title": "daily-leetcode-solution-time-complexity-log-n-space-complexity-log-n",
                "content": "![image](https://assets.leetcode.com/users/images/6b668789-1528-4080-9ea3-37b97cff6585_1661483519.3508134.png)\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/6b668789-1528-4080-9ea3-37b97cff6585_1661483519.3508134.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2481227,
                "title": "very-easy-to-understand-implementation-with-80-runtime",
                "content": "```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        list_of_powers_of_2=[]\\n        for i in range(31):\\n            list_of_powers_of_2.append(\\'\\'.join(sorted(str(1<<i))))   ## storing powers of 2 as sorted string to help checking reorder of number given matches or not. \\n        return \\'\\'.join(sorted(str(n))) in list_of_powers_of_2 \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        list_of_powers_of_2=[]\\n        for i in range(31):\\n            list_of_powers_of_2.append(\\'\\'.join(sorted(str(1<<i))))   ## storing powers of 2 as sorted string to help checking reorder of number given matches or not. \\n        return \\'\\'.join(sorted(str(n))) in list_of_powers_of_2 \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481143,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        if(n == 1) return true;\\n        unordered_map<int, int> map;\\n        \\n        string temp = to_string(n);\\n        for(int i = 0; i < temp.size(); i++){\\n            map[int(temp[i])-48]++;\\n        }  \\n        \\n        int digits = temp.size();\\n        return helper(map, 1, n, digits);\\n    }\\n    \\n    bool helper(unordered_map<int, int> map, long k, int s, int digits){\\n        if(k > pow(10, digits) - 1) return false;\\n        if(k == s) return true;\\n        \\n        unordered_map<int, int> copy = map;\\n        \\n        string temp = to_string(k);\\n        for(int i = 0; i < temp.size(); i++){\\n            copy[int(temp[i])-48]--;\\n        }\\n        \\n        for(auto &it: copy){\\n            if(it.second != 0) return helper(map, k*2, s, digits);\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        if(n == 1) return true;\\n        unordered_map<int, int> map;\\n        \\n        string temp = to_string(n);\\n        for(int i = 0; i < temp.size(); i++){\\n            map[int(temp[i])-48]++;\\n        }  \\n        \\n        int digits = temp.size();\\n        return helper(map, 1, n, digits);\\n    }\\n    \\n    bool helper(unordered_map<int, int> map, long k, int s, int digits){\\n        if(k > pow(10, digits) - 1) return false;\\n        if(k == s) return true;\\n        \\n        unordered_map<int, int> copy = map;\\n        \\n        string temp = to_string(k);\\n        for(int i = 0; i < temp.size(); i++){\\n            copy[int(temp[i])-48]--;\\n        }\\n        \\n        for(auto &it: copy){\\n            if(it.second != 0) return helper(map, k*2, s, digits);\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481027,
                "title": "swift-simple-solution",
                "content": "```\\nclass Solution {\\n\\tfunc reorderedPowerOf2(_ n: Int) -> Bool {\\n\\t\\tvar pool = Set<[Character]>()\\n\\t\\tvar i = 1\\n\\t\\twhile i <= 1000000000 {\\n\\t\\t\\tpool.insert(String(i).sorted())\\n\\t\\t\\ti *= 2\\n\\t\\t}\\n\\t\\treturn pool.contains(String(n).sorted())\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\tfunc reorderedPowerOf2(_ n: Int) -> Bool {\\n\\t\\tvar pool = Set<[Character]>()\\n\\t\\tvar i = 1\\n\\t\\twhile i <= 1000000000 {\\n\\t\\t\\tpool.insert(String(i).sorted())\\n\\t\\t\\ti *= 2\\n\\t\\t}\\n\\t\\treturn pool.contains(String(n).sorted())\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2480924,
                "title": "c-clean-code-hashmap",
                "content": "**Code** : \\n```\\nclass Solution {\\npublic:\\n    vector<int> countdig(int N){\\n        vector<int>digitsInN(10);\\n        while(N)\\n            digitsInN[N % 10]++, N /= 10;\\n        return digitsInN;\\n    }\\n    bool reorderedPowerOf2(int N) {\\n        vector<int> digitsInN = countdig(N); \\n        for(int i = 0, powOf2 = 1; i < 30; i++, powOf2 <<= 1)\\n            if(digitsInN == countdig(powOf2)) return true;  \\n        return false;\\n    }\\n};\\n```\\nTime Complexity : **O(logN)**\\nSpace Complexity : **O(1)**\\n\\nHope this helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> countdig(int N){\\n        vector<int>digitsInN(10);\\n        while(N)\\n            digitsInN[N % 10]++, N /= 10;\\n        return digitsInN;\\n    }\\n    bool reorderedPowerOf2(int N) {\\n        vector<int> digitsInN = countdig(N); \\n        for(int i = 0, powOf2 = 1; i < 30; i++, powOf2 <<= 1)\\n            if(digitsInN == countdig(powOf2)) return true;  \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2480910,
                "title": "python-precompute-all-power2-and-add-to-set-30ms-beats-100",
                "content": "\\n\\nIdea: \\n- precalculate all power 2 numbers and add them as sorted strings into a set\\n- check if `sorted(str(n))` is in the set\\n\\n```python\\nclass Solution(object):\\n    def __init__(self):\\n        self.s = {\"1\"}\\n        K = 1\\n        while K <= 10** 9:\\n            K <<= 1\\n            self.s.add(\"\".join(sorted(str(K))))\\n            \\n    def reorderedPowerOf2(self, N):\\n        return \"\".join(sorted(str(N))) in self.s\\n```\\n\\nTime: `O(1)` or `O(KlogK)` where `max(K) = 9`\\nSpace: `O(1)` or 32 strings with max length of 9\\n\\n![image](https://assets.leetcode.com/users/images/0fed2e3c-313f-494e-aa12-4d5aa02d1ff6_1661473604.5191245.png)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution(object):\\n    def __init__(self):\\n        self.s = {\"1\"}\\n        K = 1\\n        while K <= 10** 9:\\n            K <<= 1\\n            self.s.add(\"\".join(sorted(str(K))))\\n            \\n    def reorderedPowerOf2(self, N):\\n        return \"\".join(sorted(str(N))) in self.s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178138,
                "title": "greate-solution",
                "content": "class Solution {\\npublic:\\n   bool reorderedPowerOf2(int n)\\n{\\n\\n    string num = to_string(n);\\n    int ans = 1;\\n    string ansnum = to_string(ans);\\n    while (ansnum.size() != num.size())\\n    {\\n        ans = ans * 2;\\n        ansnum = to_string(ans);\\n    }\\n\\n    unordered_map<char, int> mp;\\n    for (int i = 0; i < num.size(); i++)\\n    {\\n        mp[num[i]]++;\\n    }\\n\\n    while (ansnum.size() == num.size())\\n    {\\n        unordered_map<char, int> mp1;\\n        for (int i = 0; i < ansnum.size(); i++)\\n        {\\n            mp1[ansnum[i]]++;\\n        }\\n\\n        if (mp == mp1)\\n            return 1;\\n        ans = ans * 2;\\n        ansnum = to_string(ans);\\n\\n    }\\n    return 0;\\n}\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n   bool reorderedPowerOf2(int n)\\n{\\n\\n    string num = to_string(n);\\n    int ans = 1;\\n    string ansnum = to_string(ans);\\n    while (ansnum.size() != num.size())\\n    {\\n        ans = ans * 2;\\n        ansnum = to_string(ans);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1825803,
                "title": "javascript-869-reordered-power-of-2",
                "content": "---\\n\\n- Used known powers of 2, as question is a different test\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n```\\nvar reorderedPowerOf2 = function (n) {\\n    let p2 = [\\n        1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608,\\n\\t\\t16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824, /* , 2147483648, 4294967296, 8589934592, */\\n    ];\\n\\n    let ns = (\"\" + n).split(\"\").sort().join(\"\");\\n\\n    OUTER:\\n\\tfor (let p of p2) {\\n        let ps = (\"\" + p).split(\"\").sort().join(\"\");\\n        if (ps.length > ns.length) return false;\\n        if (ps === ns) return true;\\n    }\\n\\n    return false;\\n};\\n```\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reorderedPowerOf2 = function (n) {\\n    let p2 = [\\n        1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608,\\n\\t\\t16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824, /* , 2147483648, 4294967296, 8589934592, */\\n    ];\\n\\n    let ns = (\"\" + n).split(\"\").sort().join(\"\");\\n\\n    OUTER:\\n\\tfor (let p of p2) {\\n        let ps = (\"\" + p).split(\"\").sort().join(\"\");\\n        if (ps.length > ns.length) return false;\\n        if (ps === ns) return true;\\n    }\\n\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1606443,
                "title": "c-0-ms-faster-than-100-solution-by-sorting-string",
                "content": "- Sort the digits of n and the numbers of form 2^i in the same order, then check if n is the same as the number of forms 2^i \\n- example: \\nn = 2401 -> 0124 \\n2^10 = 1024 -> 0124 \\n=> true\\n\\n```c++\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        vector<string> power;\\n        for(int i=0;i<=30;i++){\\n            int a=pow(2,i);\\n            power.push_back(to_string(a));\\n        }\\n        for(int i=0;i<=30;i++){\\n            sort(power[i].begin(),power[i].end());\\n        }\\n        string s=to_string(n);\\n        sort(s.begin(),s.end());\\n\\n        for(int i=0;i<=30;i++){\\n            if(s==power[i]){return true;}\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        vector<string> power;\\n        for(int i=0;i<=30;i++){\\n            int a=pow(2,i);\\n            power.push_back(to_string(a));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1313945,
                "title": "c-solution",
                "content": "```\\n\\n```public:\\n    bool reorderedPowerOf2(int n) {\\n        string s=to_string(n);\\n        long long int i,x;\\n        sort(s.begin(),s.end());\\n        for(i=0;i<=30;i++)\\n        {\\n            x=pow(2,i);\\n            string s1=to_string(x);\\n            sort(s1.begin(),s1.end());\\n            if(s==s1)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1121817,
                "title": "rust-fastest-solution-using-64-bit-number-as-counter-array",
                "content": "```rust\\nuse std::iter::successors;\\n\\nlazy_static! {\\n    static ref POWS: Vec<u64> = (0..30).map(|x| 1 << x).map(digit_map).collect();\\n}\\npub fn reordered_power_of2(n: i32) -> bool {\\n    POWS.contains(&digit_map(n))\\n}\\n\\nfn digit_map(n: i32) -> u64 {\\n    successors(Some(n), |&x| Some(x / 10))\\n        .take_while(|&x| x > 0)\\n        .map(|x| x % 10)\\n        .fold(0, |m, c| {\\n            let mask = 0b1111 << 4 * c;\\n            let count = ((m & mask) >> 4 * c) + 1;\\n            m & (!0 ^ mask) | (count << 4 * c)\\n        })\\n}\\n```\\n\\nthe only tricky part here is `digit_map` function, we use 64-bit number as array of 4-bit numbers. Bits from `4*i` to `4*i + 3` store count of  digit `i`\\n step-by step\\n```\\n    successors(Some(n), |&x| Some(x / 10))          // descending iterator of n / 10^i\\n        .take_while(|&x| x > 0)                     // stop when the number is zero\\n        .map(|x| x % 10)                            // take next digit\\n        .fold(0, |m, d| {                           // m - is current digit bitcounter, d is next digit\\n            let mask = 0b1111 << 4 * d;             // make a mask filtering bits from `4*i` to `4*i + 3`\\n            let count = ((m & mask) >> 4 * d) + 1;  // get and increment current value under the mask\\n            m & (!0 ^ mask) | (count << 4 * d)      // assign number under the mask for the next iteration\\n        });",
                "solutionTags": [],
                "code": "```rust\\nuse std::iter::successors;\\n\\nlazy_static! {\\n    static ref POWS: Vec<u64> = (0..30).map(|x| 1 << x).map(digit_map).collect();\\n}\\npub fn reordered_power_of2(n: i32) -> bool {\\n    POWS.contains(&digit_map(n))\\n}\\n\\nfn digit_map(n: i32) -> u64 {\\n    successors(Some(n), |&x| Some(x / 10))\\n        .take_while(|&x| x > 0)\\n        .map(|x| x % 10)\\n        .fold(0, |m, c| {\\n            let mask = 0b1111 << 4 * c;\\n            let count = ((m & mask) >> 4 * c) + 1;\\n            m & (!0 ^ mask) | (count << 4 * c)\\n        })\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1120777,
                "title": "heavily-commented-javascript-solution-hash-maps-no-sort",
                "content": "My first thought was going towards generating all posibilities of orders of N\\'s numbers and check if it\\'s a pow by math.\\nThen I was thinking, we only have to check even numbers\\n\\nBut then I took a look at all the numbers that are  power of 2 under 10^9\\nThere are only 29 numbers there, as 2^30 is already over 10^9: 1,073,741,824\\n\\nSo if we generate those pows, or at least up to the N.length + 1\\nWe can then check the numbers that have the same length by a frequency map\\nIf the frequency map of N and one of the target powers is the same, we have a match.\\n\\nFor example: 1234\\nAll the powers of 2 of length 4 (it always has to be the same length as N of course) are:\\n[ 1024, 2048, 4096, 8192 ]\\n\\nThe frequency map of 1234 is:\\n{ \\'1\\': 1, \\'2\\': 1, \\'3\\': 1, \\'4\\': 1 };\\n\\nVersus one of the powers of 2:\\n{ \\'1\\': 1, \\'0\\': 1, \\'2\\': 1, \\'4\\': 1 };\\n\\twill not match.\\n\\nBut if we had 1204 as N then we have a freq map of: { \\'1\\': 1, \\'2\\': 1, \\'0\\': 1, \\'4\\': 1 };\\nThough not in the same order as the freq map of 1024, a simple for loop will match them.\\n\\n-- Coding --\\n\\nThat works great with sample input, I think one optimization could be in the poweredNumbers \\ngenerator. I am generating all the pows of lower digit count too. Maybe with some math\\nand binary search I could make that better, but I don\\'t think it\\'s worth the effort.        \\n        \\n\\n\\n\\t/**\\n\\t * @param {number} N\\n\\t * @return {boolean}\\n\\t */\\n\\tvar reorderedPowerOf2 = function(N) {\\n\\n\\n\\t\\tvar maxPowerLength = 0, // I got this variable of a hair blower\\n\\t\\t\\tsN = String(N),\\n\\t\\t\\tnLength = sN.length, // how many numbers are in N total\\n\\t\\t\\tpoweredNumbers = [], // this will hold the numbers we should check N against\\n\\t\\t\\ti = 0,\\n\\t\\t\\tnFreq = {}; // we\\'ll use this in part 2, to check which numbers we need to find\\n\\n\\t\\t// Generate the powers\\n\\t\\twhile (maxPowerLength <= nLength) {\\n\\t\\t\\tlet pow = Math.pow(2, i);\\n\\n\\t\\t\\tmaxPowerLength = String(pow).length;\\n\\n\\t\\t\\t// We\\'re only interested in numbers of the same length, of course\\n\\t\\t\\tif (maxPowerLength === nLength) {\\n\\t\\t\\t\\tpoweredNumbers.push(pow);\\n\\t\\t\\t}\\n\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\t\\t// at this point, for a N like 1234, we\\'ll have poweredNumbers [ 1024, 2048, 4096, 8192 ]\\n\\t\\t// console.log(\\'poweredNumbers\\', poweredNumbers);\\n\\n\\t\\t// now we need to see if all the numbers in N can be check off of one of those\\n\\t\\tnFreq = getFreqMap(sN);\\n\\n\\t\\t// at this point we have nFreq: { \\'1\\': 1, \\'2\\': 1, \\'3\\': 1, \\'4\\': 1 };\\n\\t\\t// console.log(\\'nFreq\\', nFreq);\\n\\n\\t\\t// Create a map for the target numbers and see if there is a match\\n\\t\\tfor (var target of poweredNumbers) {\\n\\t\\t\\tlet fm2 = getFreqMap(String(target));\\n\\n\\t\\t\\tif (isFreqMapEqual(nFreq, fm2)) {\\n\\t\\t\\t\\t// we have a match!\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// by reaching this point we\\'ve proven there is no match possible\\n\\t\\treturn false;\\n\\t};\\n\\n\\t/**\\n\\t * Helper function: Create frequency map of a string\\n\\t * @param {string} s\\n\\t * @return {object}\\n\\t */\\n\\tvar getFreqMap = function (s) {\\n\\t\\tvar map = {},\\n\\t\\t\\tl = s.length;\\n\\n\\t\\tfor (i = 0; i < l; i++) {\\n\\t\\t\\tif (!map[s[i]]) {\\n\\t\\t\\t\\tmap[s[i]] = 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmap[s[i]]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn map;\\n\\t}\\n\\n\\t/**\\n\\t * Helper function:  Check if 2 frequency maps hold the same values.\\n\\t *  Assumes the maps are of the same length total\\n\\t * @param {object} fm1 frequency map\\n\\t * @param {object} fm2 frequence map\\n\\t * @return {boolean}\\n\\t */\\n\\tvar isFreqMapEqual = function(fm1, fm2) {\\n\\n\\t\\tfor (var entry in fm1) {\\n\\t\\t\\tif (fm1[entry] !== fm2[entry]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "My first thought was going towards generating all posibilities of orders of N\\'s numbers and check if it\\'s a pow by math.\\nThen I was thinking, we only have to check even numbers\\n\\nBut then I took a look at all the numbers that are  power of 2 under 10^9\\nThere are only 29 numbers there, as 2^30 is already over 10^9: 1,073,741,824\\n\\nSo if we generate those pows, or at least up to the N.length + 1\\nWe can then check the numbers that have the same length by a frequency map\\nIf the frequency map of N and one of the target powers is the same, we have a match.\\n\\nFor example: 1234\\nAll the powers of 2 of length 4 (it always has to be the same length as N of course) are:\\n[ 1024, 2048, 4096, 8192 ]\\n\\nThe frequency map of 1234 is:\\n{ \\'1\\': 1, \\'2\\': 1, \\'3\\': 1, \\'4\\': 1 };\\n\\nVersus one of the powers of 2:\\n{ \\'1\\': 1, \\'0\\': 1, \\'2\\': 1, \\'4\\': 1 };\\n\\twill not match.\\n\\nBut if we had 1204 as N then we have a freq map of: { \\'1\\': 1, \\'2\\': 1, \\'0\\': 1, \\'4\\': 1 };\\nThough not in the same order as the freq map of 1024, a simple for loop will match them.\\n\\n-- Coding --\\n\\nThat works great with sample input, I think one optimization could be in the poweredNumbers \\ngenerator. I am generating all the pows of lower digit count too. Maybe with some math\\nand binary search I could make that better, but I don\\'t think it\\'s worth the effort.        \\n        \\n\\n\\n\\t/**\\n\\t * @param {number} N\\n\\t * @return {boolean}\\n\\t */\\n\\tvar reorderedPowerOf2 = function(N) {\\n\\n\\n\\t\\tvar maxPowerLength = 0, // I got this variable of a hair blower\\n\\t\\t\\tsN = String(N),\\n\\t\\t\\tnLength = sN.length, // how many numbers are in N total\\n\\t\\t\\tpoweredNumbers = [], // this will hold the numbers we should check N against\\n\\t\\t\\ti = 0,\\n\\t\\t\\tnFreq = {}; // we\\'ll use this in part 2, to check which numbers we need to find\\n\\n\\t\\t// Generate the powers\\n\\t\\twhile (maxPowerLength <= nLength) {\\n\\t\\t\\tlet pow = Math.pow(2, i);\\n\\n\\t\\t\\tmaxPowerLength = String(pow).length;\\n\\n\\t\\t\\t// We\\'re only interested in numbers of the same length, of course\\n\\t\\t\\tif (maxPowerLength === nLength) {\\n\\t\\t\\t\\tpoweredNumbers.push(pow);\\n\\t\\t\\t}\\n\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\t\\t// at this point, for a N like 1234, we\\'ll have poweredNumbers [ 1024, 2048, 4096, 8192 ]\\n\\t\\t// console.log(\\'poweredNumbers\\', poweredNumbers);\\n\\n\\t\\t// now we need to see if all the numbers in N can be check off of one of those\\n\\t\\tnFreq = getFreqMap(sN);\\n\\n\\t\\t// at this point we have nFreq: { \\'1\\': 1, \\'2\\': 1, \\'3\\': 1, \\'4\\': 1 };\\n\\t\\t// console.log(\\'nFreq\\', nFreq);\\n\\n\\t\\t// Create a map for the target numbers and see if there is a match\\n\\t\\tfor (var target of poweredNumbers) {\\n\\t\\t\\tlet fm2 = getFreqMap(String(target));\\n\\n\\t\\t\\tif (isFreqMapEqual(nFreq, fm2)) {\\n\\t\\t\\t\\t// we have a match!\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// by reaching this point we\\'ve proven there is no match possible\\n\\t\\treturn false;\\n\\t};\\n\\n\\t/**\\n\\t * Helper function: Create frequency map of a string\\n\\t * @param {string} s\\n\\t * @return {object}\\n\\t */\\n\\tvar getFreqMap = function (s) {\\n\\t\\tvar map = {},\\n\\t\\t\\tl = s.length;\\n\\n\\t\\tfor (i = 0; i < l; i++) {\\n\\t\\t\\tif (!map[s[i]]) {\\n\\t\\t\\t\\tmap[s[i]] = 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmap[s[i]]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn map;\\n\\t}\\n\\n\\t/**\\n\\t * Helper function:  Check if 2 frequency maps hold the same values.\\n\\t *  Assumes the maps are of the same length total\\n\\t * @param {object} fm1 frequency map\\n\\t * @param {object} fm2 frequence map\\n\\t * @return {boolean}\\n\\t */\\n\\tvar isFreqMapEqual = function(fm1, fm2) {\\n\\n\\t\\tfor (var entry in fm1) {\\n\\t\\t\\tif (fm1[entry] !== fm2[entry]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1120141,
                "title": "c-cool-super-short-100-faster-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) \\n    {\\n        static const set<string> pows {\"1\", \"2\", \"4\", \"8\", \"16\", \"23\", \"46\", \"128\", \"256\", \"125\", \"0124\", \"0248\", \"0469\", \"1289\", \"13468\", \"23678\", \"35566\", \"011237\", \"122446\", \"224588\", \"0145678\", \"0122579\", \"0134449\", \"0368888\", \"11266777\", \"23334455\", \"01466788\", \"112234778\", \"234455668\", \"012356789\", \"0112344778\"};\\n        \\n        string str = to_string(N);\\n        sort(str.begin(), str.end());\\n        \\n        return pows.find(str) != pows.end();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) \\n    {\\n        static const set<string> pows {\"1\", \"2\", \"4\", \"8\", \"16\", \"23\", \"46\", \"128\", \"256\", \"125\", \"0124\", \"0248\", \"0469\", \"1289\", \"13468\", \"23678\", \"35566\", \"011237\", \"122446\", \"224588\", \"0145678\", \"0122579\", \"0134449\", \"0368888\", \"11266777\", \"23334455\", \"01466788\", \"112234778\", \"234455668\", \"012356789\", \"0112344778\"};\\n        \\n        string str = to_string(N);\\n        sort(str.begin(), str.end());\\n        \\n        return pows.find(str) != pows.end();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120090,
                "title": "java-count-occurance-of-digits",
                "content": "From the problem description it is clear that we need to check whether N is a permutation of a power of 2. The approach is the following:\\n\\nIn the first step, we count the occurance of each digit (0-9) in N\\n\\nIn the second step, we go through each power of 2 (say, x). For each x, we do the following:\\n1. Count the occurance of each digit in x\\n2. We compare the occurance of digits in x with that of N. If we find a match, we return true.\\n3. If we don\\'t find a match for any x, we return false.\\n\\nFor example, for N = 83461, the counts will match for x = 16384 and thus we will return true. For, N = 10000, the counts will not match for any x, so we will return false.\\n\\n```\\n\\tpublic boolean reorderedPowerOf2(int N) {\\n        int[] dcountN = getDigitCount(N);\\n        \\n        for(int i = 0; i < 31; i++){\\n            int x = 1 << i, j;\\n            int[] dcountX = getDigitCount(x);\\n            \\n            for(j = 0; j < 10 && dcountN[j] == dcountX[j]; j++);\\n\\t\\t\\t/*if j becomes 10 after above loop, it means the counts\\n\\t\\t\\t  of the digits are the same in x and N*/\\n            if(j == 10) return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private int[] getDigitCount(int x){\\n        int[] result = new int[10];\\n        while(x > 0){\\n            result[x % 10]++;\\n            x /= 10;\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "From the problem description it is clear that we need to check whether N is a permutation of a power of 2. The approach is the following:\\n\\nIn the first step, we count the occurance of each digit (0-9) in N\\n\\nIn the second step, we go through each power of 2 (say, x). For each x, we do the following:\\n1. Count the occurance of each digit in x\\n2. We compare the occurance of digits in x with that of N. If we find a match, we return true.\\n3. If we don\\'t find a match for any x, we return false.\\n\\nFor example, for N = 83461, the counts will match for x = 16384 and thus we will return true. For, N = 10000, the counts will not match for any x, so we will return false.\\n\\n```\\n\\tpublic boolean reorderedPowerOf2(int N) {\\n        int[] dcountN = getDigitCount(N);\\n        \\n        for(int i = 0; i < 31; i++){\\n            int x = 1 << i, j;\\n            int[] dcountX = getDigitCount(x);\\n            \\n            for(j = 0; j < 10 && dcountN[j] == dcountX[j]; j++);\\n\\t\\t\\t/*if j becomes 10 after above loop, it means the counts\\n\\t\\t\\t  of the digits are the same in x and N*/\\n            if(j == 10) return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private int[] getDigitCount(int x){\\n        int[] result = new int[10];\\n        while(x > 0){\\n            result[x % 10]++;\\n            x /= 10;\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1120038,
                "title": "python-o64-o1-hashmap-solution",
                "content": "```\\nclass Solution:\\n    def helper(self,num):\\n        char_arr = str(num)\\n        table = dict()\\n        for char in char_arr:\\n            if char not in table:\\n                table[char] = 1\\n            else:\\n                table[char] += 1\\n        return table\\n            \\n            \\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        num_tab = self.helper(N)\\n        i = 0\\n        while i < 64:\\n            if num_tab == self.helper(pow(2,i)):\\n                return True\\n            else:\\n                i += 1\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def helper(self,num):\\n        char_arr = str(num)\\n        table = dict()\\n        for char in char_arr:\\n            if char not in table:\\n                table[char] = 1\\n            else:\\n                table[char] += 1\\n        return table\\n            \\n            \\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        num_tab = self.helper(N)\\n        i = 0\\n        while i < 64:\\n            if num_tab == self.helper(pow(2,i)):\\n                return True\\n            else:\\n                i += 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1104832,
                "title": "c-beats-100-simple-approach",
                "content": "Powers of 2 will increase really rapidly, hence we can utilize that. \\n\\n// 1\\n// 2\\n// 4\\n// 8\\n// 16\\n// 32\\n// 64\\n// 128\\n// 256\\n// 512\\n// 1024\\n// 2048\\n// 4096\\n// 8192\\n// 16384\\n// 32768\\n// 65536\\n// 131072\\n// 262144\\n// 524288\\n\\nJust collect the numbers having same number of digits and a match accordingly. \\n\\n```\\nclass Solution {\\npublic:\\n\\t#define d(x) cout<<#x<<\" \"<<x<<endl; \\n    bool check(int a,int b)\\n    {\\n\\t\\t// Can use a map too.\\n        vector<int> ar(10,0);\\n        while(a)\\n        {\\n            ar[a%10]++;\\n            a/=10;\\n        }\\n        while(b)\\n        {\\n            ar[b%10]--;\\n            b/=10;\\n        }\\n        for(int i:ar)\\n        {\\n            if(i!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n  \\n    bool reorderedPowerOf2(int N) {\\n        vector<int> ar;\\n        int sum = 1;\\n\\t\\t\\n\\t\\t//Number of Digits of N\\n        int digitN = floor(log10(N)) + 1;\\n\\t\\t\\n\\t\\t// Important Consideration we need to go to the last value in that range and not till N, \\n\\t\\t// Eg: for 125 we should go till 512 so let\\'s better go till 999.\\n        int X = pow(10,digitN)-1;\\n\\t\\t\\n        while(sum<X)\\n        {\\n            int digit = floor(log10(sum)) + 1;\\n            if(digit == digitN)\\n                ar.push_back(sum);\\n            sum=sum*2;\\n            // d(digit);\\n            // d(sum);\\n        }\\n        for(int i:ar)\\n        {\\n            // cout<<i;\\n            if(check(i,N))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\t#define d(x) cout<<#x<<\" \"<<x<<endl; \\n    bool check(int a,int b)\\n    {\\n\\t\\t// Can use a map too.\\n        vector<int> ar(10,0);\\n        while(a)\\n        {\\n            ar[a%10]++;\\n            a/=10;\\n        }\\n        while(b)\\n        {\\n            ar[b%10]--;\\n            b/=10;\\n        }\\n        for(int i:ar)\\n        {\\n            if(i!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n  \\n    bool reorderedPowerOf2(int N) {\\n        vector<int> ar;\\n        int sum = 1;\\n\\t\\t\\n\\t\\t//Number of Digits of N\\n        int digitN = floor(log10(N)) + 1;\\n\\t\\t\\n\\t\\t// Important Consideration we need to go to the last value in that range and not till N, \\n\\t\\t// Eg: for 125 we should go till 512 so let\\'s better go till 999.\\n        int X = pow(10,digitN)-1;\\n\\t\\t\\n        while(sum<X)\\n        {\\n            int digit = floor(log10(sum)) + 1;\\n            if(digit == digitN)\\n                ar.push_back(sum);\\n            sum=sum*2;\\n            // d(digit);\\n            // d(sum);\\n        }\\n        for(int i:ar)\\n        {\\n            // cout<<i;\\n            if(check(i,N))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 970128,
                "title": "rust-cheapest-best",
                "content": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn reordered_power_of2(n: i32) -> bool {\\n        [\\n            [1, 1, 1, 0, 1, 0, 0, 0, 0, 0],\\n            [0, 0, 1, 1, 0, 0, 1, 1, 1, 0],\\n            [0, 0, 0, 1, 0, 2, 2, 0, 0, 0],\\n            [0, 0, 1, 0, 0, 0, 0, 0, 0, 0],\\n            [1, 0, 1, 0, 1, 0, 0, 0, 1, 0],\\n            [1, 0, 0, 0, 1, 0, 1, 0, 0, 1],\\n            [0, 1, 2, 0, 2, 0, 1, 0, 0, 0],\\n            [0, 0, 1, 0, 0, 1, 1, 0, 0, 0],\\n            [1, 1, 0, 0, 1, 0, 2, 1, 2, 0],\\n            [1, 1, 0, 0, 1, 1, 1, 1, 1, 0],\\n            [0, 1, 0, 0, 0, 0, 1, 0, 0, 0],\\n            [1, 0, 0, 1, 0, 0, 1, 0, 4, 0],\\n            [0, 2, 1, 0, 0, 0, 2, 3, 0, 0],\\n            [0, 0, 0, 0, 1, 0, 1, 0, 0, 0],\\n            [0, 0, 1, 3, 2, 2, 0, 0, 0, 0],\\n            [1, 1, 1, 1, 0, 1, 1, 1, 1, 1],\\n            [1, 2, 1, 1, 0, 0, 0, 1, 0, 0],\\n            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\\n            [0, 1, 1, 0, 0, 0, 0, 0, 1, 1],\\n            [0, 1, 0, 1, 1, 0, 1, 0, 1, 0],\\n            [1, 1, 2, 0, 0, 1, 0, 1, 0, 1],\\n            [0, 2, 2, 1, 1, 0, 0, 2, 1, 0],\\n            [0, 0, 1, 1, 0, 0, 0, 0, 0, 0],\\n            [0, 0, 2, 0, 1, 1, 0, 0, 2, 0],\\n            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\\n            [1, 1, 0, 1, 3, 0, 0, 0, 0, 1],\\n            [0, 0, 1, 1, 2, 2, 2, 0, 1, 0],\\n            [0, 1, 1, 0, 0, 1, 0, 0, 0, 0],\\n            [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\\n            [0, 1, 1, 0, 0, 0, 0, 0, 1, 0],\\n        ]\\n        .iter()\\n        .cloned()\\n        .collect::<HashSet<[i32; 10]>>()\\n        .contains(\\n            &n.to_string().chars().map(|c| c.to_digit(10).unwrap()).fold(\\n                [0; 10],\\n                |mut acc, cur| {\\n                    acc[cur as usize] += 1;\\n                    acc\\n                },\\n            ),\\n        )\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn reordered_power_of2(n: i32) -> bool {\\n        [\\n            [1, 1, 1, 0, 1, 0, 0, 0, 0, 0],\\n            [0, 0, 1, 1, 0, 0, 1, 1, 1, 0],\\n            [0, 0, 0, 1, 0, 2, 2, 0, 0, 0],\\n            [0, 0, 1, 0, 0, 0, 0, 0, 0, 0],\\n            [1, 0, 1, 0, 1, 0, 0, 0, 1, 0],\\n            [1, 0, 0, 0, 1, 0, 1, 0, 0, 1],\\n            [0, 1, 2, 0, 2, 0, 1, 0, 0, 0],\\n            [0, 0, 1, 0, 0, 1, 1, 0, 0, 0],\\n            [1, 1, 0, 0, 1, 0, 2, 1, 2, 0],\\n            [1, 1, 0, 0, 1, 1, 1, 1, 1, 0],\\n            [0, 1, 0, 0, 0, 0, 1, 0, 0, 0],\\n            [1, 0, 0, 1, 0, 0, 1, 0, 4, 0],\\n            [0, 2, 1, 0, 0, 0, 2, 3, 0, 0],\\n            [0, 0, 0, 0, 1, 0, 1, 0, 0, 0],\\n            [0, 0, 1, 3, 2, 2, 0, 0, 0, 0],\\n            [1, 1, 1, 1, 0, 1, 1, 1, 1, 1],\\n            [1, 2, 1, 1, 0, 0, 0, 1, 0, 0],\\n            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\\n            [0, 1, 1, 0, 0, 0, 0, 0, 1, 1],\\n            [0, 1, 0, 1, 1, 0, 1, 0, 1, 0],\\n            [1, 1, 2, 0, 0, 1, 0, 1, 0, 1],\\n            [0, 2, 2, 1, 1, 0, 0, 2, 1, 0],\\n            [0, 0, 1, 1, 0, 0, 0, 0, 0, 0],\\n            [0, 0, 2, 0, 1, 1, 0, 0, 2, 0],\\n            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\\n            [1, 1, 0, 1, 3, 0, 0, 0, 0, 1],\\n            [0, 0, 1, 1, 2, 2, 2, 0, 1, 0],\\n            [0, 1, 1, 0, 0, 1, 0, 0, 0, 0],\\n            [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\\n            [0, 1, 1, 0, 0, 0, 0, 0, 1, 0],\\n        ]\\n        .iter()\\n        .cloned()\\n        .collect::<HashSet<[i32; 10]>>()\\n        .contains(\\n            &n.to_string().chars().map(|c| c.to_digit(10).unwrap()).fold(\\n                [0; 10],\\n                |mut acc, cur| {\\n                    acc[cur as usize] += 1;\\n                    acc\\n                },\\n            ),\\n        )\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 480331,
                "title": "count-digits-up-to-2-31-1-c-solution",
                "content": "```\\n    bool reorderedPowerOf2(int N) {\\n         for(int i =0;i < 31;i++){\\n            if(cmpr(N,1<<i))\\n                return true;\\n         }\\n        return false;\\n    }\\n    bool cmpr(int i , int j){\\n        vector <int> cnti (10,0);\\n        vector <int> cntj (10,0);\\n        while(i> 0){\\n            cnti[i%10]++;\\n            i -= i%10;\\n            i /= 10;\\n        }\\n        while(j> 0){\\n            cntj[j%10]++;\\n            j -= j%10;\\n            j /= 10;\\n        }\\n        for(int it =0; it < 10; it++){\\n            if(cnti[it] != cntj[it]) return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool reorderedPowerOf2(int N) {\\n         for(int i =0;i < 31;i++){\\n            if(cmpr(N,1<<i))\\n                return true;\\n         }\\n        return false;\\n    }\\n    bool cmpr(int i , int j){\\n        vector <int> cnti (10,0);\\n        vector <int> cntj (10,0);\\n        while(i> 0){\\n            cnti[i%10]++;\\n            i -= i%10;\\n            i /= 10;\\n        }\\n        while(j> 0){\\n            cntj[j%10]++;\\n            j -= j%10;\\n            j /= 10;\\n        }\\n        for(int it =0; it < 10; it++){\\n            if(cnti[it] != cntj[it]) return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 475150,
                "title": "c",
                "content": "```\\npublic bool ReorderedPowerOf2(int N) {\\n\\tvar pows = new HashSet<string>();\\n\\tfor (var i = 1; 0 < i && i < int.MaxValue; i *= 2)\\n\\t\\tpows.Add(Ordered(i));\\n\\n\\treturn pows.Contains(Ordered(N));\\n\\n\\tstring Ordered(int n) =>\\n\\t\\tnew string(n.ToString().ToCharArray().OrderBy(c => c).ToArray());\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic bool ReorderedPowerOf2(int N) {\\n\\tvar pows = new HashSet<string>();\\n\\tfor (var i = 1; 0 < i && i < int.MaxValue; i *= 2)\\n\\t\\tpows.Add(Ordered(i));\\n\\n\\treturn pows.Contains(Ordered(N));\\n\\n\\tstring Ordered(int n) =>\\n\\t\\tnew string(n.ToString().ToCharArray().OrderBy(c => c).ToArray());\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 470212,
                "title": "c-simple-straight-forward-using-sorting-beat-100-100",
                "content": "Just a simple idea using std::string and sorting.\\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        string sN = to_string(N);\\n        sort(sN.begin(), sN.end());\\n        \\n        for (int i=1; ; i*=2) {\\n            string si = to_string(i);\\n            if (si.length() < sN.length()) continue;\\n            if (si.length() > sN.length()) break;\\n            sort(si.begin(), si.end());\\n            if (si == sN) return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        string sN = to_string(N);\\n        sort(sN.begin(), sN.end());\\n        \\n        for (int i=1; ; i*=2) {\\n            string si = to_string(i);\\n            if (si.length() < sN.length()) continue;\\n            if (si.length() > sN.length()) break;\\n            sort(si.begin(), si.end());\\n            if (si == sN) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433700,
                "title": "c-o-1-time-o-1-space-with-explanation",
                "content": "If a number `q` can be converted to a target number `N` by re-ordering digits, the histograms of the digits of `q` and `N` must match. For example the histogram of the numbers `1024` => `((0,1),(1,1),(2,1),(3,0),(4,1),(5,0),(6,0),(7,0),(8,0),(9,0))` is the same as the histogram for `2014` => `((0,1),(1,1),(2,1),(3,0),(4,1),(5,0),(6,0),(7,0),(8,0),(9,0))`. The number of integers which are a power of 2 less than `10e9` are `floor(log2(10e9))`. Hence, the solution just checks if the given target `N` has the same histogram as any power of two in the given range.\\n\\n```\\nclass Solution {\\nprivate:\\n    /*\\n        make_hist(): function to make histogram of input number\\n        \\n        params: pp (long int): number to construct histogram\\n        returns: ret (pair<int,vector<int>>): ret.first: number of digits in pp\\n                                              ret.second: histogram of digits in pp\\n    */\\n    pair<int,vector<int>> make_hist(long int pp)\\n    {\\n        int num_digs = 0;\\n        vector<int> dig_count(10, 0);\\n        while(pp)\\n        {\\n            ++num_digs;\\n            ++dig_count[pp%10];\\n            pp /= 10;\\n        }\\n        return make_pair(num_digs, dig_count);\\n    }\\npublic:    \\n    bool reorderedPowerOf2(int N) \\n    {\\n        // make histogram of target N\\n        auto tg_hist = make_hist(N);\\n        \\n        // start querying from lowest power of 2\\n        long int q = 1;\\n        while(q <= 10e9) // upper limit given in the question\\n        {\\n            // make histogram of power of 2\\n            auto q_hist = make_hist(q);\\n            q <<= 1; // increment q to next power\\n            \\n            // if number of digits in query > number of digits in target\\n            // break -- since answer cannot have different number of digits\\n            if(q_hist.first > tg_hist.first) break;\\n            \\n            // if number of digits in query < than number of digits in target\\n            // move on to next query\\n            if(q_hist.first < tg_hist.first) continue;\\n            \\n            // now it is ensured query and target have same number of digits\\n            \\n            // compare histograms of target and query\\n            int i = 0;\\n            for(; i < 10; ++i)\\n            {\\n                if(tg_hist.second[i] != q_hist.second[i]) break;\\n            }\\n            \\n            // if match found\\n            if(i == 10) return true;\\n        }\\n        // no match found\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    /*\\n        make_hist(): function to make histogram of input number\\n        \\n        params: pp (long int): number to construct histogram\\n        returns: ret (pair<int,vector<int>>): ret.first: number of digits in pp\\n                                              ret.second: histogram of digits in pp\\n    */\\n    pair<int,vector<int>> make_hist(long int pp)\\n    {\\n        int num_digs = 0;\\n        vector<int> dig_count(10, 0);\\n        while(pp)\\n        {\\n            ++num_digs;\\n            ++dig_count[pp%10];\\n            pp /= 10;\\n        }\\n        return make_pair(num_digs, dig_count);\\n    }\\npublic:    \\n    bool reorderedPowerOf2(int N) \\n    {\\n        // make histogram of target N\\n        auto tg_hist = make_hist(N);\\n        \\n        // start querying from lowest power of 2\\n        long int q = 1;\\n        while(q <= 10e9) // upper limit given in the question\\n        {\\n            // make histogram of power of 2\\n            auto q_hist = make_hist(q);\\n            q <<= 1; // increment q to next power\\n            \\n            // if number of digits in query > number of digits in target\\n            // break -- since answer cannot have different number of digits\\n            if(q_hist.first > tg_hist.first) break;\\n            \\n            // if number of digits in query < than number of digits in target\\n            // move on to next query\\n            if(q_hist.first < tg_hist.first) continue;\\n            \\n            // now it is ensured query and target have same number of digits\\n            \\n            // compare histograms of target and query\\n            int i = 0;\\n            for(; i < 10; ++i)\\n            {\\n                if(tg_hist.second[i] != q_hist.second[i]) break;\\n            }\\n            \\n            // if match found\\n            if(i == 10) return true;\\n        }\\n        // no match found\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 165554,
                "title": "cpp-by-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    set<string> s;\\n    Solution(){\\n        int n = 1;\\n        for(int i = 0; i < 32; i++){\\n            string str = to_string(n);\\n            sort(str.begin(), str.end());\\n            s.insert(str);\\n            n <<= 1;\\n        }\\n    }  \\n    bool reorderedPowerOf2(int N) {\\n        string n = to_string(N);\\n        sort(n.begin(), n.end());\\n        if(s.find(n) == s.end()) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    set<string> s;\\n    Solution(){\\n        int n = 1;\\n        for(int i = 0; i < 32; i++){\\n            string str = to_string(n);\\n            sort(str.begin(), str.end());\\n            s.insert(str);\\n            n <<= 1;\\n        }\\n    }  \\n    bool reorderedPowerOf2(int N) {\\n        string n = to_string(N);\\n        sort(n.begin(), n.end());\\n        if(s.find(n) == s.end()) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150509,
                "title": "another-0ms-c-solution-no-special-data-structure",
                "content": "```\\n    int myPow(int a) {              //  returns 10^a;\\n        if(!a) return 1;\\n\\n        int res=1;\\n        while(a--)\\n\\t\\t\\t\\tres *= 10;\\n\\n        return res;\\n    }\\n\\n    int counter(int N, int& c1 ) {\\n        int res = 0;\\n\\n        for (; N; N /= 10) {res += myPow(N%10); c1++;}\\n\\n        return res;\\n    }\\n\\n\\n    bool reorderedPowerOf2(int N) {\\n        if(N<10) {\\n            if(N==1 || N==2 || N==4 || N==8) return true;\\n            return false;\\n        }\\n        \\n        int c, cc=0;\\n        c = counter(N, cc);\\n\\n        for (int i = 2*cc, k; i < 3*cc+3; i++)\\n            if (counter(1 << i, k) == c) return true;\\n\\n        return false;\\n    } \\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\n    int myPow(int a) {              //  returns 10^a;\\n        if(!a) return 1;\\n\\n        int res=1;\\n        while(a--)\\n\\t\\t\\t\\tres *= 10;\\n\\n        return res;\\n    }\\n\\n    int counter(int N, int& c1 ) {\\n        int res = 0;\\n\\n        for (; N; N /= 10) {res += myPow(N%10); c1++;}\\n\\n        return res;\\n    }\\n\\n\\n    bool reorderedPowerOf2(int N) {\\n        if(N<10) {\\n            if(N==1 || N==2 || N==4 || N==8) return true;\\n            return false;\\n        }\\n        \\n        int c, cc=0;\\n        c = counter(N, cc);\\n\\n        for (int i = 2*cc, k; i < 3*cc+3; i++)\\n            if (counter(1 << i, k) == c) return true;\\n\\n        return false;\\n    } \\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 3702162,
                "title": "explained-easy-cpp-solution",
                "content": "# Approach\\nPut Digits of n in a vector(Suppose G) and then find a power of 2 that has digits as vector G if we find that both have same digits return true else false.\\n\\n# Complexity\\n- Time complexity: 0ms,better than 100% online CPP Solutions\\n\\n- Space complexity: 6.36mb better than 40.61% online CPP Solutions\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        vector<int> g;\\n        while(n)\\n        {\\n            g.push_back(n%10);\\n            n/=10;\\n        }\\n        sort(g.begin(),g.end());\\n        for(int i=0;;i++)\\n        {\\n            vector<int> v;\\n            long long int t=pow(2,i);\\n            while(t)\\n            {\\n               v.push_back(t%10);\\n               t/=10;\\n            }\\n            sort(v.begin(),v.end());\\n            if(v==g)\\n            return true;\\n\\n            if(v.size()>g.size())\\n            break;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sorting",
                    "Counting",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        vector<int> g;\\n        while(n)\\n        {\\n            g.push_back(n%10);\\n            n/=10;\\n        }\\n        sort(g.begin(),g.end());\\n        for(int i=0;;i++)\\n        {\\n            vector<int> v;\\n            long long int t=pow(2,i);\\n            while(t)\\n            {\\n               v.push_back(t%10);\\n               t/=10;\\n            }\\n            sort(v.begin(),v.end());\\n            if(v==g)\\n            return true;\\n\\n            if(v.size()>g.size())\\n            break;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499369,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\n public:\\n  bool reorderedPowerOf2(int N) {\\n    int count = counter(N);\\n\\n    for (int i = 0; i < 30; ++i)\\n      if (counter(1 << i) == count)\\n        return true;\\n\\n    return false;\\n  }\\n private:\\n  int counter(int n) {\\n    int count = 0;\\n\\n    for (; n > 0; n /= 10)\\n      count += pow(10, n % 10);\\n\\n    return count;\\n  }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n\\n        t = sorted(str(n))\\n        i = 0\\n        while len(str(2**i))<=len(str(n)):\\n            if t==sorted(str(2**i)):\\n                return True\\n            i+=1\\n        return False\\n```\\n\\n```Java []\\nclass Solution {\\n    static byte[][] ocurr;\\n    public boolean reorderedPowerOf2(int n) {\\n        if (n == 1) return true;\\n        if (ocurr == null) {\\n            ocurr = fillOccurencesForEachPowerOf2();\\n        }\\n        byte[] freq = countFreqs(n);\\n        for (byte[] oc : ocurr) {\\n            if (areSame(oc, freq)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    private byte[][] fillOccurencesForEachPowerOf2() {\\n        byte[][] res = new byte[30][10];\\n        for (int i = 0; i < res.length; i++) {\\n            int pow = (int) Math.pow(2, i);\\n            res[i] = countFreqs(pow);\\n        }\\n        return res;\\n    }\\n    private byte[] countFreqs(int pow) {\\n        byte[] freq = new byte[10];\\n        while (pow > 0) {\\n            int digit = pow % 10;\\n            freq[digit]++;\\n            pow /= 10;\\n        }\\n        return freq;\\n    }\\n    private boolean areSame(byte[] oc, byte[] freq) {\\n        for (int i = 0; i < oc.length; i++) {\\n            if (oc[i] != freq[i]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\n public:\\n  bool reorderedPowerOf2(int N) {\\n    int count = counter(N);\\n\\n    for (int i = 0; i < 30; ++i)\\n      if (counter(1 << i) == count)\\n        return true;\\n\\n    return false;\\n  }\\n private:\\n  int counter(int n) {\\n    int count = 0;\\n\\n    for (; n > 0; n /= 10)\\n      count += pow(10, n % 10);\\n\\n    return count;\\n  }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n\\n        t = sorted(str(n))\\n        i = 0\\n        while len(str(2**i))<=len(str(n)):\\n            if t==sorted(str(2**i)):\\n                return True\\n            i+=1\\n        return False\\n```\n```Java []\\nclass Solution {\\n    static byte[][] ocurr;\\n    public boolean reorderedPowerOf2(int n) {\\n        if (n == 1) return true;\\n        if (ocurr == null) {\\n            ocurr = fillOccurencesForEachPowerOf2();\\n        }\\n        byte[] freq = countFreqs(n);\\n        for (byte[] oc : ocurr) {\\n            if (areSame(oc, freq)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    private byte[][] fillOccurencesForEachPowerOf2() {\\n        byte[][] res = new byte[30][10];\\n        for (int i = 0; i < res.length; i++) {\\n            int pow = (int) Math.pow(2, i);\\n            res[i] = countFreqs(pow);\\n        }\\n        return res;\\n    }\\n    private byte[] countFreqs(int pow) {\\n        byte[] freq = new byte[10];\\n        while (pow > 0) {\\n            int digit = pow % 10;\\n            freq[digit]++;\\n            pow /= 10;\\n        }\\n        return freq;\\n    }\\n    private boolean areSame(byte[] oc, byte[] freq) {\\n        for (int i = 0; i < oc.length; i++) {\\n            if (oc[i] != freq[i]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343801,
                "title": "c-short-and-100-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n)\\n    {\\n        string nn = to_string(n);\\n        \\n        sort(nn.begin(), nn.end());\\n        \\n        for (int i = 0; i < 32; i++)\\n        {\\n            string pp = to_string(1 << i);\\n            \\n            sort(pp.begin(), pp.end());\\n            \\n            if (pp == nn)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n)\\n    {\\n        string nn = to_string(n);\\n        \\n        sort(nn.begin(), nn.end());\\n        \\n        for (int i = 0; i < 32; i++)\\n        {\\n            string pp = to_string(1 << i);\\n            \\n            sort(pp.begin(), pp.end());\\n            \\n            if (pp == nn)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224186,
                "title": "java-easy-solution-no-bit-operations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- There are 31 powers of 2 that are within the question constraints of `1 <= n <= 10^9`\\n- Sort the number `n` and each sorted power of 2 from 0 -> 30\\n- Leading 0 case is handled because the ordered power will never have a 0. For example, 0256 and 256 are not.\\n# Complexity\\n- Time complexity: $$O(nlogn*n)$$ Sort * string creation\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        char[] numArray = String.valueOf(n).toCharArray();\\n        Arrays.sort(numArray);\\n        String orderedNum = new String(numArray);\\n\\n        for (int i = 0; i < 31; i++) {\\n            int powerNum = (int) Math.pow(2, i);\\n            char[] powerNumArray = String.valueOf(powerNum).toCharArray();\\n            Arrays.sort(powerNumArray);\\n            String orderedPower = new String(powerNumArray);\\n\\n            if (orderedNum.equals(orderedPower)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        char[] numArray = String.valueOf(n).toCharArray();\\n        Arrays.sort(numArray);\\n        String orderedNum = new String(numArray);\\n\\n        for (int i = 0; i < 31; i++) {\\n            int powerNum = (int) Math.pow(2, i);\\n            char[] powerNumArray = String.valueOf(powerNum).toCharArray();\\n            Arrays.sort(powerNumArray);\\n            String orderedPower = new String(powerNumArray);\\n\\n            if (orderedNum.equals(orderedPower)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976338,
                "title": "python-few-lines-of-easy-brute-force",
                "content": "```python\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        target = sorted(str(n))\\n\\n        for i in range(31):  # 10^9\\n            if sorted(str(2**i)) == target:\\n                return True\\n\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        target = sorted(str(n))\\n\\n        for i in range(31):  # 10^9\\n            if sorted(str(2**i)) == target:\\n                return True\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755253,
                "title": "c-100-fast-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) \\n{\\n   string str = to_string(n);\\n   sort(str.begin(),str.end());\\n   long long int num;\\n   int counter=0;\\n   \\n   while(true)\\n   {\\n      num = pow(2,counter++);\\n      \\n      string temp = to_string(num);\\n      \\n       \\n      if(temp.length()>str.length())\\n      {\\n          //cout<<\"temp=\"<<temp<<endl;\\n          break;\\n      }\\n       \\n      sort(temp.begin(),temp.end());\\n         \\n      if(str == temp)\\n      return true;\\n     \\n   }     \\n   return false;   \\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) \\n{\\n   string str = to_string(n);\\n   sort(str.begin(),str.end());\\n   long long int num;\\n   int counter=0;\\n   \\n   while(true)\\n   {\\n      num = pow(2,counter++);\\n      \\n      string temp = to_string(num);\\n      \\n       \\n      if(temp.length()>str.length())\\n      {\\n          //cout<<\"temp=\"<<temp<<endl;\\n          break;\\n      }\\n       \\n      sort(temp.begin(),temp.end());\\n         \\n      if(str == temp)\\n      return true;\\n     \\n   }     \\n   return false;   \\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2512264,
                "title": "clever-solution-convert-to-string-c",
                "content": "```\\nbool reorderedPowerOf2(int n) {\\n    unordered_set<string> powers = {\\n        \"1\", \"2\", \"4\", \"8\", \"16\", \"32\", \"64\", \"128\",\"256\",\"512\",\"1024\",\"2048\",\"4096\",\"8192\",\"16384\",\"32768\",\"65536\", \"131072\", \"262144\",\"524288\", \"1048576\", \"2097152\", \"4194304\", \"8388608\", \"16777216\", \"33554432\", \"67108864\", \"134217728\", \"268435456\", \"536870912\", \"1073741824\", \"2147483648\"\\n    };\\n\\n    string num = to_string(n);\\n    sort(num.begin(), num.end());\\n\\n    for(string s : powers) {\\n        sort(s.begin(), s.end());\\n\\n        if(num == s)\\n            return true;\\n    } \\n    return false;\\n}\\n```\\n**upVote** \\uD83C\\uDF1D",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nbool reorderedPowerOf2(int n) {\\n    unordered_set<string> powers = {\\n        \"1\", \"2\", \"4\", \"8\", \"16\", \"32\", \"64\", \"128\",\"256\",\"512\",\"1024\",\"2048\",\"4096\",\"8192\",\"16384\",\"32768\",\"65536\", \"131072\", \"262144\",\"524288\", \"1048576\", \"2097152\", \"4194304\", \"8388608\", \"16777216\", \"33554432\", \"67108864\", \"134217728\", \"268435456\", \"536870912\", \"1073741824\", \"2147483648\"\\n    };\\n\\n    string num = to_string(n);\\n    sort(num.begin(), num.end());\\n\\n    for(string s : powers) {\\n        sort(s.begin(), s.end());\\n\\n        if(num == s)\\n            return true;\\n    } \\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2496603,
                "title": "reordered-power-of-2-o-1-time-complexity-cpp-solution",
                "content": "*simply take all 2 powered no.s from 2^0 to 2^30 which falls under 10^9 and convert given number \\'n\\' into string and then simply compare with all other 2^x powers by converting it into string and sorting and checking if they both match then return true else after end of loop return false.*\\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        if(n==0) return false;\\n        string cnum = to_string(n);\\n        vector<string> res;\\n        sort(cnum.begin(),cnum.end());\\n        int len = cnum.size();\\n        for(int i=0;i<30;i++){\\n            int temp = pow(2,i);\\n            string num = to_string(temp);\\n            if(len==num.size()){\\n                sort(num.begin(),num.end());\\n                if(num==cnum) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        if(n==0) return false;\\n        string cnum = to_string(n);\\n        vector<string> res;\\n        sort(cnum.begin(),cnum.end());\\n        int len = cnum.size();\\n        for(int i=0;i<30;i++){\\n            int temp = pow(2,i);\\n            string num = to_string(temp);\\n            if(len==num.size()){\\n                sort(num.begin(),num.end());\\n                if(num==cnum) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485629,
                "title": "c",
                "content": "```\\npublic class Solution \\n{\\n    public bool ReorderedPowerOf2(int n) \\n    {\\n\\t\\tstring s0 = string.Concat(n.ToString().OrderBy(ch => ch));\\n        \\n        int len = Convert.ToString( (int)Math.Pow(10, n.ToString().Length) , 2).Length;\\n        for (int i = 0; i <= len; i++)\\n        {\\n            int temp = (int)Math.Pow(2, i);\\n            string s1 = string.Concat(temp.ToString().OrderBy(ch => ch));\\n\\n            if (s1 == s0)\\n            {\\n                return true;\\n            }            \\n        }\\n\\n        return false;        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public bool ReorderedPowerOf2(int n) \\n    {\\n\\t\\tstring s0 = string.Concat(n.ToString().OrderBy(ch => ch));\\n        \\n        int len = Convert.ToString( (int)Math.Pow(10, n.ToString().Length) , 2).Length;\\n        for (int i = 0; i <= len; i++)\\n        {\\n            int temp = (int)Math.Pow(2, i);\\n            string s1 = string.Concat(temp.ToString().OrderBy(ch => ch));\\n\\n            if (s1 == s0)\\n            {\\n                return true;\\n            }            \\n        }\\n\\n        return false;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485464,
                "title": "golang-c-python-100-solutions",
                "content": "same logic: \\n1) we prepare a int[10] list to store count of each digits in <kbd>n</kbd>,\\n2) check every <kbd>2 ** i</kbd> result for an identical list, until result reaches <kbd>1e9</kbd> (dictated in the subject)\\n\\n# Go\\n```go\\nfunc reorderedPowerOf2(n int) bool {\\n    check := count_n(n)\\n    // fmt.Println(check)\\n    num := 0\\n    i := 0\\n    for num < 1e9 + 1 {\\n        num = int(math.Pow(2, float64(i)))\\n        temp := count_n(num)\\n        if check == temp {\\n            return true\\n        }\\n        i++\\n    }\\n    return false\\n}\\n\\nfunc count_n(n int) [10] int {\\n    r := [10] int {} // auto 0-filled\\n    for n > 0 {\\n        r[n % 10]++\\n        n /= 10\\n    }\\n    return r\\n}\\n```\\n# C++\\n```r\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n)\\n    {\\n        vector<int> check, temp;\\n        int         i, res;\\n\\n        check = count_n(n);\\n        i = 0;\\n        res = 0;\\n        while (res < (int) 1e9 + 1)\\n        {\\n            res = pow(2, i);\\n            temp = count_n(res);\\n            if (check == temp)\\n                return true;\\n            i++;\\n        }\\n        return false;\\n    }\\n\\n    vector<int> count_n(int n)\\n    {\\n        vector<int> r(10, 0);\\n\\n        while (n)\\n        {\\n            r[n % 10]++;\\n            n /= 10;\\n        }\\n        return r;\\n    }\\n};\\n```\\n# Python\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        def count_n(num: int) -> List[int]:\\n            r = [0] * 10\\n            while num > 0:\\n                r[num % 10] += 1\\n                num //= 10\\n            return r\\n        check = count_n(n)\\n        res, i = 0, 0\\n        while res < 10 ** 9 + 1:\\n            res = 2 ** i\\n            temp = count_n(res)\\n            if check == temp:\\n                return True\\n            i += 1\\n        return False\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "Go"
                ],
                "code": "```go\\nfunc reorderedPowerOf2(n int) bool {\\n    check := count_n(n)\\n    // fmt.Println(check)\\n    num := 0\\n    i := 0\\n    for num < 1e9 + 1 {\\n        num = int(math.Pow(2, float64(i)))\\n        temp := count_n(num)\\n        if check == temp {\\n            return true\\n        }\\n        i++\\n    }\\n    return false\\n}\\n\\nfunc count_n(n int) [10] int {\\n    r := [10] int {} // auto 0-filled\\n    for n > 0 {\\n        r[n % 10]++\\n        n /= 10\\n    }\\n    return r\\n}\\n```\n```r\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n)\\n    {\\n        vector<int> check, temp;\\n        int         i, res;\\n\\n        check = count_n(n);\\n        i = 0;\\n        res = 0;\\n        while (res < (int) 1e9 + 1)\\n        {\\n            res = pow(2, i);\\n            temp = count_n(res);\\n            if (check == temp)\\n                return true;\\n            i++;\\n        }\\n        return false;\\n    }\\n\\n    vector<int> count_n(int n)\\n    {\\n        vector<int> r(10, 0);\\n\\n        while (n)\\n        {\\n            r[n % 10]++;\\n            n /= 10;\\n        }\\n        return r;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        def count_n(num: int) -> List[int]:\\n            r = [0] * 10\\n            while num > 0:\\n                r[num % 10] += 1\\n                num //= 10\\n            return r\\n        check = count_n(n)\\n        res, i = 0, 0\\n        while res < 10 ** 9 + 1:\\n            res = 2 ** i\\n            temp = count_n(res)\\n            if check == temp:\\n                return True\\n            i += 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485338,
                "title": "c-100-0ms-readable-optimised",
                "content": "```\\n\\tint nDig(int n) {\\n        int x=0;\\n        while(n || !x) {\\n            x++;\\n            n/=10;\\n        }\\n        return x;\\n    }\\n    string encodeDig(int n) {\\n        string x=\"0000000000\";\\n        while(n) {\\n            int i=n%10;\\n            x[i]+=1;\\n            n/=10;\\n        }\\n        return x;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n        string nstr=encodeDig(n);\\n        int ndig = nDig(n);\\n        int p2=1;\\n        while(nDig(p2)!=ndig) p2*=2;\\n        while(nDig(p2)==ndig) if(nstr==encodeDig(p2)) return true; else p2*=2;\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\tint nDig(int n) {\\n        int x=0;\\n        while(n || !x) {\\n            x++;\\n            n/=10;\\n        }\\n        return x;\\n    }\\n    string encodeDig(int n) {\\n        string x=\"0000000000\";\\n        while(n) {\\n            int i=n%10;\\n            x[i]+=1;\\n            n/=10;\\n        }\\n        return x;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n        string nstr=encodeDig(n);\\n        int ndig = nDig(n);\\n        int p2=1;\\n        while(nDig(p2)!=ndig) p2*=2;\\n        while(nDig(p2)==ndig) if(nstr==encodeDig(p2)) return true; else p2*=2;\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2485329,
                "title": "crazy-unusual-method-fta-python",
                "content": "![image](https://assets.leetcode.com/users/images/f581bc8b-cdae-458c-81ce-e507a5604a39_1661544945.0515218.png)\\nThe idea of this method is behind the desire of pre-calculating all the possible answers in a special way so that when we get a number we can quickly say is it an answer or not.\\n\\nLet\\'s not stray far from the idea of counting the number of all digits, because it\\'s pretty reasonable. We need to somehow hash all precalculations for powers of two less than 10**9.\\n\\nThat is, in other words, we must be able to quickly understand whether, say, the number of eights in the number given to us coincides with the number of eights in any of the powers of two. Or, to put it another way, is there a power of two with the same number of eights as in the given number.\\n\\nThat is, for each digit we need to understand the \"degree\" of its occurrence in the number and be able to quickly answer whether there is a power of two with the same number of the same digits.\\n\\nAt this point, I remembered the Fundamental Theorem of Arithmetic, and I came up with the idea of \\u200B\\u200Bthe following way to encode numbers. To each digit we associate a certain prime number (for simplicity, let\\'s say that we associate the \"i\" digit with the \"i+1\"-th prime number). Then the number will be encoded by multiplying all prime numbers encoded by its digits, raised to the power of occurrence of these digits.\\n\\nThus, we can create a set with all encoded powers of two less than 10**9, and then just encode each number given to us in the same way and check whether this number is in our set or not.\\n\\nThe main idea has been explained. Only the technical part of the implementation remains.\\n\\nFirst, let\\'s create a list of the first 10 primes (it\\'s faster to do it by hand). Here it is: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\\n\\nNow we need all powers of two less than 10**9. They can be generated like this:\\n```\\npowers_of_two = []\\ni = 0\\nwhile 2 ** i <= 10**9:\\n\\tpowers_of_two.append(2**i)\\n\\ti += 1\\n```\\nNow each power of two has to be encoded. For example, it can be done like this:\\n```\\nans = set()\\nfor num in powers_of_two:\\n\\tcnt = Counter(str(num))\\n\\ttmp = 1\\n\\tfor digit in cnt:\\n\\t\\ttmp *= primes[int(digit)] ** cnt[digit]\\n\\tans.add(tmp)\\n```\\nNow we have all the necessary pre-calculations in hand, and we can write the code itself:\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        ans = {3, 143849475, 5, 191712774, 11, 89201295, 1074450, 10005, 23, 35, 154275, 4757357605, 1621158, 66602158, 260015, 51, 187, 11970, 195, 6374082, 330, 588153930, 1105, 90321, 35070035, 345, 10846, 2530, 1891175, 341887}\\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\\n        cnt = Counter(str(n))\\n        t = 1\\n        for digit in cnt:\\n            t *= primes[int(digit)] ** cnt[digit]\\n        return t in ans\\n```\\n**Upvote if you find interesting this approach!**",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\npowers_of_two = []\\ni = 0\\nwhile 2 ** i <= 10**9:\\n\\tpowers_of_two.append(2**i)\\n\\ti += 1\\n```\n```\\nans = set()\\nfor num in powers_of_two:\\n\\tcnt = Counter(str(num))\\n\\ttmp = 1\\n\\tfor digit in cnt:\\n\\t\\ttmp *= primes[int(digit)] ** cnt[digit]\\n\\tans.add(tmp)\\n```\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        ans = {3, 143849475, 5, 191712774, 11, 89201295, 1074450, 10005, 23, 35, 154275, 4757357605, 1621158, 66602158, 260015, 51, 187, 11970, 195, 6374082, 330, 588153930, 1105, 90321, 35070035, 345, 10846, 2530, 1891175, 341887}\\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\\n        cnt = Counter(str(n))\\n        t = 1\\n        for digit in cnt:\\n            t *= primes[int(digit)] ** cnt[digit]\\n        return t in ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485204,
                "title": "java-with-bit-shift-100-faster-memory-usage-99-33",
                "content": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        int digitCount[] = getDigitCount(n);\\n        int totalDigits = 0;\\n        \\n        for (int count : digitCount) {\\n            totalDigits += count;\\n        }\\n        \\n\\t\\t// set upper and lower limit\\n        int max = (int) Math.pow(10, totalDigits);\\n        int min = (int) Math.pow(10, totalDigits - 1);\\n        int powTwo = 1;\\n        \\n\\t\\t// shift until within upper and lower limit range\\n        while (powTwo < min) {\\n            powTwo <<= 1;\\n        }\\n        \\n        boolean same = true;\\n        while (powTwo < max) {\\n            int[] powTwoDigitCount = getDigitCount(powTwo);\\n            same = true;\\n\\t\\t\\t\\n\\t\\t\\t// check if digits occurrences are equal\\n            for (int i = 0; i < digitCount.length; i++) {\\n                if (digitCount[i] != powTwoDigitCount[i]) {\\n                    same = false;\\n                    break;\\n                }\\n            }\\n            \\n            if (same) break;\\n            powTwo <<= 1;\\n        }\\n        \\n        return same;\\n    }\\n    \\n    private int[] getDigitCount(int n) {\\n        int digitCount[] = new int[10];\\n        while (n != 0) {\\n            digitCount[n % 10]++;\\n            n /= 10;\\n        }\\n        \\n        return digitCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        int digitCount[] = getDigitCount(n);\\n        int totalDigits = 0;\\n        \\n        for (int count : digitCount) {\\n            totalDigits += count;\\n        }\\n        \\n\\t\\t// set upper and lower limit\\n        int max = (int) Math.pow(10, totalDigits);\\n        int min = (int) Math.pow(10, totalDigits - 1);\\n        int powTwo = 1;\\n        \\n\\t\\t// shift until within upper and lower limit range\\n        while (powTwo < min) {\\n            powTwo <<= 1;\\n        }\\n        \\n        boolean same = true;\\n        while (powTwo < max) {\\n            int[] powTwoDigitCount = getDigitCount(powTwo);\\n            same = true;\\n\\t\\t\\t\\n\\t\\t\\t// check if digits occurrences are equal\\n            for (int i = 0; i < digitCount.length; i++) {\\n                if (digitCount[i] != powTwoDigitCount[i]) {\\n                    same = false;\\n                    break;\\n                }\\n            }\\n            \\n            if (same) break;\\n            powTwo <<= 1;\\n        }\\n        \\n        return same;\\n    }\\n    \\n    private int[] getDigitCount(int n) {\\n        int digitCount[] = new int[10];\\n        while (n != 0) {\\n            digitCount[n % 10]++;\\n            n /= 10;\\n        }\\n        \\n        return digitCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485111,
                "title": "i-am-a-noob-got-1ms-solution",
                "content": "```\\nimport java.util.*;\\nclass Solution \\n{\\n    public boolean reorderedPowerOf2(int n) \\n    {\\n        if(n==1)\\n        {\\n            return true;\\n        }\\n        boolean flag = true;\\n        int length = String.valueOf(n).length();\\n        int k =1;\\n        int[] arr = func(n);\\n        while(flag = true)\\n        {\\n            k = k*2;\\n            int[] temp = func(k);\\n            if(Arrays. equals(temp,arr ))\\n            {\\n                return true;\\n            }    \\n            int p =String.valueOf(k).length();\\n            if(p>length)\\n            {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    public static int[] func(int n)\\n    {\\n        int[] arr = new int[10];\\n        while(n>0)\\n        {\\n            int digit = n%10;\\n            arr[digit]++;\\n            n = n/10;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution \\n{\\n    public boolean reorderedPowerOf2(int n) \\n    {\\n        if(n==1)\\n        {\\n            return true;\\n        }\\n        boolean flag = true;\\n        int length = String.valueOf(n).length();\\n        int k =1;\\n        int[] arr = func(n);\\n        while(flag = true)\\n        {\\n            k = k*2;\\n            int[] temp = func(k);\\n            if(Arrays. equals(temp,arr ))\\n            {\\n                return true;\\n            }    \\n            int p =String.valueOf(k).length();\\n            if(p>length)\\n            {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    public static int[] func(int n)\\n    {\\n        int[] arr = new int[10];\\n        while(n>0)\\n        {\\n            int digit = n%10;\\n            arr[digit]++;\\n            n = n/10;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484999,
                "title": "i-am-a-noob-but-1ms-solution",
                "content": "import java.util.;\\nclass Solution \\n{\\n\\tpublic boolean reorderedPowerOf2(int n) \\n    {\\n        if(n==1)\\n        {\\n            return true;\\n        }\\n        boolean flag = true;\\n        int length = String.valueOf(n).length();\\n        int k =1;\\n        int[] arr = func(n);\\n        while(flag = true)\\n        {\\n            k = k2;\\n            int[] temp = func(k);\\n            if(Arrays. equals(temp,arr ))\\n            {\\n                return true;\\n            }    \\n            int p =String.valueOf(k).length();\\n            if(p>length)\\n            {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    public static int[] func(int n)\\n    {\\n        int[] arr = new int[10];\\n        while(n>0)\\n        {\\n            int digit = n%10;\\n            arr[digit]++;\\n            n = n/10;\\n        }\\n        return arr;\\n    }\\n}",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution \\n{\\n\\tpublic boolean reorderedPowerOf2(int n) \\n    {\\n        if(n==1)\\n        {\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2484959,
                "title": "c-reordered-power-of-2",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        string s=to_string(n);\\n        sort(s.begin(),s.end());\\n        for(int i=0;i<=30;i++){\\n            string temp=\"\";\\n            int t=pow(2,i);\\n            temp=to_string(t);\\n            sort(temp.begin(),temp.end());\\n            if(temp==s)\\n                return true;\\n            \\n        }\\n        return false;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        string s=to_string(n);\\n        sort(s.begin(),s.end());\\n        for(int i=0;i<=30;i++){\\n            string temp=\"\";\\n            int t=pow(2,i);\\n            temp=to_string(t);\\n            sort(temp.begin(),temp.end());\\n            if(temp==s)\\n                return true;\\n            \\n        }\\n        return false;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2484863,
                "title": "0ms-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        int i,s=1;\\n        string a=to_string(n);\\n        sort(a.begin(),a.end());\\n        vector<string> v;\\n        string b;\\n        for(i=0;i<=29;i++)\\n        {\\n            b=to_string(s);\\n            v.push_back(b);\\n            s=s*2;\\n            sort(b.begin(),b.end());\\n            if(b==a)\\n                return true;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        int i,s=1;\\n        string a=to_string(n);\\n        sort(a.begin(),a.end());\\n        vector<string> v;\\n        string b;\\n        for(i=0;i<=29;i++)\\n        {\\n            b=to_string(s);\\n            v.push_back(b);\\n            s=s*2;\\n            sort(b.begin(),b.end());\\n            if(b==a)\\n                return true;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484734,
                "title": "c-easy-solution-clean-code-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        string num=to_string(n);\\n        sort(num.begin(),num.end());\\n        //cout<<num<<endl;\\n        //vector<string> hash;\\n        for(int i=0;i<=30;i++){\\n            //cout<<pow(2,i)<<endl;\\n            string temp=\"\";\\n            int t=pow(2,i);\\n            temp=to_string(t);\\n            sort(temp.begin(),temp.end());\\n            //cout<<temp<<endl;\\n            if(temp==num) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        string num=to_string(n);\\n        sort(num.begin(),num.end());\\n        //cout<<num<<endl;\\n        //vector<string> hash;\\n        for(int i=0;i<=30;i++){\\n            //cout<<pow(2,i)<<endl;\\n            string temp=\"\";\\n            int t=pow(2,i);\\n            temp=to_string(t);\\n            sort(temp.begin(),temp.end());\\n            //cout<<temp<<endl;\\n            if(temp==num) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2484719,
                "title": "80-faster-c-code-daily-leetcode-challenge-august-day-26",
                "content": "```\\nvector<map<int,int>> findarray(int nodigits){\\n    long long start=1;\\n    for(int i=1;i<nodigits;i++){\\n        start*=10;\\n    }\\n    long long end=start*10;\\n    long long start2=1;\\n    while(start2<start){\\n        start2*=2;\\n    }\\n   vector<map<int,int>> ans(100);\\n    int i=0;\\n    while(start2<=end){\\n        long long topush=start2;\\n        while(topush>0){\\n            int digito=topush%10;\\n            ans[i][digito]++;\\n            topush/=10;\\n        }\\n        i++;\\n        start2*=2;\\n    }\\n    return ans;\\n}    \\n```\\n```\\n    bool reorderedPowerOf2(int n) {\\n        int digits=0;\\n        long long num=n;\\n        map<int,int> original;\\n        while(num>0){\\n            int digito=num%10;\\n            original[digito]++;\\n            num/=10;\\n            digits++;\\n        }\\n        vector<map<int,int>> find=findarray(digits);\\n        for(int i=0;i<find.size();i++){\\n            if(find[i]==original){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvector<map<int,int>> findarray(int nodigits){\\n    long long start=1;\\n    for(int i=1;i<nodigits;i++){\\n        start*=10;\\n    }\\n    long long end=start*10;\\n    long long start2=1;\\n    while(start2<start){\\n        start2*=2;\\n    }\\n   vector<map<int,int>> ans(100);\\n    int i=0;\\n    while(start2<=end){\\n        long long topush=start2;\\n        while(topush>0){\\n            int digito=topush%10;\\n            ans[i][digito]++;\\n            topush/=10;\\n        }\\n        i++;\\n        start2*=2;\\n    }\\n    return ans;\\n}    \\n```\n```\\n    bool reorderedPowerOf2(int n) {\\n        int digits=0;\\n        long long num=n;\\n        map<int,int> original;\\n        while(num>0){\\n            int digito=num%10;\\n            original[digito]++;\\n            num/=10;\\n            digits++;\\n        }\\n        vector<map<int,int>> find=findarray(digits);\\n        for(int i=0;i<find.size();i++){\\n            if(find[i]==original){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2484686,
                "title": "c-detailed-explanation-tc-o-nlogn",
                "content": "**Two Approaches**\\n* Approach-1 -> Generating all the permutations for the digits of number n, and checking individually for the power of 2.\\n*  TC =Total Permutations of the digits i.e. (n)!\\n ```\\nclass Solution {\\n    bool twoPower(string digits){\\n        int num=stoi(digits);\\n        return (num & (num-1))==0;\\n    }\\n    bool check(string digits,int pos){\\n        if(pos==digits.size()){\\n            if(digits[0]!=\\'0\\'&&twoPower(digits)) {\\n                return true;\\n            }\\n            else return false;\\n        }\\n        for(int i=pos;i<digits.size();i++){\\n            swap(digits[pos],digits[i]);\\n            if(digits[0]!=\\'0\\'&&check(digits,pos+1)) return true;\\n            swap(digits[i],digits[pos]);\\n        }\\n        return false;\\n    }\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        return check(to_string(n),0);\\n    }\\n};\\n```\\n* Approach-2 -> Getting all the power of twos arranging their digits in increasing order and put them in map, convert n to string, sort it, check whether it belongs to that map or not.\\n* Let count of digits of given number=k, TC = O(32 * k * log(k)).\\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        unordered_map<string,bool> mp;\\n        for(int i=0;i<32;i++){\\n            int num= 1<<i;\\n            string s=to_string(num);\\n            sort(s.begin(),s.end());\\n            mp[s]=true;\\n        }\\n        string tc=to_string(n);\\n        sort(tc.begin(),tc.end());\\n        return mp.find(tc)!=mp.end();\\n    }\\n};\\n```",
                "solutionTags": [
                    "String",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    bool twoPower(string digits){\\n        int num=stoi(digits);\\n        return (num & (num-1))==0;\\n    }\\n    bool check(string digits,int pos){\\n        if(pos==digits.size()){\\n            if(digits[0]!=\\'0\\'&&twoPower(digits)) {\\n                return true;\\n            }\\n            else return false;\\n        }\\n        for(int i=pos;i<digits.size();i++){\\n            swap(digits[pos],digits[i]);\\n            if(digits[0]!=\\'0\\'&&check(digits,pos+1)) return true;\\n            swap(digits[i],digits[pos]);\\n        }\\n        return false;\\n    }\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        return check(to_string(n),0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        unordered_map<string,bool> mp;\\n        for(int i=0;i<32;i++){\\n            int num= 1<<i;\\n            string s=to_string(num);\\n            sort(s.begin(),s.end());\\n            mp[s]=true;\\n        }\\n        string tc=to_string(n);\\n        sort(tc.begin(),tc.end());\\n        return mp.find(tc)!=mp.end();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484665,
                "title": "java-simple-100-sweet-and-simple",
                "content": "**IF you LIKE it UPVOTE**\\n```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n    int Count[] = Count(n);\\n       \\n        for (int i = 0; i < 31; i++) {\\n            int power = (int)Math.pow(2,i);\\n            int[] PowerCount = Count(power);\\n            if (Equal(Count, PowerCount)) {\\n                return true;\\n            }\\n            \\n        }\\n        return false;\\n    }\\n\\n    private int[] Count(int n) { \\n        int Count[] = new int[10];\\n        while (n != 0) {\\n            Count[n % 10]++;\\n            n /= 10;\\n        }\\n        return Count;\\n    }\\n\\n    private boolean Equal(int ar1[], int ar2[]) {\\n        for (int i = 0; i < ar2.length; i++) {\\n            if (ar1[i] != ar2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n    int Count[] = Count(n);\\n       \\n        for (int i = 0; i < 31; i++) {\\n            int power = (int)Math.pow(2,i);\\n            int[] PowerCount = Count(power);\\n            if (Equal(Count, PowerCount)) {\\n                return true;\\n            }\\n            \\n        }\\n        return false;\\n    }\\n\\n    private int[] Count(int n) { \\n        int Count[] = new int[10];\\n        while (n != 0) {\\n            Count[n % 10]++;\\n            n /= 10;\\n        }\\n        return Count;\\n    }\\n\\n    private boolean Equal(int ar1[], int ar2[]) {\\n        for (int i = 0; i < ar2.length; i++) {\\n            if (ar1[i] != ar2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484537,
                "title": "easy-c-solution-using-vector-100-faster-than-others",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> solve(int n){\\n        //Storing occurence of n :-\\n        vector<int>v(10);\\n        while(n){\\n            v[n%10]++;\\n            n/=10;\\n        }\\n        return v;\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        if(n==1)return true;\\n        \\n        vector<int>v = solve(n);\\n        \\n        for(int i = 0;i<30;i++){\\n            // if(v == solve(pow(2,i)))return true;\\n            if(v == solve(1<<i))return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> solve(int n){\\n        //Storing occurence of n :-\\n        vector<int>v(10);\\n        while(n){\\n            v[n%10]++;\\n            n/=10;\\n        }\\n        return v;\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        if(n==1)return true;\\n        \\n        vector<int>v = solve(n);\\n        \\n        for(int i = 0;i<30;i++){\\n            // if(v == solve(pow(2,i)))return true;\\n            if(v == solve(1<<i))return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484532,
                "title": "c-code-with-comment",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        \\n        //Convert the integer to string\\n        string s=to_string(n);\\n        \\n        //Sort the string\\n        sort(s.begin(),s.end());\\n        \\n        //Now check for all power till 32 and covert all power into string and sort them\\n        //If we get any power of 2 string equal to s then return true\\n        for(int i=0;i<32;i++){\\n            int power_2=(1<<i);\\n            string compare=to_string(power_2);\\n            sort(compare.begin(),compare.end());\\n            if(compare==s)return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        \\n        //Convert the integer to string\\n        string s=to_string(n);\\n        \\n        //Sort the string\\n        sort(s.begin(),s.end());\\n        \\n        //Now check for all power till 32 and covert all power into string and sort them\\n        //If we get any power of 2 string equal to s then return true\\n        for(int i=0;i<32;i++){\\n            int power_2=(1<<i);\\n            string compare=to_string(power_2);\\n            sort(compare.begin(),compare.end());\\n            if(compare==s)return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484340,
                "title": "c-easy-solution",
                "content": "**c++ easy understanding code using a string sort_string function**\\n\\n\\n\\n    \\n   string sort_string(int n)\\n    {\\n       string str=to_string(n);//convert to array\\n       sort(str.begin(),str.end());//sort it    \\n\\t   return str;\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        string s=sort_string(n);// sort  the \\n        \\n        for(int i=0;i<30;i++)\\n        {\\n            string t=sort_string(1<<i);//sort the decimal form of the power of 2\\n            if(s==t)return true;//check if they are same or not\\n            \\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "**c++ easy understanding code using a string sort_string function**\\n\\n\\n\\n    \\n   string sort_string(int n)\\n    {\\n       string str=to_string(n);//convert to array\\n       sort(str.begin(),str.end());//sort it    \\n\\t   return str;\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        string s=sort_string(n);// sort  the \\n        \\n        for(int i=0;i<30;i++)\\n        {\\n            string t=sort_string(1<<i);//sort the decimal form of the power of 2\\n            if(s==t)return true;//check if they are same or not\\n            \\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2484279,
                "title": "100-faster-100-less-memory-than-submissions",
                "content": "![image](https://assets.leetcode.com/users/images/75551367-0224-4491-a7be-5fd53e52c224_1661530948.5126617.png)\\n\\n\\n```\\n    public bool ReorderedPowerOf2(int n) {\\n        int[] numbers = GetFrequencyArray(n);\\n        for(int i=0; i<31; i++)\\n        {\\n            int pow = (int)Math.Pow(2, i);\\n            int[] powerFrequencies = GetFrequencyArray(pow);\\n            if(Compare(numbers, powerFrequencies)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    private int[] GetFrequencyArray(int n)\\n    {\\n        int[] frequencies = new int[10];\\n        while(n>0)\\n        {\\n            frequencies[n%10]++;\\n            n /= 10;\\n        }\\n        return frequencies;\\n    }\\n    \\n    private bool Compare(int[] arrOne, int[] arrTwo)\\n    {\\n        for(int i=0; i<10; i++)\\n        {\\n            if(arrOne[i] != arrTwo[i]) return false;\\n        }\\n        return true;\\n    }  \\n```",
                "solutionTags": [],
                "code": "```\\n    public bool ReorderedPowerOf2(int n) {\\n        int[] numbers = GetFrequencyArray(n);\\n        for(int i=0; i<31; i++)\\n        {\\n            int pow = (int)Math.Pow(2, i);\\n            int[] powerFrequencies = GetFrequencyArray(pow);\\n            if(Compare(numbers, powerFrequencies)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    private int[] GetFrequencyArray(int n)\\n    {\\n        int[] frequencies = new int[10];\\n        while(n>0)\\n        {\\n            frequencies[n%10]++;\\n            n /= 10;\\n        }\\n        return frequencies;\\n    }\\n    \\n    private bool Compare(int[] arrOne, int[] arrTwo)\\n    {\\n        for(int i=0; i<10; i++)\\n        {\\n            if(arrOne[i] != arrTwo[i]) return false;\\n        }\\n        return true;\\n    }  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2484264,
                "title": "c-easy-and-simple-solution",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n**CLICK HERE AND SUBSCRIBE PLEASE (\\uD83D\\uDE42)->** [[CLCK HERE](https://www.youtube.com/channel/UCus2cmS0yQHmoszCRt9JeRQ)]\\n```\\n bool reorderedPowerOf2(int n) {\\n        vector<string>ans;\\n        string ndigit=to_string(n);\\n        \\n    \\n        sort(ndigit.begin(),ndigit.end());\\n        \\n        \\n        for(int i=0;i<31;i++){\\n            int p=pow(2,i);\\n            ans.push_back(to_string(p));\\n        }\\n        for(int i=0;i<ans.size();i++){\\n            sort(ans[i].begin(),ans[i].end());\\n        }\\n        for(int i=0;i<=30;i++){\\n            if(ans[i]==ndigit) return true;\\n        }\\n        return false;\\n    }\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n**CLICK HERE AND SUBSCRIBE PLEASE (\\uD83D\\uDE42)->** [[CLCK HERE](https://www.youtube.com/channel/UCus2cmS0yQHmoszCRt9JeRQ)]",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n bool reorderedPowerOf2(int n) {\\n        vector<string>ans;\\n        string ndigit=to_string(n);\\n        \\n    \\n        sort(ndigit.begin(),ndigit.end());\\n        \\n        \\n        for(int i=0;i<31;i++){\\n            int p=pow(2,i);\\n            ans.push_back(to_string(p));\\n        }\\n        for(int i=0;i<ans.size();i++){\\n            sort(ans[i].begin(),ans[i].end());\\n        }\\n        for(int i=0;i<=30;i++){\\n            if(ans[i]==ndigit) return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2484235,
                "title": "javascript-soln",
                "content": "```\\nvar reorderedPowerOf2 = function(n) {\\n    const max = 10**9\\n    let power = 0;\\n    let pvalue = 0 \\n    const input = `${n}`.split(\\'\\').sort((a, b) =>a -b).join(\\'\\')\\n    while(pvalue <= max ) {\\n        pvalue = 2**power\\n        power++\\n        const p = `${pvalue}`.split(\\'\\').sort((a, b) =>a -b).join(\\'\\')\\n        if(p === input) { return true }  \\n        if(p.length > input.length) { return false }\\n    }\\n    return false\\n};",
                "solutionTags": [],
                "code": "```\\nvar reorderedPowerOf2 = function(n) {\\n    const max = 10**9\\n    let power = 0;\\n    let pvalue = 0 \\n    const input = `${n}`.split(\\'\\').sort((a, b) =>a -b).join(\\'\\')\\n    while(pvalue <= max ) {\\n        pvalue = 2**power\\n        power++\\n        const p = `${pvalue}`.split(\\'\\').sort((a, b) =>a -b).join(\\'\\')\\n        if(p === input) { return true }  \\n        if(p.length > input.length) { return false }\\n    }\\n    return false\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2484183,
                "title": "python-25ms-beat-90",
                "content": "1. create a list of all possible power of 2 under 10^9 by utilizing binary representation of integers.\\n2. an integer is power of 2 iff its representation in binary starts with \\'1\\' and trailed with all \\'0\\'s.\\n3. utilizing the counter function to compare the frequency of characters with that of each element in the list we built in step 1. \\n```\\nclass Solution(object):\\n    def reorderedPowerOf2(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: bool\\n        \"\"\"\\n        n=str(n)\\n        counter=collections.Counter(n)\\n        ## create the lst of all possible power of 2 under 10**9\\n        lst=[]\\n        for i in range(0,99):\\n            s=\\'1\\'+\\'0\\'*i\\n            m=int(s,2)\\n            if m>10**9:\\n                break\\n            lst.append(str(m))\\n        ##\\n        for i in lst:\\n            if len(i)!=len(n):\\n                continue\\n            counter2=collections.Counter(i)\\n            if counter == counter2:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def reorderedPowerOf2(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: bool\\n        \"\"\"\\n        n=str(n)\\n        counter=collections.Counter(n)\\n        ## create the lst of all possible power of 2 under 10**9\\n        lst=[]\\n        for i in range(0,99):\\n            s=\\'1\\'+\\'0\\'*i\\n            m=int(s,2)\\n            if m>10**9:\\n                break\\n            lst.append(str(m))\\n        ##\\n        for i in lst:\\n            if len(i)!=len(n):\\n                continue\\n            counter2=collections.Counter(i)\\n            if counter == counter2:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484172,
                "title": "python",
                "content": "```\\nimport itertools\\n\\nclass Solution:\\n    def isPowerOfTwo(self, n):\\n        while n%2 == 0:\\n            n /= 2\\n        return 1 == n\\n    \\n    def getAllPermutations(self, n):\\n        permutations = []\\n        for num in itertools.permutations(list(n)):\\n            permutations.append(int(\"\".join(num)))\\n        return permutations\\n    \\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        n = str(n)\\n        for num in self.getAllPermutations(n):\\n            if(self.isPowerOfTwo(num) and len(n) == len(str(num))): return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nimport itertools\\n\\nclass Solution:\\n    def isPowerOfTwo(self, n):\\n        while n%2 == 0:\\n            n /= 2\\n        return 1 == n\\n    \\n    def getAllPermutations(self, n):\\n        permutations = []\\n        for num in itertools.permutations(list(n)):\\n            permutations.append(int(\"\".join(num)))\\n        return permutations\\n    \\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        n = str(n)\\n        for num in self.getAllPermutations(n):\\n            if(self.isPowerOfTwo(num) and len(n) == len(str(num))): return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484030,
                "title": "1-ms-faster-than-100-00-of-java",
                "content": "```\\npublic boolean reorderedPowerOf2(int n) {\\n\\t\\tif (n == 1) return true;\\n\\t\\tboolean isCorrect = false;\\n\\t\\t\\n\\t\\tint[] valCountArr = new int[10];\\n\\t\\tlong count = 0;\\n\\t\\tfor(char c : String.valueOf(n).toCharArray()) {\\n\\t\\t\\tvalCountArr[c-\\'0\\']++;\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\t\\n\\t\\tint target = 2;\\n\\t\\t\\n\\t\\twhile (String.valueOf(target).length() <= count) {\\n\\t\\t\\t\\n\\t\\t\\tif(String.valueOf(target).length() < count) {\\n\\t\\t\\t\\ttarget *= 2;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tint[] targetArr = new int[10];\\n\\t\\t\\t\\n\\t\\t\\tfor(char c : String.valueOf(target).toCharArray())\\n\\t\\t\\t\\ttargetArr[c-\\'0\\']++;\\n\\t\\t\\t\\n\\t\\t\\tfor(int i = 0; i < 10; i++) {\\n\\t\\t\\t\\tif (targetArr[i] == valCountArr[i]) {\\n\\t\\t\\t\\t\\tif (i == 9)\\n\\t\\t\\t\\t\\t\\tisCorrect = true;\\n\\t\\t\\t\\t}else break;\\n\\t\\t\\t}\\n\\t\\t\\tif(isCorrect) break;\\n\\t\\t\\ttarget *= 2;\\n\\t\\t}\\n\\t\\treturn isCorrect;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean reorderedPowerOf2(int n) {\\n\\t\\tif (n == 1) return true;\\n\\t\\tboolean isCorrect = false;\\n\\t\\t\\n\\t\\tint[] valCountArr = new int[10];\\n\\t\\tlong count = 0;\\n\\t\\tfor(char c : String.valueOf(n).toCharArray()) {\\n\\t\\t\\tvalCountArr[c-\\'0\\']++;\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\t\\n\\t\\tint target = 2;\\n\\t\\t\\n\\t\\twhile (String.valueOf(target).length() <= count) {\\n\\t\\t\\t\\n\\t\\t\\tif(String.valueOf(target).length() < count) {\\n\\t\\t\\t\\ttarget *= 2;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tint[] targetArr = new int[10];\\n\\t\\t\\t\\n\\t\\t\\tfor(char c : String.valueOf(target).toCharArray())\\n\\t\\t\\t\\ttargetArr[c-\\'0\\']++;\\n\\t\\t\\t\\n\\t\\t\\tfor(int i = 0; i < 10; i++) {\\n\\t\\t\\t\\tif (targetArr[i] == valCountArr[i]) {\\n\\t\\t\\t\\t\\tif (i == 9)\\n\\t\\t\\t\\t\\t\\tisCorrect = true;\\n\\t\\t\\t\\t}else break;\\n\\t\\t\\t}\\n\\t\\t\\tif(isCorrect) break;\\n\\t\\t\\ttarget *= 2;\\n\\t\\t}\\n\\t\\treturn isCorrect;\\n\\t}",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1754009,
                "content": [
                    {
                        "username": "user9132S",
                        "content": "when I run the test case \"46\", the solution should be \"false\", but the expected is \"true\".\\nI don\\'t understand why it should be true, since the binary representation of \"46\" is 101110, and its clear that we can\\'t reorder this number to be a power of 2.... what I\\'m missing here?\\n\\n(I\\'m solving in C)"
                    },
                    {
                        "username": "user9132S",
                        "content": "[@lowchhector](/lowchhector) Thank you!"
                    },
                    {
                        "username": "lowchhector",
                        "content": "im thinking 46 can be reordered to 64 which is a power of 2"
                    },
                    {
                        "username": "shakti_2003",
                        "content": "we can not represent 46 as a power of 2 but it shows true for 46 .. how ????"
                    },
                    {
                        "username": "EgoriiSt",
                        "content": "if you reorder 46 you get 64 which is 2^6"
                    }
                ]
            },
            {
                "id": 1956852,
                "content": [
                    {
                        "username": "user9132S",
                        "content": "when I run the test case \"46\", the solution should be \"false\", but the expected is \"true\".\\nI don\\'t understand why it should be true, since the binary representation of \"46\" is 101110, and its clear that we can\\'t reorder this number to be a power of 2.... what I\\'m missing here?\\n\\n(I\\'m solving in C)"
                    },
                    {
                        "username": "user9132S",
                        "content": "[@lowchhector](/lowchhector) Thank you!"
                    },
                    {
                        "username": "lowchhector",
                        "content": "im thinking 46 can be reordered to 64 which is a power of 2"
                    },
                    {
                        "username": "shakti_2003",
                        "content": "we can not represent 46 as a power of 2 but it shows true for 46 .. how ????"
                    },
                    {
                        "username": "EgoriiSt",
                        "content": "if you reorder 46 you get 64 which is 2^6"
                    }
                ]
            }
        ]
    }
]