[
    {
        "title": "Remove Nth Node From End of List",
        "question_content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n&nbsp;\nExample 1:\n\nInput: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]\n\nExample 2:\n\nInput: head = [1], n = 1\nOutput: []\n\nExample 3:\n\nInput: head = [1,2], n = 1\nOutput: [1]\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the list is sz.\n\t1 <= sz <= 30\n\t0 <= Node.val <= 100\n\t1 <= n <= sz\n\n&nbsp;\nFollow up: Could you do this in one pass?",
        "solutions": [
            {
                "id": 1164542,
                "title": "js-python-java-c-easy-two-pointer-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nWith a singly linked list, the _only_ way to find the end of the list, and thus the **n**\\'th node from the end, is to actually iterate all the way to the end. The challenge here is attemping to find the solution in only one pass. A naive approach here might be to store pointers to each node in an array, allowing us to calculate the **n**\\'th from the end once we reach the end, but that would take **O(M) extra space**, where **M** is the length of the linked list.\\n\\nA slightly less naive approach would be to only store only the last **n+1** node pointers in the array. This could be achieved by overwriting the elements of the storage array in circlular fashion as we iterate through the list. This would lower the **space complexity** to **O(N+1)**.\\n\\nIn order to solve this problem in only one pass and **O(1) extra space**, however, we would need to find a way to _both_ reach the end of the list with one pointer _and also_ reach the **n**\\'th node from the end simultaneously with a second pointer.\\n\\nTo do that, we can simply stagger our two pointers by **n** nodes by giving the first pointer (**fast**) a head start before starting the second pointer (**slow**). Doing this will cause **slow** to reach the **n**\\'th node from the end at the same time that **fast** reaches the end.\\n\\n![Visual 1](https://i.imgur.com/BSiLKj0.png)\\n\\nSince we will need access to the node _before_ the target node in order to remove the target node, we can use **fast.next == null** as our exit condition, rather than **fast == null**, so that we stop one node earlier.\\n\\nThis will unfortunately cause a problem when **n** is the same as the length of the list, which would make the first node the target node, and thus make it impossible to find the node _before_ the target node. If that\\'s the case, however, we can just **return head.next** without needing to stitch together the two sides of the target node.\\n\\nOtherwise, once we succesfully find the node _before_ the target, we can then stitch it together with the node _after_ the target, and then **return head**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThere are only minor differences between the code of all four languages.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **60ms / 40.6MB** (beats 100% / 13%).\\n```javascript\\nvar removeNthFromEnd = function(head, n) {\\n    let fast = head, slow = head\\n    for (let i = 0; i < n; i++) fast = fast.next\\n    if (!fast) return head.next\\n    while (fast.next) fast = fast.next, slow = slow.next\\n    slow.next = slow.next.next\\n    return head\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **28ms / 13.9MB** (beats 92% / 99%).\\n```python\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        fast, slow = head, head\\n        for _ in range(n): fast = fast.next\\n        if not fast: return head.next\\n        while fast.next: fast, slow = fast.next, slow.next\\n        slow.next = slow.next.next\\n        return head\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 36.5MB** (beats 100% / 97%).\\n```java\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fast = head, slow = head;\\n        for (int i = 0; i < n; i++) fast = fast.next;\\n        if (fast == null) return head.next;\\n        while (fast.next != null) {\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 10.6MB** (beats 100% / 93%).\\n```c++\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n        for (int i = 0; i < n; i++) fast = fast->next;\\n        if (!fast) return head->next;\\n        while (fast->next) fast = fast->next, slow = slow->next;\\n        slow->next = slow->next->next;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar removeNthFromEnd = function(head, n) {\\n    let fast = head, slow = head\\n    for (let i = 0; i < n; i++) fast = fast.next\\n    if (!fast) return head.next\\n    while (fast.next) fast = fast.next, slow = slow.next\\n    slow.next = slow.next.next\\n    return head\\n};\\n```\n```python\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        fast, slow = head, head\\n        for _ in range(n): fast = fast.next\\n        if not fast: return head.next\\n        while fast.next: fast, slow = fast.next, slow.next\\n        slow.next = slow.next.next\\n        return head\\n```\n```java\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fast = head, slow = head;\\n        for (int i = 0; i < n; i++) fast = fast.next;\\n        if (fast == null) return head.next;\\n        while (fast.next != null) {\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n        for (int i = 0; i < n; i++) fast = fast->next;\\n        if (!fast) return head->next;\\n        while (fast->next) fast = fast->next, slow = slow->next;\\n        slow->next = slow->next->next;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8804,
                "title": "simple-java-solution-in-one-pass",
                "content": "A one pass solution can be done using  pointers. Move one pointer **fast** -->  **n+1** places forward, to maintain a gap of n between the two pointers and then move both at the same speed. Finally, when the fast pointer reaches the end, the slow pointer will be **n+1** places behind - just the right spot for it to be able to skip the next node.\\n\\nSince the question gives that **n** is valid, not too many checks have to be put in place. Otherwise, this would be necessary.\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n        ListNode start = new ListNode(0);\\n        ListNode slow = start, fast = start;\\n        slow.next = head;\\n        \\n        //Move fast in front so that the gap between slow and fast becomes n\\n        for(int i=1; i<=n+1; i++)   {\\n            fast = fast.next;\\n        }\\n        //Move fast to the end, maintaining the gap\\n        while(fast != null) {\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        //Skip the desired node\\n        slow.next = slow.next.next;\\n        return start.next;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "A one pass solution can be done using  pointers. Move one pointer **fast** -->  **n+1** places forward, to maintain a gap of n between the two pointers and then move both at the same speed. Finally, when the fast pointer reaches the end, the slow pointer will be **n+1** places behind - just the right spot for it to be able to skip the next node.\\n\\nSince the question gives that **n** is valid, not too many checks have to be put in place. Otherwise, this would be necessary.\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n        ListNode start = new ListNode(0);\\n        ListNode slow = start, fast = start;\\n        slow.next = head;\\n        \\n        //Move fast in front so that the gap between slow and fast becomes n\\n        for(int i=1; i<=n+1; i++)   {\\n            fast = fast.next;\\n        }\\n        //Move fast to the end, maintaining the gap\\n        while(fast != null) {\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        //Skip the desired node\\n        slow.next = slow.next.next;\\n        return start.next;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 8802,
                "title": "3-short-python-solutions",
                "content": "**Value-Shifting - AC in 64 ms**\\n\\nMy first solution is \"cheating\" a little. Instead of really removing the nth *node*, I remove the nth *value*. I recursively determine the indexes (counting from back), then shift the values for all indexes larger than n, and then always drop the head.\\n\\n    class Solution:\\n        def removeNthFromEnd(self, head, n):\\n            def index(node):\\n                if not node:\\n                    return 0\\n                i = index(node.next) + 1\\n                if i > n:\\n                    node.next.val = node.val\\n                return i\\n            index(head)\\n            return head.next\\n\\n---\\n\\n**Index and Remove - AC in 56 ms**\\n\\nIn this solution I recursively determine the indexes again, but this time my helper function removes the nth node. It returns two values. The index, as in my first solution, and the possibly changed head of the remaining list.\\n\\n    class Solution:\\n        def removeNthFromEnd(self, head, n):\\n            def remove(head):\\n                if not head:\\n                    return 0, head\\n                i, head.next = remove(head.next)\\n                return i+1, (head, head.next)[i+1 == n]\\n            return remove(head)[1]\\n\\n---\\n\\n**n ahead - AC in 48 ms**\\n\\nThe standard solution, but without a dummy extra node. Instead, I simply handle the special case of removing the head right after the fast cursor got its head start.\\n\\n    class Solution:\\n        def removeNthFromEnd(self, head, n):\\n            fast = slow = head\\n            for _ in range(n):\\n                fast = fast.next\\n            if not fast:\\n                return head.next\\n            while fast.next:\\n                fast = fast.next\\n                slow = slow.next\\n            slow.next = slow.next.next\\n            return head",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Value-Shifting - AC in 64 ms**\\n\\nMy first solution is \"cheating\" a little. Instead of really removing the nth *node*, I remove the nth *value*. I recursively determine the indexes (counting from back), then shift the values for all indexes larger than n, and then always drop the head.\\n\\n    class Solution:\\n        def removeNthFromEnd(self, head, n):\\n            def index(node):\\n                if not node:\\n                    return 0\\n                i = index(node.next) + 1\\n                if i > n:\\n                    node.next.val = node.val\\n                return i\\n            index(head)\\n            return head.next\\n\\n---\\n\\n**Index and Remove - AC in 56 ms**\\n\\nIn this solution I recursively determine the indexes again, but this time my helper function removes the nth node. It returns two values. The index, as in my first solution, and the possibly changed head of the remaining list.\\n\\n    class Solution:\\n        def removeNthFromEnd(self, head, n):\\n            def remove(head):\\n                if not head:\\n                    return 0, head\\n                i, head.next = remove(head.next)\\n                return i+1, (head, head.next)[i+1 == n]\\n            return remove(head)[1]\\n\\n---\\n\\n**n ahead - AC in 48 ms**\\n\\nThe standard solution, but without a dummy extra node. Instead, I simply handle the special case of removing the head right after the fast cursor got its head start.\\n\\n    class Solution:\\n        def removeNthFromEnd(self, head, n):\\n            fast = slow = head\\n            for _ in range(n):\\n                fast = fast.next\\n            if not fast:\\n                return head.next\\n            while fast.next:\\n                fast = fast.next\\n                slow = slow.next\\n            slow.next = slow.next.next\\n            return head",
                "codeTag": "Java"
            },
            {
                "id": 1164537,
                "title": "short-simple-one-pass-solution-w-explanation-beats-100-no-dummy-node-required",
                "content": "This problem is very similar to the **[1721. Swapping Nodes in a Linked List](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/)** , just that we have to **remove** the kth node from the end instead of swapping it.\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (One-Pointer, Two-Pass)***\\n\\nThis approach is very intuitive and easy to get. \\n\\n* We just iterate in the first-pass to find the length of the linked list - **`len`**.\\n\\n* In the next pass, iterate **`len - n - 1`** nodes from start and delete the next node (which would be *`nth`* node from end).\\n\\n---\\n\\n**C++**\\n```\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\tListNode* iter = head;\\n\\tint len = 0, i = 1;\\n\\twhile(iter) iter = iter -> next, len++;    // finding the length of linked list\\n\\tif(len == n) return head -> next;          // if head itself is to be deleted, just return head -> next\\n\\tfor(iter = head; i < len - n; i++) iter = iter -> next; // iterate first len-n nodes\\n\\titer -> next = iter -> next -> next;      // remove the nth node from the end\\n\\treturn head;\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n\\tptr, length = head, 0\\n\\twhile ptr:\\n\\t\\tptr, length = ptr.next, length + 1\\n\\tif length == n : return head.next\\n\\tptr = head\\n\\tfor i in range(1, length - n):\\n\\t\\tptr = ptr.next\\n\\tptr.next = ptr.next.next\\n\\treturn head\\n```\\n\\n\\n***Time Complexity :*** **`O(N)`**, where, `N` is the number of nodes in the given list. \\n***Space Complexity :*** **`O(1)`**, since only constant space is used.\\n\\n---\\n---\\n\\n\\u2714\\uFE0F ***Solution (Two-Pointer, One-Pass)***\\n\\nWe are required to remove the nth node from the end of list. For this, we need to traverse *`N - n`* nodes from the start of the list, where *`N`* is the length of linked list. We can do this in one-pass as follows -\\n\\n* Let\\'s assign two pointers - **`fast`** and **`slow`** to head. We will first iterate for *`n`* nodes from start using the *`fast`* pointer. \\n\\n* Now, between the *`fast`*  and *`slow`* pointers, **there is a gap of `n` nodes**. Now, just Iterate and increment both the pointers till `fast` reaches the last node. The gap between `fast` and `slow` is still of `n` nodes, meaning that **`slow` is nth node from the last node (which currently is `fast`)**.\\n\\n```\\nFor eg. let the list be 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9, and n = 4.\\n\\n1. 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> null\\n   ^slow               ^fast\\n   |<--gap of n nodes-->|\\n \\n => Now traverse till fast reaches end\\n \\n 2. 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> null\\n                        ^slow               ^fast\\n                        |<--gap of n nodes-->|\\n\\t\\t\\t\\t\\t\\t\\n\\'slow\\' is at (n+1)th node from end.\\nSo just delete nth node from end by assigning slow -> next as slow -> next -> next (which would remove nth node from end of list).\\n```\\n\\n * Since we have to **delete the nth node from end of list** (And not nth from the last of list!), we just delete the next node to **`slow`** pointer and return the head.\\n\\n---\\n\\n**C++**\\n```\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\tListNode *fast = head, *slow = head;\\n\\twhile(n--) fast = fast -> next;      // iterate first n nodes using fast\\n\\tif(!fast) return head -> next;       // if fast is already null, it means we have to delete head itself. So, just return next of head\\n\\twhile(fast -> next)                  // iterate till fast reaches the last node of list\\n\\t\\tfast = fast -> next, slow = slow -> next;            \\n\\tslow -> next = slow -> next -> next; // remove the nth node from last\\n\\treturn head;\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n\\tfast = slow = head\\n\\tfor i in range(n):\\n\\t\\tfast = fast.next\\n\\tif not fast: return head.next\\n\\twhile fast.next:\\n\\t\\tfast, slow = fast.next, slow.next\\n\\tslow.next = slow.next.next\\n\\treturn head\\n```\\n\\n\\n\\n***Time Complexity :*** **`O(N)`**, where, `N` is the number of nodes in the given list. Although, the time complexity is same as above solution, we have reduced the constant factor in it to half.\\n***Space Complexity :*** **`O(1)`**, since only constant space is used.\\n\\n---\\n\\n**Note :** The Problem only asks us to **remove the node from the linked list and not delete it**. A good question to ask in an interview for this problem would be whether we just need to remove the node from linked list or completely delete it from the memory. Since it has not been stated in this problem if the node is required somewhere else later on, its better to just remove the node from linked list as asked.\\n\\nIf we want to delete the node altogether, then we can just free its memory and point it to NULL before returning from the function.\\n\\n\\n---\\n---\\n\\n*Best Runtime -*\\n\\n<table><tr><td><img src=https://assets.leetcode.com/users/images/6c81d074-139d-4de5-96f5-5943f62a2cca_1618736585.2373421.png /></td></tr></table>\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any questions or mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\tListNode* iter = head;\\n\\tint len = 0, i = 1;\\n\\twhile(iter) iter = iter -> next, len++;    // finding the length of linked list\\n\\tif(len == n) return head -> next;          // if head itself is to be deleted, just return head -> next\\n\\tfor(iter = head; i < len - n; i++) iter = iter -> next; // iterate first len-n nodes\\n\\titer -> next = iter -> next -> next;      // remove the nth node from the end\\n\\treturn head;\\n}\\n```\n```\\ndef removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n\\tptr, length = head, 0\\n\\twhile ptr:\\n\\t\\tptr, length = ptr.next, length + 1\\n\\tif length == n : return head.next\\n\\tptr = head\\n\\tfor i in range(1, length - n):\\n\\t\\tptr = ptr.next\\n\\tptr.next = ptr.next.next\\n\\treturn head\\n```\n```\\nFor eg. let the list be 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9, and n = 4.\\n\\n1. 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> null\\n   ^slow               ^fast\\n   |<--gap of n nodes-->|\\n \\n => Now traverse till fast reaches end\\n \\n 2. 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> null\\n                        ^slow               ^fast\\n                        |<--gap of n nodes-->|\\n\\t\\t\\t\\t\\t\\t\\n\\'slow\\' is at (n+1)th node from end.\\nSo just delete nth node from end by assigning slow -> next as slow -> next -> next (which would remove nth node from end of list).\\n```\n```\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\tListNode *fast = head, *slow = head;\\n\\twhile(n--) fast = fast -> next;      // iterate first n nodes using fast\\n\\tif(!fast) return head -> next;       // if fast is already null, it means we have to delete head itself. So, just return next of head\\n\\twhile(fast -> next)                  // iterate till fast reaches the last node of list\\n\\t\\tfast = fast -> next, slow = slow -> next;            \\n\\tslow -> next = slow -> next -> next; // remove the nth node from last\\n\\treturn head;\\n}\\n```\n```\\ndef removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n\\tfast = slow = head\\n\\tfor i in range(n):\\n\\t\\tfast = fast.next\\n\\tif not fast: return head.next\\n\\twhile fast.next:\\n\\t\\tfast, slow = fast.next, slow.next\\n\\tslow.next = slow.next.next\\n\\treturn head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1037986,
                "title": "python-two-pointer-solution-with-comments-easy-to-understand",
                "content": "Please upvote once you get this :)\\n```\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        fast = head\\n        slow = head\\n        # advance fast to nth position\\n        for i in range(n):\\n            fast = fast.next\\n            \\n        if not fast:\\n            return head.next\\n        # then advance both fast and slow now they are nth postions apart\\n        # when fast gets to None, slow will be just before the item to be deleted\\n        while fast.next:\\n            slow = slow.next\\n            fast = fast.next\\n        # delete the node\\n        slow.next = slow.next.next\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        fast = head\\n        slow = head\\n        # advance fast to nth position\\n        for i in range(n):\\n            fast = fast.next\\n            \\n        if not fast:\\n            return head.next\\n        # then advance both fast and slow now they are nth postions apart\\n        # when fast gets to None, slow will be just before the item to be deleted\\n        while fast.next:\\n            slow = slow.next\\n            fast = fast.next\\n        # delete the node\\n        slow.next = slow.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8812,
                "title": "my-short-c-solution",
                "content": "    class Solution\\n    {\\n    public:\\n        ListNode* removeNthFromEnd(ListNode* head, int n)\\n        {\\n            ListNode** t1 = &head, *t2 = head;\\n            for(int i = 1; i < n; ++i)\\n            {\\n                t2 = t2->next;\\n            }\\n            while(t2->next != NULL)\\n            {\\n                t1 = &((*t1)->next);\\n                t2 = t2->next;\\n            }\\n            *t1 = (*t1)->next;\\n            return head;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n    public:\\n        ListNode* removeNthFromEnd(ListNode* head, int n)\\n        {\\n            ListNode** t1 = &head, *t2 = head;\\n            for(int i = 1; i < n; ++i)\\n            {\\n                t2 = t2->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 8843,
                "title": "c-solution-easy-to-understand-with-explanations",
                "content": "<h1>Renewed Solution</h1>\\n\\nThe difference between the final node and the `to_be_delete` node is N. And here the assumption is that n is <b>always</b> valid.\\n\\n`fast` pointer points to the node which is N step away from the `to_be_delete` node.<br>\\n`slow` pointer points to the `to_be_delete` node.\\n\\nThe algorithms is described as below:\\n\\n<b>Firstly</b>, move `fast` pointer N step forward.<br>\\n<b>Secondly</b>,move `fast` and `slow` pointers simultaneously <b>one step a time</b> forward till the `fast` pointer reach the end, which will cause the `slow` pointer points to the previous node of the `to_be_delete` node.\\n\\n<b>Finally</b>, `slow->next = slow->next->next`.\\n\\n    ListNode *removeNthFromEnd(ListNode *head, int n) \\n    {\\n        if (!head)\\n            return nullptr;\\n    \\n        ListNode new_head(-1);\\n        new_head.next = head;\\n\\n        ListNode *slow = &new_head, *fast = &new_head;\\n\\n        for (int i = 0; i < n; i++)\\n            fast = fast->next;\\n\\n        while (fast->next) \\n        {\\n            fast = fast->next;\\n            slow = slow->next;\\n        }\\n\\n        ListNode *to_de_deleted = slow->next;\\n        slow->next = slow->next->next;\\n        \\n        delete to_be_deleted;\\n\\n        return new_head.next;\\n    }\\n**Fixed : Added code for deleting the N-th node.**",
                "solutionTags": [
                    "C++"
                ],
                "code": "<h1>Renewed Solution</h1>\\n\\nThe difference between the final node and the `to_be_delete` node is N. And here the assumption is that n is <b>always</b> valid.\\n\\n`fast` pointer points to the node which is N step away from the `to_be_delete` node.<br>\\n`slow` pointer points to the `to_be_delete` node.\\n\\nThe algorithms is described as below:\\n\\n<b>Firstly</b>, move `fast` pointer N step forward.<br>\\n<b>Secondly</b>,move `fast` and `slow` pointers simultaneously <b>one step a time</b> forward till the `fast` pointer reach the end, which will cause the `slow` pointer points to the previous node of the `to_be_delete` node.\\n\\n<b>Finally</b>, `slow->next = slow->next->next`.\\n\\n    ListNode *removeNthFromEnd(ListNode *head, int n) \\n    {\\n        if (!head)\\n            return nullptr;\\n    \\n        ListNode new_head(-1);\\n        new_head.next = head;\\n\\n        ListNode *slow = &new_head, *fast = &new_head;\\n\\n        for (int i = 0; i < n; i++)\\n            fast = fast->next;\\n\\n        while (fast->next) \\n        {\\n            fast = fast->next;\\n            slow = slow->next;\\n        }\\n\\n        ListNode *to_de_deleted = slow->next;\\n        slow->next = slow->next->next;\\n        \\n        delete to_be_deleted;\\n\\n        return new_head.next;\\n    }\\n**Fixed : Added code for deleting the N-th node.**",
                "codeTag": "Unknown"
            },
            {
                "id": 589304,
                "title": "clear-java-solution-with-detailed-explanation",
                "content": "ok lets do this!!\\nso we are given a linked list and an number \\'n\\'\\nthis n is the number of root from last which needs to be removed!!\\nfor example\\n1->2->3->4->5->6->7\\nn=3\\nmeans we have to delete the 3rd node from the last(5th node from the beginning).\\nnow that the question is clear !\\n\\nlets move to the answer!\\npiece of advice-whenever you see a linked list removal type question ,always make a dummy node at the beginning!\\nanyways!\\n\\nLOGIC-\\n1>we keep two pointer slow and fast(both move one at a time)both initially at start of list(at the dummy node)\\n2>we move the fast to n+1 places away from the slow pointer\\n3>we then traverse the list we check if fast is equal to null or not,if it is null we know that the slow pointer has reached just one node  before the node we need to delete!\\n4>then we slow.next=slow.next.next!\\n\\nshould we do a dry run!\\nwhy not!\\nsuppose:\\n1->2->3->4->5->6\\nn=2\\nmake a dummy node with val=0;(we call this start)\\nso now our list looks like\\n0->1->2->3->4->5->6\\nslow ,start , fast all are pointing to 0 valued node!\\nafter executing step 2 of our algorithm we have \\nslow and start still at 0\\nbut fast is at node with val 3;\\nnow we execute step 3\\ndifferent positions of slow and fast is shown below!\\n[slow=1,fast=4]->[slow=2,fast=5]->[slow=3,fast=6]->[slow=4,fast=null]\\nwow!!slow have reached  one node before out target node\\nnow just do slow.next=slow.next.next;\\n\\ndo a couple of dry runs on your own to get the logic!\\n```\\npublic ListNode removeNthFromEnd(ListNode head, int n) {\\n    \\n    ListNode start = new ListNode(0);\\n    ListNode slow = start, fast = start;\\n    start.next = head;\\n    \\n    \\n    for(int i=1; i<=n+1; i++)   {\\n        fast = fast.next;\\n    }\\n    \\n    while(fast != null) {\\n        slow = slow.next;\\n        fast = fast.next;\\n    }\\n\\n    slow.next = slow.next.next;\\n    return start.next;\\n}\\n```\\n\\nhope it helps!\\nupvote the answer if you like it so that more people can benefit !\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic ListNode removeNthFromEnd(ListNode head, int n) {\\n    \\n    ListNode start = new ListNode(0);\\n    ListNode slow = start, fast = start;\\n    start.next = head;\\n    \\n    \\n    for(int i=1; i<=n+1; i++)   {\\n        fast = fast.next;\\n    }\\n    \\n    while(fast != null) {\\n        slow = slow.next;\\n        fast = fast.next;\\n    }\\n\\n    slow.next = slow.next.next;\\n    return start.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3492814,
                "title": "beats-100-full-proper-explanation-with-images",
                "content": "# Intuition\\nwe can find the nth node just by one traversal by using two pointer approach.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTake two dummy nodes, who\\u2019s next will be pointing to the head.\\nTake another node to store the head, initially,s a dummy node(start), and the next node will be pointing to the head. The reason why we are using this extra dummy node is that there is an edge case. If the node is equal to the length of the LinkedList, then this slow will point to slow\\u2019s next\\u2192 next. And we can say our dummy start node will be broken and will be connected to the slow next\\u2192 next.\\n\\nStart traversing until the fast pointer reaches the nth node.\\n![image.png](https://assets.leetcode.com/users/images/6d30920b-bf59-4564-897d-869a54148190_1683371160.3817167.png)\\n\\nNow start traversing by one step both of the pointers until the fast pointers reach the end.\\n    \\n![image.png](https://assets.leetcode.com/users/images/6e6e1af9-8863-4eff-988c-decc91e86746_1683371181.7739182.png)\\n\\nWhen the traversal is done, just do the deleting part. Make slow pointers next to the next of the slow pointer to ignore/disconnect the given node.\\n![image.png](https://assets.leetcode.com/users/images/8fd772c7-a44b-4569-99bd-293d4c5dcd32_1683371203.3690717.png)\\n\\n\\nLast, return to the next start.\\nDry Run:  We will be taking the first example for the dry run, so, the LinkedList is [1,2,3,4,5] and the node which has to be deleted is 2 from the last. For the first time, fast ptr starts traversing from node 1 and reaches 2, as it traverses for node number 2, then the slow ptr starts increasing one, and as well as the fast ptr until it reaches the end.\\n\\n1st traversal : fast=3, slow=1\\n2nd traversal : fast=4, slow=2\\n3rd traversal : fast=5, slow=3\\nNow, the slow->next->next will be pointed to the slow->next\\n\\nSo , the new linked list will be [1,2,3,5]\\n\\nNote that the above approach is provided by Striver on Youtube I highly recommend to checkout  his video solutions.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n       ListNode start = new ListNode();\\n        start.next = head;\\n        ListNode fast = start;\\n        ListNode slow = start;     \\n\\n        for(int i = 1; i <= n; ++i)\\n            fast = fast.next;\\n    \\n        while(fast.next != null)\\n        {\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        \\n        slow.next = slow.next.next;\\n        \\n        return start.next;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n       ListNode start = new ListNode();\\n        start.next = head;\\n        ListNode fast = start;\\n        ListNode slow = start;     \\n\\n        for(int i = 1; i <= n; ++i)\\n            fast = fast.next;\\n    \\n        while(fast.next != null)\\n        {\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        \\n        slow.next = slow.next.next;\\n        \\n        return start.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757145,
                "title": "c-del-n-th-node-from-the-end",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1) .\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* temp=new ListNode();\\n        temp->next=head;\\n\\n        ListNode* fast=temp;\\n        ListNode* slow=temp;\\n\\n        for(int i=1;i<=n;i++){\\n             fast=fast->next;\\n        }\\n\\n        while(fast->next!=NULL){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n\\n        ListNode* gaya=slow->next;\\n        slow->next=slow->next->next;\\n        delete(gaya);\\n        \\n        return temp->next;\\n    }\\n};\\nif it helps plzz don\\'t Forget to upvote it :)\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* temp=new ListNode();\\n        temp->next=head;\\n\\n        ListNode* fast=temp;\\n        ListNode* slow=temp;\\n\\n        for(int i=1;i<=n;i++){\\n             fast=fast->next;\\n        }\\n\\n        while(fast->next!=NULL){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n\\n        ListNode* gaya=slow->next;\\n        slow->next=slow->next->next;\\n        delete(gaya);\\n        \\n        return temp->next;\\n    }\\n};\\nif it helps plzz don\\'t Forget to upvote it :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8806,
                "title": "my-one-pass-solution",
                "content": "    public ListNode RemoveNthFromEnd(ListNode head, int n) {\\n        ListNode h1=head, h2=head;\\n        while(n-->0) h2=h2.next;\\n        if(h2==null)return head.next;  // The head need to be removed, do it.\\n        h2=h2.next;\\n        \\n        while(h2!=null){\\n            h1=h1.next;\\n            h2=h2.next;\\n        }\\n        h1.next=h1.next.next;   // the one after the h1 need to be removed\\n        return head;\\n    }",
                "solutionTags": [],
                "code": "    public ListNode RemoveNthFromEnd(ListNode head, int n) {\\n        ListNode h1=head, h2=head;\\n        while(n-->0) h2=h2.next;\\n        if(h2==null)return head.next;  // The head need to be removed, do it.\\n        h2=h2.next;\\n        \\n        while(h2!=null){\\n            h1=h1.next;\\n            h2=h2.next;\\n        }\\n        h1.next=h1.next.next;   // the one after the h1 need to be removed\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 9032,
                "title": "python-concise-one-pass-solution-with-dummy-head",
                "content": "\\n    def removeNthFromEnd(self, head, n):\\n        fast = slow = dummy = ListNode(0)\\n        dummy.next = head\\n        for _ in xrange(n):\\n            fast = fast.next\\n        while fast and fast.next:\\n            fast = fast.next\\n            slow = slow.next\\n        slow.next = slow.next.next\\n        return dummy.next",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "\\n    def removeNthFromEnd(self, head, n):\\n        fast = slow = dummy = ListNode(0)\\n        dummy.next = head\\n        for _ in xrange(n):\\n            fast = fast.next\\n        while fast and fast.next:\\n            fast = fast.next\\n            slow = slow.next\\n        slow.next = slow.next.next\\n        return dummy.next",
                "codeTag": "Python3"
            },
            {
                "id": 1401309,
                "title": "single-pass-python-solution-o-n-easy-sr",
                "content": "**Please upvote if you get this**\\n```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        i,j=head, head\\n        for k in range(n):\\n            j = j.next\\n        #now i and j will be at difference n\\n        if j == None: #Only happens when we are supposed to remove the first element\\n            return head.next\\n        while j.next != None:\\n            i = i.next\\n            j = j.next\\n        i.next = i.next.next\\n        return head\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        i,j=head, head\\n        for k in range(n):\\n            j = j.next\\n        #now i and j will be at difference n\\n        if j == None: #Only happens when we are supposed to remove the first element\\n            return head.next\\n        while j.next != None:\\n            i = i.next\\n            j = j.next\\n        i.next = i.next.next\\n        return head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632794,
                "title": "c-diagram-related-problems",
                "content": "**Approach**\\n- Take two pointers p and q at the head of linked list.\\n- Move q pointers by n to the right. Here n = 2.\\n- Then move both p and q pointers to right until q reaches the end.\\n- Then change pointer of p node to its next to next node.\\n- Don\\'t forget to delete the last nth node.\\n\\n**Digram Representation**\\n\\n![image](https://assets.leetcode.com/users/images/295d90c6-c36f-48b5-a83a-7028b8640f4e_1664330424.1773272.png)\\n\\n**C++ Code**\\n\\n```cpp\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p = head, *q = head;\\n        while (n--) q = q->next;\\n        if (!q) return head->next;\\n        while (q->next) {\\n            p = p->next;\\n            q = q->next;\\n        }\\n        ListNode* toDelete = p->next;\\n        p->next = p->next->next;\\n        delete toDelete;\\n        return head;\\n}\\n```\\n\\n**Related Problems**\\n[1. Linked List Cycle ](https://leetcode.com/problems/linked-list-cycle/)\\n[2. Linked List Cycle II ](https://leetcode.com/problems/linked-list-cycle-ii/)\\n[3. Reorder List ](https://leetcode.com/problems/reorder-list/)\\n[4. Sort List ](https://leetcode.com/problems/sort-list/)\\n[5. Swapping Nodes in a Linked List ](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```cpp\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p = head, *q = head;\\n        while (n--) q = q->next;\\n        if (!q) return head->next;\\n        while (q->next) {\\n            p = p->next;\\n            q = q->next;\\n        }\\n        ListNode* toDelete = p->next;\\n        p->next = p->next->next;\\n        delete toDelete;\\n        return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 9000,
                "title": "a-simple-2ms-c-solution",
                "content": "struct ListNode *removeNthFromEnd(struct ListNode *head, int n) {\\n\\n    struct ListNode* front = head;\\n    struct ListNode* behind = head;\\n    \\n    while (front != NULL) {\\n        front = front->next;\\n        \\n        if (n-- < 0) behind = behind->next;\\n    }\\n    if (n == 0) head = head->next;\\n    else behind->next = behind->next->next;\\n    return head;\\n}",
                "solutionTags": [],
                "code": "struct ListNode *removeNthFromEnd(struct ListNode *head, int n) {\\n\\n    struct ListNode* front = head;\\n    struct ListNode* behind = head;\\n    \\n    while (front != NULL) {\\n        front = front->next;\\n        \\n        if (n-- < 0) behind = behind->next;\\n    }\\n    if (n == 0) head = head->next;\\n    else behind->next = behind->next->next;\\n    return head;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 8822,
                "title": "java-solution-1ms-u5bb9-u6613-u7406-u89e3",
                "content": "    //\\u8fd8\\u662f\\u8d70\\u7684\\u5feb\\u7684\\u70b9(fastNode)\\u4e0e\\u8d70\\u5f97\\u6162\\u7684\\u70b9(slowNode)\\u8def\\u7a0b\\u5dee\\u7684\\u95ee\\u9898\\n    \\tpublic static ListNode removeNthFromEnd(ListNode head, int n) {\\n            ListNode headNode = new ListNode(9527);\\n            headNode.next = head;\\n            ListNode fastNode = headNode;\\n            ListNode slowNode = headNode;\\n            while(fastNode.next != null){\\n            \\tif(n <= 0)\\n            \\t\\tslowNode = slowNode.next;\\n            \\tfastNode = fastNode.next;\\n            \\tn--;\\n            }\\n            if(slowNode.next != null)\\n            \\tslowNode.next = slowNode.next.next;\\n            return headNode.next;\\n        }",
                "solutionTags": [],
                "code": "    //\\u8fd8\\u662f\\u8d70\\u7684\\u5feb\\u7684\\u70b9(fastNode)\\u4e0e\\u8d70\\u5f97\\u6162\\u7684\\u70b9(slowNode)\\u8def\\u7a0b\\u5dee\\u7684\\u95ee\\u9898\\n    \\tpublic static ListNode removeNthFromEnd(ListNode head, int n) {\\n            ListNode headNode = new ListNode(9527);\\n            headNode.next = head;\\n            ListNode fastNode = headNode;\\n            ListNode slowNode = headNode;\\n            while(fastNode.next != null){\\n            \\tif(n <= 0)\\n            \\t\\tslowNode = slowNode.next;\\n            \\tfastNode = fastNode.next;\\n            \\tn--;\\n            }\\n            if(slowNode.next != null)\\n            \\tslowNode.next = slowNode.next.next;\\n            return headNode.next;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 510175,
                "title": "python-solution-using-two-pointers",
                "content": "```\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n\\t\\n        slow = head # finally point to the previous node of the target node\\n        fast = head # finally point to the last node\\n        for i in range(n): # let the fast pointer move n steps ahead of the slow pointer\\n            fast = fast.next\\n        \\n        # This situation would happen when we are required to del the first node (n = len(List))\\n        # Also, it can handle the [] case\\n        if not fast:\\n            return slow.next\\n        \\n        while fast.next:\\n            fast = fast.next\\n            slow = slow.next\\n            \\n        slow.next = slow.next.next\\n        return head\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n\\t\\n        slow = head # finally point to the previous node of the target node\\n        fast = head # finally point to the last node\\n        for i in range(n): # let the fast pointer move n steps ahead of the slow pointer\\n            fast = fast.next\\n        \\n        # This situation would happen when we are required to del the first node (n = len(List))\\n        # Also, it can handle the [] case\\n        if not fast:\\n            return slow.next\\n        \\n        while fast.next:\\n            fast = fast.next\\n            slow = slow.next\\n            \\n        slow.next = slow.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307508,
                "title": "100-faster-java-code-you-will-not-get-this-much-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n![Screenshot 2023-03-15 185755.png](https://assets.leetcode.com/users/images/7db3581c-70aa-44f5-a6ad-bbc9a83cd0c9_1679056324.048882.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n\\n        // Create a temporary node and a counter to find the length of the linked list\\n        ListNode temp = head;\\n        int count = 0;\\n\\n        // Traverse the linked list and count the number of nodes\\n        while (temp != null) {\\n            count++;\\n            temp = temp.next;\\n        }\\n\\n        // Calculate the index of the node to be removed from the beginning of the list\\n        int len = count - n;\\n\\n        // If the first node needs to be removed, update the head and return\\n        if (len == 0) {\\n            head = head.next;\\n        } \\n        else {\\n             // Traverse the list until the node before the one to be removed\\n            ListNode prev = head;\\n            while (len - 1 != 0) {\\n                prev = prev.next;\\n                len--;\\n            }\\n        // Remove the node by updating the previous node\\'s next pointer\\n        prev.next = prev.next.next;\\n        }\\n\\n    // Return the head node of the modified list\\n    return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n\\n        // Create a temporary node and a counter to find the length of the linked list\\n        ListNode temp = head;\\n        int count = 0;\\n\\n        // Traverse the linked list and count the number of nodes\\n        while (temp != null) {\\n            count++;\\n            temp = temp.next;\\n        }\\n\\n        // Calculate the index of the node to be removed from the beginning of the list\\n        int len = count - n;\\n\\n        // If the first node needs to be removed, update the head and return\\n        if (len == 0) {\\n            head = head.next;\\n        } \\n        else {\\n             // Traverse the list until the node before the one to be removed\\n            ListNode prev = head;\\n            while (len - 1 != 0) {\\n                prev = prev.next;\\n                len--;\\n            }\\n        // Remove the node by updating the previous node\\'s next pointer\\n        prev.next = prev.next.next;\\n        }\\n\\n    // Return the head node of the modified list\\n    return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1644146,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranty of any kind. You are free to use the content freely and as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func removeNthFromEnd(_ head: ListNode?, _ n: Int) -> ListNode? {\\n        let node = ListNode(0)\\n        node.next = head\\n        \\n        var prev: ListNode? = node\\n        var post: ListNode? = node\\n        \\n        for _ in 0..<n {\\n            guard let next = post?.next else { continue }\\n            post = next\\n        }\\n        \\n        while let postNext = post?.next, let prevNext = prev?.next {\\n            prev = prevNext\\n            post = postNext\\n        }\\n        \\n        prev!.next = prev!.next!.next\\n        \\n        return node.next\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<p>\\n<details>\\n<summary><b>ListNode + Extension</b></summary>\\n\\n```swift\\npublic class ListNode {\\n    public var val: Int\\n    public var next: ListNode?\\n    public init() { self.val = 0; self.next = nil; }\\n    public init(_ val: Int) { self.val = val; self.next = nil; }\\n    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n    \\n    // An additional initializer that can be used to implement nodes from an array\\n    public init?(_ array: [Int]) {\\n        guard !array.isEmpty else { return nil }\\n        self.val = array[0]\\n        var prev: ListNode = self\\n        for i in 1..<array.count {\\n            let new = ListNode(array[i])\\n            prev.next = new\\n            prev = new\\n        }\\n    }\\n}\\n```\\n\\n```swift\\nextension ListNode: Equatable {\\n    public static func == (lhs: ListNode, rhs: ListNode) -> Bool {\\n        return lhs.val == rhs.val && lhs.next == rhs.next\\n    }\\n}\\n```\\n\\n</details>\\n</p>\\n\\n<hr>\\n\\n<p>\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<br>\\n\\n<pre>\\nResult: Executed 3 tests, with 0 failures (0 unexpected) in 0.034 (0.036) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.removeNthFromEnd(ListNode([1,2,3,4,5]), 2)\\n        XCTAssertEqual(value, ListNode([1,2,3,5]))\\n    }\\n    func test1() {\\n        let value = solution.removeNthFromEnd(ListNode([1]), 1)\\n        XCTAssertEqual(value, ListNode([]))\\n    }\\n    func test2() {\\n        let value = solution.removeNthFromEnd(ListNode([1,2]), 1)\\n        XCTAssertEqual(value, ListNode([1]))\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func removeNthFromEnd(_ head: ListNode?, _ n: Int) -> ListNode? {\\n        let node = ListNode(0)\\n        node.next = head\\n        \\n        var prev: ListNode? = node\\n        var post: ListNode? = node\\n        \\n        for _ in 0..<n {\\n            guard let next = post?.next else { continue }\\n            post = next\\n        }\\n        \\n        while let postNext = post?.next, let prevNext = prev?.next {\\n            prev = prevNext\\n            post = postNext\\n        }\\n        \\n        prev!.next = prev!.next!.next\\n        \\n        return node.next\\n    }\\n}\\n```\n```swift\\npublic class ListNode {\\n    public var val: Int\\n    public var next: ListNode?\\n    public init() { self.val = 0; self.next = nil; }\\n    public init(_ val: Int) { self.val = val; self.next = nil; }\\n    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n    \\n    // An additional initializer that can be used to implement nodes from an array\\n    public init?(_ array: [Int]) {\\n        guard !array.isEmpty else { return nil }\\n        self.val = array[0]\\n        var prev: ListNode = self\\n        for i in 1..<array.count {\\n            let new = ListNode(array[i])\\n            prev.next = new\\n            prev = new\\n        }\\n    }\\n}\\n```\n```swift\\nextension ListNode: Equatable {\\n    public static func == (lhs: ListNode, rhs: ListNode) -> Bool {\\n        return lhs.val == rhs.val && lhs.next == rhs.next\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.removeNthFromEnd(ListNode([1,2,3,4,5]), 2)\\n        XCTAssertEqual(value, ListNode([1,2,3,5]))\\n    }\\n    func test1() {\\n        let value = solution.removeNthFromEnd(ListNode([1]), 1)\\n        XCTAssertEqual(value, ListNode([]))\\n    }\\n    func test2() {\\n        let value = solution.removeNthFromEnd(ListNode([1,2]), 1)\\n        XCTAssertEqual(value, ListNode([1]))\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 612328,
                "title": "python-go-js-c-o-n-by-two-pointers-w-visualization",
                "content": "O(n) one-pass by two-pointers and delay\\n\\n---\\n\\n**Hint**:\\n\\nThink of **two-pointers** with **n-step delay**.\\n\\nFirst pointer keeps going till the end.\\nSecond pointer traverses to the previous node of the one being removed with n-step delay.\\n\\nWhen first pointer reach the end, the second one will be on the right position.\\nThen update linkage of second pointer and remove the N-th node from the end.\\n\\n---\\n\\n**Visualization & Diagram**:\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1588588180.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1588588255.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1588588288.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1588588310.png)\\n\\n---\\n\\n**Implementation** by two-pointers and delay in Python:\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        \\n        # use dummy head will make the removal of head node easier\\n        dummy_head = ListNode(-1)\\n        dummy_head.next = head\\n        \\n        # cur keeps iteration till the end\\n        # prev_of_removal traverses to the previous node of the one of being removed\\n        cur, prev_of_removal = dummy_head, dummy_head\\n        \\n        \\n        while cur.next != None:\\n            \\n            # n-step delay for prev_of_removal\\n            if n <= 0:\\n                prev_of_removal = prev_of_removal.next\\n                \\n            cur = cur.next\\n            \\n            n -=1\\n        \\n        \\n        # Remove the N-th node from end of list\\n        n_th_node = prev_of_removal.next\\n        prev_of_removal.next = n_th_node.next\\n        \\n        del n_th_node\\n        \\n        return dummy_head.next\\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} n\\n * @return {ListNode}\\n */\\nvar removeNthFromEnd = function(head, n) {\\n    \\n    // use dummy head will make the removal of head node easier\\n    let dummyHead = new ListNode( -1, head);\\n    \\n    // cur keeps iteration till the end\\n    // prev_of_removal traverses to the previous node of the one of being removed    \\n    let cur = dummyHead;\\n    let prevOfRemoval = dummyHead;\\n    \\n    while( cur.next != null ){\\n        \\n        // n-step delay for prevOfRemoval\\n        if( n <= 0 ){\\n            prevOfRemoval = prevOfRemoval.next;\\n        }\\n        \\n        cur = cur.next;\\n        \\n        // update counter of n-step delay\\n        n -= 1;\\n    }\\n    \\n    \\n    nThNode = prevOfRemoval.next;\\n    prevOfRemoval.next = nThNode.next;\\n    \\n    return dummyHead.next;\\n    \\n};\\n```\\n\\n---\\n\\n**Implementation** by two-pointers and delay in Go:\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\n\\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {\\n    \\n    dummyHead := &ListNode{-1, head}\\n    \\n    cur, prevOfRemoval := dummyHead, dummyHead\\n    \\n    for cur.Next != nil{\\n        \\n        // n step delay for prevOfRemoval\\n        if n <= 0 {\\n            prevOfRemoval = prevOfRemoval.Next\\n        }\\n        \\n        cur = cur.Next\\n        \\n        n -= 1\\n    }\\n    \\n    // Remove the N-th node from end of list\\n    nthNode := prevOfRemoval.Next\\n    prevOfRemoval.Next = nthNode.Next\\n    \\n    return dummyHead.Next\\n    \\n}\\n```\\n\\n---\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        \\n        // use dummy head will make the removal of head node easier\\n        ListNode* dummyHead = new ListNode(-1, head);\\n        \\n        // cur keeps iteration till the end\\n        // prevOfRemoval traverses to the previous node of the one of being removied\\n        ListNode* cur = dummyHead;\\n        ListNode* prevOfRemoval = dummyHead;\\n        \\n        while( cur->next != nullptr ){\\n            \\n            // n-step delay for prevOfRemoval\\n            if( n <= 0 ){\\n                prevOfRemoval = prevOfRemoval->next;\\n            }\\n            \\n            cur = cur->next;\\n            \\n            // update counter of n step delay\\n            n -= 1;\\n        }\\n        \\n        // Remove the n-th node from end of list\\n        ListNode* nThNode = prevOfRemoval->next;\\n        prevOfRemoval->next = nThNode->next;\\n        \\n        delete nThNode;\\n        \\n        return dummyHead->next;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Two Pointers",
                    "Iterator"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        \\n        # use dummy head will make the removal of head node easier\\n        dummy_head = ListNode(-1)\\n        dummy_head.next = head\\n        \\n        # cur keeps iteration till the end\\n        # prev_of_removal traverses to the previous node of the one of being removed\\n        cur, prev_of_removal = dummy_head, dummy_head\\n        \\n        \\n        while cur.next != None:\\n            \\n            # n-step delay for prev_of_removal\\n            if n <= 0:\\n                prev_of_removal = prev_of_removal.next\\n                \\n            cur = cur.next\\n            \\n            n -=1\\n        \\n        \\n        # Remove the N-th node from end of list\\n        n_th_node = prev_of_removal.next\\n        prev_of_removal.next = n_th_node.next\\n        \\n        del n_th_node\\n        \\n        return dummy_head.next\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} n\\n * @return {ListNode}\\n */\\nvar removeNthFromEnd = function(head, n) {\\n    \\n    // use dummy head will make the removal of head node easier\\n    let dummyHead = new ListNode( -1, head);\\n    \\n    // cur keeps iteration till the end\\n    // prev_of_removal traverses to the previous node of the one of being removed    \\n    let cur = dummyHead;\\n    let prevOfRemoval = dummyHead;\\n    \\n    while( cur.next != null ){\\n        \\n        // n-step delay for prevOfRemoval\\n        if( n <= 0 ){\\n            prevOfRemoval = prevOfRemoval.next;\\n        }\\n        \\n        cur = cur.next;\\n        \\n        // update counter of n-step delay\\n        n -= 1;\\n    }\\n    \\n    \\n    nThNode = prevOfRemoval.next;\\n    prevOfRemoval.next = nThNode.next;\\n    \\n    return dummyHead.next;\\n    \\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\n\\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {\\n    \\n    dummyHead := &ListNode{-1, head}\\n    \\n    cur, prevOfRemoval := dummyHead, dummyHead\\n    \\n    for cur.Next != nil{\\n        \\n        // n step delay for prevOfRemoval\\n        if n <= 0 {\\n            prevOfRemoval = prevOfRemoval.Next\\n        }\\n        \\n        cur = cur.Next\\n        \\n        n -= 1\\n    }\\n    \\n    // Remove the N-th node from end of list\\n    nthNode := prevOfRemoval.Next\\n    prevOfRemoval.Next = nthNode.Next\\n    \\n    return dummyHead.Next\\n    \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        \\n        // use dummy head will make the removal of head node easier\\n        ListNode* dummyHead = new ListNode(-1, head);\\n        \\n        // cur keeps iteration till the end\\n        // prevOfRemoval traverses to the previous node of the one of being removied\\n        ListNode* cur = dummyHead;\\n        ListNode* prevOfRemoval = dummyHead;\\n        \\n        while( cur->next != nullptr ){\\n            \\n            // n-step delay for prevOfRemoval\\n            if( n <= 0 ){\\n                prevOfRemoval = prevOfRemoval->next;\\n            }\\n            \\n            cur = cur->next;\\n            \\n            // update counter of n step delay\\n            n -= 1;\\n        }\\n        \\n        // Remove the n-th node from end of list\\n        ListNode* nThNode = prevOfRemoval->next;\\n        prevOfRemoval->next = nThNode->next;\\n        \\n        delete nThNode;\\n        \\n        return dummyHead->next;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734524,
                "title": "0ms-faster-than-100-java-easy-sol-only-iteration-no-stacks",
                "content": "Please **Upvote** if it helped you.\\n\\n```\\npublic ListNode removeNthFromEnd(ListNode head, int n) {\\n        int count = 0; // creating a counter variable to get the number of Nodes\\n        \\n        ListNode list = head;  // here creating a Node that will point to the head Node, so the list is now pointing to the head Node\\n        \\n        while(list != null) {    // as list is pointing to head Node and I wanna reach to the end Node, \\n                                // I will run a loop starting from head Node until the end of the list i.e. until the list becomes null\\n            \\n            list = list.next;   // this statement will make \"list\" point to the next Node ( like in i++, if i is 1 then it will become 2 )\\n                                // before list ---> head..... now list ---> head.next ( for easy understanding )\\n            count++;            // as we\\'ll go forward, we\\'ll keep on increasing our counter variable to know the size of the list\\n        }\\n        \\n        int node = count - n;   // this is position of required Node from the start \\n                                // if list.size() == 9 and we need to delete 2nd element from end\\n                                // node = 9 (size) - 2 (end position)  == 7 (position from start)\\n        \\n        if( node == 0) {        // suppose in above example position from end is 9\\n                                // means position from start ==> 9-9 = 0\\n                                // we have to delete the first element that is head so we\\'ll simply return head.next \\n                                \\n            return head.next;   // list that will pass the whole list except head because we wanna delete it so head.next \\n                                // as mentioned earlier head.next will point to second Node head here\\n\\n        }\\n        list = head;            // now if you remember, we have iterated through this list pointer to know the size, so it will be pointing to the \\n                                // last Node, in this statement I made sure that it again will point to the head Node ( Now you can understand why \\n                                // we created a seperate Node \"list\" and not used the head Node in the argument\\n        \\n        while(node-- > 1) {     // here I\\'m simply running a loop till node becomes less than 1 (not 0 because we need to go the Node before the \\n                                // Node we wanna delete ( like if we wanna delete 7th Node so we\\'ll go to Node 6 ) you\\'ll see why\\n            list = list.next;   // now the list Node will point to the 6th Node if we wanna delete 7th, after this loop completes\\n        }\\n        list.next = list.next.next;     // simply understand it by the notations below\\n                                        // current situation :-  list ----> Node (6th)\\n                                        //                       list.next = 7th Node\\n                                        //                       list.next.next = 8th Node ( null if not present )\\n                                        //  so here\\'s the basic logic  :- if we wanna remove 7th Node we\\'ll just cut it\\'s link from 6th Node \\n                                        //  and we\\'ll make our 8th Node as 7th by pointing 6th Node\\'s next to the 8th Node so 6th ----> 8th \\n                                        \\n        return head;                    // we can\\'t return \"list\" for reasons explained earlier beacaue currently list is pointing to 6th Node\\n                                        // and we have to return the starting Node so we\\'ll return head Node\\n                                        // if you\\'re wondering how? then let me make this also clear that \"list\" is not a copy of head, it\\'s just pointing \\n                                        // to head Node, so the changes made will also reflect in the head Node\\n                                        // I hope I explained everything, so Please Upvote if you haven\\'t already\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\npublic ListNode removeNthFromEnd(ListNode head, int n) {\\n        int count = 0; // creating a counter variable to get the number of Nodes\\n        \\n        ListNode list = head;  // here creating a Node that will point to the head Node, so the list is now pointing to the head Node\\n        \\n        while(list != null) {    // as list is pointing to head Node and I wanna reach to the end Node, \\n                                // I will run a loop starting from head Node until the end of the list i.e. until the list becomes null\\n            \\n            list = list.next;   // this statement will make \"list\" point to the next Node ( like in i++, if i is 1 then it will become 2 )\\n                                // before list ---> head..... now list ---> head.next ( for easy understanding )\\n            count++;            // as we\\'ll go forward, we\\'ll keep on increasing our counter variable to know the size of the list\\n        }\\n        \\n        int node = count - n;   // this is position of required Node from the start \\n                                // if list.size() == 9 and we need to delete 2nd element from end\\n                                // node = 9 (size) - 2 (end position)  == 7 (position from start)\\n        \\n        if( node == 0) {        // suppose in above example position from end is 9\\n                                // means position from start ==> 9-9 = 0\\n                                // we have to delete the first element that is head so we\\'ll simply return head.next \\n                                \\n            return head.next;   // list that will pass the whole list except head because we wanna delete it so head.next \\n                                // as mentioned earlier head.next will point to second Node head here\\n\\n        }\\n        list = head;            // now if you remember, we have iterated through this list pointer to know the size, so it will be pointing to the \\n                                // last Node, in this statement I made sure that it again will point to the head Node ( Now you can understand why \\n                                // we created a seperate Node \"list\" and not used the head Node in the argument\\n        \\n        while(node-- > 1) {     // here I\\'m simply running a loop till node becomes less than 1 (not 0 because we need to go the Node before the \\n                                // Node we wanna delete ( like if we wanna delete 7th Node so we\\'ll go to Node 6 ) you\\'ll see why\\n            list = list.next;   // now the list Node will point to the 6th Node if we wanna delete 7th, after this loop completes\\n        }\\n        list.next = list.next.next;     // simply understand it by the notations below\\n                                        // current situation :-  list ----> Node (6th)\\n                                        //                       list.next = 7th Node\\n                                        //                       list.next.next = 8th Node ( null if not present )\\n                                        //  so here\\'s the basic logic  :- if we wanna remove 7th Node we\\'ll just cut it\\'s link from 6th Node \\n                                        //  and we\\'ll make our 8th Node as 7th by pointing 6th Node\\'s next to the 8th Node so 6th ----> 8th \\n                                        \\n        return head;                    // we can\\'t return \"list\" for reasons explained earlier beacaue currently list is pointing to 6th Node\\n                                        // and we have to return the starting Node so we\\'ll return head Node\\n                                        // if you\\'re wondering how? then let me make this also clear that \"list\" is not a copy of head, it\\'s just pointing \\n                                        // to head Node, so the changes made will also reflect in the head Node\\n                                        // I hope I explained everything, so Please Upvote if you haven\\'t already\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 449061,
                "title": "simple-and-fast-c-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        \\n\\t\\t// move fast pointer to the n + 1 element\\n        while (n--) { fast = fast->next; }\\n        \\n        // handle edge case: given n is always valid, \\n        // if fast reached the end, we need to remove the first element\\n        if (fast == nullptr) return head->next;\\n\\n        // move both pointers at the same time maintaing the difference\\n        while (fast->next != nullptr) {\\n            fast = fast->next;\\n            slow = slow->next;\\n        }\\n        \\n        // slow will be pointing to the element before the one we want to remove\\n        slow->next = slow->next->next;\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        \\n\\t\\t// move fast pointer to the n + 1 element\\n        while (n--) { fast = fast->next; }\\n        \\n        // handle edge case: given n is always valid, \\n        // if fast reached the end, we need to remove the first element\\n        if (fast == nullptr) return head->next;\\n\\n        // move both pointers at the same time maintaing the difference\\n        while (fast->next != nullptr) {\\n            fast = fast->next;\\n            slow = slow->next;\\n        }\\n        \\n        // slow will be pointing to the element before the one we want to remove\\n        slow->next = slow->next->next;\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 524116,
                "title": "javascript-one-pass-two-pointer",
                "content": "**algorithm**\\n1. To remove n-th node from the end, send node `hare` as far as `n`.\\n2. Move node `curr` and `hare` in same speed until `hare` gets the last node.\\n3. Since `curr` and `hare` has gap as `n`, `curr` has n+1-th node from the end when `hare` has 1th node from the end. So change `curr.next` to `curr.next.next`.\\n\\n**edge case**\\n`n = 3` `linked list = [1,2,3]`\\n- When `n` is same with the length of the list. We need to remove first element, instead remove next element of `curr`.\\n- In this case, you can find that `hare` would be `null`, because the last element of list points `null` such as `[1,2,3,null]`\\n\\n**complexity**\\n- Time complexity: **O(N)**\\n- Space complexity: **O(1)**\\n```JavaScript\\n/**\\n * @param {ListNode} head\\n * @param {number} n\\n * @return {ListNode}\\n */\\nvar removeNthFromEnd = function(head, n) {\\n    let hare = head, curr = head;\\n    while (n--) {\\n        hare = hare.next;\\n    }\\n    while (hare && hare.next) {\\n        curr = curr.next;\\n        hare = hare.next;\\n    }\\n    if (!hare) {\\n        head = head.next;\\n    } else {\\n        curr.next = curr.next ? curr.next.next : null;\\n    }\\n    return head;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```JavaScript\\n/**\\n * @param {ListNode} head\\n * @param {number} n\\n * @return {ListNode}\\n */\\nvar removeNthFromEnd = function(head, n) {\\n    let hare = head, curr = head;\\n    while (n--) {\\n        hare = hare.next;\\n    }\\n    while (hare && hare.next) {\\n        curr = curr.next;\\n        hare = hare.next;\\n    }\\n    if (!hare) {\\n        head = head.next;\\n    } else {\\n        curr.next = curr.next ? curr.next.next : null;\\n    }\\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1651738,
                "title": "c-simplest-solution-one-pass-two-pointer-technique",
                "content": "* To solve this problem in one-pass & O(n) space, we need to find a way to both reach the end of the linked list & reach the nth node from the end simultaneoulsy.\\n* To do that, we initialize 2 pointers ```*fast``` & ```*slow``` both pointing to the head of the linked lits, the stagger the both by ```n``` nodes, so that ```fast``` is ```n``` nodes ahead of ```slow```.\\n* Doing this will cause ```slow``` to reach the ```n```\\'th node from the end at the same time that ```fast``` reaches the end.\\n* Since we will need access to the node before the target node in order to remove the target node, we are going to loop until ```fast->next != NULL``` rather than until ```fast != null```, so that we stop one node earlier.\\n* This method will be a problem when ```n``` is same as the no. of nodes in the linked list, which would make the first node the target node, and hence it\\'s not possible to find the node before the target node. If that\\'s the case, we can just return ```head->next```\\n\\n**Time Complexity :** O(N) - N = sz\\n\\n**Auxiliary Space :** O(1)\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n        \\n        for(int i=0; i<n; i++) fast = fast->next;\\n        \\n        if(!fast) return head->next;\\n        \\n        while(fast->next) fast = fast->next, slow = slow->next;\\n        \\n        slow->next = slow->next->next;\\n        \\n        return head;\\n    }\\n};\\n```\\n\\n**If you like my solution & explanation, please upvote my post :)**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```*fast```\n```*slow```\n```n```\n```fast```\n```n```\n```slow```\n```slow```\n```n```\n```fast```\n```fast->next != NULL```\n```fast != null```\n```n```\n```head->next```\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n        \\n        for(int i=0; i<n; i++) fast = fast->next;\\n        \\n        if(!fast) return head->next;\\n        \\n        while(fast->next) fast = fast->next, slow = slow->next;\\n        \\n        slow->next = slow->next->next;\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 9090,
                "title": "my-simple-java-solution-in-one-pass",
                "content": "     public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode dummy=new ListNode(0);\\n        dummy.next=head;\\n        ListNode fast=dummy;\\n        ListNode slow=dummy;\\n        int temp=n;\\n        for(;fast.next!=null;temp--){\\n            if(temp<=0){ //control\\n                slow=slow.next;\\n            }\\n            fast=fast.next;\\n        }\\n        slow.next=slow.next.next;//delete Nth\\n        return dummy.next;\\n    }",
                "solutionTags": [],
                "code": "     public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode dummy=new ListNode(0);\\n        dummy.next=head;\\n        ListNode fast=dummy;\\n        ListNode slow=dummy;\\n        int temp=n;\\n        for(;fast.next!=null;temp--){\\n            if(temp<=0){ //control\\n                slow=slow.next;\\n            }\\n            fast=fast.next;\\n        }\\n        slow.next=slow.next.next;//delete Nth\\n        return dummy.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2633625,
                "title": "c-dear-deleted-node-rest-in-peace",
                "content": "### Approach 1: actually delete the removed node\\n\\nThis solution is similar to many others, with one difference: actually delete the removed node. :)\\n\\n```cpp\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode prehead(-1, head);\\n        ListNode* prev = &prehead;\\n        for (int i = 0; i < n; ++i) {\\n            head = head->next;\\n        }\\n        while (head) {\\n            head = head->next;\\n            prev = prev->next;\\n        }\\n        ListNode* rip = prev->next;\\n        prev->next = prev->next->next;\\n        // Don\\'t be that person that leaks memory. :)\\n        delete rip;\\n        return prehead.next;\\n    }\\n```\\n\\n_As always: Feedback, questions, and comments are welcome._\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/Nqm4jJcyBf)!**",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```cpp\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode prehead(-1, head);\\n        ListNode* prev = &prehead;\\n        for (int i = 0; i < n; ++i) {\\n            head = head->next;\\n        }\\n        while (head) {\\n            head = head->next;\\n            prev = prev->next;\\n        }\\n        ListNode* rip = prev->next;\\n        prev->next = prev->next->next;\\n        // Don\\'t be that person that leaks memory. :)\\n        delete rip;\\n        return prehead.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1708527,
                "title": "java-solution-100-faster-with-explanation-also-asked-in-interviews",
                "content": "**Upvote if you found this use full**\\n\\n**Also asked in Adobe, Amazon, Arcesium, Factset, Intuit, Zoho, HCL**\\n\\n```\\n// Steps-\\n    \\n// Use a dummy variable pointing to head\\n\\n// Use two pointer fast and slow pointing to dummy variable . Move first pointer for n steps\\n\\n// Then start moving both until first pointer reaches the last node and slow pointer reaches (size of list - n)th node.\\n    \\n// Then delete the next node of slow and return dummy.next;\\n\\n\\n// Concept-\\n    \\n// When you move the fast pointer to nth node, the remaining nodes to traverse is (size_of_linked_list - n).     \\n// After that, when you start moving slow pointer and fast pointer by 1 node each, \\n// it is guaranteed that slow pointer will cover a distance of (size_of_linked_list - n) nodes. And that\\'s node we want to remove.\\n\\n\\nclass Solution \\n{\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        if(head.next==null)\\n            return null;\\n        ListNode dummy=new ListNode();\\n        dummy.next=head;\\n        ListNode slow=dummy;\\n        ListNode fast=dummy;\\n        \\n        for(int i=1;i<=n;i++)\\n            fast=fast.next;\\n        \\n        while(fast.next!=null)\\n        {\\n            fast=fast.next;\\n            slow=slow.next;\\n        }\\n        \\n        slow.next=slow.next.next;\\n        return dummy.next;\\n    }\\n}\\n\\n```\\n\\n**Without using dummy node**\\n\\n```\\nclass Solution \\n{\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        if(head.next==null)\\n            return null;\\n        \\n        ListNode slow=head;\\n        ListNode fast=head;\\n        \\n        for(int i=1;i<=n;i++)\\n            fast=fast.next;\\n        \\n        // edge case handeled when we have to delete the 1st node i.e n=size of linked list\\n        \\n        if(fast==null)\\n            return head.next;\\n        \\n        while(fast!=null && fast.next!=null)\\n        {\\n            fast=fast.next;\\n            slow=slow.next;\\n        }\\n        \\n        slow.next=slow.next.next;\\n        return head;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Steps-\\n    \\n// Use a dummy variable pointing to head\\n\\n// Use two pointer fast and slow pointing to dummy variable . Move first pointer for n steps\\n\\n// Then start moving both until first pointer reaches the last node and slow pointer reaches (size of list - n)th node.\\n    \\n// Then delete the next node of slow and return dummy.next;\\n\\n\\n// Concept-\\n    \\n// When you move the fast pointer to nth node, the remaining nodes to traverse is (size_of_linked_list - n).     \\n// After that, when you start moving slow pointer and fast pointer by 1 node each, \\n// it is guaranteed that slow pointer will cover a distance of (size_of_linked_list - n) nodes. And that\\'s node we want to remove.\\n\\n\\nclass Solution \\n{\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        if(head.next==null)\\n            return null;\\n        ListNode dummy=new ListNode();\\n        dummy.next=head;\\n        ListNode slow=dummy;\\n        ListNode fast=dummy;\\n        \\n        for(int i=1;i<=n;i++)\\n            fast=fast.next;\\n        \\n        while(fast.next!=null)\\n        {\\n            fast=fast.next;\\n            slow=slow.next;\\n        }\\n        \\n        slow.next=slow.next.next;\\n        return dummy.next;\\n    }\\n}\\n\\n```\n```\\nclass Solution \\n{\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        if(head.next==null)\\n            return null;\\n        \\n        ListNode slow=head;\\n        ListNode fast=head;\\n        \\n        for(int i=1;i<=n;i++)\\n            fast=fast.next;\\n        \\n        // edge case handeled when we have to delete the 1st node i.e n=size of linked list\\n        \\n        if(fast==null)\\n            return head.next;\\n        \\n        while(fast!=null && fast.next!=null)\\n        {\\n            fast=fast.next;\\n            slow=slow.next;\\n        }\\n        \\n        slow.next=slow.next.next;\\n        return head;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588515,
                "title": "go",
                "content": "```\\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {    \\n    dummy := &ListNode{Next: head}\\n    slow, fast := dummy, dummy\\n    \\n    for i := 0; i <= n; i++ {\\n        fast = fast.Next\\n    }\\n    \\n    for fast != nil {\\n        fast = fast.Next\\n        slow = slow.Next\\n    }\\n    \\n    slow.Next = slow.Next.Next\\n    \\n    return dummy.Next\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {    \\n    dummy := &ListNode{Next: head}\\n    slow, fast := dummy, dummy\\n    \\n    for i := 0; i <= n; i++ {\\n        fast = fast.Next\\n    }\\n    \\n    for fast != nil {\\n        fast = fast.Next\\n        slow = slow.Next\\n    }\\n    \\n    slow.Next = slow.Next.Next\\n    \\n    return dummy.Next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 9094,
                "title": "here-is-my-solution-in-c-one-pass-2-pointers-with-comments",
                "content": "    struct ListNode* removeNthFromEnd(struct ListNode* head, int n) {\\n    struct ListNode* HEAD1;\\n    struct ListNode* HEAD2;\\n    HEAD1=head;\\n    HEAD2=head;\\n    for(int i=0;i<n;i++) //take pointer HEAD1 n places ahead of HEAD2\\n    {   \\n        HEAD1=HEAD1->next;\\n        if(!HEAD1)          // when we have to delete the first node\\n        return head->next;\\n    }  \\n    while(HEAD1->next)   //take HEAD1 to last node so that HEAD2 is 1 behind the node we want to delete\\n    {   \\n        HEAD2=HEAD2->next;\\n        HEAD1=HEAD1->next;\\n        \\n    }\\n    HEAD2->next=HEAD2->next->next; // delete the node next to HEAD2\\n    \\n    \\n    return head;\\n    \\n}",
                "solutionTags": [],
                "code": "    struct ListNode* removeNthFromEnd(struct ListNode* head, int n) {\\n    struct ListNode* HEAD1;\\n    struct ListNode* HEAD2;\\n    HEAD1=head;\\n    HEAD2=head;\\n    for(int i=0;i<n;i++) //take pointer HEAD1 n places ahead of HEAD2\\n    {   \\n        HEAD1=HEAD1->next;\\n        if(!HEAD1)          // when we have to delete the first node\\n        return head->next;\\n    }  \\n    while(HEAD1->next)   //take HEAD1 to last node so that HEAD2 is 1 behind the node we want to delete\\n    {   \\n        HEAD2=HEAD2->next;\\n        HEAD1=HEAD1->next;\\n        \\n    }\\n    HEAD2->next=HEAD2->next->next; // delete the node next to HEAD2\\n    \\n    \\n    return head;\\n    \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1164532,
                "title": "remove-nth-node-from-end-of-list-simple-one-pass-solution-w-explanation",
                "content": "This problem is very similar to the **[1721. Swapping Nodes in a Linked List](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/)** (which was given in *March LeetCoding Challenge 2021* as well), just that we have to **remove** the kth node from the end instead of swapping it.\\n\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (One-Pointer, Two-Pass)***\\n\\nThis approach is very intuitive and easy to get. \\n\\n* We just iterate in the first-pass to find the length of the linked list - **`len`**.\\n\\n* In the next pass, iterate **`len - n - 1`** nodes from start and delete the next node (which would be *`nth`* node from end).\\n\\n---\\n\\n**C++**\\n```\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\tListNode* iter = head;\\n\\tint len = 0, i = 1;\\n\\twhile(iter) iter = iter -> next, len++;    // finding the length of linked list\\n\\tif(len == n) return head -> next;          // if head itself is to be deleted, just return head -> next\\n\\tfor(iter = head; i < len - n; i++) iter = iter -> next; // iterate first len-n nodes\\n\\titer -> next = iter -> next -> next;      // remove the nth node from the end\\n\\treturn head;\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n\\tptr, length = head, 0\\n\\twhile ptr:\\n\\t\\tptr, length = ptr.next, length + 1\\n\\tif length == n : return head.next\\n\\tptr = head\\n\\tfor i in range(1, length - n):\\n\\t\\tptr = ptr.next\\n\\tptr.next = ptr.next.next\\n\\treturn head\\n```\\n\\n\\n***Time Complexity :*** **`O(N)`**, where, `N` is the number of nodes in the given list. \\n***Space Complexity :*** **`O(1)`**, since only constant space is used.\\n\\n---\\n---\\n\\n\\u2714\\uFE0F ***Solution (Two-Pointer, One-Pass)***\\n\\nWe are required to remove the nth node from the end of list. For this, we need to traverse *`N - n`* nodes from the start of the list, where *`N`* is the length of linked list. We can do this in one-pass as follows -\\n\\n* Let\\'s assign two pointers - **`fast`** and **`slow`** to head. We will first iterate for *`n`* nodes from start using the *`fast`* pointer. \\n\\n* Now, between the *`fast`*  and *`slow`* pointers, **there is a gap of `n` nodes**. Now, just Iterate and increment both the pointers till `fast` reaches the last node. The gap between `fast` and `slow` is still of `n` nodes, meaning that **`slow` is nth node from the last node (which currently is `fast`)**.\\n\\n```\\nFor eg. let the list be 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9, and n = 4.\\n\\n1. 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> null\\n   ^slow               ^fast\\n   |<--gap of n nodes-->|\\n \\n => Now traverse till fast reaches end\\n \\n 2. 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> null\\n                        ^slow               ^fast\\n                        |<--gap of n nodes-->|\\n\\t\\t\\t\\t\\t\\t\\n\\'slow\\' is at (n+1)th node from end.\\nSo just delete nth node from end by assigning slow -> next as slow -> next -> next (which would remove nth node from end of list).\\n```\\n\\n * Since we have to **delete the nth node from end of list** (And not nth from the last of list!), we just delete the next node to **`slow`** pointer and return the head.\\n\\n---\\n\\n**C++**\\n```\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\tListNode *fast = head, *slow = head;\\n\\twhile(n--) fast = fast -> next;      // iterate first n nodes using fast\\n\\tif(!fast) return head -> next;       // if fast is already null, it means we have to delete head itself. So, just return next of head\\n\\twhile(fast -> next)                  // iterate till fast reaches the last node of list\\n\\t\\tfast = fast -> next, slow = slow -> next;            \\n\\tslow -> next = slow -> next -> next; // remove the nth node from last\\n\\treturn head;\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n\\tfast = slow = head\\n\\tfor i in range(n):\\n\\t\\tfast = fast.next\\n\\tif not fast: return head.next\\n\\twhile fast.next:\\n\\t\\tfast, slow = fast.next, slow.next\\n\\tslow.next = slow.next.next\\n\\treturn head\\n```\\n\\n\\n\\n***Time Complexity :*** **`O(N)`**, where, `N` is the number of nodes in the given list. Although, the time complexity is same as above solution, we have reduced the constant factor in it to half.\\n***Space Complexity :*** **`O(1)`**, since only constant space is used.\\n\\n---\\n\\n**Note :** The Problem only asks us to **remove the node from the linked list and not delete it**. A good question to ask in an interview for this problem would be whether we just need to remove the node from linked list or completely delete it from the memory. Since it has not been stated in this problem if the node is required somewhere else later on, its better to just remove the node from linked list as asked.\\n\\nIf we want to delete the node altogether, then we can just free its memory and point it to NULL before returning from the function.\\n\\n\\n---\\n---\\n\\n*Best Runtime -*\\n\\n<table><tr><td><img src=https://assets.leetcode.com/users/images/6c81d074-139d-4de5-96f5-5943f62a2cca_1618736585.2373421.png /></td></tr></table>\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any questions or mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\tListNode* iter = head;\\n\\tint len = 0, i = 1;\\n\\twhile(iter) iter = iter -> next, len++;    // finding the length of linked list\\n\\tif(len == n) return head -> next;          // if head itself is to be deleted, just return head -> next\\n\\tfor(iter = head; i < len - n; i++) iter = iter -> next; // iterate first len-n nodes\\n\\titer -> next = iter -> next -> next;      // remove the nth node from the end\\n\\treturn head;\\n}\\n```\n```\\ndef removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n\\tptr, length = head, 0\\n\\twhile ptr:\\n\\t\\tptr, length = ptr.next, length + 1\\n\\tif length == n : return head.next\\n\\tptr = head\\n\\tfor i in range(1, length - n):\\n\\t\\tptr = ptr.next\\n\\tptr.next = ptr.next.next\\n\\treturn head\\n```\n```\\nFor eg. let the list be 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9, and n = 4.\\n\\n1. 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> null\\n   ^slow               ^fast\\n   |<--gap of n nodes-->|\\n \\n => Now traverse till fast reaches end\\n \\n 2. 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> null\\n                        ^slow               ^fast\\n                        |<--gap of n nodes-->|\\n\\t\\t\\t\\t\\t\\t\\n\\'slow\\' is at (n+1)th node from end.\\nSo just delete nth node from end by assigning slow -> next as slow -> next -> next (which would remove nth node from end of list).\\n```\n```\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\tListNode *fast = head, *slow = head;\\n\\twhile(n--) fast = fast -> next;      // iterate first n nodes using fast\\n\\tif(!fast) return head -> next;       // if fast is already null, it means we have to delete head itself. So, just return next of head\\n\\twhile(fast -> next)                  // iterate till fast reaches the last node of list\\n\\t\\tfast = fast -> next, slow = slow -> next;            \\n\\tslow -> next = slow -> next -> next; // remove the nth node from last\\n\\treturn head;\\n}\\n```\n```\\ndef removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n\\tfast = slow = head\\n\\tfor i in range(n):\\n\\t\\tfast = fast.next\\n\\tif not fast: return head.next\\n\\twhile fast.next:\\n\\t\\tfast, slow = fast.next, slow.next\\n\\tslow.next = slow.next.next\\n\\treturn head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1164545,
                "title": "remove-nth-node-from-end-of-list-js-python-java-c-easy-two-pointer-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nWith a singly linked list, the _only_ way to find the end of the list, and thus the **n**\\'th node from the end, is to actually iterate all the way to the end. The challenge here is attemping to find the solution in only one pass. A naive approach here might be to store pointers to each node in an array, allowing us to calculate the **n**\\'th from the end once we reach the end, but that would take **O(M) extra space**, where **M** is the length of the linked list.\\n\\nA slightly less naive approach would be to only store only the last **n+1** node pointers in the array. This could be achieved by overwriting the elements of the storage array in circlular fashion as we iterate through the list. This would lower the **space complexity** to **O(N+1)**.\\n\\nIn order to solve this problem in only one pass and **O(1) extra space**, however, we would need to find a way to _both_ reach the end of the list with one pointer _and also_ reach the **n**\\'th node from the end simultaneously with a second pointer.\\n\\nTo do that, we can simply stagger our two pointers by **n** nodes by giving the first pointer (**fast**) a head start before starting the second pointer (**slow**). Doing this will cause **slow** to reach the **n**\\'th node from the end at the same time that **fast** reaches the end.\\n\\n![Visual 1](https://i.imgur.com/BSiLKj0.png)\\n\\nSince we will need access to the node _before_ the target node in order to remove the target node, we can use **fast.next == null** as our exit condition, rather than **fast == null**, so that we stop one node earlier.\\n\\nThis will unfortunately cause a problem when **n** is the same as the length of the list, which would make the first node the target node, and thus make it impossible to find the node _before_ the target node. If that\\'s the case, however, we can just **return head.next** without needing to stitch together the two sides of the target node.\\n\\nOtherwise, once we succesfully find the node _before_ the target, we can then stitch it together with the node _after_ the target, and then **return head**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThere are only minor differences between the code of all four languages.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **60ms / 40.6MB** (beats 100% / 13%).\\n```javascript\\nvar removeNthFromEnd = function(head, n) {\\n    let fast = head, slow = head\\n    for (let i = 0; i < n; i++) fast = fast.next\\n    if (!fast) return head.next\\n    while (fast.next) fast = fast.next, slow = slow.next\\n    slow.next = slow.next.next\\n    return head\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **28ms / 13.9MB** (beats 92% / 99%).\\n```python\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        fast, slow = head, head\\n        for _ in range(n): fast = fast.next\\n        if not fast: return head.next\\n        while fast.next: fast, slow = fast.next, slow.next\\n        slow.next = slow.next.next\\n        return head\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 36.5MB** (beats 100% / 97%).\\n```java\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fast = head, slow = head;\\n        for (int i = 0; i < n; i++) fast = fast.next;\\n        if (fast == null) return head.next;\\n        while (fast.next != null) {\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 10.6MB** (beats 100% / 93%).\\n```c++\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n        for (int i = 0; i < n; i++) fast = fast->next;\\n        if (!fast) return head->next;\\n        while (fast->next) fast = fast->next, slow = slow->next;\\n        slow->next = slow->next->next;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar removeNthFromEnd = function(head, n) {\\n    let fast = head, slow = head\\n    for (let i = 0; i < n; i++) fast = fast.next\\n    if (!fast) return head.next\\n    while (fast.next) fast = fast.next, slow = slow.next\\n    slow.next = slow.next.next\\n    return head\\n};\\n```\n```python\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        fast, slow = head, head\\n        for _ in range(n): fast = fast.next\\n        if not fast: return head.next\\n        while fast.next: fast, slow = fast.next, slow.next\\n        slow.next = slow.next.next\\n        return head\\n```\n```java\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fast = head, slow = head;\\n        for (int i = 0; i < n; i++) fast = fast.next;\\n        if (fast == null) return head.next;\\n        while (fast.next != null) {\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n        for (int i = 0; i < n; i++) fast = fast->next;\\n        if (!fast) return head->next;\\n        while (fast->next) fast = fast->next, slow = slow->next;\\n        slow->next = slow->next->next;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512706,
                "title": "c-java-python-javascript-with-explanation-linked-list",
                "content": "# Intuition:\\nThe problem is to remove the nth node from the end of a linked list. We can find the total number of nodes in the linked list and then traverse the list again to find the nth node from the end. We can then remove the node by updating the pointer of the previous node.\\n\\n# Approach:\\n\\n1. Initialize a pointer to the head of the linked list and a count variable to 0.\\n2. Traverse the linked list and increment the count for each node until the end of the list is reached.\\n3. If the count is equal to n, remove the head node and return the next node as the new head.\\n4. Otherwise, initialize the pointer to the head of the linked list again and set n to count - n - 1.\\n5. Traverse the linked list again and update the pointer of the previous node to remove the nth node from the end.\\n6. Return the head of the linked list.\\n\\n# Complexity:\\n\\n- Time Complexity: O(n), where n is the total number of nodes in the linked list. We need to traverse the linked list twice - once to count the total number of nodes and then to find the nth node from the end.\\n\\n- Space Complexity: O(1), as we are not using any extra space and only using constant space for the pointers and count variable.\\n\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==NULL){\\n            return head;\\n        }\\n        ListNode* ptr=head;\\n        int count = 0;\\n        while(ptr){\\n            count++;\\n            ptr=ptr->next;\\n        }\\n        if(count==n){\\n            head=head->next;\\n            return head;\\n        }\\n        ptr=head;\\n        n=count-n-1;\\n        count=0;\\n        while(ptr){\\n            if(count==n){\\n                ptr->next=ptr->next->next;\\n            }\\n            count++;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n    }\\n};\\n```\\n\\n---\\n# JAVA\\n```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if (head == null) {\\n            return head;\\n        }\\n        \\n        ListNode ptr = head;\\n        int count = 0;\\n        while (ptr != null) {\\n            count++;\\n            ptr = ptr.next;\\n        }\\n        \\n        if (count == n) {\\n            head = head.next;\\n            return head;\\n        }\\n        \\n        ptr = head;\\n        n = count - n - 1;\\n        count = 0;\\n        while (ptr != null) {\\n            if (count == n) {\\n                ptr.next = ptr.next.next;\\n            }\\n            count++;\\n            ptr = ptr.next;\\n        }\\n        \\n        return head;\\n    }\\n}\\n\\n```\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        if head is None:\\n            return head\\n        \\n        ptr = head\\n        count = 0\\n        while ptr is not None:\\n            count += 1\\n            ptr = ptr.next\\n        \\n        if count == n:\\n            head = head.next\\n            return head\\n        \\n        ptr = head\\n        n = count - n - 1\\n        count = 0\\n        while ptr is not None:\\n            if count == n:\\n                ptr.next = ptr.next.next\\n            count += 1\\n            ptr = ptr.next\\n        \\n        return head\\n\\n```\\n---\\n\\n# JavaScript\\n```\\nvar removeNthFromEnd = function(head, n) {\\n        if (head === null) {\\n            return head;\\n        }\\n        \\n        let ptr = head;\\n        let count = 0;\\n        while (ptr !== null) {\\n            count++;\\n            ptr = ptr.next;\\n        }\\n        \\n        if (count === n) {\\n            head = head.next;\\n            return head;\\n        }\\n        \\n        ptr = head;\\n        n = count - n - 1;\\n        count = 0;\\n        while (ptr !== null) {\\n            if (count === n) {\\n                ptr.next = ptr.next.next;\\n            }\\n            count++;\\n            ptr = ptr.next;\\n        }\\n        \\n        return head;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==NULL){\\n            return head;\\n        }\\n        ListNode* ptr=head;\\n        int count = 0;\\n        while(ptr){\\n            count++;\\n            ptr=ptr->next;\\n        }\\n        if(count==n){\\n            head=head->next;\\n            return head;\\n        }\\n        ptr=head;\\n        n=count-n-1;\\n        count=0;\\n        while(ptr){\\n            if(count==n){\\n                ptr->next=ptr->next->next;\\n            }\\n            count++;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if (head == null) {\\n            return head;\\n        }\\n        \\n        ListNode ptr = head;\\n        int count = 0;\\n        while (ptr != null) {\\n            count++;\\n            ptr = ptr.next;\\n        }\\n        \\n        if (count == n) {\\n            head = head.next;\\n            return head;\\n        }\\n        \\n        ptr = head;\\n        n = count - n - 1;\\n        count = 0;\\n        while (ptr != null) {\\n            if (count == n) {\\n                ptr.next = ptr.next.next;\\n            }\\n            count++;\\n            ptr = ptr.next;\\n        }\\n        \\n        return head;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        if head is None:\\n            return head\\n        \\n        ptr = head\\n        count = 0\\n        while ptr is not None:\\n            count += 1\\n            ptr = ptr.next\\n        \\n        if count == n:\\n            head = head.next\\n            return head\\n        \\n        ptr = head\\n        n = count - n - 1\\n        count = 0\\n        while ptr is not None:\\n            if count == n:\\n                ptr.next = ptr.next.next\\n            count += 1\\n            ptr = ptr.next\\n        \\n        return head\\n\\n```\n```\\nvar removeNthFromEnd = function(head, n) {\\n        if (head === null) {\\n            return head;\\n        }\\n        \\n        let ptr = head;\\n        let count = 0;\\n        while (ptr !== null) {\\n            count++;\\n            ptr = ptr.next;\\n        }\\n        \\n        if (count === n) {\\n            head = head.next;\\n            return head;\\n        }\\n        \\n        ptr = head;\\n        n = count - n - 1;\\n        count = 0;\\n        while (ptr !== null) {\\n            if (count === n) {\\n                ptr.next = ptr.next.next;\\n            }\\n            count++;\\n            ptr = ptr.next;\\n        }\\n        \\n        return head;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 993889,
                "title": "c-solution-with-complexity-analysis-two-methods-two-pointers",
                "content": "### T = O(m) where m is number of iterations\\n### S = O(1) no extra space used\\n```\\n  // approach using single pass using fast and slow pointer\\n\\n\\tListNode* fast = head;\\n\\tListNode* slow = head;\\n\\n\\tfor(int i = 0; i < n; i++) {\\n\\t\\tfast= fast->next;\\n\\t}\\n\\n\\tif (fast == nullptr) return head->next;\\n\\n\\twhile(fast->next) {\\n\\t\\tslow = slow->next;\\n\\t\\tfast = fast->next;\\n\\t}\\n\\n\\tslow->next = slow->next->next;\\n\\treturn head;\\n```\\n\\n```\\n// approach using double pass\\nListNode* temp = head;\\nint l = 0;\\nwhile(temp) {\\n   temp = temp->next;\\n   l++;\\n}\\n\\n// corner case\\nif(l == n) {\\n\\treturn head->next;\\n}\\nListNode* p = head;\\nint j = 0;\\nfor(int i = 0; i < l-n-1; i++) {\\n\\tp = p->next;\\n\\tj++;\\n}\\n\\ncout << j;\\nListNode* del = p->next;\\np->next = del->next;\\ndelete del;\\nreturn head;\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n  // approach using single pass using fast and slow pointer\\n\\n\\tListNode* fast = head;\\n\\tListNode* slow = head;\\n\\n\\tfor(int i = 0; i < n; i++) {\\n\\t\\tfast= fast->next;\\n\\t}\\n\\n\\tif (fast == nullptr) return head->next;\\n\\n\\twhile(fast->next) {\\n\\t\\tslow = slow->next;\\n\\t\\tfast = fast->next;\\n\\t}\\n\\n\\tslow->next = slow->next->next;\\n\\treturn head;\\n```\n```\\n// approach using double pass\\nListNode* temp = head;\\nint l = 0;\\nwhile(temp) {\\n   temp = temp->next;\\n   l++;\\n}\\n\\n// corner case\\nif(l == n) {\\n\\treturn head->next;\\n}\\nListNode* p = head;\\nint j = 0;\\nfor(int i = 0; i < l-n-1; i++) {\\n\\tp = p->next;\\n\\tj++;\\n}\\n\\ncout << j;\\nListNode* del = p->next;\\np->next = del->next;\\ndelete del;\\nreturn head;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 982619,
                "title": "4-simple-solutions-explained-recursion-two-pointers-100-stack-two-runs",
                "content": "In the time complexity, I will refer to the length of the list as `m` and n and the index from the end.\\nNote: all of the solutions are run in less than  or equal to O(2 * n) but with closer look some are faster than others\\n\\nSolution 1:\\nThis solution runs in O(m + (m - n)) time with two runs once to count length second to get to the n -1 node from the end.\\nSpace O(1).\\n```\\nListNode *removeNthFromEnd(ListNode *head, int &n) // exection with two runs\\n    {\\n        int length = 0;\\n        ListNode *p = head;\\n\\n        while (p) // find length\\n        {\\n            length++;\\n            p = p->next;\\n        }\\n\\n        if (n == length) // check if need to remove the first node\\n            return head->next;\\n\\n        length -= n;\\n        length--;\\n\\n        p = head;\\n        while (length--) // get p the node before the n-th from the end\\n            p = p->next;\\n        p->next = p->next->next; // the move the node\\n\\n        return head;\\n    }\\n```\\n\\nSolution 2:\\nThis solution runs in O(m + n) time using a stack.\\nspace O(m).\\n```\\nListNode *removeNthFromEnd(ListNode *head, int &n) // excution using stack\\n{\\n\\tstack<ListNode *> s;\\n\\tint length = 0;\\n\\n\\tListNode *t = head;\\n\\twhile (t) // push all nodes\\n\\t{\\n\\t\\ts.push(t);\\n\\t\\tt = t->next;\\n\\t\\tlength++;\\n\\t}\\n\\n\\tif (length == n) // if need to remove the first node\\n\\t\\treturn head->next;\\n\\n\\twhile (n--) // get the n-1 node from the end\\n\\t\\ts.pop();\\n\\tt = s.top();\\n\\tt->next = t->next->next; // remove the node\\n\\n\\treturn head;\\n}\\n```\\n\\nSolution 3:\\nThis solution runs in O(m) time using backtracking and rebuilding the list.\\nSpace O(m)\\n```\\nListNode *removeNthFromEnd(ListNode *head, int &n)\\n{\\n\\tif(head == NULL) // if end\\n\\t\\treturn NULL;\\n\\n\\thead->next = removeNthFromEnd(head->next,n);// set to the next node\\n\\n\\tif(--n == 0) // do I need to remove this node\\n\\t\\treturn head->next;\\n\\treturn head;\\n}\\n```\\n\\n\\n\\nSolution 4:\\nThis solution runs in O(m) time with two pointers with space between them thus when the one before the end the other can remove the node.\\nspace O(1).\\n```\\nListNode *removeNthFromEnd(ListNode *head, int &n) // execution with two pointers\\n{\\n\\tListNode *t1 = head;\\n\\n\\twhile (t1 && n--) // get t1 to the  n+1 node thus the difference between t1 and t2 is n at all times\\n\\t\\tt1 = t1->next;\\n\\n\\tif (t1 == NULL) // if need to remove teh first Node\\n\\t\\treturn head->next;\\n\\n\\tListNode *t2 = head;\\n\\twhile (t1->next) // find the node before n-th from the end\\n\\t{\\n\\t\\tt1 = t1->next;\\n\\t\\tt2 = t2->next;\\n\\t}\\n\\tt2->next = t2->next->next;\\n\\n\\treturn head;\\n}\\n```\\nIf it helps vote up so it will reach others!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nListNode *removeNthFromEnd(ListNode *head, int &n) // exection with two runs\\n    {\\n        int length = 0;\\n        ListNode *p = head;\\n\\n        while (p) // find length\\n        {\\n            length++;\\n            p = p->next;\\n        }\\n\\n        if (n == length) // check if need to remove the first node\\n            return head->next;\\n\\n        length -= n;\\n        length--;\\n\\n        p = head;\\n        while (length--) // get p the node before the n-th from the end\\n            p = p->next;\\n        p->next = p->next->next; // the move the node\\n\\n        return head;\\n    }\\n```\n```\\nListNode *removeNthFromEnd(ListNode *head, int &n) // excution using stack\\n{\\n\\tstack<ListNode *> s;\\n\\tint length = 0;\\n\\n\\tListNode *t = head;\\n\\twhile (t) // push all nodes\\n\\t{\\n\\t\\ts.push(t);\\n\\t\\tt = t->next;\\n\\t\\tlength++;\\n\\t}\\n\\n\\tif (length == n) // if need to remove the first node\\n\\t\\treturn head->next;\\n\\n\\twhile (n--) // get the n-1 node from the end\\n\\t\\ts.pop();\\n\\tt = s.top();\\n\\tt->next = t->next->next; // remove the node\\n\\n\\treturn head;\\n}\\n```\n```\\nListNode *removeNthFromEnd(ListNode *head, int &n)\\n{\\n\\tif(head == NULL) // if end\\n\\t\\treturn NULL;\\n\\n\\thead->next = removeNthFromEnd(head->next,n);// set to the next node\\n\\n\\tif(--n == 0) // do I need to remove this node\\n\\t\\treturn head->next;\\n\\treturn head;\\n}\\n```\n```\\nListNode *removeNthFromEnd(ListNode *head, int &n) // execution with two pointers\\n{\\n\\tListNode *t1 = head;\\n\\n\\twhile (t1 && n--) // get t1 to the  n+1 node thus the difference between t1 and t2 is n at all times\\n\\t\\tt1 = t1->next;\\n\\n\\tif (t1 == NULL) // if need to remove teh first Node\\n\\t\\treturn head->next;\\n\\n\\tListNode *t2 = head;\\n\\twhile (t1->next) // find the node before n-th from the end\\n\\t{\\n\\t\\tt1 = t1->next;\\n\\t\\tt2 = t2->next;\\n\\t}\\n\\tt2->next = t2->next->next;\\n\\n\\treturn head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 222301,
                "title": "javascript",
                "content": "```\\nvar removeNthFromEnd = function(head, n) {\\n  let root = head;\\n  let clone = head;\\n  let len = 0;\\n \\n  while (clone) {\\n    len++;\\n    clone = clone.next;\\n  }\\n  \\n  let count = len - n;\\n  if (count === 0) return head.next;\\n  while (root && count > 1) {\\n    root = root.next;\\n    count--;\\n  }\\n\\n  root.next = root.next && root.next.next;\\n  return head;\\n};\\n```\\n\\n```\\nvar removeNthFromEnd = function(head, n) {\\n  const help = (root, count) => {\\n    if (root.next) count = help(root.next, count);\\n    \\n    if (count === n) root.next = root.next.next;\\n    return ++count;\\n  }\\n  const count = help(head, 0);\\n  return count === n ? head.next : head;\\n};\\n```\\n\\n```\\nvar removeNthFromEnd = function(head, n) {\\n  const root = new ListNode(0);\\n  root.next = head;\\n  let front = root;\\n  let back = root;\\n  while (n >= 0) {\\n    front = front.next;\\n    n--;\\n  }\\n  while (front) {\\n    front = front.next;\\n    back = back.next;\\n  }\\n  back.next = back.next.next;\\n  return root.next;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar removeNthFromEnd = function(head, n) {\\n  let root = head;\\n  let clone = head;\\n  let len = 0;\\n \\n  while (clone) {\\n    len++;\\n    clone = clone.next;\\n  }\\n  \\n  let count = len - n;\\n  if (count === 0) return head.next;\\n  while (root && count > 1) {\\n    root = root.next;\\n    count--;\\n  }\\n\\n  root.next = root.next && root.next.next;\\n  return head;\\n};\\n```\n```\\nvar removeNthFromEnd = function(head, n) {\\n  const help = (root, count) => {\\n    if (root.next) count = help(root.next, count);\\n    \\n    if (count === n) root.next = root.next.next;\\n    return ++count;\\n  }\\n  const count = help(head, 0);\\n  return count === n ? head.next : head;\\n};\\n```\n```\\nvar removeNthFromEnd = function(head, n) {\\n  const root = new ListNode(0);\\n  root.next = head;\\n  let front = root;\\n  let back = root;\\n  while (n >= 0) {\\n    front = front.next;\\n    n--;\\n  }\\n  while (front) {\\n    front = front.next;\\n    back = back.next;\\n  }\\n  back.next = back.next.next;\\n  return root.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 9112,
                "title": "javascript-solution",
                "content": "    var removeNthFromEnd = function(head, n) {\\n        var nullHead = new ListNode(null);\\n        nullHead.next = head;\\n        var p1 = nullHead;\\n        var p2 = nullHead;\\n        \\n        for(var i = 0; i < n + 1; i++)\\n            p1 = p1.next;\\n        while(p1 !== null){\\n            p2 = p2.next;\\n            p1 = p1.next;\\n        }\\n        p2.next = p2.next.next;\\n        return nullHead.next;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var removeNthFromEnd = function(head, n) {\\n        var nullHead = new ListNode(null);\\n        nullHead.next = head;\\n        var p1 = nullHead;\\n        var p2 = nullHead;\\n        \\n        for(var i = 0; i < n + 1; i++)\\n            p1 = p1.next;\\n        while(p1 !== null){\\n            p2 = p2.next;\\n            p1 = p1.next;\\n        }\\n        p2.next = p2.next.next;\\n        return nullHead.next;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 1899619,
                "title": "100-fastest-swift-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    func removeNthFromEnd(_ head: ListNode?, _ n: Int) -> ListNode? {\\n        var fast = head\\n        var slow = head\\n        var count = n\\n\\n        while count > 0 {\\n            count -= 1\\n            fast = fast?.next\\n        }\\n\\n        if fast == nil { return head?.next }\\n\\n        while slow != nil && fast != nil {\\n            if fast?.next == nil { slow?.next = slow?.next?.next } // end\\n            slow = slow?.next\\n            fast = fast?.next\\n        }\\n\\n        return head\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    func removeNthFromEnd(_ head: ListNode?, _ n: Int) -> ListNode? {\\n        var fast = head\\n        var slow = head\\n        var count = n\\n\\n        while count > 0 {\\n            count -= 1\\n            fast = fast?.next\\n        }\\n\\n        if fast == nil { return head?.next }\\n\\n        while slow != nil && fast != nil {\\n            if fast?.next == nil { slow?.next = slow?.next?.next } // end\\n            slow = slow?.next\\n            fast = fast?.next\\n        }\\n\\n        return head\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1698834,
                "title": "19-c-solution-easy-to-understand-with-explanation-conceptual-knowledgable",
                "content": "**Knockcat**\\n```\\n* Detailed Understanding of each Case.\\n* Conceptual Approach.\\n* Worth it Approach.\\n* C syntax also given.\\n```\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *temp = new ListNode;                 //Allocating Memory For New Node using new Keyword;\\n        temp = head;                                   //Initializing it to head;\\n        int cnt = 0;\\n        \\n        while(temp != NULL)\\n        {\\n            cnt++;\\n            temp = temp->next;\\n        }\\n        \\n        if(cnt == 0)\\n            return head;\\n        \\n        int cnt_first = (cnt - n) + 1;               //position of nth node from head\\n        \\n        head = Delete(head , cnt_first , cnt);       //function Delete to Delete the Node\\n        \\n        return head;\\n    }\\n    \\n    ListNode *Delete(ListNode *head, int  pos,int cnt)\\n    {\\n        if(head == NULL)\\n            return head;\\n        \\n        //If Deleted Node happen to be first Node\\n        else if(head != NULL && pos == 1)\\n        {\\n            ListNode *curr = new ListNode;      //Allocating memory using keyword new & then initializing node to head\\n            curr = head;\\n            // ListNode *curr = head;           //C syntax\\n            head = head -> next;\\n            // free(curr);                      //C syntax\\n            delete curr;\\n            curr = NULL;\\n        }\\n        \\n        //If Deleted Node happen to be Last Node\\n        else if(head != NULL && pos == cnt )    \\n        {\\n            ListNode *curr = new ListNode;      //Allocating memory using keyword new & then initializing node to head;\\n            curr = head;\\n            while (curr->next->next != NULL)\\n            {\\n                curr = curr->next;\\n            }\\n            ListNode *temp = new ListNode;\\n            temp = curr->next;\\n            // free(temp);                      //C syntax\\n            delete temp;\\n            temp = NULL;\\n            curr->next = NULL;\\n        }\\n        \\n        else if(cnt < pos || cnt < 1)\\n        {\\n            // cout<<\"Not a valid position\"<<end;\\n        }\\n        \\n        //If Deleted Node happen to be the Intermediate Node\\n        else\\n        {\\n            ListNode *curr = new ListNode;      //Allocating memory using keyword new & then initializing node to head;\\n            curr = head;\\n            ListNode *prev = new ListNode;\\n            prev = head;\\n            // ListNode *prev = NULL, *curr = head; //C syntax\\n            while(pos > 1)\\n            {\\n                prev = curr;\\n                curr = curr -> next;\\n                pos--;\\n            }\\n            prev -> next = curr -> next;\\n            // free(curr);                      //C syntax\\n            delete curr;\\n            curr = NULL;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n* Detailed Understanding of each Case.\\n* Conceptual Approach.\\n* Worth it Approach.\\n* C syntax also given.\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *temp = new ListNode;                 //Allocating Memory For New Node using new Keyword;\\n        temp = head;                                   //Initializing it to head;\\n        int cnt = 0;\\n        \\n        while(temp != NULL)\\n        {\\n            cnt++;\\n            temp = temp->next;\\n        }\\n        \\n        if(cnt == 0)\\n            return head;\\n        \\n        int cnt_first = (cnt - n) + 1;               //position of nth node from head\\n        \\n        head = Delete(head , cnt_first , cnt);       //function Delete to Delete the Node\\n        \\n        return head;\\n    }\\n    \\n    ListNode *Delete(ListNode *head, int  pos,int cnt)\\n    {\\n        if(head == NULL)\\n            return head;\\n        \\n        //If Deleted Node happen to be first Node\\n        else if(head != NULL && pos == 1)\\n        {\\n            ListNode *curr = new ListNode;      //Allocating memory using keyword new & then initializing node to head\\n            curr = head;\\n            // ListNode *curr = head;           //C syntax\\n            head = head -> next;\\n            // free(curr);                      //C syntax\\n            delete curr;\\n            curr = NULL;\\n        }\\n        \\n        //If Deleted Node happen to be Last Node\\n        else if(head != NULL && pos == cnt )    \\n        {\\n            ListNode *curr = new ListNode;      //Allocating memory using keyword new & then initializing node to head;\\n            curr = head;\\n            while (curr->next->next != NULL)\\n            {\\n                curr = curr->next;\\n            }\\n            ListNode *temp = new ListNode;\\n            temp = curr->next;\\n            // free(temp);                      //C syntax\\n            delete temp;\\n            temp = NULL;\\n            curr->next = NULL;\\n        }\\n        \\n        else if(cnt < pos || cnt < 1)\\n        {\\n            // cout<<\"Not a valid position\"<<end;\\n        }\\n        \\n        //If Deleted Node happen to be the Intermediate Node\\n        else\\n        {\\n            ListNode *curr = new ListNode;      //Allocating memory using keyword new & then initializing node to head;\\n            curr = head;\\n            ListNode *prev = new ListNode;\\n            prev = head;\\n            // ListNode *prev = NULL, *curr = head; //C syntax\\n            while(pos > 1)\\n            {\\n                prev = curr;\\n                curr = curr -> next;\\n                pos--;\\n            }\\n            prev -> next = curr -> next;\\n            // free(curr);                      //C syntax\\n            delete curr;\\n            curr = NULL;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1164614,
                "title": "python-two-pointers-approch-explained",
                "content": "Two passes solution is straightforward. For one pass solution we use the idea of `2` iterators, let one of them start at the beginning, another at index `n`, then when the second one is finished, the first one will be on the right place.\\n\\n#### Complexity\\nTime complexity is `O(L)`, more precisely we make `2L-n` steps, where `L` is length of list, space complexity is `O(1)`. So it the end it is exactly the same as staightforward two passes solution. So, if you meet this problem in real interview, you can just explain two pass solution, and when interviewer say can you do better: explain him that another one pass solution in fact is exaclty the same time and space.\\n\\n#### Code\\n```\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        P1, P2 = dummy, dummy\\n        for _ in range(n): P2 = P2.next\\n        \\n        while P2.next:\\n            P1 = P1.next\\n            P2 = P2.next\\n            \\n        P1.next = P1.next.next\\n        \\n        return dummy.next\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        P1, P2 = dummy, dummy\\n        for _ in range(n): P2 = P2.next\\n        \\n        while P2.next:\\n            P1 = P1.next\\n            P2 = P2.next\\n            \\n        P1.next = P1.next.next\\n        \\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222616,
                "title": "java-solution-for-beginners-linkedlist-easy-to-understand",
                "content": "Please **UPVOTE** if you like my solution!\\n\\n```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        int count = 1;\\n        ListNode c = head;\\n        while(c.next!=null){\\n            count++;\\n            c=c.next;\\n        }\\n        \\n        if(n == count){\\n            head = head.next;\\n            return head;\\n        }\\n        \\n        ListNode ln = head;\\n        int i= 0;\\n        while(++i<count-n){\\n            ln = ln.next;  \\n        }\\n        ln.next = ln.next.next;\\n        \\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        int count = 1;\\n        ListNode c = head;\\n        while(c.next!=null){\\n            count++;\\n            c=c.next;\\n        }\\n        \\n        if(n == count){\\n            head = head.next;\\n            return head;\\n        }\\n        \\n        ListNode ln = head;\\n        int i= 0;\\n        while(++i<count-n){\\n            ln = ln.next;  \\n        }\\n        ln.next = ln.next.next;\\n        \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552644,
                "title": "faster-than-100-c-code",
                "content": "idea is to take two pointers and traverse the first pointer n nodes\\ntill the time 2nd pointer will be as it is\\nnow when you\\'ll traverse the both poniters simultaneously then definitely first pointer\\nis gonna be at the position last and 2nd pointer will be just before the node we\\'ve to delete\\n\\nhere first pointer is fast and 2nd pointer is slow; \\nhere is the code implementation os the above approach------------------------\\n```\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *start=new ListNode(); \\n        start->next=head;\\n        ListNode *slow=start,*fast=start;\\n        for(int i=0;i<n;i++)\\n            fast=fast->next; //traverse n nodes\\n        \\n        while(fast->next!=nullptr){  //as i told fast will be at the last node\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        ListNode *del=slow->next; //step to finish matlab khatam krna hai node ko\\n        slow->next=slow->next->next; //next pointer of the slow will point on just after the victim node\\n        delete(del); //Khatam \\uD83D\\uDC7B\\n        return start->next;\\n    }\\n```\\n\\nmy english ;P\\n\\uD83D\\uDE42 why you guys always forget to upvote, it motivates me to post such answers.\\n<a href=\"https://cutt.ly/KalyanChannel\">You can checkout the Youtube channel \\uD83D\\uDCF1  </a>",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *start=new ListNode(); \\n        start->next=head;\\n        ListNode *slow=start,*fast=start;\\n        for(int i=0;i<n;i++)\\n            fast=fast->next; //traverse n nodes\\n        \\n        while(fast->next!=nullptr){  //as i told fast will be at the last node\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        ListNode *del=slow->next; //step to finish matlab khatam krna hai node ko\\n        slow->next=slow->next->next; //next pointer of the slow will point on just after the victim node\\n        delete(del); //Khatam \\uD83D\\uDC7B\\n        return start->next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8874,
                "title": "golang-solution-3ms",
                "content": "Example Input:\\n```\\n| 1 | -> | 2 | -> | 3 | -> | 4 | -> | 5 |\\n\\nFig 1\\n```\\n#### First Approach \\n- The idea is to use two pointers `left` and `right`.\\n- `right` will advance `n` nodes into the list.\\n- At this point `left` will point to the head of the list. (Figure 2)\\n- Then, we walk `left` and `right` in tandem, until `right` reaches the end of the list.\\n- At this point `left` will point to the *Nth node from the end*, which we want to remove.  (Figure 3)\\n```\\nleft                       right\\n| 1 | -> | 2 | -> | 3 | -> | 4 | -> | 5 |\\n\\nFig 2\\n```\\n```\\n                  left                    right\\n| 1 | -> | 2 | -> | 3 | -> | 4 | -> | 5 |   *\\n\\nFig 3\\n```\\nThis will work. However, we have to maintain a previous pointer to `left`, in order to delete `left`. We also need to take care of the corner case where, the node to be deleted is the `head` of our list. i.e when `n` = 5 in our example.\\n\\nWe'll instead follow a cleaner approach which is discussed next.\\n#### Second Approach\\n- We employ a node called the `preHeader` node, whose `Next` pointer points to the head of our list.\\n- Then we point our `left` pointer to the `preHeader` to start off with. (Figure 4)\\n- The advantage of this approach is that, when our `right` pointer gets to the end of our list, `left` will be pointing to the node just before the *Nth node from the end*, which makes deleting that node very straight forward.  (Figure 5/6)\\n- Another advantage is that, we do not need to code anything special for handling the corner case where `n` = 5 in our example. \\n```\\nleft                                 right\\n| ph | -> | 1 | -> | 2 | -> | 3 | -> | 4 | -> | 5 |\\n\\nFig 4\\n```\\n```\\n                   left                             right\\n| ph | -> | 1 | -> | 2 | -> | 3 | -> | 4 | -> | 5 |   *\\n\\nFig 5\\n```\\n```\\n                   left                    right\\n| ph | -> | 1 | -> | 2 | -> | 4 | -> | 5 |   *\\n\\nFig 6\\n```\\n\\n```c\\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {\\n    if head == nil || n <= 0 {return head}\\n    preHeader := &ListNode{Next: head}\\n    left, right := preHeader, head\\n\\n    for i := 0; right != nil && i < n; i++ {\\n        right = right.Next\\n    }\\n    for right != nil {\\n        left, right = left.Next, right.Next\\n    }\\n    left.Next = left.Next.Next\\n    return preHeader.Next\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n| 1 | -> | 2 | -> | 3 | -> | 4 | -> | 5 |\\n\\nFig 1\\n```\n```\\nleft                       right\\n| 1 | -> | 2 | -> | 3 | -> | 4 | -> | 5 |\\n\\nFig 2\\n```\n```\\n                  left                    right\\n| 1 | -> | 2 | -> | 3 | -> | 4 | -> | 5 |   *\\n\\nFig 3\\n```\n```\\nleft                                 right\\n| ph | -> | 1 | -> | 2 | -> | 3 | -> | 4 | -> | 5 |\\n\\nFig 4\\n```\n```\\n                   left                             right\\n| ph | -> | 1 | -> | 2 | -> | 3 | -> | 4 | -> | 5 |   *\\n\\nFig 5\\n```\n```\\n                   left                    right\\n| ph | -> | 1 | -> | 2 | -> | 4 | -> | 5 |   *\\n\\nFig 6\\n```\n```c\\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {\\n    if head == nil || n <= 0 {return head}\\n    preHeader := &ListNode{Next: head}\\n    left, right := preHeader, head\\n\\n    for i := 0; right != nil && i < n; i++ {\\n        right = right.Next\\n    }\\n    for right != nil {\\n        left, right = left.Next, right.Next\\n    }\\n    left.Next = left.Next.Next\\n    return preHeader.Next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 9028,
                "title": "my-java-solution",
                "content": "    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode voidHead = new ListNode(-1);\\n        voidHead.next = head;\\n        ListNode p1 = voidHead;\\n        ListNode p2 = voidHead;\\n        while (p1.next!=null){\\n            p1=p1.next;\\n            if (n--<=0)p2=p2.next;\\n        }\\n        if (p2.next!=null) p2.next=p2.next.next;\\n        return voidHead.next;\\n    }",
                "solutionTags": [],
                "code": "    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode voidHead = new ListNode(-1);\\n        voidHead.next = head;\\n        ListNode p1 = voidHead;\\n        ListNode p2 = voidHead;\\n        while (p1.next!=null){\\n            p1=p1.next;\\n            if (n--<=0)p2=p2.next;\\n        }\\n        if (p2.next!=null) p2.next=p2.next.next;\\n        return voidHead.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1668618,
                "title": "python-one-pass-o-n-faster-than-93-19",
                "content": "```class Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow, fast = head, head\\n        \\n        while n > 0:\\n            fast = fast.next\\n            n -= 1\\n        \\n        while fast is not None and fast.next is not None:\\n            slow = slow.next\\n            fast = fast.next\\n\\n        if fast is not None:\\n            slow.next = slow.next.next\\n        else:\\n            head = head.next\\n        \\n        return head",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```class Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow, fast = head, head\\n        \\n        while n > 0:\\n            fast = fast.next\\n            n -= 1\\n        \\n        while fast is not None and fast.next is not None:\\n            slow = slow.next\\n            fast = fast.next\\n\\n        if fast is not None:\\n            slow.next = slow.next.next\\n        else:\\n            head = head.next\\n        \\n        return head",
                "codeTag": "Java"
            },
            {
                "id": 723171,
                "title": "2-pointer-with-original-submission-and-thought-process-faster-than-98",
                "content": "So this is the original code in my submission. I\\'d apparently visited this a few months back and made a hash of it, but after revisiting having learnt some base techniques it\\'s much easier.\\n\\n**(1)** \\nOk obviously need to delete a node. So best know how to do that. Already in my mind i\\'m seeing:\\n\\n``` \\nconst deleteNextNode = (node) => node.next = node.next.next\\n```\\n\\nWhich means if we want to delete a node, we need to get the node before it.\\n\\n**(2)**\\nThen the other bit, which actually comes before in the description, is to get the `Nth` node from the end. In our case, as we want to get the `Nth` node from the end of the linked list to delete it, we actually want to get the `Nth+1` node **from the end**. Seems like a slow/fast 2 pointer solution.\\n\\nTo do this, i\\'m seeing the beginning of the answer to the entire question:\\n\\n```\\nvar removeNthFromEnd = function(head, n) {\\n\\n    if(!head) return head\\n\\n    let [slow, fast] = [head, head]\\n\\t\\n    // move fast ahead by n\\n\\t// have to be careful about --n or n-- here. \\n\\t// As we want the node before the one we are deleting,\\n\\t// we want fast to be ahead by an additional node\\n\\t// if the question was just to return slow, i\\'d probably use --n instead\\n    while(n--){\\n        fast = fast.next\\n    }\\n    \\n\\t// we want to stop when fast.next is null\\n\\t// we move both along the linked list \\n\\t// keeping the same distance between them\\n    while(fast.next){\\n        [slow, fast] = [slow.next, fast.next]\\n    }\\n\\t...\\n}\\n```\\n\\nOne final issue came up when submitting. What happens when `n` is equal to the length of the linked list. We\\'ll we run into problems. Easiest solution I could think of is to create a dummy node that is before the linked list. That allows us to remove the head node if the Nth node from the end is the head node.\\n\\n**Final submission:**\\n```\\n/**\\n * @param {ListNode} head\\n * @param {number} n\\n * @return {ListNode}\\n */\\nvar removeNthFromEnd = function(head, n) {\\n    if(!head) return head\\n    let begin = { val: -1, next: head }\\n       \\n    let [slow, fast] = [begin, begin]\\n    // move fast ahead by n\\n    while(n--){\\n        fast = fast.next\\n    }\\n    \\n    while(fast.next){\\n        [slow, fast] = [slow.next, fast.next]\\n    }\\n    \\n    // remove slow.next\\n    removeNextNode(slow)\\n    \\n    return begin.next\\n};\\n\\nconst removeNextNode = (node) => { \\n    node.next = node.next.next\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "``` \\nconst deleteNextNode = (node) => node.next = node.next.next\\n```\n```\\nvar removeNthFromEnd = function(head, n) {\\n\\n    if(!head) return head\\n\\n    let [slow, fast] = [head, head]\\n\\t\\n    // move fast ahead by n\\n\\t// have to be careful about --n or n-- here. \\n\\t// As we want the node before the one we are deleting,\\n\\t// we want fast to be ahead by an additional node\\n\\t// if the question was just to return slow, i\\'d probably use --n instead\\n    while(n--){\\n        fast = fast.next\\n    }\\n    \\n\\t// we want to stop when fast.next is null\\n\\t// we move both along the linked list \\n\\t// keeping the same distance between them\\n    while(fast.next){\\n        [slow, fast] = [slow.next, fast.next]\\n    }\\n\\t...\\n}\\n```\n```\\n/**\\n * @param {ListNode} head\\n * @param {number} n\\n * @return {ListNode}\\n */\\nvar removeNthFromEnd = function(head, n) {\\n    if(!head) return head\\n    let begin = { val: -1, next: head }\\n       \\n    let [slow, fast] = [begin, begin]\\n    // move fast ahead by n\\n    while(n--){\\n        fast = fast.next\\n    }\\n    \\n    while(fast.next){\\n        [slow, fast] = [slow.next, fast.next]\\n    }\\n    \\n    // remove slow.next\\n    removeNextNode(slow)\\n    \\n    return begin.next\\n};\\n\\nconst removeNextNode = (node) => { \\n    node.next = node.next.next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 337245,
                "title": "simple-and-easy-to-understand-c-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int size=0;\\n        ListNode* ans=head;\\n        ListNode* check=head;\\n        while(head){\\n            size++;\\n            head=head->next;\\n        }\\n        if(size==1) return NULL;\\n        if(size <= n){\\n            return ans->next;\\n        }\\n        for(int i=1;i<size-n;i++){\\n            check=check->next;\\n        }\\n        check->next=check->next->next;\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int size=0;\\n        ListNode* ans=head;\\n        ListNode* check=head;\\n        while(head){\\n            size++;\\n            head=head->next;\\n        }\\n        if(size==1) return NULL;\\n        if(size <= n){\\n            return ans->next;\\n        }\\n        for(int i=1;i<size-n;i++){\\n            check=check->next;\\n        }\\n        check->next=check->next->next;\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632933,
                "title": "c-0ms-short-simple-code",
                "content": "***DO UPVOTE IF IT HELPS !!!!***\\n\\nLL = **1 -> 2 -> 3 -> 4-> 5 -> null** & n=2\\n\\n1. Initially slow = head, fast = head\\n2. Fast is initialised **\\'n+1\\' positions ahead**.\\n3. Thus, **slow = 1 and fast = 4** (n+1 positions ahead i.e. 2+1 = 3 positions ahead). \\n4. While fast!=NULL, increment **both slow and fast by one**.\\n5. Therefore, slow = 2, fast = 5\\n6. Now, slow = 3, fast = NULL, hence exit form while loop\\n7. Now update **slow->next = slow->next->next.**\\n\\n**TC** = O(N), **SC** = O(1)\\n\\n\\t  ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        \\n        if(head==NULL) return head;\\n        \\n        ListNode *s=head, *f=head;          //2 pointers, slow=head\\n        \\n        for(int i=1;i<=n+1;i++){            //fast is initialised \\'n+1\\' positions ahead\\n            if(f==NULL) return head->next;  \\n            f=f->next;\\n        }\\n        \\n        while(f!=NULL){                     //when fast is NULL, exit\\n            s=s->next;\\n            f=f->next;\\n        }\\n        \\n        s->next=s->next->next;              //update connection\\n        return head;\\n    }",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!***\\n\\nLL = **1 -> 2 -> 3 -> 4-> 5 -> null** & n=2\\n\\n1. Initially slow = head, fast = head\\n2. Fast is initialised **\\'n+1\\' positions ahead**.\\n3. Thus, **slow = 1 and fast = 4** (n+1 positions ahead i.e. 2+1 = 3 positions ahead). \\n4. While fast!=NULL, increment **both slow and fast by one**.\\n5. Therefore, slow = 2, fast = 5\\n6. Now, slow = 3, fast = NULL, hence exit form while loop\\n7. Now update **slow->next = slow->next->next.**\\n\\n**TC** = O(N), **SC** = O(1)\\n\\n\\t  ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        \\n        if(head==NULL) return head;\\n        \\n        ListNode *s=head, *f=head;          //2 pointers, slow=head\\n        \\n        for(int i=1;i<=n+1;i++){            //fast is initialised \\'n+1\\' positions ahead\\n            if(f==NULL) return head->next;  \\n            f=f->next;\\n        }\\n        \\n        while(f!=NULL){                     //when fast is NULL, exit\\n            s=s->next;\\n            f=f->next;\\n        }\\n        \\n        s->next=s->next->next;              //update connection\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2428116,
                "title": "one-pass-simple-c-solution-w-comments-and-explanation",
                "content": "Here\\'s a one-pass solution with the following algorithm:\\n1. Create a dummy node and let the 2 pointers, `fast` and `slow` point to that node. Dummy nodes make things easier, especially when we delete the **first node/head**.\\n2. Position `fast` so that the gap between them is `n`\\n3. To position `slow` just **behind/before the node-to-delete**, move both pointers until `fast.next` is `null` \\n4. After the pointers are positioned where they should, delete the node by pointing `slow.next` to `slow.next.next`\\n5. Return the head via `dummy.next`\\n\\n**Implementation**\\n\\n```\\npublic ListNode RemoveNthFromEnd(ListNode head, int n) {\\n\\tListNode dummy = new(0, head); // Create a dummy node\\n\\tListNode slow = dummy, fast = dummy;\\n\\n\\t// Gap of fast and slow is n\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tfast = fast.next;\\n\\t}\\n\\n\\t// Move slow to the node behind the node to delete\\n\\twhile (fast?.next != null) {\\n\\t\\tslow = slow.next;\\n\\t\\tfast = fast.next;\\n\\t}\\n\\n\\t\\t\\t// Delete the node\\n\\tslow.next = slow.next.next;\\n\\n\\treturn dummy.next;\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Two Pointers"
                ],
                "code": "```\\npublic ListNode RemoveNthFromEnd(ListNode head, int n) {\\n\\tListNode dummy = new(0, head); // Create a dummy node\\n\\tListNode slow = dummy, fast = dummy;\\n\\n\\t// Gap of fast and slow is n\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tfast = fast.next;\\n\\t}\\n\\n\\t// Move slow to the node behind the node to delete\\n\\twhile (fast?.next != null) {\\n\\t\\tslow = slow.next;\\n\\t\\tfast = fast.next;\\n\\t}\\n\\n\\t\\t\\t// Delete the node\\n\\tslow.next = slow.next.next;\\n\\n\\treturn dummy.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1658772,
                "title": "rust-0ms-faster-than-100-recursive-solution-with-backtracking-no-cloning",
                "content": "I want to make a shout out to the online booklet [Learn Rust With Entirely Too Many Linked Lists](https://rust-unofficial.github.io/too-many-lists/) -- it\\'s a good way to learn how to use Rust\\'s built-in tools to massage code to satisfy the borrow chcker. It provides a nice exlaination for using `mem::replace`, when to use it, and `Option\\'s` helpful `take()` function.\\n\\n\\n```\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        remove_nth_from_end_recr(head, n).0\\n    }\\n}\\n    \\nfn remove_nth_from_end_recr(head: Option<Box<ListNode>>, n: i32) -> (Option<Box<ListNode>>, usize) {\\n    match head {\\n        None => (None, 1),\\n        Some(mut node) => {\\n            let (prev, num) = remove_nth_from_end_recr(node.next.take(), n);\\n            if n == num as i32 {\\n                (prev, num+1)\\n            } else {\\n                node.next = prev;\\n                (Some(node), num+1)\\n            }\\n        }\\n    }\\n}\\n```\\n\\n\\n```\\nRuntime: 0 ms, faster than 100.00% of Rust online submissions for Remove Nth Node From End of List.\\nMemory Usage: 2.1 MB, less than 37.35% of Rust online submissions for Remove Nth Node From End of List.\\n```\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        remove_nth_from_end_recr(head, n).0\\n    }\\n}\\n    \\nfn remove_nth_from_end_recr(head: Option<Box<ListNode>>, n: i32) -> (Option<Box<ListNode>>, usize) {\\n    match head {\\n        None => (None, 1),\\n        Some(mut node) => {\\n            let (prev, num) = remove_nth_from_end_recr(node.next.take(), n);\\n            if n == num as i32 {\\n                (prev, num+1)\\n            } else {\\n                node.next = prev;\\n                (Some(node), num+1)\\n            }\\n        }\\n    }\\n}\\n```\n```\\nRuntime: 0 ms, faster than 100.00% of Rust online submissions for Remove Nth Node From End of List.\\nMemory Usage: 2.1 MB, less than 37.35% of Rust online submissions for Remove Nth Node From End of List.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1472058,
                "title": "javascript-99-single-loop-clean-code",
                "content": "1. dummy head to keep the \\'prev\\' for the real head.\\n2. counting in the single loop to avoid the second loop many other solutions used.\\n\\n```\\nvar removeNthFromEnd = function(head, n) { \\n    let dummy = new ListNode(0, head);\\n    let prev = dummy;\\n    let node = head;\\n    let count = 1;\\n    while (node.next) {\\n        if (count === n) {\\n            prev = prev.next;\\n        } else {\\n            count++;\\n        }\\n        node = node.next;\\n    }\\n    prev.next = prev.next.next;\\n    return dummy.next;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeNthFromEnd = function(head, n) { \\n    let dummy = new ListNode(0, head);\\n    let prev = dummy;\\n    let node = head;\\n    let count = 1;\\n    while (node.next) {\\n        if (count === n) {\\n            prev = prev.next;\\n        } else {\\n            count++;\\n        }\\n        node = node.next;\\n    }\\n    prev.next = prev.next.next;\\n    return dummy.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 168502,
                "title": "simple-javascript-99-solution-with-comments",
                "content": "```\\nvar removeNthFromEnd = function(head, n) {\\n    let nodeToReturn = head;\\n    \\n    //Have two pointers, one that is n ahead of the other\\n    let pointer1 = head;\\n    let pointer2 = head;\\n    \\n    //Move pointer2 to be n ahead\\n    for(let i = 0; i<n;i++){\\n        pointer2 = pointer2.next;\\n    }\\n    \\n    //If pointer2 doesn\\'t exist, that means we must remove the head of the list\\n    if(!pointer2){\\n        return nodeToReturn.next;\\n    }\\n    \\n    //Move both pointers until pointer2 reaches the end\\n    while(pointer2.next){\\n        pointer1 = pointer1.next;\\n        pointer2 = pointer2.next;\\n    }\\n\\n    //Save the node two places ahead of pointer1;    \\n    pointer1.next = pointer1.next.next;\\n    \\n    return nodeToReturn;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar removeNthFromEnd = function(head, n) {\\n    let nodeToReturn = head;\\n    \\n    //Have two pointers, one that is n ahead of the other\\n    let pointer1 = head;\\n    let pointer2 = head;\\n    \\n    //Move pointer2 to be n ahead\\n    for(let i = 0; i<n;i++){\\n        pointer2 = pointer2.next;\\n    }\\n    \\n    //If pointer2 doesn\\'t exist, that means we must remove the head of the list\\n    if(!pointer2){\\n        return nodeToReturn.next;\\n    }\\n    \\n    //Move both pointers until pointer2 reaches the end\\n    while(pointer2.next){\\n        pointer1 = pointer1.next;\\n        pointer2 = pointer2.next;\\n    }\\n\\n    //Save the node two places ahead of pointer1;    \\n    pointer1.next = pointer1.next.next;\\n    \\n    return nodeToReturn;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8971,
                "title": "simple-6-line-java-one-pass-solution",
                "content": "public class Solution {\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode start=new ListNode(0),slow=start,fast=start;\\n        start.next=head;\\n        for(int i=0;i<n;i++) fast=fast.next;\\n        while(fast.next!=null) {fast=fast.next;slow=slow.next;}\\n        slow.next=slow.next.next;\\n        return start.next;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode start=new ListNode(0),slow=start,fast=start;\\n        start.next=head;\\n        for(int i=0;i<n;i++) fast=fast.next;\\n        while(fast.next!=null) {fast=fast.next;slow=slow.next;}",
                "codeTag": "Java"
            },
            {
                "id": 9007,
                "title": "python-solution-one-pass",
                "content": "nearly one pass, O(1) space. 44 ms\\n\\n    def removeNthFromEnd(self, head, n):\\n        slow = fast = self\\n        self.next = head\\n        while fast.next:\\n            if n:\\n                n -= 1\\n            else:\\n                slow = slow.next\\n            fast = fast.next\\n        slow.next = slow.next.next\\n        return self.next   \\n\\nreal one pass, but O(n) space,  44 ms  \\n\\n    def removeNthFromEnd(self, head, n):\\n        self.next, nodelist  = head, [self]\\n        while head.next:\\n            if len(nodelist) == n:\\n                nodelist.pop(0)\\n            nodelist += head,\\n            head = head.next\\n        nodelist[0].next = nodelist[0].next.next \\n        return self.next",
                "solutionTags": [
                    "Python"
                ],
                "code": "nearly one pass, O(1) space. 44 ms\\n\\n    def removeNthFromEnd(self, head, n):\\n        slow = fast = self\\n        self.next = head\\n        while fast.next:\\n            if n:\\n                n -= 1\\n            else:\\n                slow = slow.next\\n            fast = fast.next\\n        slow.next = slow.next.next\\n        return self.next   \\n\\nreal one pass, but O(n) space,  44 ms  \\n\\n    def removeNthFromEnd(self, head, n):\\n        self.next, nodelist  = head, [self]\\n        while head.next:\\n            if len(nodelist) == n:\\n                nodelist.pop(0)\\n            nodelist += head,\\n            head = head.next\\n        nodelist[0].next = nodelist[0].next.next \\n        return self.next",
                "codeTag": "Python3"
            },
            {
                "id": 3469283,
                "title": "c-easy-explanation-simple",
                "content": "/* question me dia apko ek linked list di h or bola h Nth node from the end delete krdo  mtlb agar linked list h \\nL1 = [1,2,3,4,5] or N=2 to last 2nd node delete krdo to vo konsi hogi vo hogi vo node jiska data h 4 to hme 4 ko delete krna h iske lia hmne kya kia hmne ek fast pointer lia jo head pe khada h ek slow ha vo bhi head pe h to phle fast ko jb tk chala lo jb tk fast \\'n\\' nhi ho jata fir hmne kya kia ek slow pointer lia usko chlao fast ke sath jb tk fast null nhi ho jata (slow bhi ek step , fast bhi ek step) jse hi fast null ho jae to appka slow us position pe ho jisko delete krna h to abb kya kro slow ke next ko krdo slow ke next ka next */\\n\\n\\n\\n\\nclass Solution {\\n\\npublic:\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\t\\n        ListNode* fast = head;\\n\\t\\t\\n        if(head == NULL)\\n\\t\\t\\n            return NULL;\\n\\t\\t\\t\\n        ListNode* slow = head;\\n        \\n        int count = 1;\\n        while(n--){\\n            cout<<fast->val<<\" \";\\n           fast = fast->next;\\n        }\\n        if(fast== NULL)\\n            return slow->next;\\n            \\n        while(fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next;\\n        }\\n          slow->next = slow->next->next;\\n          return head;\\n       }\\n  \\n};",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\npublic:\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\t\\n        ListNode* fast = head;\\n\\t\\t\\n        if(head == NULL)\\n\\t\\t\\n            return NULL;\\n\\t\\t\\t\\n        ListNode* slow = head;\\n        \\n        int count = 1;\\n        while(n--){\\n            cout<<fast->val<<\" \";\\n           fast = fast->next;\\n        }",
                "codeTag": "C++"
            },
            {
                "id": 2632802,
                "title": "java-2-solutions-explained",
                "content": "```\\n// 1. In one traversal : using slow and fast pointer\\n/*\\ntake two pointer slow and fast\\n- fast will move n position forwards\\n- now move forwards slow and fast both, till fast not reach to end of LL\\n- after performing upper operations, slow will reach to the previous node to the node which we want to delete\\n*/\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n        ListNode slow = head, fast = head;\\n        \\n        // move fast n position forwards\\n        while(n != 0){\\n            fast = fast.next;\\n            n--;\\n        }\\n        \\n        // now move slow and fast both till fast not reach to end of LL\\n        while(fast != null && fast.next != null){\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        \\n        // if fast is null, its mean we want to delete head node\\n        if(fast == null) return head.next;\\n        \\n        // remove node\\n        slow.next = slow.next.next;\\n        \\n        return head;\\n    }\\n}\\n\\n\\n// 2. In two traversal\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n        // find length\\n        int len = 0;\\n        ListNode temp = head;\\n        while(temp != null){\\n            temp = temp.next;\\n            len++;\\n        }\\n        \\n        if(len == n) return head.next;\\n        \\n        // Reach to the previous node of the last node\\n        temp = head;\\n        n = len-n-1;\\n        while(temp.next != null && n != 0){\\n            temp = temp.next;\\n            n--;\\n        }\\n        \\n        // remove \\n        if(temp.next != null)\\n            temp.next = temp.next.next;\\n        \\n        \\n        return head;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n        ListNode slow = head, fast = head;\\n        \\n        // move fast n position forwards\\n        while(n != 0){\\n            fast = fast.next;\\n            n--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2599256,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        if head.next is None:\\n            return None\\n        \\n        size=0\\n        curr= head\\n        while curr!= None:\\n            curr= curr.next\\n            size+=1\\n        if n== size:\\n            return head.next\\n        \\n        indexToSearch= size-n\\n        prev= head\\n        i=1\\n        while i< indexToSearch:\\n            prev= prev.next\\n            i+=1\\n        prev.next= prev.next.next\\n        return head\\n```\\n\\n**UPVOTE** *is the best encouragement for me... Thank you*\\uD83D\\uDE01",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        if head.next is None:\\n            return None\\n        \\n        size=0\\n        curr= head\\n        while curr!= None:\\n            curr= curr.next\\n            size+=1\\n        if n== size:\\n            return head.next\\n        \\n        indexToSearch= size-n\\n        prev= head\\n        i=1\\n        while i< indexToSearch:\\n            prev= prev.next\\n            i+=1\\n        prev.next= prev.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768626,
                "title": "c-efficient-two-pointers-with-comments-explanation",
                "content": "##### If you understand the approach please please upvote!!!\\uD83D\\uDC4D\\n***Thanks :)***\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *slow=head;\\n        ListNode *fast=head;\\n        while(n--) fast = fast -> next;//iterate first n nodes using fast\\n\\t    if(!fast) return head -> next; //if fast is already null, it means we have to delete head itself. So, just return next of head\\n        while(fast->next){//iterate till fast reaches the last node of list\\n            slow=slow->next; \\n            fast=fast->next;\\n        }\\n        slow->next=slow->next->next;// remove the nth node from last\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *slow=head;\\n        ListNode *fast=head;\\n        while(n--) fast = fast -> next;//iterate first n nodes using fast\\n\\t    if(!fast) return head -> next; //if fast is already null, it means we have to delete head itself. So, just return next of head\\n        while(fast->next){//iterate till fast reaches the last node of list\\n            slow=slow->next; \\n            fast=fast->next;\\n        }\\n        slow->next=slow->next->next;// remove the nth node from last\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563061,
                "title": "python-2-simple-solutions",
                "content": "**Python :**\\n\\n**1 :**\\n\\n```\\nclass Solution:\\n    def getLengthOfLL(self, head: Optional[ListNode]) -> int:\\n        length = 0\\n        \\n        while head:\\n            length += 1\\n            head = head.next\\n            \\n        return length\\n            \\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        temp = head\\n        length = self.getLengthOfLL(temp)\\n        if n == length:\\n            return head.next\\n        \\n        if length == 1:\\n            return None\\n        \\n        i = 1\\n        \\n        while temp and i < (length - n):\\n            temp = temp.next\\n            i += 1\\n        \\n        temp.next = temp.next.next        \\n        return head\\n```\\n\\n**2 :**\\n```\\ndef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\tfast = head\\n\\tslow = head\\n\\n\\twhile n:\\n\\t\\tfast = fast.next\\n\\t\\tn -= 1\\n\\n\\tif not fast:\\n\\t\\treturn head.next\\n\\n\\twhile fast.next:\\n\\t\\tslow = slow.next\\n\\t\\tfast = fast.next\\n\\n\\tslow.next = slow.next.next\\n\\treturn head\\n```\\n\\n**Like it ? please upvote !**\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getLengthOfLL(self, head: Optional[ListNode]) -> int:\\n        length = 0\\n        \\n        while head:\\n            length += 1\\n            head = head.next\\n            \\n        return length\\n            \\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        temp = head\\n        length = self.getLengthOfLL(temp)\\n        if n == length:\\n            return head.next\\n        \\n        if length == 1:\\n            return None\\n        \\n        i = 1\\n        \\n        while temp and i < (length - n):\\n            temp = temp.next\\n            i += 1\\n        \\n        temp.next = temp.next.next        \\n        return head\\n```\n```\\ndef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\tfast = head\\n\\tslow = head\\n\\n\\twhile n:\\n\\t\\tfast = fast.next\\n\\t\\tn -= 1\\n\\n\\tif not fast:\\n\\t\\treturn head.next\\n\\n\\twhile fast.next:\\n\\t\\tslow = slow.next\\n\\t\\tfast = fast.next\\n\\n\\tslow.next = slow.next.next\\n\\treturn head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726055,
                "title": "rust-0ms",
                "content": "```\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n         let mut dummy = Box::new(ListNode {\\n            val: -1,\\n            next: head,\\n        });\\n\\n        let mut right = dummy.clone();\\n        let mut left = dummy.as_mut();\\n\\n        for _ in 0..n {\\n            right = right.next.unwrap();\\n        }\\n\\n        while let Some(node) = right.next {\\n            right = node;\\n            left = left.next.as_mut().unwrap();\\n        }\\n\\n        left.next = left.next.as_mut().unwrap().next.clone();\\n\\n        dummy.next\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n         let mut dummy = Box::new(ListNode {\\n            val: -1,\\n            next: head,\\n        });\\n\\n        let mut right = dummy.clone();\\n        let mut left = dummy.as_mut();\\n\\n        for _ in 0..n {\\n            right = right.next.unwrap();\\n        }\\n\\n        while let Some(node) = right.next {\\n            right = node;\\n            left = left.next.as_mut().unwrap();\\n        }\\n\\n        left.next = left.next.as_mut().unwrap().next.clone();\\n\\n        dummy.next\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 414563,
                "title": "rust-safe-code-one-pass-has-to-use-clone-to-bypass-borrow-checker",
                "content": "```\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        let mut dummy = ListNode::new(0);\\n        dummy.next = head;\\n        let mut dummy = Box::new(dummy);\\n        let mut fast = dummy.clone();\\n        let mut slow =  dummy.as_mut();\\n        // move fast n forward\\n        for _ in 0..n {\\n            fast = fast.next.unwrap();\\n        }\\n\\n        while fast.next.is_some() {\\n            fast = fast.next.unwrap();\\n            slow = slow.next.as_mut().unwrap();\\n        }\\n        let next = slow.next.as_mut().unwrap();\\n        slow.next = next.next.clone();\\n        dummy.next\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        let mut dummy = ListNode::new(0);\\n        dummy.next = head;\\n        let mut dummy = Box::new(dummy);\\n        let mut fast = dummy.clone();\\n        let mut slow =  dummy.as_mut();\\n        // move fast n forward\\n        for _ in 0..n {\\n            fast = fast.next.unwrap();\\n        }\\n\\n        while fast.next.is_some() {\\n            fast = fast.next.unwrap();\\n            slow = slow.next.as_mut().unwrap();\\n        }\\n        let next = slow.next.as_mut().unwrap();\\n        slow.next = next.next.clone();\\n        dummy.next\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8996,
                "title": "easy-java-o-1-space-complexity-solution",
                "content": "    public ListNode removeNthFromEnd(ListNode head, int n) {\\n\\n        ListNode start = new ListNode(0);\\n        ListNode n1 = start, n2 = start;\\n        n2.next = head;\\n        \\n        for(int i =0;i<n+1;i++){\\n            n2 = n2.next; // trying o create gab n between two pointers\\n        }\\n        \\n        while(n2 != null){\\n            n1 = n1.next;\\n            n2 = n2.next;\\n        }\\n        \\n        //time to change\\n        n1.next = n1.next.next;\\n        return start.next;\\n    }",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "    public ListNode removeNthFromEnd(ListNode head, int n) {\\n\\n        ListNode start = new ListNode(0);\\n        ListNode n1 = start, n2 = start;\\n        n2.next = head;\\n        \\n        for(int i =0;i<n+1;i++){\\n            n2 = n2.next; // trying o create gab n between two pointers\\n        }\\n        \\n        while(n2 != null){\\n            n1 = n1.next;\\n            n2 = n2.next;\\n        }\\n        \\n        //time to change\\n        n1.next = n1.next.next;\\n        return start.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 9040,
                "title": "simple-one-pass-4ms-c-implementation",
                "content": "    class Solution {\\n    public:\\n        ListNode* removeNthFromEnd(ListNode* head, int n) {\\n            ListNode realHead(0);\\n            realHead.next = head;\\n            head = &realHead;\\n            ListNode *curr = &realHead;\\n            while (n-- > 0)\\n                curr = curr->next;\\n            while (curr->next != nullptr) {\\n                curr = curr->next;\\n                head = head->next;\\n            }\\n    \\n            head->next = head->next->next;\\n            return realHead.next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* removeNthFromEnd(ListNode* head, int n) {\\n            ListNode realHead(0);\\n            realHead.next = head;\\n            head = &realHead;\\n            ListNode *curr = &realHead;\\n            while (n-- > 0)\\n                curr = curr->next;\\n            while (curr->next != nullptr) {\\n                curr = curr->next;\\n                head = head->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3916930,
                "title": "python3-beats-95-efficient-removal-of-nth-node-from-the-end-of-a-linked-list",
                "content": "# Solution no. 01\\nThe first solution helps you understand the basics with simple steps. \\n\\n# Intuition\\n\\nTo determine the node to remove, which is n positions from the end, we need to figure out how many positions we should move from the front to reach the desired node. By counting the total number of nodes in the linked list, we gain this insight and can then adjust the connections accordingly to remove the targeted node from the end.\\n\\n# Approach\\n1. Count the total number of nodes in the linked list by traversing it with a curr pointer.\\n1. Calculate the position to move from the front to reach the node n positions from the end.\\n1. Reset the count and curr to traverse the list again.\\n1. If the node to be removed is the first node, return head.next.\\n1. Traverse the list while keeping track of the count.\\n1. When the count matches the calculated position before the node to be removed, update the connection to skip the node.\\n1. Exit the loop after performing the removal.\\n1. Return the updated head.\\n\\n# Complexity\\n- Time complexity:\\nWe traverse the linked list twice, so the time complexity is O(n), where n is the number of nodes in the list.\\n\\n- Space complexity:\\nWe only use a few variables, so the space complexity is O(1).\\n\\n# Code\\n```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        count = 0\\n        curr = head\\n        while curr:\\n            count += 1\\n            curr = curr.next\\n\\n        check = count - n - 1\\n        count = 0\\n        curr = head\\n\\n        # Removing the first node\\n        if check == -1:  \\n            return head.next\\n\\n        while curr:\\n            if count == check:\\n                curr.next = curr.next.next\\n                # As the removal is done, Exit the loop\\n                break  \\n            curr = curr.next\\n            count += 1\\n\\n        return head\\n\\n```\\n\\n\\n---\\n\\n# Solution no. 02\\n\\n# Intuition\\nIn our first approach we counted the total number of nodes in the linked list and then identify the n-th node from the end by its position from the beginning. While this counting approach could work, it involves traversing the list twice: once to count the nodes and once to find the node to remove. This double traversal can be inefficient, especially for large lists.\\n\\nA more efficient approach comes from recognizing that we don\\'t really need to know the total number of nodes in the list to solve this problem. Instead, we can utilize two pointers to maintain a specific gap between them as they traverse the list. This gap will be the key to identifying the n-th node from the end.\\n\\n# Approach\\n1. We\\'ll use two pointers, first and second, initialized to a dummy node at the beginning of the linked list. The goal is to maintain a gap of n+1 nodes between the two pointers as we traverse the list.\\n\\n1. Move the first pointer n+1 steps ahead, creating a gap of n nodes between first and second.\\n\\n1. Now, move both first and second pointers one step at a time until the first pointer reaches the end of the list. This ensures that the gap between the two pointers remains constant at n nodes.\\n\\n1. When first reaches the end, the second pointer will be pointing to the node right before the node we want to remove (n-th node from the end).\\n\\n1. Update the second.next pointer to skip the n-th node, effectively removing it from the list.\\n\\n# Complexity\\n- Time complexity:\\n The solution involves a single pass through the linked list, so the time complexity is **O(N)**, where N is the number of nodes in the linked list.\\n\\n- Space complexity:\\nWe are using a constant amount of extra space to store the dummy, first, and second pointers, so the space complexity is **O(1)**.\\n\\n# Code\\n```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        \\n        first = dummy\\n        second = dummy\\n        \\n        # Advance first pointer so that the gap between first and second is n+1 nodes apart\\n        for i in range(n+1):\\n            first = first.next\\n        \\n        # Move first to the end, maintaining the gap\\n        while first:\\n            first = first.next\\n            second = second.next\\n        \\n        # Remove the nth node from the end\\n        second.next = second.next.next\\n        \\n        return dummy.next \\n\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        count = 0\\n        curr = head\\n        while curr:\\n            count += 1\\n            curr = curr.next\\n\\n        check = count - n - 1\\n        count = 0\\n        curr = head\\n\\n        # Removing the first node\\n        if check == -1:  \\n            return head.next\\n\\n        while curr:\\n            if count == check:\\n                curr.next = curr.next.next\\n                # As the removal is done, Exit the loop\\n                break  \\n            curr = curr.next\\n            count += 1\\n\\n        return head\\n\\n```\n```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        \\n        first = dummy\\n        second = dummy\\n        \\n        # Advance first pointer so that the gap between first and second is n+1 nodes apart\\n        for i in range(n+1):\\n            first = first.next\\n        \\n        # Move first to the end, maintaining the gap\\n        while first:\\n            first = first.next\\n            second = second.next\\n        \\n        # Remove the nth node from the end\\n        second.next = second.next.next\\n        \\n        return dummy.next \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2558592,
                "title": "2-different-python-solutions-with-explanation",
                "content": "# Solution 1: Two Passes\\nThe reason why this problem is a medium and not an easy one is because we need to remove the nth node **from the end**. To do this, we need to find the length of the linked list. That is why we need 2 passes: one to find the length of the linked list and another to actually remove the node.\\n\\nWe first set `i` as the head and iterate the entire list, with each iteration adding 1 to the length. That is really basic.\\n\\nNow that we have our length, we can remove the node. To remove a node, you set the previous node\\'s link to the node after the one we remove. \\n\\nSay we want to remove node 2: we set 1\\'s next link to 3 instead of 2. Therefore the linked list becomes 0, 1, 3.\\n```txt\\n 0------->1------->2------->3\\n 0        1        2        3\\n|_|----->|_|-------------->|_|\\n```\\n\\nAlso, the corner case is that `n` is the length, in which we don\\'t do anything but return the node after `head`.\\n\\nNow onto removing the node:\\nWe move our `j` pointer to the node **before** the node we want to remove. To do that, we need to mvoe it `length-n-1` times. \\n\\nOnce we are at that desired node, we just set `j`\\'s next pointer to the node after the node we want to remove. \\n\\nFor those of you who are worried about memory leaks: python has a garbage collection system that\\'s automated, so you don\\'t have to take care of that.\\n```py\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        i = head\\n        length = 0\\n        while i:\\n            i = i.next\\n            length += 1\\n            \\n        if length == n:\\n            return head.next\\n        j = head\\n        for x in range(length-n-1):\\n            j = j.next\\n        j.next = j.next.next\\n        return head\\n```\\n\\n# Solution 2: One Pass\\nThis is the optimal solution: we maintain two pointers and are able to do the entire thing (find length and remove node) in **one pass**.\\n\\nThe trick is that the distance between the 2 pointers is `n`, so when we have the right pointer at the end, the left pointer will be exactly at the node before the node we want to remove. \\n\\nNote: to prevent the right node from becoming None (go after the last node), I use `while right.next` instead of `while right` as my loop definition\\n\\nWe first move the right pointer `n` times, so that the distance between the left and right pointers is `n`.\\n\\nNow we maintain this \"window\" and move both pointers until the right pointer is at the end of the list. Now, the left pointer is at the node before the node we want to remove, so we can just remove the node. \\n\\nIf you want to know how to remove a node, I explain it in the first solution (so scroll up). \\n```py\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        left = right = head\\n        for i in range(n):\\n            right = right.next\\n            \\n        if not right:\\n            return left.next\\n        \\n        while right.next:\\n            left = left.next\\n            right = right.next\\n        left.next = left.next.next\\n        return head\\n```\\n\\n**If you liked this, please upvote to support me!**",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```txt\\n 0------->1------->2------->3\\n 0        1        2        3\\n|_|----->|_|-------------->|_|\\n```\n```py\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        i = head\\n        length = 0\\n        while i:\\n            i = i.next\\n            length += 1\\n            \\n        if length == n:\\n            return head.next\\n        j = head\\n        for x in range(length-n-1):\\n            j = j.next\\n        j.next = j.next.next\\n        return head\\n```\n```py\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        left = right = head\\n        for i in range(n):\\n            right = right.next\\n            \\n        if not right:\\n            return left.next\\n        \\n        while right.next:\\n            left = left.next\\n            right = right.next\\n        left.next = left.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1109517,
                "title": "python3-beats-99-97-remove-nth-node-from-list-s-end",
                "content": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        first = second = head\\n        for _ in range(n):\\n            first = first.next\\n            \\n        if not first:\\n            return head.next\\n        while first.next:\\n            first = first.next\\n            second = second.next\\n        \\n        second.next = second.next.next\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        first = second = head\\n        for _ in range(n):\\n            first = first.next\\n            \\n        if not first:\\n            return head.next\\n        while first.next:\\n            first = first.next\\n            second = second.next\\n        \\n        second.next = second.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504455,
                "title": "my-c-solution-one-pass",
                "content": "Runtime: 92 ms, faster than 75.77% of C# online submissions for Remove Nth Node From End of List.\\nMemory Usage: 24.8 MB, less than 10.00% of C# online submissions for Remove Nth Node From End of List.\\n\\n```\\npublic ListNode RemoveNthFromEnd(ListNode head, int n) {\\n    var left = head;\\n    var right = head;\\n\\n    while(right != null) {\\n        right = right.next;\\n        if (n-- < 0) left = left.next; \\n    } \\n\\n    if (n == 0) head = head.next;\\n    else left.next = left.next.next;\\n\\n    return head;        \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode RemoveNthFromEnd(ListNode head, int n) {\\n    var left = head;\\n    var right = head;\\n\\n    while(right != null) {\\n        right = right.next;\\n        if (n-- < 0) left = left.next; \\n    } \\n\\n    if (n == 0) head = head.next;\\n    else left.next = left.next.next;\\n\\n    return head;        \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 9025,
                "title": "simple-python-solution-one-pass",
                "content": "    # Definition for singly-linked list.\\n    # class ListNode(object):\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.next = None\\n    \\n    class Solution(object):\\n        def removeNthFromEnd(self, head, n):\\n            \"\"\"\\n            :type head: ListNode\\n            :type n: int\\n            :rtype: ListNode\\n            \"\"\"\\n            runner = head\\n            slow = head\\n            for i in xrange(n):\\n                runner = runner.next\\n            if runner is None:       # case where n is the length of the list -- remove first node\\n                head = head.next\\n                return head\\n            while runner.next != None:\\n                runner = runner.next\\n                slow = slow.next\\n            slow.next = slow.next.next\\n            return head",
                "solutionTags": [
                    "Python"
                ],
                "code": "    # Definition for singly-linked list.\\n    # class ListNode(object):\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.next = None\\n    \\n    class Solution(object):\\n        def removeNthFromEnd(self, head, n):\\n            \"\"\"\\n            :type head: ListNode\\n            :type n: int\\n            :rtype: ListNode\\n            \"\"\"\\n            runner = head\\n            slow = head\\n            for i in xrange(n):\\n                runner = runner.next\\n            if runner is None:       # case where n is the length of the list -- remove first node\\n                head = head.next\\n                return head\\n            while runner.next != None:\\n                runner = runner.next\\n                slow = slow.next\\n            slow.next = slow.next.next\\n            return head",
                "codeTag": "Java"
            },
            {
                "id": 9095,
                "title": "my-simple-java-solution",
                "content": "    public class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n\\t\\twhile(fast != null) {\\n\\t\\t\\tfast = fast.next;\\n        \\tif(n-- < 0) {\\n        \\t\\tslow = slow.next;\\n        \\t}\\n        }\\n\\t\\t\\n\\t\\tif(n == 0) {\\n\\t\\t\\thead = head.next;\\n\\t\\t} else if(n < 0) {\\n\\t\\t\\tslow.next = slow.next.next;\\n\\t\\t} else {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn head;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n\\t\\twhile(fast != null) {\\n\\t\\t\\tfast = fast.next;\\n        \\tif(n-- < 0) {\\n        \\t\\tslow = slow.next;\\n        \\t}",
                "codeTag": "Java"
            },
            {
                "id": 3748032,
                "title": "c-2-pointers",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int k) {\\n        ListNode *pre_slow, *slow, *fast;\\n        pre_slow=NULL;\\n        slow=fast=head;\\n        \\n        for(int i=0;i<k;i++) fast=fast->next;\\n        \\n        while(fast!=NULL){\\n            pre_slow=slow;\\n            slow=slow->next;\\n            fast=fast->next;\\n        }\\n        \\n        if(pre_slow==NULL){\\n            ListNode* new_head = head->next;\\n            delete head;\\n            return new_head;\\n        }\\n    \\n        pre_slow->next=slow->next;\\n        slow->next=NULL;\\n        delete slow;\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int k) {\\n        ListNode *pre_slow, *slow, *fast;\\n        pre_slow=NULL;\\n        slow=fast=head;\\n        \\n        for(int i=0;i<k;i++) fast=fast->next;\\n        \\n        while(fast!=NULL){\\n            pre_slow=slow;\\n            slow=slow->next;\\n            fast=fast->next;\\n        }\\n        \\n        if(pre_slow==NULL){\\n            ListNode* new_head = head->next;\\n            delete head;\\n            return new_head;\\n        }\\n    \\n        pre_slow->next=slow->next;\\n        slow->next=NULL;\\n        delete slow;\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257400,
                "title": "c-python-easy-one-pass-0-ms-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> nodes;\\n        ListNode* temp = head;\\n        while (temp)\\n        {\\n            nodes.push_back(temp);\\n            temp = temp->next;\\n        }\\n        if (nodes.size()==1) return NULL;\\n        if (nodes.size()-n<=0) return nodes[1];\\n        ListNode* node = nodes[nodes.size()-1-n];\\n        node->next = node->next->next;\\n        return head;\\n    }\\n};\\n```\\n\\n# Python\\n```\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        nodes = []\\n        temp = head\\n        while (temp):\\n            nodes.append(temp)\\n            temp = temp.next\\n        if (len(nodes)==1): return None\\n        if (len(nodes)-n<=0): return nodes[1]\\n        node = nodes[len(nodes)-1-n]\\n        node.next= node.next.next\\n        return head\\n```\\n\\nUpvote if this helps please \\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> nodes;\\n        ListNode* temp = head;\\n        while (temp)\\n        {\\n            nodes.push_back(temp);\\n            temp = temp->next;\\n        }\\n        if (nodes.size()==1) return NULL;\\n        if (nodes.size()-n<=0) return nodes[1];\\n        ListNode* node = nodes[nodes.size()-1-n];\\n        node->next = node->next->next;\\n        return head;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        nodes = []\\n        temp = head\\n        while (temp):\\n            nodes.append(temp)\\n            temp = temp.next\\n        if (len(nodes)==1): return None\\n        if (len(nodes)-n<=0): return nodes[1]\\n        node = nodes[len(nodes)-1-n]\\n        node.next= node.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198611,
                "title": "python-two-pointer-clean-simple-o-n-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        dummy = ListNode()\\n        dummy.next = head\\n\\n        pnt1, pnt2 = dummy, head\\n        for _ in range(n):\\n            pnt2 = pnt2.next\\n\\n        while pnt2:\\n            pnt1, pnt2 = pnt1.next, pnt2.next\\n        \\n        pnt1.next = pnt1.next.next\\n        return dummy.next\\n\\n```\\n\\n## Easy To Understand Solution :\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        trav = head\\n        size = 0\\n        while True:\\n            size += 1\\n            trav = trav.next\\n            if trav == None:\\n                break\\n        \\n        if size == 1:\\n            return None\\n        \\n        if size == n:\\n            return head.next\\n        \\n        \\n        trav = head\\n        while size != n + 1:# or you can write size - n - 1 != 0 :\\n            trav = trav.next\\n            n+=1\\n        \\n        trav.next = trav.next.next\\n        return head\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        dummy = ListNode()\\n        dummy.next = head\\n\\n        pnt1, pnt2 = dummy, head\\n        for _ in range(n):\\n            pnt2 = pnt2.next\\n\\n        while pnt2:\\n            pnt1, pnt2 = pnt1.next, pnt2.next\\n        \\n        pnt1.next = pnt1.next.next\\n        return dummy.next\\n\\n```\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        trav = head\\n        size = 0\\n        while True:\\n            size += 1\\n            trav = trav.next\\n            if trav == None:\\n                break\\n        \\n        if size == 1:\\n            return None\\n        \\n        if size == n:\\n            return head.next\\n        \\n        \\n        trav = head\\n        while size != n + 1:# or you can write size - n - 1 != 0 :\\n            trav = trav.next\\n            n+=1\\n        \\n        trav.next = trav.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061329,
                "title": "javascript-very-very-easy-to-understand-solution-with-video-explanation",
                "content": "Here is video for explain if it is helpful please subscribe! :\\n\\n\\n\\nhttps://youtu.be/yvYtR-KPD6c\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} n\\n * @return {ListNode}\\n */\\nvar removeNthFromEnd = function(head, n) {\\n    let arr = []\\n    let res = new ListNode()\\n    let copy = res;\\n    while(head){\\n        arr.push(head.val)\\n        head = head.next;\\n    }\\n    for(let i =0; i<arr.length;i++){\\n        if(arr.length-i == n) continue;\\n        copy.next = new ListNode(arr[i])\\n        copy = copy.next;\\n    }\\n    return res.next;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} n\\n * @return {ListNode}\\n */\\nvar removeNthFromEnd = function(head, n) {\\n    let arr = []\\n    let res = new ListNode()\\n    let copy = res;\\n    while(head){\\n        arr.push(head.val)\\n        head = head.next;\\n    }\\n    for(let i =0; i<arr.length;i++){\\n        if(arr.length-i == n) continue;\\n        copy.next = new ListNode(arr[i])\\n        copy = copy.next;\\n    }\\n    return res.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2632628,
                "title": "python3-19-remove-nth-node-from-end-of-list-t-m-93-70",
                "content": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        \\n        sz, ptr = 0, head\\n        \\n        while ptr:\\n            ptr = ptr.next\\n            sz+=1\\n\\n        if n==sz:\\n            return head.next\\n\\n        sz -= n+1\\n        ptr = head \\n          \\n        while sz > 0:\\n            ptr = ptr.next\\n            sz-=1\\n            \\n        ptr.next = ptr.next.next   \\n        \\n        return head\\n\\t\\t\\n```\\t\\n\\n[https://leetcode.com/submissions/detail/787596599/](http://)\\n\\t\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        \\n        sz, ptr = 0, head\\n        \\n        while ptr:\\n            ptr = ptr.next\\n            sz+=1\\n\\n        if n==sz:\\n            return head.next\\n\\n        sz -= n+1\\n        ptr = head \\n          \\n        while sz > 0:\\n            ptr = ptr.next\\n            sz-=1\\n            \\n        ptr.next = ptr.next.next   \\n        \\n        return head\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632561,
                "title": "daily-leetcoding-challenge-september-day-28",
                "content": "This problem is the Daily LeetCoding Challenge for September, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-nth-node-from-end-of-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two pass algorithm\n\n  \n**Approach 2:** One pass algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-nth-node-from-end-of-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1460289,
                "title": "java-solution-using-two-pointer-and-in-one-pass",
                "content": "Idea:- For solving this question in one pass we can use two pointer approach. In this approach we make two pointer and maintain a gap of size n-1 between these two pointers. \\nWhen first pointer is at the end of the list we sure that second pointer at n+1 position from end . Now we need only remove nth element with the help of second pointer.\\nThe Only edge case is when (n==size of list).\\n```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode p1=head,p2=head;\\n        while(p1!=null&&p1.next!=null){\\n            if(n<=0){\\n                p2=p2.next;\\n            }\\n            p1=p1.next;\\n            --n;\\n        }\\n        if(n>0){                      // The only edge case removed with this condition\\n            head=head.next;\\n        }else{\\n            p2.next=p2.next.next;\\n        }\\n        return head;\\n    }\\n}\\n// If you like the code and concept than Please UpVote me :)",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode p1=head,p2=head;\\n        while(p1!=null&&p1.next!=null){\\n            if(n<=0){\\n                p2=p2.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1376782,
                "title": "simple-one-pass-solution-in-java-explained-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        // Create two nodes pointing to head;\\n        var first = head;\\n        var second = head;\\n        \\n        // make second node n nodes ahead of first node;\\n        for (int i =0; i <n; i++)\\n            second = second.next;\\n        \\n        // If second node is null, that mean n == list.size-1;\\n        // that means we have to remove the head of the list;\\n        if (second == null)\\n            return first.next;\\n        \\n        // if second node is not null, lets move both first and second nodes\\n        // until second.next == null;\\n        // remember after this, first node will n+1 nodes from the end;\\n        while(second.next != null) {\\n            first = first.next;\\n            second = second.next;\\n        }\\n        \\n        // we can easily skip nth node and make first.next point to n.next;\\n        first.next = first.next.next;\\n        \\n        return head;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        // Create two nodes pointing to head;\\n        var first = head;\\n        var second = head;\\n        \\n        // make second node n nodes ahead of first node;\\n        for (int i =0; i <n; i++)\\n            second = second.next;\\n        \\n        // If second node is null, that mean n == list.size-1;\\n        // that means we have to remove the head of the list;\\n        if (second == null)\\n            return first.next;\\n        \\n        // if second node is not null, lets move both first and second nodes\\n        // until second.next == null;\\n        // remember after this, first node will n+1 nodes from the end;\\n        while(second.next != null) {\\n            first = first.next;\\n            second = second.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 922955,
                "title": "clean-c-solution",
                "content": "```c\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    struct ListNode *p=head, *q=head;\\n\\t// delay by n nodes.\\n    for(int i=0; i<n; i++) {\\n        p = p->next;\\n    }\\n    if(!p) {\\n        //remove head\\n        return head->next;\\n    }\\n\\t// pass through\\n    while(p->next) {\\n        p = p->next;\\n        q = q->next;\\n    }\\n    q->next = q->next->next;\\n    return head;\\n}\\n```\\n\\nAlthough there are two loop, but it is still a one pass solution.",
                "solutionTags": [],
                "code": "```c\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    struct ListNode *p=head, *q=head;\\n\\t// delay by n nodes.\\n    for(int i=0; i<n; i++) {\\n        p = p->next;\\n    }\\n    if(!p) {\\n        //remove head\\n        return head->next;\\n    }\\n\\t// pass through\\n    while(p->next) {\\n        p = p->next;\\n        q = q->next;\\n    }\\n    q->next = q->next->next;\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 913192,
                "title": "two-pointers-farer-than-99-67-memory-less-than-99-98",
                "content": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        fast = head\\n        while n > 0:\\n            fast = fast.next\\n            n -= 1\\n        if not fast: return head.next\\n        slow = head\\n        while fast.next:\\n            fast = fast.next\\n            slow = slow.next\\n        slow.next = slow.next.next\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        fast = head\\n        while n > 0:\\n            fast = fast.next\\n            n -= 1\\n        if not fast: return head.next\\n        slow = head\\n        while fast.next:\\n            fast = fast.next\\n            slow = slow.next\\n        slow.next = slow.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 288895,
                "title": "unsafe-rust-single-pass-solution",
                "content": "The fastest solution is to use two pointers, one in front and the other n step back. When the front pointer hits the end of the list, the tail pointer points at the node to remove. So the front pointer can be immutable while the tail one must be mutable. \\n\\nHowever, we cannot have both an immutable and a mutable reference to the same object in safe rust --- I spent quite some time fighting with the borrow checker and realised this is impossible (correct me if I\\'m wrong) --- so the safe rust solution requires two passes: one for the length of list, the other for removing the node.\\n\\nHere is a solution with unsafe rust which should be the most performant.\\n```\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        unsafe {\\n            let mut head = head;\\n            let mut front: *mut Option<Box<ListNode>> = &mut head;\\n            let mut tail: *mut Option<Box<ListNode>> = &mut head;\\n            for _ in 0..n {\\n                front = &mut (*front).as_mut().unwrap().next;\\n            }\\n            if (*front).is_none() {\\n                return head.take().unwrap().next;\\n            }\\n            loop {\\n                front = &mut (*front).as_mut().unwrap().next;\\n                if (*front).is_none() {\\n                    break;\\n                }\\n                tail = &mut (*tail).as_mut().unwrap().next;\\n            }\\n            (*tail).as_mut().unwrap().next = (*tail).as_mut().unwrap().next.as_mut().unwrap().next.take();\\n            head\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        unsafe {\\n            let mut head = head;\\n            let mut front: *mut Option<Box<ListNode>> = &mut head;\\n            let mut tail: *mut Option<Box<ListNode>> = &mut head;\\n            for _ in 0..n {\\n                front = &mut (*front).as_mut().unwrap().next;\\n            }\\n            if (*front).is_none() {\\n                return head.take().unwrap().next;\\n            }\\n            loop {\\n                front = &mut (*front).as_mut().unwrap().next;\\n                if (*front).is_none() {\\n                    break;\\n                }\\n                tail = &mut (*tail).as_mut().unwrap().next;\\n            }\\n            (*tail).as_mut().unwrap().next = (*tail).as_mut().unwrap().next.as_mut().unwrap().next.take();\\n            head\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 247310,
                "title": "python-one-pass",
                "content": "Suppose the length of linked list is L, the distance between the node to delete and the tail is **|node-tail| = N**. Then **|node-head| = L-N**. So we can use two pointers here to get that **L-N**.\\n\\nPointer **a** first walks N units and there are L-N units left that **a** can walk. Then we have **b** start walking from the head and **a** keep walking simultaneously. \\nAfter **L-N** rounds,  **a** will reach the tail and **b** has walked L-N from the head, with a distance N away from the tail. So when **a** reaches the tail, we know the node that **b** is pointing at is what to delete.\\n\\nIn case the head node is what to delete, we can create a dummy head whose next node is the **head**. Then we have both a and b point at the dummy and eventually return **dummy.next**.\\n```\\ndef removeNthFromEnd(head, n):\\n\\ta = b = dummy = ListNode(0)\\n\\tdummy.next = head\\n\\tfor _ in range(n): \\n\\t\\ta = a.next\\n\\twhile a.next: \\n\\t\\ta, b = a.next, b.next\\n\\tb.next = b.next.next\\n\\treturn dummy.next\\n```\\nIt\\'s a one pass O(n) time O(1) space solution.",
                "solutionTags": [],
                "code": "```\\ndef removeNthFromEnd(head, n):\\n\\ta = b = dummy = ListNode(0)\\n\\tdummy.next = head\\n\\tfor _ in range(n): \\n\\t\\ta = a.next\\n\\twhile a.next: \\n\\t\\ta, b = a.next, b.next\\n\\tb.next = b.next.next\\n\\treturn dummy.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 220627,
                "title": "rust-0-ms-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        let mut dummy_head = Some(Box::new(ListNode {\\n            val: 0, next: head,\\n        }));\\n        let mut len = 0;\\n        {\\n            let mut p = dummy_head.as_ref();\\n            while p.unwrap().next.is_some() {\\n                len += 1;\\n                p = p.unwrap().next.as_ref();\\n            }\\n        }\\n        let idx = len - n;\\n        {\\n            let mut p = dummy_head.as_mut();\\n            for _ in 0..(idx) {\\n                p = p.unwrap().next.as_mut();\\n            }\\n            let next = p.as_mut().unwrap().next.as_mut().unwrap().next.take();\\n            p.as_mut().unwrap().next = next;\\n        }\\n        dummy_head.unwrap().next\\n    }\\n}\\n```\\nAfter hours figting with borrow checker, I think the \"One Pass\" algorithm cannot be written in Rust without `unsafe`. \\nBut actually the two pass solution is just as fast as one pass solution (times of moving pointer should be same), so just take it.",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        let mut dummy_head = Some(Box::new(ListNode {\\n            val: 0, next: head,\\n        }));\\n        let mut len = 0;\\n        {\\n            let mut p = dummy_head.as_ref();\\n            while p.unwrap().next.is_some() {\\n                len += 1;\\n                p = p.unwrap().next.as_ref();\\n            }\\n        }\\n        let idx = len - n;\\n        {\\n            let mut p = dummy_head.as_mut();\\n            for _ in 0..(idx) {\\n                p = p.unwrap().next.as_mut();\\n            }\\n            let next = p.as_mut().unwrap().next.as_mut().unwrap().next.take();\\n            p.as_mut().unwrap().next = next;\\n        }\\n        dummy_head.unwrap().next\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 9101,
                "title": "my-c-solution",
                "content": "    class Solution {\\n    public:\\n        ListNode *removeNthFromEnd(ListNode *head, int n) {\\n            ListNode* front = new ListNode(0);\\n    \\t\\tfront->next = head;\\n    \\t\\tListNode* prev = front;\\n    \\t\\tListNode* post = front;\\n    \\t\\twhile (prev != nullptr){\\n    \\t\\t\\tprev = prev->next;\\n    \\t\\t\\tif (n<0)\\tpost = post->next;\\n    \\t\\t\\tn--;\\n    \\t\\t}\\n    \\t\\tListNode* temp = post->next;\\n    \\t\\tpost->next = temp->next;\\n    \\t\\tdelete temp;\\n    \\t\\treturn front->next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode *removeNthFromEnd(ListNode *head, int n) {\\n            ListNode* front = new ListNode(0);\\n    \\t\\tfront->next = head;\\n    \\t\\tListNode* prev = front;\\n    \\t\\tListNode* post = front;\\n    \\t\\twhile (prev != nullptr){\\n    \\t\\t\\tprev = prev->next;\\n    \\t\\t\\tif (n<0)\\tpost = post->next;\\n    \\t\\t\\tn--;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 8819,
                "title": "my-one-pass-solution-with-two-pointers",
                "content": "    class Solution:\\n\\tdef removeNthFromEnd(self, head, n):\\n\\t\\tcur = head\\n\\t\\tnpre= head\\n\\t\\tdis = 0\\n\\t\\tcount = 1\\n\\t\\twhile cur.next is not None:\\n\\t\\t\\tcur = cur.next\\n\\t\\t\\tcount += 1\\n\\t\\t\\tdis += 1\\n\\t\\t\\twhile dis > n:\\n\\t\\t\\t\\tnpre = npre.next\\n\\t\\t\\t\\tdis -= 1\\n\\t\\tif count <= n:\\n\\t\\t\\treturn head.next\\n\\t\\tnpre.next = npre.next.next\\n\\t\\treturn head\\n\\nYou should pay attention to the case which removes the first node.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n\\tdef removeNthFromEnd(self, head, n):\\n\\t\\tcur = head\\n\\t\\tnpre= head\\n\\t\\tdis = 0\\n\\t\\tcount = 1\\n\\t\\twhile cur.next is not None:\\n\\t\\t\\tcur = cur.next\\n\\t\\t\\tcount += 1\\n\\t\\t\\tdis += 1\\n\\t\\t\\twhile dis > n:\\n\\t\\t\\t\\tnpre = npre.next\\n\\t\\t\\t\\tdis -= 1\\n\\t\\tif count <= n:\\n\\t\\t\\treturn head.next\\n\\t\\tnpre.next = npre.next.next\\n\\t\\treturn head\\n\\nYou should pay attention to the case which removes the first node.",
                "codeTag": "Java"
            },
            {
                "id": 3145684,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nTwo Pass\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if (head->next == NULL && n == 1)\\n            return NULL;\\n        ListNode* curr = head;\\n        int count = 0;\\n        while (curr != NULL) {\\n            count++;\\n            curr = curr->next;\\n        }\\n        if (count == n)\\n            return head->next;\\n        int cnt = count - n - 1;\\n        curr = head;\\n        while (cnt--) \\n            curr = curr->next;\\n        curr->next = curr->next->next;\\n        return head;\\n    }\\n};\\n```\\n\\n# Approach 2\\nOne Pass\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if (head->next == NULL && n == 1)\\n            return NULL;\\n        ListNode* slow = head, * fast = head;\\n        while (n--) \\n            fast = fast->next;\\n        if (fast == NULL)\\n            return head->next;    \\n        while (fast->next != NULL) {\\n            slow = slow->next;\\n            fast = fast->next;\\n        }    \\n        slow->next = slow->next->next;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if (head->next == NULL && n == 1)\\n            return NULL;\\n        ListNode* curr = head;\\n        int count = 0;\\n        while (curr != NULL) {\\n            count++;\\n            curr = curr->next;\\n        }\\n        if (count == n)\\n            return head->next;\\n        int cnt = count - n - 1;\\n        curr = head;\\n        while (cnt--) \\n            curr = curr->next;\\n        curr->next = curr->next->next;\\n        return head;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if (head->next == NULL && n == 1)\\n            return NULL;\\n        ListNode* slow = head, * fast = head;\\n        while (n--) \\n            fast = fast->next;\\n        if (fast == NULL)\\n            return head->next;    \\n        while (fast->next != NULL) {\\n            slow = slow->next;\\n            fast = fast->next;\\n        }    \\n        slow->next = slow->next->next;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100048,
                "title": "beats-100-c-easy-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMake a gap of N between two pointers, \\nthen increment both pointer one step at a time, until succeeding pointer reaches the end!\\nThe preceding pointer will automatically be pointing at \\n(LL.size() - n)th position.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(!head->next){\\n            return head->next;\\n        }\\n        ListNode* prevHold = NULL;\\n        ListNode* prev = head;\\n        ListNode* fwd = head;\\n        --n;\\n        while(n--){\\n            fwd = fwd->next;\\n        }\\n        if(!fwd->next){\\n            return head->next;\\n        }\\n        while(fwd->next){\\n            prevHold = prev;\\n            prev = prev->next;\\n            fwd = fwd->next;\\n        }\\n        prevHold->next = prev->next;\\n        delete prev;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(!head->next){\\n            return head->next;\\n        }\\n        ListNode* prevHold = NULL;\\n        ListNode* prev = head;\\n        ListNode* fwd = head;\\n        --n;\\n        while(n--){\\n            fwd = fwd->next;\\n        }\\n        if(!fwd->next){\\n            return head->next;\\n        }\\n        while(fwd->next){\\n            prevHold = prev;\\n            prev = prev->next;\\n            fwd = fwd->next;\\n        }\\n        prevHold->next = prev->next;\\n        delete prev;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2637475,
                "title": "simple-beginner-friendly-easy-to-understand-0ms",
                "content": "```class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* dummynode = new ListNode(0);  // creating dummy node;\\n\\t\\t\\n\\t\\t// if head has only one node (base case)\\n        if(head->next==NULL){\\n            head=head->next;\\n            delete(head);\\n            return dummynode->next;\\n        }\\n        dummynode->next=head; // dummy node pointing to head\\n        ListNode* prev=head;  // previous pointer to store previous node\\n        ListNode* curr=head; // current poninter to point current node\\n        int count=1;\\n        while(curr->next!=NULL){\\n                if(count!=n){\\n                    count++;\\n                    curr=curr->next;\\n                    continue;\\n                }\\n            curr=curr->next;\\n            prev=prev->next;\\n        }\\n        \\n\\t\\t\\n\\t\\t//if we have to delete head;\\n\\t\\t\\n        if(dummynode->next==head && count!=1 && prev==head){\\n            dummynode->next=head->next;\\n            return dummynode->next;\\n        }\\n\\t\\t// traversing till one node begind prev node\\n        while(head->next!=prev && head!=prev){\\n            head=head->next;\\n        }\\n        head->next=prev->next;\\n        \\n        return dummynode->next;\\n        \\n    }\\n};```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* dummynode = new ListNode(0);  // creating dummy node;\\n\\t\\t\\n\\t\\t// if head has only one node (base case)\\n        if(head->next==NULL){\\n            head=head->next;\\n            delete(head);\\n            return dummynode->next;\\n        }\\n        dummynode->next=head; // dummy node pointing to head\\n        ListNode* prev=head;  // previous pointer to store previous node\\n        ListNode* curr=head; // current poninter to point current node\\n        int count=1;\\n        while(curr->next!=NULL){\\n                if(count!=n){\\n                    count++;\\n                    curr=curr->next;\\n                    continue;\\n                }\\n            curr=curr->next;\\n            prev=prev->next;\\n        }\\n        \\n\\t\\t\\n\\t\\t//if we have to delete head;\\n\\t\\t\\n        if(dummynode->next==head && count!=1 && prev==head){\\n            dummynode->next=head->next;\\n            return dummynode->next;\\n        }\\n\\t\\t// traversing till one node begind prev node\\n        while(head->next!=prev && head!=prev){\\n            head=head->next;\\n        }\\n        head->next=prev->next;\\n        \\n        return dummynode->next;\\n        \\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2423563,
                "title": "python-simple-and-clean-beats-90-69",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n*This is an NFT*\\n\\n**Runner Method**\\n1. Instantiate the fast and slow runner\\n2. *fast* runner moves *n* steps ahead of the *slow* runner\\n3. Meanwhile, the *fast* runner reaches the end, *slow* runner will be at the prev node of the target node.\\n4. Then we just delete the target node and return the head the of the LL.\\n\\n***Implementation***\\n\\n```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        #Step 1\\n\\t\\tslow = fast = head\\n\\t\\t\\n\\t\\t#Step 2\\n        while(n>0):\\n            fast = fast.next\\n            n-=1\\n\\t\\t\\t\\n\\t\\t#Step 3\\n        while(fast and fast.next):\\n            slow = slow.next\\n            fast = fast.next\\n\\t\\t\\t\\n\\t\\t#Step 4\\n        if(fast):\\n            slow.next = slow.next.next\\n        else:\\n            head = head.next\\n        return head\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        #Step 1\\n\\t\\tslow = fast = head\\n\\t\\t\\n\\t\\t#Step 2\\n        while(n>0):\\n            fast = fast.next\\n            n-=1\\n\\t\\t\\t\\n\\t\\t#Step 3\\n        while(fast and fast.next):\\n            slow = slow.next\\n            fast = fast.next\\n\\t\\t\\t\\n\\t\\t#Step 4\\n        if(fast):\\n            slow.next = slow.next.next\\n        else:\\n            head = head.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706885,
                "title": "my-single-loop-solution-in-c-o-n-time-o-1-space-complexity",
                "content": "```\\nListNode *removeNthFromEnd(ListNode *head, int n){\\n    ListNode *p = head, *q = head;\\n    while (q) {\\n        if (n < 0)  p = p->next;\\n        else  n--;\\n        q = q->next;\\n    }\\n    if (n == 0) head = head->next;\\n    else  p->next = p->next->next;\\n    return head;\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nListNode *removeNthFromEnd(ListNode *head, int n){\\n    ListNode *p = head, *q = head;\\n    while (q) {\\n        if (n < 0)  p = p->next;\\n        else  n--;\\n        q = q->next;\\n    }\\n    if (n == 0) head = head->next;\\n    else  p->next = p->next->next;\\n    return head;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1677829,
                "title": "c-two-pointer-easy-to-understand-time-o-n-space-o-1",
                "content": "![image](https://assets.leetcode.com/users/images/aa9908c4-58aa-4d16-a850-5885515a9064_1642417916.7980297.jpeg)\\n**Please Upvote if it helps...!**\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n        int count = n;\\n        while(count > 0)\\n        {\\n            fast = fast->next;\\n            count--;\\n        }      \\n        if(fast == NULL)\\n        {\\n            return head->next; // edge case handled\\n        }   \\n        while(fast->next!=NULL)\\n        {\\n            slow=slow->next; \\n            fast=fast->next;\\n        }\\n        slow->next = slow->next->next;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n        int count = n;\\n        while(count > 0)\\n        {\\n            fast = fast->next;\\n            count--;\\n        }      \\n        if(fast == NULL)\\n        {\\n            return head->next; // edge case handled\\n        }   \\n        while(fast->next!=NULL)\\n        {\\n            slow=slow->next; \\n            fast=fast->next;\\n        }\\n        slow->next = slow->next->next;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529913,
                "title": "c-one-pass-100-fast-recursion-solution-with-picture",
                "content": "\\n![image](https://assets.leetcode.com/users/images/263aacc8-9c23-403b-b1b0-4ea6dd31b992_1634740578.2843018.jpeg)\\n\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n    int remove(ListNode* head, int n)\\n    {\\n        if(head==NULL)\\n            return 0;\\n        \\n        int steps = remove(head->next, n); //steps to reach the last node from head->next node\\n            \\n        if(steps == n)   //if head->next is the node that we need to remove\\n            head->next = head->next->next;   //then remove it\\n        \\n        return steps+1;\\n    }\\n\\t\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        \\n        if(remove(head, n) == n)   //if head is the node that we need to remove \\n            head = head->next;     \\n        \\n        return head;\\n    }\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int remove(ListNode* head, int n)\\n    {\\n        if(head==NULL)\\n            return 0;\\n        \\n        int steps = remove(head->next, n); //steps to reach the last node from head->next node\\n            \\n        if(steps == n)   //if head->next is the node that we need to remove\\n            head->next = head->next->next;   //then remove it\\n        \\n        return steps+1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1517658,
                "title": "javascript-100-very-simple-tortoise-hare-array-versions",
                "content": "![image](https://assets.leetcode.com/users/images/200ef282-0c57-426a-885e-d02d887785ab_1634065405.0991726.png)\\n\\n\\nEDIT: Upon further testing, the Array tracking version at the bottom seems to consistently score better runtimes here on LC.  They\\'re both O(n).  I still think that this is a classic Tortoise and Hare problem, and that\\'s what they\\'ll be looking for.  But you can Easily defend the Array version as well imo (On Time Complexity at least.  It\\'s still worse on space because it\\'s O(n) space whereas Tortoise and Hare is O(1).).  Take your pick. \\n\\nI wrote two solutions for this problem.  First is the most performant, and the most \\'clever\\' solution that they\\'ll probably want in an interview.  First solution uses tortoise and hare pointers to locate the node which needs to be removed.  Second is FAR easier to code imo, but I\\'m not sure they would consider it optimal in an interview if they\\'re looking for constant space.  Second stores linked list nodes in an array and then we can locate which nodes we need Very easily and remove them.  That said, it does take extra space to store in the array and this is a classic \\'tortoise and hare\\' problem - so if they\\'re asking it, they\\'re likely looking for the first solution.  If you strugle to implement it on the spot though, the second version might save face in a pinch.\\n\\nEitherway though, the basic intuition is to \\'locate\\' the node Before the one to be removed.  There are three possibilities here.  1.) Node to be removed is the head node.  I.E. - The one we need to locate Before it doesn\\'t exist.  In this case, our hare will end up at null after it loops. Or in the Array version, llMap.length - n - 1 will be -1.  We then just simply return head.next which \\'removes\\' the original head node.  2.) Node to be removed is at the End of the list.  In this case, our node Before it has a node.next, but node.next.next = null.  Here our code for case 3 works as well because it will just set node.next = null, which \\'removes\\' our node.next (The last node.) 3.)  Normal Linked List node removal.  There is a node.next (One to be removed since we located the node Before it.), and there is a node.next.next.  In this case, we just set node.next = node.next.next and the node is removed.  Hardest part about this problem is locating the correct node.  Tortoise and Hare both start at head.  We then move hare forward n.  After moving hare, we check to see if hare === null (!hare).  If it does, we know the node to remove is the first and we go with case 1.  Then we begin to move tortoise and hare in tandem until hare.next === null.  This means hare is now at the end of the list and turtle is one before the node we need to remove. We have located the correct node.  The storing in an array one is pretty simple, we just store them, and can instantly look up the nth from the end by its array index.\\n\\n```\\nconst removeNthFromEnd = (head, n) => {  \\n  let tortoise = head, hare = head;\\n  \\n  while (n) hare = hare.next, n--;\\n  if (!hare) return head.next;\\n  \\n  while (hare.next) hare = hare.next, tortoise = tortoise.next;       \\n         \\n  tortoise.next = tortoise.next.next\\n  \\n  return head\\n}\\n```\\n\\nTrack by array version.\\n\\n```\\nconst removeNthFromEnd = (head, n) => {\\n  const llMap = [];\\n  \\n  while (head) {\\n    llMap.push(head);\\n    head = head.next;\\n  }\\n    \\n  const prevNode = llMap[llMap.length - n - 1];\\n  \\n  if (!prevNode) return llMap[0].next;\\n  \\n  prevNode.next = prevNode.next.next;\\n    \\n  return llMap[0];\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst removeNthFromEnd = (head, n) => {  \\n  let tortoise = head, hare = head;\\n  \\n  while (n) hare = hare.next, n--;\\n  if (!hare) return head.next;\\n  \\n  while (hare.next) hare = hare.next, tortoise = tortoise.next;       \\n         \\n  tortoise.next = tortoise.next.next\\n  \\n  return head\\n}\\n```\n```\\nconst removeNthFromEnd = (head, n) => {\\n  const llMap = [];\\n  \\n  while (head) {\\n    llMap.push(head);\\n    head = head.next;\\n  }\\n    \\n  const prevNode = llMap[llMap.length - n - 1];\\n  \\n  if (!prevNode) return llMap[0].next;\\n  \\n  prevNode.next = prevNode.next.next;\\n    \\n  return llMap[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1406874,
                "title": "java-brute-force-appraoch",
                "content": "**This is not most optimise!!**\\n1.First we find out the length of linkedlist ;\\n2.then we will loop till the length - n ;\\n3.then we change the **curr.next** to **curr.next.next** ;\\n```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode p = head;\\n        head = dummy;\\n            \\n        ListNode temp  = head;\\n        int len = size(head);\\n        int i = 0;\\n        if(len <= 1){\\n            return null;\\n        }\\n        \\n        while( i < len - n-1){\\n            temp = temp.next;\\n            i += 1;\\n        }\\n        temp.next = temp.next.next;\\n        return head.next;\\n        \\n    }\\n    public int size(ListNode head){\\n        int size = 0;\\n        while(head != null){\\n            head = head.next;\\n            size++;\\n        }\\n        return size;\\n    }\\n}\\n//This is not most optimise but still we get 0ms Runtime\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode p = head;\\n        head = dummy;\\n            \\n        ListNode temp  = head;\\n        int len = size(head);\\n        int i = 0;\\n        if(len <= 1){\\n            return null;\\n        }\\n        \\n        while( i < len - n-1){\\n            temp = temp.next;\\n            i += 1;\\n        }\\n        temp.next = temp.next.next;\\n        return head.next;\\n        \\n    }\\n    public int size(ListNode head){\\n        int size = 0;\\n        while(head != null){\\n            head = head.next;\\n            size++;\\n        }\\n        return size;\\n    }\\n}\\n//This is not most optimise but still we get 0ms Runtime\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304109,
                "title": "c-edge-case-handled-o-n-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n//         making three pointers to listNode curr,prev and fi\\n        ListNode* curr=head,*prev=head;\\n        ListNode* fi=NULL;\\n\\n        int x=n;\\n        int count=0;\\n//         incrementing curr n times\\n        while(n--)\\n        {\\n            curr=curr->next;\\n            count++;\\n        }\\n//         check if the number is first to delete or not\\n          if(curr==NULL && x==count)\\n                return head->next;\\n//         if its not the first to delete and the nth node is out of bound\\n            else if(curr==NULL)\\n                return head;\\n       \\n//        simply increment curr till NULL and increment prev as well mainaining a previous pointer\\n        while(curr!=NULL)\\n        {\\n            curr=curr->next;\\n            fi=prev;\\n            prev=prev->next;\\n        }\\n//         deleting the pointer\\n        fi->next=prev->next;\\n//         return the head \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n//         making three pointers to listNode curr,prev and fi\\n        ListNode* curr=head,*prev=head;\\n        ListNode* fi=NULL;\\n\\n        int x=n;\\n        int count=0;\\n//         incrementing curr n times\\n        while(n--)\\n        {\\n            curr=curr->next;\\n            count++;\\n        }\\n//         check if the number is first to delete or not\\n          if(curr==NULL && x==count)\\n                return head->next;\\n//         if its not the first to delete and the nth node is out of bound\\n            else if(curr==NULL)\\n                return head;\\n       \\n//        simply increment curr till NULL and increment prev as well mainaining a previous pointer\\n        while(curr!=NULL)\\n        {\\n            curr=curr->next;\\n            fi=prev;\\n            prev=prev->next;\\n        }\\n//         deleting the pointer\\n        fi->next=prev->next;\\n//         return the head \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867059,
                "title": "c-recursion-faster-than-92-78",
                "content": "```\\n    private int m = 0;\\n    \\n    public ListNode RemoveNthFromEnd(ListNode head, int n) {\\n            \\n        if (head == null)\\n        {\\n            return null;\\n        }\\n\\n        var h = RemoveNthFromEnd(head.next, n);\\n\\n        m++;\\n        if (m == n) return h;\\n\\n        head.next = h;\\n        return head;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private int m = 0;\\n    \\n    public ListNode RemoveNthFromEnd(ListNode head, int n) {\\n            \\n        if (head == null)\\n        {\\n            return null;\\n        }\\n\\n        var h = RemoveNthFromEnd(head.next, n);\\n\\n        m++;\\n        if (m == n) return h;\\n\\n        head.next = h;\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 609269,
                "title": "javascript-solution",
                "content": "```\\nlet removeNthFromEnd = function(head, n) {\\n    let p = head, node = head\\n    \\n    while(n--){\\n        p = p.next\\n    }\\n    while(p && p.next ) {\\n        p = p.next\\n        node = node.next\\n    }\\n    \\n    if(!p)  head = head.next\\n    else node.next = node.next.next\\n\\n    return head\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet removeNthFromEnd = function(head, n) {\\n    let p = head, node = head\\n    \\n    while(n--){\\n        p = p.next\\n    }\\n    while(p && p.next ) {\\n        p = p.next\\n        node = node.next\\n    }\\n    \\n    if(!p)  head = head.next\\n    else node.next = node.next.next\\n\\n    return head\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 364537,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode newHead = new ListNode(0);\\n        newHead.next = head;\\n        ListNode a = newHead;\\n        ListNode b = newHead;\\n        while(n > 0){\\n            b = b.next;\\n            n--;\\n        }\\n        while(b.next != null){\\n            b = b.next;\\n            a = a.next;\\n        }\\n        a.next = a.next.next;\\n        return newHead.next;\\n    }\\n}\\n```\\n\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Remove Nth Node From End of List.\\nMemory Usage: 34.8 MB, less than 100.00% of Java online submissions for Remove Nth Node From End of List.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode newHead = new ListNode(0);\\n        newHead.next = head;\\n        ListNode a = newHead;\\n        ListNode b = newHead;\\n        while(n > 0){\\n            b = b.next;\\n            n--;\\n        }\\n        while(b.next != null){\\n            b = b.next;\\n            a = a.next;\\n        }\\n        a.next = a.next.next;\\n        return newHead.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295314,
                "title": "c-brute-force-to-clean-solution-with-explanation",
                "content": "When displaying these problems, developers should show the thought process. \\nHere I show the brute force solution and the cleaner solution. \\n\\n\\nNote the similarities:\\n1. Intialization - Creating that first empty node handles the zero condition\\n2. Deletion - Basic principle of a linked list\\n\\n--------------------------------\\n\\n**BRUTE FORCE**\\nThe brute force uses getting a count first. \\nIt\\'s not pretty but the biggest issue is looping through the list twice. \\n\\n```\\npublic class Solution {\\n    public ListNode RemoveNthFromEnd(ListNode head, int n) {\\n        var start = new ListNode(0);\\n        var node = start;\\n        node.next = head;\\n\\t\\t\\n        // Get Count\\n        var count = GetCount(head);\\n\\t\\t\\n        // Iterate to node to Skip\\n        for(int i = 0; i < count - n; i++) {\\n            node = node.next;\\n        }\\n\\t\\t\\n        // Remove Node\\n        node.next = node.next.next;\\n\\n        return start.next;\\n    }\\n    \\n    private int GetCount(ListNode head) {\\n        var count = 0;\\n        var current = head;\\n        while(current != null) {\\n            count++;\\n            current = current.next;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n------------------------------------------------------------------\\n\\n**DOUBLE POINTER**\\n\\nIf you understand the method to get the count, this becomes more feasible. \\n\\nThe solution that everyone has posted repeatedly. \\n1. Fast pointer - exactly n ahead slow\\n2. Slow pointer - the pointer that will hit length - n\\n\\n```\\npublic class Solution {\\n    public ListNode RemoveNthFromEnd(ListNode head, int n) { \\n        var start = new ListNode(0);\\n        var slow = start;\\n        var fast = start;\\n        slow.next = head;\\n    \\n        // Fast is n in front of slow\\n        for(int i = 0; i <= n;  i++)   {\\n            fast = fast.next;\\n        }\\n        \\n        // When Fast is at end, Slow is at end - n\\n        while(fast != null) {\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        \\n        // Remove Node\\n        slow.next = slow.next.next;\\n\\n        return start.next;\\n    }    \\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public ListNode RemoveNthFromEnd(ListNode head, int n) {\\n        var start = new ListNode(0);\\n        var node = start;\\n        node.next = head;\\n\\t\\t\\n        // Get Count\\n        var count = GetCount(head);\\n\\t\\t\\n        // Iterate to node to Skip\\n        for(int i = 0; i < count - n; i++) {\\n            node = node.next;\\n        }\\n\\t\\t\\n        // Remove Node\\n        node.next = node.next.next;\\n\\n        return start.next;\\n    }\\n    \\n    private int GetCount(ListNode head) {\\n        var count = 0;\\n        var current = head;\\n        while(current != null) {\\n            count++;\\n            current = current.next;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public ListNode RemoveNthFromEnd(ListNode head, int n) { \\n        var start = new ListNode(0);\\n        var slow = start;\\n        var fast = start;\\n        slow.next = head;\\n    \\n        // Fast is n in front of slow\\n        for(int i = 0; i <= n;  i++)   {\\n            fast = fast.next;\\n        }\\n        \\n        // When Fast is at end, Slow is at end - n\\n        while(fast != null) {\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        \\n        // Remove Node\\n        slow.next = slow.next.next;\\n\\n        return start.next;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 229716,
                "title": "rust-recursion-0ms",
                "content": "```rust\\npub fn remove(head: Option<Box<ListNode>>, n: i32) -> (i32, Option<Box<ListNode>>) {\\n    if let Some(boxed) = head {\\n        let (mut tail_index, tail) = remove(boxed.next, n);\\n        tail_index += 1;\\n\\n        if tail_index == n {\\n            (tail_index, tail)\\n        } else {\\n            (tail_index, Some(Box::new(ListNode {\\n                val: boxed.val,\\n                next: tail\\n            })))\\n        }\\n    } else {\\n        (0, None)\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        remove(head, n).1\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\npub fn remove(head: Option<Box<ListNode>>, n: i32) -> (i32, Option<Box<ListNode>>) {\\n    if let Some(boxed) = head {\\n        let (mut tail_index, tail) = remove(boxed.next, n);\\n        tail_index += 1;\\n\\n        if tail_index == n {\\n            (tail_index, tail)\\n        } else {\\n            (tail_index, Some(Box::new(ListNode {\\n                val: boxed.val,\\n                next: tail\\n            })))\\n        }\\n    } else {\\n        (0, None)\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        remove(head, n).1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 9034,
                "title": "java-solution-using-recursion",
                "content": "      public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode cur = head;\\n\\t    int count = helper(cur, 0, n);\\n\\t    if (count+1 == n) head = head.next;\\n\\t    return head; \\n    }\\n    \\n    public int helper(ListNode head, int count, int target) {\\n        if (head == null || head.next == null) {\\n            return 0;\\n        }\\n        count = helper(head.next, count, target);\\n        count++;\\n        if (count == target) {\\n            head.next = head.next.next;\\n        }\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "      public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode cur = head;\\n\\t    int count = helper(cur, 0, n);\\n\\t    if (count+1 == n) head = head.next;\\n\\t    return head; \\n    }\\n    \\n    public int helper(ListNode head, int count, int target) {\\n        if (head == null || head.next == null) {\\n            return 0;\\n        }\\n        count = helper(head.next, count, target);\\n        count++;\\n        if (count == target) {\\n            head.next = head.next.next;\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 9039,
                "title": "share-my-4ms-solution",
                "content": "    /**\\n     * Definition for singly-linked list.\\n     * struct ListNode {\\n     *     int val;\\n     *     ListNode *next;\\n     *     ListNode(int x) : val(x), next(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        ListNode* removeNthFromEnd(ListNode* head, int n) {//\\u5f00\\u8f9f\\u4e00\\u4e2a\\u5934\\u7ed3\\u70b9\\u5c31\\u53ef\\u4ee5\\u89e3\\u51b3\\u95ee\\u9898\\u5566\\uff01\\n            if(!head -> next) return NULL;\\n            ListNode* headt = new ListNode(0);\\n            headt -> next = head;\\n            ListNode* forward = headt;\\n            ListNode* tail = headt;\\n            for(int i = 0; i < n; i++){\\n                if(forward -> next) forward = forward -> next;\\n            }\\n            while(forward -> next){\\n                forward = forward -> next;\\n                tail = tail -> next;\\n            }\\n            tail -> next = tail -> next -> next;\\n            return headt -> next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* removeNthFromEnd(ListNode* head, int n) {//\\u5f00\\u8f9f\\u4e00\\u4e2a\\u5934\\u7ed3\\u70b9\\u5c31\\u53ef\\u4ee5\\u89e3\\u51b3\\u95ee\\u9898\\u5566\\uff01\\n            if(!head -> next) return NULL;\\n            ListNode* headt = new ListNode(0);\\n            headt -> next = head;\\n            ListNode* forward = headt;\\n            ListNode* tail = headt;\\n            for(int i = 0; i < n; i++){\\n                if(forward -> next) forward = forward -> next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 9051,
                "title": "java-short-and-clean-solution",
                "content": "    public class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fast = head, slow = head;\\n        while (fast != null) {\\n        \\tif (n-- < 0) {\\n        \\t\\tslow = slow.next;\\n        \\t}\\n        \\tfast = fast.next;\\n        }\\n        if (n < 0) \\n        \\tslow.next = slow.next.next;\\n        else \\n        \\thead = head.next;\\n        \\n        return head;\\n    } }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fast = head, slow = head;\\n        while (fast != null) {\\n        \\tif (n-- < 0) {\\n        \\t\\tslow = slow.next;\\n        \\t}",
                "codeTag": "Java"
            },
            {
                "id": 9163,
                "title": "python-solution-with-dummy-head-less-edge-cases-make-life-easier",
                "content": "Try to consider the extreme case. What if n = len(list)? What if n = 0? (impossible, but you need to demonstrate that you have thought of the edge cases)\\n\\nUsing the dummy head ensures that you can always return something, as the head itself could be removed.\\n\\n    class Solution:\\n        # @return a ListNode\\n        '''\\n        n = 5\\n        (-1)->1->2->3->4->5\\n        \\n        i    =    0->1->2->3->4->5\\n        fast = (-1)->1->2->3->4->5\\n        \\n        fast = 5\\n        slow = (-1)\\n        \\n        slow.next = head.next = 2\\n        '''\\n        def removeNthFromEnd(self, head, n):\\n            assert n > 0\\n            dummy = ListNode(-1)\\n            dummy.next = head\\n            slow, fast = dummy, dummy\\n            for i in range(n):\\n                fast = fast.next\\n                assert fast\\n            while fast.next:\\n                fast = fast.next\\n                slow = slow.next\\n            slow.next = slow.next.next\\n            return dummy.next",
                "solutionTags": [],
                "code": "Try to consider the extreme case. What if n = len(list)? What if n = 0? (impossible, but you need to demonstrate that you have thought of the edge cases)\\n\\nUsing the dummy head ensures that you can always return something, as the head itself could be removed.\\n\\n    class Solution:\\n        # @return a ListNode\\n        '''\\n        n = 5\\n        (-1)->1->2->3->4->5\\n        \\n        i    =    0->1->2->3->4->5\\n        fast = (-1)->1->2->3->4->5\\n        \\n        fast = 5\\n        slow = (-1)\\n        \\n        slow.next = head.next = 2\\n        '''\\n        def removeNthFromEnd(self, head, n):\\n            assert n > 0\\n            dummy = ListNode(-1)\\n            dummy.next = head\\n            slow, fast = dummy, dummy\\n            for i in range(n):\\n                fast = fast.next\\n                assert fast\\n            while fast.next:\\n                fast = fast.next\\n                slow = slow.next\\n            slow.next = slow.next.next\\n            return dummy.next",
                "codeTag": "Java"
            },
            {
                "id": 3446797,
                "title": "keep-it-simple-baby",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1 for loop\\n1 love\\n1 live\\n\\n# Code\\n```\\npublic class Solution\\n    {\\n        public ListNode RemoveNthFromEnd(ListNode head, int n)\\n        {\\n            ListNode prev = null;\\n\\n            for (var (node, i) = (head, 0); node != null; node = node.next, i++)            \\n                if (i >= n)                \\n                    if (prev == null) prev = head;\\n                    else prev = prev.next;    \\n            \\n            if (prev == null) return head.next;\\n            if (prev.next != null) prev.next = prev.next.next;\\n            return head;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n    {\\n        public ListNode RemoveNthFromEnd(ListNode head, int n)\\n        {\\n            ListNode prev = null;\\n\\n            for (var (node, i) = (head, 0); node != null; node = node.next, i++)            \\n                if (i >= n)                \\n                    if (prev == null) prev = head;\\n                    else prev = prev.next;    \\n            \\n            if (prev == null) return head.next;\\n            if (prev.next != null) prev.next = prev.next.next;\\n            return head;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394224,
                "title": "java-linked-list-remove-elem",
                "content": "\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ArrayList<ListNode> arr = new ArrayList<>();\\n        while (head != null)\\n        {\\n            arr.add(head);\\n            head = head.next;\\n        }\\n        if (arr.size() == 0 || n > arr.size())\\n            return null;\\n        if (n == arr.size())\\n            return arr.get(0).next;\\n        arr.get(arr.size() - n - 1).next = arr.get(arr.size() - n).next;\\n        return arr.get(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ArrayList<ListNode> arr = new ArrayList<>();\\n        while (head != null)\\n        {\\n            arr.add(head);\\n            head = head.next;\\n        }\\n        if (arr.size() == 0 || n > arr.size())\\n            return null;\\n        if (n == arr.size())\\n            return arr.get(0).next;\\n        arr.get(arr.size() - n - 1).next = arr.get(arr.size() - n).next;\\n        return arr.get(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2633008,
                "title": "simple-js",
                "content": "```\\nconst removeNthFromEnd = function(head, n) {\\n\\n    const nodeFromStart = totalNoOfNodes(head) - n;\\n    \\n    if(nodeFromStart==0) return head.next\\n    \\n    let prev = head;\\n    let next = head.next;\\n    for(let i=1; i<nodeFromStart; i++) {\\n        prev=prev.next;\\n        next=next.next;\\n    }\\n    \\n    prev.next = next.next; //CRUX\\n    \\n    return head;\\n    \\n};\\n\\nfunction totalNoOfNodes(head){\\n    let count = 0;\\n    while(head){\\n        head = head.next;\\n        count++;\\n    }\\n    \\n    return count;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst removeNthFromEnd = function(head, n) {\\n\\n    const nodeFromStart = totalNoOfNodes(head) - n;\\n    \\n    if(nodeFromStart==0) return head.next\\n    \\n    let prev = head;\\n    let next = head.next;\\n    for(let i=1; i<nodeFromStart; i++) {\\n        prev=prev.next;\\n        next=next.next;\\n    }\\n    \\n    prev.next = next.next; //CRUX\\n    \\n    return head;\\n    \\n};\\n\\nfunction totalNoOfNodes(head){\\n    let count = 0;\\n    while(head){\\n        head = head.next;\\n        count++;\\n    }\\n    \\n    return count;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2411474,
                "title": "python-3-one-pass-approach-explained",
                "content": "**Context**\\\\\\nWe\\'re given two parameters: `head` and `n`. The former stores a reference to the head of the linked list. The latter stores an integer representing the xth final node that we must remove (*i.e. if `n` is 2, then we must remove the 2nd final node*). The problem requires us to remove the nth final node from the linked list.\\n\\n**Solution**\\\\\\nThe way to solve this problem in one-pass is by utilizing two pointer variables: `slow` and `fast`. In order to find the nth final node, we\\'ll need to find the total number of nodes in the linked list. However, this (finding the total number of nodes) requires N additional time - which prevents us from solving the problem in one pass.\\n\\nRather than finding the nth final node, we can find the nth node instead (*i.e. if the total number of nodes is 5 and `n` is 2, then we\\'ll want to remove the 3rd node*). This can be achieved by executing two tasks:\\n* move `fast` `n` times beforehand\\n* move `slow` and `fast` in parallel until `fast.next` is null.\\n\\nBy the time `fast.next` is null, `slow` should be storing a reference to the nth node\\'s previous node. The way to remove the nth node is by having `slow` point to the nth node\\'s next node (`slow.next = slow.next.next`).\\n\\n```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = fast = head\\n        \\n        for _ in range(n):\\n            fast = fast.next\\n        \\n        # if fast is null, then it implies that we must remove\\n        # the first node. Hence, we\\'ll return the next node\\n        # (after the first node) as an answer.\\n        if not fast:\\n            return head.next\\n        \\n        while fast.next:\\n            slow = slow.next\\n            fast = fast.next\\n        \\n        slow.next = slow.next.next\\n        return head\\n```\\n\\\\\\nThe time complexity is O(N) because we must iterate through the linked list at most once (moving `fast` `n` times beforehand + moving `fast` until it\\'s null).\\n\\nThe space complexity is O(1) because we\\'re only using few additional spaces to initialize few variables.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = fast = head\\n        \\n        for _ in range(n):\\n            fast = fast.next\\n        \\n        # if fast is null, then it implies that we must remove\\n        # the first node. Hence, we\\'ll return the next node\\n        # (after the first node) as an answer.\\n        if not fast:\\n            return head.next\\n        \\n        while fast.next:\\n            slow = slow.next\\n            fast = fast.next\\n        \\n        slow.next = slow.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2270564,
                "title": "easy-c-sol-naive-efficient-approaches-time-o-n",
                "content": "```\\n// Naive Solution :: Time : O(N) + O(N) :: Aux_Space : O(1)\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        int count = 0;\\n        ListNode *curr = head;\\n\\n        while(curr){\\n            count++;\\n            curr = curr->next;\\n        }\\n\\n        if(count == n){\\n            head = head->next;\\n            return head;\\n        }\\n\\n\\n        int k = count-n;\\n\\n        ListNode *temp = head;\\n        count = 1;\\n\\n        while(count!=k){\\n\\n            temp = temp->next;\\n            count++;\\n        }\\n\\n        ListNode *var = temp->next;\\n        temp->next = temp->next->next;\\n        delete(var);\\n\\n        return head;\\n    }\\n};\\n\\n// Efficient Solutin :: Time : O(N) :: Aux_Space : O(1)\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        ListNode* curr = new ListNode();\\n        curr->next = head;\\n        ListNode* fast = curr;\\n        ListNode* slow = curr;\\n\\n        int k = n;\\n\\n        while(k--){\\n            fast = fast->next;\\n        }\\n\\n        while(fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next;\\n        }\\n\\n        slow->next = slow->next->next;\\n\\n        return curr->next;\\n\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        int count = 0;\\n        ListNode *curr = head;\\n\\n        while(curr){\\n            count++;\\n            curr = curr->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2192124,
                "title": "java-0ms-beats-100-in-time-simple-and-easy-with-explaination",
                "content": "![image](https://assets.leetcode.com/users/images/2e075c52-0509-4921-afd1-8763fa174e10_1656090668.9436104.png)\\n\\n```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        int len=0;\\n        ListNode temp=head;\\n        // Find the length/size of list.\\n        while(temp!=null)\\n        {\\n            len++;\\n            temp=temp.next;\\n        }\\n        System.out.println(len);\\n        if(len==1) return null;\\n        if(len-n==0) return head.next;\\n      \\n        int count=1;\\n        temp=head;\\n\\t\\t//Reach to the node before the one you want to delete.\\n        //If len is 5, 2nd element from last means 3rd element from start.\\n        while(count!=len-n)\\n        {\\n            temp=temp.next;\\n            count++;\\n        }\\n        System.out.println(temp.val);\\n        temp.next=temp.next.next;\\n    return head;\\n    }\\n}\\n```\\n***Pls upvote the solution if you find it helpful.***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        int len=0;\\n        ListNode temp=head;\\n        // Find the length/size of list.\\n        while(temp!=null)\\n        {\\n            len++;\\n            temp=temp.next;\\n        }\\n        System.out.println(len);\\n        if(len==1) return null;\\n        if(len-n==0) return head.next;\\n      \\n        int count=1;\\n        temp=head;\\n\\t\\t//Reach to the node before the one you want to delete.\\n        //If len is 5, 2nd element from last means 3rd element from start.\\n        while(count!=len-n)\\n        {\\n            temp=temp.next;\\n            count++;\\n        }\\n        System.out.println(temp.val);\\n        temp.next=temp.next.next;\\n    return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2127566,
                "title": "0ms-1liner-100-fastest-solution-explained-o-n-time-complexity-o-n-space-complexity",
                "content": "(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* *** Kotlin ***\\n\\n```\\n\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n      fun removeNthFromEnd(head: ListNode?, n: Int): ListNode? {\\n    if (head == null) return null\\n    \\n    var nodeCount = 0\\n    var current = head\\n    \\n    while (current != null) {\\n      nodeCount++\\n      current = current.next\\n    }\\n    \\n    if (nodeCount == n) return head.next\\n    \\n    var prev: ListNode? = null\\n    current = head\\n    val dummy = ListNode(-1)\\n    dummy.next = current\\n    \\n    var step = nodeCount - n\\n    while (step-- > 0) {\\n      prev = current\\n      current = current?.next\\n    }\\n    \\n    prev?.next = current?.next\\n    \\n    return dummy.next\\n  }\\n}\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "JavaScript",
                    "Kotlin",
                    "PHP"
                ],
                "code": "```\\n```\n```\\n\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n      fun removeNthFromEnd(head: ListNode?, n: Int): ListNode? {\\n    if (head == null) return null\\n    \\n    var nodeCount = 0\\n    var current = head\\n    \\n    while (current != null) {\\n      nodeCount++\\n      current = current.next\\n    }\\n    \\n    if (nodeCount == n) return head.next\\n    \\n    var prev: ListNode? = null\\n    current = head\\n    val dummy = ListNode(-1)\\n    dummy.next = current\\n    \\n    var step = nodeCount - n\\n    while (step-- > 0) {\\n      prev = current\\n      current = current?.next\\n    }\\n    \\n    prev?.next = current?.next\\n    \\n    return dummy.next\\n  }\\n}\\n\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087843,
                "title": "c-solution-in-two-pass-and-one-pass",
                "content": "**Code in two pass**\\n```\\nint lenList(struct ListNode* head){\\n    struct ListNode* ptr = head;\\n    int l = 0;\\n    while(ptr != NULL) {\\n        l++;\\n        ptr = ptr->next;\\n    }\\n    return l;\\n}\\n\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    if(!head || !head->next) return NULL;\\n\\n    int len = lenList(head);\\n    if(len == n) {\\n        head = head->next;\\n        return head;\\n    }\\n    struct ListNode* ptr = head;\\n    int count = len - n;\\n    while(count > 1) {\\n        ptr = ptr->next;\\n        count--;\\n    }\\n    struct ListNode* q = ptr->next;\\n    ptr->next = ptr->next->next;\\n    free(q);\\n    \\n    return head;\\n}\\n```\\n\\n**Code in one pass**\\n```\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    struct ListNode* fast = head;\\n    struct ListNode* slow = head;\\n    \\n    for(int i=0; i<n; i++) fast = fast->next;\\n    if(!fast) return head->next;\\n    \\n    while(fast->next){\\n        fast = fast->next;\\n        slow = slow->next;\\n    }\\n    \\n    struct ListNode* q = slow->next;\\n    slow->next = slow->next->next;\\n    free(q);\\n    \\n    return head;\\n}\\n```\\n\\n**Please upvote if you liked the solution**\\n*Feel free to ask any questions in the comment section*",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint lenList(struct ListNode* head){\\n    struct ListNode* ptr = head;\\n    int l = 0;\\n    while(ptr != NULL) {\\n        l++;\\n        ptr = ptr->next;\\n    }\\n    return l;\\n}\\n\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    if(!head || !head->next) return NULL;\\n\\n    int len = lenList(head);\\n    if(len == n) {\\n        head = head->next;\\n        return head;\\n    }\\n    struct ListNode* ptr = head;\\n    int count = len - n;\\n    while(count > 1) {\\n        ptr = ptr->next;\\n        count--;\\n    }\\n    struct ListNode* q = ptr->next;\\n    ptr->next = ptr->next->next;\\n    free(q);\\n    \\n    return head;\\n}\\n```\n```\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    struct ListNode* fast = head;\\n    struct ListNode* slow = head;\\n    \\n    for(int i=0; i<n; i++) fast = fast->next;\\n    if(!fast) return head->next;\\n    \\n    while(fast->next){\\n        fast = fast->next;\\n        slow = slow->next;\\n    }\\n    \\n    struct ListNode* q = slow->next;\\n    slow->next = slow->next->next;\\n    free(q);\\n    \\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1989690,
                "title": "javascript-solution",
                "content": "```\\nvar removeNthFromEnd = function(head, n) {\\n    let tempList = new ListNode(0);\\n    tempList.next = head;\\n\\t\\n    // set variables for next node and current node\\n    let slow = tempList;\\n    let fast = tempList;\\n\\t\\n    // set fast to n nodes ahead of slow\\n    for (let i = 0; i <= n; i++) {\\n        fast = fast.next;\\n    }\\n\\t\\n    // While we haven\\'t reached the end of the list\\n    // set slow to n nodes behind fast\\n    while (fast) {\\n        slow = slow.next;\\n        fast = fast.next;\\n    }\\n\\t\\n    // set slow.next to two nodes ahead of slow\\n    // then return the nth node of the list\\n    slow.next = slow.next.next;\\n    return tempList.next;\\n}\\n```\\n\\nTime complexity is 0(n)\\nSpace complexity 0(1)\\n\\nRuntime: 60 ms, faster than 95.08% of JavaScript online submissions for Remove Nth Node From End of List.\\nMemory Usage: 42.7 MB, less than 72.68% of JavaScript online submissions for Remove Nth Node From End of List.",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nvar removeNthFromEnd = function(head, n) {\\n    let tempList = new ListNode(0);\\n    tempList.next = head;\\n\\t\\n    // set variables for next node and current node\\n    let slow = tempList;\\n    let fast = tempList;\\n\\t\\n    // set fast to n nodes ahead of slow\\n    for (let i = 0; i <= n; i++) {\\n        fast = fast.next;\\n    }\\n\\t\\n    // While we haven\\'t reached the end of the list\\n    // set slow to n nodes behind fast\\n    while (fast) {\\n        slow = slow.next;\\n        fast = fast.next;\\n    }\\n\\t\\n    // set slow.next to two nodes ahead of slow\\n    // then return the nth node of the list\\n    slow.next = slow.next.next;\\n    return tempList.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1725772,
                "title": "two-pointer-approach",
                "content": "class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode result = head;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        \\n\\t //moving fast pointer to n+starting position\\n       while(n-- > 0){\\n           \\n           fast = fast.next;\\n       }\\n\\t   \\n\\t   \\n        if(fast == null){\\n            return result.next;\\n        }\\n       \\n        while(fast.next != null){\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        System.out.println(\"deleting value\"+ slow.next.val);\\n       \\n        slow.next = slow.next.next;\\n        \\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode result = head;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        \\n\\t //moving fast pointer to n+starting position\\n       while(n-- > 0){\\n           \\n           fast = fast.next;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 1699955,
                "title": "easy-and-clean-optimized-code-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* fast = head , *slow = head;\\n        for(int i = 0 ; i < n ; i++) fast = fast->next;\\n        if(!fast) return head->next;\\n        while(fast->next){\\n            fast = fast->next;\\n            slow = slow->next;\\n        }\\n        slow->next = slow->next->next;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* fast = head , *slow = head;\\n        for(int i = 0 ; i < n ; i++) fast = fast->next;\\n        if(!fast) return head->next;\\n        while(fast->next){\\n            fast = fast->next;\\n            slow = slow->next;\\n        }\\n        slow->next = slow->next->next;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645734,
                "title": "slow-and-fast-pointer-java-code",
                "content": "```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode slow = dummy;\\n        ListNode fast = dummy;\\n        \\n        // move fast pointer n time\\n        for(int i = 1; i <=n; ++i)\\n            fast = fast.next;\\n        \\n        while(fast.next != null){\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        \\n        slow.next = slow.next.next;\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode slow = dummy;\\n        ListNode fast = dummy;\\n        \\n        // move fast pointer n time\\n        for(int i = 1; i <=n; ++i)\\n            fast = fast.next;\\n        \\n        while(fast.next != null){\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        \\n        slow.next = slow.next.next;\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431330,
                "title": "java-o-n-one-pass-solution",
                "content": "This is a great problem to grasp the concept of linked lists, and uses a technique that occurs in other linked list problems.\\n\\n**Two-Pass Solution**\\nThe obvious approach to this problem is to use 2 passes through the linked list, the first pass for counting the number of nodes, and the second pass to find the node to remove and remove it. \\n```\\n//Sorry if my code is a little long, just trying to be as descriptive as possible\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode cur = head;\\n        int count = 0;\\n        while(cur != null){\\n            count++;\\n            cur = cur.next;\\n        }\\n        \\n        if(n == count){\\n            return head.next;\\n        }\\n        \\n        cur = head;\\n        ListNode pred = null;\\n        for(int i = 0; i < count - n; i++){\\n            pred = cur;\\n            cur = cur.next;\\n        }\\n       \\n        pred.next = cur.next;\\n        return head;\\n    }\\n}\\n```\\nThis code is not \"bad\" by any means, 2 passes still means ```O(n)``` time, and a constant number of new variables means ```O(1)``` space, but can we use the fact that we are looking to remove the ```n```th node from the end to create a one-pass solution?\\n\\n**One-Pass Solution**\\nA common way of doing one-pass solutions for linked list search/remove/insert problems is to use some variation of the slow-fast pointer technique. In this question, we can start by initializing a pointer ```fast``` at the head of the linked list given. Then we can move this pointer ```n``` nodes further. Then we can intialize a pointer ```slow``` to ```head```, and ```prev``` to ```null``` (this pointer being the one trailing ```slow```). We can move ```fast```, ```slow```, and ```prev``` simultaneously, and once ```fast``` becomes ```null``` (passes the end of the list), ```slow``` will be pointing to the ```n```th node from the end, which can now be removed. \\n\\n```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fast = head;\\n        for(int i = 0; i < n; i++){\\n            fast = fast.next;\\n        }\\n        ListNode slow = head;\\n        ListNode prev = null;\\n        while(fast != null){\\n            fast = fast.next;\\n            prev = slow;\\n            slow = slow.next;\\n        }\\n        if(prev == null){\\n            return head.next;\\n        }\\n        prev.next = slow.next;\\n        return head;\\n    }\\n}\\n```\\nThis solution is also done in ```O(n)``` time, and ```O(1)``` space, but the difference being that it is done in one pass. \\n\\nHope this helps!!",
                "solutionTags": [],
                "code": "```\\n//Sorry if my code is a little long, just trying to be as descriptive as possible\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode cur = head;\\n        int count = 0;\\n        while(cur != null){\\n            count++;\\n            cur = cur.next;\\n        }\\n        \\n        if(n == count){\\n            return head.next;\\n        }\\n        \\n        cur = head;\\n        ListNode pred = null;\\n        for(int i = 0; i < count - n; i++){\\n            pred = cur;\\n            cur = cur.next;\\n        }\\n       \\n        pred.next = cur.next;\\n        return head;\\n    }\\n}\\n```\n```O(n)```\n```O(1)```\n```n```\n```fast```\n```n```\n```slow```\n```head```\n```prev```\n```null```\n```slow```\n```fast```\n```slow```\n```prev```\n```fast```\n```null```\n```slow```\n```n```\n```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fast = head;\\n        for(int i = 0; i < n; i++){\\n            fast = fast.next;\\n        }\\n        ListNode slow = head;\\n        ListNode prev = null;\\n        while(fast != null){\\n            fast = fast.next;\\n            prev = slow;\\n            slow = slow.next;\\n        }\\n        if(prev == null){\\n            return head.next;\\n        }\\n        prev.next = slow.next;\\n        return head;\\n    }\\n}\\n```\n```O(n)```\n```O(1)```",
                "codeTag": "Java"
            },
            {
                "id": 1416454,
                "title": "2-pointer-approach-with-comments-typescript",
                "content": "```ts\\n// N: number of nodes\\n// Time: O(N)\\n// Space: O(1)\\n\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction removeNthFromEnd(head: ListNode | null, n: number): ListNode | null {\\n    const dummyHead = new ListNode(0, head);\\n    let slow = dummyHead;\\n    let fast = dummyHead;\\n    \\n    // Move fast n nodes ahead of slow\\n    for (let i = 0; i < n; i++) {\\n        fast = fast.next;\\n    }\\n    \\n    // When fast reaches 1st node from the end, slow will be n+1th node from the end\\n    while (fast.next) {\\n        fast = fast.next;\\n        slow = slow.next;\\n    }\\n    \\n    // Skip over the nth node from the end\\n    slow.next = slow.next.next;\\n    \\n    return dummyHead.next;\\n}\\n```",
                "solutionTags": [],
                "code": "```ts\\n// N: number of nodes\\n// Time: O(N)\\n// Space: O(1)\\n\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction removeNthFromEnd(head: ListNode | null, n: number): ListNode | null {\\n    const dummyHead = new ListNode(0, head);\\n    let slow = dummyHead;\\n    let fast = dummyHead;\\n    \\n    // Move fast n nodes ahead of slow\\n    for (let i = 0; i < n; i++) {\\n        fast = fast.next;\\n    }\\n    \\n    // When fast reaches 1st node from the end, slow will be n+1th node from the end\\n    while (fast.next) {\\n        fast = fast.next;\\n        slow = slow.next;\\n    }\\n    \\n    // Skip over the nth node from the end\\n    slow.next = slow.next.next;\\n    \\n    return dummyHead.next;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366565,
                "title": "c-simple-one-pass-o-n-time-o-1-space",
                "content": "curr refers to the first node and nPlusOneNodesFromCurris n plus nodes\\nfar from the curr node so if it becomes null we need to delete the next value\\nof curr\\n\\nEDGE CASES\\n\\ndeleting the first node and second node\\nif its first node nPlusOneNodesFromCurr will be NULL when n=1\\nand if its second node n will be 0 and nPlusOneNodesFromCurr will be NULL\\n```\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *curr=head,*nPlusOneNodesFromCurr=head;\\n        n++;\\n        while(nPlusOneNodesFromCurr!=NULL&&n--){\\n            nPlusOneNodesFromCurr=nPlusOneNodesFromCurr->next;\\n        }\\n        if(nPlusOneNodesFromCurr==NULL&&n==1)\\n         return head->next;\\n     \\n        while(nPlusOneNodesFromCurr!=NULL){\\n            curr=curr->next;\\n           nPlusOneNodesFromCurr=nPlusOneNodesFromCurr->next;     \\n        }\\n        curr->next=curr->next->next;\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *curr=head,*nPlusOneNodesFromCurr=head;\\n        n++;\\n        while(nPlusOneNodesFromCurr!=NULL&&n--){\\n            nPlusOneNodesFromCurr=nPlusOneNodesFromCurr->next;\\n        }\\n        if(nPlusOneNodesFromCurr==NULL&&n==1)\\n         return head->next;\\n     \\n        while(nPlusOneNodesFromCurr!=NULL){\\n            curr=curr->next;\\n           nPlusOneNodesFromCurr=nPlusOneNodesFromCurr->next;     \\n        }\\n        curr->next=curr->next->next;\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354890,
                "title": "c-brute-to-optimal-easy",
                "content": "**1. Brute Force**\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        //if only one element \\n        if(!head->next){\\n            return nullptr;\\n        }\\n        //if two element\\n        if(!head->next->next){\\n            if(n==1){\\n                head->next=nullptr;\\n                return head;\\n            }\\n            else{\\n                return head->next;\\n            }\\n        }\\n        //more than two element\\n        int ctr=0, length=0;\\n        ListNode *temp=head;\\n        ListNode *ptr =head;\\n        \\n        //checking length\\n        while(ptr){\\n            ptr = ptr->next;\\n            length++;\\n        }\\n        \\n        //1st edge case if first element removed\\n        if(n==length){\\n            return head->next;\\n        }\\n        //removing length-n element\\n        while(temp){\\n            //if element found is n-1th from end\\n            if(ctr==length-n-1){\\n      \\n                if(temp->next->next!=nullptr){\\n                    temp->next=temp->next->next;\\n                }\\n                //2nd edge case if last element removed\\n                else{\\n                    temp->next = nullptr;\\n                }\\n            }\\n            temp = temp->next;\\n            ctr++;\\n        }\\n        return head;\\n    }\\n};\\n```\\n\\n**2. Two Pointer**\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* start = new ListNode(0);\\n        start->next = head;\\n        ListNode* fast=start;\\n        ListNode* slow=start;\\n        \\n        for(int i=1; i<=n; ++i){\\n            fast = fast->next;\\n        }\\n            \\n            while(fast->next!=NULL){\\n                fast = fast->next;\\n                slow = slow->next;\\n            }\\n            slow->next = slow->next->next;\\n        return start->next;\\n       \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        //if only one element \\n        if(!head->next){\\n            return nullptr;\\n        }\\n        //if two element\\n        if(!head->next->next){\\n            if(n==1){\\n                head->next=nullptr;\\n                return head;\\n            }\\n            else{\\n                return head->next;\\n            }\\n        }\\n        //more than two element\\n        int ctr=0, length=0;\\n        ListNode *temp=head;\\n        ListNode *ptr =head;\\n        \\n        //checking length\\n        while(ptr){\\n            ptr = ptr->next;\\n            length++;\\n        }\\n        \\n        //1st edge case if first element removed\\n        if(n==length){\\n            return head->next;\\n        }\\n        //removing length-n element\\n        while(temp){\\n            //if element found is n-1th from end\\n            if(ctr==length-n-1){\\n      \\n                if(temp->next->next!=nullptr){\\n                    temp->next=temp->next->next;\\n                }\\n                //2nd edge case if last element removed\\n                else{\\n                    temp->next = nullptr;\\n                }\\n            }\\n            temp = temp->next;\\n            ctr++;\\n        }\\n        return head;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* start = new ListNode(0);\\n        start->next = head;\\n        ListNode* fast=start;\\n        ListNode* slow=start;\\n        \\n        for(int i=1; i<=n; ++i){\\n            fast = fast->next;\\n        }\\n            \\n            while(fast->next!=NULL){\\n                fast = fast->next;\\n                slow = slow->next;\\n            }\\n            slow->next = slow->next->next;\\n        return start->next;\\n       \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1256656,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        \\n        ListNode* p1 = head;\\n        ListNode* p2;\\n        ListNode* prevP2 = NULL;\\n        \\n        while(n){\\n            p1 = p1->next;\\n            n--;\\n        }\\n        \\n        p2 = head;\\n        while(p1){\\n            prevP2 = p2;\\n            p2 = p2->next;\\n            p1 = p1->next;\\n        }\\n        \\n        //Trying to delete the head\\n        if(!prevP2) return p2->next;\\n        else{\\n            prevP2->next = p2->next;\\n            return head;\\n        }\\n        return head;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        \\n        ListNode* p1 = head;\\n        ListNode* p2;\\n        ListNode* prevP2 = NULL;\\n        \\n        while(n){\\n            p1 = p1->next;\\n            n--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1164484,
                "title": "c-super-simple-short-one-pass-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if (!head) \\n            return NULL;\\n        \\n        ListNode* dummy_head = new ListNode();\\n        dummy_head->next = head;\\n        ListNode *fast = dummy_head, *slow = dummy_head;\\n        \\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n        \\n        while (fast->next) {\\n            fast = fast->next;\\n            slow = slow->next;        \\n        }\\n        \\n        ListNode *to_delete = slow->next;\\n        slow->next = slow->next->next;\\n        delete to_delete;\\n        \\n        return dummy_head->next;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if (!head) \\n            return NULL;\\n        \\n        ListNode* dummy_head = new ListNode();\\n        dummy_head->next = head;\\n        ListNode *fast = dummy_head, *slow = dummy_head;\\n        \\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n        \\n        while (fast->next) {\\n            fast = fast->next;\\n            slow = slow->next;        \\n        }\\n        \\n        ListNode *to_delete = slow->next;\\n        slow->next = slow->next->next;\\n        delete to_delete;\\n        \\n        return dummy_head->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961866,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        fast=slow=head\\n        for i in range(n):\\n            fast=fast.next\\n        if not fast:return head.next\\n        while fast.next:\\n            slow=slow.next\\n            fast=fast.next\\n        slow.next=slow.next.next\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        fast=slow=head\\n        for i in range(n):\\n            fast=fast.next\\n        if not fast:return head.next\\n        while fast.next:\\n            slow=slow.next\\n            fast=fast.next\\n        slow.next=slow.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503293,
                "title": "javascript-detailed-explanation",
                "content": "```\\nvar removeNthFromEnd = function(head, n) {\\n    // create a newlistnode which we will use to store our answer\\n    let dummy = new ListNode(-1);\\n    // keep a reference to head, which we will return\\n    dummy.next = head;\\n    \\n    // we\\'re starting these are our dummy value (-1)\\n    let slow = dummy;\\n    let fast = dummy;\\n    \\n    // get one ahead of N # of nodes, so given n =2, then 1->2->3->4->5 we\\'d be at 3\\n    // effectively creating a distance of size N from the fast pointer (3) and the slow (1)\\n    for(let i = 1; i <= n + 1; i++) {\\n        fast = fast.next;\\n    }\\n    \\n    // slow is at head still, fast is ahead of slow at a distance of N\\n    // we move slow and fast one at a time, when fast is at the end of the list (null)\\n    // slow will be at distance N-1 from the end of the list\\n    while(fast !== null) {\\n        slow = slow.next;\\n        fast = fast.next;\\n    }\\n    \\n    // slow is now one before N, lets skip it\\n    slow.next = slow.next.next;\\n    \\n    // dummy contains our initial value (-1->1->2->3->4->5)\\n    // we don\\'t need the dummy value (-1)\\n    // so return the next value (1->2->3->4->5)\\n    return dummy.next;\\n};\\n\\n\\n// this is algo looks manually stepping through it. Given: 1->2->3->4->5, n = 2\\n// move fast to N + 1\\n// fast     i    n+1 (end point)\\n//  1       1    3\\n//  2       2    3\\n//  3       3    3\\n// fast: 3, slow : -1, distance between fast slow: 2 (which will always be n)\\n\\n// loop until fast !== null\\n// slow    fast    distance between (not difference)\\n//  1       4             2\\n//  2       5             2\\n//  3       null(eol)     2\\n\\n// so now our slow pointer is one before the node we need to skip (n)\\n// so lets skip it, slow.next is the value we need to skip (4), so\\n// slow.next -> slow.next.next(5)\\n// 1->2->3->5```",
                "solutionTags": [],
                "code": "```\\nvar removeNthFromEnd = function(head, n) {\\n    // create a newlistnode which we will use to store our answer\\n    let dummy = new ListNode(-1);\\n    // keep a reference to head, which we will return\\n    dummy.next = head;\\n    \\n    // we\\'re starting these are our dummy value (-1)\\n    let slow = dummy;\\n    let fast = dummy;\\n    \\n    // get one ahead of N # of nodes, so given n =2, then 1->2->3->4->5 we\\'d be at 3\\n    // effectively creating a distance of size N from the fast pointer (3) and the slow (1)\\n    for(let i = 1; i <= n + 1; i++) {\\n        fast = fast.next;\\n    }\\n    \\n    // slow is at head still, fast is ahead of slow at a distance of N\\n    // we move slow and fast one at a time, when fast is at the end of the list (null)\\n    // slow will be at distance N-1 from the end of the list\\n    while(fast !== null) {\\n        slow = slow.next;\\n        fast = fast.next;\\n    }\\n    \\n    // slow is now one before N, lets skip it\\n    slow.next = slow.next.next;\\n    \\n    // dummy contains our initial value (-1->1->2->3->4->5)\\n    // we don\\'t need the dummy value (-1)\\n    // so return the next value (1->2->3->4->5)\\n    return dummy.next;\\n};\\n\\n\\n// this is algo looks manually stepping through it. Given: 1->2->3->4->5, n = 2\\n// move fast to N + 1\\n// fast     i    n+1 (end point)\\n//  1       1    3\\n//  2       2    3\\n//  3       3    3\\n// fast: 3, slow : -1, distance between fast slow: 2 (which will always be n)\\n\\n// loop until fast !== null\\n// slow    fast    distance between (not difference)\\n//  1       4             2\\n//  2       5             2\\n//  3       null(eol)     2\\n\\n// so now our slow pointer is one before the node we need to skip (n)\\n// so lets skip it, slow.next is the value we need to skip (4), so\\n// slow.next -> slow.next.next(5)\\n// 1->2->3->5```",
                "codeTag": "Unknown"
            },
            {
                "id": 368217,
                "title": "remove-nth-node-from-end-of-list",
                "content": "Given a linked list, remove the n-th node from the end of list and return its head.\\n\\nExample:\\n\\nGiven linked list: 1->2->3->4->5, and n = 2.\\n\\nAfter removing the second node from the end, the linked list becomes 1->2->3->5.\\n\\n```\\n\\t# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        p = head\\n        i = 0\\n        while p:\\n            p = p.next\\n            i += 1\\n        p = head\\n        step = i-n#total length - n\\n        if step == 0:\\n            head = head.next\\n        else:\\n            l = 1\\n            while l<step :\\n                p = p.next\\n                l += 1\\n            p.next = p.next.next\\n        return head\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n\\t# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        p = head\\n        i = 0\\n        while p:\\n            p = p.next\\n            i += 1\\n        p = head\\n        step = i-n#total length - n\\n        if step == 0:\\n            head = head.next\\n        else:\\n            l = 1\\n            while l<step :\\n                p = p.next\\n                l += 1\\n            p.next = p.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 287711,
                "title": "solution-in-python",
                "content": "Runtime: 40 ms, faster than 93.06% of Python3 online submissions for Remove Nth Node From End of List.\\nMemory Usage: 13.2 MB, less than 5.60% of Python3 online submissions for Remove Nth Node From End of List.\\n```# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        if head.next == None:\\n            return None\\n        tmp = head\\n        size = 0\\n        \\n        # find the size of the linked list\\n        while tmp:\\n            size += 1\\n            tmp = tmp.next\\n        tmp = head\\n        \\n        #if we have to remove the first node:\\n        if n == size: \\n            return head.next\\n        \\n        for i in range(size-n-1):\\n            tmp = tmp.next\\n        tmp.next = tmp.next.next\\n        return head",
                "solutionTags": [],
                "code": "Runtime: 40 ms, faster than 93.06% of Python3 online submissions for Remove Nth Node From End of List.\\nMemory Usage: 13.2 MB, less than 5.60% of Python3 online submissions for Remove Nth Node From End of List.\\n```# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        if head.next == None:\\n            return None\\n        tmp = head\\n        size = 0\\n        \\n        # find the size of the linked list\\n        while tmp:\\n            size += 1\\n            tmp = tmp.next\\n        tmp = head\\n        \\n        #if we have to remove the first node:\\n        if n == size: \\n            return head.next\\n        \\n        for i in range(size-n-1):\\n            tmp = tmp.next\\n        tmp.next = tmp.next.next\\n        return head",
                "codeTag": "Java"
            },
            {
                "id": 209699,
                "title": "javascript-o-n-time-o-1-space-with-comments",
                "content": "```javascript\\n/**\\n * Time: O(n)\\n * Space: O(1)\\n * n - # of nodes\\n */\\n\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} n\\n * @return {ListNode}\\n */\\nfunction removeNthFromEnd(head, n) {\\n  const dummy = new ListNode(); // use dummy to handle removing head\\n  dummy.next = head;\\n  let fast = dummy;\\n  let slow = dummy;\\n\\n  // Move fast n + 1 nodes ahead of slow\\n  for (let i = 0; i < n + 1; i++) {\\n    fast = fast.next;\\n  }\\n\\n  // Move fast to end, slow will be (n + 1)th from last node, just before the node to remove\\n  while (fast) {\\n    fast = fast.next;\\n    slow = slow.next;\\n  }\\n\\n  // Remove the nth from last node\\n  slow.next = slow.next.next;\\n  return dummy.next;\\n}\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * Time: O(n)\\n * Space: O(1)\\n * n - # of nodes\\n */\\n\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} n\\n * @return {ListNode}\\n */\\nfunction removeNthFromEnd(head, n) {\\n  const dummy = new ListNode(); // use dummy to handle removing head\\n  dummy.next = head;\\n  let fast = dummy;\\n  let slow = dummy;\\n\\n  // Move fast n + 1 nodes ahead of slow\\n  for (let i = 0; i < n + 1; i++) {\\n    fast = fast.next;\\n  }\\n\\n  // Move fast to end, slow will be (n + 1)th from last node, just before the node to remove\\n  while (fast) {\\n    fast = fast.next;\\n    slow = slow.next;\\n  }\\n\\n  // Remove the nth from last node\\n  slow.next = slow.next.next;\\n  return dummy.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 167577,
                "title": "java-two-pointers-with-explanations",
                "content": "**Logical Thought**\\nThe loop invariant is that two pointers `s, e` such that `s is always n nodes distance in front of e`. In this way, `s` is always the preceding node of the node to remove.When e is the `tail` node of the List (i.e. when `e.next = null`), we simply remove s.next (`s.next = s.next.next`). For example,\\n```\\nGiven 1 - 2 - 3 - 4 - 5 - N, n = 2,\\ns is always 2 nodes distance in front of e\\nD - 1 - 2 - 3 - 4 - 5 - N\\n            s\\n                    e\\n3 is the node to remove.\\n```\\n**Code**\\n```\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n\\n        if (head == null || head.next == null) {\\n            return null;\\n        }\\n\\n        ListNode dummyHead = new ListNode(0), s = dummyHead, e = s;\\n        dummyHead.next = head;\\n\\n        for (int i = 0; i < n; i++) {\\n            e = e.next;\\n        }\\n        while (e.next != null) {\\n            e = e.next;\\n            s = s.next;\\n        }\\n        s.next = s.next.next;\\n\\n        return dummyHead.next;\\n    }\\n```\\n**Trick**\\nTo remove a node in List, we need to figure out its preceding node. Since we may remove the List\\'s head, which does not have a preceding node, we establish a `dummyHead` for simplicity (`dummyHead.next = head`).\\n\\nI appreciate your **VOTE UP** (\\u02CAo\\u0334\\u0336\\u0337\\u0324\\u2304o\\u0334\\u0336\\u0337\\u0324\\u02CB) ",
                "solutionTags": [],
                "code": "```\\nGiven 1 - 2 - 3 - 4 - 5 - N, n = 2,\\ns is always 2 nodes distance in front of e\\nD - 1 - 2 - 3 - 4 - 5 - N\\n            s\\n                    e\\n3 is the node to remove.\\n```\n```\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n\\n        if (head == null || head.next == null) {\\n            return null;\\n        }\\n\\n        ListNode dummyHead = new ListNode(0), s = dummyHead, e = s;\\n        dummyHead.next = head;\\n\\n        for (int i = 0; i < n; i++) {\\n            e = e.next;\\n        }\\n        while (e.next != null) {\\n            e = e.next;\\n            s = s.next;\\n        }\\n        s.next = s.next.next;\\n\\n        return dummyHead.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8816,
                "title": "minimal-recursive-java-solution-12ms",
                "content": "```\\n\\tpublic static ListNode removeNthFromEnd(ListNode head, int n) {\\n\\t\\tif(head==null){\\n\\t\\t\\treturn null;\\n\\t\\t}\\n        int depth=removeHelper(head,n);\\n        head=depth>n?head:head.next;\\n        return head;\\n \\n    }\\n\\t public static int removeHelper(ListNode head,int n){\\n\\t\\tif(head.next==null){\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\tint cur=1+removeHelper(head.next, n);\\n\\t\\tif(cur==n+1){\\n\\t\\t\\thead.next=head.next==null?null:head.next.next;\\n\\t\\t}\\n\\t\\treturn cur;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic static ListNode removeNthFromEnd(ListNode head, int n) {\\n\\t\\tif(head==null){\\n\\t\\t\\treturn null;\\n\\t\\t}\\n        int depth=removeHelper(head,n);\\n        head=depth>n?head:head.next;\\n        return head;\\n \\n    }\\n\\t public static int removeHelper(ListNode head,int n){\\n\\t\\tif(head.next==null){\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\tint cur=1+removeHelper(head.next, n);\\n\\t\\tif(cur==n+1){\\n\\t\\t\\thead.next=head.next==null?null:head.next.next;\\n\\t\\t}\\n\\t\\treturn cur;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8910,
                "title": "o-n-time-o-1-space-ruby-solution-single-pass",
                "content": "``` ruby\\ndef remove_nth_from_end(head, n)\\n    return nil unless head.next\\n    count = 0\\n    h, p = head, head\\n    while h\\n        p = p.next if count > n\\n        h = h.next\\n        count += 1\\n    end\\n    return head.next if count == n\\n    p.next = p.next.next\\n    head\\nend\\n```",
                "solutionTags": [],
                "code": "``` ruby\\ndef remove_nth_from_end(head, n)\\n    return nil unless head.next\\n    count = 0\\n    h, p = head, head\\n    while h\\n        p = p.next if count > n\\n        h = h.next\\n        count += 1\\n    end\\n    return head.next if count == n\\n    p.next = p.next.next\\n    head\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 8984,
                "title": "one-pass-javascript-solution",
                "content": "    var removeNthFromEnd = function(head, n) {\\n      var left, before, right = head;\\n      left = before = {next: head}; \\n      while (n--) right = right.next;\\n      while (right) {\\n        right = right.next;\\n        left = left.next;\\n      }\\n      left.next = left.next.next;\\n      return before.next;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var removeNthFromEnd = function(head, n) {\\n      var left, before, right = head;\\n      left = before = {next: head}; \\n      while (n--) right = right.next;\\n      while (right) {\\n        right = right.next;\\n        left = left.next;\\n      }\\n      left.next = left.next.next;\\n      return before.next;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 4086979,
                "title": "accepted-java-code-beats-100",
                "content": "# Complexity\\n- Time complexity : $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```JAVA []\\nclass Solution {\\npublic ListNode removeNthFromEnd(ListNode head, int n) {\\n    if(head == null) return head;\\n    int k = 0;\\n    ListNode curr = head;\\n    for(; curr != null; curr = curr.next) k++;\\n    k -= n; //to get position of given element from first node\\n    if(k == 0) return head.next;\\n    for(curr = head; k > 1; k--, curr = curr.next) ;\\n    curr.next = curr.next.next; // to remove that node\\n    return head;\\n    }\\n}\\n```\\n>>> ## Upvote\\uD83D\\uDC4D if you find helpful\\n",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```JAVA []\\nclass Solution {\\npublic ListNode removeNthFromEnd(ListNode head, int n) {\\n    if(head == null) return head;\\n    int k = 0;\\n    ListNode curr = head;\\n    for(; curr != null; curr = curr.next) k++;\\n    k -= n; //to get position of given element from first node\\n    if(k == 0) return head.next;\\n    for(curr = head; k > 1; k--, curr = curr.next) ;\\n    curr.next = curr.next.next; // to remove that node\\n    return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799083,
                "title": "simple-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* start = new ListNode();\\n        start->next = head;\\n        ListNode* slow = start;\\n        ListNode* fast = start;\\n        for(int i = 0; i < n; ++i) {\\n            fast = fast->next;\\n        }\\n        while(fast->next) {\\n            fast = fast->next;\\n            slow = slow->next;\\n        }\\n        slow->next = slow->next->next;\\n        return start->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* start = new ListNode();\\n        start->next = head;\\n        ListNode* slow = start;\\n        ListNode* fast = start;\\n        for(int i = 0; i < n; ++i) {\\n            fast = fast->next;\\n        }\\n        while(fast->next) {\\n            fast = fast->next;\\n            slow = slow->next;\\n        }\\n        slow->next = slow->next->next;\\n        return start->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725716,
                "title": "easy-to-understand-c",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* temp = head;\\n<!-- Iterate till end to find length of list -->\\n        int cnt = 0;\\n        while (temp) {\\n            temp = temp->next;\\n            cnt++;\\n        }\\n<!-- If single node then return head->next i.e NULL -->\\n        cnt = cnt - n;\\n        if (cnt == 0) {\\n            return head->next;\\n        }\\n<!-- mark the length till which you have to iterate -->\\n        temp = head;\\n        while (cnt - 1) {\\n            temp = temp->next;\\n            cnt--;\\n        }\\n<!-- After iterating till just previous node of node which is to be removed, mark the next of node by skipping the node in between -->\\n        temp->next = temp->next->next;\\n        return head;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* temp = head;\\n<!-- Iterate till end to find length of list -->\\n        int cnt = 0;\\n        while (temp) {\\n            temp = temp->next;\\n            cnt++;\\n        }\\n<!-- If single node then return head->next i.e NULL -->\\n        cnt = cnt - n;\\n        if (cnt == 0) {\\n            return head->next;\\n        }\\n<!-- mark the length till which you have to iterate -->\\n        temp = head;\\n        while (cnt - 1) {\\n            temp = temp->next;\\n            cnt--;\\n        }\\n<!-- After iterating till just previous node of node which is to be removed, mark the next of node by skipping the node in between -->\\n        temp->next = temp->next->next;\\n        return head;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370715,
                "title": "typescript-2-pointers-smart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction removeNthFromEnd(head: ListNode | null, n: number): ListNode | null {\\n    let fastP: ListNode = head\\n    let slowP: ListNode = head\\n    for (let i = 0; i < n; i++) {\\n        fastP = fastP.next;\\n    }\\n    if (!fastP) return head.next;\\n\\n    while (fastP.next) {\\n        fastP = fastP.next\\n        slowP = slowP.next;\\n    }\\n    slowP.next = slowP.next.next;\\n\\n    return head\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction removeNthFromEnd(head: ListNode | null, n: number): ListNode | null {\\n    let fastP: ListNode = head\\n    let slowP: ListNode = head\\n    for (let i = 0; i < n; i++) {\\n        fastP = fastP.next;\\n    }\\n    if (!fastP) return head.next;\\n\\n    while (fastP.next) {\\n        fastP = fastP.next\\n        slowP = slowP.next;\\n    }\\n    slowP.next = slowP.next.next;\\n\\n    return head\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254467,
                "title": "c-easy-solution-using-length-of-linkedlist",
                "content": "# Intuition\\nWe can traverse the linked list and find the length of the list. Then, we can traverse the list again to reach the nth node from the end and remove it. To remove the node, we need to modify the \\'next\\' pointer of its previous node to point to its next node.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Define a helper function \\'getlength()\\' that takes the head of the linked list as input and returns its length.\\n2. Compute the length of the linked list using the \\'getlength()\\' function.\\n3. Traverse the linked list again until the node n nodes from the end is reached.\\n4. Modify the next pointer of the previous node to point to the next node of the node to be removed.\\n5. Delete the node to be removed.\\n6. Return the head of the modified linked list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N), where N is the length of the linked list. We traverse the linked list twice.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1), We only use constant extra space to store the pointers.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    int getlength(ListNode* head){\\n        ListNode* curr = head;\\n        int length = 0;\\n        while(curr!=NULL){\\n            length++;\\n            curr = curr->next;\\n        }\\n        return length;\\n    }\\n\\n\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        if (head == nullptr) {\\n            return nullptr;\\n        }\\n\\n       int length = getlength(head);\\n       ListNode* node = NULL;\\n       if(length<=1) return node;\\n\\n       ListNode* curr = head;\\n       ListNode* prev = NULL;\\n\\n       int position = length - n;\\n       int count = 1;\\n\\n       if(length==n){\\n            head = head->next;\\n           curr->next = NULL;\\n           delete curr;\\n           return head;\\n       }\\n\\n       while(count<=position){\\n           prev = curr;\\n           curr = curr->next;\\n           count++;\\n       }\\n\\n        if(curr==NULL){\\n           prev->next = NULL;\\n       }\\n        else{\\n        prev->next = curr->next;\\n        curr->next = NULL;\\n        delete curr;\\n        }     \\n\\n        return head;\\n               \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    int getlength(ListNode* head){\\n        ListNode* curr = head;\\n        int length = 0;\\n        while(curr!=NULL){\\n            length++;\\n            curr = curr->next;\\n        }\\n        return length;\\n    }\\n\\n\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        if (head == nullptr) {\\n            return nullptr;\\n        }\\n\\n       int length = getlength(head);\\n       ListNode* node = NULL;\\n       if(length<=1) return node;\\n\\n       ListNode* curr = head;\\n       ListNode* prev = NULL;\\n\\n       int position = length - n;\\n       int count = 1;\\n\\n       if(length==n){\\n            head = head->next;\\n           curr->next = NULL;\\n           delete curr;\\n           return head;\\n       }\\n\\n       while(count<=position){\\n           prev = curr;\\n           curr = curr->next;\\n           count++;\\n       }\\n\\n        if(curr==NULL){\\n           prev->next = NULL;\\n       }\\n        else{\\n        prev->next = curr->next;\\n        curr->next = NULL;\\n        delete curr;\\n        }     \\n\\n        return head;\\n               \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3245946,
                "title": "0ms-beats-100-one-pass-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n){\\n        ListNode ans=new ListNode();\\n        ans.next=head;\\n        ListNode fast=ans;\\n        ListNode slow=ans;\\n\\n        for(int i=1;i<=n;i++){\\n            fast=fast.next;\\n        }\\n\\n        while(fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next;\\n        }\\n        slow.next=slow.next.next;\\n        return ans.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n){\\n        ListNode ans=new ListNode();\\n        ans.next=head;\\n        ListNode fast=ans;\\n        ListNode slow=ans;\\n\\n        for(int i=1;i<=n;i++){\\n            fast=fast.next;\\n        }\\n\\n        while(fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next;\\n        }\\n        slow.next=slow.next.next;\\n        return ans.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041441,
                "title": "0ms-100-beats-easy-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        int size=findSize(head);\\n        ListNode ans= new ListNode();\\n        ListNode prev=ans;\\n        ListNode cur=head;\\n        for(int i=0;i<size-n;i++){\\n            prev.next=cur;\\n            cur=cur.next;\\n            prev=prev.next;\\n        } \\n        prev.next=cur.next;\\n        return ans.next;\\n    }\\n    public int findSize(ListNode head){\\n        ListNode temp=head;\\n        int count=0;\\n        while(temp!=null){\\n            count++;\\n            temp=temp.next;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        int size=findSize(head);\\n        ListNode ans= new ListNode();\\n        ListNode prev=ans;\\n        ListNode cur=head;\\n        for(int i=0;i<size-n;i++){\\n            prev.next=cur;\\n            cur=cur.next;\\n            prev=prev.next;\\n        } \\n        prev.next=cur.next;\\n        return ans.next;\\n    }\\n    public int findSize(ListNode head){\\n        ListNode temp=head;\\n        int count=0;\\n        while(temp!=null){\\n            count++;\\n            temp=temp.next;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016097,
                "title": "single-pass-recursive-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse recursion to accumulate new list with a single pass.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI use a recursive helper function that returns a tuple containing the accumulated result ListNode along with a count of nodes that begins from the end of the list. At each recursive step, I first call the recursive helper function, then check if the current node is the nth node from the end of the list. If it is, then I do not accumulate the current node value, if it isn\\'t then I add the current node value and continue. \\n\\n[Quick Video Explanation with Diagram](https://youtu.be/p3CPh_hjcpk)\\nhttps://youtu.be/p3CPh_hjcpk\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def recursiveHelper(self, head: Optional[ListNode], n: int) -> (Optional[ListNode], int):\\n        if (head == None):\\n            return (None, 0)\\n        else:\\n            (chain, location) = self.recursiveHelper(head.next, n)\\n            location += 1\\n            if (location == n):\\n                return (chain, location)\\n            else:\\n                return (ListNode(head.val, chain), location)\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        (head, location) = self.recursiveHelper(head, n)\\n        return head\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def recursiveHelper(self, head: Optional[ListNode], n: int) -> (Optional[ListNode], int):\\n        if (head == None):\\n            return (None, 0)\\n        else:\\n            (chain, location) = self.recursiveHelper(head.next, n)\\n            location += 1\\n            if (location == n):\\n                return (chain, location)\\n            else:\\n                return (ListNode(head.val, chain), location)\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        (head, location) = self.recursiveHelper(head, n)\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833601,
                "title": "concise-java-solution-faster-than-100-with-explanation",
                "content": "**Explanation**: First, I get the length of the list by looping through it. Then I calculate the node to be removed as `listLength - n`. A standard algorithm to  remove the node is then implemented. Below is the full code.\\n\\n```\\npublic ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fakeHead = head;\\n        int listLength = 1;\\n        while(fakeHead.next != null) {\\n            listLength++;\\n            fakeHead = fakeHead.next;\\n        }\\n        if(n == listLength) {\\n            head = head.next;\\n            return head;\\n        }\\n        int nodeToRemove = listLength - n;\\n        fakeHead = head;\\n        for(int i=0; fakeHead.next!=null && i<nodeToRemove-1; i++){\\n            fakeHead = fakeHead.next;\\n        }\\n        fakeHead.next = fakeHead.next.next;\\n        return head;\\n    }\\n```\\n\\nIf this solution helped you, an upvote would be greatly appreciated :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fakeHead = head;\\n        int listLength = 1;\\n        while(fakeHead.next != null) {\\n            listLength++;\\n            fakeHead = fakeHead.next;\\n        }\\n        if(n == listLength) {\\n            head = head.next;\\n            return head;\\n        }\\n        int nodeToRemove = listLength - n;\\n        fakeHead = head;\\n        for(int i=0; fakeHead.next!=null && i<nodeToRemove-1; i++){\\n            fakeHead = fakeHead.next;\\n        }\\n        fakeHead.next = fakeHead.next.next;\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2634465,
                "title": "javascript-solution-88-36-percent-faster",
                "content": "``` \\nvar removeNthFromEnd = function(head, n) {\\n    var node = new ListNode()\\n    var rep = node\\n    var hash = []\\n    while(head!==null){\\n        hash.push(head.val)\\n        head = head.next\\n    }\\n    var count = hash.length-n\\n    let i = 0\\n    while(i<hash.length){\\n        if(count!==0){\\n            node.next = new ListNode(hash[i])\\n            count--\\n            node = node.next\\n        }else{\\n            count+=n-1 \\n        }\\n        i++\\n    }\\n    return rep.next\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` \\nvar removeNthFromEnd = function(head, n) {\\n    var node = new ListNode()\\n    var rep = node\\n    var hash = []\\n    while(head!==null){\\n        hash.push(head.val)\\n        head = head.next\\n    }\\n    var count = hash.length-n\\n    let i = 0\\n    while(i<hash.length){\\n        if(count!==0){\\n            node.next = new ListNode(hash[i])\\n            count--\\n            node = node.next\\n        }else{\\n            count+=n-1 \\n        }\\n        i++\\n    }\\n    return rep.next\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2633583,
                "title": "rust-concise-two-pass-with-iterators-with-comments",
                "content": "After solving this, I read through **all** the published Rust solutions, and despite all the posted variations, I think this brings something new to the table in terms of using standard library features of Rust to avoid reinventing the wheel. The algorithm itself is the same as every other iterative Rust solution, though - count the number of total nodes, step up to the node immediately before the node to be deleted, and link it to the node immediately after the deleted node.\\n\\nImplementation notes:\\n* `std::iter::successors` yields elements as long as the state is `Some(...)`. Could it be more ideal for counting the number of nodes in our linked list? :)\\n* `fold` gives us exactly what we need to iterate over the list and give us the node we want.\\n\\n```\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        let cnt = std::iter::successors(head.as_ref(), |last| last.next.as_ref()).count();\\n        let mut dummy = Some(Box::new(ListNode{val: 0, next: head}));\\n        let mut prev = (0..cnt - n as usize).fold(dummy.as_mut(), |curr, _| curr.unwrap().next.as_mut() );\\n        prev.unwrap().next = prev.as_mut().unwrap().next.as_mut().unwrap().next.take();\\n        dummy.unwrap().next\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        let cnt = std::iter::successors(head.as_ref(), |last| last.next.as_ref()).count();\\n        let mut dummy = Some(Box::new(ListNode{val: 0, next: head}));\\n        let mut prev = (0..cnt - n as usize).fold(dummy.as_mut(), |curr, _| curr.unwrap().next.as_mut() );\\n        prev.unwrap().next = prev.as_mut().unwrap().next.as_mut().unwrap().next.take();\\n        dummy.unwrap().next\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2603476,
                "title": "0-ms-faster-than-100-00-of-java",
                "content": "```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode temp=head;\\n        ListNode slow=head;\\n        ListNode fast=slow.next;\\n        int count=0;\\n        while(temp!=null){\\n            count++;\\n            temp=temp.next;\\n        }\\n        count=count-n;\\n        while(count!=1 && fast!=null){\\n            slow=slow.next;\\n            fast=fast.next;\\n            count--;\\n        }\\n        if(fast==null){\\n            head=head.next;\\n        }else{\\n            slow.next=fast.next;\\n        }\\n        return head;\\n    }\\n}\\nPLEASE UPVOTE \\uD83D\\uDE0A```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode temp=head;\\n        ListNode slow=head;\\n        ListNode fast=slow.next;\\n        int count=0;\\n        while(temp!=null){\\n            count++;\\n            temp=temp.next;\\n        }\\n        count=count-n;\\n        while(count!=1 && fast!=null){\\n            slow=slow.next;\\n            fast=fast.next;\\n            count--;\\n        }\\n        if(fast==null){\\n            head=head.next;\\n        }else{\\n            slow.next=fast.next;\\n        }\\n        return head;\\n    }\\n}\\nPLEASE UPVOTE \\uD83D\\uDE0A```",
                "codeTag": "Java"
            },
            {
                "id": 2384172,
                "title": "c-solution-0ms-better-than-100-comments-easy",
                "content": "![image](https://assets.leetcode.com/users/images/9bbc3ebd-149a-43b6-afb5-b312d3eed80a_1659721445.167148.png)\\n```\\n// to calculate the number of elements in linked list\\nint length(ListNode* head){\\n\\tint len=0;\\n\\twhile(head!=NULL)\\n\\t\\thead = head->next, len++;\\n\\treturn len;\\n}\\n\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\tint len = length(head);\\n\\t// if n is same as length, it means we need to remove the first element\\n\\tif(n==len){\\n\\t\\thead = head->next; return head;\\n\\t}\\n\\t\\n\\tint count=1;\\n\\tListNode* temp = head;\\n\\t// running the while loop n number of times, \\n\\t// and stopping just before the last nth node, i.e., prev node before last nth node.\\n\\twhile(count!=len-n){\\n\\t\\ttemp= temp->next;\\n\\t\\tcount++;\\n\\t}\\n\\t\\n\\t// now its just simple delete node example\\n\\t// we point the next of the prev node to next of last nth node.\\n\\tif(temp!= NULL && temp->next!=NULL)\\n\\t\\ttemp->next= temp->next->next;\\n\\treturn head;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// to calculate the number of elements in linked list\\nint length(ListNode* head){\\n\\tint len=0;\\n\\twhile(head!=NULL)\\n\\t\\thead = head->next, len++;\\n\\treturn len;\\n}\\n\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\tint len = length(head);\\n\\t// if n is same as length, it means we need to remove the first element\\n\\tif(n==len){\\n\\t\\thead = head->next; return head;\\n\\t}\\n\\t\\n\\tint count=1;\\n\\tListNode* temp = head;\\n\\t// running the while loop n number of times, \\n\\t// and stopping just before the last nth node, i.e., prev node before last nth node.\\n\\twhile(count!=len-n){\\n\\t\\ttemp= temp->next;\\n\\t\\tcount++;\\n\\t}\\n\\t\\n\\t// now its just simple delete node example\\n\\t// we point the next of the prev node to next of last nth node.\\n\\tif(temp!= NULL && temp->next!=NULL)\\n\\t\\ttemp->next= temp->next->next;\\n\\treturn head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2317493,
                "title": "c-slow-fast-pointers",
                "content": "Straight forward solution, comment below if there\\'re any suggestions or doubts :)\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode * start = new ListNode();\\n        start -> next = head;\\n        ListNode* fast = start;\\n        ListNode* slow = start;     \\n\\n        for(int i = 1; i <= n; ++i) fast = fast->next;\\n    \\n        while(fast->next != NULL){\\n            fast = fast->next;\\n            slow = slow->next;\\n        }\\n        \\n        slow->next = slow->next->next;\\n        \\n        return start->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode * start = new ListNode();\\n        start -> next = head;\\n        ListNode* fast = start;\\n        ListNode* slow = start;     \\n\\n        for(int i = 1; i <= n; ++i) fast = fast->next;\\n    \\n        while(fast->next != NULL){\\n            fast = fast->next;\\n            slow = slow->next;\\n        }\\n        \\n        slow->next = slow->next->next;\\n        \\n        return start->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299971,
                "title": "easy-to-understand-one-pass-solution",
                "content": "***Fast and slow pointers*** [0ms 40.3MB](https://leetcode.com/submissions/detail/750313835/)\\nHey there! Just another popular problem - boy, they really into LinkedList problems. Idea is simples - we put the slow pointer in the beginning of the list, and n-1 to right of it we put another (call it slow and fast respectivly). Then traverse until last node for **fast pointer**, then simply delete.  Here goes the code! \\n```\\npublic ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fastPointer = head;\\n        if (fastPointer.next == null) {\\n            return null;\\n        }\\n        ListNode slowPointer = null;\\n        \\n        for (int i = 1; i < n; i++) {\\n            fastPointer = fastPointer.next;\\n        }\\n        \\n        while (fastPointer.next != null) {\\n            fastPointer = fastPointer.next;\\n            if (slowPointer == null) {\\n                slowPointer = head;\\n            } else {\\n                slowPointer = slowPointer.next;\\n            }\\n        }\\n        \\n        if (slowPointer == null) {\\n            return head.next;\\n        }\\n        slowPointer.next = slowPointer.next.next;\\n        return head;\\n    }\\n``` \\nTime complexity: O(n) - since we traverse list in one pass\\nSpace complexity: O(1) - no additional space required",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Interactive"
                ],
                "code": "```\\npublic ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fastPointer = head;\\n        if (fastPointer.next == null) {\\n            return null;\\n        }\\n        ListNode slowPointer = null;\\n        \\n        for (int i = 1; i < n; i++) {\\n            fastPointer = fastPointer.next;\\n        }\\n        \\n        while (fastPointer.next != null) {\\n            fastPointer = fastPointer.next;\\n            if (slowPointer == null) {\\n                slowPointer = head;\\n            } else {\\n                slowPointer = slowPointer.next;\\n            }\\n        }\\n        \\n        if (slowPointer == null) {\\n            return head.next;\\n        }\\n        slowPointer.next = slowPointer.next.next;\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2246932,
                "title": "java-in-depth-explanation-two-pointers-technique",
                "content": "You need to know how to remove element from the LinkedList.\\n \\n **Intuition**\\n\\nThe optimal solution for the problem is using **Two Pointer Technique**.  Let\\'s say `n = 2` and we have a LinkedList `1 -> 2 -> 3 -> 4 -> 5 `. Then we want to make it as `1 -> 2 -> 3 -> 5`. Therefore, we want to have make `left` pointer points to `3`, and we could do `left.next = left.next.next`. But how do we achieve it?\\n  \\n**Oberservation**\\nThis is what we want eventually so we can perform the operation mentioned above. We can obeserve that the distance between `left` and `right` are `n+1`. \\n```\\n1   ->   2   ->   3   ->   4   ->   5  ->  null\\n                 left                      right\\n\\t\\t\\t\\t |----      n+1        ------|\\n```\\n\\nHow do we achieve it? We can place `left` on `dummyHead` position, and place `right` on position where is `n` distance away from `head`. Therefore, the distance between `left` and `right` will be `n+1` eventually.\\n\\n```\\ndummyHead   ->   1   ->   2   ->   3   ->   4   ->   5\\n   left                          right \\n   |----         n+1         ------|\\n```\\n\\n**Java code implementation**\\n\\n```\\nclass Solution\\n{\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        // O(L) time | O(1) space\\n        // two pointer technique\\n        ListNode dummyHead = new ListNode(-1);\\n        dummyHead.next = head;\\n        ListNode left = dummyHead;\\n        ListNode right = head;\\n        \\n        while(n > 0)\\n        {\\n            n -= 1;\\n            right = right.next;\\n        }\\n        \\n        while(right != null)\\n        {\\n            left = left.next;\\n            right = right.next;\\n        }\\n        left.next = left.next.next;\\n        \\n        return dummyHead.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n1   ->   2   ->   3   ->   4   ->   5  ->  null\\n                 left                      right\\n\\t\\t\\t\\t |----      n+1        ------|\\n```\n```\\ndummyHead   ->   1   ->   2   ->   3   ->   4   ->   5\\n   left                          right \\n   |----         n+1         ------|\\n```\n```\\nclass Solution\\n{\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        // O(L) time | O(1) space\\n        // two pointer technique\\n        ListNode dummyHead = new ListNode(-1);\\n        dummyHead.next = head;\\n        ListNode left = dummyHead;\\n        ListNode right = head;\\n        \\n        while(n > 0)\\n        {\\n            n -= 1;\\n            right = right.next;\\n        }\\n        \\n        while(right != null)\\n        {\\n            left = left.next;\\n            right = right.next;\\n        }\\n        left.next = left.next.next;\\n        \\n        return dummyHead.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136314,
                "title": "easy-and-simple-python-solution-with-explanation",
                "content": "-We take two pointers. Keep the first pointer start at the begining of the list and second traverse to position N+1 th element in the list. \\n-Here we consider the head to be initially null. \\n-This will help the 2 pointers to be seperated by exactly N nodes.\\n-The N node difference gap will be maintained as we advance both pointers at the same pace.\\n-We continue to traverse untill the second pointer reaches Null.\\n-When the second pointer reaches Null, the first pointer will exactly point one position before the target node which is to be deleted.\\n-With first.next.next we jump that node and return head for the result\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        \\n        ans=ListNode(0)\\n        ans.next=head\\n        first=ans\\n        second=ans\\n        for i in range(1,n+2):\\n            second=second.next\\n        while(second is not None):\\n            second=second.next\\n            first=first.next\\n        first.next=first.next.next\\n        return ans.next\\n```\\n\\n**Please upvote if it helped :)**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        \\n        ans=ListNode(0)\\n        ans.next=head\\n        first=ans\\n        second=ans\\n        for i in range(1,n+2):\\n            second=second.next\\n        while(second is not None):\\n            second=second.next\\n            first=first.next\\n        first.next=first.next.next\\n        return ans.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090746,
                "title": "easy-cpp-two-piointer-approach",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head == NULL)\\n        return NULL;\\n \\n    ListNode *fast = head;\\n    ListNode *slow = head;\\n \\n    for(int i=0; i<n; i++){\\n        fast = fast->next; //Firstly move the pointer by one step till it reaches nth node from starting\\n    }\\n \\n    //if remove the first node\\n    if(fast == NULL){\\n        head = head->next;\\n        return head;\\n    }\\n \\n    while(fast->next != NULL){\\n        fast = fast->next;\\n        slow = slow->next;\\n    }\\n        //slow will reach at the (n-1)th position from end of the list\\n    slow->next = slow->next->next;\\n \\n    return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head == NULL)\\n        return NULL;\\n \\n    ListNode *fast = head;\\n    ListNode *slow = head;\\n \\n    for(int i=0; i<n; i++){\\n        fast = fast->next; //Firstly move the pointer by one step till it reaches nth node from starting\\n    }\\n \\n    //if remove the first node\\n    if(fast == NULL){\\n        head = head->next;\\n        return head;\\n    }\\n \\n    while(fast->next != NULL){\\n        fast = fast->next;\\n        slow = slow->next;\\n    }\\n        //slow will reach at the (n-1)th position from end of the list\\n    slow->next = slow->next->next;\\n \\n    return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2079645,
                "title": "python-using-two-pointers-and-dummy-node-in-o-n-time",
                "content": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        dummy = ListNode(0,head)\\n        first = dummy\\n        second = head\\n        while n > 0 and second:\\n            n-=1\\n            second = second.next\\n        \\n        while second:\\n            first = first.next\\n            second = second.next\\n        \\n        first.next = first.next.next\\n        return dummy.next\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        dummy = ListNode(0,head)\\n        first = dummy\\n        second = head\\n        while n > 0 and second:\\n            n-=1\\n            second = second.next\\n        \\n        while second:\\n            first = first.next\\n            second = second.next\\n        \\n        first.next = first.next.next\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2077600,
                "title": "java-single-pass-two-pointer-o-n-time-and-o-1-space",
                "content": "```\\n//TC: O(n)\\n//SC: O(1)\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        //base case\\n        if(head == null){\\n            return head;\\n        }\\n        \\n        int count = 0;\\n        ListNode dummy = new ListNode(-1);\\n        //Adding a dummy node befor the head, gives us the ease to write to code\\n        //without having to handle seperately the case where we have to delete\\n        //head node or even if there is only one node in the list\\n        dummy.next = head;\\n        ListNode slow = dummy;\\n        ListNode fast = dummy;//ahead of slow, and heance the name\\n        \\n        //We move the fast pointer until the count is <= n\\n        while(count <= n){\\n            count++;\\n            fast = fast.next;\\n        }\\n        //Then we move slow and fast at 1x speed, until fast is null\\n        //This places the slow at (n-1)th position form end\\n        //As we want to remove nth node, we reset links and we remove\\n        //the nth node\\n        while(fast != null){\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        //Reset the links and remove nth node\\n        slow.next = slow.next.next;\\n        //As head is at dummy.next, we return that\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n//TC: O(n)\\n//SC: O(1)\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        //base case\\n        if(head == null){\\n            return head;\\n        }\\n        \\n        int count = 0;\\n        ListNode dummy = new ListNode(-1);\\n        //Adding a dummy node befor the head, gives us the ease to write to code\\n        //without having to handle seperately the case where we have to delete\\n        //head node or even if there is only one node in the list\\n        dummy.next = head;\\n        ListNode slow = dummy;\\n        ListNode fast = dummy;//ahead of slow, and heance the name\\n        \\n        //We move the fast pointer until the count is <= n\\n        while(count <= n){\\n            count++;\\n            fast = fast.next;\\n        }\\n        //Then we move slow and fast at 1x speed, until fast is null\\n        //This places the slow at (n-1)th position form end\\n        //As we want to remove nth node, we reset links and we remove\\n        //the nth node\\n        while(fast != null){\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        //Reset the links and remove nth node\\n        slow.next = slow.next.next;\\n        //As head is at dummy.next, we return that\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024693,
                "title": "python-solution-faster-than-95",
                "content": "Take a dummy node connect it with head (if we take a dummy node then it would be easy to delete the first node if target node is head ie. n = length of list). Take 2 pointers fast and slow. Increase the fast pointer by n steps. Then in next pass increase both slow and fast together by one step. Slow will stop before the target element then delete the link.\\n\\n```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        fast = head\\n        slow = dummy\\n        \\n        for i in range(n):\\n            fast = fast.next\\n        \\n        while fast:\\n            fast = fast.next\\n            slow = slow.next\\n        \\n        tmp = slow.next.next\\n        slow.next.next = None\\n        slow.next = tmp\\n        \\n        return dummy.next\\n\\n# Time: O(N)    where N is the length of Linkedlist\\n# Space: O(1)\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        fast = head\\n        slow = dummy\\n        \\n        for i in range(n):\\n            fast = fast.next\\n        \\n        while fast:\\n            fast = fast.next\\n            slow = slow.next\\n        \\n        tmp = slow.next.next\\n        slow.next.next = None\\n        slow.next = tmp\\n        \\n        return dummy.next\\n\\n# Time: O(N)    where N is the length of Linkedlist\\n# Space: O(1)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1575851,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1564857,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1566736,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1565826,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1576041,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1576258,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1571048,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1576900,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1567166,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1820945,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1575851,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1564857,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1566736,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1565826,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1576041,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1576258,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1571048,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1576900,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1567166,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1820945,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1567809,
                "content": [
                    {
                        "username": "what_if",
                        "content": "I see many people use two pointers, which I think is actually the same as two passes."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@chickooo](/chickooo) Your analysis isn't correct for two pointers. The first pointer moves k steps. Then **both** pointers move (n - k) steps so it's 2*(n-k) steps.\n\nTotal number of steps is k + 2*(n-k) = 2n - k which is exactly the same as the two pass approach."
                    },
                    {
                        "username": "kuelf",
                        "content": "[@chickooo](/chickooo) It is the same.\nBoth reduce to O(n).\nAlso k is meaningless."
                    },
                    {
                        "username": "chickooo",
                        "content": "For two pointers, the complexity is **O(n+k)**\\nBut for two pass it is **O(n + (n-k))**\\n\\nhere, k is nth position from end."
                    },
                    {
                        "username": "xiaoxiaoxiaoV",
                        "content": "if  we ignore the note,\"Given n will always be valid\", how we handle the situation that n is bigger than the length of the linked list?"
                    },
                    {
                        "username": "scrabbletank",
                        "content": "It says in the problem description that n is always valid, but this doesn't seem to be the case. One of the final test passes uses this test case:\\n\\n[1]\\n1\\n\\nThere isn't a 2nd element to remove, so in this case N is invalid. What's more, the expected answer is [] and not [1]."
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Initialize a `dummy` node  `(None -> head)`\\nthis will help you to cater the issue of removing `first(head)` node."
                    },
                    {
                        "username": "forresthopkinsa",
                        "content": "If you\\'re getting weird JS test failures and you don\\'t know why, here\\'s some help: this problem tests for tail nodes with `{ next: null }`.\\n\\n`{ next: undefined }` and `{}` will not work.\\n\\nThis is the first time I\\'ve seen a problem with this requirement. This expectation is undocumented and the resulting errors can be cryptic."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Thanks a lot for that! My code was getting that error and I was looking for a comment related to it. A simple if(node.next === undefined)node.next = null   did the trick."
                    },
                    {
                        "username": "MPMoka",
                        "content": "Test system is not providing right \\'n\\' to the code."
                    },
                    {
                        "username": "ronlek",
                        "content": "Here's a solution that's actually \"one-pass\".\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        vector<ListNode*> nodeList;\n        ListNode *node = head;\n\n        while(node){\n            nodeList.push_back(node);\n            node = node -> next;\n        }\n\n        int nlSize = nodeList.size();\n        if(nlSize - n == 0){\n            return head -> next;\n        }\n\n        ListNode *cur = nodeList[nlSize - n - 1];\n        cur -> next = cur -> next -> next;\n\n        return head;\n    }\n};\n```\n\nTime Complexity: `O(N)`. Each node is traversed once.\nSpace Complexity: `O(N)`. Each node is stored in the vector."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nHere are the rules...\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yawend",
                        "content": "To delete the Nth Node from end, N+1th Node from end is required.\\nhighlight:\\nhow to find the nth node from end:\\nUse two pointers, both pointers points the the head initially.\\nThen pointer1 moves nth steps first.\\nThen both 2 pointer moves together.\\nWhen pointer1 moves to the end of the linklist,\\npointer2 points to the nth node from end.\\n\\n`class Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        \\n        #find the N+1th Node from end\\n        p=self.findFromEnd(dummy,n+1)\\n        \\n        #let the N+1th Node from end next to the N-1th Node from end\\n        p.next=p.next.next\\n        return dummy.next\\n\\n    def findFromEnd(self, head, n):\\n        p1=ListNode(-1)\\n        p2=ListNode(-1)\\n        \\n        #both p1 and p2 points to head\\n        p1.next=head\\n        p2.next=head\\n        \\n        #pointer p1 moves to the Nth node first\\n        for i in range(n):\\n            p1=p1.next\\n        \\n        #move p1 and p2 at the same time, when p1 moves to the end,p2 move to the Nth Node from end\\n        while p1 != None:\\n            p2=p2.next\\n            p1=p1.next\\n        \\n        return p2`"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Faster C++ || Java Script || Java || Python \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-remove-nth-node-from-end-of-list-c-python-java-javascript-solution/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/remove-nth-node-from-end-of-list-leetcode-python/\\n"
                    }
                ]
            },
            {
                "id": 1571049,
                "content": [
                    {
                        "username": "what_if",
                        "content": "I see many people use two pointers, which I think is actually the same as two passes."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@chickooo](/chickooo) Your analysis isn't correct for two pointers. The first pointer moves k steps. Then **both** pointers move (n - k) steps so it's 2*(n-k) steps.\n\nTotal number of steps is k + 2*(n-k) = 2n - k which is exactly the same as the two pass approach."
                    },
                    {
                        "username": "kuelf",
                        "content": "[@chickooo](/chickooo) It is the same.\nBoth reduce to O(n).\nAlso k is meaningless."
                    },
                    {
                        "username": "chickooo",
                        "content": "For two pointers, the complexity is **O(n+k)**\\nBut for two pass it is **O(n + (n-k))**\\n\\nhere, k is nth position from end."
                    },
                    {
                        "username": "xiaoxiaoxiaoV",
                        "content": "if  we ignore the note,\"Given n will always be valid\", how we handle the situation that n is bigger than the length of the linked list?"
                    },
                    {
                        "username": "scrabbletank",
                        "content": "It says in the problem description that n is always valid, but this doesn't seem to be the case. One of the final test passes uses this test case:\\n\\n[1]\\n1\\n\\nThere isn't a 2nd element to remove, so in this case N is invalid. What's more, the expected answer is [] and not [1]."
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Initialize a `dummy` node  `(None -> head)`\\nthis will help you to cater the issue of removing `first(head)` node."
                    },
                    {
                        "username": "forresthopkinsa",
                        "content": "If you\\'re getting weird JS test failures and you don\\'t know why, here\\'s some help: this problem tests for tail nodes with `{ next: null }`.\\n\\n`{ next: undefined }` and `{}` will not work.\\n\\nThis is the first time I\\'ve seen a problem with this requirement. This expectation is undocumented and the resulting errors can be cryptic."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Thanks a lot for that! My code was getting that error and I was looking for a comment related to it. A simple if(node.next === undefined)node.next = null   did the trick."
                    },
                    {
                        "username": "MPMoka",
                        "content": "Test system is not providing right \\'n\\' to the code."
                    },
                    {
                        "username": "ronlek",
                        "content": "Here's a solution that's actually \"one-pass\".\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        vector<ListNode*> nodeList;\n        ListNode *node = head;\n\n        while(node){\n            nodeList.push_back(node);\n            node = node -> next;\n        }\n\n        int nlSize = nodeList.size();\n        if(nlSize - n == 0){\n            return head -> next;\n        }\n\n        ListNode *cur = nodeList[nlSize - n - 1];\n        cur -> next = cur -> next -> next;\n\n        return head;\n    }\n};\n```\n\nTime Complexity: `O(N)`. Each node is traversed once.\nSpace Complexity: `O(N)`. Each node is stored in the vector."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nHere are the rules...\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yawend",
                        "content": "To delete the Nth Node from end, N+1th Node from end is required.\\nhighlight:\\nhow to find the nth node from end:\\nUse two pointers, both pointers points the the head initially.\\nThen pointer1 moves nth steps first.\\nThen both 2 pointer moves together.\\nWhen pointer1 moves to the end of the linklist,\\npointer2 points to the nth node from end.\\n\\n`class Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        \\n        #find the N+1th Node from end\\n        p=self.findFromEnd(dummy,n+1)\\n        \\n        #let the N+1th Node from end next to the N-1th Node from end\\n        p.next=p.next.next\\n        return dummy.next\\n\\n    def findFromEnd(self, head, n):\\n        p1=ListNode(-1)\\n        p2=ListNode(-1)\\n        \\n        #both p1 and p2 points to head\\n        p1.next=head\\n        p2.next=head\\n        \\n        #pointer p1 moves to the Nth node first\\n        for i in range(n):\\n            p1=p1.next\\n        \\n        #move p1 and p2 at the same time, when p1 moves to the end,p2 move to the Nth Node from end\\n        while p1 != None:\\n            p2=p2.next\\n            p1=p1.next\\n        \\n        return p2`"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Faster C++ || Java Script || Java || Python \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-remove-nth-node-from-end-of-list-c-python-java-javascript-solution/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/remove-nth-node-from-end-of-list-leetcode-python/\\n"
                    }
                ]
            },
            {
                "id": 1568838,
                "content": [
                    {
                        "username": "what_if",
                        "content": "I see many people use two pointers, which I think is actually the same as two passes."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@chickooo](/chickooo) Your analysis isn't correct for two pointers. The first pointer moves k steps. Then **both** pointers move (n - k) steps so it's 2*(n-k) steps.\n\nTotal number of steps is k + 2*(n-k) = 2n - k which is exactly the same as the two pass approach."
                    },
                    {
                        "username": "kuelf",
                        "content": "[@chickooo](/chickooo) It is the same.\nBoth reduce to O(n).\nAlso k is meaningless."
                    },
                    {
                        "username": "chickooo",
                        "content": "For two pointers, the complexity is **O(n+k)**\\nBut for two pass it is **O(n + (n-k))**\\n\\nhere, k is nth position from end."
                    },
                    {
                        "username": "xiaoxiaoxiaoV",
                        "content": "if  we ignore the note,\"Given n will always be valid\", how we handle the situation that n is bigger than the length of the linked list?"
                    },
                    {
                        "username": "scrabbletank",
                        "content": "It says in the problem description that n is always valid, but this doesn't seem to be the case. One of the final test passes uses this test case:\\n\\n[1]\\n1\\n\\nThere isn't a 2nd element to remove, so in this case N is invalid. What's more, the expected answer is [] and not [1]."
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Initialize a `dummy` node  `(None -> head)`\\nthis will help you to cater the issue of removing `first(head)` node."
                    },
                    {
                        "username": "forresthopkinsa",
                        "content": "If you\\'re getting weird JS test failures and you don\\'t know why, here\\'s some help: this problem tests for tail nodes with `{ next: null }`.\\n\\n`{ next: undefined }` and `{}` will not work.\\n\\nThis is the first time I\\'ve seen a problem with this requirement. This expectation is undocumented and the resulting errors can be cryptic."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Thanks a lot for that! My code was getting that error and I was looking for a comment related to it. A simple if(node.next === undefined)node.next = null   did the trick."
                    },
                    {
                        "username": "MPMoka",
                        "content": "Test system is not providing right \\'n\\' to the code."
                    },
                    {
                        "username": "ronlek",
                        "content": "Here's a solution that's actually \"one-pass\".\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        vector<ListNode*> nodeList;\n        ListNode *node = head;\n\n        while(node){\n            nodeList.push_back(node);\n            node = node -> next;\n        }\n\n        int nlSize = nodeList.size();\n        if(nlSize - n == 0){\n            return head -> next;\n        }\n\n        ListNode *cur = nodeList[nlSize - n - 1];\n        cur -> next = cur -> next -> next;\n\n        return head;\n    }\n};\n```\n\nTime Complexity: `O(N)`. Each node is traversed once.\nSpace Complexity: `O(N)`. Each node is stored in the vector."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nHere are the rules...\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yawend",
                        "content": "To delete the Nth Node from end, N+1th Node from end is required.\\nhighlight:\\nhow to find the nth node from end:\\nUse two pointers, both pointers points the the head initially.\\nThen pointer1 moves nth steps first.\\nThen both 2 pointer moves together.\\nWhen pointer1 moves to the end of the linklist,\\npointer2 points to the nth node from end.\\n\\n`class Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        \\n        #find the N+1th Node from end\\n        p=self.findFromEnd(dummy,n+1)\\n        \\n        #let the N+1th Node from end next to the N-1th Node from end\\n        p.next=p.next.next\\n        return dummy.next\\n\\n    def findFromEnd(self, head, n):\\n        p1=ListNode(-1)\\n        p2=ListNode(-1)\\n        \\n        #both p1 and p2 points to head\\n        p1.next=head\\n        p2.next=head\\n        \\n        #pointer p1 moves to the Nth node first\\n        for i in range(n):\\n            p1=p1.next\\n        \\n        #move p1 and p2 at the same time, when p1 moves to the end,p2 move to the Nth Node from end\\n        while p1 != None:\\n            p2=p2.next\\n            p1=p1.next\\n        \\n        return p2`"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Faster C++ || Java Script || Java || Python \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-remove-nth-node-from-end-of-list-c-python-java-javascript-solution/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/remove-nth-node-from-end-of-list-leetcode-python/\\n"
                    }
                ]
            },
            {
                "id": 1941941,
                "content": [
                    {
                        "username": "what_if",
                        "content": "I see many people use two pointers, which I think is actually the same as two passes."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@chickooo](/chickooo) Your analysis isn't correct for two pointers. The first pointer moves k steps. Then **both** pointers move (n - k) steps so it's 2*(n-k) steps.\n\nTotal number of steps is k + 2*(n-k) = 2n - k which is exactly the same as the two pass approach."
                    },
                    {
                        "username": "kuelf",
                        "content": "[@chickooo](/chickooo) It is the same.\nBoth reduce to O(n).\nAlso k is meaningless."
                    },
                    {
                        "username": "chickooo",
                        "content": "For two pointers, the complexity is **O(n+k)**\\nBut for two pass it is **O(n + (n-k))**\\n\\nhere, k is nth position from end."
                    },
                    {
                        "username": "xiaoxiaoxiaoV",
                        "content": "if  we ignore the note,\"Given n will always be valid\", how we handle the situation that n is bigger than the length of the linked list?"
                    },
                    {
                        "username": "scrabbletank",
                        "content": "It says in the problem description that n is always valid, but this doesn't seem to be the case. One of the final test passes uses this test case:\\n\\n[1]\\n1\\n\\nThere isn't a 2nd element to remove, so in this case N is invalid. What's more, the expected answer is [] and not [1]."
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Initialize a `dummy` node  `(None -> head)`\\nthis will help you to cater the issue of removing `first(head)` node."
                    },
                    {
                        "username": "forresthopkinsa",
                        "content": "If you\\'re getting weird JS test failures and you don\\'t know why, here\\'s some help: this problem tests for tail nodes with `{ next: null }`.\\n\\n`{ next: undefined }` and `{}` will not work.\\n\\nThis is the first time I\\'ve seen a problem with this requirement. This expectation is undocumented and the resulting errors can be cryptic."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Thanks a lot for that! My code was getting that error and I was looking for a comment related to it. A simple if(node.next === undefined)node.next = null   did the trick."
                    },
                    {
                        "username": "MPMoka",
                        "content": "Test system is not providing right \\'n\\' to the code."
                    },
                    {
                        "username": "ronlek",
                        "content": "Here's a solution that's actually \"one-pass\".\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        vector<ListNode*> nodeList;\n        ListNode *node = head;\n\n        while(node){\n            nodeList.push_back(node);\n            node = node -> next;\n        }\n\n        int nlSize = nodeList.size();\n        if(nlSize - n == 0){\n            return head -> next;\n        }\n\n        ListNode *cur = nodeList[nlSize - n - 1];\n        cur -> next = cur -> next -> next;\n\n        return head;\n    }\n};\n```\n\nTime Complexity: `O(N)`. Each node is traversed once.\nSpace Complexity: `O(N)`. Each node is stored in the vector."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nHere are the rules...\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yawend",
                        "content": "To delete the Nth Node from end, N+1th Node from end is required.\\nhighlight:\\nhow to find the nth node from end:\\nUse two pointers, both pointers points the the head initially.\\nThen pointer1 moves nth steps first.\\nThen both 2 pointer moves together.\\nWhen pointer1 moves to the end of the linklist,\\npointer2 points to the nth node from end.\\n\\n`class Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        \\n        #find the N+1th Node from end\\n        p=self.findFromEnd(dummy,n+1)\\n        \\n        #let the N+1th Node from end next to the N-1th Node from end\\n        p.next=p.next.next\\n        return dummy.next\\n\\n    def findFromEnd(self, head, n):\\n        p1=ListNode(-1)\\n        p2=ListNode(-1)\\n        \\n        #both p1 and p2 points to head\\n        p1.next=head\\n        p2.next=head\\n        \\n        #pointer p1 moves to the Nth node first\\n        for i in range(n):\\n            p1=p1.next\\n        \\n        #move p1 and p2 at the same time, when p1 moves to the end,p2 move to the Nth Node from end\\n        while p1 != None:\\n            p2=p2.next\\n            p1=p1.next\\n        \\n        return p2`"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Faster C++ || Java Script || Java || Python \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-remove-nth-node-from-end-of-list-c-python-java-javascript-solution/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/remove-nth-node-from-end-of-list-leetcode-python/\\n"
                    }
                ]
            },
            {
                "id": 1575528,
                "content": [
                    {
                        "username": "what_if",
                        "content": "I see many people use two pointers, which I think is actually the same as two passes."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@chickooo](/chickooo) Your analysis isn't correct for two pointers. The first pointer moves k steps. Then **both** pointers move (n - k) steps so it's 2*(n-k) steps.\n\nTotal number of steps is k + 2*(n-k) = 2n - k which is exactly the same as the two pass approach."
                    },
                    {
                        "username": "kuelf",
                        "content": "[@chickooo](/chickooo) It is the same.\nBoth reduce to O(n).\nAlso k is meaningless."
                    },
                    {
                        "username": "chickooo",
                        "content": "For two pointers, the complexity is **O(n+k)**\\nBut for two pass it is **O(n + (n-k))**\\n\\nhere, k is nth position from end."
                    },
                    {
                        "username": "xiaoxiaoxiaoV",
                        "content": "if  we ignore the note,\"Given n will always be valid\", how we handle the situation that n is bigger than the length of the linked list?"
                    },
                    {
                        "username": "scrabbletank",
                        "content": "It says in the problem description that n is always valid, but this doesn't seem to be the case. One of the final test passes uses this test case:\\n\\n[1]\\n1\\n\\nThere isn't a 2nd element to remove, so in this case N is invalid. What's more, the expected answer is [] and not [1]."
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Initialize a `dummy` node  `(None -> head)`\\nthis will help you to cater the issue of removing `first(head)` node."
                    },
                    {
                        "username": "forresthopkinsa",
                        "content": "If you\\'re getting weird JS test failures and you don\\'t know why, here\\'s some help: this problem tests for tail nodes with `{ next: null }`.\\n\\n`{ next: undefined }` and `{}` will not work.\\n\\nThis is the first time I\\'ve seen a problem with this requirement. This expectation is undocumented and the resulting errors can be cryptic."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Thanks a lot for that! My code was getting that error and I was looking for a comment related to it. A simple if(node.next === undefined)node.next = null   did the trick."
                    },
                    {
                        "username": "MPMoka",
                        "content": "Test system is not providing right \\'n\\' to the code."
                    },
                    {
                        "username": "ronlek",
                        "content": "Here's a solution that's actually \"one-pass\".\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        vector<ListNode*> nodeList;\n        ListNode *node = head;\n\n        while(node){\n            nodeList.push_back(node);\n            node = node -> next;\n        }\n\n        int nlSize = nodeList.size();\n        if(nlSize - n == 0){\n            return head -> next;\n        }\n\n        ListNode *cur = nodeList[nlSize - n - 1];\n        cur -> next = cur -> next -> next;\n\n        return head;\n    }\n};\n```\n\nTime Complexity: `O(N)`. Each node is traversed once.\nSpace Complexity: `O(N)`. Each node is stored in the vector."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nHere are the rules...\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yawend",
                        "content": "To delete the Nth Node from end, N+1th Node from end is required.\\nhighlight:\\nhow to find the nth node from end:\\nUse two pointers, both pointers points the the head initially.\\nThen pointer1 moves nth steps first.\\nThen both 2 pointer moves together.\\nWhen pointer1 moves to the end of the linklist,\\npointer2 points to the nth node from end.\\n\\n`class Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        \\n        #find the N+1th Node from end\\n        p=self.findFromEnd(dummy,n+1)\\n        \\n        #let the N+1th Node from end next to the N-1th Node from end\\n        p.next=p.next.next\\n        return dummy.next\\n\\n    def findFromEnd(self, head, n):\\n        p1=ListNode(-1)\\n        p2=ListNode(-1)\\n        \\n        #both p1 and p2 points to head\\n        p1.next=head\\n        p2.next=head\\n        \\n        #pointer p1 moves to the Nth node first\\n        for i in range(n):\\n            p1=p1.next\\n        \\n        #move p1 and p2 at the same time, when p1 moves to the end,p2 move to the Nth Node from end\\n        while p1 != None:\\n            p2=p2.next\\n            p1=p1.next\\n        \\n        return p2`"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Faster C++ || Java Script || Java || Python \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-remove-nth-node-from-end-of-list-c-python-java-javascript-solution/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/remove-nth-node-from-end-of-list-leetcode-python/\\n"
                    }
                ]
            },
            {
                "id": 1573790,
                "content": [
                    {
                        "username": "what_if",
                        "content": "I see many people use two pointers, which I think is actually the same as two passes."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@chickooo](/chickooo) Your analysis isn't correct for two pointers. The first pointer moves k steps. Then **both** pointers move (n - k) steps so it's 2*(n-k) steps.\n\nTotal number of steps is k + 2*(n-k) = 2n - k which is exactly the same as the two pass approach."
                    },
                    {
                        "username": "kuelf",
                        "content": "[@chickooo](/chickooo) It is the same.\nBoth reduce to O(n).\nAlso k is meaningless."
                    },
                    {
                        "username": "chickooo",
                        "content": "For two pointers, the complexity is **O(n+k)**\\nBut for two pass it is **O(n + (n-k))**\\n\\nhere, k is nth position from end."
                    },
                    {
                        "username": "xiaoxiaoxiaoV",
                        "content": "if  we ignore the note,\"Given n will always be valid\", how we handle the situation that n is bigger than the length of the linked list?"
                    },
                    {
                        "username": "scrabbletank",
                        "content": "It says in the problem description that n is always valid, but this doesn't seem to be the case. One of the final test passes uses this test case:\\n\\n[1]\\n1\\n\\nThere isn't a 2nd element to remove, so in this case N is invalid. What's more, the expected answer is [] and not [1]."
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Initialize a `dummy` node  `(None -> head)`\\nthis will help you to cater the issue of removing `first(head)` node."
                    },
                    {
                        "username": "forresthopkinsa",
                        "content": "If you\\'re getting weird JS test failures and you don\\'t know why, here\\'s some help: this problem tests for tail nodes with `{ next: null }`.\\n\\n`{ next: undefined }` and `{}` will not work.\\n\\nThis is the first time I\\'ve seen a problem with this requirement. This expectation is undocumented and the resulting errors can be cryptic."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Thanks a lot for that! My code was getting that error and I was looking for a comment related to it. A simple if(node.next === undefined)node.next = null   did the trick."
                    },
                    {
                        "username": "MPMoka",
                        "content": "Test system is not providing right \\'n\\' to the code."
                    },
                    {
                        "username": "ronlek",
                        "content": "Here's a solution that's actually \"one-pass\".\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        vector<ListNode*> nodeList;\n        ListNode *node = head;\n\n        while(node){\n            nodeList.push_back(node);\n            node = node -> next;\n        }\n\n        int nlSize = nodeList.size();\n        if(nlSize - n == 0){\n            return head -> next;\n        }\n\n        ListNode *cur = nodeList[nlSize - n - 1];\n        cur -> next = cur -> next -> next;\n\n        return head;\n    }\n};\n```\n\nTime Complexity: `O(N)`. Each node is traversed once.\nSpace Complexity: `O(N)`. Each node is stored in the vector."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nHere are the rules...\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yawend",
                        "content": "To delete the Nth Node from end, N+1th Node from end is required.\\nhighlight:\\nhow to find the nth node from end:\\nUse two pointers, both pointers points the the head initially.\\nThen pointer1 moves nth steps first.\\nThen both 2 pointer moves together.\\nWhen pointer1 moves to the end of the linklist,\\npointer2 points to the nth node from end.\\n\\n`class Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        \\n        #find the N+1th Node from end\\n        p=self.findFromEnd(dummy,n+1)\\n        \\n        #let the N+1th Node from end next to the N-1th Node from end\\n        p.next=p.next.next\\n        return dummy.next\\n\\n    def findFromEnd(self, head, n):\\n        p1=ListNode(-1)\\n        p2=ListNode(-1)\\n        \\n        #both p1 and p2 points to head\\n        p1.next=head\\n        p2.next=head\\n        \\n        #pointer p1 moves to the Nth node first\\n        for i in range(n):\\n            p1=p1.next\\n        \\n        #move p1 and p2 at the same time, when p1 moves to the end,p2 move to the Nth Node from end\\n        while p1 != None:\\n            p2=p2.next\\n            p1=p1.next\\n        \\n        return p2`"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Faster C++ || Java Script || Java || Python \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-remove-nth-node-from-end-of-list-c-python-java-javascript-solution/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/remove-nth-node-from-end-of-list-leetcode-python/\\n"
                    }
                ]
            },
            {
                "id": 2031745,
                "content": [
                    {
                        "username": "what_if",
                        "content": "I see many people use two pointers, which I think is actually the same as two passes."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@chickooo](/chickooo) Your analysis isn't correct for two pointers. The first pointer moves k steps. Then **both** pointers move (n - k) steps so it's 2*(n-k) steps.\n\nTotal number of steps is k + 2*(n-k) = 2n - k which is exactly the same as the two pass approach."
                    },
                    {
                        "username": "kuelf",
                        "content": "[@chickooo](/chickooo) It is the same.\nBoth reduce to O(n).\nAlso k is meaningless."
                    },
                    {
                        "username": "chickooo",
                        "content": "For two pointers, the complexity is **O(n+k)**\\nBut for two pass it is **O(n + (n-k))**\\n\\nhere, k is nth position from end."
                    },
                    {
                        "username": "xiaoxiaoxiaoV",
                        "content": "if  we ignore the note,\"Given n will always be valid\", how we handle the situation that n is bigger than the length of the linked list?"
                    },
                    {
                        "username": "scrabbletank",
                        "content": "It says in the problem description that n is always valid, but this doesn't seem to be the case. One of the final test passes uses this test case:\\n\\n[1]\\n1\\n\\nThere isn't a 2nd element to remove, so in this case N is invalid. What's more, the expected answer is [] and not [1]."
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Initialize a `dummy` node  `(None -> head)`\\nthis will help you to cater the issue of removing `first(head)` node."
                    },
                    {
                        "username": "forresthopkinsa",
                        "content": "If you\\'re getting weird JS test failures and you don\\'t know why, here\\'s some help: this problem tests for tail nodes with `{ next: null }`.\\n\\n`{ next: undefined }` and `{}` will not work.\\n\\nThis is the first time I\\'ve seen a problem with this requirement. This expectation is undocumented and the resulting errors can be cryptic."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Thanks a lot for that! My code was getting that error and I was looking for a comment related to it. A simple if(node.next === undefined)node.next = null   did the trick."
                    },
                    {
                        "username": "MPMoka",
                        "content": "Test system is not providing right \\'n\\' to the code."
                    },
                    {
                        "username": "ronlek",
                        "content": "Here's a solution that's actually \"one-pass\".\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        vector<ListNode*> nodeList;\n        ListNode *node = head;\n\n        while(node){\n            nodeList.push_back(node);\n            node = node -> next;\n        }\n\n        int nlSize = nodeList.size();\n        if(nlSize - n == 0){\n            return head -> next;\n        }\n\n        ListNode *cur = nodeList[nlSize - n - 1];\n        cur -> next = cur -> next -> next;\n\n        return head;\n    }\n};\n```\n\nTime Complexity: `O(N)`. Each node is traversed once.\nSpace Complexity: `O(N)`. Each node is stored in the vector."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nHere are the rules...\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yawend",
                        "content": "To delete the Nth Node from end, N+1th Node from end is required.\\nhighlight:\\nhow to find the nth node from end:\\nUse two pointers, both pointers points the the head initially.\\nThen pointer1 moves nth steps first.\\nThen both 2 pointer moves together.\\nWhen pointer1 moves to the end of the linklist,\\npointer2 points to the nth node from end.\\n\\n`class Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        \\n        #find the N+1th Node from end\\n        p=self.findFromEnd(dummy,n+1)\\n        \\n        #let the N+1th Node from end next to the N-1th Node from end\\n        p.next=p.next.next\\n        return dummy.next\\n\\n    def findFromEnd(self, head, n):\\n        p1=ListNode(-1)\\n        p2=ListNode(-1)\\n        \\n        #both p1 and p2 points to head\\n        p1.next=head\\n        p2.next=head\\n        \\n        #pointer p1 moves to the Nth node first\\n        for i in range(n):\\n            p1=p1.next\\n        \\n        #move p1 and p2 at the same time, when p1 moves to the end,p2 move to the Nth Node from end\\n        while p1 != None:\\n            p2=p2.next\\n            p1=p1.next\\n        \\n        return p2`"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Faster C++ || Java Script || Java || Python \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-remove-nth-node-from-end-of-list-c-python-java-javascript-solution/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/remove-nth-node-from-end-of-list-leetcode-python/\\n"
                    }
                ]
            },
            {
                "id": 1699663,
                "content": [
                    {
                        "username": "what_if",
                        "content": "I see many people use two pointers, which I think is actually the same as two passes."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@chickooo](/chickooo) Your analysis isn't correct for two pointers. The first pointer moves k steps. Then **both** pointers move (n - k) steps so it's 2*(n-k) steps.\n\nTotal number of steps is k + 2*(n-k) = 2n - k which is exactly the same as the two pass approach."
                    },
                    {
                        "username": "kuelf",
                        "content": "[@chickooo](/chickooo) It is the same.\nBoth reduce to O(n).\nAlso k is meaningless."
                    },
                    {
                        "username": "chickooo",
                        "content": "For two pointers, the complexity is **O(n+k)**\\nBut for two pass it is **O(n + (n-k))**\\n\\nhere, k is nth position from end."
                    },
                    {
                        "username": "xiaoxiaoxiaoV",
                        "content": "if  we ignore the note,\"Given n will always be valid\", how we handle the situation that n is bigger than the length of the linked list?"
                    },
                    {
                        "username": "scrabbletank",
                        "content": "It says in the problem description that n is always valid, but this doesn't seem to be the case. One of the final test passes uses this test case:\\n\\n[1]\\n1\\n\\nThere isn't a 2nd element to remove, so in this case N is invalid. What's more, the expected answer is [] and not [1]."
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Initialize a `dummy` node  `(None -> head)`\\nthis will help you to cater the issue of removing `first(head)` node."
                    },
                    {
                        "username": "forresthopkinsa",
                        "content": "If you\\'re getting weird JS test failures and you don\\'t know why, here\\'s some help: this problem tests for tail nodes with `{ next: null }`.\\n\\n`{ next: undefined }` and `{}` will not work.\\n\\nThis is the first time I\\'ve seen a problem with this requirement. This expectation is undocumented and the resulting errors can be cryptic."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Thanks a lot for that! My code was getting that error and I was looking for a comment related to it. A simple if(node.next === undefined)node.next = null   did the trick."
                    },
                    {
                        "username": "MPMoka",
                        "content": "Test system is not providing right \\'n\\' to the code."
                    },
                    {
                        "username": "ronlek",
                        "content": "Here's a solution that's actually \"one-pass\".\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        vector<ListNode*> nodeList;\n        ListNode *node = head;\n\n        while(node){\n            nodeList.push_back(node);\n            node = node -> next;\n        }\n\n        int nlSize = nodeList.size();\n        if(nlSize - n == 0){\n            return head -> next;\n        }\n\n        ListNode *cur = nodeList[nlSize - n - 1];\n        cur -> next = cur -> next -> next;\n\n        return head;\n    }\n};\n```\n\nTime Complexity: `O(N)`. Each node is traversed once.\nSpace Complexity: `O(N)`. Each node is stored in the vector."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nHere are the rules...\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yawend",
                        "content": "To delete the Nth Node from end, N+1th Node from end is required.\\nhighlight:\\nhow to find the nth node from end:\\nUse two pointers, both pointers points the the head initially.\\nThen pointer1 moves nth steps first.\\nThen both 2 pointer moves together.\\nWhen pointer1 moves to the end of the linklist,\\npointer2 points to the nth node from end.\\n\\n`class Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        \\n        #find the N+1th Node from end\\n        p=self.findFromEnd(dummy,n+1)\\n        \\n        #let the N+1th Node from end next to the N-1th Node from end\\n        p.next=p.next.next\\n        return dummy.next\\n\\n    def findFromEnd(self, head, n):\\n        p1=ListNode(-1)\\n        p2=ListNode(-1)\\n        \\n        #both p1 and p2 points to head\\n        p1.next=head\\n        p2.next=head\\n        \\n        #pointer p1 moves to the Nth node first\\n        for i in range(n):\\n            p1=p1.next\\n        \\n        #move p1 and p2 at the same time, when p1 moves to the end,p2 move to the Nth Node from end\\n        while p1 != None:\\n            p2=p2.next\\n            p1=p1.next\\n        \\n        return p2`"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Faster C++ || Java Script || Java || Python \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-remove-nth-node-from-end-of-list-c-python-java-javascript-solution/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/remove-nth-node-from-end-of-list-leetcode-python/\\n"
                    }
                ]
            },
            {
                "id": 1576661,
                "content": [
                    {
                        "username": "what_if",
                        "content": "I see many people use two pointers, which I think is actually the same as two passes."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@chickooo](/chickooo) Your analysis isn't correct for two pointers. The first pointer moves k steps. Then **both** pointers move (n - k) steps so it's 2*(n-k) steps.\n\nTotal number of steps is k + 2*(n-k) = 2n - k which is exactly the same as the two pass approach."
                    },
                    {
                        "username": "kuelf",
                        "content": "[@chickooo](/chickooo) It is the same.\nBoth reduce to O(n).\nAlso k is meaningless."
                    },
                    {
                        "username": "chickooo",
                        "content": "For two pointers, the complexity is **O(n+k)**\\nBut for two pass it is **O(n + (n-k))**\\n\\nhere, k is nth position from end."
                    },
                    {
                        "username": "xiaoxiaoxiaoV",
                        "content": "if  we ignore the note,\"Given n will always be valid\", how we handle the situation that n is bigger than the length of the linked list?"
                    },
                    {
                        "username": "scrabbletank",
                        "content": "It says in the problem description that n is always valid, but this doesn't seem to be the case. One of the final test passes uses this test case:\\n\\n[1]\\n1\\n\\nThere isn't a 2nd element to remove, so in this case N is invalid. What's more, the expected answer is [] and not [1]."
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Initialize a `dummy` node  `(None -> head)`\\nthis will help you to cater the issue of removing `first(head)` node."
                    },
                    {
                        "username": "forresthopkinsa",
                        "content": "If you\\'re getting weird JS test failures and you don\\'t know why, here\\'s some help: this problem tests for tail nodes with `{ next: null }`.\\n\\n`{ next: undefined }` and `{}` will not work.\\n\\nThis is the first time I\\'ve seen a problem with this requirement. This expectation is undocumented and the resulting errors can be cryptic."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Thanks a lot for that! My code was getting that error and I was looking for a comment related to it. A simple if(node.next === undefined)node.next = null   did the trick."
                    },
                    {
                        "username": "MPMoka",
                        "content": "Test system is not providing right \\'n\\' to the code."
                    },
                    {
                        "username": "ronlek",
                        "content": "Here's a solution that's actually \"one-pass\".\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        vector<ListNode*> nodeList;\n        ListNode *node = head;\n\n        while(node){\n            nodeList.push_back(node);\n            node = node -> next;\n        }\n\n        int nlSize = nodeList.size();\n        if(nlSize - n == 0){\n            return head -> next;\n        }\n\n        ListNode *cur = nodeList[nlSize - n - 1];\n        cur -> next = cur -> next -> next;\n\n        return head;\n    }\n};\n```\n\nTime Complexity: `O(N)`. Each node is traversed once.\nSpace Complexity: `O(N)`. Each node is stored in the vector."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nHere are the rules...\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yawend",
                        "content": "To delete the Nth Node from end, N+1th Node from end is required.\\nhighlight:\\nhow to find the nth node from end:\\nUse two pointers, both pointers points the the head initially.\\nThen pointer1 moves nth steps first.\\nThen both 2 pointer moves together.\\nWhen pointer1 moves to the end of the linklist,\\npointer2 points to the nth node from end.\\n\\n`class Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        \\n        #find the N+1th Node from end\\n        p=self.findFromEnd(dummy,n+1)\\n        \\n        #let the N+1th Node from end next to the N-1th Node from end\\n        p.next=p.next.next\\n        return dummy.next\\n\\n    def findFromEnd(self, head, n):\\n        p1=ListNode(-1)\\n        p2=ListNode(-1)\\n        \\n        #both p1 and p2 points to head\\n        p1.next=head\\n        p2.next=head\\n        \\n        #pointer p1 moves to the Nth node first\\n        for i in range(n):\\n            p1=p1.next\\n        \\n        #move p1 and p2 at the same time, when p1 moves to the end,p2 move to the Nth Node from end\\n        while p1 != None:\\n            p2=p2.next\\n            p1=p1.next\\n        \\n        return p2`"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Faster C++ || Java Script || Java || Python \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-remove-nth-node-from-end-of-list-c-python-java-javascript-solution/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/remove-nth-node-from-end-of-list-leetcode-python/\\n"
                    }
                ]
            },
            {
                "id": 1576621,
                "content": [
                    {
                        "username": "what_if",
                        "content": "I see many people use two pointers, which I think is actually the same as two passes."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@chickooo](/chickooo) Your analysis isn't correct for two pointers. The first pointer moves k steps. Then **both** pointers move (n - k) steps so it's 2*(n-k) steps.\n\nTotal number of steps is k + 2*(n-k) = 2n - k which is exactly the same as the two pass approach."
                    },
                    {
                        "username": "kuelf",
                        "content": "[@chickooo](/chickooo) It is the same.\nBoth reduce to O(n).\nAlso k is meaningless."
                    },
                    {
                        "username": "chickooo",
                        "content": "For two pointers, the complexity is **O(n+k)**\\nBut for two pass it is **O(n + (n-k))**\\n\\nhere, k is nth position from end."
                    },
                    {
                        "username": "xiaoxiaoxiaoV",
                        "content": "if  we ignore the note,\"Given n will always be valid\", how we handle the situation that n is bigger than the length of the linked list?"
                    },
                    {
                        "username": "scrabbletank",
                        "content": "It says in the problem description that n is always valid, but this doesn't seem to be the case. One of the final test passes uses this test case:\\n\\n[1]\\n1\\n\\nThere isn't a 2nd element to remove, so in this case N is invalid. What's more, the expected answer is [] and not [1]."
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Initialize a `dummy` node  `(None -> head)`\\nthis will help you to cater the issue of removing `first(head)` node."
                    },
                    {
                        "username": "forresthopkinsa",
                        "content": "If you\\'re getting weird JS test failures and you don\\'t know why, here\\'s some help: this problem tests for tail nodes with `{ next: null }`.\\n\\n`{ next: undefined }` and `{}` will not work.\\n\\nThis is the first time I\\'ve seen a problem with this requirement. This expectation is undocumented and the resulting errors can be cryptic."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Thanks a lot for that! My code was getting that error and I was looking for a comment related to it. A simple if(node.next === undefined)node.next = null   did the trick."
                    },
                    {
                        "username": "MPMoka",
                        "content": "Test system is not providing right \\'n\\' to the code."
                    },
                    {
                        "username": "ronlek",
                        "content": "Here's a solution that's actually \"one-pass\".\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        vector<ListNode*> nodeList;\n        ListNode *node = head;\n\n        while(node){\n            nodeList.push_back(node);\n            node = node -> next;\n        }\n\n        int nlSize = nodeList.size();\n        if(nlSize - n == 0){\n            return head -> next;\n        }\n\n        ListNode *cur = nodeList[nlSize - n - 1];\n        cur -> next = cur -> next -> next;\n\n        return head;\n    }\n};\n```\n\nTime Complexity: `O(N)`. Each node is traversed once.\nSpace Complexity: `O(N)`. Each node is stored in the vector."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nHere are the rules...\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yawend",
                        "content": "To delete the Nth Node from end, N+1th Node from end is required.\\nhighlight:\\nhow to find the nth node from end:\\nUse two pointers, both pointers points the the head initially.\\nThen pointer1 moves nth steps first.\\nThen both 2 pointer moves together.\\nWhen pointer1 moves to the end of the linklist,\\npointer2 points to the nth node from end.\\n\\n`class Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        \\n        #find the N+1th Node from end\\n        p=self.findFromEnd(dummy,n+1)\\n        \\n        #let the N+1th Node from end next to the N-1th Node from end\\n        p.next=p.next.next\\n        return dummy.next\\n\\n    def findFromEnd(self, head, n):\\n        p1=ListNode(-1)\\n        p2=ListNode(-1)\\n        \\n        #both p1 and p2 points to head\\n        p1.next=head\\n        p2.next=head\\n        \\n        #pointer p1 moves to the Nth node first\\n        for i in range(n):\\n            p1=p1.next\\n        \\n        #move p1 and p2 at the same time, when p1 moves to the end,p2 move to the Nth Node from end\\n        while p1 != None:\\n            p2=p2.next\\n            p1=p1.next\\n        \\n        return p2`"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Faster C++ || Java Script || Java || Python \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-remove-nth-node-from-end-of-list-c-python-java-javascript-solution/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/remove-nth-node-from-end-of-list-leetcode-python/\\n"
                    }
                ]
            },
            {
                "id": 1572845,
                "content": [
                    {
                        "username": "burcukaptikacti",
                        "content": "I solve like this : \\n\\n![image](https://assets.leetcode.com/users/burcukaptikacti/image_1563436209.png)\\n\\n"
                    },
                    {
                        "username": "user0856Nl",
                        "content": "The test case [1, 2], n = 2 should give as output [ ] since, starting from the end, the node to be removed is out of list.\\nYour expected output is [2] but it\\'s completely wrong!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Not wrong! The counting from the end starts at 1. So if n = 1 you would remove the last element. If n = 2 you remove the second last element.\\n\\nHere, removing the second last element means remove `1` which gives an output of `[2]`."
                    },
                    {
                        "username": "acmol",
                        "content": "I think it's nonsence..\nIthink this method is not better than iterating two times."
                    },
                    {
                        "username": "ParagVarshney",
                        "content": "in this question head={1,2,3,4,5} or head=1   ????"
                    },
                    {
                        "username": "trololo999",
                        "content": "Is it cheating if use an array to store the nodes ?"
                    },
                    {
                        "username": "geoffreyn",
                        "content": "Can anyone fix this edge case?\\n\\n ```\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = head\\n        fast = head.next\\n\\n        cnt = 0\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            cnt += 1\\n\\n        while cnt > n:\\n            slow = slow.next\\n            cnt -= 1\\n\\n        if slow.next:\\n            slow.next = slow.next.next\\n        else:\\n            return head.next\\n        return head\\n```\\n\\nInput\\nhead =\\n[1,2]\\nn =\\n2\\n\\nOutput\\n[1]\\nExpected\\n[2]"
                    },
                    {
                        "username": "alanzh",
                        "content": "so i know thats not best solution but why in the case when head = [1,2] and n = 1 output is still [1,2]? When i put node.next = None it works but without it output is [1,2]\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        g = head\\n        #cnt = 0\\n        ar = []\\n        \\n        while g:\\n            ar.append(g)\\n            g = g.next\\n        \\n        \\n\\n        ar.pop(len(ar)-n)\\n        dummy = node = ListNode()\\n        for i in ar:\\n            node.next = i\\n            node = node.next\\n            #node.next = None\\n        \\n        return dummy.next"
                    },
                    {
                        "username": "vk1610",
                        "content": "I solved it by first calculating the length of LL , and simply iterated the LL from head to length-n .\\nit manages to solve Q , but my code is not efficient as it beats only 25% python users, does anyone know any other technique?"
                    },
                    {
                        "username": "lpinyi1012",
                        "content": "how is it possible to know where to stop if we are doing it in one pass without knowing where the end is?\nis there a way to know the end node like ListNode.size() without traversing the whole list?"
                    },
                    {
                        "username": "aydayka555",
                        "content": "I always find examples soo much less in leetcode, given 2 samples doesnt explain code properly, and always one of smaples are given with one which is not enough explanative!\\n"
                    }
                ]
            },
            {
                "id": 1573521,
                "content": [
                    {
                        "username": "burcukaptikacti",
                        "content": "I solve like this : \\n\\n![image](https://assets.leetcode.com/users/burcukaptikacti/image_1563436209.png)\\n\\n"
                    },
                    {
                        "username": "user0856Nl",
                        "content": "The test case [1, 2], n = 2 should give as output [ ] since, starting from the end, the node to be removed is out of list.\\nYour expected output is [2] but it\\'s completely wrong!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Not wrong! The counting from the end starts at 1. So if n = 1 you would remove the last element. If n = 2 you remove the second last element.\\n\\nHere, removing the second last element means remove `1` which gives an output of `[2]`."
                    },
                    {
                        "username": "acmol",
                        "content": "I think it's nonsence..\nIthink this method is not better than iterating two times."
                    },
                    {
                        "username": "ParagVarshney",
                        "content": "in this question head={1,2,3,4,5} or head=1   ????"
                    },
                    {
                        "username": "trololo999",
                        "content": "Is it cheating if use an array to store the nodes ?"
                    },
                    {
                        "username": "geoffreyn",
                        "content": "Can anyone fix this edge case?\\n\\n ```\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = head\\n        fast = head.next\\n\\n        cnt = 0\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            cnt += 1\\n\\n        while cnt > n:\\n            slow = slow.next\\n            cnt -= 1\\n\\n        if slow.next:\\n            slow.next = slow.next.next\\n        else:\\n            return head.next\\n        return head\\n```\\n\\nInput\\nhead =\\n[1,2]\\nn =\\n2\\n\\nOutput\\n[1]\\nExpected\\n[2]"
                    },
                    {
                        "username": "alanzh",
                        "content": "so i know thats not best solution but why in the case when head = [1,2] and n = 1 output is still [1,2]? When i put node.next = None it works but without it output is [1,2]\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        g = head\\n        #cnt = 0\\n        ar = []\\n        \\n        while g:\\n            ar.append(g)\\n            g = g.next\\n        \\n        \\n\\n        ar.pop(len(ar)-n)\\n        dummy = node = ListNode()\\n        for i in ar:\\n            node.next = i\\n            node = node.next\\n            #node.next = None\\n        \\n        return dummy.next"
                    },
                    {
                        "username": "vk1610",
                        "content": "I solved it by first calculating the length of LL , and simply iterated the LL from head to length-n .\\nit manages to solve Q , but my code is not efficient as it beats only 25% python users, does anyone know any other technique?"
                    },
                    {
                        "username": "lpinyi1012",
                        "content": "how is it possible to know where to stop if we are doing it in one pass without knowing where the end is?\nis there a way to know the end node like ListNode.size() without traversing the whole list?"
                    },
                    {
                        "username": "aydayka555",
                        "content": "I always find examples soo much less in leetcode, given 2 samples doesnt explain code properly, and always one of smaples are given with one which is not enough explanative!\\n"
                    }
                ]
            },
            {
                "id": 1569186,
                "content": [
                    {
                        "username": "burcukaptikacti",
                        "content": "I solve like this : \\n\\n![image](https://assets.leetcode.com/users/burcukaptikacti/image_1563436209.png)\\n\\n"
                    },
                    {
                        "username": "user0856Nl",
                        "content": "The test case [1, 2], n = 2 should give as output [ ] since, starting from the end, the node to be removed is out of list.\\nYour expected output is [2] but it\\'s completely wrong!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Not wrong! The counting from the end starts at 1. So if n = 1 you would remove the last element. If n = 2 you remove the second last element.\\n\\nHere, removing the second last element means remove `1` which gives an output of `[2]`."
                    },
                    {
                        "username": "acmol",
                        "content": "I think it's nonsence..\nIthink this method is not better than iterating two times."
                    },
                    {
                        "username": "ParagVarshney",
                        "content": "in this question head={1,2,3,4,5} or head=1   ????"
                    },
                    {
                        "username": "trololo999",
                        "content": "Is it cheating if use an array to store the nodes ?"
                    },
                    {
                        "username": "geoffreyn",
                        "content": "Can anyone fix this edge case?\\n\\n ```\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = head\\n        fast = head.next\\n\\n        cnt = 0\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            cnt += 1\\n\\n        while cnt > n:\\n            slow = slow.next\\n            cnt -= 1\\n\\n        if slow.next:\\n            slow.next = slow.next.next\\n        else:\\n            return head.next\\n        return head\\n```\\n\\nInput\\nhead =\\n[1,2]\\nn =\\n2\\n\\nOutput\\n[1]\\nExpected\\n[2]"
                    },
                    {
                        "username": "alanzh",
                        "content": "so i know thats not best solution but why in the case when head = [1,2] and n = 1 output is still [1,2]? When i put node.next = None it works but without it output is [1,2]\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        g = head\\n        #cnt = 0\\n        ar = []\\n        \\n        while g:\\n            ar.append(g)\\n            g = g.next\\n        \\n        \\n\\n        ar.pop(len(ar)-n)\\n        dummy = node = ListNode()\\n        for i in ar:\\n            node.next = i\\n            node = node.next\\n            #node.next = None\\n        \\n        return dummy.next"
                    },
                    {
                        "username": "vk1610",
                        "content": "I solved it by first calculating the length of LL , and simply iterated the LL from head to length-n .\\nit manages to solve Q , but my code is not efficient as it beats only 25% python users, does anyone know any other technique?"
                    },
                    {
                        "username": "lpinyi1012",
                        "content": "how is it possible to know where to stop if we are doing it in one pass without knowing where the end is?\nis there a way to know the end node like ListNode.size() without traversing the whole list?"
                    },
                    {
                        "username": "aydayka555",
                        "content": "I always find examples soo much less in leetcode, given 2 samples doesnt explain code properly, and always one of smaples are given with one which is not enough explanative!\\n"
                    }
                ]
            },
            {
                "id": 2074292,
                "content": [
                    {
                        "username": "burcukaptikacti",
                        "content": "I solve like this : \\n\\n![image](https://assets.leetcode.com/users/burcukaptikacti/image_1563436209.png)\\n\\n"
                    },
                    {
                        "username": "user0856Nl",
                        "content": "The test case [1, 2], n = 2 should give as output [ ] since, starting from the end, the node to be removed is out of list.\\nYour expected output is [2] but it\\'s completely wrong!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Not wrong! The counting from the end starts at 1. So if n = 1 you would remove the last element. If n = 2 you remove the second last element.\\n\\nHere, removing the second last element means remove `1` which gives an output of `[2]`."
                    },
                    {
                        "username": "acmol",
                        "content": "I think it's nonsence..\nIthink this method is not better than iterating two times."
                    },
                    {
                        "username": "ParagVarshney",
                        "content": "in this question head={1,2,3,4,5} or head=1   ????"
                    },
                    {
                        "username": "trololo999",
                        "content": "Is it cheating if use an array to store the nodes ?"
                    },
                    {
                        "username": "geoffreyn",
                        "content": "Can anyone fix this edge case?\\n\\n ```\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = head\\n        fast = head.next\\n\\n        cnt = 0\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            cnt += 1\\n\\n        while cnt > n:\\n            slow = slow.next\\n            cnt -= 1\\n\\n        if slow.next:\\n            slow.next = slow.next.next\\n        else:\\n            return head.next\\n        return head\\n```\\n\\nInput\\nhead =\\n[1,2]\\nn =\\n2\\n\\nOutput\\n[1]\\nExpected\\n[2]"
                    },
                    {
                        "username": "alanzh",
                        "content": "so i know thats not best solution but why in the case when head = [1,2] and n = 1 output is still [1,2]? When i put node.next = None it works but without it output is [1,2]\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        g = head\\n        #cnt = 0\\n        ar = []\\n        \\n        while g:\\n            ar.append(g)\\n            g = g.next\\n        \\n        \\n\\n        ar.pop(len(ar)-n)\\n        dummy = node = ListNode()\\n        for i in ar:\\n            node.next = i\\n            node = node.next\\n            #node.next = None\\n        \\n        return dummy.next"
                    },
                    {
                        "username": "vk1610",
                        "content": "I solved it by first calculating the length of LL , and simply iterated the LL from head to length-n .\\nit manages to solve Q , but my code is not efficient as it beats only 25% python users, does anyone know any other technique?"
                    },
                    {
                        "username": "lpinyi1012",
                        "content": "how is it possible to know where to stop if we are doing it in one pass without knowing where the end is?\nis there a way to know the end node like ListNode.size() without traversing the whole list?"
                    },
                    {
                        "username": "aydayka555",
                        "content": "I always find examples soo much less in leetcode, given 2 samples doesnt explain code properly, and always one of smaples are given with one which is not enough explanative!\\n"
                    }
                ]
            },
            {
                "id": 2069230,
                "content": [
                    {
                        "username": "burcukaptikacti",
                        "content": "I solve like this : \\n\\n![image](https://assets.leetcode.com/users/burcukaptikacti/image_1563436209.png)\\n\\n"
                    },
                    {
                        "username": "user0856Nl",
                        "content": "The test case [1, 2], n = 2 should give as output [ ] since, starting from the end, the node to be removed is out of list.\\nYour expected output is [2] but it\\'s completely wrong!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Not wrong! The counting from the end starts at 1. So if n = 1 you would remove the last element. If n = 2 you remove the second last element.\\n\\nHere, removing the second last element means remove `1` which gives an output of `[2]`."
                    },
                    {
                        "username": "acmol",
                        "content": "I think it's nonsence..\nIthink this method is not better than iterating two times."
                    },
                    {
                        "username": "ParagVarshney",
                        "content": "in this question head={1,2,3,4,5} or head=1   ????"
                    },
                    {
                        "username": "trololo999",
                        "content": "Is it cheating if use an array to store the nodes ?"
                    },
                    {
                        "username": "geoffreyn",
                        "content": "Can anyone fix this edge case?\\n\\n ```\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = head\\n        fast = head.next\\n\\n        cnt = 0\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            cnt += 1\\n\\n        while cnt > n:\\n            slow = slow.next\\n            cnt -= 1\\n\\n        if slow.next:\\n            slow.next = slow.next.next\\n        else:\\n            return head.next\\n        return head\\n```\\n\\nInput\\nhead =\\n[1,2]\\nn =\\n2\\n\\nOutput\\n[1]\\nExpected\\n[2]"
                    },
                    {
                        "username": "alanzh",
                        "content": "so i know thats not best solution but why in the case when head = [1,2] and n = 1 output is still [1,2]? When i put node.next = None it works but without it output is [1,2]\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        g = head\\n        #cnt = 0\\n        ar = []\\n        \\n        while g:\\n            ar.append(g)\\n            g = g.next\\n        \\n        \\n\\n        ar.pop(len(ar)-n)\\n        dummy = node = ListNode()\\n        for i in ar:\\n            node.next = i\\n            node = node.next\\n            #node.next = None\\n        \\n        return dummy.next"
                    },
                    {
                        "username": "vk1610",
                        "content": "I solved it by first calculating the length of LL , and simply iterated the LL from head to length-n .\\nit manages to solve Q , but my code is not efficient as it beats only 25% python users, does anyone know any other technique?"
                    },
                    {
                        "username": "lpinyi1012",
                        "content": "how is it possible to know where to stop if we are doing it in one pass without knowing where the end is?\nis there a way to know the end node like ListNode.size() without traversing the whole list?"
                    },
                    {
                        "username": "aydayka555",
                        "content": "I always find examples soo much less in leetcode, given 2 samples doesnt explain code properly, and always one of smaples are given with one which is not enough explanative!\\n"
                    }
                ]
            },
            {
                "id": 2068894,
                "content": [
                    {
                        "username": "burcukaptikacti",
                        "content": "I solve like this : \\n\\n![image](https://assets.leetcode.com/users/burcukaptikacti/image_1563436209.png)\\n\\n"
                    },
                    {
                        "username": "user0856Nl",
                        "content": "The test case [1, 2], n = 2 should give as output [ ] since, starting from the end, the node to be removed is out of list.\\nYour expected output is [2] but it\\'s completely wrong!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Not wrong! The counting from the end starts at 1. So if n = 1 you would remove the last element. If n = 2 you remove the second last element.\\n\\nHere, removing the second last element means remove `1` which gives an output of `[2]`."
                    },
                    {
                        "username": "acmol",
                        "content": "I think it's nonsence..\nIthink this method is not better than iterating two times."
                    },
                    {
                        "username": "ParagVarshney",
                        "content": "in this question head={1,2,3,4,5} or head=1   ????"
                    },
                    {
                        "username": "trololo999",
                        "content": "Is it cheating if use an array to store the nodes ?"
                    },
                    {
                        "username": "geoffreyn",
                        "content": "Can anyone fix this edge case?\\n\\n ```\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = head\\n        fast = head.next\\n\\n        cnt = 0\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            cnt += 1\\n\\n        while cnt > n:\\n            slow = slow.next\\n            cnt -= 1\\n\\n        if slow.next:\\n            slow.next = slow.next.next\\n        else:\\n            return head.next\\n        return head\\n```\\n\\nInput\\nhead =\\n[1,2]\\nn =\\n2\\n\\nOutput\\n[1]\\nExpected\\n[2]"
                    },
                    {
                        "username": "alanzh",
                        "content": "so i know thats not best solution but why in the case when head = [1,2] and n = 1 output is still [1,2]? When i put node.next = None it works but without it output is [1,2]\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        g = head\\n        #cnt = 0\\n        ar = []\\n        \\n        while g:\\n            ar.append(g)\\n            g = g.next\\n        \\n        \\n\\n        ar.pop(len(ar)-n)\\n        dummy = node = ListNode()\\n        for i in ar:\\n            node.next = i\\n            node = node.next\\n            #node.next = None\\n        \\n        return dummy.next"
                    },
                    {
                        "username": "vk1610",
                        "content": "I solved it by first calculating the length of LL , and simply iterated the LL from head to length-n .\\nit manages to solve Q , but my code is not efficient as it beats only 25% python users, does anyone know any other technique?"
                    },
                    {
                        "username": "lpinyi1012",
                        "content": "how is it possible to know where to stop if we are doing it in one pass without knowing where the end is?\nis there a way to know the end node like ListNode.size() without traversing the whole list?"
                    },
                    {
                        "username": "aydayka555",
                        "content": "I always find examples soo much less in leetcode, given 2 samples doesnt explain code properly, and always one of smaples are given with one which is not enough explanative!\\n"
                    }
                ]
            },
            {
                "id": 2067748,
                "content": [
                    {
                        "username": "burcukaptikacti",
                        "content": "I solve like this : \\n\\n![image](https://assets.leetcode.com/users/burcukaptikacti/image_1563436209.png)\\n\\n"
                    },
                    {
                        "username": "user0856Nl",
                        "content": "The test case [1, 2], n = 2 should give as output [ ] since, starting from the end, the node to be removed is out of list.\\nYour expected output is [2] but it\\'s completely wrong!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Not wrong! The counting from the end starts at 1. So if n = 1 you would remove the last element. If n = 2 you remove the second last element.\\n\\nHere, removing the second last element means remove `1` which gives an output of `[2]`."
                    },
                    {
                        "username": "acmol",
                        "content": "I think it's nonsence..\nIthink this method is not better than iterating two times."
                    },
                    {
                        "username": "ParagVarshney",
                        "content": "in this question head={1,2,3,4,5} or head=1   ????"
                    },
                    {
                        "username": "trololo999",
                        "content": "Is it cheating if use an array to store the nodes ?"
                    },
                    {
                        "username": "geoffreyn",
                        "content": "Can anyone fix this edge case?\\n\\n ```\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = head\\n        fast = head.next\\n\\n        cnt = 0\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            cnt += 1\\n\\n        while cnt > n:\\n            slow = slow.next\\n            cnt -= 1\\n\\n        if slow.next:\\n            slow.next = slow.next.next\\n        else:\\n            return head.next\\n        return head\\n```\\n\\nInput\\nhead =\\n[1,2]\\nn =\\n2\\n\\nOutput\\n[1]\\nExpected\\n[2]"
                    },
                    {
                        "username": "alanzh",
                        "content": "so i know thats not best solution but why in the case when head = [1,2] and n = 1 output is still [1,2]? When i put node.next = None it works but without it output is [1,2]\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        g = head\\n        #cnt = 0\\n        ar = []\\n        \\n        while g:\\n            ar.append(g)\\n            g = g.next\\n        \\n        \\n\\n        ar.pop(len(ar)-n)\\n        dummy = node = ListNode()\\n        for i in ar:\\n            node.next = i\\n            node = node.next\\n            #node.next = None\\n        \\n        return dummy.next"
                    },
                    {
                        "username": "vk1610",
                        "content": "I solved it by first calculating the length of LL , and simply iterated the LL from head to length-n .\\nit manages to solve Q , but my code is not efficient as it beats only 25% python users, does anyone know any other technique?"
                    },
                    {
                        "username": "lpinyi1012",
                        "content": "how is it possible to know where to stop if we are doing it in one pass without knowing where the end is?\nis there a way to know the end node like ListNode.size() without traversing the whole list?"
                    },
                    {
                        "username": "aydayka555",
                        "content": "I always find examples soo much less in leetcode, given 2 samples doesnt explain code properly, and always one of smaples are given with one which is not enough explanative!\\n"
                    }
                ]
            },
            {
                "id": 2064136,
                "content": [
                    {
                        "username": "burcukaptikacti",
                        "content": "I solve like this : \\n\\n![image](https://assets.leetcode.com/users/burcukaptikacti/image_1563436209.png)\\n\\n"
                    },
                    {
                        "username": "user0856Nl",
                        "content": "The test case [1, 2], n = 2 should give as output [ ] since, starting from the end, the node to be removed is out of list.\\nYour expected output is [2] but it\\'s completely wrong!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Not wrong! The counting from the end starts at 1. So if n = 1 you would remove the last element. If n = 2 you remove the second last element.\\n\\nHere, removing the second last element means remove `1` which gives an output of `[2]`."
                    },
                    {
                        "username": "acmol",
                        "content": "I think it's nonsence..\nIthink this method is not better than iterating two times."
                    },
                    {
                        "username": "ParagVarshney",
                        "content": "in this question head={1,2,3,4,5} or head=1   ????"
                    },
                    {
                        "username": "trololo999",
                        "content": "Is it cheating if use an array to store the nodes ?"
                    },
                    {
                        "username": "geoffreyn",
                        "content": "Can anyone fix this edge case?\\n\\n ```\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = head\\n        fast = head.next\\n\\n        cnt = 0\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            cnt += 1\\n\\n        while cnt > n:\\n            slow = slow.next\\n            cnt -= 1\\n\\n        if slow.next:\\n            slow.next = slow.next.next\\n        else:\\n            return head.next\\n        return head\\n```\\n\\nInput\\nhead =\\n[1,2]\\nn =\\n2\\n\\nOutput\\n[1]\\nExpected\\n[2]"
                    },
                    {
                        "username": "alanzh",
                        "content": "so i know thats not best solution but why in the case when head = [1,2] and n = 1 output is still [1,2]? When i put node.next = None it works but without it output is [1,2]\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        g = head\\n        #cnt = 0\\n        ar = []\\n        \\n        while g:\\n            ar.append(g)\\n            g = g.next\\n        \\n        \\n\\n        ar.pop(len(ar)-n)\\n        dummy = node = ListNode()\\n        for i in ar:\\n            node.next = i\\n            node = node.next\\n            #node.next = None\\n        \\n        return dummy.next"
                    },
                    {
                        "username": "vk1610",
                        "content": "I solved it by first calculating the length of LL , and simply iterated the LL from head to length-n .\\nit manages to solve Q , but my code is not efficient as it beats only 25% python users, does anyone know any other technique?"
                    },
                    {
                        "username": "lpinyi1012",
                        "content": "how is it possible to know where to stop if we are doing it in one pass without knowing where the end is?\nis there a way to know the end node like ListNode.size() without traversing the whole list?"
                    },
                    {
                        "username": "aydayka555",
                        "content": "I always find examples soo much less in leetcode, given 2 samples doesnt explain code properly, and always one of smaples are given with one which is not enough explanative!\\n"
                    }
                ]
            },
            {
                "id": 2049900,
                "content": [
                    {
                        "username": "burcukaptikacti",
                        "content": "I solve like this : \\n\\n![image](https://assets.leetcode.com/users/burcukaptikacti/image_1563436209.png)\\n\\n"
                    },
                    {
                        "username": "user0856Nl",
                        "content": "The test case [1, 2], n = 2 should give as output [ ] since, starting from the end, the node to be removed is out of list.\\nYour expected output is [2] but it\\'s completely wrong!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Not wrong! The counting from the end starts at 1. So if n = 1 you would remove the last element. If n = 2 you remove the second last element.\\n\\nHere, removing the second last element means remove `1` which gives an output of `[2]`."
                    },
                    {
                        "username": "acmol",
                        "content": "I think it's nonsence..\nIthink this method is not better than iterating two times."
                    },
                    {
                        "username": "ParagVarshney",
                        "content": "in this question head={1,2,3,4,5} or head=1   ????"
                    },
                    {
                        "username": "trololo999",
                        "content": "Is it cheating if use an array to store the nodes ?"
                    },
                    {
                        "username": "geoffreyn",
                        "content": "Can anyone fix this edge case?\\n\\n ```\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = head\\n        fast = head.next\\n\\n        cnt = 0\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            cnt += 1\\n\\n        while cnt > n:\\n            slow = slow.next\\n            cnt -= 1\\n\\n        if slow.next:\\n            slow.next = slow.next.next\\n        else:\\n            return head.next\\n        return head\\n```\\n\\nInput\\nhead =\\n[1,2]\\nn =\\n2\\n\\nOutput\\n[1]\\nExpected\\n[2]"
                    },
                    {
                        "username": "alanzh",
                        "content": "so i know thats not best solution but why in the case when head = [1,2] and n = 1 output is still [1,2]? When i put node.next = None it works but without it output is [1,2]\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        g = head\\n        #cnt = 0\\n        ar = []\\n        \\n        while g:\\n            ar.append(g)\\n            g = g.next\\n        \\n        \\n\\n        ar.pop(len(ar)-n)\\n        dummy = node = ListNode()\\n        for i in ar:\\n            node.next = i\\n            node = node.next\\n            #node.next = None\\n        \\n        return dummy.next"
                    },
                    {
                        "username": "vk1610",
                        "content": "I solved it by first calculating the length of LL , and simply iterated the LL from head to length-n .\\nit manages to solve Q , but my code is not efficient as it beats only 25% python users, does anyone know any other technique?"
                    },
                    {
                        "username": "lpinyi1012",
                        "content": "how is it possible to know where to stop if we are doing it in one pass without knowing where the end is?\nis there a way to know the end node like ListNode.size() without traversing the whole list?"
                    },
                    {
                        "username": "aydayka555",
                        "content": "I always find examples soo much less in leetcode, given 2 samples doesnt explain code properly, and always one of smaples are given with one which is not enough explanative!\\n"
                    }
                ]
            },
            {
                "id": 2045973,
                "content": [
                    {
                        "username": "burcukaptikacti",
                        "content": "I solve like this : \\n\\n![image](https://assets.leetcode.com/users/burcukaptikacti/image_1563436209.png)\\n\\n"
                    },
                    {
                        "username": "user0856Nl",
                        "content": "The test case [1, 2], n = 2 should give as output [ ] since, starting from the end, the node to be removed is out of list.\\nYour expected output is [2] but it\\'s completely wrong!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Not wrong! The counting from the end starts at 1. So if n = 1 you would remove the last element. If n = 2 you remove the second last element.\\n\\nHere, removing the second last element means remove `1` which gives an output of `[2]`."
                    },
                    {
                        "username": "acmol",
                        "content": "I think it's nonsence..\nIthink this method is not better than iterating two times."
                    },
                    {
                        "username": "ParagVarshney",
                        "content": "in this question head={1,2,3,4,5} or head=1   ????"
                    },
                    {
                        "username": "trololo999",
                        "content": "Is it cheating if use an array to store the nodes ?"
                    },
                    {
                        "username": "geoffreyn",
                        "content": "Can anyone fix this edge case?\\n\\n ```\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = head\\n        fast = head.next\\n\\n        cnt = 0\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            cnt += 1\\n\\n        while cnt > n:\\n            slow = slow.next\\n            cnt -= 1\\n\\n        if slow.next:\\n            slow.next = slow.next.next\\n        else:\\n            return head.next\\n        return head\\n```\\n\\nInput\\nhead =\\n[1,2]\\nn =\\n2\\n\\nOutput\\n[1]\\nExpected\\n[2]"
                    },
                    {
                        "username": "alanzh",
                        "content": "so i know thats not best solution but why in the case when head = [1,2] and n = 1 output is still [1,2]? When i put node.next = None it works but without it output is [1,2]\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        g = head\\n        #cnt = 0\\n        ar = []\\n        \\n        while g:\\n            ar.append(g)\\n            g = g.next\\n        \\n        \\n\\n        ar.pop(len(ar)-n)\\n        dummy = node = ListNode()\\n        for i in ar:\\n            node.next = i\\n            node = node.next\\n            #node.next = None\\n        \\n        return dummy.next"
                    },
                    {
                        "username": "vk1610",
                        "content": "I solved it by first calculating the length of LL , and simply iterated the LL from head to length-n .\\nit manages to solve Q , but my code is not efficient as it beats only 25% python users, does anyone know any other technique?"
                    },
                    {
                        "username": "lpinyi1012",
                        "content": "how is it possible to know where to stop if we are doing it in one pass without knowing where the end is?\nis there a way to know the end node like ListNode.size() without traversing the whole list?"
                    },
                    {
                        "username": "aydayka555",
                        "content": "I always find examples soo much less in leetcode, given 2 samples doesnt explain code properly, and always one of smaples are given with one which is not enough explanative!\\n"
                    }
                ]
            },
            {
                "id": 2038012,
                "content": [
                    {
                        "username": "HarshSaini07",
                        "content": "Line 24: Char 20: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:20\\n\\nhow i solve this type of error "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "700 problems solved sweet"
                    },
                    {
                        "username": "arpit_055",
                        "content": "I guess since this solution has been accepted.....there has to be some reason, if it doesn\\'t work for [1,2] case then the solution would not have been accepted...It is the correct solution... pls check again\\n"
                    },
                    {
                        "username": "user7140ci",
                        "content": "The provided ListNode class can\\'t give answer from Example 2: the primitive int val can\\'t be null, so the result will be [0].    "
                    },
                    {
                        "username": "Ashik543",
                        "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\n\n\n\n\n\n\n\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n   \n     newNode=ListNode(0)\n    newNode=fast\n    newNode=slow\n    count=1\n    while fast != None:\n           fast=fast.next\n           count=count+1\n        \n           for i in range(0,count-n):\n               slow=slow.next\n               slow.next=slow.next.next\n        \n            return fast.next\n\nI still find errors ,what's the reason? Please do let me know."
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "I could be reading it wrong and you may have already corrected it, but you create a newNode and then assign fast and slow to it with no previous declaration of fast and slow. Do you mean to assign newNode to fast and slow? Try doing that. That should hopefully fix the error you are getting. Other than that, you are on the right track to get the solution. "
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "Tip using two pointers and overthinking this question is waste of time. All you need to do is to connect correct nodes with each other. How to do it? Store nodes in arraylist"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "good question , the two pointer approach is not the only solution, i will recommend not go with brute force O(n^2)"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "I was of the impression the 2 pointer approach is O(n), am I incorrect? I would like to learn of a better solution than 2 pointer"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "Using 2 pointers (fast, slow) keeps the code simple\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Is there any way to solve this problem using only one loop ? I had an interview and was asked to solve this problem using only one loop ,any suggestions?"
                    },
                    {
                        "username": "kldpsh77",
                        "content": "by using dictionary (map) you can map index number with node and modify the element before the element we have to remove by node.next to node.next.next\\nSee below solution\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/3857386/simple-python-solution-using-single-loop/"
                    },
                    {
                        "username": "kaushikbor2018",
                        "content": "I came out with the solution with the following process:\\n1. check whether the head is null. if it is then return it then and there.\\n2. count the size of the linked list.\\n3. declare a variable \\'diff\\' storing the difference between n and the size of the linked list.\\n\" here diff represents the no. nodes we need to pass through from head to get to the next element we want to delete \"\\n4. if diff = 0, then first element is to be deleted. if diff=1, then second element is to be deleted. similarly if diff = k, then k+1th is to be deleted.\\n\\n"
                    }
                ]
            },
            {
                "id": 2033169,
                "content": [
                    {
                        "username": "HarshSaini07",
                        "content": "Line 24: Char 20: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:20\\n\\nhow i solve this type of error "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "700 problems solved sweet"
                    },
                    {
                        "username": "arpit_055",
                        "content": "I guess since this solution has been accepted.....there has to be some reason, if it doesn\\'t work for [1,2] case then the solution would not have been accepted...It is the correct solution... pls check again\\n"
                    },
                    {
                        "username": "user7140ci",
                        "content": "The provided ListNode class can\\'t give answer from Example 2: the primitive int val can\\'t be null, so the result will be [0].    "
                    },
                    {
                        "username": "Ashik543",
                        "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\n\n\n\n\n\n\n\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n   \n     newNode=ListNode(0)\n    newNode=fast\n    newNode=slow\n    count=1\n    while fast != None:\n           fast=fast.next\n           count=count+1\n        \n           for i in range(0,count-n):\n               slow=slow.next\n               slow.next=slow.next.next\n        \n            return fast.next\n\nI still find errors ,what's the reason? Please do let me know."
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "I could be reading it wrong and you may have already corrected it, but you create a newNode and then assign fast and slow to it with no previous declaration of fast and slow. Do you mean to assign newNode to fast and slow? Try doing that. That should hopefully fix the error you are getting. Other than that, you are on the right track to get the solution. "
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "Tip using two pointers and overthinking this question is waste of time. All you need to do is to connect correct nodes with each other. How to do it? Store nodes in arraylist"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "good question , the two pointer approach is not the only solution, i will recommend not go with brute force O(n^2)"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "I was of the impression the 2 pointer approach is O(n), am I incorrect? I would like to learn of a better solution than 2 pointer"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "Using 2 pointers (fast, slow) keeps the code simple\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Is there any way to solve this problem using only one loop ? I had an interview and was asked to solve this problem using only one loop ,any suggestions?"
                    },
                    {
                        "username": "kldpsh77",
                        "content": "by using dictionary (map) you can map index number with node and modify the element before the element we have to remove by node.next to node.next.next\\nSee below solution\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/3857386/simple-python-solution-using-single-loop/"
                    },
                    {
                        "username": "kaushikbor2018",
                        "content": "I came out with the solution with the following process:\\n1. check whether the head is null. if it is then return it then and there.\\n2. count the size of the linked list.\\n3. declare a variable \\'diff\\' storing the difference between n and the size of the linked list.\\n\" here diff represents the no. nodes we need to pass through from head to get to the next element we want to delete \"\\n4. if diff = 0, then first element is to be deleted. if diff=1, then second element is to be deleted. similarly if diff = k, then k+1th is to be deleted.\\n\\n"
                    }
                ]
            },
            {
                "id": 2023084,
                "content": [
                    {
                        "username": "HarshSaini07",
                        "content": "Line 24: Char 20: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:20\\n\\nhow i solve this type of error "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "700 problems solved sweet"
                    },
                    {
                        "username": "arpit_055",
                        "content": "I guess since this solution has been accepted.....there has to be some reason, if it doesn\\'t work for [1,2] case then the solution would not have been accepted...It is the correct solution... pls check again\\n"
                    },
                    {
                        "username": "user7140ci",
                        "content": "The provided ListNode class can\\'t give answer from Example 2: the primitive int val can\\'t be null, so the result will be [0].    "
                    },
                    {
                        "username": "Ashik543",
                        "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\n\n\n\n\n\n\n\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n   \n     newNode=ListNode(0)\n    newNode=fast\n    newNode=slow\n    count=1\n    while fast != None:\n           fast=fast.next\n           count=count+1\n        \n           for i in range(0,count-n):\n               slow=slow.next\n               slow.next=slow.next.next\n        \n            return fast.next\n\nI still find errors ,what's the reason? Please do let me know."
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "I could be reading it wrong and you may have already corrected it, but you create a newNode and then assign fast and slow to it with no previous declaration of fast and slow. Do you mean to assign newNode to fast and slow? Try doing that. That should hopefully fix the error you are getting. Other than that, you are on the right track to get the solution. "
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "Tip using two pointers and overthinking this question is waste of time. All you need to do is to connect correct nodes with each other. How to do it? Store nodes in arraylist"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "good question , the two pointer approach is not the only solution, i will recommend not go with brute force O(n^2)"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "I was of the impression the 2 pointer approach is O(n), am I incorrect? I would like to learn of a better solution than 2 pointer"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "Using 2 pointers (fast, slow) keeps the code simple\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Is there any way to solve this problem using only one loop ? I had an interview and was asked to solve this problem using only one loop ,any suggestions?"
                    },
                    {
                        "username": "kldpsh77",
                        "content": "by using dictionary (map) you can map index number with node and modify the element before the element we have to remove by node.next to node.next.next\\nSee below solution\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/3857386/simple-python-solution-using-single-loop/"
                    },
                    {
                        "username": "kaushikbor2018",
                        "content": "I came out with the solution with the following process:\\n1. check whether the head is null. if it is then return it then and there.\\n2. count the size of the linked list.\\n3. declare a variable \\'diff\\' storing the difference between n and the size of the linked list.\\n\" here diff represents the no. nodes we need to pass through from head to get to the next element we want to delete \"\\n4. if diff = 0, then first element is to be deleted. if diff=1, then second element is to be deleted. similarly if diff = k, then k+1th is to be deleted.\\n\\n"
                    }
                ]
            },
            {
                "id": 2021460,
                "content": [
                    {
                        "username": "HarshSaini07",
                        "content": "Line 24: Char 20: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:20\\n\\nhow i solve this type of error "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "700 problems solved sweet"
                    },
                    {
                        "username": "arpit_055",
                        "content": "I guess since this solution has been accepted.....there has to be some reason, if it doesn\\'t work for [1,2] case then the solution would not have been accepted...It is the correct solution... pls check again\\n"
                    },
                    {
                        "username": "user7140ci",
                        "content": "The provided ListNode class can\\'t give answer from Example 2: the primitive int val can\\'t be null, so the result will be [0].    "
                    },
                    {
                        "username": "Ashik543",
                        "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\n\n\n\n\n\n\n\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n   \n     newNode=ListNode(0)\n    newNode=fast\n    newNode=slow\n    count=1\n    while fast != None:\n           fast=fast.next\n           count=count+1\n        \n           for i in range(0,count-n):\n               slow=slow.next\n               slow.next=slow.next.next\n        \n            return fast.next\n\nI still find errors ,what's the reason? Please do let me know."
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "I could be reading it wrong and you may have already corrected it, but you create a newNode and then assign fast and slow to it with no previous declaration of fast and slow. Do you mean to assign newNode to fast and slow? Try doing that. That should hopefully fix the error you are getting. Other than that, you are on the right track to get the solution. "
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "Tip using two pointers and overthinking this question is waste of time. All you need to do is to connect correct nodes with each other. How to do it? Store nodes in arraylist"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "good question , the two pointer approach is not the only solution, i will recommend not go with brute force O(n^2)"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "I was of the impression the 2 pointer approach is O(n), am I incorrect? I would like to learn of a better solution than 2 pointer"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "Using 2 pointers (fast, slow) keeps the code simple\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Is there any way to solve this problem using only one loop ? I had an interview and was asked to solve this problem using only one loop ,any suggestions?"
                    },
                    {
                        "username": "kldpsh77",
                        "content": "by using dictionary (map) you can map index number with node and modify the element before the element we have to remove by node.next to node.next.next\\nSee below solution\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/3857386/simple-python-solution-using-single-loop/"
                    },
                    {
                        "username": "kaushikbor2018",
                        "content": "I came out with the solution with the following process:\\n1. check whether the head is null. if it is then return it then and there.\\n2. count the size of the linked list.\\n3. declare a variable \\'diff\\' storing the difference between n and the size of the linked list.\\n\" here diff represents the no. nodes we need to pass through from head to get to the next element we want to delete \"\\n4. if diff = 0, then first element is to be deleted. if diff=1, then second element is to be deleted. similarly if diff = k, then k+1th is to be deleted.\\n\\n"
                    }
                ]
            },
            {
                "id": 2021264,
                "content": [
                    {
                        "username": "HarshSaini07",
                        "content": "Line 24: Char 20: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:20\\n\\nhow i solve this type of error "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "700 problems solved sweet"
                    },
                    {
                        "username": "arpit_055",
                        "content": "I guess since this solution has been accepted.....there has to be some reason, if it doesn\\'t work for [1,2] case then the solution would not have been accepted...It is the correct solution... pls check again\\n"
                    },
                    {
                        "username": "user7140ci",
                        "content": "The provided ListNode class can\\'t give answer from Example 2: the primitive int val can\\'t be null, so the result will be [0].    "
                    },
                    {
                        "username": "Ashik543",
                        "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\n\n\n\n\n\n\n\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n   \n     newNode=ListNode(0)\n    newNode=fast\n    newNode=slow\n    count=1\n    while fast != None:\n           fast=fast.next\n           count=count+1\n        \n           for i in range(0,count-n):\n               slow=slow.next\n               slow.next=slow.next.next\n        \n            return fast.next\n\nI still find errors ,what's the reason? Please do let me know."
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "I could be reading it wrong and you may have already corrected it, but you create a newNode and then assign fast and slow to it with no previous declaration of fast and slow. Do you mean to assign newNode to fast and slow? Try doing that. That should hopefully fix the error you are getting. Other than that, you are on the right track to get the solution. "
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "Tip using two pointers and overthinking this question is waste of time. All you need to do is to connect correct nodes with each other. How to do it? Store nodes in arraylist"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "good question , the two pointer approach is not the only solution, i will recommend not go with brute force O(n^2)"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "I was of the impression the 2 pointer approach is O(n), am I incorrect? I would like to learn of a better solution than 2 pointer"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "Using 2 pointers (fast, slow) keeps the code simple\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Is there any way to solve this problem using only one loop ? I had an interview and was asked to solve this problem using only one loop ,any suggestions?"
                    },
                    {
                        "username": "kldpsh77",
                        "content": "by using dictionary (map) you can map index number with node and modify the element before the element we have to remove by node.next to node.next.next\\nSee below solution\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/3857386/simple-python-solution-using-single-loop/"
                    },
                    {
                        "username": "kaushikbor2018",
                        "content": "I came out with the solution with the following process:\\n1. check whether the head is null. if it is then return it then and there.\\n2. count the size of the linked list.\\n3. declare a variable \\'diff\\' storing the difference between n and the size of the linked list.\\n\" here diff represents the no. nodes we need to pass through from head to get to the next element we want to delete \"\\n4. if diff = 0, then first element is to be deleted. if diff=1, then second element is to be deleted. similarly if diff = k, then k+1th is to be deleted.\\n\\n"
                    }
                ]
            },
            {
                "id": 2018477,
                "content": [
                    {
                        "username": "HarshSaini07",
                        "content": "Line 24: Char 20: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:20\\n\\nhow i solve this type of error "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "700 problems solved sweet"
                    },
                    {
                        "username": "arpit_055",
                        "content": "I guess since this solution has been accepted.....there has to be some reason, if it doesn\\'t work for [1,2] case then the solution would not have been accepted...It is the correct solution... pls check again\\n"
                    },
                    {
                        "username": "user7140ci",
                        "content": "The provided ListNode class can\\'t give answer from Example 2: the primitive int val can\\'t be null, so the result will be [0].    "
                    },
                    {
                        "username": "Ashik543",
                        "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\n\n\n\n\n\n\n\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n   \n     newNode=ListNode(0)\n    newNode=fast\n    newNode=slow\n    count=1\n    while fast != None:\n           fast=fast.next\n           count=count+1\n        \n           for i in range(0,count-n):\n               slow=slow.next\n               slow.next=slow.next.next\n        \n            return fast.next\n\nI still find errors ,what's the reason? Please do let me know."
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "I could be reading it wrong and you may have already corrected it, but you create a newNode and then assign fast and slow to it with no previous declaration of fast and slow. Do you mean to assign newNode to fast and slow? Try doing that. That should hopefully fix the error you are getting. Other than that, you are on the right track to get the solution. "
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "Tip using two pointers and overthinking this question is waste of time. All you need to do is to connect correct nodes with each other. How to do it? Store nodes in arraylist"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "good question , the two pointer approach is not the only solution, i will recommend not go with brute force O(n^2)"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "I was of the impression the 2 pointer approach is O(n), am I incorrect? I would like to learn of a better solution than 2 pointer"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "Using 2 pointers (fast, slow) keeps the code simple\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Is there any way to solve this problem using only one loop ? I had an interview and was asked to solve this problem using only one loop ,any suggestions?"
                    },
                    {
                        "username": "kldpsh77",
                        "content": "by using dictionary (map) you can map index number with node and modify the element before the element we have to remove by node.next to node.next.next\\nSee below solution\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/3857386/simple-python-solution-using-single-loop/"
                    },
                    {
                        "username": "kaushikbor2018",
                        "content": "I came out with the solution with the following process:\\n1. check whether the head is null. if it is then return it then and there.\\n2. count the size of the linked list.\\n3. declare a variable \\'diff\\' storing the difference between n and the size of the linked list.\\n\" here diff represents the no. nodes we need to pass through from head to get to the next element we want to delete \"\\n4. if diff = 0, then first element is to be deleted. if diff=1, then second element is to be deleted. similarly if diff = k, then k+1th is to be deleted.\\n\\n"
                    }
                ]
            },
            {
                "id": 2010908,
                "content": [
                    {
                        "username": "HarshSaini07",
                        "content": "Line 24: Char 20: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:20\\n\\nhow i solve this type of error "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "700 problems solved sweet"
                    },
                    {
                        "username": "arpit_055",
                        "content": "I guess since this solution has been accepted.....there has to be some reason, if it doesn\\'t work for [1,2] case then the solution would not have been accepted...It is the correct solution... pls check again\\n"
                    },
                    {
                        "username": "user7140ci",
                        "content": "The provided ListNode class can\\'t give answer from Example 2: the primitive int val can\\'t be null, so the result will be [0].    "
                    },
                    {
                        "username": "Ashik543",
                        "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\n\n\n\n\n\n\n\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n   \n     newNode=ListNode(0)\n    newNode=fast\n    newNode=slow\n    count=1\n    while fast != None:\n           fast=fast.next\n           count=count+1\n        \n           for i in range(0,count-n):\n               slow=slow.next\n               slow.next=slow.next.next\n        \n            return fast.next\n\nI still find errors ,what's the reason? Please do let me know."
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "I could be reading it wrong and you may have already corrected it, but you create a newNode and then assign fast and slow to it with no previous declaration of fast and slow. Do you mean to assign newNode to fast and slow? Try doing that. That should hopefully fix the error you are getting. Other than that, you are on the right track to get the solution. "
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "Tip using two pointers and overthinking this question is waste of time. All you need to do is to connect correct nodes with each other. How to do it? Store nodes in arraylist"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "good question , the two pointer approach is not the only solution, i will recommend not go with brute force O(n^2)"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "I was of the impression the 2 pointer approach is O(n), am I incorrect? I would like to learn of a better solution than 2 pointer"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "Using 2 pointers (fast, slow) keeps the code simple\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Is there any way to solve this problem using only one loop ? I had an interview and was asked to solve this problem using only one loop ,any suggestions?"
                    },
                    {
                        "username": "kldpsh77",
                        "content": "by using dictionary (map) you can map index number with node and modify the element before the element we have to remove by node.next to node.next.next\\nSee below solution\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/3857386/simple-python-solution-using-single-loop/"
                    },
                    {
                        "username": "kaushikbor2018",
                        "content": "I came out with the solution with the following process:\\n1. check whether the head is null. if it is then return it then and there.\\n2. count the size of the linked list.\\n3. declare a variable \\'diff\\' storing the difference between n and the size of the linked list.\\n\" here diff represents the no. nodes we need to pass through from head to get to the next element we want to delete \"\\n4. if diff = 0, then first element is to be deleted. if diff=1, then second element is to be deleted. similarly if diff = k, then k+1th is to be deleted.\\n\\n"
                    }
                ]
            },
            {
                "id": 2005098,
                "content": [
                    {
                        "username": "HarshSaini07",
                        "content": "Line 24: Char 20: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:20\\n\\nhow i solve this type of error "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "700 problems solved sweet"
                    },
                    {
                        "username": "arpit_055",
                        "content": "I guess since this solution has been accepted.....there has to be some reason, if it doesn\\'t work for [1,2] case then the solution would not have been accepted...It is the correct solution... pls check again\\n"
                    },
                    {
                        "username": "user7140ci",
                        "content": "The provided ListNode class can\\'t give answer from Example 2: the primitive int val can\\'t be null, so the result will be [0].    "
                    },
                    {
                        "username": "Ashik543",
                        "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\n\n\n\n\n\n\n\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n   \n     newNode=ListNode(0)\n    newNode=fast\n    newNode=slow\n    count=1\n    while fast != None:\n           fast=fast.next\n           count=count+1\n        \n           for i in range(0,count-n):\n               slow=slow.next\n               slow.next=slow.next.next\n        \n            return fast.next\n\nI still find errors ,what's the reason? Please do let me know."
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "I could be reading it wrong and you may have already corrected it, but you create a newNode and then assign fast and slow to it with no previous declaration of fast and slow. Do you mean to assign newNode to fast and slow? Try doing that. That should hopefully fix the error you are getting. Other than that, you are on the right track to get the solution. "
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "Tip using two pointers and overthinking this question is waste of time. All you need to do is to connect correct nodes with each other. How to do it? Store nodes in arraylist"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "good question , the two pointer approach is not the only solution, i will recommend not go with brute force O(n^2)"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "I was of the impression the 2 pointer approach is O(n), am I incorrect? I would like to learn of a better solution than 2 pointer"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "Using 2 pointers (fast, slow) keeps the code simple\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Is there any way to solve this problem using only one loop ? I had an interview and was asked to solve this problem using only one loop ,any suggestions?"
                    },
                    {
                        "username": "kldpsh77",
                        "content": "by using dictionary (map) you can map index number with node and modify the element before the element we have to remove by node.next to node.next.next\\nSee below solution\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/3857386/simple-python-solution-using-single-loop/"
                    },
                    {
                        "username": "kaushikbor2018",
                        "content": "I came out with the solution with the following process:\\n1. check whether the head is null. if it is then return it then and there.\\n2. count the size of the linked list.\\n3. declare a variable \\'diff\\' storing the difference between n and the size of the linked list.\\n\" here diff represents the no. nodes we need to pass through from head to get to the next element we want to delete \"\\n4. if diff = 0, then first element is to be deleted. if diff=1, then second element is to be deleted. similarly if diff = k, then k+1th is to be deleted.\\n\\n"
                    }
                ]
            },
            {
                "id": 1989947,
                "content": [
                    {
                        "username": "HarshSaini07",
                        "content": "Line 24: Char 20: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:20\\n\\nhow i solve this type of error "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "700 problems solved sweet"
                    },
                    {
                        "username": "arpit_055",
                        "content": "I guess since this solution has been accepted.....there has to be some reason, if it doesn\\'t work for [1,2] case then the solution would not have been accepted...It is the correct solution... pls check again\\n"
                    },
                    {
                        "username": "user7140ci",
                        "content": "The provided ListNode class can\\'t give answer from Example 2: the primitive int val can\\'t be null, so the result will be [0].    "
                    },
                    {
                        "username": "Ashik543",
                        "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\n\n\n\n\n\n\n\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n   \n     newNode=ListNode(0)\n    newNode=fast\n    newNode=slow\n    count=1\n    while fast != None:\n           fast=fast.next\n           count=count+1\n        \n           for i in range(0,count-n):\n               slow=slow.next\n               slow.next=slow.next.next\n        \n            return fast.next\n\nI still find errors ,what's the reason? Please do let me know."
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "I could be reading it wrong and you may have already corrected it, but you create a newNode and then assign fast and slow to it with no previous declaration of fast and slow. Do you mean to assign newNode to fast and slow? Try doing that. That should hopefully fix the error you are getting. Other than that, you are on the right track to get the solution. "
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "Tip using two pointers and overthinking this question is waste of time. All you need to do is to connect correct nodes with each other. How to do it? Store nodes in arraylist"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "good question , the two pointer approach is not the only solution, i will recommend not go with brute force O(n^2)"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "I was of the impression the 2 pointer approach is O(n), am I incorrect? I would like to learn of a better solution than 2 pointer"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "Using 2 pointers (fast, slow) keeps the code simple\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Is there any way to solve this problem using only one loop ? I had an interview and was asked to solve this problem using only one loop ,any suggestions?"
                    },
                    {
                        "username": "kldpsh77",
                        "content": "by using dictionary (map) you can map index number with node and modify the element before the element we have to remove by node.next to node.next.next\\nSee below solution\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/3857386/simple-python-solution-using-single-loop/"
                    },
                    {
                        "username": "kaushikbor2018",
                        "content": "I came out with the solution with the following process:\\n1. check whether the head is null. if it is then return it then and there.\\n2. count the size of the linked list.\\n3. declare a variable \\'diff\\' storing the difference between n and the size of the linked list.\\n\" here diff represents the no. nodes we need to pass through from head to get to the next element we want to delete \"\\n4. if diff = 0, then first element is to be deleted. if diff=1, then second element is to be deleted. similarly if diff = k, then k+1th is to be deleted.\\n\\n"
                    }
                ]
            },
            {
                "id": 1981274,
                "content": [
                    {
                        "username": "HarshSaini07",
                        "content": "Line 24: Char 20: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:20\\n\\nhow i solve this type of error "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "700 problems solved sweet"
                    },
                    {
                        "username": "arpit_055",
                        "content": "I guess since this solution has been accepted.....there has to be some reason, if it doesn\\'t work for [1,2] case then the solution would not have been accepted...It is the correct solution... pls check again\\n"
                    },
                    {
                        "username": "user7140ci",
                        "content": "The provided ListNode class can\\'t give answer from Example 2: the primitive int val can\\'t be null, so the result will be [0].    "
                    },
                    {
                        "username": "Ashik543",
                        "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\n\n\n\n\n\n\n\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n   \n     newNode=ListNode(0)\n    newNode=fast\n    newNode=slow\n    count=1\n    while fast != None:\n           fast=fast.next\n           count=count+1\n        \n           for i in range(0,count-n):\n               slow=slow.next\n               slow.next=slow.next.next\n        \n            return fast.next\n\nI still find errors ,what's the reason? Please do let me know."
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "I could be reading it wrong and you may have already corrected it, but you create a newNode and then assign fast and slow to it with no previous declaration of fast and slow. Do you mean to assign newNode to fast and slow? Try doing that. That should hopefully fix the error you are getting. Other than that, you are on the right track to get the solution. "
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "Tip using two pointers and overthinking this question is waste of time. All you need to do is to connect correct nodes with each other. How to do it? Store nodes in arraylist"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "good question , the two pointer approach is not the only solution, i will recommend not go with brute force O(n^2)"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "I was of the impression the 2 pointer approach is O(n), am I incorrect? I would like to learn of a better solution than 2 pointer"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "Using 2 pointers (fast, slow) keeps the code simple\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Is there any way to solve this problem using only one loop ? I had an interview and was asked to solve this problem using only one loop ,any suggestions?"
                    },
                    {
                        "username": "kldpsh77",
                        "content": "by using dictionary (map) you can map index number with node and modify the element before the element we have to remove by node.next to node.next.next\\nSee below solution\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/3857386/simple-python-solution-using-single-loop/"
                    },
                    {
                        "username": "kaushikbor2018",
                        "content": "I came out with the solution with the following process:\\n1. check whether the head is null. if it is then return it then and there.\\n2. count the size of the linked list.\\n3. declare a variable \\'diff\\' storing the difference between n and the size of the linked list.\\n\" here diff represents the no. nodes we need to pass through from head to get to the next element we want to delete \"\\n4. if diff = 0, then first element is to be deleted. if diff=1, then second element is to be deleted. similarly if diff = k, then k+1th is to be deleted.\\n\\n"
                    }
                ]
            },
            {
                "id": 1947920,
                "content": [
                    {
                        "username": "zmn17",
                        "content": "head =\\n[1,2]\\nn =\\n2\\nUse Testcase\\nOutput\\n[1]\\nExpected\\n[2]\\n\\ncan someone explain this test case?? n =2 so the 2nd node from the end which is 1?? isnt it?? "
                    },
                    {
                        "username": "Afroz_shah",
                        "content": "you need to put one condition \\nwhere num=number of the node which can be get through traversal\\nand n=position from back\\nif(num-n<0){\\n            return head->next;\\n        }"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Start by adding an extra node in the beginning"
                    },
                    {
                        "username": "vivekkt",
                        "content": "I used the two pointer solution. But for some reason, the second test case in Run fails. The same test case works on my local machine as a unit test though!!!\nTest Case : \n `head = [1], n = 1`\n\nSolution:\n ```\nfunc RemoveNthFromEnd(head *ListNode, n int) *ListNode {\n\tif head == nil || n == 0 || head.Next == nil {\n\t\treturn head\n\t}\n\tdummy := &ListNode{Val: -1, Next: head}\n\tfirst, second := dummy, dummy\n\tfor i := 1; i <= n+1; i++ {\n\t\tfirst = first.Next\n\t}\n\tfor first != nil {\n\t\tfirst = first.Next\n\t\tsecond = second.Next\n\t}\n\tsecond.Next = second.Next.Next\n\treturn dummy.Next\n}\n```\n\nThe following unit test passes on my local for the above solution:\n ```\nfunc TestRemoveNthFromEnd(t *testing.T) {\n\t// GIVEN\n\thead := &ListNode{\n\t\tVal:  -1,\n\t\tNext: nil,\n\t}\n\tnode := &ListNode{\n\t\tVal:  1,\n\t\tNext: nil,\n\t}\n\thead.Next = node\n\n\t// WHEN\n\tn := RemoveNthFromEnd(head, 1)\n\n\t// THEN\n\tassert.Equal(t, (*ListNode)(nil), n.Next)\n}\n\n```\n\nWhy does this test case fail on leet code? "
                    },
                    {
                        "username": "user4346Sy",
                        "content": "100% beat\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (head == NULL)\\n                return NULL; // List does not have n nodes\\n            \\n            head = head->next;\\n        }\\n        \\n        while (head != NULL) {\\n            if (prev == NULL)\\n                prev = curr;\\n            else\\n                prev = prev->next;\\n            \\n            head = head->next;\\n        }\\n        \\n        if (prev == NULL)\\n            return curr->next; // Remove the head node\\n        else\\n            prev->next = prev->next->next; // Remove the nth node\\n        \\n        return curr;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% beat rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xenojohn",
                        "content": "Leetcode seems to be broken at this question.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\n        element_number = 0\\n\\n        head_copy = head\\n\\n        while head:\\n            element_number += 1\\n            head = head.next\\n        \\n        head = head_copy\\n        \\n        how_far = element_number - n\\n        prev_node= None\\n        print(how_far)\\n\\n        while head:\\n            print(\"how_far: \", how_far)\\n            if how_far == 0:\\n                print(\"We\\'re in if, we are breaking after this..\")\\n                print(head.val, prev_node, head, head.next)\\n                prev_node.next = head.next\\n                break\\n                print(\"We\\'re printing after break..\")\\n\\n            prev_node = head\\n            head = head.next\\n            how_far -= 1\\n\\n        return head_copy\\n```\\n\\nit seems to just purely ignore the break (i\\'ve tried with return but it still doesn\\'t return, but continue looping). This is a weird behaviour. Did anyone else also find this?\\n\\nDebug;\\n\\n3\\nhow_far:  3\\nhow_far:  2\\nhow_far:  1\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n4 ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}} ListNode{val: 4, next: ListNode{val: 5, next: None}} ListNode{val: 5, next: None}\\n0\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n1 None ListNode{val: 1, next: None} None"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I don\\'t understand what exactly happen. It seems that \\'break\\' behaves like \\'continue\\'. The text after \\'break\\' is missing.\\nYou use while loop. Why use head? I suggest that you use \\'how_far\\' instead, like that:\\nwhile how_far:\\nor\\nwhile how_far != 0:\\nWe are that we reach the node in how_far position before head.\\n"
                    },
                    {
                        "username": "Shashank1524",
                        "content": "ListNode temp = head;\n        ListNode tempN = head;\n        int length = 0;\n        while(temp!=null) {\n            temp = temp.next;\n            length++;\n        }\n        temp = head;\n        for(int i = 0; i<length-n-1; i++) {\n            temp = temp.next;\n        }`\n        tempN = temp.next;\n        System.out.print(tempN.next); \n\ncan anyone please help me with this code? \nSo the issue is, I don't understand why the NullPointerException is thrown at Sysout even though the console shows the expected output, what am I doing worng?(please ignore the complexity of the code) "
                    },
                    {
                        "username": "zelyony",
                        "content": "IMO test2 and test3 contradict each other\\ntest2: n=1 and 0th node removed. (node0 is removed, node1 is absent)\\ntest3: n=1 and 1st node removed. (node0 is left, node1 is removed)\\nso for same n=1 different order nodes are removed.\\nwtf?"
                    },
                    {
                        "username": "Vish_sp",
                        "content": "Hi ,in c# int is not nullable then how can i return a empty List i am getting error at test case [1]  out put [] can any one help here..?"
                    },
                    {
                        "username": "kaninaba94",
                        "content": "It is misleading that head is specified as type list in the description, but in the function argument it\\'s type ListNode."
                    },
                    {
                        "username": "shashwat1319",
                        "content": "how to access element in linklist?"
                    }
                ]
            },
            {
                "id": 1941870,
                "content": [
                    {
                        "username": "zmn17",
                        "content": "head =\\n[1,2]\\nn =\\n2\\nUse Testcase\\nOutput\\n[1]\\nExpected\\n[2]\\n\\ncan someone explain this test case?? n =2 so the 2nd node from the end which is 1?? isnt it?? "
                    },
                    {
                        "username": "Afroz_shah",
                        "content": "you need to put one condition \\nwhere num=number of the node which can be get through traversal\\nand n=position from back\\nif(num-n<0){\\n            return head->next;\\n        }"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Start by adding an extra node in the beginning"
                    },
                    {
                        "username": "vivekkt",
                        "content": "I used the two pointer solution. But for some reason, the second test case in Run fails. The same test case works on my local machine as a unit test though!!!\nTest Case : \n `head = [1], n = 1`\n\nSolution:\n ```\nfunc RemoveNthFromEnd(head *ListNode, n int) *ListNode {\n\tif head == nil || n == 0 || head.Next == nil {\n\t\treturn head\n\t}\n\tdummy := &ListNode{Val: -1, Next: head}\n\tfirst, second := dummy, dummy\n\tfor i := 1; i <= n+1; i++ {\n\t\tfirst = first.Next\n\t}\n\tfor first != nil {\n\t\tfirst = first.Next\n\t\tsecond = second.Next\n\t}\n\tsecond.Next = second.Next.Next\n\treturn dummy.Next\n}\n```\n\nThe following unit test passes on my local for the above solution:\n ```\nfunc TestRemoveNthFromEnd(t *testing.T) {\n\t// GIVEN\n\thead := &ListNode{\n\t\tVal:  -1,\n\t\tNext: nil,\n\t}\n\tnode := &ListNode{\n\t\tVal:  1,\n\t\tNext: nil,\n\t}\n\thead.Next = node\n\n\t// WHEN\n\tn := RemoveNthFromEnd(head, 1)\n\n\t// THEN\n\tassert.Equal(t, (*ListNode)(nil), n.Next)\n}\n\n```\n\nWhy does this test case fail on leet code? "
                    },
                    {
                        "username": "user4346Sy",
                        "content": "100% beat\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (head == NULL)\\n                return NULL; // List does not have n nodes\\n            \\n            head = head->next;\\n        }\\n        \\n        while (head != NULL) {\\n            if (prev == NULL)\\n                prev = curr;\\n            else\\n                prev = prev->next;\\n            \\n            head = head->next;\\n        }\\n        \\n        if (prev == NULL)\\n            return curr->next; // Remove the head node\\n        else\\n            prev->next = prev->next->next; // Remove the nth node\\n        \\n        return curr;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% beat rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xenojohn",
                        "content": "Leetcode seems to be broken at this question.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\n        element_number = 0\\n\\n        head_copy = head\\n\\n        while head:\\n            element_number += 1\\n            head = head.next\\n        \\n        head = head_copy\\n        \\n        how_far = element_number - n\\n        prev_node= None\\n        print(how_far)\\n\\n        while head:\\n            print(\"how_far: \", how_far)\\n            if how_far == 0:\\n                print(\"We\\'re in if, we are breaking after this..\")\\n                print(head.val, prev_node, head, head.next)\\n                prev_node.next = head.next\\n                break\\n                print(\"We\\'re printing after break..\")\\n\\n            prev_node = head\\n            head = head.next\\n            how_far -= 1\\n\\n        return head_copy\\n```\\n\\nit seems to just purely ignore the break (i\\'ve tried with return but it still doesn\\'t return, but continue looping). This is a weird behaviour. Did anyone else also find this?\\n\\nDebug;\\n\\n3\\nhow_far:  3\\nhow_far:  2\\nhow_far:  1\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n4 ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}} ListNode{val: 4, next: ListNode{val: 5, next: None}} ListNode{val: 5, next: None}\\n0\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n1 None ListNode{val: 1, next: None} None"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I don\\'t understand what exactly happen. It seems that \\'break\\' behaves like \\'continue\\'. The text after \\'break\\' is missing.\\nYou use while loop. Why use head? I suggest that you use \\'how_far\\' instead, like that:\\nwhile how_far:\\nor\\nwhile how_far != 0:\\nWe are that we reach the node in how_far position before head.\\n"
                    },
                    {
                        "username": "Shashank1524",
                        "content": "ListNode temp = head;\n        ListNode tempN = head;\n        int length = 0;\n        while(temp!=null) {\n            temp = temp.next;\n            length++;\n        }\n        temp = head;\n        for(int i = 0; i<length-n-1; i++) {\n            temp = temp.next;\n        }`\n        tempN = temp.next;\n        System.out.print(tempN.next); \n\ncan anyone please help me with this code? \nSo the issue is, I don't understand why the NullPointerException is thrown at Sysout even though the console shows the expected output, what am I doing worng?(please ignore the complexity of the code) "
                    },
                    {
                        "username": "zelyony",
                        "content": "IMO test2 and test3 contradict each other\\ntest2: n=1 and 0th node removed. (node0 is removed, node1 is absent)\\ntest3: n=1 and 1st node removed. (node0 is left, node1 is removed)\\nso for same n=1 different order nodes are removed.\\nwtf?"
                    },
                    {
                        "username": "Vish_sp",
                        "content": "Hi ,in c# int is not nullable then how can i return a empty List i am getting error at test case [1]  out put [] can any one help here..?"
                    },
                    {
                        "username": "kaninaba94",
                        "content": "It is misleading that head is specified as type list in the description, but in the function argument it\\'s type ListNode."
                    },
                    {
                        "username": "shashwat1319",
                        "content": "how to access element in linklist?"
                    }
                ]
            },
            {
                "id": 1928350,
                "content": [
                    {
                        "username": "zmn17",
                        "content": "head =\\n[1,2]\\nn =\\n2\\nUse Testcase\\nOutput\\n[1]\\nExpected\\n[2]\\n\\ncan someone explain this test case?? n =2 so the 2nd node from the end which is 1?? isnt it?? "
                    },
                    {
                        "username": "Afroz_shah",
                        "content": "you need to put one condition \\nwhere num=number of the node which can be get through traversal\\nand n=position from back\\nif(num-n<0){\\n            return head->next;\\n        }"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Start by adding an extra node in the beginning"
                    },
                    {
                        "username": "vivekkt",
                        "content": "I used the two pointer solution. But for some reason, the second test case in Run fails. The same test case works on my local machine as a unit test though!!!\nTest Case : \n `head = [1], n = 1`\n\nSolution:\n ```\nfunc RemoveNthFromEnd(head *ListNode, n int) *ListNode {\n\tif head == nil || n == 0 || head.Next == nil {\n\t\treturn head\n\t}\n\tdummy := &ListNode{Val: -1, Next: head}\n\tfirst, second := dummy, dummy\n\tfor i := 1; i <= n+1; i++ {\n\t\tfirst = first.Next\n\t}\n\tfor first != nil {\n\t\tfirst = first.Next\n\t\tsecond = second.Next\n\t}\n\tsecond.Next = second.Next.Next\n\treturn dummy.Next\n}\n```\n\nThe following unit test passes on my local for the above solution:\n ```\nfunc TestRemoveNthFromEnd(t *testing.T) {\n\t// GIVEN\n\thead := &ListNode{\n\t\tVal:  -1,\n\t\tNext: nil,\n\t}\n\tnode := &ListNode{\n\t\tVal:  1,\n\t\tNext: nil,\n\t}\n\thead.Next = node\n\n\t// WHEN\n\tn := RemoveNthFromEnd(head, 1)\n\n\t// THEN\n\tassert.Equal(t, (*ListNode)(nil), n.Next)\n}\n\n```\n\nWhy does this test case fail on leet code? "
                    },
                    {
                        "username": "user4346Sy",
                        "content": "100% beat\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (head == NULL)\\n                return NULL; // List does not have n nodes\\n            \\n            head = head->next;\\n        }\\n        \\n        while (head != NULL) {\\n            if (prev == NULL)\\n                prev = curr;\\n            else\\n                prev = prev->next;\\n            \\n            head = head->next;\\n        }\\n        \\n        if (prev == NULL)\\n            return curr->next; // Remove the head node\\n        else\\n            prev->next = prev->next->next; // Remove the nth node\\n        \\n        return curr;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% beat rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xenojohn",
                        "content": "Leetcode seems to be broken at this question.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\n        element_number = 0\\n\\n        head_copy = head\\n\\n        while head:\\n            element_number += 1\\n            head = head.next\\n        \\n        head = head_copy\\n        \\n        how_far = element_number - n\\n        prev_node= None\\n        print(how_far)\\n\\n        while head:\\n            print(\"how_far: \", how_far)\\n            if how_far == 0:\\n                print(\"We\\'re in if, we are breaking after this..\")\\n                print(head.val, prev_node, head, head.next)\\n                prev_node.next = head.next\\n                break\\n                print(\"We\\'re printing after break..\")\\n\\n            prev_node = head\\n            head = head.next\\n            how_far -= 1\\n\\n        return head_copy\\n```\\n\\nit seems to just purely ignore the break (i\\'ve tried with return but it still doesn\\'t return, but continue looping). This is a weird behaviour. Did anyone else also find this?\\n\\nDebug;\\n\\n3\\nhow_far:  3\\nhow_far:  2\\nhow_far:  1\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n4 ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}} ListNode{val: 4, next: ListNode{val: 5, next: None}} ListNode{val: 5, next: None}\\n0\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n1 None ListNode{val: 1, next: None} None"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I don\\'t understand what exactly happen. It seems that \\'break\\' behaves like \\'continue\\'. The text after \\'break\\' is missing.\\nYou use while loop. Why use head? I suggest that you use \\'how_far\\' instead, like that:\\nwhile how_far:\\nor\\nwhile how_far != 0:\\nWe are that we reach the node in how_far position before head.\\n"
                    },
                    {
                        "username": "Shashank1524",
                        "content": "ListNode temp = head;\n        ListNode tempN = head;\n        int length = 0;\n        while(temp!=null) {\n            temp = temp.next;\n            length++;\n        }\n        temp = head;\n        for(int i = 0; i<length-n-1; i++) {\n            temp = temp.next;\n        }`\n        tempN = temp.next;\n        System.out.print(tempN.next); \n\ncan anyone please help me with this code? \nSo the issue is, I don't understand why the NullPointerException is thrown at Sysout even though the console shows the expected output, what am I doing worng?(please ignore the complexity of the code) "
                    },
                    {
                        "username": "zelyony",
                        "content": "IMO test2 and test3 contradict each other\\ntest2: n=1 and 0th node removed. (node0 is removed, node1 is absent)\\ntest3: n=1 and 1st node removed. (node0 is left, node1 is removed)\\nso for same n=1 different order nodes are removed.\\nwtf?"
                    },
                    {
                        "username": "Vish_sp",
                        "content": "Hi ,in c# int is not nullable then how can i return a empty List i am getting error at test case [1]  out put [] can any one help here..?"
                    },
                    {
                        "username": "kaninaba94",
                        "content": "It is misleading that head is specified as type list in the description, but in the function argument it\\'s type ListNode."
                    },
                    {
                        "username": "shashwat1319",
                        "content": "how to access element in linklist?"
                    }
                ]
            },
            {
                "id": 1927944,
                "content": [
                    {
                        "username": "zmn17",
                        "content": "head =\\n[1,2]\\nn =\\n2\\nUse Testcase\\nOutput\\n[1]\\nExpected\\n[2]\\n\\ncan someone explain this test case?? n =2 so the 2nd node from the end which is 1?? isnt it?? "
                    },
                    {
                        "username": "Afroz_shah",
                        "content": "you need to put one condition \\nwhere num=number of the node which can be get through traversal\\nand n=position from back\\nif(num-n<0){\\n            return head->next;\\n        }"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Start by adding an extra node in the beginning"
                    },
                    {
                        "username": "vivekkt",
                        "content": "I used the two pointer solution. But for some reason, the second test case in Run fails. The same test case works on my local machine as a unit test though!!!\nTest Case : \n `head = [1], n = 1`\n\nSolution:\n ```\nfunc RemoveNthFromEnd(head *ListNode, n int) *ListNode {\n\tif head == nil || n == 0 || head.Next == nil {\n\t\treturn head\n\t}\n\tdummy := &ListNode{Val: -1, Next: head}\n\tfirst, second := dummy, dummy\n\tfor i := 1; i <= n+1; i++ {\n\t\tfirst = first.Next\n\t}\n\tfor first != nil {\n\t\tfirst = first.Next\n\t\tsecond = second.Next\n\t}\n\tsecond.Next = second.Next.Next\n\treturn dummy.Next\n}\n```\n\nThe following unit test passes on my local for the above solution:\n ```\nfunc TestRemoveNthFromEnd(t *testing.T) {\n\t// GIVEN\n\thead := &ListNode{\n\t\tVal:  -1,\n\t\tNext: nil,\n\t}\n\tnode := &ListNode{\n\t\tVal:  1,\n\t\tNext: nil,\n\t}\n\thead.Next = node\n\n\t// WHEN\n\tn := RemoveNthFromEnd(head, 1)\n\n\t// THEN\n\tassert.Equal(t, (*ListNode)(nil), n.Next)\n}\n\n```\n\nWhy does this test case fail on leet code? "
                    },
                    {
                        "username": "user4346Sy",
                        "content": "100% beat\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (head == NULL)\\n                return NULL; // List does not have n nodes\\n            \\n            head = head->next;\\n        }\\n        \\n        while (head != NULL) {\\n            if (prev == NULL)\\n                prev = curr;\\n            else\\n                prev = prev->next;\\n            \\n            head = head->next;\\n        }\\n        \\n        if (prev == NULL)\\n            return curr->next; // Remove the head node\\n        else\\n            prev->next = prev->next->next; // Remove the nth node\\n        \\n        return curr;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% beat rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xenojohn",
                        "content": "Leetcode seems to be broken at this question.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\n        element_number = 0\\n\\n        head_copy = head\\n\\n        while head:\\n            element_number += 1\\n            head = head.next\\n        \\n        head = head_copy\\n        \\n        how_far = element_number - n\\n        prev_node= None\\n        print(how_far)\\n\\n        while head:\\n            print(\"how_far: \", how_far)\\n            if how_far == 0:\\n                print(\"We\\'re in if, we are breaking after this..\")\\n                print(head.val, prev_node, head, head.next)\\n                prev_node.next = head.next\\n                break\\n                print(\"We\\'re printing after break..\")\\n\\n            prev_node = head\\n            head = head.next\\n            how_far -= 1\\n\\n        return head_copy\\n```\\n\\nit seems to just purely ignore the break (i\\'ve tried with return but it still doesn\\'t return, but continue looping). This is a weird behaviour. Did anyone else also find this?\\n\\nDebug;\\n\\n3\\nhow_far:  3\\nhow_far:  2\\nhow_far:  1\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n4 ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}} ListNode{val: 4, next: ListNode{val: 5, next: None}} ListNode{val: 5, next: None}\\n0\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n1 None ListNode{val: 1, next: None} None"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I don\\'t understand what exactly happen. It seems that \\'break\\' behaves like \\'continue\\'. The text after \\'break\\' is missing.\\nYou use while loop. Why use head? I suggest that you use \\'how_far\\' instead, like that:\\nwhile how_far:\\nor\\nwhile how_far != 0:\\nWe are that we reach the node in how_far position before head.\\n"
                    },
                    {
                        "username": "Shashank1524",
                        "content": "ListNode temp = head;\n        ListNode tempN = head;\n        int length = 0;\n        while(temp!=null) {\n            temp = temp.next;\n            length++;\n        }\n        temp = head;\n        for(int i = 0; i<length-n-1; i++) {\n            temp = temp.next;\n        }`\n        tempN = temp.next;\n        System.out.print(tempN.next); \n\ncan anyone please help me with this code? \nSo the issue is, I don't understand why the NullPointerException is thrown at Sysout even though the console shows the expected output, what am I doing worng?(please ignore the complexity of the code) "
                    },
                    {
                        "username": "zelyony",
                        "content": "IMO test2 and test3 contradict each other\\ntest2: n=1 and 0th node removed. (node0 is removed, node1 is absent)\\ntest3: n=1 and 1st node removed. (node0 is left, node1 is removed)\\nso for same n=1 different order nodes are removed.\\nwtf?"
                    },
                    {
                        "username": "Vish_sp",
                        "content": "Hi ,in c# int is not nullable then how can i return a empty List i am getting error at test case [1]  out put [] can any one help here..?"
                    },
                    {
                        "username": "kaninaba94",
                        "content": "It is misleading that head is specified as type list in the description, but in the function argument it\\'s type ListNode."
                    },
                    {
                        "username": "shashwat1319",
                        "content": "how to access element in linklist?"
                    }
                ]
            },
            {
                "id": 1912962,
                "content": [
                    {
                        "username": "zmn17",
                        "content": "head =\\n[1,2]\\nn =\\n2\\nUse Testcase\\nOutput\\n[1]\\nExpected\\n[2]\\n\\ncan someone explain this test case?? n =2 so the 2nd node from the end which is 1?? isnt it?? "
                    },
                    {
                        "username": "Afroz_shah",
                        "content": "you need to put one condition \\nwhere num=number of the node which can be get through traversal\\nand n=position from back\\nif(num-n<0){\\n            return head->next;\\n        }"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Start by adding an extra node in the beginning"
                    },
                    {
                        "username": "vivekkt",
                        "content": "I used the two pointer solution. But for some reason, the second test case in Run fails. The same test case works on my local machine as a unit test though!!!\nTest Case : \n `head = [1], n = 1`\n\nSolution:\n ```\nfunc RemoveNthFromEnd(head *ListNode, n int) *ListNode {\n\tif head == nil || n == 0 || head.Next == nil {\n\t\treturn head\n\t}\n\tdummy := &ListNode{Val: -1, Next: head}\n\tfirst, second := dummy, dummy\n\tfor i := 1; i <= n+1; i++ {\n\t\tfirst = first.Next\n\t}\n\tfor first != nil {\n\t\tfirst = first.Next\n\t\tsecond = second.Next\n\t}\n\tsecond.Next = second.Next.Next\n\treturn dummy.Next\n}\n```\n\nThe following unit test passes on my local for the above solution:\n ```\nfunc TestRemoveNthFromEnd(t *testing.T) {\n\t// GIVEN\n\thead := &ListNode{\n\t\tVal:  -1,\n\t\tNext: nil,\n\t}\n\tnode := &ListNode{\n\t\tVal:  1,\n\t\tNext: nil,\n\t}\n\thead.Next = node\n\n\t// WHEN\n\tn := RemoveNthFromEnd(head, 1)\n\n\t// THEN\n\tassert.Equal(t, (*ListNode)(nil), n.Next)\n}\n\n```\n\nWhy does this test case fail on leet code? "
                    },
                    {
                        "username": "user4346Sy",
                        "content": "100% beat\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (head == NULL)\\n                return NULL; // List does not have n nodes\\n            \\n            head = head->next;\\n        }\\n        \\n        while (head != NULL) {\\n            if (prev == NULL)\\n                prev = curr;\\n            else\\n                prev = prev->next;\\n            \\n            head = head->next;\\n        }\\n        \\n        if (prev == NULL)\\n            return curr->next; // Remove the head node\\n        else\\n            prev->next = prev->next->next; // Remove the nth node\\n        \\n        return curr;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% beat rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xenojohn",
                        "content": "Leetcode seems to be broken at this question.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\n        element_number = 0\\n\\n        head_copy = head\\n\\n        while head:\\n            element_number += 1\\n            head = head.next\\n        \\n        head = head_copy\\n        \\n        how_far = element_number - n\\n        prev_node= None\\n        print(how_far)\\n\\n        while head:\\n            print(\"how_far: \", how_far)\\n            if how_far == 0:\\n                print(\"We\\'re in if, we are breaking after this..\")\\n                print(head.val, prev_node, head, head.next)\\n                prev_node.next = head.next\\n                break\\n                print(\"We\\'re printing after break..\")\\n\\n            prev_node = head\\n            head = head.next\\n            how_far -= 1\\n\\n        return head_copy\\n```\\n\\nit seems to just purely ignore the break (i\\'ve tried with return but it still doesn\\'t return, but continue looping). This is a weird behaviour. Did anyone else also find this?\\n\\nDebug;\\n\\n3\\nhow_far:  3\\nhow_far:  2\\nhow_far:  1\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n4 ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}} ListNode{val: 4, next: ListNode{val: 5, next: None}} ListNode{val: 5, next: None}\\n0\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n1 None ListNode{val: 1, next: None} None"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I don\\'t understand what exactly happen. It seems that \\'break\\' behaves like \\'continue\\'. The text after \\'break\\' is missing.\\nYou use while loop. Why use head? I suggest that you use \\'how_far\\' instead, like that:\\nwhile how_far:\\nor\\nwhile how_far != 0:\\nWe are that we reach the node in how_far position before head.\\n"
                    },
                    {
                        "username": "Shashank1524",
                        "content": "ListNode temp = head;\n        ListNode tempN = head;\n        int length = 0;\n        while(temp!=null) {\n            temp = temp.next;\n            length++;\n        }\n        temp = head;\n        for(int i = 0; i<length-n-1; i++) {\n            temp = temp.next;\n        }`\n        tempN = temp.next;\n        System.out.print(tempN.next); \n\ncan anyone please help me with this code? \nSo the issue is, I don't understand why the NullPointerException is thrown at Sysout even though the console shows the expected output, what am I doing worng?(please ignore the complexity of the code) "
                    },
                    {
                        "username": "zelyony",
                        "content": "IMO test2 and test3 contradict each other\\ntest2: n=1 and 0th node removed. (node0 is removed, node1 is absent)\\ntest3: n=1 and 1st node removed. (node0 is left, node1 is removed)\\nso for same n=1 different order nodes are removed.\\nwtf?"
                    },
                    {
                        "username": "Vish_sp",
                        "content": "Hi ,in c# int is not nullable then how can i return a empty List i am getting error at test case [1]  out put [] can any one help here..?"
                    },
                    {
                        "username": "kaninaba94",
                        "content": "It is misleading that head is specified as type list in the description, but in the function argument it\\'s type ListNode."
                    },
                    {
                        "username": "shashwat1319",
                        "content": "how to access element in linklist?"
                    }
                ]
            },
            {
                "id": 1903794,
                "content": [
                    {
                        "username": "zmn17",
                        "content": "head =\\n[1,2]\\nn =\\n2\\nUse Testcase\\nOutput\\n[1]\\nExpected\\n[2]\\n\\ncan someone explain this test case?? n =2 so the 2nd node from the end which is 1?? isnt it?? "
                    },
                    {
                        "username": "Afroz_shah",
                        "content": "you need to put one condition \\nwhere num=number of the node which can be get through traversal\\nand n=position from back\\nif(num-n<0){\\n            return head->next;\\n        }"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Start by adding an extra node in the beginning"
                    },
                    {
                        "username": "vivekkt",
                        "content": "I used the two pointer solution. But for some reason, the second test case in Run fails. The same test case works on my local machine as a unit test though!!!\nTest Case : \n `head = [1], n = 1`\n\nSolution:\n ```\nfunc RemoveNthFromEnd(head *ListNode, n int) *ListNode {\n\tif head == nil || n == 0 || head.Next == nil {\n\t\treturn head\n\t}\n\tdummy := &ListNode{Val: -1, Next: head}\n\tfirst, second := dummy, dummy\n\tfor i := 1; i <= n+1; i++ {\n\t\tfirst = first.Next\n\t}\n\tfor first != nil {\n\t\tfirst = first.Next\n\t\tsecond = second.Next\n\t}\n\tsecond.Next = second.Next.Next\n\treturn dummy.Next\n}\n```\n\nThe following unit test passes on my local for the above solution:\n ```\nfunc TestRemoveNthFromEnd(t *testing.T) {\n\t// GIVEN\n\thead := &ListNode{\n\t\tVal:  -1,\n\t\tNext: nil,\n\t}\n\tnode := &ListNode{\n\t\tVal:  1,\n\t\tNext: nil,\n\t}\n\thead.Next = node\n\n\t// WHEN\n\tn := RemoveNthFromEnd(head, 1)\n\n\t// THEN\n\tassert.Equal(t, (*ListNode)(nil), n.Next)\n}\n\n```\n\nWhy does this test case fail on leet code? "
                    },
                    {
                        "username": "user4346Sy",
                        "content": "100% beat\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (head == NULL)\\n                return NULL; // List does not have n nodes\\n            \\n            head = head->next;\\n        }\\n        \\n        while (head != NULL) {\\n            if (prev == NULL)\\n                prev = curr;\\n            else\\n                prev = prev->next;\\n            \\n            head = head->next;\\n        }\\n        \\n        if (prev == NULL)\\n            return curr->next; // Remove the head node\\n        else\\n            prev->next = prev->next->next; // Remove the nth node\\n        \\n        return curr;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% beat rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xenojohn",
                        "content": "Leetcode seems to be broken at this question.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\n        element_number = 0\\n\\n        head_copy = head\\n\\n        while head:\\n            element_number += 1\\n            head = head.next\\n        \\n        head = head_copy\\n        \\n        how_far = element_number - n\\n        prev_node= None\\n        print(how_far)\\n\\n        while head:\\n            print(\"how_far: \", how_far)\\n            if how_far == 0:\\n                print(\"We\\'re in if, we are breaking after this..\")\\n                print(head.val, prev_node, head, head.next)\\n                prev_node.next = head.next\\n                break\\n                print(\"We\\'re printing after break..\")\\n\\n            prev_node = head\\n            head = head.next\\n            how_far -= 1\\n\\n        return head_copy\\n```\\n\\nit seems to just purely ignore the break (i\\'ve tried with return but it still doesn\\'t return, but continue looping). This is a weird behaviour. Did anyone else also find this?\\n\\nDebug;\\n\\n3\\nhow_far:  3\\nhow_far:  2\\nhow_far:  1\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n4 ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}} ListNode{val: 4, next: ListNode{val: 5, next: None}} ListNode{val: 5, next: None}\\n0\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n1 None ListNode{val: 1, next: None} None"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I don\\'t understand what exactly happen. It seems that \\'break\\' behaves like \\'continue\\'. The text after \\'break\\' is missing.\\nYou use while loop. Why use head? I suggest that you use \\'how_far\\' instead, like that:\\nwhile how_far:\\nor\\nwhile how_far != 0:\\nWe are that we reach the node in how_far position before head.\\n"
                    },
                    {
                        "username": "Shashank1524",
                        "content": "ListNode temp = head;\n        ListNode tempN = head;\n        int length = 0;\n        while(temp!=null) {\n            temp = temp.next;\n            length++;\n        }\n        temp = head;\n        for(int i = 0; i<length-n-1; i++) {\n            temp = temp.next;\n        }`\n        tempN = temp.next;\n        System.out.print(tempN.next); \n\ncan anyone please help me with this code? \nSo the issue is, I don't understand why the NullPointerException is thrown at Sysout even though the console shows the expected output, what am I doing worng?(please ignore the complexity of the code) "
                    },
                    {
                        "username": "zelyony",
                        "content": "IMO test2 and test3 contradict each other\\ntest2: n=1 and 0th node removed. (node0 is removed, node1 is absent)\\ntest3: n=1 and 1st node removed. (node0 is left, node1 is removed)\\nso for same n=1 different order nodes are removed.\\nwtf?"
                    },
                    {
                        "username": "Vish_sp",
                        "content": "Hi ,in c# int is not nullable then how can i return a empty List i am getting error at test case [1]  out put [] can any one help here..?"
                    },
                    {
                        "username": "kaninaba94",
                        "content": "It is misleading that head is specified as type list in the description, but in the function argument it\\'s type ListNode."
                    },
                    {
                        "username": "shashwat1319",
                        "content": "how to access element in linklist?"
                    }
                ]
            },
            {
                "id": 1902347,
                "content": [
                    {
                        "username": "zmn17",
                        "content": "head =\\n[1,2]\\nn =\\n2\\nUse Testcase\\nOutput\\n[1]\\nExpected\\n[2]\\n\\ncan someone explain this test case?? n =2 so the 2nd node from the end which is 1?? isnt it?? "
                    },
                    {
                        "username": "Afroz_shah",
                        "content": "you need to put one condition \\nwhere num=number of the node which can be get through traversal\\nand n=position from back\\nif(num-n<0){\\n            return head->next;\\n        }"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Start by adding an extra node in the beginning"
                    },
                    {
                        "username": "vivekkt",
                        "content": "I used the two pointer solution. But for some reason, the second test case in Run fails. The same test case works on my local machine as a unit test though!!!\nTest Case : \n `head = [1], n = 1`\n\nSolution:\n ```\nfunc RemoveNthFromEnd(head *ListNode, n int) *ListNode {\n\tif head == nil || n == 0 || head.Next == nil {\n\t\treturn head\n\t}\n\tdummy := &ListNode{Val: -1, Next: head}\n\tfirst, second := dummy, dummy\n\tfor i := 1; i <= n+1; i++ {\n\t\tfirst = first.Next\n\t}\n\tfor first != nil {\n\t\tfirst = first.Next\n\t\tsecond = second.Next\n\t}\n\tsecond.Next = second.Next.Next\n\treturn dummy.Next\n}\n```\n\nThe following unit test passes on my local for the above solution:\n ```\nfunc TestRemoveNthFromEnd(t *testing.T) {\n\t// GIVEN\n\thead := &ListNode{\n\t\tVal:  -1,\n\t\tNext: nil,\n\t}\n\tnode := &ListNode{\n\t\tVal:  1,\n\t\tNext: nil,\n\t}\n\thead.Next = node\n\n\t// WHEN\n\tn := RemoveNthFromEnd(head, 1)\n\n\t// THEN\n\tassert.Equal(t, (*ListNode)(nil), n.Next)\n}\n\n```\n\nWhy does this test case fail on leet code? "
                    },
                    {
                        "username": "user4346Sy",
                        "content": "100% beat\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (head == NULL)\\n                return NULL; // List does not have n nodes\\n            \\n            head = head->next;\\n        }\\n        \\n        while (head != NULL) {\\n            if (prev == NULL)\\n                prev = curr;\\n            else\\n                prev = prev->next;\\n            \\n            head = head->next;\\n        }\\n        \\n        if (prev == NULL)\\n            return curr->next; // Remove the head node\\n        else\\n            prev->next = prev->next->next; // Remove the nth node\\n        \\n        return curr;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% beat rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xenojohn",
                        "content": "Leetcode seems to be broken at this question.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\n        element_number = 0\\n\\n        head_copy = head\\n\\n        while head:\\n            element_number += 1\\n            head = head.next\\n        \\n        head = head_copy\\n        \\n        how_far = element_number - n\\n        prev_node= None\\n        print(how_far)\\n\\n        while head:\\n            print(\"how_far: \", how_far)\\n            if how_far == 0:\\n                print(\"We\\'re in if, we are breaking after this..\")\\n                print(head.val, prev_node, head, head.next)\\n                prev_node.next = head.next\\n                break\\n                print(\"We\\'re printing after break..\")\\n\\n            prev_node = head\\n            head = head.next\\n            how_far -= 1\\n\\n        return head_copy\\n```\\n\\nit seems to just purely ignore the break (i\\'ve tried with return but it still doesn\\'t return, but continue looping). This is a weird behaviour. Did anyone else also find this?\\n\\nDebug;\\n\\n3\\nhow_far:  3\\nhow_far:  2\\nhow_far:  1\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n4 ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}} ListNode{val: 4, next: ListNode{val: 5, next: None}} ListNode{val: 5, next: None}\\n0\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n1 None ListNode{val: 1, next: None} None"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I don\\'t understand what exactly happen. It seems that \\'break\\' behaves like \\'continue\\'. The text after \\'break\\' is missing.\\nYou use while loop. Why use head? I suggest that you use \\'how_far\\' instead, like that:\\nwhile how_far:\\nor\\nwhile how_far != 0:\\nWe are that we reach the node in how_far position before head.\\n"
                    },
                    {
                        "username": "Shashank1524",
                        "content": "ListNode temp = head;\n        ListNode tempN = head;\n        int length = 0;\n        while(temp!=null) {\n            temp = temp.next;\n            length++;\n        }\n        temp = head;\n        for(int i = 0; i<length-n-1; i++) {\n            temp = temp.next;\n        }`\n        tempN = temp.next;\n        System.out.print(tempN.next); \n\ncan anyone please help me with this code? \nSo the issue is, I don't understand why the NullPointerException is thrown at Sysout even though the console shows the expected output, what am I doing worng?(please ignore the complexity of the code) "
                    },
                    {
                        "username": "zelyony",
                        "content": "IMO test2 and test3 contradict each other\\ntest2: n=1 and 0th node removed. (node0 is removed, node1 is absent)\\ntest3: n=1 and 1st node removed. (node0 is left, node1 is removed)\\nso for same n=1 different order nodes are removed.\\nwtf?"
                    },
                    {
                        "username": "Vish_sp",
                        "content": "Hi ,in c# int is not nullable then how can i return a empty List i am getting error at test case [1]  out put [] can any one help here..?"
                    },
                    {
                        "username": "kaninaba94",
                        "content": "It is misleading that head is specified as type list in the description, but in the function argument it\\'s type ListNode."
                    },
                    {
                        "username": "shashwat1319",
                        "content": "how to access element in linklist?"
                    }
                ]
            },
            {
                "id": 1885458,
                "content": [
                    {
                        "username": "zmn17",
                        "content": "head =\\n[1,2]\\nn =\\n2\\nUse Testcase\\nOutput\\n[1]\\nExpected\\n[2]\\n\\ncan someone explain this test case?? n =2 so the 2nd node from the end which is 1?? isnt it?? "
                    },
                    {
                        "username": "Afroz_shah",
                        "content": "you need to put one condition \\nwhere num=number of the node which can be get through traversal\\nand n=position from back\\nif(num-n<0){\\n            return head->next;\\n        }"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Start by adding an extra node in the beginning"
                    },
                    {
                        "username": "vivekkt",
                        "content": "I used the two pointer solution. But for some reason, the second test case in Run fails. The same test case works on my local machine as a unit test though!!!\nTest Case : \n `head = [1], n = 1`\n\nSolution:\n ```\nfunc RemoveNthFromEnd(head *ListNode, n int) *ListNode {\n\tif head == nil || n == 0 || head.Next == nil {\n\t\treturn head\n\t}\n\tdummy := &ListNode{Val: -1, Next: head}\n\tfirst, second := dummy, dummy\n\tfor i := 1; i <= n+1; i++ {\n\t\tfirst = first.Next\n\t}\n\tfor first != nil {\n\t\tfirst = first.Next\n\t\tsecond = second.Next\n\t}\n\tsecond.Next = second.Next.Next\n\treturn dummy.Next\n}\n```\n\nThe following unit test passes on my local for the above solution:\n ```\nfunc TestRemoveNthFromEnd(t *testing.T) {\n\t// GIVEN\n\thead := &ListNode{\n\t\tVal:  -1,\n\t\tNext: nil,\n\t}\n\tnode := &ListNode{\n\t\tVal:  1,\n\t\tNext: nil,\n\t}\n\thead.Next = node\n\n\t// WHEN\n\tn := RemoveNthFromEnd(head, 1)\n\n\t// THEN\n\tassert.Equal(t, (*ListNode)(nil), n.Next)\n}\n\n```\n\nWhy does this test case fail on leet code? "
                    },
                    {
                        "username": "user4346Sy",
                        "content": "100% beat\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (head == NULL)\\n                return NULL; // List does not have n nodes\\n            \\n            head = head->next;\\n        }\\n        \\n        while (head != NULL) {\\n            if (prev == NULL)\\n                prev = curr;\\n            else\\n                prev = prev->next;\\n            \\n            head = head->next;\\n        }\\n        \\n        if (prev == NULL)\\n            return curr->next; // Remove the head node\\n        else\\n            prev->next = prev->next->next; // Remove the nth node\\n        \\n        return curr;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% beat rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xenojohn",
                        "content": "Leetcode seems to be broken at this question.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\n        element_number = 0\\n\\n        head_copy = head\\n\\n        while head:\\n            element_number += 1\\n            head = head.next\\n        \\n        head = head_copy\\n        \\n        how_far = element_number - n\\n        prev_node= None\\n        print(how_far)\\n\\n        while head:\\n            print(\"how_far: \", how_far)\\n            if how_far == 0:\\n                print(\"We\\'re in if, we are breaking after this..\")\\n                print(head.val, prev_node, head, head.next)\\n                prev_node.next = head.next\\n                break\\n                print(\"We\\'re printing after break..\")\\n\\n            prev_node = head\\n            head = head.next\\n            how_far -= 1\\n\\n        return head_copy\\n```\\n\\nit seems to just purely ignore the break (i\\'ve tried with return but it still doesn\\'t return, but continue looping). This is a weird behaviour. Did anyone else also find this?\\n\\nDebug;\\n\\n3\\nhow_far:  3\\nhow_far:  2\\nhow_far:  1\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n4 ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}} ListNode{val: 4, next: ListNode{val: 5, next: None}} ListNode{val: 5, next: None}\\n0\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n1 None ListNode{val: 1, next: None} None"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I don\\'t understand what exactly happen. It seems that \\'break\\' behaves like \\'continue\\'. The text after \\'break\\' is missing.\\nYou use while loop. Why use head? I suggest that you use \\'how_far\\' instead, like that:\\nwhile how_far:\\nor\\nwhile how_far != 0:\\nWe are that we reach the node in how_far position before head.\\n"
                    },
                    {
                        "username": "Shashank1524",
                        "content": "ListNode temp = head;\n        ListNode tempN = head;\n        int length = 0;\n        while(temp!=null) {\n            temp = temp.next;\n            length++;\n        }\n        temp = head;\n        for(int i = 0; i<length-n-1; i++) {\n            temp = temp.next;\n        }`\n        tempN = temp.next;\n        System.out.print(tempN.next); \n\ncan anyone please help me with this code? \nSo the issue is, I don't understand why the NullPointerException is thrown at Sysout even though the console shows the expected output, what am I doing worng?(please ignore the complexity of the code) "
                    },
                    {
                        "username": "zelyony",
                        "content": "IMO test2 and test3 contradict each other\\ntest2: n=1 and 0th node removed. (node0 is removed, node1 is absent)\\ntest3: n=1 and 1st node removed. (node0 is left, node1 is removed)\\nso for same n=1 different order nodes are removed.\\nwtf?"
                    },
                    {
                        "username": "Vish_sp",
                        "content": "Hi ,in c# int is not nullable then how can i return a empty List i am getting error at test case [1]  out put [] can any one help here..?"
                    },
                    {
                        "username": "kaninaba94",
                        "content": "It is misleading that head is specified as type list in the description, but in the function argument it\\'s type ListNode."
                    },
                    {
                        "username": "shashwat1319",
                        "content": "how to access element in linklist?"
                    }
                ]
            },
            {
                "id": 1878243,
                "content": [
                    {
                        "username": "zmn17",
                        "content": "head =\\n[1,2]\\nn =\\n2\\nUse Testcase\\nOutput\\n[1]\\nExpected\\n[2]\\n\\ncan someone explain this test case?? n =2 so the 2nd node from the end which is 1?? isnt it?? "
                    },
                    {
                        "username": "Afroz_shah",
                        "content": "you need to put one condition \\nwhere num=number of the node which can be get through traversal\\nand n=position from back\\nif(num-n<0){\\n            return head->next;\\n        }"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Start by adding an extra node in the beginning"
                    },
                    {
                        "username": "vivekkt",
                        "content": "I used the two pointer solution. But for some reason, the second test case in Run fails. The same test case works on my local machine as a unit test though!!!\nTest Case : \n `head = [1], n = 1`\n\nSolution:\n ```\nfunc RemoveNthFromEnd(head *ListNode, n int) *ListNode {\n\tif head == nil || n == 0 || head.Next == nil {\n\t\treturn head\n\t}\n\tdummy := &ListNode{Val: -1, Next: head}\n\tfirst, second := dummy, dummy\n\tfor i := 1; i <= n+1; i++ {\n\t\tfirst = first.Next\n\t}\n\tfor first != nil {\n\t\tfirst = first.Next\n\t\tsecond = second.Next\n\t}\n\tsecond.Next = second.Next.Next\n\treturn dummy.Next\n}\n```\n\nThe following unit test passes on my local for the above solution:\n ```\nfunc TestRemoveNthFromEnd(t *testing.T) {\n\t// GIVEN\n\thead := &ListNode{\n\t\tVal:  -1,\n\t\tNext: nil,\n\t}\n\tnode := &ListNode{\n\t\tVal:  1,\n\t\tNext: nil,\n\t}\n\thead.Next = node\n\n\t// WHEN\n\tn := RemoveNthFromEnd(head, 1)\n\n\t// THEN\n\tassert.Equal(t, (*ListNode)(nil), n.Next)\n}\n\n```\n\nWhy does this test case fail on leet code? "
                    },
                    {
                        "username": "user4346Sy",
                        "content": "100% beat\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (head == NULL)\\n                return NULL; // List does not have n nodes\\n            \\n            head = head->next;\\n        }\\n        \\n        while (head != NULL) {\\n            if (prev == NULL)\\n                prev = curr;\\n            else\\n                prev = prev->next;\\n            \\n            head = head->next;\\n        }\\n        \\n        if (prev == NULL)\\n            return curr->next; // Remove the head node\\n        else\\n            prev->next = prev->next->next; // Remove the nth node\\n        \\n        return curr;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% beat rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xenojohn",
                        "content": "Leetcode seems to be broken at this question.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\n        element_number = 0\\n\\n        head_copy = head\\n\\n        while head:\\n            element_number += 1\\n            head = head.next\\n        \\n        head = head_copy\\n        \\n        how_far = element_number - n\\n        prev_node= None\\n        print(how_far)\\n\\n        while head:\\n            print(\"how_far: \", how_far)\\n            if how_far == 0:\\n                print(\"We\\'re in if, we are breaking after this..\")\\n                print(head.val, prev_node, head, head.next)\\n                prev_node.next = head.next\\n                break\\n                print(\"We\\'re printing after break..\")\\n\\n            prev_node = head\\n            head = head.next\\n            how_far -= 1\\n\\n        return head_copy\\n```\\n\\nit seems to just purely ignore the break (i\\'ve tried with return but it still doesn\\'t return, but continue looping). This is a weird behaviour. Did anyone else also find this?\\n\\nDebug;\\n\\n3\\nhow_far:  3\\nhow_far:  2\\nhow_far:  1\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n4 ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}} ListNode{val: 4, next: ListNode{val: 5, next: None}} ListNode{val: 5, next: None}\\n0\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n1 None ListNode{val: 1, next: None} None"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I don\\'t understand what exactly happen. It seems that \\'break\\' behaves like \\'continue\\'. The text after \\'break\\' is missing.\\nYou use while loop. Why use head? I suggest that you use \\'how_far\\' instead, like that:\\nwhile how_far:\\nor\\nwhile how_far != 0:\\nWe are that we reach the node in how_far position before head.\\n"
                    },
                    {
                        "username": "Shashank1524",
                        "content": "ListNode temp = head;\n        ListNode tempN = head;\n        int length = 0;\n        while(temp!=null) {\n            temp = temp.next;\n            length++;\n        }\n        temp = head;\n        for(int i = 0; i<length-n-1; i++) {\n            temp = temp.next;\n        }`\n        tempN = temp.next;\n        System.out.print(tempN.next); \n\ncan anyone please help me with this code? \nSo the issue is, I don't understand why the NullPointerException is thrown at Sysout even though the console shows the expected output, what am I doing worng?(please ignore the complexity of the code) "
                    },
                    {
                        "username": "zelyony",
                        "content": "IMO test2 and test3 contradict each other\\ntest2: n=1 and 0th node removed. (node0 is removed, node1 is absent)\\ntest3: n=1 and 1st node removed. (node0 is left, node1 is removed)\\nso for same n=1 different order nodes are removed.\\nwtf?"
                    },
                    {
                        "username": "Vish_sp",
                        "content": "Hi ,in c# int is not nullable then how can i return a empty List i am getting error at test case [1]  out put [] can any one help here..?"
                    },
                    {
                        "username": "kaninaba94",
                        "content": "It is misleading that head is specified as type list in the description, but in the function argument it\\'s type ListNode."
                    },
                    {
                        "username": "shashwat1319",
                        "content": "how to access element in linklist?"
                    }
                ]
            },
            {
                "id": 1856530,
                "content": [
                    {
                        "username": "zmn17",
                        "content": "head =\\n[1,2]\\nn =\\n2\\nUse Testcase\\nOutput\\n[1]\\nExpected\\n[2]\\n\\ncan someone explain this test case?? n =2 so the 2nd node from the end which is 1?? isnt it?? "
                    },
                    {
                        "username": "Afroz_shah",
                        "content": "you need to put one condition \\nwhere num=number of the node which can be get through traversal\\nand n=position from back\\nif(num-n<0){\\n            return head->next;\\n        }"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Start by adding an extra node in the beginning"
                    },
                    {
                        "username": "vivekkt",
                        "content": "I used the two pointer solution. But for some reason, the second test case in Run fails. The same test case works on my local machine as a unit test though!!!\nTest Case : \n `head = [1], n = 1`\n\nSolution:\n ```\nfunc RemoveNthFromEnd(head *ListNode, n int) *ListNode {\n\tif head == nil || n == 0 || head.Next == nil {\n\t\treturn head\n\t}\n\tdummy := &ListNode{Val: -1, Next: head}\n\tfirst, second := dummy, dummy\n\tfor i := 1; i <= n+1; i++ {\n\t\tfirst = first.Next\n\t}\n\tfor first != nil {\n\t\tfirst = first.Next\n\t\tsecond = second.Next\n\t}\n\tsecond.Next = second.Next.Next\n\treturn dummy.Next\n}\n```\n\nThe following unit test passes on my local for the above solution:\n ```\nfunc TestRemoveNthFromEnd(t *testing.T) {\n\t// GIVEN\n\thead := &ListNode{\n\t\tVal:  -1,\n\t\tNext: nil,\n\t}\n\tnode := &ListNode{\n\t\tVal:  1,\n\t\tNext: nil,\n\t}\n\thead.Next = node\n\n\t// WHEN\n\tn := RemoveNthFromEnd(head, 1)\n\n\t// THEN\n\tassert.Equal(t, (*ListNode)(nil), n.Next)\n}\n\n```\n\nWhy does this test case fail on leet code? "
                    },
                    {
                        "username": "user4346Sy",
                        "content": "100% beat\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (head == NULL)\\n                return NULL; // List does not have n nodes\\n            \\n            head = head->next;\\n        }\\n        \\n        while (head != NULL) {\\n            if (prev == NULL)\\n                prev = curr;\\n            else\\n                prev = prev->next;\\n            \\n            head = head->next;\\n        }\\n        \\n        if (prev == NULL)\\n            return curr->next; // Remove the head node\\n        else\\n            prev->next = prev->next->next; // Remove the nth node\\n        \\n        return curr;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% beat rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xenojohn",
                        "content": "Leetcode seems to be broken at this question.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\n        element_number = 0\\n\\n        head_copy = head\\n\\n        while head:\\n            element_number += 1\\n            head = head.next\\n        \\n        head = head_copy\\n        \\n        how_far = element_number - n\\n        prev_node= None\\n        print(how_far)\\n\\n        while head:\\n            print(\"how_far: \", how_far)\\n            if how_far == 0:\\n                print(\"We\\'re in if, we are breaking after this..\")\\n                print(head.val, prev_node, head, head.next)\\n                prev_node.next = head.next\\n                break\\n                print(\"We\\'re printing after break..\")\\n\\n            prev_node = head\\n            head = head.next\\n            how_far -= 1\\n\\n        return head_copy\\n```\\n\\nit seems to just purely ignore the break (i\\'ve tried with return but it still doesn\\'t return, but continue looping). This is a weird behaviour. Did anyone else also find this?\\n\\nDebug;\\n\\n3\\nhow_far:  3\\nhow_far:  2\\nhow_far:  1\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n4 ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}} ListNode{val: 4, next: ListNode{val: 5, next: None}} ListNode{val: 5, next: None}\\n0\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n1 None ListNode{val: 1, next: None} None"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I don\\'t understand what exactly happen. It seems that \\'break\\' behaves like \\'continue\\'. The text after \\'break\\' is missing.\\nYou use while loop. Why use head? I suggest that you use \\'how_far\\' instead, like that:\\nwhile how_far:\\nor\\nwhile how_far != 0:\\nWe are that we reach the node in how_far position before head.\\n"
                    },
                    {
                        "username": "Shashank1524",
                        "content": "ListNode temp = head;\n        ListNode tempN = head;\n        int length = 0;\n        while(temp!=null) {\n            temp = temp.next;\n            length++;\n        }\n        temp = head;\n        for(int i = 0; i<length-n-1; i++) {\n            temp = temp.next;\n        }`\n        tempN = temp.next;\n        System.out.print(tempN.next); \n\ncan anyone please help me with this code? \nSo the issue is, I don't understand why the NullPointerException is thrown at Sysout even though the console shows the expected output, what am I doing worng?(please ignore the complexity of the code) "
                    },
                    {
                        "username": "zelyony",
                        "content": "IMO test2 and test3 contradict each other\\ntest2: n=1 and 0th node removed. (node0 is removed, node1 is absent)\\ntest3: n=1 and 1st node removed. (node0 is left, node1 is removed)\\nso for same n=1 different order nodes are removed.\\nwtf?"
                    },
                    {
                        "username": "Vish_sp",
                        "content": "Hi ,in c# int is not nullable then how can i return a empty List i am getting error at test case [1]  out put [] can any one help here..?"
                    },
                    {
                        "username": "kaninaba94",
                        "content": "It is misleading that head is specified as type list in the description, but in the function argument it\\'s type ListNode."
                    },
                    {
                        "username": "shashwat1319",
                        "content": "how to access element in linklist?"
                    }
                ]
            },
            {
                "id": 1846477,
                "content": [
                    {
                        "username": "user4711ok",
                        "content": "Tearing my hair out; why does this give a runtime error?\\n\\nOk so I run these two pointers through the list, simple. One does it in a for loop and one does it unrolled. Looking at the stdout, the pointer in the loop goes through 5 times (as it should) but I get a runtime error trying to go through it unrolled. If I put a \"return if null\" statement beforehand, I still get a runtime error, so it\\'s not that it\\'s null.\\n\\nCame across this on the way to a solution. The error is:\\n\\nLine 26: Char 59: runtime error: member access within null pointer of type \\'const ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        const ListNode* scanPtr = head;\\n\\n        while(scanPtr)\\n        {\\n            printf(\"G: %X links to %X\\\\n\", scanPtr, scanPtr->next);\\n            scanPtr = scanPtr->next;\\n        }\\n\\n        const ListNode* breakPtr = head;\\n\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n        breakPtr = breakPtr->next;\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n\\n        printf(\"Done!\\\\n\");\\n\\n        return head;\\n    }"
                    },
                    {
                        "username": "vanavi",
                        "content": "Hi everybody! \\nI proposed a solution using method `.at()`.  And i prove it in my local server and works perfectly fine. But i test it in here and returns `TypeError: head.at is not a function`\\n\\nWhy i cant apply it in this problem? "
                    },
                    {
                        "username": "nklwwlkn",
                        "content": "Hey, \\n\\nIt\\'s a Linked list data structure, and not an array. You see the TypeError because the ListNode class doesn\\'t have an \"at\" method."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Everyone is doing it alright. But yall forgetting one if condition that\\'s it."
                    },
                    {
                        "username": "user3948b",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p=head,*q=head;\\n        int m =0;\\n        while(p!=NULL ) {\\n            m++;\\n            p=p->next;\\n        }\\n        for(int i=0;i<m-n;i++) {\\n            q=q->next;\\n        }\\n        ListNode *d= q->next;\\n        q->next = d->next;\\n       delete d;\\n        return head;\\n        \\n         }`\\nwhy this is not working"
                    },
                    {
                        "username": "cagils",
                        "content": "**O(1) 2-pointers approach, optimized algorithm explanation:**\n\n0. Assign fast pointer to head.next, slow pointer to the head (named 'node')\n1. Traverse the list from the head n-1 times with the fast pointer (named 'cur'). It started at head.next, so we have traversed the list now n times\n2. If you have arrived at null (edge case of head removal), return head.next\n3. Now we move both pointers at the same time until fast pointer (cur) reaches the end\n4. Remove the node next of the current slow pointer (node). So node.next = node.next.next\n5. Return head\n\nFor a 6-line implementation in JS you can look at my solution."
                    },
                    {
                        "username": "user8170Cm",
                        "content": "Hint: use a stack"
                    },
                    {
                        "username": "Fantaseaxx",
                        "content": "Dose anyone know what\\'s wrong with my code? Cant pass the test : head=[1],n=1 the output should be [ ],I ran my code in my IDE, shows the same results, but on Leetcode console output is [1]\\nclass Solution {\\n    static int cur =0;\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if(head == null) return null;\\n        head.next = removeNthFromEnd(head.next,n);\\n        cur++;\\n        if(cur == n) return head.next;\\n        return head;\\n\\n    }\\n}"
                    },
                    {
                        "username": "ravilsqrt",
                        "content": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n       arr = [head]\n        while arr[-1].next:\n            arr.append(arr[-1].next)\n        if len(arr) == 1:\n            return None\n\n        arr.pop(len(arr) - n)\n\n        cur_new = ListNode(arr[0].val)\n        for i in range(len(arr)):\n            if i != 0:\n                exec('cur_new{amount}'.format(amount='.next' * i + '= arr[i]'))\n        return cur_new\n\nI failed on 194 test with this solution, but I got correct answer in pycharm and online interpreter"
                    },
                    {
                        "username": "Amangupta97656",
                        "content": "IT\\'S EASY SOLUTION\\n\\n\\n\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        //if Single element list, thus returning empty list\\n        if(head.next == null)\\n            return null;\\n\\n        ListNode ptr = head;\\n        ListNode ptr2 = head;\\n\\n        int len = 0;\\n\\n        //finding the lenght of the list\\n        while(ptr != null)\\n        {\\n            len++;\\n            ptr = ptr.next;\\n        }\\n\\n        //required index\\n        int index = len - n;\\n        ptr = head;\\n\\n        boolean start = false;\\n\\n        while(true)\\n        {\\n            if(index == 0)\\n            {\\n                // if head element\\n                if(ptr == head)\\n                {\\n                    ptr2 = ptr2.next;\\n                    ptr.next = null;\\n                    head = ptr2;\\n                    break;\\n                }\\n\\n                else\\n                {\\n                    ptr2.next = ptr.next;\\n                    ptr.next = null;\\n                    break;\\n                }\\n            }\\n\\n            index--;\\n\\n            //for letting the second pointer start late\\n            if(start)\\n                ptr2 = ptr2.next;\\n\\n            start = true;\\n\\n            ptr = ptr.next;\\n        }    \\n\\n        return head;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It\\'s easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arpit_055",
                        "content": "I have compiled my solution \\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        for(int i=0;i<(n-1);i++){\\n            fast=fast->next;\\n        }\\n        while(fast->next!=nullptr){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        if(slow==head){\\n            head=head->next;\\n            delete slow;\\n            return head;\\n        }\\n        slow->next=slow->next->next;\\n        return head;\\n    }\\n\\nbut I\\'m keep getting this error member access within null pointer in this line /*slow->next=slow->next->next*/ ,I have also tried writing temp=slow->next and then slow->next=temp->next but it didn\\'t work.Is there any other way to write this line..\\n"
                    }
                ]
            },
            {
                "id": 1845450,
                "content": [
                    {
                        "username": "user4711ok",
                        "content": "Tearing my hair out; why does this give a runtime error?\\n\\nOk so I run these two pointers through the list, simple. One does it in a for loop and one does it unrolled. Looking at the stdout, the pointer in the loop goes through 5 times (as it should) but I get a runtime error trying to go through it unrolled. If I put a \"return if null\" statement beforehand, I still get a runtime error, so it\\'s not that it\\'s null.\\n\\nCame across this on the way to a solution. The error is:\\n\\nLine 26: Char 59: runtime error: member access within null pointer of type \\'const ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        const ListNode* scanPtr = head;\\n\\n        while(scanPtr)\\n        {\\n            printf(\"G: %X links to %X\\\\n\", scanPtr, scanPtr->next);\\n            scanPtr = scanPtr->next;\\n        }\\n\\n        const ListNode* breakPtr = head;\\n\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n        breakPtr = breakPtr->next;\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n\\n        printf(\"Done!\\\\n\");\\n\\n        return head;\\n    }"
                    },
                    {
                        "username": "vanavi",
                        "content": "Hi everybody! \\nI proposed a solution using method `.at()`.  And i prove it in my local server and works perfectly fine. But i test it in here and returns `TypeError: head.at is not a function`\\n\\nWhy i cant apply it in this problem? "
                    },
                    {
                        "username": "nklwwlkn",
                        "content": "Hey, \\n\\nIt\\'s a Linked list data structure, and not an array. You see the TypeError because the ListNode class doesn\\'t have an \"at\" method."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Everyone is doing it alright. But yall forgetting one if condition that\\'s it."
                    },
                    {
                        "username": "user3948b",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p=head,*q=head;\\n        int m =0;\\n        while(p!=NULL ) {\\n            m++;\\n            p=p->next;\\n        }\\n        for(int i=0;i<m-n;i++) {\\n            q=q->next;\\n        }\\n        ListNode *d= q->next;\\n        q->next = d->next;\\n       delete d;\\n        return head;\\n        \\n         }`\\nwhy this is not working"
                    },
                    {
                        "username": "cagils",
                        "content": "**O(1) 2-pointers approach, optimized algorithm explanation:**\n\n0. Assign fast pointer to head.next, slow pointer to the head (named 'node')\n1. Traverse the list from the head n-1 times with the fast pointer (named 'cur'). It started at head.next, so we have traversed the list now n times\n2. If you have arrived at null (edge case of head removal), return head.next\n3. Now we move both pointers at the same time until fast pointer (cur) reaches the end\n4. Remove the node next of the current slow pointer (node). So node.next = node.next.next\n5. Return head\n\nFor a 6-line implementation in JS you can look at my solution."
                    },
                    {
                        "username": "user8170Cm",
                        "content": "Hint: use a stack"
                    },
                    {
                        "username": "Fantaseaxx",
                        "content": "Dose anyone know what\\'s wrong with my code? Cant pass the test : head=[1],n=1 the output should be [ ],I ran my code in my IDE, shows the same results, but on Leetcode console output is [1]\\nclass Solution {\\n    static int cur =0;\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if(head == null) return null;\\n        head.next = removeNthFromEnd(head.next,n);\\n        cur++;\\n        if(cur == n) return head.next;\\n        return head;\\n\\n    }\\n}"
                    },
                    {
                        "username": "ravilsqrt",
                        "content": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n       arr = [head]\n        while arr[-1].next:\n            arr.append(arr[-1].next)\n        if len(arr) == 1:\n            return None\n\n        arr.pop(len(arr) - n)\n\n        cur_new = ListNode(arr[0].val)\n        for i in range(len(arr)):\n            if i != 0:\n                exec('cur_new{amount}'.format(amount='.next' * i + '= arr[i]'))\n        return cur_new\n\nI failed on 194 test with this solution, but I got correct answer in pycharm and online interpreter"
                    },
                    {
                        "username": "Amangupta97656",
                        "content": "IT\\'S EASY SOLUTION\\n\\n\\n\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        //if Single element list, thus returning empty list\\n        if(head.next == null)\\n            return null;\\n\\n        ListNode ptr = head;\\n        ListNode ptr2 = head;\\n\\n        int len = 0;\\n\\n        //finding the lenght of the list\\n        while(ptr != null)\\n        {\\n            len++;\\n            ptr = ptr.next;\\n        }\\n\\n        //required index\\n        int index = len - n;\\n        ptr = head;\\n\\n        boolean start = false;\\n\\n        while(true)\\n        {\\n            if(index == 0)\\n            {\\n                // if head element\\n                if(ptr == head)\\n                {\\n                    ptr2 = ptr2.next;\\n                    ptr.next = null;\\n                    head = ptr2;\\n                    break;\\n                }\\n\\n                else\\n                {\\n                    ptr2.next = ptr.next;\\n                    ptr.next = null;\\n                    break;\\n                }\\n            }\\n\\n            index--;\\n\\n            //for letting the second pointer start late\\n            if(start)\\n                ptr2 = ptr2.next;\\n\\n            start = true;\\n\\n            ptr = ptr.next;\\n        }    \\n\\n        return head;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It\\'s easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arpit_055",
                        "content": "I have compiled my solution \\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        for(int i=0;i<(n-1);i++){\\n            fast=fast->next;\\n        }\\n        while(fast->next!=nullptr){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        if(slow==head){\\n            head=head->next;\\n            delete slow;\\n            return head;\\n        }\\n        slow->next=slow->next->next;\\n        return head;\\n    }\\n\\nbut I\\'m keep getting this error member access within null pointer in this line /*slow->next=slow->next->next*/ ,I have also tried writing temp=slow->next and then slow->next=temp->next but it didn\\'t work.Is there any other way to write this line..\\n"
                    }
                ]
            },
            {
                "id": 1838225,
                "content": [
                    {
                        "username": "user4711ok",
                        "content": "Tearing my hair out; why does this give a runtime error?\\n\\nOk so I run these two pointers through the list, simple. One does it in a for loop and one does it unrolled. Looking at the stdout, the pointer in the loop goes through 5 times (as it should) but I get a runtime error trying to go through it unrolled. If I put a \"return if null\" statement beforehand, I still get a runtime error, so it\\'s not that it\\'s null.\\n\\nCame across this on the way to a solution. The error is:\\n\\nLine 26: Char 59: runtime error: member access within null pointer of type \\'const ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        const ListNode* scanPtr = head;\\n\\n        while(scanPtr)\\n        {\\n            printf(\"G: %X links to %X\\\\n\", scanPtr, scanPtr->next);\\n            scanPtr = scanPtr->next;\\n        }\\n\\n        const ListNode* breakPtr = head;\\n\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n        breakPtr = breakPtr->next;\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n\\n        printf(\"Done!\\\\n\");\\n\\n        return head;\\n    }"
                    },
                    {
                        "username": "vanavi",
                        "content": "Hi everybody! \\nI proposed a solution using method `.at()`.  And i prove it in my local server and works perfectly fine. But i test it in here and returns `TypeError: head.at is not a function`\\n\\nWhy i cant apply it in this problem? "
                    },
                    {
                        "username": "nklwwlkn",
                        "content": "Hey, \\n\\nIt\\'s a Linked list data structure, and not an array. You see the TypeError because the ListNode class doesn\\'t have an \"at\" method."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Everyone is doing it alright. But yall forgetting one if condition that\\'s it."
                    },
                    {
                        "username": "user3948b",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p=head,*q=head;\\n        int m =0;\\n        while(p!=NULL ) {\\n            m++;\\n            p=p->next;\\n        }\\n        for(int i=0;i<m-n;i++) {\\n            q=q->next;\\n        }\\n        ListNode *d= q->next;\\n        q->next = d->next;\\n       delete d;\\n        return head;\\n        \\n         }`\\nwhy this is not working"
                    },
                    {
                        "username": "cagils",
                        "content": "**O(1) 2-pointers approach, optimized algorithm explanation:**\n\n0. Assign fast pointer to head.next, slow pointer to the head (named 'node')\n1. Traverse the list from the head n-1 times with the fast pointer (named 'cur'). It started at head.next, so we have traversed the list now n times\n2. If you have arrived at null (edge case of head removal), return head.next\n3. Now we move both pointers at the same time until fast pointer (cur) reaches the end\n4. Remove the node next of the current slow pointer (node). So node.next = node.next.next\n5. Return head\n\nFor a 6-line implementation in JS you can look at my solution."
                    },
                    {
                        "username": "user8170Cm",
                        "content": "Hint: use a stack"
                    },
                    {
                        "username": "Fantaseaxx",
                        "content": "Dose anyone know what\\'s wrong with my code? Cant pass the test : head=[1],n=1 the output should be [ ],I ran my code in my IDE, shows the same results, but on Leetcode console output is [1]\\nclass Solution {\\n    static int cur =0;\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if(head == null) return null;\\n        head.next = removeNthFromEnd(head.next,n);\\n        cur++;\\n        if(cur == n) return head.next;\\n        return head;\\n\\n    }\\n}"
                    },
                    {
                        "username": "ravilsqrt",
                        "content": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n       arr = [head]\n        while arr[-1].next:\n            arr.append(arr[-1].next)\n        if len(arr) == 1:\n            return None\n\n        arr.pop(len(arr) - n)\n\n        cur_new = ListNode(arr[0].val)\n        for i in range(len(arr)):\n            if i != 0:\n                exec('cur_new{amount}'.format(amount='.next' * i + '= arr[i]'))\n        return cur_new\n\nI failed on 194 test with this solution, but I got correct answer in pycharm and online interpreter"
                    },
                    {
                        "username": "Amangupta97656",
                        "content": "IT\\'S EASY SOLUTION\\n\\n\\n\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        //if Single element list, thus returning empty list\\n        if(head.next == null)\\n            return null;\\n\\n        ListNode ptr = head;\\n        ListNode ptr2 = head;\\n\\n        int len = 0;\\n\\n        //finding the lenght of the list\\n        while(ptr != null)\\n        {\\n            len++;\\n            ptr = ptr.next;\\n        }\\n\\n        //required index\\n        int index = len - n;\\n        ptr = head;\\n\\n        boolean start = false;\\n\\n        while(true)\\n        {\\n            if(index == 0)\\n            {\\n                // if head element\\n                if(ptr == head)\\n                {\\n                    ptr2 = ptr2.next;\\n                    ptr.next = null;\\n                    head = ptr2;\\n                    break;\\n                }\\n\\n                else\\n                {\\n                    ptr2.next = ptr.next;\\n                    ptr.next = null;\\n                    break;\\n                }\\n            }\\n\\n            index--;\\n\\n            //for letting the second pointer start late\\n            if(start)\\n                ptr2 = ptr2.next;\\n\\n            start = true;\\n\\n            ptr = ptr.next;\\n        }    \\n\\n        return head;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It\\'s easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arpit_055",
                        "content": "I have compiled my solution \\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        for(int i=0;i<(n-1);i++){\\n            fast=fast->next;\\n        }\\n        while(fast->next!=nullptr){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        if(slow==head){\\n            head=head->next;\\n            delete slow;\\n            return head;\\n        }\\n        slow->next=slow->next->next;\\n        return head;\\n    }\\n\\nbut I\\'m keep getting this error member access within null pointer in this line /*slow->next=slow->next->next*/ ,I have also tried writing temp=slow->next and then slow->next=temp->next but it didn\\'t work.Is there any other way to write this line..\\n"
                    }
                ]
            },
            {
                "id": 1832920,
                "content": [
                    {
                        "username": "user4711ok",
                        "content": "Tearing my hair out; why does this give a runtime error?\\n\\nOk so I run these two pointers through the list, simple. One does it in a for loop and one does it unrolled. Looking at the stdout, the pointer in the loop goes through 5 times (as it should) but I get a runtime error trying to go through it unrolled. If I put a \"return if null\" statement beforehand, I still get a runtime error, so it\\'s not that it\\'s null.\\n\\nCame across this on the way to a solution. The error is:\\n\\nLine 26: Char 59: runtime error: member access within null pointer of type \\'const ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        const ListNode* scanPtr = head;\\n\\n        while(scanPtr)\\n        {\\n            printf(\"G: %X links to %X\\\\n\", scanPtr, scanPtr->next);\\n            scanPtr = scanPtr->next;\\n        }\\n\\n        const ListNode* breakPtr = head;\\n\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n        breakPtr = breakPtr->next;\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n\\n        printf(\"Done!\\\\n\");\\n\\n        return head;\\n    }"
                    },
                    {
                        "username": "vanavi",
                        "content": "Hi everybody! \\nI proposed a solution using method `.at()`.  And i prove it in my local server and works perfectly fine. But i test it in here and returns `TypeError: head.at is not a function`\\n\\nWhy i cant apply it in this problem? "
                    },
                    {
                        "username": "nklwwlkn",
                        "content": "Hey, \\n\\nIt\\'s a Linked list data structure, and not an array. You see the TypeError because the ListNode class doesn\\'t have an \"at\" method."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Everyone is doing it alright. But yall forgetting one if condition that\\'s it."
                    },
                    {
                        "username": "user3948b",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p=head,*q=head;\\n        int m =0;\\n        while(p!=NULL ) {\\n            m++;\\n            p=p->next;\\n        }\\n        for(int i=0;i<m-n;i++) {\\n            q=q->next;\\n        }\\n        ListNode *d= q->next;\\n        q->next = d->next;\\n       delete d;\\n        return head;\\n        \\n         }`\\nwhy this is not working"
                    },
                    {
                        "username": "cagils",
                        "content": "**O(1) 2-pointers approach, optimized algorithm explanation:**\n\n0. Assign fast pointer to head.next, slow pointer to the head (named 'node')\n1. Traverse the list from the head n-1 times with the fast pointer (named 'cur'). It started at head.next, so we have traversed the list now n times\n2. If you have arrived at null (edge case of head removal), return head.next\n3. Now we move both pointers at the same time until fast pointer (cur) reaches the end\n4. Remove the node next of the current slow pointer (node). So node.next = node.next.next\n5. Return head\n\nFor a 6-line implementation in JS you can look at my solution."
                    },
                    {
                        "username": "user8170Cm",
                        "content": "Hint: use a stack"
                    },
                    {
                        "username": "Fantaseaxx",
                        "content": "Dose anyone know what\\'s wrong with my code? Cant pass the test : head=[1],n=1 the output should be [ ],I ran my code in my IDE, shows the same results, but on Leetcode console output is [1]\\nclass Solution {\\n    static int cur =0;\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if(head == null) return null;\\n        head.next = removeNthFromEnd(head.next,n);\\n        cur++;\\n        if(cur == n) return head.next;\\n        return head;\\n\\n    }\\n}"
                    },
                    {
                        "username": "ravilsqrt",
                        "content": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n       arr = [head]\n        while arr[-1].next:\n            arr.append(arr[-1].next)\n        if len(arr) == 1:\n            return None\n\n        arr.pop(len(arr) - n)\n\n        cur_new = ListNode(arr[0].val)\n        for i in range(len(arr)):\n            if i != 0:\n                exec('cur_new{amount}'.format(amount='.next' * i + '= arr[i]'))\n        return cur_new\n\nI failed on 194 test with this solution, but I got correct answer in pycharm and online interpreter"
                    },
                    {
                        "username": "Amangupta97656",
                        "content": "IT\\'S EASY SOLUTION\\n\\n\\n\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        //if Single element list, thus returning empty list\\n        if(head.next == null)\\n            return null;\\n\\n        ListNode ptr = head;\\n        ListNode ptr2 = head;\\n\\n        int len = 0;\\n\\n        //finding the lenght of the list\\n        while(ptr != null)\\n        {\\n            len++;\\n            ptr = ptr.next;\\n        }\\n\\n        //required index\\n        int index = len - n;\\n        ptr = head;\\n\\n        boolean start = false;\\n\\n        while(true)\\n        {\\n            if(index == 0)\\n            {\\n                // if head element\\n                if(ptr == head)\\n                {\\n                    ptr2 = ptr2.next;\\n                    ptr.next = null;\\n                    head = ptr2;\\n                    break;\\n                }\\n\\n                else\\n                {\\n                    ptr2.next = ptr.next;\\n                    ptr.next = null;\\n                    break;\\n                }\\n            }\\n\\n            index--;\\n\\n            //for letting the second pointer start late\\n            if(start)\\n                ptr2 = ptr2.next;\\n\\n            start = true;\\n\\n            ptr = ptr.next;\\n        }    \\n\\n        return head;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It\\'s easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arpit_055",
                        "content": "I have compiled my solution \\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        for(int i=0;i<(n-1);i++){\\n            fast=fast->next;\\n        }\\n        while(fast->next!=nullptr){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        if(slow==head){\\n            head=head->next;\\n            delete slow;\\n            return head;\\n        }\\n        slow->next=slow->next->next;\\n        return head;\\n    }\\n\\nbut I\\'m keep getting this error member access within null pointer in this line /*slow->next=slow->next->next*/ ,I have also tried writing temp=slow->next and then slow->next=temp->next but it didn\\'t work.Is there any other way to write this line..\\n"
                    }
                ]
            },
            {
                "id": 1826013,
                "content": [
                    {
                        "username": "user4711ok",
                        "content": "Tearing my hair out; why does this give a runtime error?\\n\\nOk so I run these two pointers through the list, simple. One does it in a for loop and one does it unrolled. Looking at the stdout, the pointer in the loop goes through 5 times (as it should) but I get a runtime error trying to go through it unrolled. If I put a \"return if null\" statement beforehand, I still get a runtime error, so it\\'s not that it\\'s null.\\n\\nCame across this on the way to a solution. The error is:\\n\\nLine 26: Char 59: runtime error: member access within null pointer of type \\'const ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        const ListNode* scanPtr = head;\\n\\n        while(scanPtr)\\n        {\\n            printf(\"G: %X links to %X\\\\n\", scanPtr, scanPtr->next);\\n            scanPtr = scanPtr->next;\\n        }\\n\\n        const ListNode* breakPtr = head;\\n\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n        breakPtr = breakPtr->next;\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n\\n        printf(\"Done!\\\\n\");\\n\\n        return head;\\n    }"
                    },
                    {
                        "username": "vanavi",
                        "content": "Hi everybody! \\nI proposed a solution using method `.at()`.  And i prove it in my local server and works perfectly fine. But i test it in here and returns `TypeError: head.at is not a function`\\n\\nWhy i cant apply it in this problem? "
                    },
                    {
                        "username": "nklwwlkn",
                        "content": "Hey, \\n\\nIt\\'s a Linked list data structure, and not an array. You see the TypeError because the ListNode class doesn\\'t have an \"at\" method."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Everyone is doing it alright. But yall forgetting one if condition that\\'s it."
                    },
                    {
                        "username": "user3948b",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p=head,*q=head;\\n        int m =0;\\n        while(p!=NULL ) {\\n            m++;\\n            p=p->next;\\n        }\\n        for(int i=0;i<m-n;i++) {\\n            q=q->next;\\n        }\\n        ListNode *d= q->next;\\n        q->next = d->next;\\n       delete d;\\n        return head;\\n        \\n         }`\\nwhy this is not working"
                    },
                    {
                        "username": "cagils",
                        "content": "**O(1) 2-pointers approach, optimized algorithm explanation:**\n\n0. Assign fast pointer to head.next, slow pointer to the head (named 'node')\n1. Traverse the list from the head n-1 times with the fast pointer (named 'cur'). It started at head.next, so we have traversed the list now n times\n2. If you have arrived at null (edge case of head removal), return head.next\n3. Now we move both pointers at the same time until fast pointer (cur) reaches the end\n4. Remove the node next of the current slow pointer (node). So node.next = node.next.next\n5. Return head\n\nFor a 6-line implementation in JS you can look at my solution."
                    },
                    {
                        "username": "user8170Cm",
                        "content": "Hint: use a stack"
                    },
                    {
                        "username": "Fantaseaxx",
                        "content": "Dose anyone know what\\'s wrong with my code? Cant pass the test : head=[1],n=1 the output should be [ ],I ran my code in my IDE, shows the same results, but on Leetcode console output is [1]\\nclass Solution {\\n    static int cur =0;\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if(head == null) return null;\\n        head.next = removeNthFromEnd(head.next,n);\\n        cur++;\\n        if(cur == n) return head.next;\\n        return head;\\n\\n    }\\n}"
                    },
                    {
                        "username": "ravilsqrt",
                        "content": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n       arr = [head]\n        while arr[-1].next:\n            arr.append(arr[-1].next)\n        if len(arr) == 1:\n            return None\n\n        arr.pop(len(arr) - n)\n\n        cur_new = ListNode(arr[0].val)\n        for i in range(len(arr)):\n            if i != 0:\n                exec('cur_new{amount}'.format(amount='.next' * i + '= arr[i]'))\n        return cur_new\n\nI failed on 194 test with this solution, but I got correct answer in pycharm and online interpreter"
                    },
                    {
                        "username": "Amangupta97656",
                        "content": "IT\\'S EASY SOLUTION\\n\\n\\n\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        //if Single element list, thus returning empty list\\n        if(head.next == null)\\n            return null;\\n\\n        ListNode ptr = head;\\n        ListNode ptr2 = head;\\n\\n        int len = 0;\\n\\n        //finding the lenght of the list\\n        while(ptr != null)\\n        {\\n            len++;\\n            ptr = ptr.next;\\n        }\\n\\n        //required index\\n        int index = len - n;\\n        ptr = head;\\n\\n        boolean start = false;\\n\\n        while(true)\\n        {\\n            if(index == 0)\\n            {\\n                // if head element\\n                if(ptr == head)\\n                {\\n                    ptr2 = ptr2.next;\\n                    ptr.next = null;\\n                    head = ptr2;\\n                    break;\\n                }\\n\\n                else\\n                {\\n                    ptr2.next = ptr.next;\\n                    ptr.next = null;\\n                    break;\\n                }\\n            }\\n\\n            index--;\\n\\n            //for letting the second pointer start late\\n            if(start)\\n                ptr2 = ptr2.next;\\n\\n            start = true;\\n\\n            ptr = ptr.next;\\n        }    \\n\\n        return head;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It\\'s easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arpit_055",
                        "content": "I have compiled my solution \\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        for(int i=0;i<(n-1);i++){\\n            fast=fast->next;\\n        }\\n        while(fast->next!=nullptr){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        if(slow==head){\\n            head=head->next;\\n            delete slow;\\n            return head;\\n        }\\n        slow->next=slow->next->next;\\n        return head;\\n    }\\n\\nbut I\\'m keep getting this error member access within null pointer in this line /*slow->next=slow->next->next*/ ,I have also tried writing temp=slow->next and then slow->next=temp->next but it didn\\'t work.Is there any other way to write this line..\\n"
                    }
                ]
            },
            {
                "id": 1817380,
                "content": [
                    {
                        "username": "user4711ok",
                        "content": "Tearing my hair out; why does this give a runtime error?\\n\\nOk so I run these two pointers through the list, simple. One does it in a for loop and one does it unrolled. Looking at the stdout, the pointer in the loop goes through 5 times (as it should) but I get a runtime error trying to go through it unrolled. If I put a \"return if null\" statement beforehand, I still get a runtime error, so it\\'s not that it\\'s null.\\n\\nCame across this on the way to a solution. The error is:\\n\\nLine 26: Char 59: runtime error: member access within null pointer of type \\'const ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        const ListNode* scanPtr = head;\\n\\n        while(scanPtr)\\n        {\\n            printf(\"G: %X links to %X\\\\n\", scanPtr, scanPtr->next);\\n            scanPtr = scanPtr->next;\\n        }\\n\\n        const ListNode* breakPtr = head;\\n\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n        breakPtr = breakPtr->next;\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n\\n        printf(\"Done!\\\\n\");\\n\\n        return head;\\n    }"
                    },
                    {
                        "username": "vanavi",
                        "content": "Hi everybody! \\nI proposed a solution using method `.at()`.  And i prove it in my local server and works perfectly fine. But i test it in here and returns `TypeError: head.at is not a function`\\n\\nWhy i cant apply it in this problem? "
                    },
                    {
                        "username": "nklwwlkn",
                        "content": "Hey, \\n\\nIt\\'s a Linked list data structure, and not an array. You see the TypeError because the ListNode class doesn\\'t have an \"at\" method."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Everyone is doing it alright. But yall forgetting one if condition that\\'s it."
                    },
                    {
                        "username": "user3948b",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p=head,*q=head;\\n        int m =0;\\n        while(p!=NULL ) {\\n            m++;\\n            p=p->next;\\n        }\\n        for(int i=0;i<m-n;i++) {\\n            q=q->next;\\n        }\\n        ListNode *d= q->next;\\n        q->next = d->next;\\n       delete d;\\n        return head;\\n        \\n         }`\\nwhy this is not working"
                    },
                    {
                        "username": "cagils",
                        "content": "**O(1) 2-pointers approach, optimized algorithm explanation:**\n\n0. Assign fast pointer to head.next, slow pointer to the head (named 'node')\n1. Traverse the list from the head n-1 times with the fast pointer (named 'cur'). It started at head.next, so we have traversed the list now n times\n2. If you have arrived at null (edge case of head removal), return head.next\n3. Now we move both pointers at the same time until fast pointer (cur) reaches the end\n4. Remove the node next of the current slow pointer (node). So node.next = node.next.next\n5. Return head\n\nFor a 6-line implementation in JS you can look at my solution."
                    },
                    {
                        "username": "user8170Cm",
                        "content": "Hint: use a stack"
                    },
                    {
                        "username": "Fantaseaxx",
                        "content": "Dose anyone know what\\'s wrong with my code? Cant pass the test : head=[1],n=1 the output should be [ ],I ran my code in my IDE, shows the same results, but on Leetcode console output is [1]\\nclass Solution {\\n    static int cur =0;\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if(head == null) return null;\\n        head.next = removeNthFromEnd(head.next,n);\\n        cur++;\\n        if(cur == n) return head.next;\\n        return head;\\n\\n    }\\n}"
                    },
                    {
                        "username": "ravilsqrt",
                        "content": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n       arr = [head]\n        while arr[-1].next:\n            arr.append(arr[-1].next)\n        if len(arr) == 1:\n            return None\n\n        arr.pop(len(arr) - n)\n\n        cur_new = ListNode(arr[0].val)\n        for i in range(len(arr)):\n            if i != 0:\n                exec('cur_new{amount}'.format(amount='.next' * i + '= arr[i]'))\n        return cur_new\n\nI failed on 194 test with this solution, but I got correct answer in pycharm and online interpreter"
                    },
                    {
                        "username": "Amangupta97656",
                        "content": "IT\\'S EASY SOLUTION\\n\\n\\n\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        //if Single element list, thus returning empty list\\n        if(head.next == null)\\n            return null;\\n\\n        ListNode ptr = head;\\n        ListNode ptr2 = head;\\n\\n        int len = 0;\\n\\n        //finding the lenght of the list\\n        while(ptr != null)\\n        {\\n            len++;\\n            ptr = ptr.next;\\n        }\\n\\n        //required index\\n        int index = len - n;\\n        ptr = head;\\n\\n        boolean start = false;\\n\\n        while(true)\\n        {\\n            if(index == 0)\\n            {\\n                // if head element\\n                if(ptr == head)\\n                {\\n                    ptr2 = ptr2.next;\\n                    ptr.next = null;\\n                    head = ptr2;\\n                    break;\\n                }\\n\\n                else\\n                {\\n                    ptr2.next = ptr.next;\\n                    ptr.next = null;\\n                    break;\\n                }\\n            }\\n\\n            index--;\\n\\n            //for letting the second pointer start late\\n            if(start)\\n                ptr2 = ptr2.next;\\n\\n            start = true;\\n\\n            ptr = ptr.next;\\n        }    \\n\\n        return head;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It\\'s easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arpit_055",
                        "content": "I have compiled my solution \\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        for(int i=0;i<(n-1);i++){\\n            fast=fast->next;\\n        }\\n        while(fast->next!=nullptr){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        if(slow==head){\\n            head=head->next;\\n            delete slow;\\n            return head;\\n        }\\n        slow->next=slow->next->next;\\n        return head;\\n    }\\n\\nbut I\\'m keep getting this error member access within null pointer in this line /*slow->next=slow->next->next*/ ,I have also tried writing temp=slow->next and then slow->next=temp->next but it didn\\'t work.Is there any other way to write this line..\\n"
                    }
                ]
            },
            {
                "id": 1807847,
                "content": [
                    {
                        "username": "user4711ok",
                        "content": "Tearing my hair out; why does this give a runtime error?\\n\\nOk so I run these two pointers through the list, simple. One does it in a for loop and one does it unrolled. Looking at the stdout, the pointer in the loop goes through 5 times (as it should) but I get a runtime error trying to go through it unrolled. If I put a \"return if null\" statement beforehand, I still get a runtime error, so it\\'s not that it\\'s null.\\n\\nCame across this on the way to a solution. The error is:\\n\\nLine 26: Char 59: runtime error: member access within null pointer of type \\'const ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        const ListNode* scanPtr = head;\\n\\n        while(scanPtr)\\n        {\\n            printf(\"G: %X links to %X\\\\n\", scanPtr, scanPtr->next);\\n            scanPtr = scanPtr->next;\\n        }\\n\\n        const ListNode* breakPtr = head;\\n\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n        breakPtr = breakPtr->next;\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n\\n        printf(\"Done!\\\\n\");\\n\\n        return head;\\n    }"
                    },
                    {
                        "username": "vanavi",
                        "content": "Hi everybody! \\nI proposed a solution using method `.at()`.  And i prove it in my local server and works perfectly fine. But i test it in here and returns `TypeError: head.at is not a function`\\n\\nWhy i cant apply it in this problem? "
                    },
                    {
                        "username": "nklwwlkn",
                        "content": "Hey, \\n\\nIt\\'s a Linked list data structure, and not an array. You see the TypeError because the ListNode class doesn\\'t have an \"at\" method."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Everyone is doing it alright. But yall forgetting one if condition that\\'s it."
                    },
                    {
                        "username": "user3948b",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p=head,*q=head;\\n        int m =0;\\n        while(p!=NULL ) {\\n            m++;\\n            p=p->next;\\n        }\\n        for(int i=0;i<m-n;i++) {\\n            q=q->next;\\n        }\\n        ListNode *d= q->next;\\n        q->next = d->next;\\n       delete d;\\n        return head;\\n        \\n         }`\\nwhy this is not working"
                    },
                    {
                        "username": "cagils",
                        "content": "**O(1) 2-pointers approach, optimized algorithm explanation:**\n\n0. Assign fast pointer to head.next, slow pointer to the head (named 'node')\n1. Traverse the list from the head n-1 times with the fast pointer (named 'cur'). It started at head.next, so we have traversed the list now n times\n2. If you have arrived at null (edge case of head removal), return head.next\n3. Now we move both pointers at the same time until fast pointer (cur) reaches the end\n4. Remove the node next of the current slow pointer (node). So node.next = node.next.next\n5. Return head\n\nFor a 6-line implementation in JS you can look at my solution."
                    },
                    {
                        "username": "user8170Cm",
                        "content": "Hint: use a stack"
                    },
                    {
                        "username": "Fantaseaxx",
                        "content": "Dose anyone know what\\'s wrong with my code? Cant pass the test : head=[1],n=1 the output should be [ ],I ran my code in my IDE, shows the same results, but on Leetcode console output is [1]\\nclass Solution {\\n    static int cur =0;\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if(head == null) return null;\\n        head.next = removeNthFromEnd(head.next,n);\\n        cur++;\\n        if(cur == n) return head.next;\\n        return head;\\n\\n    }\\n}"
                    },
                    {
                        "username": "ravilsqrt",
                        "content": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n       arr = [head]\n        while arr[-1].next:\n            arr.append(arr[-1].next)\n        if len(arr) == 1:\n            return None\n\n        arr.pop(len(arr) - n)\n\n        cur_new = ListNode(arr[0].val)\n        for i in range(len(arr)):\n            if i != 0:\n                exec('cur_new{amount}'.format(amount='.next' * i + '= arr[i]'))\n        return cur_new\n\nI failed on 194 test with this solution, but I got correct answer in pycharm and online interpreter"
                    },
                    {
                        "username": "Amangupta97656",
                        "content": "IT\\'S EASY SOLUTION\\n\\n\\n\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        //if Single element list, thus returning empty list\\n        if(head.next == null)\\n            return null;\\n\\n        ListNode ptr = head;\\n        ListNode ptr2 = head;\\n\\n        int len = 0;\\n\\n        //finding the lenght of the list\\n        while(ptr != null)\\n        {\\n            len++;\\n            ptr = ptr.next;\\n        }\\n\\n        //required index\\n        int index = len - n;\\n        ptr = head;\\n\\n        boolean start = false;\\n\\n        while(true)\\n        {\\n            if(index == 0)\\n            {\\n                // if head element\\n                if(ptr == head)\\n                {\\n                    ptr2 = ptr2.next;\\n                    ptr.next = null;\\n                    head = ptr2;\\n                    break;\\n                }\\n\\n                else\\n                {\\n                    ptr2.next = ptr.next;\\n                    ptr.next = null;\\n                    break;\\n                }\\n            }\\n\\n            index--;\\n\\n            //for letting the second pointer start late\\n            if(start)\\n                ptr2 = ptr2.next;\\n\\n            start = true;\\n\\n            ptr = ptr.next;\\n        }    \\n\\n        return head;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It\\'s easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arpit_055",
                        "content": "I have compiled my solution \\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        for(int i=0;i<(n-1);i++){\\n            fast=fast->next;\\n        }\\n        while(fast->next!=nullptr){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        if(slow==head){\\n            head=head->next;\\n            delete slow;\\n            return head;\\n        }\\n        slow->next=slow->next->next;\\n        return head;\\n    }\\n\\nbut I\\'m keep getting this error member access within null pointer in this line /*slow->next=slow->next->next*/ ,I have also tried writing temp=slow->next and then slow->next=temp->next but it didn\\'t work.Is there any other way to write this line..\\n"
                    }
                ]
            },
            {
                "id": 1807283,
                "content": [
                    {
                        "username": "user4711ok",
                        "content": "Tearing my hair out; why does this give a runtime error?\\n\\nOk so I run these two pointers through the list, simple. One does it in a for loop and one does it unrolled. Looking at the stdout, the pointer in the loop goes through 5 times (as it should) but I get a runtime error trying to go through it unrolled. If I put a \"return if null\" statement beforehand, I still get a runtime error, so it\\'s not that it\\'s null.\\n\\nCame across this on the way to a solution. The error is:\\n\\nLine 26: Char 59: runtime error: member access within null pointer of type \\'const ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        const ListNode* scanPtr = head;\\n\\n        while(scanPtr)\\n        {\\n            printf(\"G: %X links to %X\\\\n\", scanPtr, scanPtr->next);\\n            scanPtr = scanPtr->next;\\n        }\\n\\n        const ListNode* breakPtr = head;\\n\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n        breakPtr = breakPtr->next;\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n\\n        printf(\"Done!\\\\n\");\\n\\n        return head;\\n    }"
                    },
                    {
                        "username": "vanavi",
                        "content": "Hi everybody! \\nI proposed a solution using method `.at()`.  And i prove it in my local server and works perfectly fine. But i test it in here and returns `TypeError: head.at is not a function`\\n\\nWhy i cant apply it in this problem? "
                    },
                    {
                        "username": "nklwwlkn",
                        "content": "Hey, \\n\\nIt\\'s a Linked list data structure, and not an array. You see the TypeError because the ListNode class doesn\\'t have an \"at\" method."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Everyone is doing it alright. But yall forgetting one if condition that\\'s it."
                    },
                    {
                        "username": "user3948b",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p=head,*q=head;\\n        int m =0;\\n        while(p!=NULL ) {\\n            m++;\\n            p=p->next;\\n        }\\n        for(int i=0;i<m-n;i++) {\\n            q=q->next;\\n        }\\n        ListNode *d= q->next;\\n        q->next = d->next;\\n       delete d;\\n        return head;\\n        \\n         }`\\nwhy this is not working"
                    },
                    {
                        "username": "cagils",
                        "content": "**O(1) 2-pointers approach, optimized algorithm explanation:**\n\n0. Assign fast pointer to head.next, slow pointer to the head (named 'node')\n1. Traverse the list from the head n-1 times with the fast pointer (named 'cur'). It started at head.next, so we have traversed the list now n times\n2. If you have arrived at null (edge case of head removal), return head.next\n3. Now we move both pointers at the same time until fast pointer (cur) reaches the end\n4. Remove the node next of the current slow pointer (node). So node.next = node.next.next\n5. Return head\n\nFor a 6-line implementation in JS you can look at my solution."
                    },
                    {
                        "username": "user8170Cm",
                        "content": "Hint: use a stack"
                    },
                    {
                        "username": "Fantaseaxx",
                        "content": "Dose anyone know what\\'s wrong with my code? Cant pass the test : head=[1],n=1 the output should be [ ],I ran my code in my IDE, shows the same results, but on Leetcode console output is [1]\\nclass Solution {\\n    static int cur =0;\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if(head == null) return null;\\n        head.next = removeNthFromEnd(head.next,n);\\n        cur++;\\n        if(cur == n) return head.next;\\n        return head;\\n\\n    }\\n}"
                    },
                    {
                        "username": "ravilsqrt",
                        "content": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n       arr = [head]\n        while arr[-1].next:\n            arr.append(arr[-1].next)\n        if len(arr) == 1:\n            return None\n\n        arr.pop(len(arr) - n)\n\n        cur_new = ListNode(arr[0].val)\n        for i in range(len(arr)):\n            if i != 0:\n                exec('cur_new{amount}'.format(amount='.next' * i + '= arr[i]'))\n        return cur_new\n\nI failed on 194 test with this solution, but I got correct answer in pycharm and online interpreter"
                    },
                    {
                        "username": "Amangupta97656",
                        "content": "IT\\'S EASY SOLUTION\\n\\n\\n\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        //if Single element list, thus returning empty list\\n        if(head.next == null)\\n            return null;\\n\\n        ListNode ptr = head;\\n        ListNode ptr2 = head;\\n\\n        int len = 0;\\n\\n        //finding the lenght of the list\\n        while(ptr != null)\\n        {\\n            len++;\\n            ptr = ptr.next;\\n        }\\n\\n        //required index\\n        int index = len - n;\\n        ptr = head;\\n\\n        boolean start = false;\\n\\n        while(true)\\n        {\\n            if(index == 0)\\n            {\\n                // if head element\\n                if(ptr == head)\\n                {\\n                    ptr2 = ptr2.next;\\n                    ptr.next = null;\\n                    head = ptr2;\\n                    break;\\n                }\\n\\n                else\\n                {\\n                    ptr2.next = ptr.next;\\n                    ptr.next = null;\\n                    break;\\n                }\\n            }\\n\\n            index--;\\n\\n            //for letting the second pointer start late\\n            if(start)\\n                ptr2 = ptr2.next;\\n\\n            start = true;\\n\\n            ptr = ptr.next;\\n        }    \\n\\n        return head;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It\\'s easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arpit_055",
                        "content": "I have compiled my solution \\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        for(int i=0;i<(n-1);i++){\\n            fast=fast->next;\\n        }\\n        while(fast->next!=nullptr){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        if(slow==head){\\n            head=head->next;\\n            delete slow;\\n            return head;\\n        }\\n        slow->next=slow->next->next;\\n        return head;\\n    }\\n\\nbut I\\'m keep getting this error member access within null pointer in this line /*slow->next=slow->next->next*/ ,I have also tried writing temp=slow->next and then slow->next=temp->next but it didn\\'t work.Is there any other way to write this line..\\n"
                    }
                ]
            },
            {
                "id": 1806956,
                "content": [
                    {
                        "username": "user4711ok",
                        "content": "Tearing my hair out; why does this give a runtime error?\\n\\nOk so I run these two pointers through the list, simple. One does it in a for loop and one does it unrolled. Looking at the stdout, the pointer in the loop goes through 5 times (as it should) but I get a runtime error trying to go through it unrolled. If I put a \"return if null\" statement beforehand, I still get a runtime error, so it\\'s not that it\\'s null.\\n\\nCame across this on the way to a solution. The error is:\\n\\nLine 26: Char 59: runtime error: member access within null pointer of type \\'const ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        const ListNode* scanPtr = head;\\n\\n        while(scanPtr)\\n        {\\n            printf(\"G: %X links to %X\\\\n\", scanPtr, scanPtr->next);\\n            scanPtr = scanPtr->next;\\n        }\\n\\n        const ListNode* breakPtr = head;\\n\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n        breakPtr = breakPtr->next;\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n\\n        printf(\"Done!\\\\n\");\\n\\n        return head;\\n    }"
                    },
                    {
                        "username": "vanavi",
                        "content": "Hi everybody! \\nI proposed a solution using method `.at()`.  And i prove it in my local server and works perfectly fine. But i test it in here and returns `TypeError: head.at is not a function`\\n\\nWhy i cant apply it in this problem? "
                    },
                    {
                        "username": "nklwwlkn",
                        "content": "Hey, \\n\\nIt\\'s a Linked list data structure, and not an array. You see the TypeError because the ListNode class doesn\\'t have an \"at\" method."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Everyone is doing it alright. But yall forgetting one if condition that\\'s it."
                    },
                    {
                        "username": "user3948b",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p=head,*q=head;\\n        int m =0;\\n        while(p!=NULL ) {\\n            m++;\\n            p=p->next;\\n        }\\n        for(int i=0;i<m-n;i++) {\\n            q=q->next;\\n        }\\n        ListNode *d= q->next;\\n        q->next = d->next;\\n       delete d;\\n        return head;\\n        \\n         }`\\nwhy this is not working"
                    },
                    {
                        "username": "cagils",
                        "content": "**O(1) 2-pointers approach, optimized algorithm explanation:**\n\n0. Assign fast pointer to head.next, slow pointer to the head (named 'node')\n1. Traverse the list from the head n-1 times with the fast pointer (named 'cur'). It started at head.next, so we have traversed the list now n times\n2. If you have arrived at null (edge case of head removal), return head.next\n3. Now we move both pointers at the same time until fast pointer (cur) reaches the end\n4. Remove the node next of the current slow pointer (node). So node.next = node.next.next\n5. Return head\n\nFor a 6-line implementation in JS you can look at my solution."
                    },
                    {
                        "username": "user8170Cm",
                        "content": "Hint: use a stack"
                    },
                    {
                        "username": "Fantaseaxx",
                        "content": "Dose anyone know what\\'s wrong with my code? Cant pass the test : head=[1],n=1 the output should be [ ],I ran my code in my IDE, shows the same results, but on Leetcode console output is [1]\\nclass Solution {\\n    static int cur =0;\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if(head == null) return null;\\n        head.next = removeNthFromEnd(head.next,n);\\n        cur++;\\n        if(cur == n) return head.next;\\n        return head;\\n\\n    }\\n}"
                    },
                    {
                        "username": "ravilsqrt",
                        "content": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n       arr = [head]\n        while arr[-1].next:\n            arr.append(arr[-1].next)\n        if len(arr) == 1:\n            return None\n\n        arr.pop(len(arr) - n)\n\n        cur_new = ListNode(arr[0].val)\n        for i in range(len(arr)):\n            if i != 0:\n                exec('cur_new{amount}'.format(amount='.next' * i + '= arr[i]'))\n        return cur_new\n\nI failed on 194 test with this solution, but I got correct answer in pycharm and online interpreter"
                    },
                    {
                        "username": "Amangupta97656",
                        "content": "IT\\'S EASY SOLUTION\\n\\n\\n\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        //if Single element list, thus returning empty list\\n        if(head.next == null)\\n            return null;\\n\\n        ListNode ptr = head;\\n        ListNode ptr2 = head;\\n\\n        int len = 0;\\n\\n        //finding the lenght of the list\\n        while(ptr != null)\\n        {\\n            len++;\\n            ptr = ptr.next;\\n        }\\n\\n        //required index\\n        int index = len - n;\\n        ptr = head;\\n\\n        boolean start = false;\\n\\n        while(true)\\n        {\\n            if(index == 0)\\n            {\\n                // if head element\\n                if(ptr == head)\\n                {\\n                    ptr2 = ptr2.next;\\n                    ptr.next = null;\\n                    head = ptr2;\\n                    break;\\n                }\\n\\n                else\\n                {\\n                    ptr2.next = ptr.next;\\n                    ptr.next = null;\\n                    break;\\n                }\\n            }\\n\\n            index--;\\n\\n            //for letting the second pointer start late\\n            if(start)\\n                ptr2 = ptr2.next;\\n\\n            start = true;\\n\\n            ptr = ptr.next;\\n        }    \\n\\n        return head;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It\\'s easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arpit_055",
                        "content": "I have compiled my solution \\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        for(int i=0;i<(n-1);i++){\\n            fast=fast->next;\\n        }\\n        while(fast->next!=nullptr){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        if(slow==head){\\n            head=head->next;\\n            delete slow;\\n            return head;\\n        }\\n        slow->next=slow->next->next;\\n        return head;\\n    }\\n\\nbut I\\'m keep getting this error member access within null pointer in this line /*slow->next=slow->next->next*/ ,I have also tried writing temp=slow->next and then slow->next=temp->next but it didn\\'t work.Is there any other way to write this line..\\n"
                    }
                ]
            },
            {
                "id": 1803178,
                "content": [
                    {
                        "username": "user4711ok",
                        "content": "Tearing my hair out; why does this give a runtime error?\\n\\nOk so I run these two pointers through the list, simple. One does it in a for loop and one does it unrolled. Looking at the stdout, the pointer in the loop goes through 5 times (as it should) but I get a runtime error trying to go through it unrolled. If I put a \"return if null\" statement beforehand, I still get a runtime error, so it\\'s not that it\\'s null.\\n\\nCame across this on the way to a solution. The error is:\\n\\nLine 26: Char 59: runtime error: member access within null pointer of type \\'const ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        const ListNode* scanPtr = head;\\n\\n        while(scanPtr)\\n        {\\n            printf(\"G: %X links to %X\\\\n\", scanPtr, scanPtr->next);\\n            scanPtr = scanPtr->next;\\n        }\\n\\n        const ListNode* breakPtr = head;\\n\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n        breakPtr = breakPtr->next;\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n\\n        printf(\"Done!\\\\n\");\\n\\n        return head;\\n    }"
                    },
                    {
                        "username": "vanavi",
                        "content": "Hi everybody! \\nI proposed a solution using method `.at()`.  And i prove it in my local server and works perfectly fine. But i test it in here and returns `TypeError: head.at is not a function`\\n\\nWhy i cant apply it in this problem? "
                    },
                    {
                        "username": "nklwwlkn",
                        "content": "Hey, \\n\\nIt\\'s a Linked list data structure, and not an array. You see the TypeError because the ListNode class doesn\\'t have an \"at\" method."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Everyone is doing it alright. But yall forgetting one if condition that\\'s it."
                    },
                    {
                        "username": "user3948b",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p=head,*q=head;\\n        int m =0;\\n        while(p!=NULL ) {\\n            m++;\\n            p=p->next;\\n        }\\n        for(int i=0;i<m-n;i++) {\\n            q=q->next;\\n        }\\n        ListNode *d= q->next;\\n        q->next = d->next;\\n       delete d;\\n        return head;\\n        \\n         }`\\nwhy this is not working"
                    },
                    {
                        "username": "cagils",
                        "content": "**O(1) 2-pointers approach, optimized algorithm explanation:**\n\n0. Assign fast pointer to head.next, slow pointer to the head (named 'node')\n1. Traverse the list from the head n-1 times with the fast pointer (named 'cur'). It started at head.next, so we have traversed the list now n times\n2. If you have arrived at null (edge case of head removal), return head.next\n3. Now we move both pointers at the same time until fast pointer (cur) reaches the end\n4. Remove the node next of the current slow pointer (node). So node.next = node.next.next\n5. Return head\n\nFor a 6-line implementation in JS you can look at my solution."
                    },
                    {
                        "username": "user8170Cm",
                        "content": "Hint: use a stack"
                    },
                    {
                        "username": "Fantaseaxx",
                        "content": "Dose anyone know what\\'s wrong with my code? Cant pass the test : head=[1],n=1 the output should be [ ],I ran my code in my IDE, shows the same results, but on Leetcode console output is [1]\\nclass Solution {\\n    static int cur =0;\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if(head == null) return null;\\n        head.next = removeNthFromEnd(head.next,n);\\n        cur++;\\n        if(cur == n) return head.next;\\n        return head;\\n\\n    }\\n}"
                    },
                    {
                        "username": "ravilsqrt",
                        "content": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n       arr = [head]\n        while arr[-1].next:\n            arr.append(arr[-1].next)\n        if len(arr) == 1:\n            return None\n\n        arr.pop(len(arr) - n)\n\n        cur_new = ListNode(arr[0].val)\n        for i in range(len(arr)):\n            if i != 0:\n                exec('cur_new{amount}'.format(amount='.next' * i + '= arr[i]'))\n        return cur_new\n\nI failed on 194 test with this solution, but I got correct answer in pycharm and online interpreter"
                    },
                    {
                        "username": "Amangupta97656",
                        "content": "IT\\'S EASY SOLUTION\\n\\n\\n\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        //if Single element list, thus returning empty list\\n        if(head.next == null)\\n            return null;\\n\\n        ListNode ptr = head;\\n        ListNode ptr2 = head;\\n\\n        int len = 0;\\n\\n        //finding the lenght of the list\\n        while(ptr != null)\\n        {\\n            len++;\\n            ptr = ptr.next;\\n        }\\n\\n        //required index\\n        int index = len - n;\\n        ptr = head;\\n\\n        boolean start = false;\\n\\n        while(true)\\n        {\\n            if(index == 0)\\n            {\\n                // if head element\\n                if(ptr == head)\\n                {\\n                    ptr2 = ptr2.next;\\n                    ptr.next = null;\\n                    head = ptr2;\\n                    break;\\n                }\\n\\n                else\\n                {\\n                    ptr2.next = ptr.next;\\n                    ptr.next = null;\\n                    break;\\n                }\\n            }\\n\\n            index--;\\n\\n            //for letting the second pointer start late\\n            if(start)\\n                ptr2 = ptr2.next;\\n\\n            start = true;\\n\\n            ptr = ptr.next;\\n        }    \\n\\n        return head;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It\\'s easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arpit_055",
                        "content": "I have compiled my solution \\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        for(int i=0;i<(n-1);i++){\\n            fast=fast->next;\\n        }\\n        while(fast->next!=nullptr){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        if(slow==head){\\n            head=head->next;\\n            delete slow;\\n            return head;\\n        }\\n        slow->next=slow->next->next;\\n        return head;\\n    }\\n\\nbut I\\'m keep getting this error member access within null pointer in this line /*slow->next=slow->next->next*/ ,I have also tried writing temp=slow->next and then slow->next=temp->next but it didn\\'t work.Is there any other way to write this line..\\n"
                    }
                ]
            },
            {
                "id": 1798329,
                "content": [
                    {
                        "username": "iamravirajesh",
                        "content": "Class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n         ListNode curr = head;\\n         int cnt=0;\\n         \\n         while(curr!=null)\\n         {\\n             cnt++;\\n             curr=curr.next;\\n         }\\n         curr=head;\\n         cnt=cnt-n;\\n\\n         if(cnt==0)\\n         {\\n             curr.val=curr.next.val;\\n             curr.next=curr.next.next;\\n         }\\n\\n         while(cnt>1)\\n         {\\n             cnt--;\\n             curr=curr.next;\\n         }\\n\\n         curr.next=curr.next.next;\\n\\n         return head;\\n    }\\n}\\n\\ncan someone please explain what\\'s wrong with my code? It is giving null pointer error at  \"curr.val=curr.next.val;\" ans \"curr.next=curr.next.next;\""
                    },
                    {
                        "username": "Drakath2812",
                        "content": "I don\\'t follow the logic of the problem, I can\\'t work out which node is supposed to be removed, the numbering in the examples given seem inconsistent at best, and when I thought i\\'d figured it out, apparently [1,2] and n=2, should return 2? why?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python Question...\\n\\nI understand that one of the objects of this problem is to look at this as a problem in C. There are no such things as linked lists in C. But there are in Python and to force a python programmer to ignore this doesn\\'t make sense. The solution to this problem utilizing a linked list and popping an element out of it is two lines of code (and the second line is a return statement). It seems to me that if the programming language that we are using has built in commands that allow us to do things more efficiently then Leetcode should allow us to use them. Can anyone explain to me why we can\\'t?\\n\\nThanks in advance."
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n\\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n\\n        //If node to be remove is the first node from starting .i.e head node\\n        if (fast == NULL){\\n            slow = slow->next;\\n            delete head;\\n            return slow;\\n        } \\n    \\n        \\n        while (fast->next!=NULL)\\n           fast = fast->next, slow = slow->next;\\n\\n        ListNode *temp = slow->next;\\n        slow->next = slow->next->next;\\n        delete temp;\\n        \\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lionezzz",
                        "content": "Some utility code for those who don\\'t use LeetCode\\'s environment for tests and use other IDE:\\n\\npublic static void main(String[] args) {\\n    int[] nodes = {1,2,3,4,5};\\n    int n = 2;\\n    ListNode head = constructListNode(nodes);\\n    ListNode result = new Solution().removeNthFromEnd(head, n);\\n    System.out.println(result == null ? \"[]\" : result.toString());\\n}\\n\\npublic static ListNode constructListNode(int[] nodes) {\\n    ListNode current = new ListNode(nodes[nodes.length - 1]);\\n    for (int i = nodes.length - 2; i >= 0; i--) {\\n        current = new ListNode(nodes[i], current);\\n    }\\n    return current;\\n}\\n\\npublic static class ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {\\n    }\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"[\" + val + (next == null ? \"]\" : \", \" + next.toStringInner() + \"]\");\\n    }\\n\\n    public String toStringInner() {\\n        return val + (next == null ? \"\" : \", \" + next.toStringInner());\\n    }\\n}"
                    },
                    {
                        "username": "propercthulhu",
                        "content": "What is the python3 solution here for the input of [1], as you literally cannot delete the val attribute with any form of del or delattr, as you repeatedly get an AttributeError. Literally only case that won\\'t pass and all my attempts to return what they expect fails."
                    },
                    {
                        "username": "AlanD88",
                        "content": "Can someone explain testcase 22 for me?\\n\\n`head = [1,2]\\nn = 2`\\n\\nWe\\'re supposed to remove the nth node.  So in this case we remove the node at index 2, which is 2.\\n\\nBut the test case removes node at position one and shows head to point to node with val 2?  \\n\\nIm so confused"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhila01](/nikhila01) Thank you! I was having the same question. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're supposed to remove the nth node _counting from the end_. `n = 1` means remove the last node. `n = 2` means remove the second last node.\n\nSo for `head = [1,2] n = 2` you need to remove the second last node, which is `1`.  That means the result is `[2]`."
                    },
                    {
                        "username": "smartnealll",
                        "content": "I get a NullPointerException, and it said there is a bug at 25 line(check.next = check.next.next;). However, I debug it. Before line 25, the check is [3, 4, 5]. I think my line 25 is correct, but it said  cannot read field because \"\"<local3>.next\" is null. Can anyone please give me some suggestion?\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode check = head;\\n        int count = 1;\\n        while(check.next != null) {\\n        check = check.next;\\n            count++;\\n        }\\n        count = count - n - 1;\\n        check = head;\\n        while(count > 0) {\\n            check = check.next;\\n            count--;\\n        }\\n        check.next = check.next.next;\\n        return check; \\n    }\\n\\n\\n\\n"
                    },
                    {
                        "username": "badmusamuda",
                        "content": "Runtime: 0 ms, Beats : 100%\\nMemory:40.5 MB, Beats 90 to 64.30%\\n\\n[1.] Reverse the ListNode by adding from the tail\\n\\n `ListNode cp = null;\\n        ListNode temp = head;\\n        while(temp != null){\\n            cp = new ListNode(temp.val, cp);\\n            temp = temp.next;\\n        }`\\n\\n\\n[2.] Re-add, and skip when the condition is satisfied\\n\\n`int start = 1;\\n        temp = null;\\n        while (cp != null){\\n            if(start != n){\\n                temp = new ListNode(cp.val, temp);\\n            }\\n            cp = cp.next;\\n            start++;\\n        }\\n        cp = null;\\n        return temp;`"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int length = 0;\\n        ListNode* temp = head;\\n\\n\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        \\n        \\n        if(length==1 && n==1){  //EDGE CASE1\\n            return NULL;\\n        }\\n        \\n\\n        length = length-n;\\n        if(length==0){\\n            return head->next; //EDGE CASE2\\n        }\\n        int count =0;\\n        ListNode* temp1 = head;\\n\\n\\n\\n        while(temp1){\\n            count++;\\n            if(count==length){\\n                ListNode* sub=temp1->next;\\n                temp1->next=sub->next ;\\n                return head;\\n            }\\n            temp1=temp1->next;\\n        }\\n        return head;\\n    }\\n\\nJust take a counter variable to count length of an linkedlist and then do length-n to get the position, now iterate over linkedlist again until you get that point, once you get that node you can remove to get your answer. \\n\\nThere are 2 further edge cases which I have mentioned above."
                    }
                ]
            },
            {
                "id": 1794340,
                "content": [
                    {
                        "username": "iamravirajesh",
                        "content": "Class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n         ListNode curr = head;\\n         int cnt=0;\\n         \\n         while(curr!=null)\\n         {\\n             cnt++;\\n             curr=curr.next;\\n         }\\n         curr=head;\\n         cnt=cnt-n;\\n\\n         if(cnt==0)\\n         {\\n             curr.val=curr.next.val;\\n             curr.next=curr.next.next;\\n         }\\n\\n         while(cnt>1)\\n         {\\n             cnt--;\\n             curr=curr.next;\\n         }\\n\\n         curr.next=curr.next.next;\\n\\n         return head;\\n    }\\n}\\n\\ncan someone please explain what\\'s wrong with my code? It is giving null pointer error at  \"curr.val=curr.next.val;\" ans \"curr.next=curr.next.next;\""
                    },
                    {
                        "username": "Drakath2812",
                        "content": "I don\\'t follow the logic of the problem, I can\\'t work out which node is supposed to be removed, the numbering in the examples given seem inconsistent at best, and when I thought i\\'d figured it out, apparently [1,2] and n=2, should return 2? why?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python Question...\\n\\nI understand that one of the objects of this problem is to look at this as a problem in C. There are no such things as linked lists in C. But there are in Python and to force a python programmer to ignore this doesn\\'t make sense. The solution to this problem utilizing a linked list and popping an element out of it is two lines of code (and the second line is a return statement). It seems to me that if the programming language that we are using has built in commands that allow us to do things more efficiently then Leetcode should allow us to use them. Can anyone explain to me why we can\\'t?\\n\\nThanks in advance."
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n\\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n\\n        //If node to be remove is the first node from starting .i.e head node\\n        if (fast == NULL){\\n            slow = slow->next;\\n            delete head;\\n            return slow;\\n        } \\n    \\n        \\n        while (fast->next!=NULL)\\n           fast = fast->next, slow = slow->next;\\n\\n        ListNode *temp = slow->next;\\n        slow->next = slow->next->next;\\n        delete temp;\\n        \\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lionezzz",
                        "content": "Some utility code for those who don\\'t use LeetCode\\'s environment for tests and use other IDE:\\n\\npublic static void main(String[] args) {\\n    int[] nodes = {1,2,3,4,5};\\n    int n = 2;\\n    ListNode head = constructListNode(nodes);\\n    ListNode result = new Solution().removeNthFromEnd(head, n);\\n    System.out.println(result == null ? \"[]\" : result.toString());\\n}\\n\\npublic static ListNode constructListNode(int[] nodes) {\\n    ListNode current = new ListNode(nodes[nodes.length - 1]);\\n    for (int i = nodes.length - 2; i >= 0; i--) {\\n        current = new ListNode(nodes[i], current);\\n    }\\n    return current;\\n}\\n\\npublic static class ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {\\n    }\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"[\" + val + (next == null ? \"]\" : \", \" + next.toStringInner() + \"]\");\\n    }\\n\\n    public String toStringInner() {\\n        return val + (next == null ? \"\" : \", \" + next.toStringInner());\\n    }\\n}"
                    },
                    {
                        "username": "propercthulhu",
                        "content": "What is the python3 solution here for the input of [1], as you literally cannot delete the val attribute with any form of del or delattr, as you repeatedly get an AttributeError. Literally only case that won\\'t pass and all my attempts to return what they expect fails."
                    },
                    {
                        "username": "AlanD88",
                        "content": "Can someone explain testcase 22 for me?\\n\\n`head = [1,2]\\nn = 2`\\n\\nWe\\'re supposed to remove the nth node.  So in this case we remove the node at index 2, which is 2.\\n\\nBut the test case removes node at position one and shows head to point to node with val 2?  \\n\\nIm so confused"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhila01](/nikhila01) Thank you! I was having the same question. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're supposed to remove the nth node _counting from the end_. `n = 1` means remove the last node. `n = 2` means remove the second last node.\n\nSo for `head = [1,2] n = 2` you need to remove the second last node, which is `1`.  That means the result is `[2]`."
                    },
                    {
                        "username": "smartnealll",
                        "content": "I get a NullPointerException, and it said there is a bug at 25 line(check.next = check.next.next;). However, I debug it. Before line 25, the check is [3, 4, 5]. I think my line 25 is correct, but it said  cannot read field because \"\"<local3>.next\" is null. Can anyone please give me some suggestion?\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode check = head;\\n        int count = 1;\\n        while(check.next != null) {\\n        check = check.next;\\n            count++;\\n        }\\n        count = count - n - 1;\\n        check = head;\\n        while(count > 0) {\\n            check = check.next;\\n            count--;\\n        }\\n        check.next = check.next.next;\\n        return check; \\n    }\\n\\n\\n\\n"
                    },
                    {
                        "username": "badmusamuda",
                        "content": "Runtime: 0 ms, Beats : 100%\\nMemory:40.5 MB, Beats 90 to 64.30%\\n\\n[1.] Reverse the ListNode by adding from the tail\\n\\n `ListNode cp = null;\\n        ListNode temp = head;\\n        while(temp != null){\\n            cp = new ListNode(temp.val, cp);\\n            temp = temp.next;\\n        }`\\n\\n\\n[2.] Re-add, and skip when the condition is satisfied\\n\\n`int start = 1;\\n        temp = null;\\n        while (cp != null){\\n            if(start != n){\\n                temp = new ListNode(cp.val, temp);\\n            }\\n            cp = cp.next;\\n            start++;\\n        }\\n        cp = null;\\n        return temp;`"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int length = 0;\\n        ListNode* temp = head;\\n\\n\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        \\n        \\n        if(length==1 && n==1){  //EDGE CASE1\\n            return NULL;\\n        }\\n        \\n\\n        length = length-n;\\n        if(length==0){\\n            return head->next; //EDGE CASE2\\n        }\\n        int count =0;\\n        ListNode* temp1 = head;\\n\\n\\n\\n        while(temp1){\\n            count++;\\n            if(count==length){\\n                ListNode* sub=temp1->next;\\n                temp1->next=sub->next ;\\n                return head;\\n            }\\n            temp1=temp1->next;\\n        }\\n        return head;\\n    }\\n\\nJust take a counter variable to count length of an linkedlist and then do length-n to get the position, now iterate over linkedlist again until you get that point, once you get that node you can remove to get your answer. \\n\\nThere are 2 further edge cases which I have mentioned above."
                    }
                ]
            },
            {
                "id": 1793531,
                "content": [
                    {
                        "username": "iamravirajesh",
                        "content": "Class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n         ListNode curr = head;\\n         int cnt=0;\\n         \\n         while(curr!=null)\\n         {\\n             cnt++;\\n             curr=curr.next;\\n         }\\n         curr=head;\\n         cnt=cnt-n;\\n\\n         if(cnt==0)\\n         {\\n             curr.val=curr.next.val;\\n             curr.next=curr.next.next;\\n         }\\n\\n         while(cnt>1)\\n         {\\n             cnt--;\\n             curr=curr.next;\\n         }\\n\\n         curr.next=curr.next.next;\\n\\n         return head;\\n    }\\n}\\n\\ncan someone please explain what\\'s wrong with my code? It is giving null pointer error at  \"curr.val=curr.next.val;\" ans \"curr.next=curr.next.next;\""
                    },
                    {
                        "username": "Drakath2812",
                        "content": "I don\\'t follow the logic of the problem, I can\\'t work out which node is supposed to be removed, the numbering in the examples given seem inconsistent at best, and when I thought i\\'d figured it out, apparently [1,2] and n=2, should return 2? why?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python Question...\\n\\nI understand that one of the objects of this problem is to look at this as a problem in C. There are no such things as linked lists in C. But there are in Python and to force a python programmer to ignore this doesn\\'t make sense. The solution to this problem utilizing a linked list and popping an element out of it is two lines of code (and the second line is a return statement). It seems to me that if the programming language that we are using has built in commands that allow us to do things more efficiently then Leetcode should allow us to use them. Can anyone explain to me why we can\\'t?\\n\\nThanks in advance."
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n\\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n\\n        //If node to be remove is the first node from starting .i.e head node\\n        if (fast == NULL){\\n            slow = slow->next;\\n            delete head;\\n            return slow;\\n        } \\n    \\n        \\n        while (fast->next!=NULL)\\n           fast = fast->next, slow = slow->next;\\n\\n        ListNode *temp = slow->next;\\n        slow->next = slow->next->next;\\n        delete temp;\\n        \\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lionezzz",
                        "content": "Some utility code for those who don\\'t use LeetCode\\'s environment for tests and use other IDE:\\n\\npublic static void main(String[] args) {\\n    int[] nodes = {1,2,3,4,5};\\n    int n = 2;\\n    ListNode head = constructListNode(nodes);\\n    ListNode result = new Solution().removeNthFromEnd(head, n);\\n    System.out.println(result == null ? \"[]\" : result.toString());\\n}\\n\\npublic static ListNode constructListNode(int[] nodes) {\\n    ListNode current = new ListNode(nodes[nodes.length - 1]);\\n    for (int i = nodes.length - 2; i >= 0; i--) {\\n        current = new ListNode(nodes[i], current);\\n    }\\n    return current;\\n}\\n\\npublic static class ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {\\n    }\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"[\" + val + (next == null ? \"]\" : \", \" + next.toStringInner() + \"]\");\\n    }\\n\\n    public String toStringInner() {\\n        return val + (next == null ? \"\" : \", \" + next.toStringInner());\\n    }\\n}"
                    },
                    {
                        "username": "propercthulhu",
                        "content": "What is the python3 solution here for the input of [1], as you literally cannot delete the val attribute with any form of del or delattr, as you repeatedly get an AttributeError. Literally only case that won\\'t pass and all my attempts to return what they expect fails."
                    },
                    {
                        "username": "AlanD88",
                        "content": "Can someone explain testcase 22 for me?\\n\\n`head = [1,2]\\nn = 2`\\n\\nWe\\'re supposed to remove the nth node.  So in this case we remove the node at index 2, which is 2.\\n\\nBut the test case removes node at position one and shows head to point to node with val 2?  \\n\\nIm so confused"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhila01](/nikhila01) Thank you! I was having the same question. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're supposed to remove the nth node _counting from the end_. `n = 1` means remove the last node. `n = 2` means remove the second last node.\n\nSo for `head = [1,2] n = 2` you need to remove the second last node, which is `1`.  That means the result is `[2]`."
                    },
                    {
                        "username": "smartnealll",
                        "content": "I get a NullPointerException, and it said there is a bug at 25 line(check.next = check.next.next;). However, I debug it. Before line 25, the check is [3, 4, 5]. I think my line 25 is correct, but it said  cannot read field because \"\"<local3>.next\" is null. Can anyone please give me some suggestion?\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode check = head;\\n        int count = 1;\\n        while(check.next != null) {\\n        check = check.next;\\n            count++;\\n        }\\n        count = count - n - 1;\\n        check = head;\\n        while(count > 0) {\\n            check = check.next;\\n            count--;\\n        }\\n        check.next = check.next.next;\\n        return check; \\n    }\\n\\n\\n\\n"
                    },
                    {
                        "username": "badmusamuda",
                        "content": "Runtime: 0 ms, Beats : 100%\\nMemory:40.5 MB, Beats 90 to 64.30%\\n\\n[1.] Reverse the ListNode by adding from the tail\\n\\n `ListNode cp = null;\\n        ListNode temp = head;\\n        while(temp != null){\\n            cp = new ListNode(temp.val, cp);\\n            temp = temp.next;\\n        }`\\n\\n\\n[2.] Re-add, and skip when the condition is satisfied\\n\\n`int start = 1;\\n        temp = null;\\n        while (cp != null){\\n            if(start != n){\\n                temp = new ListNode(cp.val, temp);\\n            }\\n            cp = cp.next;\\n            start++;\\n        }\\n        cp = null;\\n        return temp;`"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int length = 0;\\n        ListNode* temp = head;\\n\\n\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        \\n        \\n        if(length==1 && n==1){  //EDGE CASE1\\n            return NULL;\\n        }\\n        \\n\\n        length = length-n;\\n        if(length==0){\\n            return head->next; //EDGE CASE2\\n        }\\n        int count =0;\\n        ListNode* temp1 = head;\\n\\n\\n\\n        while(temp1){\\n            count++;\\n            if(count==length){\\n                ListNode* sub=temp1->next;\\n                temp1->next=sub->next ;\\n                return head;\\n            }\\n            temp1=temp1->next;\\n        }\\n        return head;\\n    }\\n\\nJust take a counter variable to count length of an linkedlist and then do length-n to get the position, now iterate over linkedlist again until you get that point, once you get that node you can remove to get your answer. \\n\\nThere are 2 further edge cases which I have mentioned above."
                    }
                ]
            },
            {
                "id": 1793259,
                "content": [
                    {
                        "username": "iamravirajesh",
                        "content": "Class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n         ListNode curr = head;\\n         int cnt=0;\\n         \\n         while(curr!=null)\\n         {\\n             cnt++;\\n             curr=curr.next;\\n         }\\n         curr=head;\\n         cnt=cnt-n;\\n\\n         if(cnt==0)\\n         {\\n             curr.val=curr.next.val;\\n             curr.next=curr.next.next;\\n         }\\n\\n         while(cnt>1)\\n         {\\n             cnt--;\\n             curr=curr.next;\\n         }\\n\\n         curr.next=curr.next.next;\\n\\n         return head;\\n    }\\n}\\n\\ncan someone please explain what\\'s wrong with my code? It is giving null pointer error at  \"curr.val=curr.next.val;\" ans \"curr.next=curr.next.next;\""
                    },
                    {
                        "username": "Drakath2812",
                        "content": "I don\\'t follow the logic of the problem, I can\\'t work out which node is supposed to be removed, the numbering in the examples given seem inconsistent at best, and when I thought i\\'d figured it out, apparently [1,2] and n=2, should return 2? why?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python Question...\\n\\nI understand that one of the objects of this problem is to look at this as a problem in C. There are no such things as linked lists in C. But there are in Python and to force a python programmer to ignore this doesn\\'t make sense. The solution to this problem utilizing a linked list and popping an element out of it is two lines of code (and the second line is a return statement). It seems to me that if the programming language that we are using has built in commands that allow us to do things more efficiently then Leetcode should allow us to use them. Can anyone explain to me why we can\\'t?\\n\\nThanks in advance."
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n\\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n\\n        //If node to be remove is the first node from starting .i.e head node\\n        if (fast == NULL){\\n            slow = slow->next;\\n            delete head;\\n            return slow;\\n        } \\n    \\n        \\n        while (fast->next!=NULL)\\n           fast = fast->next, slow = slow->next;\\n\\n        ListNode *temp = slow->next;\\n        slow->next = slow->next->next;\\n        delete temp;\\n        \\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lionezzz",
                        "content": "Some utility code for those who don\\'t use LeetCode\\'s environment for tests and use other IDE:\\n\\npublic static void main(String[] args) {\\n    int[] nodes = {1,2,3,4,5};\\n    int n = 2;\\n    ListNode head = constructListNode(nodes);\\n    ListNode result = new Solution().removeNthFromEnd(head, n);\\n    System.out.println(result == null ? \"[]\" : result.toString());\\n}\\n\\npublic static ListNode constructListNode(int[] nodes) {\\n    ListNode current = new ListNode(nodes[nodes.length - 1]);\\n    for (int i = nodes.length - 2; i >= 0; i--) {\\n        current = new ListNode(nodes[i], current);\\n    }\\n    return current;\\n}\\n\\npublic static class ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {\\n    }\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"[\" + val + (next == null ? \"]\" : \", \" + next.toStringInner() + \"]\");\\n    }\\n\\n    public String toStringInner() {\\n        return val + (next == null ? \"\" : \", \" + next.toStringInner());\\n    }\\n}"
                    },
                    {
                        "username": "propercthulhu",
                        "content": "What is the python3 solution here for the input of [1], as you literally cannot delete the val attribute with any form of del or delattr, as you repeatedly get an AttributeError. Literally only case that won\\'t pass and all my attempts to return what they expect fails."
                    },
                    {
                        "username": "AlanD88",
                        "content": "Can someone explain testcase 22 for me?\\n\\n`head = [1,2]\\nn = 2`\\n\\nWe\\'re supposed to remove the nth node.  So in this case we remove the node at index 2, which is 2.\\n\\nBut the test case removes node at position one and shows head to point to node with val 2?  \\n\\nIm so confused"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhila01](/nikhila01) Thank you! I was having the same question. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're supposed to remove the nth node _counting from the end_. `n = 1` means remove the last node. `n = 2` means remove the second last node.\n\nSo for `head = [1,2] n = 2` you need to remove the second last node, which is `1`.  That means the result is `[2]`."
                    },
                    {
                        "username": "smartnealll",
                        "content": "I get a NullPointerException, and it said there is a bug at 25 line(check.next = check.next.next;). However, I debug it. Before line 25, the check is [3, 4, 5]. I think my line 25 is correct, but it said  cannot read field because \"\"<local3>.next\" is null. Can anyone please give me some suggestion?\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode check = head;\\n        int count = 1;\\n        while(check.next != null) {\\n        check = check.next;\\n            count++;\\n        }\\n        count = count - n - 1;\\n        check = head;\\n        while(count > 0) {\\n            check = check.next;\\n            count--;\\n        }\\n        check.next = check.next.next;\\n        return check; \\n    }\\n\\n\\n\\n"
                    },
                    {
                        "username": "badmusamuda",
                        "content": "Runtime: 0 ms, Beats : 100%\\nMemory:40.5 MB, Beats 90 to 64.30%\\n\\n[1.] Reverse the ListNode by adding from the tail\\n\\n `ListNode cp = null;\\n        ListNode temp = head;\\n        while(temp != null){\\n            cp = new ListNode(temp.val, cp);\\n            temp = temp.next;\\n        }`\\n\\n\\n[2.] Re-add, and skip when the condition is satisfied\\n\\n`int start = 1;\\n        temp = null;\\n        while (cp != null){\\n            if(start != n){\\n                temp = new ListNode(cp.val, temp);\\n            }\\n            cp = cp.next;\\n            start++;\\n        }\\n        cp = null;\\n        return temp;`"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int length = 0;\\n        ListNode* temp = head;\\n\\n\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        \\n        \\n        if(length==1 && n==1){  //EDGE CASE1\\n            return NULL;\\n        }\\n        \\n\\n        length = length-n;\\n        if(length==0){\\n            return head->next; //EDGE CASE2\\n        }\\n        int count =0;\\n        ListNode* temp1 = head;\\n\\n\\n\\n        while(temp1){\\n            count++;\\n            if(count==length){\\n                ListNode* sub=temp1->next;\\n                temp1->next=sub->next ;\\n                return head;\\n            }\\n            temp1=temp1->next;\\n        }\\n        return head;\\n    }\\n\\nJust take a counter variable to count length of an linkedlist and then do length-n to get the position, now iterate over linkedlist again until you get that point, once you get that node you can remove to get your answer. \\n\\nThere are 2 further edge cases which I have mentioned above."
                    }
                ]
            },
            {
                "id": 1792058,
                "content": [
                    {
                        "username": "iamravirajesh",
                        "content": "Class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n         ListNode curr = head;\\n         int cnt=0;\\n         \\n         while(curr!=null)\\n         {\\n             cnt++;\\n             curr=curr.next;\\n         }\\n         curr=head;\\n         cnt=cnt-n;\\n\\n         if(cnt==0)\\n         {\\n             curr.val=curr.next.val;\\n             curr.next=curr.next.next;\\n         }\\n\\n         while(cnt>1)\\n         {\\n             cnt--;\\n             curr=curr.next;\\n         }\\n\\n         curr.next=curr.next.next;\\n\\n         return head;\\n    }\\n}\\n\\ncan someone please explain what\\'s wrong with my code? It is giving null pointer error at  \"curr.val=curr.next.val;\" ans \"curr.next=curr.next.next;\""
                    },
                    {
                        "username": "Drakath2812",
                        "content": "I don\\'t follow the logic of the problem, I can\\'t work out which node is supposed to be removed, the numbering in the examples given seem inconsistent at best, and when I thought i\\'d figured it out, apparently [1,2] and n=2, should return 2? why?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python Question...\\n\\nI understand that one of the objects of this problem is to look at this as a problem in C. There are no such things as linked lists in C. But there are in Python and to force a python programmer to ignore this doesn\\'t make sense. The solution to this problem utilizing a linked list and popping an element out of it is two lines of code (and the second line is a return statement). It seems to me that if the programming language that we are using has built in commands that allow us to do things more efficiently then Leetcode should allow us to use them. Can anyone explain to me why we can\\'t?\\n\\nThanks in advance."
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n\\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n\\n        //If node to be remove is the first node from starting .i.e head node\\n        if (fast == NULL){\\n            slow = slow->next;\\n            delete head;\\n            return slow;\\n        } \\n    \\n        \\n        while (fast->next!=NULL)\\n           fast = fast->next, slow = slow->next;\\n\\n        ListNode *temp = slow->next;\\n        slow->next = slow->next->next;\\n        delete temp;\\n        \\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lionezzz",
                        "content": "Some utility code for those who don\\'t use LeetCode\\'s environment for tests and use other IDE:\\n\\npublic static void main(String[] args) {\\n    int[] nodes = {1,2,3,4,5};\\n    int n = 2;\\n    ListNode head = constructListNode(nodes);\\n    ListNode result = new Solution().removeNthFromEnd(head, n);\\n    System.out.println(result == null ? \"[]\" : result.toString());\\n}\\n\\npublic static ListNode constructListNode(int[] nodes) {\\n    ListNode current = new ListNode(nodes[nodes.length - 1]);\\n    for (int i = nodes.length - 2; i >= 0; i--) {\\n        current = new ListNode(nodes[i], current);\\n    }\\n    return current;\\n}\\n\\npublic static class ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {\\n    }\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"[\" + val + (next == null ? \"]\" : \", \" + next.toStringInner() + \"]\");\\n    }\\n\\n    public String toStringInner() {\\n        return val + (next == null ? \"\" : \", \" + next.toStringInner());\\n    }\\n}"
                    },
                    {
                        "username": "propercthulhu",
                        "content": "What is the python3 solution here for the input of [1], as you literally cannot delete the val attribute with any form of del or delattr, as you repeatedly get an AttributeError. Literally only case that won\\'t pass and all my attempts to return what they expect fails."
                    },
                    {
                        "username": "AlanD88",
                        "content": "Can someone explain testcase 22 for me?\\n\\n`head = [1,2]\\nn = 2`\\n\\nWe\\'re supposed to remove the nth node.  So in this case we remove the node at index 2, which is 2.\\n\\nBut the test case removes node at position one and shows head to point to node with val 2?  \\n\\nIm so confused"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhila01](/nikhila01) Thank you! I was having the same question. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're supposed to remove the nth node _counting from the end_. `n = 1` means remove the last node. `n = 2` means remove the second last node.\n\nSo for `head = [1,2] n = 2` you need to remove the second last node, which is `1`.  That means the result is `[2]`."
                    },
                    {
                        "username": "smartnealll",
                        "content": "I get a NullPointerException, and it said there is a bug at 25 line(check.next = check.next.next;). However, I debug it. Before line 25, the check is [3, 4, 5]. I think my line 25 is correct, but it said  cannot read field because \"\"<local3>.next\" is null. Can anyone please give me some suggestion?\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode check = head;\\n        int count = 1;\\n        while(check.next != null) {\\n        check = check.next;\\n            count++;\\n        }\\n        count = count - n - 1;\\n        check = head;\\n        while(count > 0) {\\n            check = check.next;\\n            count--;\\n        }\\n        check.next = check.next.next;\\n        return check; \\n    }\\n\\n\\n\\n"
                    },
                    {
                        "username": "badmusamuda",
                        "content": "Runtime: 0 ms, Beats : 100%\\nMemory:40.5 MB, Beats 90 to 64.30%\\n\\n[1.] Reverse the ListNode by adding from the tail\\n\\n `ListNode cp = null;\\n        ListNode temp = head;\\n        while(temp != null){\\n            cp = new ListNode(temp.val, cp);\\n            temp = temp.next;\\n        }`\\n\\n\\n[2.] Re-add, and skip when the condition is satisfied\\n\\n`int start = 1;\\n        temp = null;\\n        while (cp != null){\\n            if(start != n){\\n                temp = new ListNode(cp.val, temp);\\n            }\\n            cp = cp.next;\\n            start++;\\n        }\\n        cp = null;\\n        return temp;`"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int length = 0;\\n        ListNode* temp = head;\\n\\n\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        \\n        \\n        if(length==1 && n==1){  //EDGE CASE1\\n            return NULL;\\n        }\\n        \\n\\n        length = length-n;\\n        if(length==0){\\n            return head->next; //EDGE CASE2\\n        }\\n        int count =0;\\n        ListNode* temp1 = head;\\n\\n\\n\\n        while(temp1){\\n            count++;\\n            if(count==length){\\n                ListNode* sub=temp1->next;\\n                temp1->next=sub->next ;\\n                return head;\\n            }\\n            temp1=temp1->next;\\n        }\\n        return head;\\n    }\\n\\nJust take a counter variable to count length of an linkedlist and then do length-n to get the position, now iterate over linkedlist again until you get that point, once you get that node you can remove to get your answer. \\n\\nThere are 2 further edge cases which I have mentioned above."
                    }
                ]
            },
            {
                "id": 1789844,
                "content": [
                    {
                        "username": "iamravirajesh",
                        "content": "Class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n         ListNode curr = head;\\n         int cnt=0;\\n         \\n         while(curr!=null)\\n         {\\n             cnt++;\\n             curr=curr.next;\\n         }\\n         curr=head;\\n         cnt=cnt-n;\\n\\n         if(cnt==0)\\n         {\\n             curr.val=curr.next.val;\\n             curr.next=curr.next.next;\\n         }\\n\\n         while(cnt>1)\\n         {\\n             cnt--;\\n             curr=curr.next;\\n         }\\n\\n         curr.next=curr.next.next;\\n\\n         return head;\\n    }\\n}\\n\\ncan someone please explain what\\'s wrong with my code? It is giving null pointer error at  \"curr.val=curr.next.val;\" ans \"curr.next=curr.next.next;\""
                    },
                    {
                        "username": "Drakath2812",
                        "content": "I don\\'t follow the logic of the problem, I can\\'t work out which node is supposed to be removed, the numbering in the examples given seem inconsistent at best, and when I thought i\\'d figured it out, apparently [1,2] and n=2, should return 2? why?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python Question...\\n\\nI understand that one of the objects of this problem is to look at this as a problem in C. There are no such things as linked lists in C. But there are in Python and to force a python programmer to ignore this doesn\\'t make sense. The solution to this problem utilizing a linked list and popping an element out of it is two lines of code (and the second line is a return statement). It seems to me that if the programming language that we are using has built in commands that allow us to do things more efficiently then Leetcode should allow us to use them. Can anyone explain to me why we can\\'t?\\n\\nThanks in advance."
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n\\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n\\n        //If node to be remove is the first node from starting .i.e head node\\n        if (fast == NULL){\\n            slow = slow->next;\\n            delete head;\\n            return slow;\\n        } \\n    \\n        \\n        while (fast->next!=NULL)\\n           fast = fast->next, slow = slow->next;\\n\\n        ListNode *temp = slow->next;\\n        slow->next = slow->next->next;\\n        delete temp;\\n        \\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lionezzz",
                        "content": "Some utility code for those who don\\'t use LeetCode\\'s environment for tests and use other IDE:\\n\\npublic static void main(String[] args) {\\n    int[] nodes = {1,2,3,4,5};\\n    int n = 2;\\n    ListNode head = constructListNode(nodes);\\n    ListNode result = new Solution().removeNthFromEnd(head, n);\\n    System.out.println(result == null ? \"[]\" : result.toString());\\n}\\n\\npublic static ListNode constructListNode(int[] nodes) {\\n    ListNode current = new ListNode(nodes[nodes.length - 1]);\\n    for (int i = nodes.length - 2; i >= 0; i--) {\\n        current = new ListNode(nodes[i], current);\\n    }\\n    return current;\\n}\\n\\npublic static class ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {\\n    }\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"[\" + val + (next == null ? \"]\" : \", \" + next.toStringInner() + \"]\");\\n    }\\n\\n    public String toStringInner() {\\n        return val + (next == null ? \"\" : \", \" + next.toStringInner());\\n    }\\n}"
                    },
                    {
                        "username": "propercthulhu",
                        "content": "What is the python3 solution here for the input of [1], as you literally cannot delete the val attribute with any form of del or delattr, as you repeatedly get an AttributeError. Literally only case that won\\'t pass and all my attempts to return what they expect fails."
                    },
                    {
                        "username": "AlanD88",
                        "content": "Can someone explain testcase 22 for me?\\n\\n`head = [1,2]\\nn = 2`\\n\\nWe\\'re supposed to remove the nth node.  So in this case we remove the node at index 2, which is 2.\\n\\nBut the test case removes node at position one and shows head to point to node with val 2?  \\n\\nIm so confused"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhila01](/nikhila01) Thank you! I was having the same question. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're supposed to remove the nth node _counting from the end_. `n = 1` means remove the last node. `n = 2` means remove the second last node.\n\nSo for `head = [1,2] n = 2` you need to remove the second last node, which is `1`.  That means the result is `[2]`."
                    },
                    {
                        "username": "smartnealll",
                        "content": "I get a NullPointerException, and it said there is a bug at 25 line(check.next = check.next.next;). However, I debug it. Before line 25, the check is [3, 4, 5]. I think my line 25 is correct, but it said  cannot read field because \"\"<local3>.next\" is null. Can anyone please give me some suggestion?\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode check = head;\\n        int count = 1;\\n        while(check.next != null) {\\n        check = check.next;\\n            count++;\\n        }\\n        count = count - n - 1;\\n        check = head;\\n        while(count > 0) {\\n            check = check.next;\\n            count--;\\n        }\\n        check.next = check.next.next;\\n        return check; \\n    }\\n\\n\\n\\n"
                    },
                    {
                        "username": "badmusamuda",
                        "content": "Runtime: 0 ms, Beats : 100%\\nMemory:40.5 MB, Beats 90 to 64.30%\\n\\n[1.] Reverse the ListNode by adding from the tail\\n\\n `ListNode cp = null;\\n        ListNode temp = head;\\n        while(temp != null){\\n            cp = new ListNode(temp.val, cp);\\n            temp = temp.next;\\n        }`\\n\\n\\n[2.] Re-add, and skip when the condition is satisfied\\n\\n`int start = 1;\\n        temp = null;\\n        while (cp != null){\\n            if(start != n){\\n                temp = new ListNode(cp.val, temp);\\n            }\\n            cp = cp.next;\\n            start++;\\n        }\\n        cp = null;\\n        return temp;`"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int length = 0;\\n        ListNode* temp = head;\\n\\n\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        \\n        \\n        if(length==1 && n==1){  //EDGE CASE1\\n            return NULL;\\n        }\\n        \\n\\n        length = length-n;\\n        if(length==0){\\n            return head->next; //EDGE CASE2\\n        }\\n        int count =0;\\n        ListNode* temp1 = head;\\n\\n\\n\\n        while(temp1){\\n            count++;\\n            if(count==length){\\n                ListNode* sub=temp1->next;\\n                temp1->next=sub->next ;\\n                return head;\\n            }\\n            temp1=temp1->next;\\n        }\\n        return head;\\n    }\\n\\nJust take a counter variable to count length of an linkedlist and then do length-n to get the position, now iterate over linkedlist again until you get that point, once you get that node you can remove to get your answer. \\n\\nThere are 2 further edge cases which I have mentioned above."
                    }
                ]
            },
            {
                "id": 1785417,
                "content": [
                    {
                        "username": "iamravirajesh",
                        "content": "Class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n         ListNode curr = head;\\n         int cnt=0;\\n         \\n         while(curr!=null)\\n         {\\n             cnt++;\\n             curr=curr.next;\\n         }\\n         curr=head;\\n         cnt=cnt-n;\\n\\n         if(cnt==0)\\n         {\\n             curr.val=curr.next.val;\\n             curr.next=curr.next.next;\\n         }\\n\\n         while(cnt>1)\\n         {\\n             cnt--;\\n             curr=curr.next;\\n         }\\n\\n         curr.next=curr.next.next;\\n\\n         return head;\\n    }\\n}\\n\\ncan someone please explain what\\'s wrong with my code? It is giving null pointer error at  \"curr.val=curr.next.val;\" ans \"curr.next=curr.next.next;\""
                    },
                    {
                        "username": "Drakath2812",
                        "content": "I don\\'t follow the logic of the problem, I can\\'t work out which node is supposed to be removed, the numbering in the examples given seem inconsistent at best, and when I thought i\\'d figured it out, apparently [1,2] and n=2, should return 2? why?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python Question...\\n\\nI understand that one of the objects of this problem is to look at this as a problem in C. There are no such things as linked lists in C. But there are in Python and to force a python programmer to ignore this doesn\\'t make sense. The solution to this problem utilizing a linked list and popping an element out of it is two lines of code (and the second line is a return statement). It seems to me that if the programming language that we are using has built in commands that allow us to do things more efficiently then Leetcode should allow us to use them. Can anyone explain to me why we can\\'t?\\n\\nThanks in advance."
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n\\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n\\n        //If node to be remove is the first node from starting .i.e head node\\n        if (fast == NULL){\\n            slow = slow->next;\\n            delete head;\\n            return slow;\\n        } \\n    \\n        \\n        while (fast->next!=NULL)\\n           fast = fast->next, slow = slow->next;\\n\\n        ListNode *temp = slow->next;\\n        slow->next = slow->next->next;\\n        delete temp;\\n        \\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lionezzz",
                        "content": "Some utility code for those who don\\'t use LeetCode\\'s environment for tests and use other IDE:\\n\\npublic static void main(String[] args) {\\n    int[] nodes = {1,2,3,4,5};\\n    int n = 2;\\n    ListNode head = constructListNode(nodes);\\n    ListNode result = new Solution().removeNthFromEnd(head, n);\\n    System.out.println(result == null ? \"[]\" : result.toString());\\n}\\n\\npublic static ListNode constructListNode(int[] nodes) {\\n    ListNode current = new ListNode(nodes[nodes.length - 1]);\\n    for (int i = nodes.length - 2; i >= 0; i--) {\\n        current = new ListNode(nodes[i], current);\\n    }\\n    return current;\\n}\\n\\npublic static class ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {\\n    }\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"[\" + val + (next == null ? \"]\" : \", \" + next.toStringInner() + \"]\");\\n    }\\n\\n    public String toStringInner() {\\n        return val + (next == null ? \"\" : \", \" + next.toStringInner());\\n    }\\n}"
                    },
                    {
                        "username": "propercthulhu",
                        "content": "What is the python3 solution here for the input of [1], as you literally cannot delete the val attribute with any form of del or delattr, as you repeatedly get an AttributeError. Literally only case that won\\'t pass and all my attempts to return what they expect fails."
                    },
                    {
                        "username": "AlanD88",
                        "content": "Can someone explain testcase 22 for me?\\n\\n`head = [1,2]\\nn = 2`\\n\\nWe\\'re supposed to remove the nth node.  So in this case we remove the node at index 2, which is 2.\\n\\nBut the test case removes node at position one and shows head to point to node with val 2?  \\n\\nIm so confused"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhila01](/nikhila01) Thank you! I was having the same question. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're supposed to remove the nth node _counting from the end_. `n = 1` means remove the last node. `n = 2` means remove the second last node.\n\nSo for `head = [1,2] n = 2` you need to remove the second last node, which is `1`.  That means the result is `[2]`."
                    },
                    {
                        "username": "smartnealll",
                        "content": "I get a NullPointerException, and it said there is a bug at 25 line(check.next = check.next.next;). However, I debug it. Before line 25, the check is [3, 4, 5]. I think my line 25 is correct, but it said  cannot read field because \"\"<local3>.next\" is null. Can anyone please give me some suggestion?\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode check = head;\\n        int count = 1;\\n        while(check.next != null) {\\n        check = check.next;\\n            count++;\\n        }\\n        count = count - n - 1;\\n        check = head;\\n        while(count > 0) {\\n            check = check.next;\\n            count--;\\n        }\\n        check.next = check.next.next;\\n        return check; \\n    }\\n\\n\\n\\n"
                    },
                    {
                        "username": "badmusamuda",
                        "content": "Runtime: 0 ms, Beats : 100%\\nMemory:40.5 MB, Beats 90 to 64.30%\\n\\n[1.] Reverse the ListNode by adding from the tail\\n\\n `ListNode cp = null;\\n        ListNode temp = head;\\n        while(temp != null){\\n            cp = new ListNode(temp.val, cp);\\n            temp = temp.next;\\n        }`\\n\\n\\n[2.] Re-add, and skip when the condition is satisfied\\n\\n`int start = 1;\\n        temp = null;\\n        while (cp != null){\\n            if(start != n){\\n                temp = new ListNode(cp.val, temp);\\n            }\\n            cp = cp.next;\\n            start++;\\n        }\\n        cp = null;\\n        return temp;`"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int length = 0;\\n        ListNode* temp = head;\\n\\n\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        \\n        \\n        if(length==1 && n==1){  //EDGE CASE1\\n            return NULL;\\n        }\\n        \\n\\n        length = length-n;\\n        if(length==0){\\n            return head->next; //EDGE CASE2\\n        }\\n        int count =0;\\n        ListNode* temp1 = head;\\n\\n\\n\\n        while(temp1){\\n            count++;\\n            if(count==length){\\n                ListNode* sub=temp1->next;\\n                temp1->next=sub->next ;\\n                return head;\\n            }\\n            temp1=temp1->next;\\n        }\\n        return head;\\n    }\\n\\nJust take a counter variable to count length of an linkedlist and then do length-n to get the position, now iterate over linkedlist again until you get that point, once you get that node you can remove to get your answer. \\n\\nThere are 2 further edge cases which I have mentioned above."
                    }
                ]
            },
            {
                "id": 1774792,
                "content": [
                    {
                        "username": "iamravirajesh",
                        "content": "Class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n         ListNode curr = head;\\n         int cnt=0;\\n         \\n         while(curr!=null)\\n         {\\n             cnt++;\\n             curr=curr.next;\\n         }\\n         curr=head;\\n         cnt=cnt-n;\\n\\n         if(cnt==0)\\n         {\\n             curr.val=curr.next.val;\\n             curr.next=curr.next.next;\\n         }\\n\\n         while(cnt>1)\\n         {\\n             cnt--;\\n             curr=curr.next;\\n         }\\n\\n         curr.next=curr.next.next;\\n\\n         return head;\\n    }\\n}\\n\\ncan someone please explain what\\'s wrong with my code? It is giving null pointer error at  \"curr.val=curr.next.val;\" ans \"curr.next=curr.next.next;\""
                    },
                    {
                        "username": "Drakath2812",
                        "content": "I don\\'t follow the logic of the problem, I can\\'t work out which node is supposed to be removed, the numbering in the examples given seem inconsistent at best, and when I thought i\\'d figured it out, apparently [1,2] and n=2, should return 2? why?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python Question...\\n\\nI understand that one of the objects of this problem is to look at this as a problem in C. There are no such things as linked lists in C. But there are in Python and to force a python programmer to ignore this doesn\\'t make sense. The solution to this problem utilizing a linked list and popping an element out of it is two lines of code (and the second line is a return statement). It seems to me that if the programming language that we are using has built in commands that allow us to do things more efficiently then Leetcode should allow us to use them. Can anyone explain to me why we can\\'t?\\n\\nThanks in advance."
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n\\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n\\n        //If node to be remove is the first node from starting .i.e head node\\n        if (fast == NULL){\\n            slow = slow->next;\\n            delete head;\\n            return slow;\\n        } \\n    \\n        \\n        while (fast->next!=NULL)\\n           fast = fast->next, slow = slow->next;\\n\\n        ListNode *temp = slow->next;\\n        slow->next = slow->next->next;\\n        delete temp;\\n        \\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lionezzz",
                        "content": "Some utility code for those who don\\'t use LeetCode\\'s environment for tests and use other IDE:\\n\\npublic static void main(String[] args) {\\n    int[] nodes = {1,2,3,4,5};\\n    int n = 2;\\n    ListNode head = constructListNode(nodes);\\n    ListNode result = new Solution().removeNthFromEnd(head, n);\\n    System.out.println(result == null ? \"[]\" : result.toString());\\n}\\n\\npublic static ListNode constructListNode(int[] nodes) {\\n    ListNode current = new ListNode(nodes[nodes.length - 1]);\\n    for (int i = nodes.length - 2; i >= 0; i--) {\\n        current = new ListNode(nodes[i], current);\\n    }\\n    return current;\\n}\\n\\npublic static class ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {\\n    }\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"[\" + val + (next == null ? \"]\" : \", \" + next.toStringInner() + \"]\");\\n    }\\n\\n    public String toStringInner() {\\n        return val + (next == null ? \"\" : \", \" + next.toStringInner());\\n    }\\n}"
                    },
                    {
                        "username": "propercthulhu",
                        "content": "What is the python3 solution here for the input of [1], as you literally cannot delete the val attribute with any form of del or delattr, as you repeatedly get an AttributeError. Literally only case that won\\'t pass and all my attempts to return what they expect fails."
                    },
                    {
                        "username": "AlanD88",
                        "content": "Can someone explain testcase 22 for me?\\n\\n`head = [1,2]\\nn = 2`\\n\\nWe\\'re supposed to remove the nth node.  So in this case we remove the node at index 2, which is 2.\\n\\nBut the test case removes node at position one and shows head to point to node with val 2?  \\n\\nIm so confused"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhila01](/nikhila01) Thank you! I was having the same question. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're supposed to remove the nth node _counting from the end_. `n = 1` means remove the last node. `n = 2` means remove the second last node.\n\nSo for `head = [1,2] n = 2` you need to remove the second last node, which is `1`.  That means the result is `[2]`."
                    },
                    {
                        "username": "smartnealll",
                        "content": "I get a NullPointerException, and it said there is a bug at 25 line(check.next = check.next.next;). However, I debug it. Before line 25, the check is [3, 4, 5]. I think my line 25 is correct, but it said  cannot read field because \"\"<local3>.next\" is null. Can anyone please give me some suggestion?\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode check = head;\\n        int count = 1;\\n        while(check.next != null) {\\n        check = check.next;\\n            count++;\\n        }\\n        count = count - n - 1;\\n        check = head;\\n        while(count > 0) {\\n            check = check.next;\\n            count--;\\n        }\\n        check.next = check.next.next;\\n        return check; \\n    }\\n\\n\\n\\n"
                    },
                    {
                        "username": "badmusamuda",
                        "content": "Runtime: 0 ms, Beats : 100%\\nMemory:40.5 MB, Beats 90 to 64.30%\\n\\n[1.] Reverse the ListNode by adding from the tail\\n\\n `ListNode cp = null;\\n        ListNode temp = head;\\n        while(temp != null){\\n            cp = new ListNode(temp.val, cp);\\n            temp = temp.next;\\n        }`\\n\\n\\n[2.] Re-add, and skip when the condition is satisfied\\n\\n`int start = 1;\\n        temp = null;\\n        while (cp != null){\\n            if(start != n){\\n                temp = new ListNode(cp.val, temp);\\n            }\\n            cp = cp.next;\\n            start++;\\n        }\\n        cp = null;\\n        return temp;`"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int length = 0;\\n        ListNode* temp = head;\\n\\n\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        \\n        \\n        if(length==1 && n==1){  //EDGE CASE1\\n            return NULL;\\n        }\\n        \\n\\n        length = length-n;\\n        if(length==0){\\n            return head->next; //EDGE CASE2\\n        }\\n        int count =0;\\n        ListNode* temp1 = head;\\n\\n\\n\\n        while(temp1){\\n            count++;\\n            if(count==length){\\n                ListNode* sub=temp1->next;\\n                temp1->next=sub->next ;\\n                return head;\\n            }\\n            temp1=temp1->next;\\n        }\\n        return head;\\n    }\\n\\nJust take a counter variable to count length of an linkedlist and then do length-n to get the position, now iterate over linkedlist again until you get that point, once you get that node you can remove to get your answer. \\n\\nThere are 2 further edge cases which I have mentioned above."
                    }
                ]
            },
            {
                "id": 1772792,
                "content": [
                    {
                        "username": "iamravirajesh",
                        "content": "Class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n         ListNode curr = head;\\n         int cnt=0;\\n         \\n         while(curr!=null)\\n         {\\n             cnt++;\\n             curr=curr.next;\\n         }\\n         curr=head;\\n         cnt=cnt-n;\\n\\n         if(cnt==0)\\n         {\\n             curr.val=curr.next.val;\\n             curr.next=curr.next.next;\\n         }\\n\\n         while(cnt>1)\\n         {\\n             cnt--;\\n             curr=curr.next;\\n         }\\n\\n         curr.next=curr.next.next;\\n\\n         return head;\\n    }\\n}\\n\\ncan someone please explain what\\'s wrong with my code? It is giving null pointer error at  \"curr.val=curr.next.val;\" ans \"curr.next=curr.next.next;\""
                    },
                    {
                        "username": "Drakath2812",
                        "content": "I don\\'t follow the logic of the problem, I can\\'t work out which node is supposed to be removed, the numbering in the examples given seem inconsistent at best, and when I thought i\\'d figured it out, apparently [1,2] and n=2, should return 2? why?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python Question...\\n\\nI understand that one of the objects of this problem is to look at this as a problem in C. There are no such things as linked lists in C. But there are in Python and to force a python programmer to ignore this doesn\\'t make sense. The solution to this problem utilizing a linked list and popping an element out of it is two lines of code (and the second line is a return statement). It seems to me that if the programming language that we are using has built in commands that allow us to do things more efficiently then Leetcode should allow us to use them. Can anyone explain to me why we can\\'t?\\n\\nThanks in advance."
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n\\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n\\n        //If node to be remove is the first node from starting .i.e head node\\n        if (fast == NULL){\\n            slow = slow->next;\\n            delete head;\\n            return slow;\\n        } \\n    \\n        \\n        while (fast->next!=NULL)\\n           fast = fast->next, slow = slow->next;\\n\\n        ListNode *temp = slow->next;\\n        slow->next = slow->next->next;\\n        delete temp;\\n        \\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lionezzz",
                        "content": "Some utility code for those who don\\'t use LeetCode\\'s environment for tests and use other IDE:\\n\\npublic static void main(String[] args) {\\n    int[] nodes = {1,2,3,4,5};\\n    int n = 2;\\n    ListNode head = constructListNode(nodes);\\n    ListNode result = new Solution().removeNthFromEnd(head, n);\\n    System.out.println(result == null ? \"[]\" : result.toString());\\n}\\n\\npublic static ListNode constructListNode(int[] nodes) {\\n    ListNode current = new ListNode(nodes[nodes.length - 1]);\\n    for (int i = nodes.length - 2; i >= 0; i--) {\\n        current = new ListNode(nodes[i], current);\\n    }\\n    return current;\\n}\\n\\npublic static class ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {\\n    }\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"[\" + val + (next == null ? \"]\" : \", \" + next.toStringInner() + \"]\");\\n    }\\n\\n    public String toStringInner() {\\n        return val + (next == null ? \"\" : \", \" + next.toStringInner());\\n    }\\n}"
                    },
                    {
                        "username": "propercthulhu",
                        "content": "What is the python3 solution here for the input of [1], as you literally cannot delete the val attribute with any form of del or delattr, as you repeatedly get an AttributeError. Literally only case that won\\'t pass and all my attempts to return what they expect fails."
                    },
                    {
                        "username": "AlanD88",
                        "content": "Can someone explain testcase 22 for me?\\n\\n`head = [1,2]\\nn = 2`\\n\\nWe\\'re supposed to remove the nth node.  So in this case we remove the node at index 2, which is 2.\\n\\nBut the test case removes node at position one and shows head to point to node with val 2?  \\n\\nIm so confused"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhila01](/nikhila01) Thank you! I was having the same question. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're supposed to remove the nth node _counting from the end_. `n = 1` means remove the last node. `n = 2` means remove the second last node.\n\nSo for `head = [1,2] n = 2` you need to remove the second last node, which is `1`.  That means the result is `[2]`."
                    },
                    {
                        "username": "smartnealll",
                        "content": "I get a NullPointerException, and it said there is a bug at 25 line(check.next = check.next.next;). However, I debug it. Before line 25, the check is [3, 4, 5]. I think my line 25 is correct, but it said  cannot read field because \"\"<local3>.next\" is null. Can anyone please give me some suggestion?\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode check = head;\\n        int count = 1;\\n        while(check.next != null) {\\n        check = check.next;\\n            count++;\\n        }\\n        count = count - n - 1;\\n        check = head;\\n        while(count > 0) {\\n            check = check.next;\\n            count--;\\n        }\\n        check.next = check.next.next;\\n        return check; \\n    }\\n\\n\\n\\n"
                    },
                    {
                        "username": "badmusamuda",
                        "content": "Runtime: 0 ms, Beats : 100%\\nMemory:40.5 MB, Beats 90 to 64.30%\\n\\n[1.] Reverse the ListNode by adding from the tail\\n\\n `ListNode cp = null;\\n        ListNode temp = head;\\n        while(temp != null){\\n            cp = new ListNode(temp.val, cp);\\n            temp = temp.next;\\n        }`\\n\\n\\n[2.] Re-add, and skip when the condition is satisfied\\n\\n`int start = 1;\\n        temp = null;\\n        while (cp != null){\\n            if(start != n){\\n                temp = new ListNode(cp.val, temp);\\n            }\\n            cp = cp.next;\\n            start++;\\n        }\\n        cp = null;\\n        return temp;`"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int length = 0;\\n        ListNode* temp = head;\\n\\n\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        \\n        \\n        if(length==1 && n==1){  //EDGE CASE1\\n            return NULL;\\n        }\\n        \\n\\n        length = length-n;\\n        if(length==0){\\n            return head->next; //EDGE CASE2\\n        }\\n        int count =0;\\n        ListNode* temp1 = head;\\n\\n\\n\\n        while(temp1){\\n            count++;\\n            if(count==length){\\n                ListNode* sub=temp1->next;\\n                temp1->next=sub->next ;\\n                return head;\\n            }\\n            temp1=temp1->next;\\n        }\\n        return head;\\n    }\\n\\nJust take a counter variable to count length of an linkedlist and then do length-n to get the position, now iterate over linkedlist again until you get that point, once you get that node you can remove to get your answer. \\n\\nThere are 2 further edge cases which I have mentioned above."
                    }
                ]
            },
            {
                "id": 1768698,
                "content": [
                    {
                        "username": "iamravirajesh",
                        "content": "Class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n         ListNode curr = head;\\n         int cnt=0;\\n         \\n         while(curr!=null)\\n         {\\n             cnt++;\\n             curr=curr.next;\\n         }\\n         curr=head;\\n         cnt=cnt-n;\\n\\n         if(cnt==0)\\n         {\\n             curr.val=curr.next.val;\\n             curr.next=curr.next.next;\\n         }\\n\\n         while(cnt>1)\\n         {\\n             cnt--;\\n             curr=curr.next;\\n         }\\n\\n         curr.next=curr.next.next;\\n\\n         return head;\\n    }\\n}\\n\\ncan someone please explain what\\'s wrong with my code? It is giving null pointer error at  \"curr.val=curr.next.val;\" ans \"curr.next=curr.next.next;\""
                    },
                    {
                        "username": "Drakath2812",
                        "content": "I don\\'t follow the logic of the problem, I can\\'t work out which node is supposed to be removed, the numbering in the examples given seem inconsistent at best, and when I thought i\\'d figured it out, apparently [1,2] and n=2, should return 2? why?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python Question...\\n\\nI understand that one of the objects of this problem is to look at this as a problem in C. There are no such things as linked lists in C. But there are in Python and to force a python programmer to ignore this doesn\\'t make sense. The solution to this problem utilizing a linked list and popping an element out of it is two lines of code (and the second line is a return statement). It seems to me that if the programming language that we are using has built in commands that allow us to do things more efficiently then Leetcode should allow us to use them. Can anyone explain to me why we can\\'t?\\n\\nThanks in advance."
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n\\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n\\n        //If node to be remove is the first node from starting .i.e head node\\n        if (fast == NULL){\\n            slow = slow->next;\\n            delete head;\\n            return slow;\\n        } \\n    \\n        \\n        while (fast->next!=NULL)\\n           fast = fast->next, slow = slow->next;\\n\\n        ListNode *temp = slow->next;\\n        slow->next = slow->next->next;\\n        delete temp;\\n        \\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lionezzz",
                        "content": "Some utility code for those who don\\'t use LeetCode\\'s environment for tests and use other IDE:\\n\\npublic static void main(String[] args) {\\n    int[] nodes = {1,2,3,4,5};\\n    int n = 2;\\n    ListNode head = constructListNode(nodes);\\n    ListNode result = new Solution().removeNthFromEnd(head, n);\\n    System.out.println(result == null ? \"[]\" : result.toString());\\n}\\n\\npublic static ListNode constructListNode(int[] nodes) {\\n    ListNode current = new ListNode(nodes[nodes.length - 1]);\\n    for (int i = nodes.length - 2; i >= 0; i--) {\\n        current = new ListNode(nodes[i], current);\\n    }\\n    return current;\\n}\\n\\npublic static class ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {\\n    }\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"[\" + val + (next == null ? \"]\" : \", \" + next.toStringInner() + \"]\");\\n    }\\n\\n    public String toStringInner() {\\n        return val + (next == null ? \"\" : \", \" + next.toStringInner());\\n    }\\n}"
                    },
                    {
                        "username": "propercthulhu",
                        "content": "What is the python3 solution here for the input of [1], as you literally cannot delete the val attribute with any form of del or delattr, as you repeatedly get an AttributeError. Literally only case that won\\'t pass and all my attempts to return what they expect fails."
                    },
                    {
                        "username": "AlanD88",
                        "content": "Can someone explain testcase 22 for me?\\n\\n`head = [1,2]\\nn = 2`\\n\\nWe\\'re supposed to remove the nth node.  So in this case we remove the node at index 2, which is 2.\\n\\nBut the test case removes node at position one and shows head to point to node with val 2?  \\n\\nIm so confused"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhila01](/nikhila01) Thank you! I was having the same question. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're supposed to remove the nth node _counting from the end_. `n = 1` means remove the last node. `n = 2` means remove the second last node.\n\nSo for `head = [1,2] n = 2` you need to remove the second last node, which is `1`.  That means the result is `[2]`."
                    },
                    {
                        "username": "smartnealll",
                        "content": "I get a NullPointerException, and it said there is a bug at 25 line(check.next = check.next.next;). However, I debug it. Before line 25, the check is [3, 4, 5]. I think my line 25 is correct, but it said  cannot read field because \"\"<local3>.next\" is null. Can anyone please give me some suggestion?\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode check = head;\\n        int count = 1;\\n        while(check.next != null) {\\n        check = check.next;\\n            count++;\\n        }\\n        count = count - n - 1;\\n        check = head;\\n        while(count > 0) {\\n            check = check.next;\\n            count--;\\n        }\\n        check.next = check.next.next;\\n        return check; \\n    }\\n\\n\\n\\n"
                    },
                    {
                        "username": "badmusamuda",
                        "content": "Runtime: 0 ms, Beats : 100%\\nMemory:40.5 MB, Beats 90 to 64.30%\\n\\n[1.] Reverse the ListNode by adding from the tail\\n\\n `ListNode cp = null;\\n        ListNode temp = head;\\n        while(temp != null){\\n            cp = new ListNode(temp.val, cp);\\n            temp = temp.next;\\n        }`\\n\\n\\n[2.] Re-add, and skip when the condition is satisfied\\n\\n`int start = 1;\\n        temp = null;\\n        while (cp != null){\\n            if(start != n){\\n                temp = new ListNode(cp.val, temp);\\n            }\\n            cp = cp.next;\\n            start++;\\n        }\\n        cp = null;\\n        return temp;`"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int length = 0;\\n        ListNode* temp = head;\\n\\n\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        \\n        \\n        if(length==1 && n==1){  //EDGE CASE1\\n            return NULL;\\n        }\\n        \\n\\n        length = length-n;\\n        if(length==0){\\n            return head->next; //EDGE CASE2\\n        }\\n        int count =0;\\n        ListNode* temp1 = head;\\n\\n\\n\\n        while(temp1){\\n            count++;\\n            if(count==length){\\n                ListNode* sub=temp1->next;\\n                temp1->next=sub->next ;\\n                return head;\\n            }\\n            temp1=temp1->next;\\n        }\\n        return head;\\n    }\\n\\nJust take a counter variable to count length of an linkedlist and then do length-n to get the position, now iterate over linkedlist again until you get that point, once you get that node you can remove to get your answer. \\n\\nThere are 2 further edge cases which I have mentioned above."
                    }
                ]
            },
            {
                "id": 1767986,
                "content": [
                    {
                        "username": "skodzh",
                        "content": "why head.next is null for the first test case?\\nListNode tmp=head.next.next;\\nCrashes with npe."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/19_Remove_Nth_Node_From_End_of_List.cpp"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "_tushar_13",
                        "content": "it gives error for a testcase with one element [1]\\nclass Solution:\\n\\tdef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\t\\tdummy=head;curr=dummy\\n\\t\\tlength=0\\n\\t\\twhile curr:\\n\\t\\t\\tlength+=1\\n\\t\\t\\tcurr=curr.next\\n\\t\\tindex=(length-n);now=dummy\\n\\t\\twhile (now):\\n\\t\\t\\tindex-=1\\n\\t\\t\\tif index==0:\\n\\t\\t\\t\\tnow.next=now.next.next  \\n\\t\\t\\tnow=now.next\\n\\t\\treturn dummy\\n##help##"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ravichaudhary2372000",
                        "content": "   Java solution \n\n class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode start = new ListNode();\n        start.next = head;\n        ListNode fast = start;\n        ListNode slow = start;     \n\n        for(int i = 1; i <= n; ++i)\n            fast = fast.next;\n    \n        while(fast.next != null)\n        {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        slow.next = slow.next.next;\n        \n        return start.next;\n    }\n}"
                    },
                    {
                        "username": "magpro_18",
                        "content": "why is my code showing this error on using a while loop-\\nLine 24: Char 22: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:22"
                    },
                    {
                        "username": "BenArviv",
                        "content": "Can someone explain to me why my code doesn\\'t work?\\nIn fact, it do works in my environment, but here it fails on the test {[1, 2, 3, 4, 5], 2}.\\nIf anyone has some insights, it would be great!\\nFor some reason it doesn\\'t let me display my entire code as a code, so it starts from the \\'if\\'.\\n\\nif head == None:\\n        return None\\n    temp = ListNode()\\n    prev = ListNode()\\n    length = 0 # The length of the linked-list\\n    temp = head\\n    while temp.next != None:\\n        temp = temp.next\\n        length += 1\\n    \\n    temp = head\\n    prev = None\\n    k = length - n\\n    for i in range(k):\\n        prev = temp\\n        temp = temp.next\\n        \\n    if prev != None:\\n        prev.next = temp.next\\n    \\n    return head"
                    },
                    {
                        "username": "pramodacharya",
                        "content": "You have several mistakes in your code, as pointed below\\n\\n1) First, your calculation of length is incorrect. It is counting one less node. Check it by printing the length after you calculate\\n\\n2) Second you are not handling the edge case of k = 0, which is the case where head itself needs to be removed\\n\\n3) Finally, at the end you are checking whether prev is None, which is wrong. You should check whether temp is None instead.\\n\\nI copied your code and fixed above 3 mistakes and it passed. \\nLet me know if you need more help."
                    },
                    {
                        "username": "akku18tiwari",
                        "content": " `/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fill(vector<ListNode*>& vec, ListNode* head){\\n        if(head == NULL) return;\\n\\n        vec.push_back(head);\\n        fill(vec, head->next);\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> vec;\\n        fill(vec, head);\\n        int t = vec.size() - n;\\n        vec[t-1]->next = vec[t+1];\\n        delete(vec[t]);\\n        return head;\\n        // int sz = vec.size();\\n        // vec[sz-2]->next = NULL;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        \\n    }\\n};`\\n\\ncan someone please tell why this code is giving error?\\nI am clueless what is wrong. "
                    },
                    {
                        "username": "mrdemoncyborg007",
                        "content": "# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        k=1\\n        p=head\\n        while p.next!=None:\\n            k+=1\\n            p=p.next\\n        print(k)\\n        k=k-n\\n        p=head\\n        q=head.next\\n        while k>1:\\n            k-=1\\n            p=p.next\\n            q=q.next\\n        print(p.next)\\n        p.next=q.next\\n        q.next=None\\n        return head\\n        \\n\\n\\nhere it says on line 27 p.next=q.next \"Nonetype\" object has no attribute \\'next\\' but if i dont do assign and just print p.next it prints and when i see its type with type() it shows linklist what is the problem if anyone could tell it will be of great help"
                    }
                ]
            },
            {
                "id": 1767463,
                "content": [
                    {
                        "username": "skodzh",
                        "content": "why head.next is null for the first test case?\\nListNode tmp=head.next.next;\\nCrashes with npe."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/19_Remove_Nth_Node_From_End_of_List.cpp"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "_tushar_13",
                        "content": "it gives error for a testcase with one element [1]\\nclass Solution:\\n\\tdef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\t\\tdummy=head;curr=dummy\\n\\t\\tlength=0\\n\\t\\twhile curr:\\n\\t\\t\\tlength+=1\\n\\t\\t\\tcurr=curr.next\\n\\t\\tindex=(length-n);now=dummy\\n\\t\\twhile (now):\\n\\t\\t\\tindex-=1\\n\\t\\t\\tif index==0:\\n\\t\\t\\t\\tnow.next=now.next.next  \\n\\t\\t\\tnow=now.next\\n\\t\\treturn dummy\\n##help##"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ravichaudhary2372000",
                        "content": "   Java solution \n\n class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode start = new ListNode();\n        start.next = head;\n        ListNode fast = start;\n        ListNode slow = start;     \n\n        for(int i = 1; i <= n; ++i)\n            fast = fast.next;\n    \n        while(fast.next != null)\n        {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        slow.next = slow.next.next;\n        \n        return start.next;\n    }\n}"
                    },
                    {
                        "username": "magpro_18",
                        "content": "why is my code showing this error on using a while loop-\\nLine 24: Char 22: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:22"
                    },
                    {
                        "username": "BenArviv",
                        "content": "Can someone explain to me why my code doesn\\'t work?\\nIn fact, it do works in my environment, but here it fails on the test {[1, 2, 3, 4, 5], 2}.\\nIf anyone has some insights, it would be great!\\nFor some reason it doesn\\'t let me display my entire code as a code, so it starts from the \\'if\\'.\\n\\nif head == None:\\n        return None\\n    temp = ListNode()\\n    prev = ListNode()\\n    length = 0 # The length of the linked-list\\n    temp = head\\n    while temp.next != None:\\n        temp = temp.next\\n        length += 1\\n    \\n    temp = head\\n    prev = None\\n    k = length - n\\n    for i in range(k):\\n        prev = temp\\n        temp = temp.next\\n        \\n    if prev != None:\\n        prev.next = temp.next\\n    \\n    return head"
                    },
                    {
                        "username": "pramodacharya",
                        "content": "You have several mistakes in your code, as pointed below\\n\\n1) First, your calculation of length is incorrect. It is counting one less node. Check it by printing the length after you calculate\\n\\n2) Second you are not handling the edge case of k = 0, which is the case where head itself needs to be removed\\n\\n3) Finally, at the end you are checking whether prev is None, which is wrong. You should check whether temp is None instead.\\n\\nI copied your code and fixed above 3 mistakes and it passed. \\nLet me know if you need more help."
                    },
                    {
                        "username": "akku18tiwari",
                        "content": " `/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fill(vector<ListNode*>& vec, ListNode* head){\\n        if(head == NULL) return;\\n\\n        vec.push_back(head);\\n        fill(vec, head->next);\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> vec;\\n        fill(vec, head);\\n        int t = vec.size() - n;\\n        vec[t-1]->next = vec[t+1];\\n        delete(vec[t]);\\n        return head;\\n        // int sz = vec.size();\\n        // vec[sz-2]->next = NULL;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        \\n    }\\n};`\\n\\ncan someone please tell why this code is giving error?\\nI am clueless what is wrong. "
                    },
                    {
                        "username": "mrdemoncyborg007",
                        "content": "# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        k=1\\n        p=head\\n        while p.next!=None:\\n            k+=1\\n            p=p.next\\n        print(k)\\n        k=k-n\\n        p=head\\n        q=head.next\\n        while k>1:\\n            k-=1\\n            p=p.next\\n            q=q.next\\n        print(p.next)\\n        p.next=q.next\\n        q.next=None\\n        return head\\n        \\n\\n\\nhere it says on line 27 p.next=q.next \"Nonetype\" object has no attribute \\'next\\' but if i dont do assign and just print p.next it prints and when i see its type with type() it shows linklist what is the problem if anyone could tell it will be of great help"
                    }
                ]
            },
            {
                "id": 1762738,
                "content": [
                    {
                        "username": "skodzh",
                        "content": "why head.next is null for the first test case?\\nListNode tmp=head.next.next;\\nCrashes with npe."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/19_Remove_Nth_Node_From_End_of_List.cpp"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "_tushar_13",
                        "content": "it gives error for a testcase with one element [1]\\nclass Solution:\\n\\tdef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\t\\tdummy=head;curr=dummy\\n\\t\\tlength=0\\n\\t\\twhile curr:\\n\\t\\t\\tlength+=1\\n\\t\\t\\tcurr=curr.next\\n\\t\\tindex=(length-n);now=dummy\\n\\t\\twhile (now):\\n\\t\\t\\tindex-=1\\n\\t\\t\\tif index==0:\\n\\t\\t\\t\\tnow.next=now.next.next  \\n\\t\\t\\tnow=now.next\\n\\t\\treturn dummy\\n##help##"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ravichaudhary2372000",
                        "content": "   Java solution \n\n class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode start = new ListNode();\n        start.next = head;\n        ListNode fast = start;\n        ListNode slow = start;     \n\n        for(int i = 1; i <= n; ++i)\n            fast = fast.next;\n    \n        while(fast.next != null)\n        {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        slow.next = slow.next.next;\n        \n        return start.next;\n    }\n}"
                    },
                    {
                        "username": "magpro_18",
                        "content": "why is my code showing this error on using a while loop-\\nLine 24: Char 22: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:22"
                    },
                    {
                        "username": "BenArviv",
                        "content": "Can someone explain to me why my code doesn\\'t work?\\nIn fact, it do works in my environment, but here it fails on the test {[1, 2, 3, 4, 5], 2}.\\nIf anyone has some insights, it would be great!\\nFor some reason it doesn\\'t let me display my entire code as a code, so it starts from the \\'if\\'.\\n\\nif head == None:\\n        return None\\n    temp = ListNode()\\n    prev = ListNode()\\n    length = 0 # The length of the linked-list\\n    temp = head\\n    while temp.next != None:\\n        temp = temp.next\\n        length += 1\\n    \\n    temp = head\\n    prev = None\\n    k = length - n\\n    for i in range(k):\\n        prev = temp\\n        temp = temp.next\\n        \\n    if prev != None:\\n        prev.next = temp.next\\n    \\n    return head"
                    },
                    {
                        "username": "pramodacharya",
                        "content": "You have several mistakes in your code, as pointed below\\n\\n1) First, your calculation of length is incorrect. It is counting one less node. Check it by printing the length after you calculate\\n\\n2) Second you are not handling the edge case of k = 0, which is the case where head itself needs to be removed\\n\\n3) Finally, at the end you are checking whether prev is None, which is wrong. You should check whether temp is None instead.\\n\\nI copied your code and fixed above 3 mistakes and it passed. \\nLet me know if you need more help."
                    },
                    {
                        "username": "akku18tiwari",
                        "content": " `/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fill(vector<ListNode*>& vec, ListNode* head){\\n        if(head == NULL) return;\\n\\n        vec.push_back(head);\\n        fill(vec, head->next);\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> vec;\\n        fill(vec, head);\\n        int t = vec.size() - n;\\n        vec[t-1]->next = vec[t+1];\\n        delete(vec[t]);\\n        return head;\\n        // int sz = vec.size();\\n        // vec[sz-2]->next = NULL;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        \\n    }\\n};`\\n\\ncan someone please tell why this code is giving error?\\nI am clueless what is wrong. "
                    },
                    {
                        "username": "mrdemoncyborg007",
                        "content": "# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        k=1\\n        p=head\\n        while p.next!=None:\\n            k+=1\\n            p=p.next\\n        print(k)\\n        k=k-n\\n        p=head\\n        q=head.next\\n        while k>1:\\n            k-=1\\n            p=p.next\\n            q=q.next\\n        print(p.next)\\n        p.next=q.next\\n        q.next=None\\n        return head\\n        \\n\\n\\nhere it says on line 27 p.next=q.next \"Nonetype\" object has no attribute \\'next\\' but if i dont do assign and just print p.next it prints and when i see its type with type() it shows linklist what is the problem if anyone could tell it will be of great help"
                    }
                ]
            },
            {
                "id": 1761939,
                "content": [
                    {
                        "username": "skodzh",
                        "content": "why head.next is null for the first test case?\\nListNode tmp=head.next.next;\\nCrashes with npe."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/19_Remove_Nth_Node_From_End_of_List.cpp"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "_tushar_13",
                        "content": "it gives error for a testcase with one element [1]\\nclass Solution:\\n\\tdef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\t\\tdummy=head;curr=dummy\\n\\t\\tlength=0\\n\\t\\twhile curr:\\n\\t\\t\\tlength+=1\\n\\t\\t\\tcurr=curr.next\\n\\t\\tindex=(length-n);now=dummy\\n\\t\\twhile (now):\\n\\t\\t\\tindex-=1\\n\\t\\t\\tif index==0:\\n\\t\\t\\t\\tnow.next=now.next.next  \\n\\t\\t\\tnow=now.next\\n\\t\\treturn dummy\\n##help##"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ravichaudhary2372000",
                        "content": "   Java solution \n\n class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode start = new ListNode();\n        start.next = head;\n        ListNode fast = start;\n        ListNode slow = start;     \n\n        for(int i = 1; i <= n; ++i)\n            fast = fast.next;\n    \n        while(fast.next != null)\n        {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        slow.next = slow.next.next;\n        \n        return start.next;\n    }\n}"
                    },
                    {
                        "username": "magpro_18",
                        "content": "why is my code showing this error on using a while loop-\\nLine 24: Char 22: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:22"
                    },
                    {
                        "username": "BenArviv",
                        "content": "Can someone explain to me why my code doesn\\'t work?\\nIn fact, it do works in my environment, but here it fails on the test {[1, 2, 3, 4, 5], 2}.\\nIf anyone has some insights, it would be great!\\nFor some reason it doesn\\'t let me display my entire code as a code, so it starts from the \\'if\\'.\\n\\nif head == None:\\n        return None\\n    temp = ListNode()\\n    prev = ListNode()\\n    length = 0 # The length of the linked-list\\n    temp = head\\n    while temp.next != None:\\n        temp = temp.next\\n        length += 1\\n    \\n    temp = head\\n    prev = None\\n    k = length - n\\n    for i in range(k):\\n        prev = temp\\n        temp = temp.next\\n        \\n    if prev != None:\\n        prev.next = temp.next\\n    \\n    return head"
                    },
                    {
                        "username": "pramodacharya",
                        "content": "You have several mistakes in your code, as pointed below\\n\\n1) First, your calculation of length is incorrect. It is counting one less node. Check it by printing the length after you calculate\\n\\n2) Second you are not handling the edge case of k = 0, which is the case where head itself needs to be removed\\n\\n3) Finally, at the end you are checking whether prev is None, which is wrong. You should check whether temp is None instead.\\n\\nI copied your code and fixed above 3 mistakes and it passed. \\nLet me know if you need more help."
                    },
                    {
                        "username": "akku18tiwari",
                        "content": " `/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fill(vector<ListNode*>& vec, ListNode* head){\\n        if(head == NULL) return;\\n\\n        vec.push_back(head);\\n        fill(vec, head->next);\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> vec;\\n        fill(vec, head);\\n        int t = vec.size() - n;\\n        vec[t-1]->next = vec[t+1];\\n        delete(vec[t]);\\n        return head;\\n        // int sz = vec.size();\\n        // vec[sz-2]->next = NULL;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        \\n    }\\n};`\\n\\ncan someone please tell why this code is giving error?\\nI am clueless what is wrong. "
                    },
                    {
                        "username": "mrdemoncyborg007",
                        "content": "# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        k=1\\n        p=head\\n        while p.next!=None:\\n            k+=1\\n            p=p.next\\n        print(k)\\n        k=k-n\\n        p=head\\n        q=head.next\\n        while k>1:\\n            k-=1\\n            p=p.next\\n            q=q.next\\n        print(p.next)\\n        p.next=q.next\\n        q.next=None\\n        return head\\n        \\n\\n\\nhere it says on line 27 p.next=q.next \"Nonetype\" object has no attribute \\'next\\' but if i dont do assign and just print p.next it prints and when i see its type with type() it shows linklist what is the problem if anyone could tell it will be of great help"
                    }
                ]
            },
            {
                "id": 1760978,
                "content": [
                    {
                        "username": "skodzh",
                        "content": "why head.next is null for the first test case?\\nListNode tmp=head.next.next;\\nCrashes with npe."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/19_Remove_Nth_Node_From_End_of_List.cpp"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "_tushar_13",
                        "content": "it gives error for a testcase with one element [1]\\nclass Solution:\\n\\tdef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\t\\tdummy=head;curr=dummy\\n\\t\\tlength=0\\n\\t\\twhile curr:\\n\\t\\t\\tlength+=1\\n\\t\\t\\tcurr=curr.next\\n\\t\\tindex=(length-n);now=dummy\\n\\t\\twhile (now):\\n\\t\\t\\tindex-=1\\n\\t\\t\\tif index==0:\\n\\t\\t\\t\\tnow.next=now.next.next  \\n\\t\\t\\tnow=now.next\\n\\t\\treturn dummy\\n##help##"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ravichaudhary2372000",
                        "content": "   Java solution \n\n class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode start = new ListNode();\n        start.next = head;\n        ListNode fast = start;\n        ListNode slow = start;     \n\n        for(int i = 1; i <= n; ++i)\n            fast = fast.next;\n    \n        while(fast.next != null)\n        {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        slow.next = slow.next.next;\n        \n        return start.next;\n    }\n}"
                    },
                    {
                        "username": "magpro_18",
                        "content": "why is my code showing this error on using a while loop-\\nLine 24: Char 22: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:22"
                    },
                    {
                        "username": "BenArviv",
                        "content": "Can someone explain to me why my code doesn\\'t work?\\nIn fact, it do works in my environment, but here it fails on the test {[1, 2, 3, 4, 5], 2}.\\nIf anyone has some insights, it would be great!\\nFor some reason it doesn\\'t let me display my entire code as a code, so it starts from the \\'if\\'.\\n\\nif head == None:\\n        return None\\n    temp = ListNode()\\n    prev = ListNode()\\n    length = 0 # The length of the linked-list\\n    temp = head\\n    while temp.next != None:\\n        temp = temp.next\\n        length += 1\\n    \\n    temp = head\\n    prev = None\\n    k = length - n\\n    for i in range(k):\\n        prev = temp\\n        temp = temp.next\\n        \\n    if prev != None:\\n        prev.next = temp.next\\n    \\n    return head"
                    },
                    {
                        "username": "pramodacharya",
                        "content": "You have several mistakes in your code, as pointed below\\n\\n1) First, your calculation of length is incorrect. It is counting one less node. Check it by printing the length after you calculate\\n\\n2) Second you are not handling the edge case of k = 0, which is the case where head itself needs to be removed\\n\\n3) Finally, at the end you are checking whether prev is None, which is wrong. You should check whether temp is None instead.\\n\\nI copied your code and fixed above 3 mistakes and it passed. \\nLet me know if you need more help."
                    },
                    {
                        "username": "akku18tiwari",
                        "content": " `/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fill(vector<ListNode*>& vec, ListNode* head){\\n        if(head == NULL) return;\\n\\n        vec.push_back(head);\\n        fill(vec, head->next);\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> vec;\\n        fill(vec, head);\\n        int t = vec.size() - n;\\n        vec[t-1]->next = vec[t+1];\\n        delete(vec[t]);\\n        return head;\\n        // int sz = vec.size();\\n        // vec[sz-2]->next = NULL;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        \\n    }\\n};`\\n\\ncan someone please tell why this code is giving error?\\nI am clueless what is wrong. "
                    },
                    {
                        "username": "mrdemoncyborg007",
                        "content": "# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        k=1\\n        p=head\\n        while p.next!=None:\\n            k+=1\\n            p=p.next\\n        print(k)\\n        k=k-n\\n        p=head\\n        q=head.next\\n        while k>1:\\n            k-=1\\n            p=p.next\\n            q=q.next\\n        print(p.next)\\n        p.next=q.next\\n        q.next=None\\n        return head\\n        \\n\\n\\nhere it says on line 27 p.next=q.next \"Nonetype\" object has no attribute \\'next\\' but if i dont do assign and just print p.next it prints and when i see its type with type() it shows linklist what is the problem if anyone could tell it will be of great help"
                    }
                ]
            },
            {
                "id": 1759142,
                "content": [
                    {
                        "username": "skodzh",
                        "content": "why head.next is null for the first test case?\\nListNode tmp=head.next.next;\\nCrashes with npe."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/19_Remove_Nth_Node_From_End_of_List.cpp"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "_tushar_13",
                        "content": "it gives error for a testcase with one element [1]\\nclass Solution:\\n\\tdef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\t\\tdummy=head;curr=dummy\\n\\t\\tlength=0\\n\\t\\twhile curr:\\n\\t\\t\\tlength+=1\\n\\t\\t\\tcurr=curr.next\\n\\t\\tindex=(length-n);now=dummy\\n\\t\\twhile (now):\\n\\t\\t\\tindex-=1\\n\\t\\t\\tif index==0:\\n\\t\\t\\t\\tnow.next=now.next.next  \\n\\t\\t\\tnow=now.next\\n\\t\\treturn dummy\\n##help##"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ravichaudhary2372000",
                        "content": "   Java solution \n\n class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode start = new ListNode();\n        start.next = head;\n        ListNode fast = start;\n        ListNode slow = start;     \n\n        for(int i = 1; i <= n; ++i)\n            fast = fast.next;\n    \n        while(fast.next != null)\n        {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        slow.next = slow.next.next;\n        \n        return start.next;\n    }\n}"
                    },
                    {
                        "username": "magpro_18",
                        "content": "why is my code showing this error on using a while loop-\\nLine 24: Char 22: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:22"
                    },
                    {
                        "username": "BenArviv",
                        "content": "Can someone explain to me why my code doesn\\'t work?\\nIn fact, it do works in my environment, but here it fails on the test {[1, 2, 3, 4, 5], 2}.\\nIf anyone has some insights, it would be great!\\nFor some reason it doesn\\'t let me display my entire code as a code, so it starts from the \\'if\\'.\\n\\nif head == None:\\n        return None\\n    temp = ListNode()\\n    prev = ListNode()\\n    length = 0 # The length of the linked-list\\n    temp = head\\n    while temp.next != None:\\n        temp = temp.next\\n        length += 1\\n    \\n    temp = head\\n    prev = None\\n    k = length - n\\n    for i in range(k):\\n        prev = temp\\n        temp = temp.next\\n        \\n    if prev != None:\\n        prev.next = temp.next\\n    \\n    return head"
                    },
                    {
                        "username": "pramodacharya",
                        "content": "You have several mistakes in your code, as pointed below\\n\\n1) First, your calculation of length is incorrect. It is counting one less node. Check it by printing the length after you calculate\\n\\n2) Second you are not handling the edge case of k = 0, which is the case where head itself needs to be removed\\n\\n3) Finally, at the end you are checking whether prev is None, which is wrong. You should check whether temp is None instead.\\n\\nI copied your code and fixed above 3 mistakes and it passed. \\nLet me know if you need more help."
                    },
                    {
                        "username": "akku18tiwari",
                        "content": " `/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fill(vector<ListNode*>& vec, ListNode* head){\\n        if(head == NULL) return;\\n\\n        vec.push_back(head);\\n        fill(vec, head->next);\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> vec;\\n        fill(vec, head);\\n        int t = vec.size() - n;\\n        vec[t-1]->next = vec[t+1];\\n        delete(vec[t]);\\n        return head;\\n        // int sz = vec.size();\\n        // vec[sz-2]->next = NULL;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        \\n    }\\n};`\\n\\ncan someone please tell why this code is giving error?\\nI am clueless what is wrong. "
                    },
                    {
                        "username": "mrdemoncyborg007",
                        "content": "# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        k=1\\n        p=head\\n        while p.next!=None:\\n            k+=1\\n            p=p.next\\n        print(k)\\n        k=k-n\\n        p=head\\n        q=head.next\\n        while k>1:\\n            k-=1\\n            p=p.next\\n            q=q.next\\n        print(p.next)\\n        p.next=q.next\\n        q.next=None\\n        return head\\n        \\n\\n\\nhere it says on line 27 p.next=q.next \"Nonetype\" object has no attribute \\'next\\' but if i dont do assign and just print p.next it prints and when i see its type with type() it shows linklist what is the problem if anyone could tell it will be of great help"
                    }
                ]
            },
            {
                "id": 1757564,
                "content": [
                    {
                        "username": "skodzh",
                        "content": "why head.next is null for the first test case?\\nListNode tmp=head.next.next;\\nCrashes with npe."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/19_Remove_Nth_Node_From_End_of_List.cpp"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "_tushar_13",
                        "content": "it gives error for a testcase with one element [1]\\nclass Solution:\\n\\tdef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\t\\tdummy=head;curr=dummy\\n\\t\\tlength=0\\n\\t\\twhile curr:\\n\\t\\t\\tlength+=1\\n\\t\\t\\tcurr=curr.next\\n\\t\\tindex=(length-n);now=dummy\\n\\t\\twhile (now):\\n\\t\\t\\tindex-=1\\n\\t\\t\\tif index==0:\\n\\t\\t\\t\\tnow.next=now.next.next  \\n\\t\\t\\tnow=now.next\\n\\t\\treturn dummy\\n##help##"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ravichaudhary2372000",
                        "content": "   Java solution \n\n class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode start = new ListNode();\n        start.next = head;\n        ListNode fast = start;\n        ListNode slow = start;     \n\n        for(int i = 1; i <= n; ++i)\n            fast = fast.next;\n    \n        while(fast.next != null)\n        {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        slow.next = slow.next.next;\n        \n        return start.next;\n    }\n}"
                    },
                    {
                        "username": "magpro_18",
                        "content": "why is my code showing this error on using a while loop-\\nLine 24: Char 22: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:22"
                    },
                    {
                        "username": "BenArviv",
                        "content": "Can someone explain to me why my code doesn\\'t work?\\nIn fact, it do works in my environment, but here it fails on the test {[1, 2, 3, 4, 5], 2}.\\nIf anyone has some insights, it would be great!\\nFor some reason it doesn\\'t let me display my entire code as a code, so it starts from the \\'if\\'.\\n\\nif head == None:\\n        return None\\n    temp = ListNode()\\n    prev = ListNode()\\n    length = 0 # The length of the linked-list\\n    temp = head\\n    while temp.next != None:\\n        temp = temp.next\\n        length += 1\\n    \\n    temp = head\\n    prev = None\\n    k = length - n\\n    for i in range(k):\\n        prev = temp\\n        temp = temp.next\\n        \\n    if prev != None:\\n        prev.next = temp.next\\n    \\n    return head"
                    },
                    {
                        "username": "pramodacharya",
                        "content": "You have several mistakes in your code, as pointed below\\n\\n1) First, your calculation of length is incorrect. It is counting one less node. Check it by printing the length after you calculate\\n\\n2) Second you are not handling the edge case of k = 0, which is the case where head itself needs to be removed\\n\\n3) Finally, at the end you are checking whether prev is None, which is wrong. You should check whether temp is None instead.\\n\\nI copied your code and fixed above 3 mistakes and it passed. \\nLet me know if you need more help."
                    },
                    {
                        "username": "akku18tiwari",
                        "content": " `/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fill(vector<ListNode*>& vec, ListNode* head){\\n        if(head == NULL) return;\\n\\n        vec.push_back(head);\\n        fill(vec, head->next);\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> vec;\\n        fill(vec, head);\\n        int t = vec.size() - n;\\n        vec[t-1]->next = vec[t+1];\\n        delete(vec[t]);\\n        return head;\\n        // int sz = vec.size();\\n        // vec[sz-2]->next = NULL;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        \\n    }\\n};`\\n\\ncan someone please tell why this code is giving error?\\nI am clueless what is wrong. "
                    },
                    {
                        "username": "mrdemoncyborg007",
                        "content": "# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        k=1\\n        p=head\\n        while p.next!=None:\\n            k+=1\\n            p=p.next\\n        print(k)\\n        k=k-n\\n        p=head\\n        q=head.next\\n        while k>1:\\n            k-=1\\n            p=p.next\\n            q=q.next\\n        print(p.next)\\n        p.next=q.next\\n        q.next=None\\n        return head\\n        \\n\\n\\nhere it says on line 27 p.next=q.next \"Nonetype\" object has no attribute \\'next\\' but if i dont do assign and just print p.next it prints and when i see its type with type() it shows linklist what is the problem if anyone could tell it will be of great help"
                    }
                ]
            },
            {
                "id": 1757307,
                "content": [
                    {
                        "username": "skodzh",
                        "content": "why head.next is null for the first test case?\\nListNode tmp=head.next.next;\\nCrashes with npe."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/19_Remove_Nth_Node_From_End_of_List.cpp"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "_tushar_13",
                        "content": "it gives error for a testcase with one element [1]\\nclass Solution:\\n\\tdef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\t\\tdummy=head;curr=dummy\\n\\t\\tlength=0\\n\\t\\twhile curr:\\n\\t\\t\\tlength+=1\\n\\t\\t\\tcurr=curr.next\\n\\t\\tindex=(length-n);now=dummy\\n\\t\\twhile (now):\\n\\t\\t\\tindex-=1\\n\\t\\t\\tif index==0:\\n\\t\\t\\t\\tnow.next=now.next.next  \\n\\t\\t\\tnow=now.next\\n\\t\\treturn dummy\\n##help##"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ravichaudhary2372000",
                        "content": "   Java solution \n\n class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode start = new ListNode();\n        start.next = head;\n        ListNode fast = start;\n        ListNode slow = start;     \n\n        for(int i = 1; i <= n; ++i)\n            fast = fast.next;\n    \n        while(fast.next != null)\n        {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        slow.next = slow.next.next;\n        \n        return start.next;\n    }\n}"
                    },
                    {
                        "username": "magpro_18",
                        "content": "why is my code showing this error on using a while loop-\\nLine 24: Char 22: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:22"
                    },
                    {
                        "username": "BenArviv",
                        "content": "Can someone explain to me why my code doesn\\'t work?\\nIn fact, it do works in my environment, but here it fails on the test {[1, 2, 3, 4, 5], 2}.\\nIf anyone has some insights, it would be great!\\nFor some reason it doesn\\'t let me display my entire code as a code, so it starts from the \\'if\\'.\\n\\nif head == None:\\n        return None\\n    temp = ListNode()\\n    prev = ListNode()\\n    length = 0 # The length of the linked-list\\n    temp = head\\n    while temp.next != None:\\n        temp = temp.next\\n        length += 1\\n    \\n    temp = head\\n    prev = None\\n    k = length - n\\n    for i in range(k):\\n        prev = temp\\n        temp = temp.next\\n        \\n    if prev != None:\\n        prev.next = temp.next\\n    \\n    return head"
                    },
                    {
                        "username": "pramodacharya",
                        "content": "You have several mistakes in your code, as pointed below\\n\\n1) First, your calculation of length is incorrect. It is counting one less node. Check it by printing the length after you calculate\\n\\n2) Second you are not handling the edge case of k = 0, which is the case where head itself needs to be removed\\n\\n3) Finally, at the end you are checking whether prev is None, which is wrong. You should check whether temp is None instead.\\n\\nI copied your code and fixed above 3 mistakes and it passed. \\nLet me know if you need more help."
                    },
                    {
                        "username": "akku18tiwari",
                        "content": " `/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fill(vector<ListNode*>& vec, ListNode* head){\\n        if(head == NULL) return;\\n\\n        vec.push_back(head);\\n        fill(vec, head->next);\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> vec;\\n        fill(vec, head);\\n        int t = vec.size() - n;\\n        vec[t-1]->next = vec[t+1];\\n        delete(vec[t]);\\n        return head;\\n        // int sz = vec.size();\\n        // vec[sz-2]->next = NULL;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        \\n    }\\n};`\\n\\ncan someone please tell why this code is giving error?\\nI am clueless what is wrong. "
                    },
                    {
                        "username": "mrdemoncyborg007",
                        "content": "# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        k=1\\n        p=head\\n        while p.next!=None:\\n            k+=1\\n            p=p.next\\n        print(k)\\n        k=k-n\\n        p=head\\n        q=head.next\\n        while k>1:\\n            k-=1\\n            p=p.next\\n            q=q.next\\n        print(p.next)\\n        p.next=q.next\\n        q.next=None\\n        return head\\n        \\n\\n\\nhere it says on line 27 p.next=q.next \"Nonetype\" object has no attribute \\'next\\' but if i dont do assign and just print p.next it prints and when i see its type with type() it shows linklist what is the problem if anyone could tell it will be of great help"
                    }
                ]
            },
            {
                "id": 1752948,
                "content": [
                    {
                        "username": "skodzh",
                        "content": "why head.next is null for the first test case?\\nListNode tmp=head.next.next;\\nCrashes with npe."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/19_Remove_Nth_Node_From_End_of_List.cpp"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "_tushar_13",
                        "content": "it gives error for a testcase with one element [1]\\nclass Solution:\\n\\tdef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\t\\tdummy=head;curr=dummy\\n\\t\\tlength=0\\n\\t\\twhile curr:\\n\\t\\t\\tlength+=1\\n\\t\\t\\tcurr=curr.next\\n\\t\\tindex=(length-n);now=dummy\\n\\t\\twhile (now):\\n\\t\\t\\tindex-=1\\n\\t\\t\\tif index==0:\\n\\t\\t\\t\\tnow.next=now.next.next  \\n\\t\\t\\tnow=now.next\\n\\t\\treturn dummy\\n##help##"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ravichaudhary2372000",
                        "content": "   Java solution \n\n class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode start = new ListNode();\n        start.next = head;\n        ListNode fast = start;\n        ListNode slow = start;     \n\n        for(int i = 1; i <= n; ++i)\n            fast = fast.next;\n    \n        while(fast.next != null)\n        {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        slow.next = slow.next.next;\n        \n        return start.next;\n    }\n}"
                    },
                    {
                        "username": "magpro_18",
                        "content": "why is my code showing this error on using a while loop-\\nLine 24: Char 22: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:22"
                    },
                    {
                        "username": "BenArviv",
                        "content": "Can someone explain to me why my code doesn\\'t work?\\nIn fact, it do works in my environment, but here it fails on the test {[1, 2, 3, 4, 5], 2}.\\nIf anyone has some insights, it would be great!\\nFor some reason it doesn\\'t let me display my entire code as a code, so it starts from the \\'if\\'.\\n\\nif head == None:\\n        return None\\n    temp = ListNode()\\n    prev = ListNode()\\n    length = 0 # The length of the linked-list\\n    temp = head\\n    while temp.next != None:\\n        temp = temp.next\\n        length += 1\\n    \\n    temp = head\\n    prev = None\\n    k = length - n\\n    for i in range(k):\\n        prev = temp\\n        temp = temp.next\\n        \\n    if prev != None:\\n        prev.next = temp.next\\n    \\n    return head"
                    },
                    {
                        "username": "pramodacharya",
                        "content": "You have several mistakes in your code, as pointed below\\n\\n1) First, your calculation of length is incorrect. It is counting one less node. Check it by printing the length after you calculate\\n\\n2) Second you are not handling the edge case of k = 0, which is the case where head itself needs to be removed\\n\\n3) Finally, at the end you are checking whether prev is None, which is wrong. You should check whether temp is None instead.\\n\\nI copied your code and fixed above 3 mistakes and it passed. \\nLet me know if you need more help."
                    },
                    {
                        "username": "akku18tiwari",
                        "content": " `/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fill(vector<ListNode*>& vec, ListNode* head){\\n        if(head == NULL) return;\\n\\n        vec.push_back(head);\\n        fill(vec, head->next);\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> vec;\\n        fill(vec, head);\\n        int t = vec.size() - n;\\n        vec[t-1]->next = vec[t+1];\\n        delete(vec[t]);\\n        return head;\\n        // int sz = vec.size();\\n        // vec[sz-2]->next = NULL;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        \\n    }\\n};`\\n\\ncan someone please tell why this code is giving error?\\nI am clueless what is wrong. "
                    },
                    {
                        "username": "mrdemoncyborg007",
                        "content": "# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        k=1\\n        p=head\\n        while p.next!=None:\\n            k+=1\\n            p=p.next\\n        print(k)\\n        k=k-n\\n        p=head\\n        q=head.next\\n        while k>1:\\n            k-=1\\n            p=p.next\\n            q=q.next\\n        print(p.next)\\n        p.next=q.next\\n        q.next=None\\n        return head\\n        \\n\\n\\nhere it says on line 27 p.next=q.next \"Nonetype\" object has no attribute \\'next\\' but if i dont do assign and just print p.next it prints and when i see its type with type() it shows linklist what is the problem if anyone could tell it will be of great help"
                    }
                ]
            },
            {
                "id": 1752910,
                "content": [
                    {
                        "username": "skodzh",
                        "content": "why head.next is null for the first test case?\\nListNode tmp=head.next.next;\\nCrashes with npe."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/19_Remove_Nth_Node_From_End_of_List.cpp"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "_tushar_13",
                        "content": "it gives error for a testcase with one element [1]\\nclass Solution:\\n\\tdef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\t\\tdummy=head;curr=dummy\\n\\t\\tlength=0\\n\\t\\twhile curr:\\n\\t\\t\\tlength+=1\\n\\t\\t\\tcurr=curr.next\\n\\t\\tindex=(length-n);now=dummy\\n\\t\\twhile (now):\\n\\t\\t\\tindex-=1\\n\\t\\t\\tif index==0:\\n\\t\\t\\t\\tnow.next=now.next.next  \\n\\t\\t\\tnow=now.next\\n\\t\\treturn dummy\\n##help##"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ravichaudhary2372000",
                        "content": "   Java solution \n\n class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode start = new ListNode();\n        start.next = head;\n        ListNode fast = start;\n        ListNode slow = start;     \n\n        for(int i = 1; i <= n; ++i)\n            fast = fast.next;\n    \n        while(fast.next != null)\n        {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        slow.next = slow.next.next;\n        \n        return start.next;\n    }\n}"
                    },
                    {
                        "username": "magpro_18",
                        "content": "why is my code showing this error on using a while loop-\\nLine 24: Char 22: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:22"
                    },
                    {
                        "username": "BenArviv",
                        "content": "Can someone explain to me why my code doesn\\'t work?\\nIn fact, it do works in my environment, but here it fails on the test {[1, 2, 3, 4, 5], 2}.\\nIf anyone has some insights, it would be great!\\nFor some reason it doesn\\'t let me display my entire code as a code, so it starts from the \\'if\\'.\\n\\nif head == None:\\n        return None\\n    temp = ListNode()\\n    prev = ListNode()\\n    length = 0 # The length of the linked-list\\n    temp = head\\n    while temp.next != None:\\n        temp = temp.next\\n        length += 1\\n    \\n    temp = head\\n    prev = None\\n    k = length - n\\n    for i in range(k):\\n        prev = temp\\n        temp = temp.next\\n        \\n    if prev != None:\\n        prev.next = temp.next\\n    \\n    return head"
                    },
                    {
                        "username": "pramodacharya",
                        "content": "You have several mistakes in your code, as pointed below\\n\\n1) First, your calculation of length is incorrect. It is counting one less node. Check it by printing the length after you calculate\\n\\n2) Second you are not handling the edge case of k = 0, which is the case where head itself needs to be removed\\n\\n3) Finally, at the end you are checking whether prev is None, which is wrong. You should check whether temp is None instead.\\n\\nI copied your code and fixed above 3 mistakes and it passed. \\nLet me know if you need more help."
                    },
                    {
                        "username": "akku18tiwari",
                        "content": " `/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fill(vector<ListNode*>& vec, ListNode* head){\\n        if(head == NULL) return;\\n\\n        vec.push_back(head);\\n        fill(vec, head->next);\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> vec;\\n        fill(vec, head);\\n        int t = vec.size() - n;\\n        vec[t-1]->next = vec[t+1];\\n        delete(vec[t]);\\n        return head;\\n        // int sz = vec.size();\\n        // vec[sz-2]->next = NULL;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        \\n    }\\n};`\\n\\ncan someone please tell why this code is giving error?\\nI am clueless what is wrong. "
                    },
                    {
                        "username": "mrdemoncyborg007",
                        "content": "# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        k=1\\n        p=head\\n        while p.next!=None:\\n            k+=1\\n            p=p.next\\n        print(k)\\n        k=k-n\\n        p=head\\n        q=head.next\\n        while k>1:\\n            k-=1\\n            p=p.next\\n            q=q.next\\n        print(p.next)\\n        p.next=q.next\\n        q.next=None\\n        return head\\n        \\n\\n\\nhere it says on line 27 p.next=q.next \"Nonetype\" object has no attribute \\'next\\' but if i dont do assign and just print p.next it prints and when i see its type with type() it shows linklist what is the problem if anyone could tell it will be of great help"
                    }
                ]
            },
            {
                "id": 1751930,
                "content": [
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "CAPL1",
                        "content": "Can someone explain the usage of a dummy pointer. What edge cases would we run into if we were to just separate the fast/slow pointers from head."
                    },
                    {
                        "username": "tisha_2702",
                        "content": "Cannot read field \"next\" because \"<local3>\" is null\\n\\nI am getting this problem please suggest solution"
                    },
                    {
                        "username": "gyangav01",
                        "content": "Remove Nth Node From End of List Problem Solution in Leet code\\nHere is the solution:-[Click Here](https://gyangroupindia.blogspot.com/2022/12/remove-nth-node-from-end-of-list.html)"
                    },
                    {
                        "username": "Lucifer-dragneel00",
                        "content": "class Solution {\\n     \\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n   int length = 0; for(ListNode cur = head; cur != null; cur = cur.next) length++;\\n\\nif(length == n) {head = head.next; return head;}\\n\\nif(length == 1) return head;\\n\\nListNode l = head; for(int i = 1; i<length-n; i++) l = l.next;\\n\\nl.next = l.next.next;\\n        \\n       return  head;\\n           \\n    }\\n}"
                    },
                    {
                        "username": "Akashverma212",
                        "content": "My solution has passed and use to capture all nodes without using tail. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "deezyto",
                        "content": "In the test case [1], you need to return null."
                    },
                    {
                        "username": "ryanrenjith19",
                        "content": "Can anyone help me find the problem with this code?\\n\\nIts showing the following error :\\n\\nLine 39: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:48:36\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        ListNode* ptr1 = head;\\n        int count = 0;\\n\\n        if(ptr1->next == NULL)\\n            return NULL;\\n\\n        while(ptr1 != NULL)\\n        {\\n            count++;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1 = head;\\n\\n        count = count - n + 1;\\n\\n        while(count > 0)\\n        {\\n            count--;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1->next = (ptr1->next)->next;    //error line\\n\\n        return head;\\n    }\\n}; `"
                    },
                    {
                        "username": "havish05",
                        "content": "can somebody point out the mistake? It says 187 /208 testcases passed.\\n\\nllist=self.count(head)\\n        if head == None:\\n            return None\\n\\n        if head.next == None and n==1:\\n            return None\\n\\n        curr=head\\n        # print(llist)\\n        i=1\\n        while curr.next:\\n            if i==llist-n:\\n                curr.next=curr.next.next\\n                break\\n            else:\\n                curr=curr.next\\n                i+=1\\n        return head"
                    },
                    {
                        "username": "eugene09",
                        "content": "head = [1,2] and n = 2, more interestingly output is [2]\\n\\nWhy output is [2]? Can someone explain this problem, pls?\\n\\nI guess output should be [1];\\n"
                    }
                ]
            },
            {
                "id": 1743442,
                "content": [
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "CAPL1",
                        "content": "Can someone explain the usage of a dummy pointer. What edge cases would we run into if we were to just separate the fast/slow pointers from head."
                    },
                    {
                        "username": "tisha_2702",
                        "content": "Cannot read field \"next\" because \"<local3>\" is null\\n\\nI am getting this problem please suggest solution"
                    },
                    {
                        "username": "gyangav01",
                        "content": "Remove Nth Node From End of List Problem Solution in Leet code\\nHere is the solution:-[Click Here](https://gyangroupindia.blogspot.com/2022/12/remove-nth-node-from-end-of-list.html)"
                    },
                    {
                        "username": "Lucifer-dragneel00",
                        "content": "class Solution {\\n     \\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n   int length = 0; for(ListNode cur = head; cur != null; cur = cur.next) length++;\\n\\nif(length == n) {head = head.next; return head;}\\n\\nif(length == 1) return head;\\n\\nListNode l = head; for(int i = 1; i<length-n; i++) l = l.next;\\n\\nl.next = l.next.next;\\n        \\n       return  head;\\n           \\n    }\\n}"
                    },
                    {
                        "username": "Akashverma212",
                        "content": "My solution has passed and use to capture all nodes without using tail. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "deezyto",
                        "content": "In the test case [1], you need to return null."
                    },
                    {
                        "username": "ryanrenjith19",
                        "content": "Can anyone help me find the problem with this code?\\n\\nIts showing the following error :\\n\\nLine 39: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:48:36\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        ListNode* ptr1 = head;\\n        int count = 0;\\n\\n        if(ptr1->next == NULL)\\n            return NULL;\\n\\n        while(ptr1 != NULL)\\n        {\\n            count++;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1 = head;\\n\\n        count = count - n + 1;\\n\\n        while(count > 0)\\n        {\\n            count--;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1->next = (ptr1->next)->next;    //error line\\n\\n        return head;\\n    }\\n}; `"
                    },
                    {
                        "username": "havish05",
                        "content": "can somebody point out the mistake? It says 187 /208 testcases passed.\\n\\nllist=self.count(head)\\n        if head == None:\\n            return None\\n\\n        if head.next == None and n==1:\\n            return None\\n\\n        curr=head\\n        # print(llist)\\n        i=1\\n        while curr.next:\\n            if i==llist-n:\\n                curr.next=curr.next.next\\n                break\\n            else:\\n                curr=curr.next\\n                i+=1\\n        return head"
                    },
                    {
                        "username": "eugene09",
                        "content": "head = [1,2] and n = 2, more interestingly output is [2]\\n\\nWhy output is [2]? Can someone explain this problem, pls?\\n\\nI guess output should be [1];\\n"
                    }
                ]
            },
            {
                "id": 1742860,
                "content": [
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "CAPL1",
                        "content": "Can someone explain the usage of a dummy pointer. What edge cases would we run into if we were to just separate the fast/slow pointers from head."
                    },
                    {
                        "username": "tisha_2702",
                        "content": "Cannot read field \"next\" because \"<local3>\" is null\\n\\nI am getting this problem please suggest solution"
                    },
                    {
                        "username": "gyangav01",
                        "content": "Remove Nth Node From End of List Problem Solution in Leet code\\nHere is the solution:-[Click Here](https://gyangroupindia.blogspot.com/2022/12/remove-nth-node-from-end-of-list.html)"
                    },
                    {
                        "username": "Lucifer-dragneel00",
                        "content": "class Solution {\\n     \\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n   int length = 0; for(ListNode cur = head; cur != null; cur = cur.next) length++;\\n\\nif(length == n) {head = head.next; return head;}\\n\\nif(length == 1) return head;\\n\\nListNode l = head; for(int i = 1; i<length-n; i++) l = l.next;\\n\\nl.next = l.next.next;\\n        \\n       return  head;\\n           \\n    }\\n}"
                    },
                    {
                        "username": "Akashverma212",
                        "content": "My solution has passed and use to capture all nodes without using tail. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "deezyto",
                        "content": "In the test case [1], you need to return null."
                    },
                    {
                        "username": "ryanrenjith19",
                        "content": "Can anyone help me find the problem with this code?\\n\\nIts showing the following error :\\n\\nLine 39: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:48:36\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        ListNode* ptr1 = head;\\n        int count = 0;\\n\\n        if(ptr1->next == NULL)\\n            return NULL;\\n\\n        while(ptr1 != NULL)\\n        {\\n            count++;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1 = head;\\n\\n        count = count - n + 1;\\n\\n        while(count > 0)\\n        {\\n            count--;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1->next = (ptr1->next)->next;    //error line\\n\\n        return head;\\n    }\\n}; `"
                    },
                    {
                        "username": "havish05",
                        "content": "can somebody point out the mistake? It says 187 /208 testcases passed.\\n\\nllist=self.count(head)\\n        if head == None:\\n            return None\\n\\n        if head.next == None and n==1:\\n            return None\\n\\n        curr=head\\n        # print(llist)\\n        i=1\\n        while curr.next:\\n            if i==llist-n:\\n                curr.next=curr.next.next\\n                break\\n            else:\\n                curr=curr.next\\n                i+=1\\n        return head"
                    },
                    {
                        "username": "eugene09",
                        "content": "head = [1,2] and n = 2, more interestingly output is [2]\\n\\nWhy output is [2]? Can someone explain this problem, pls?\\n\\nI guess output should be [1];\\n"
                    }
                ]
            },
            {
                "id": 1731185,
                "content": [
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "CAPL1",
                        "content": "Can someone explain the usage of a dummy pointer. What edge cases would we run into if we were to just separate the fast/slow pointers from head."
                    },
                    {
                        "username": "tisha_2702",
                        "content": "Cannot read field \"next\" because \"<local3>\" is null\\n\\nI am getting this problem please suggest solution"
                    },
                    {
                        "username": "gyangav01",
                        "content": "Remove Nth Node From End of List Problem Solution in Leet code\\nHere is the solution:-[Click Here](https://gyangroupindia.blogspot.com/2022/12/remove-nth-node-from-end-of-list.html)"
                    },
                    {
                        "username": "Lucifer-dragneel00",
                        "content": "class Solution {\\n     \\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n   int length = 0; for(ListNode cur = head; cur != null; cur = cur.next) length++;\\n\\nif(length == n) {head = head.next; return head;}\\n\\nif(length == 1) return head;\\n\\nListNode l = head; for(int i = 1; i<length-n; i++) l = l.next;\\n\\nl.next = l.next.next;\\n        \\n       return  head;\\n           \\n    }\\n}"
                    },
                    {
                        "username": "Akashverma212",
                        "content": "My solution has passed and use to capture all nodes without using tail. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "deezyto",
                        "content": "In the test case [1], you need to return null."
                    },
                    {
                        "username": "ryanrenjith19",
                        "content": "Can anyone help me find the problem with this code?\\n\\nIts showing the following error :\\n\\nLine 39: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:48:36\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        ListNode* ptr1 = head;\\n        int count = 0;\\n\\n        if(ptr1->next == NULL)\\n            return NULL;\\n\\n        while(ptr1 != NULL)\\n        {\\n            count++;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1 = head;\\n\\n        count = count - n + 1;\\n\\n        while(count > 0)\\n        {\\n            count--;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1->next = (ptr1->next)->next;    //error line\\n\\n        return head;\\n    }\\n}; `"
                    },
                    {
                        "username": "havish05",
                        "content": "can somebody point out the mistake? It says 187 /208 testcases passed.\\n\\nllist=self.count(head)\\n        if head == None:\\n            return None\\n\\n        if head.next == None and n==1:\\n            return None\\n\\n        curr=head\\n        # print(llist)\\n        i=1\\n        while curr.next:\\n            if i==llist-n:\\n                curr.next=curr.next.next\\n                break\\n            else:\\n                curr=curr.next\\n                i+=1\\n        return head"
                    },
                    {
                        "username": "eugene09",
                        "content": "head = [1,2] and n = 2, more interestingly output is [2]\\n\\nWhy output is [2]? Can someone explain this problem, pls?\\n\\nI guess output should be [1];\\n"
                    }
                ]
            },
            {
                "id": 1729271,
                "content": [
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "CAPL1",
                        "content": "Can someone explain the usage of a dummy pointer. What edge cases would we run into if we were to just separate the fast/slow pointers from head."
                    },
                    {
                        "username": "tisha_2702",
                        "content": "Cannot read field \"next\" because \"<local3>\" is null\\n\\nI am getting this problem please suggest solution"
                    },
                    {
                        "username": "gyangav01",
                        "content": "Remove Nth Node From End of List Problem Solution in Leet code\\nHere is the solution:-[Click Here](https://gyangroupindia.blogspot.com/2022/12/remove-nth-node-from-end-of-list.html)"
                    },
                    {
                        "username": "Lucifer-dragneel00",
                        "content": "class Solution {\\n     \\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n   int length = 0; for(ListNode cur = head; cur != null; cur = cur.next) length++;\\n\\nif(length == n) {head = head.next; return head;}\\n\\nif(length == 1) return head;\\n\\nListNode l = head; for(int i = 1; i<length-n; i++) l = l.next;\\n\\nl.next = l.next.next;\\n        \\n       return  head;\\n           \\n    }\\n}"
                    },
                    {
                        "username": "Akashverma212",
                        "content": "My solution has passed and use to capture all nodes without using tail. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "deezyto",
                        "content": "In the test case [1], you need to return null."
                    },
                    {
                        "username": "ryanrenjith19",
                        "content": "Can anyone help me find the problem with this code?\\n\\nIts showing the following error :\\n\\nLine 39: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:48:36\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        ListNode* ptr1 = head;\\n        int count = 0;\\n\\n        if(ptr1->next == NULL)\\n            return NULL;\\n\\n        while(ptr1 != NULL)\\n        {\\n            count++;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1 = head;\\n\\n        count = count - n + 1;\\n\\n        while(count > 0)\\n        {\\n            count--;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1->next = (ptr1->next)->next;    //error line\\n\\n        return head;\\n    }\\n}; `"
                    },
                    {
                        "username": "havish05",
                        "content": "can somebody point out the mistake? It says 187 /208 testcases passed.\\n\\nllist=self.count(head)\\n        if head == None:\\n            return None\\n\\n        if head.next == None and n==1:\\n            return None\\n\\n        curr=head\\n        # print(llist)\\n        i=1\\n        while curr.next:\\n            if i==llist-n:\\n                curr.next=curr.next.next\\n                break\\n            else:\\n                curr=curr.next\\n                i+=1\\n        return head"
                    },
                    {
                        "username": "eugene09",
                        "content": "head = [1,2] and n = 2, more interestingly output is [2]\\n\\nWhy output is [2]? Can someone explain this problem, pls?\\n\\nI guess output should be [1];\\n"
                    }
                ]
            },
            {
                "id": 1729034,
                "content": [
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "CAPL1",
                        "content": "Can someone explain the usage of a dummy pointer. What edge cases would we run into if we were to just separate the fast/slow pointers from head."
                    },
                    {
                        "username": "tisha_2702",
                        "content": "Cannot read field \"next\" because \"<local3>\" is null\\n\\nI am getting this problem please suggest solution"
                    },
                    {
                        "username": "gyangav01",
                        "content": "Remove Nth Node From End of List Problem Solution in Leet code\\nHere is the solution:-[Click Here](https://gyangroupindia.blogspot.com/2022/12/remove-nth-node-from-end-of-list.html)"
                    },
                    {
                        "username": "Lucifer-dragneel00",
                        "content": "class Solution {\\n     \\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n   int length = 0; for(ListNode cur = head; cur != null; cur = cur.next) length++;\\n\\nif(length == n) {head = head.next; return head;}\\n\\nif(length == 1) return head;\\n\\nListNode l = head; for(int i = 1; i<length-n; i++) l = l.next;\\n\\nl.next = l.next.next;\\n        \\n       return  head;\\n           \\n    }\\n}"
                    },
                    {
                        "username": "Akashverma212",
                        "content": "My solution has passed and use to capture all nodes without using tail. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "deezyto",
                        "content": "In the test case [1], you need to return null."
                    },
                    {
                        "username": "ryanrenjith19",
                        "content": "Can anyone help me find the problem with this code?\\n\\nIts showing the following error :\\n\\nLine 39: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:48:36\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        ListNode* ptr1 = head;\\n        int count = 0;\\n\\n        if(ptr1->next == NULL)\\n            return NULL;\\n\\n        while(ptr1 != NULL)\\n        {\\n            count++;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1 = head;\\n\\n        count = count - n + 1;\\n\\n        while(count > 0)\\n        {\\n            count--;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1->next = (ptr1->next)->next;    //error line\\n\\n        return head;\\n    }\\n}; `"
                    },
                    {
                        "username": "havish05",
                        "content": "can somebody point out the mistake? It says 187 /208 testcases passed.\\n\\nllist=self.count(head)\\n        if head == None:\\n            return None\\n\\n        if head.next == None and n==1:\\n            return None\\n\\n        curr=head\\n        # print(llist)\\n        i=1\\n        while curr.next:\\n            if i==llist-n:\\n                curr.next=curr.next.next\\n                break\\n            else:\\n                curr=curr.next\\n                i+=1\\n        return head"
                    },
                    {
                        "username": "eugene09",
                        "content": "head = [1,2] and n = 2, more interestingly output is [2]\\n\\nWhy output is [2]? Can someone explain this problem, pls?\\n\\nI guess output should be [1];\\n"
                    }
                ]
            },
            {
                "id": 1727125,
                "content": [
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "CAPL1",
                        "content": "Can someone explain the usage of a dummy pointer. What edge cases would we run into if we were to just separate the fast/slow pointers from head."
                    },
                    {
                        "username": "tisha_2702",
                        "content": "Cannot read field \"next\" because \"<local3>\" is null\\n\\nI am getting this problem please suggest solution"
                    },
                    {
                        "username": "gyangav01",
                        "content": "Remove Nth Node From End of List Problem Solution in Leet code\\nHere is the solution:-[Click Here](https://gyangroupindia.blogspot.com/2022/12/remove-nth-node-from-end-of-list.html)"
                    },
                    {
                        "username": "Lucifer-dragneel00",
                        "content": "class Solution {\\n     \\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n   int length = 0; for(ListNode cur = head; cur != null; cur = cur.next) length++;\\n\\nif(length == n) {head = head.next; return head;}\\n\\nif(length == 1) return head;\\n\\nListNode l = head; for(int i = 1; i<length-n; i++) l = l.next;\\n\\nl.next = l.next.next;\\n        \\n       return  head;\\n           \\n    }\\n}"
                    },
                    {
                        "username": "Akashverma212",
                        "content": "My solution has passed and use to capture all nodes without using tail. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "deezyto",
                        "content": "In the test case [1], you need to return null."
                    },
                    {
                        "username": "ryanrenjith19",
                        "content": "Can anyone help me find the problem with this code?\\n\\nIts showing the following error :\\n\\nLine 39: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:48:36\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        ListNode* ptr1 = head;\\n        int count = 0;\\n\\n        if(ptr1->next == NULL)\\n            return NULL;\\n\\n        while(ptr1 != NULL)\\n        {\\n            count++;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1 = head;\\n\\n        count = count - n + 1;\\n\\n        while(count > 0)\\n        {\\n            count--;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1->next = (ptr1->next)->next;    //error line\\n\\n        return head;\\n    }\\n}; `"
                    },
                    {
                        "username": "havish05",
                        "content": "can somebody point out the mistake? It says 187 /208 testcases passed.\\n\\nllist=self.count(head)\\n        if head == None:\\n            return None\\n\\n        if head.next == None and n==1:\\n            return None\\n\\n        curr=head\\n        # print(llist)\\n        i=1\\n        while curr.next:\\n            if i==llist-n:\\n                curr.next=curr.next.next\\n                break\\n            else:\\n                curr=curr.next\\n                i+=1\\n        return head"
                    },
                    {
                        "username": "eugene09",
                        "content": "head = [1,2] and n = 2, more interestingly output is [2]\\n\\nWhy output is [2]? Can someone explain this problem, pls?\\n\\nI guess output should be [1];\\n"
                    }
                ]
            },
            {
                "id": 1725040,
                "content": [
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "CAPL1",
                        "content": "Can someone explain the usage of a dummy pointer. What edge cases would we run into if we were to just separate the fast/slow pointers from head."
                    },
                    {
                        "username": "tisha_2702",
                        "content": "Cannot read field \"next\" because \"<local3>\" is null\\n\\nI am getting this problem please suggest solution"
                    },
                    {
                        "username": "gyangav01",
                        "content": "Remove Nth Node From End of List Problem Solution in Leet code\\nHere is the solution:-[Click Here](https://gyangroupindia.blogspot.com/2022/12/remove-nth-node-from-end-of-list.html)"
                    },
                    {
                        "username": "Lucifer-dragneel00",
                        "content": "class Solution {\\n     \\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n   int length = 0; for(ListNode cur = head; cur != null; cur = cur.next) length++;\\n\\nif(length == n) {head = head.next; return head;}\\n\\nif(length == 1) return head;\\n\\nListNode l = head; for(int i = 1; i<length-n; i++) l = l.next;\\n\\nl.next = l.next.next;\\n        \\n       return  head;\\n           \\n    }\\n}"
                    },
                    {
                        "username": "Akashverma212",
                        "content": "My solution has passed and use to capture all nodes without using tail. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "deezyto",
                        "content": "In the test case [1], you need to return null."
                    },
                    {
                        "username": "ryanrenjith19",
                        "content": "Can anyone help me find the problem with this code?\\n\\nIts showing the following error :\\n\\nLine 39: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:48:36\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        ListNode* ptr1 = head;\\n        int count = 0;\\n\\n        if(ptr1->next == NULL)\\n            return NULL;\\n\\n        while(ptr1 != NULL)\\n        {\\n            count++;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1 = head;\\n\\n        count = count - n + 1;\\n\\n        while(count > 0)\\n        {\\n            count--;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1->next = (ptr1->next)->next;    //error line\\n\\n        return head;\\n    }\\n}; `"
                    },
                    {
                        "username": "havish05",
                        "content": "can somebody point out the mistake? It says 187 /208 testcases passed.\\n\\nllist=self.count(head)\\n        if head == None:\\n            return None\\n\\n        if head.next == None and n==1:\\n            return None\\n\\n        curr=head\\n        # print(llist)\\n        i=1\\n        while curr.next:\\n            if i==llist-n:\\n                curr.next=curr.next.next\\n                break\\n            else:\\n                curr=curr.next\\n                i+=1\\n        return head"
                    },
                    {
                        "username": "eugene09",
                        "content": "head = [1,2] and n = 2, more interestingly output is [2]\\n\\nWhy output is [2]? Can someone explain this problem, pls?\\n\\nI guess output should be [1];\\n"
                    }
                ]
            },
            {
                "id": 1716796,
                "content": [
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "CAPL1",
                        "content": "Can someone explain the usage of a dummy pointer. What edge cases would we run into if we were to just separate the fast/slow pointers from head."
                    },
                    {
                        "username": "tisha_2702",
                        "content": "Cannot read field \"next\" because \"<local3>\" is null\\n\\nI am getting this problem please suggest solution"
                    },
                    {
                        "username": "gyangav01",
                        "content": "Remove Nth Node From End of List Problem Solution in Leet code\\nHere is the solution:-[Click Here](https://gyangroupindia.blogspot.com/2022/12/remove-nth-node-from-end-of-list.html)"
                    },
                    {
                        "username": "Lucifer-dragneel00",
                        "content": "class Solution {\\n     \\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n   int length = 0; for(ListNode cur = head; cur != null; cur = cur.next) length++;\\n\\nif(length == n) {head = head.next; return head;}\\n\\nif(length == 1) return head;\\n\\nListNode l = head; for(int i = 1; i<length-n; i++) l = l.next;\\n\\nl.next = l.next.next;\\n        \\n       return  head;\\n           \\n    }\\n}"
                    },
                    {
                        "username": "Akashverma212",
                        "content": "My solution has passed and use to capture all nodes without using tail. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "deezyto",
                        "content": "In the test case [1], you need to return null."
                    },
                    {
                        "username": "ryanrenjith19",
                        "content": "Can anyone help me find the problem with this code?\\n\\nIts showing the following error :\\n\\nLine 39: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:48:36\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        ListNode* ptr1 = head;\\n        int count = 0;\\n\\n        if(ptr1->next == NULL)\\n            return NULL;\\n\\n        while(ptr1 != NULL)\\n        {\\n            count++;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1 = head;\\n\\n        count = count - n + 1;\\n\\n        while(count > 0)\\n        {\\n            count--;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1->next = (ptr1->next)->next;    //error line\\n\\n        return head;\\n    }\\n}; `"
                    },
                    {
                        "username": "havish05",
                        "content": "can somebody point out the mistake? It says 187 /208 testcases passed.\\n\\nllist=self.count(head)\\n        if head == None:\\n            return None\\n\\n        if head.next == None and n==1:\\n            return None\\n\\n        curr=head\\n        # print(llist)\\n        i=1\\n        while curr.next:\\n            if i==llist-n:\\n                curr.next=curr.next.next\\n                break\\n            else:\\n                curr=curr.next\\n                i+=1\\n        return head"
                    },
                    {
                        "username": "eugene09",
                        "content": "head = [1,2] and n = 2, more interestingly output is [2]\\n\\nWhy output is [2]? Can someone explain this problem, pls?\\n\\nI guess output should be [1];\\n"
                    }
                ]
            },
            {
                "id": 1716023,
                "content": [
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "CAPL1",
                        "content": "Can someone explain the usage of a dummy pointer. What edge cases would we run into if we were to just separate the fast/slow pointers from head."
                    },
                    {
                        "username": "tisha_2702",
                        "content": "Cannot read field \"next\" because \"<local3>\" is null\\n\\nI am getting this problem please suggest solution"
                    },
                    {
                        "username": "gyangav01",
                        "content": "Remove Nth Node From End of List Problem Solution in Leet code\\nHere is the solution:-[Click Here](https://gyangroupindia.blogspot.com/2022/12/remove-nth-node-from-end-of-list.html)"
                    },
                    {
                        "username": "Lucifer-dragneel00",
                        "content": "class Solution {\\n     \\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n   int length = 0; for(ListNode cur = head; cur != null; cur = cur.next) length++;\\n\\nif(length == n) {head = head.next; return head;}\\n\\nif(length == 1) return head;\\n\\nListNode l = head; for(int i = 1; i<length-n; i++) l = l.next;\\n\\nl.next = l.next.next;\\n        \\n       return  head;\\n           \\n    }\\n}"
                    },
                    {
                        "username": "Akashverma212",
                        "content": "My solution has passed and use to capture all nodes without using tail. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "deezyto",
                        "content": "In the test case [1], you need to return null."
                    },
                    {
                        "username": "ryanrenjith19",
                        "content": "Can anyone help me find the problem with this code?\\n\\nIts showing the following error :\\n\\nLine 39: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:48:36\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        ListNode* ptr1 = head;\\n        int count = 0;\\n\\n        if(ptr1->next == NULL)\\n            return NULL;\\n\\n        while(ptr1 != NULL)\\n        {\\n            count++;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1 = head;\\n\\n        count = count - n + 1;\\n\\n        while(count > 0)\\n        {\\n            count--;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1->next = (ptr1->next)->next;    //error line\\n\\n        return head;\\n    }\\n}; `"
                    },
                    {
                        "username": "havish05",
                        "content": "can somebody point out the mistake? It says 187 /208 testcases passed.\\n\\nllist=self.count(head)\\n        if head == None:\\n            return None\\n\\n        if head.next == None and n==1:\\n            return None\\n\\n        curr=head\\n        # print(llist)\\n        i=1\\n        while curr.next:\\n            if i==llist-n:\\n                curr.next=curr.next.next\\n                break\\n            else:\\n                curr=curr.next\\n                i+=1\\n        return head"
                    },
                    {
                        "username": "eugene09",
                        "content": "head = [1,2] and n = 2, more interestingly output is [2]\\n\\nWhy output is [2]? Can someone explain this problem, pls?\\n\\nI guess output should be [1];\\n"
                    }
                ]
            },
            {
                "id": 1714258,
                "content": [
                    {
                        "username": "pranathi1163",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int num=0;\\n        ListNode* ptr=head;\\n        //count number of elements in list\\n        while(ptr!=nullptr)\\n        {\\n            num=num+1;\\n            ptr=ptr->next;\\n        }\\n        //if one elt in list return null\\n        if(num==1)\\n        {\\n            head=nullptr;\\n            return head;\\n        }\\n        //if first elt shoud be deleted...return head->next\\n        if(num==n)\\n        {\\n            return head->next;\\n        }\\n        //else traverse till that elt and change the pointers\\n        int ct=1;\\n        ptr=head;\\n        while(ptr!=nullptr)\\n        {\\n            if(ct==num-n)\\n            {\\n                ptr->next=ptr->next->next;\\n                break;\\n            }\\n            ct=ct+1;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Just count the nodes from behind using Recursion and once you meet the nth node, delete it and adjust the pointers."
                    },
                    {
                        "username": "anikethbr73",
                        "content": "I recommend  to keep track of nodes traversed until you reach the node previous to target node. then change the link in order to delete the node."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705EASY O(n) Optimized || Amazon\\uD83D\\uDD25| Microsoft\\uD83D\\uDCA5 | Adobe\\uD83D\\uDE0E\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/2890792/easy-o-n-optimized-amazon-microsoft-adobe/?orderBy=most_votes"
                    },
                    {
                        "username": "briecheese7",
                        "content": "For Java, I get that returning dummy.next skips the dummy node of 0. But what exactly does dummy.next do? How does it return this modified linkedlist?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Test 22 goes against the instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. What gives with the bad documentation and or test?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "n and sz are equals in that case."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "is these two pieces of code not same ???\\n\\n1) ListNode *node,*temp=head;\\n    \\n\\n2)ListNode *node=head;\\nListNode *temp=head;\\n\\nBecause when i am using the 1) the compiler is showing error."
                    },
                    {
                        "username": "blah777",
                        "content": "I solve this one in golang. But It seems the test stub calls removeNthFromEnd twice?\\nDo anyone get the same problem?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "why this types question is in medium level it must be in easy level ye direct\\nquestion hai no need to think too much, rather than many easy level questions gets more time to solve and also tricky Leetcode must maintain the level of questions "
                    },
                    {
                        "username": "___Toppo___",
                        "content": " #include<stdio.h>\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    int l = 0;\\n    struct ListNode* curr = head;\\n    struct ListNode* temp = head;\\n    \\n    while(curr!=NULL){\\n        curr = curr->next;\\n        l++;\\n    }\\n    \\n    int index = l-n;\\n    \\n    int i = 0;\\n    while(i<index-1){\\n        temp = temp->next;\\n        i++;\\n    }\\n    \\n    temp->next = (temp->next)->next;\\n    return head;\\n}\\n\\nwhy is it showing runtime error for \"temp->next = (temp->next)->next;\" ???"
                    }
                ]
            },
            {
                "id": 1711080,
                "content": [
                    {
                        "username": "pranathi1163",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int num=0;\\n        ListNode* ptr=head;\\n        //count number of elements in list\\n        while(ptr!=nullptr)\\n        {\\n            num=num+1;\\n            ptr=ptr->next;\\n        }\\n        //if one elt in list return null\\n        if(num==1)\\n        {\\n            head=nullptr;\\n            return head;\\n        }\\n        //if first elt shoud be deleted...return head->next\\n        if(num==n)\\n        {\\n            return head->next;\\n        }\\n        //else traverse till that elt and change the pointers\\n        int ct=1;\\n        ptr=head;\\n        while(ptr!=nullptr)\\n        {\\n            if(ct==num-n)\\n            {\\n                ptr->next=ptr->next->next;\\n                break;\\n            }\\n            ct=ct+1;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Just count the nodes from behind using Recursion and once you meet the nth node, delete it and adjust the pointers."
                    },
                    {
                        "username": "anikethbr73",
                        "content": "I recommend  to keep track of nodes traversed until you reach the node previous to target node. then change the link in order to delete the node."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705EASY O(n) Optimized || Amazon\\uD83D\\uDD25| Microsoft\\uD83D\\uDCA5 | Adobe\\uD83D\\uDE0E\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/2890792/easy-o-n-optimized-amazon-microsoft-adobe/?orderBy=most_votes"
                    },
                    {
                        "username": "briecheese7",
                        "content": "For Java, I get that returning dummy.next skips the dummy node of 0. But what exactly does dummy.next do? How does it return this modified linkedlist?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Test 22 goes against the instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. What gives with the bad documentation and or test?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "n and sz are equals in that case."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "is these two pieces of code not same ???\\n\\n1) ListNode *node,*temp=head;\\n    \\n\\n2)ListNode *node=head;\\nListNode *temp=head;\\n\\nBecause when i am using the 1) the compiler is showing error."
                    },
                    {
                        "username": "blah777",
                        "content": "I solve this one in golang. But It seems the test stub calls removeNthFromEnd twice?\\nDo anyone get the same problem?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "why this types question is in medium level it must be in easy level ye direct\\nquestion hai no need to think too much, rather than many easy level questions gets more time to solve and also tricky Leetcode must maintain the level of questions "
                    },
                    {
                        "username": "___Toppo___",
                        "content": " #include<stdio.h>\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    int l = 0;\\n    struct ListNode* curr = head;\\n    struct ListNode* temp = head;\\n    \\n    while(curr!=NULL){\\n        curr = curr->next;\\n        l++;\\n    }\\n    \\n    int index = l-n;\\n    \\n    int i = 0;\\n    while(i<index-1){\\n        temp = temp->next;\\n        i++;\\n    }\\n    \\n    temp->next = (temp->next)->next;\\n    return head;\\n}\\n\\nwhy is it showing runtime error for \"temp->next = (temp->next)->next;\" ???"
                    }
                ]
            },
            {
                "id": 1710159,
                "content": [
                    {
                        "username": "pranathi1163",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int num=0;\\n        ListNode* ptr=head;\\n        //count number of elements in list\\n        while(ptr!=nullptr)\\n        {\\n            num=num+1;\\n            ptr=ptr->next;\\n        }\\n        //if one elt in list return null\\n        if(num==1)\\n        {\\n            head=nullptr;\\n            return head;\\n        }\\n        //if first elt shoud be deleted...return head->next\\n        if(num==n)\\n        {\\n            return head->next;\\n        }\\n        //else traverse till that elt and change the pointers\\n        int ct=1;\\n        ptr=head;\\n        while(ptr!=nullptr)\\n        {\\n            if(ct==num-n)\\n            {\\n                ptr->next=ptr->next->next;\\n                break;\\n            }\\n            ct=ct+1;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Just count the nodes from behind using Recursion and once you meet the nth node, delete it and adjust the pointers."
                    },
                    {
                        "username": "anikethbr73",
                        "content": "I recommend  to keep track of nodes traversed until you reach the node previous to target node. then change the link in order to delete the node."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705EASY O(n) Optimized || Amazon\\uD83D\\uDD25| Microsoft\\uD83D\\uDCA5 | Adobe\\uD83D\\uDE0E\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/2890792/easy-o-n-optimized-amazon-microsoft-adobe/?orderBy=most_votes"
                    },
                    {
                        "username": "briecheese7",
                        "content": "For Java, I get that returning dummy.next skips the dummy node of 0. But what exactly does dummy.next do? How does it return this modified linkedlist?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Test 22 goes against the instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. What gives with the bad documentation and or test?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "n and sz are equals in that case."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "is these two pieces of code not same ???\\n\\n1) ListNode *node,*temp=head;\\n    \\n\\n2)ListNode *node=head;\\nListNode *temp=head;\\n\\nBecause when i am using the 1) the compiler is showing error."
                    },
                    {
                        "username": "blah777",
                        "content": "I solve this one in golang. But It seems the test stub calls removeNthFromEnd twice?\\nDo anyone get the same problem?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "why this types question is in medium level it must be in easy level ye direct\\nquestion hai no need to think too much, rather than many easy level questions gets more time to solve and also tricky Leetcode must maintain the level of questions "
                    },
                    {
                        "username": "___Toppo___",
                        "content": " #include<stdio.h>\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    int l = 0;\\n    struct ListNode* curr = head;\\n    struct ListNode* temp = head;\\n    \\n    while(curr!=NULL){\\n        curr = curr->next;\\n        l++;\\n    }\\n    \\n    int index = l-n;\\n    \\n    int i = 0;\\n    while(i<index-1){\\n        temp = temp->next;\\n        i++;\\n    }\\n    \\n    temp->next = (temp->next)->next;\\n    return head;\\n}\\n\\nwhy is it showing runtime error for \"temp->next = (temp->next)->next;\" ???"
                    }
                ]
            },
            {
                "id": 1709843,
                "content": [
                    {
                        "username": "pranathi1163",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int num=0;\\n        ListNode* ptr=head;\\n        //count number of elements in list\\n        while(ptr!=nullptr)\\n        {\\n            num=num+1;\\n            ptr=ptr->next;\\n        }\\n        //if one elt in list return null\\n        if(num==1)\\n        {\\n            head=nullptr;\\n            return head;\\n        }\\n        //if first elt shoud be deleted...return head->next\\n        if(num==n)\\n        {\\n            return head->next;\\n        }\\n        //else traverse till that elt and change the pointers\\n        int ct=1;\\n        ptr=head;\\n        while(ptr!=nullptr)\\n        {\\n            if(ct==num-n)\\n            {\\n                ptr->next=ptr->next->next;\\n                break;\\n            }\\n            ct=ct+1;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Just count the nodes from behind using Recursion and once you meet the nth node, delete it and adjust the pointers."
                    },
                    {
                        "username": "anikethbr73",
                        "content": "I recommend  to keep track of nodes traversed until you reach the node previous to target node. then change the link in order to delete the node."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705EASY O(n) Optimized || Amazon\\uD83D\\uDD25| Microsoft\\uD83D\\uDCA5 | Adobe\\uD83D\\uDE0E\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/2890792/easy-o-n-optimized-amazon-microsoft-adobe/?orderBy=most_votes"
                    },
                    {
                        "username": "briecheese7",
                        "content": "For Java, I get that returning dummy.next skips the dummy node of 0. But what exactly does dummy.next do? How does it return this modified linkedlist?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Test 22 goes against the instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. What gives with the bad documentation and or test?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "n and sz are equals in that case."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "is these two pieces of code not same ???\\n\\n1) ListNode *node,*temp=head;\\n    \\n\\n2)ListNode *node=head;\\nListNode *temp=head;\\n\\nBecause when i am using the 1) the compiler is showing error."
                    },
                    {
                        "username": "blah777",
                        "content": "I solve this one in golang. But It seems the test stub calls removeNthFromEnd twice?\\nDo anyone get the same problem?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "why this types question is in medium level it must be in easy level ye direct\\nquestion hai no need to think too much, rather than many easy level questions gets more time to solve and also tricky Leetcode must maintain the level of questions "
                    },
                    {
                        "username": "___Toppo___",
                        "content": " #include<stdio.h>\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    int l = 0;\\n    struct ListNode* curr = head;\\n    struct ListNode* temp = head;\\n    \\n    while(curr!=NULL){\\n        curr = curr->next;\\n        l++;\\n    }\\n    \\n    int index = l-n;\\n    \\n    int i = 0;\\n    while(i<index-1){\\n        temp = temp->next;\\n        i++;\\n    }\\n    \\n    temp->next = (temp->next)->next;\\n    return head;\\n}\\n\\nwhy is it showing runtime error for \"temp->next = (temp->next)->next;\" ???"
                    }
                ]
            },
            {
                "id": 1709177,
                "content": [
                    {
                        "username": "pranathi1163",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int num=0;\\n        ListNode* ptr=head;\\n        //count number of elements in list\\n        while(ptr!=nullptr)\\n        {\\n            num=num+1;\\n            ptr=ptr->next;\\n        }\\n        //if one elt in list return null\\n        if(num==1)\\n        {\\n            head=nullptr;\\n            return head;\\n        }\\n        //if first elt shoud be deleted...return head->next\\n        if(num==n)\\n        {\\n            return head->next;\\n        }\\n        //else traverse till that elt and change the pointers\\n        int ct=1;\\n        ptr=head;\\n        while(ptr!=nullptr)\\n        {\\n            if(ct==num-n)\\n            {\\n                ptr->next=ptr->next->next;\\n                break;\\n            }\\n            ct=ct+1;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Just count the nodes from behind using Recursion and once you meet the nth node, delete it and adjust the pointers."
                    },
                    {
                        "username": "anikethbr73",
                        "content": "I recommend  to keep track of nodes traversed until you reach the node previous to target node. then change the link in order to delete the node."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705EASY O(n) Optimized || Amazon\\uD83D\\uDD25| Microsoft\\uD83D\\uDCA5 | Adobe\\uD83D\\uDE0E\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/2890792/easy-o-n-optimized-amazon-microsoft-adobe/?orderBy=most_votes"
                    },
                    {
                        "username": "briecheese7",
                        "content": "For Java, I get that returning dummy.next skips the dummy node of 0. But what exactly does dummy.next do? How does it return this modified linkedlist?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Test 22 goes against the instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. What gives with the bad documentation and or test?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "n and sz are equals in that case."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "is these two pieces of code not same ???\\n\\n1) ListNode *node,*temp=head;\\n    \\n\\n2)ListNode *node=head;\\nListNode *temp=head;\\n\\nBecause when i am using the 1) the compiler is showing error."
                    },
                    {
                        "username": "blah777",
                        "content": "I solve this one in golang. But It seems the test stub calls removeNthFromEnd twice?\\nDo anyone get the same problem?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "why this types question is in medium level it must be in easy level ye direct\\nquestion hai no need to think too much, rather than many easy level questions gets more time to solve and also tricky Leetcode must maintain the level of questions "
                    },
                    {
                        "username": "___Toppo___",
                        "content": " #include<stdio.h>\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    int l = 0;\\n    struct ListNode* curr = head;\\n    struct ListNode* temp = head;\\n    \\n    while(curr!=NULL){\\n        curr = curr->next;\\n        l++;\\n    }\\n    \\n    int index = l-n;\\n    \\n    int i = 0;\\n    while(i<index-1){\\n        temp = temp->next;\\n        i++;\\n    }\\n    \\n    temp->next = (temp->next)->next;\\n    return head;\\n}\\n\\nwhy is it showing runtime error for \"temp->next = (temp->next)->next;\" ???"
                    }
                ]
            },
            {
                "id": 1709090,
                "content": [
                    {
                        "username": "pranathi1163",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int num=0;\\n        ListNode* ptr=head;\\n        //count number of elements in list\\n        while(ptr!=nullptr)\\n        {\\n            num=num+1;\\n            ptr=ptr->next;\\n        }\\n        //if one elt in list return null\\n        if(num==1)\\n        {\\n            head=nullptr;\\n            return head;\\n        }\\n        //if first elt shoud be deleted...return head->next\\n        if(num==n)\\n        {\\n            return head->next;\\n        }\\n        //else traverse till that elt and change the pointers\\n        int ct=1;\\n        ptr=head;\\n        while(ptr!=nullptr)\\n        {\\n            if(ct==num-n)\\n            {\\n                ptr->next=ptr->next->next;\\n                break;\\n            }\\n            ct=ct+1;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Just count the nodes from behind using Recursion and once you meet the nth node, delete it and adjust the pointers."
                    },
                    {
                        "username": "anikethbr73",
                        "content": "I recommend  to keep track of nodes traversed until you reach the node previous to target node. then change the link in order to delete the node."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705EASY O(n) Optimized || Amazon\\uD83D\\uDD25| Microsoft\\uD83D\\uDCA5 | Adobe\\uD83D\\uDE0E\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/2890792/easy-o-n-optimized-amazon-microsoft-adobe/?orderBy=most_votes"
                    },
                    {
                        "username": "briecheese7",
                        "content": "For Java, I get that returning dummy.next skips the dummy node of 0. But what exactly does dummy.next do? How does it return this modified linkedlist?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Test 22 goes against the instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. What gives with the bad documentation and or test?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "n and sz are equals in that case."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "is these two pieces of code not same ???\\n\\n1) ListNode *node,*temp=head;\\n    \\n\\n2)ListNode *node=head;\\nListNode *temp=head;\\n\\nBecause when i am using the 1) the compiler is showing error."
                    },
                    {
                        "username": "blah777",
                        "content": "I solve this one in golang. But It seems the test stub calls removeNthFromEnd twice?\\nDo anyone get the same problem?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "why this types question is in medium level it must be in easy level ye direct\\nquestion hai no need to think too much, rather than many easy level questions gets more time to solve and also tricky Leetcode must maintain the level of questions "
                    },
                    {
                        "username": "___Toppo___",
                        "content": " #include<stdio.h>\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    int l = 0;\\n    struct ListNode* curr = head;\\n    struct ListNode* temp = head;\\n    \\n    while(curr!=NULL){\\n        curr = curr->next;\\n        l++;\\n    }\\n    \\n    int index = l-n;\\n    \\n    int i = 0;\\n    while(i<index-1){\\n        temp = temp->next;\\n        i++;\\n    }\\n    \\n    temp->next = (temp->next)->next;\\n    return head;\\n}\\n\\nwhy is it showing runtime error for \"temp->next = (temp->next)->next;\" ???"
                    }
                ]
            },
            {
                "id": 1707734,
                "content": [
                    {
                        "username": "pranathi1163",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int num=0;\\n        ListNode* ptr=head;\\n        //count number of elements in list\\n        while(ptr!=nullptr)\\n        {\\n            num=num+1;\\n            ptr=ptr->next;\\n        }\\n        //if one elt in list return null\\n        if(num==1)\\n        {\\n            head=nullptr;\\n            return head;\\n        }\\n        //if first elt shoud be deleted...return head->next\\n        if(num==n)\\n        {\\n            return head->next;\\n        }\\n        //else traverse till that elt and change the pointers\\n        int ct=1;\\n        ptr=head;\\n        while(ptr!=nullptr)\\n        {\\n            if(ct==num-n)\\n            {\\n                ptr->next=ptr->next->next;\\n                break;\\n            }\\n            ct=ct+1;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Just count the nodes from behind using Recursion and once you meet the nth node, delete it and adjust the pointers."
                    },
                    {
                        "username": "anikethbr73",
                        "content": "I recommend  to keep track of nodes traversed until you reach the node previous to target node. then change the link in order to delete the node."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705EASY O(n) Optimized || Amazon\\uD83D\\uDD25| Microsoft\\uD83D\\uDCA5 | Adobe\\uD83D\\uDE0E\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/2890792/easy-o-n-optimized-amazon-microsoft-adobe/?orderBy=most_votes"
                    },
                    {
                        "username": "briecheese7",
                        "content": "For Java, I get that returning dummy.next skips the dummy node of 0. But what exactly does dummy.next do? How does it return this modified linkedlist?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Test 22 goes against the instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. What gives with the bad documentation and or test?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "n and sz are equals in that case."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "is these two pieces of code not same ???\\n\\n1) ListNode *node,*temp=head;\\n    \\n\\n2)ListNode *node=head;\\nListNode *temp=head;\\n\\nBecause when i am using the 1) the compiler is showing error."
                    },
                    {
                        "username": "blah777",
                        "content": "I solve this one in golang. But It seems the test stub calls removeNthFromEnd twice?\\nDo anyone get the same problem?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "why this types question is in medium level it must be in easy level ye direct\\nquestion hai no need to think too much, rather than many easy level questions gets more time to solve and also tricky Leetcode must maintain the level of questions "
                    },
                    {
                        "username": "___Toppo___",
                        "content": " #include<stdio.h>\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    int l = 0;\\n    struct ListNode* curr = head;\\n    struct ListNode* temp = head;\\n    \\n    while(curr!=NULL){\\n        curr = curr->next;\\n        l++;\\n    }\\n    \\n    int index = l-n;\\n    \\n    int i = 0;\\n    while(i<index-1){\\n        temp = temp->next;\\n        i++;\\n    }\\n    \\n    temp->next = (temp->next)->next;\\n    return head;\\n}\\n\\nwhy is it showing runtime error for \"temp->next = (temp->next)->next;\" ???"
                    }
                ]
            },
            {
                "id": 1706368,
                "content": [
                    {
                        "username": "pranathi1163",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int num=0;\\n        ListNode* ptr=head;\\n        //count number of elements in list\\n        while(ptr!=nullptr)\\n        {\\n            num=num+1;\\n            ptr=ptr->next;\\n        }\\n        //if one elt in list return null\\n        if(num==1)\\n        {\\n            head=nullptr;\\n            return head;\\n        }\\n        //if first elt shoud be deleted...return head->next\\n        if(num==n)\\n        {\\n            return head->next;\\n        }\\n        //else traverse till that elt and change the pointers\\n        int ct=1;\\n        ptr=head;\\n        while(ptr!=nullptr)\\n        {\\n            if(ct==num-n)\\n            {\\n                ptr->next=ptr->next->next;\\n                break;\\n            }\\n            ct=ct+1;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Just count the nodes from behind using Recursion and once you meet the nth node, delete it and adjust the pointers."
                    },
                    {
                        "username": "anikethbr73",
                        "content": "I recommend  to keep track of nodes traversed until you reach the node previous to target node. then change the link in order to delete the node."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705EASY O(n) Optimized || Amazon\\uD83D\\uDD25| Microsoft\\uD83D\\uDCA5 | Adobe\\uD83D\\uDE0E\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/2890792/easy-o-n-optimized-amazon-microsoft-adobe/?orderBy=most_votes"
                    },
                    {
                        "username": "briecheese7",
                        "content": "For Java, I get that returning dummy.next skips the dummy node of 0. But what exactly does dummy.next do? How does it return this modified linkedlist?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Test 22 goes against the instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. What gives with the bad documentation and or test?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "n and sz are equals in that case."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "is these two pieces of code not same ???\\n\\n1) ListNode *node,*temp=head;\\n    \\n\\n2)ListNode *node=head;\\nListNode *temp=head;\\n\\nBecause when i am using the 1) the compiler is showing error."
                    },
                    {
                        "username": "blah777",
                        "content": "I solve this one in golang. But It seems the test stub calls removeNthFromEnd twice?\\nDo anyone get the same problem?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "why this types question is in medium level it must be in easy level ye direct\\nquestion hai no need to think too much, rather than many easy level questions gets more time to solve and also tricky Leetcode must maintain the level of questions "
                    },
                    {
                        "username": "___Toppo___",
                        "content": " #include<stdio.h>\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    int l = 0;\\n    struct ListNode* curr = head;\\n    struct ListNode* temp = head;\\n    \\n    while(curr!=NULL){\\n        curr = curr->next;\\n        l++;\\n    }\\n    \\n    int index = l-n;\\n    \\n    int i = 0;\\n    while(i<index-1){\\n        temp = temp->next;\\n        i++;\\n    }\\n    \\n    temp->next = (temp->next)->next;\\n    return head;\\n}\\n\\nwhy is it showing runtime error for \"temp->next = (temp->next)->next;\" ???"
                    }
                ]
            },
            {
                "id": 1704391,
                "content": [
                    {
                        "username": "pranathi1163",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int num=0;\\n        ListNode* ptr=head;\\n        //count number of elements in list\\n        while(ptr!=nullptr)\\n        {\\n            num=num+1;\\n            ptr=ptr->next;\\n        }\\n        //if one elt in list return null\\n        if(num==1)\\n        {\\n            head=nullptr;\\n            return head;\\n        }\\n        //if first elt shoud be deleted...return head->next\\n        if(num==n)\\n        {\\n            return head->next;\\n        }\\n        //else traverse till that elt and change the pointers\\n        int ct=1;\\n        ptr=head;\\n        while(ptr!=nullptr)\\n        {\\n            if(ct==num-n)\\n            {\\n                ptr->next=ptr->next->next;\\n                break;\\n            }\\n            ct=ct+1;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Just count the nodes from behind using Recursion and once you meet the nth node, delete it and adjust the pointers."
                    },
                    {
                        "username": "anikethbr73",
                        "content": "I recommend  to keep track of nodes traversed until you reach the node previous to target node. then change the link in order to delete the node."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705EASY O(n) Optimized || Amazon\\uD83D\\uDD25| Microsoft\\uD83D\\uDCA5 | Adobe\\uD83D\\uDE0E\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/2890792/easy-o-n-optimized-amazon-microsoft-adobe/?orderBy=most_votes"
                    },
                    {
                        "username": "briecheese7",
                        "content": "For Java, I get that returning dummy.next skips the dummy node of 0. But what exactly does dummy.next do? How does it return this modified linkedlist?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Test 22 goes against the instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. What gives with the bad documentation and or test?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "n and sz are equals in that case."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "is these two pieces of code not same ???\\n\\n1) ListNode *node,*temp=head;\\n    \\n\\n2)ListNode *node=head;\\nListNode *temp=head;\\n\\nBecause when i am using the 1) the compiler is showing error."
                    },
                    {
                        "username": "blah777",
                        "content": "I solve this one in golang. But It seems the test stub calls removeNthFromEnd twice?\\nDo anyone get the same problem?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "why this types question is in medium level it must be in easy level ye direct\\nquestion hai no need to think too much, rather than many easy level questions gets more time to solve and also tricky Leetcode must maintain the level of questions "
                    },
                    {
                        "username": "___Toppo___",
                        "content": " #include<stdio.h>\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    int l = 0;\\n    struct ListNode* curr = head;\\n    struct ListNode* temp = head;\\n    \\n    while(curr!=NULL){\\n        curr = curr->next;\\n        l++;\\n    }\\n    \\n    int index = l-n;\\n    \\n    int i = 0;\\n    while(i<index-1){\\n        temp = temp->next;\\n        i++;\\n    }\\n    \\n    temp->next = (temp->next)->next;\\n    return head;\\n}\\n\\nwhy is it showing runtime error for \"temp->next = (temp->next)->next;\" ???"
                    }
                ]
            },
            {
                "id": 1703301,
                "content": [
                    {
                        "username": "pranathi1163",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int num=0;\\n        ListNode* ptr=head;\\n        //count number of elements in list\\n        while(ptr!=nullptr)\\n        {\\n            num=num+1;\\n            ptr=ptr->next;\\n        }\\n        //if one elt in list return null\\n        if(num==1)\\n        {\\n            head=nullptr;\\n            return head;\\n        }\\n        //if first elt shoud be deleted...return head->next\\n        if(num==n)\\n        {\\n            return head->next;\\n        }\\n        //else traverse till that elt and change the pointers\\n        int ct=1;\\n        ptr=head;\\n        while(ptr!=nullptr)\\n        {\\n            if(ct==num-n)\\n            {\\n                ptr->next=ptr->next->next;\\n                break;\\n            }\\n            ct=ct+1;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Just count the nodes from behind using Recursion and once you meet the nth node, delete it and adjust the pointers."
                    },
                    {
                        "username": "anikethbr73",
                        "content": "I recommend  to keep track of nodes traversed until you reach the node previous to target node. then change the link in order to delete the node."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705EASY O(n) Optimized || Amazon\\uD83D\\uDD25| Microsoft\\uD83D\\uDCA5 | Adobe\\uD83D\\uDE0E\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/2890792/easy-o-n-optimized-amazon-microsoft-adobe/?orderBy=most_votes"
                    },
                    {
                        "username": "briecheese7",
                        "content": "For Java, I get that returning dummy.next skips the dummy node of 0. But what exactly does dummy.next do? How does it return this modified linkedlist?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Test 22 goes against the instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. What gives with the bad documentation and or test?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "n and sz are equals in that case."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "is these two pieces of code not same ???\\n\\n1) ListNode *node,*temp=head;\\n    \\n\\n2)ListNode *node=head;\\nListNode *temp=head;\\n\\nBecause when i am using the 1) the compiler is showing error."
                    },
                    {
                        "username": "blah777",
                        "content": "I solve this one in golang. But It seems the test stub calls removeNthFromEnd twice?\\nDo anyone get the same problem?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "why this types question is in medium level it must be in easy level ye direct\\nquestion hai no need to think too much, rather than many easy level questions gets more time to solve and also tricky Leetcode must maintain the level of questions "
                    },
                    {
                        "username": "___Toppo___",
                        "content": " #include<stdio.h>\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    int l = 0;\\n    struct ListNode* curr = head;\\n    struct ListNode* temp = head;\\n    \\n    while(curr!=NULL){\\n        curr = curr->next;\\n        l++;\\n    }\\n    \\n    int index = l-n;\\n    \\n    int i = 0;\\n    while(i<index-1){\\n        temp = temp->next;\\n        i++;\\n    }\\n    \\n    temp->next = (temp->next)->next;\\n    return head;\\n}\\n\\nwhy is it showing runtime error for \"temp->next = (temp->next)->next;\" ???"
                    }
                ]
            },
            {
                "id": 1677246,
                "content": [
                    {
                        "username": "adityamishra19_",
                        "content": "//c++\\nListNode*reverselist(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode*recursedhead = reverselist(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return recursedhead;\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode*ptr=reverselist(head);\\n        if(ptr==NULL || ptr->next==NULL) return NULL;\\n        if(n==1){\\n            ptr=ptr->next;\\n            return reverselist(ptr);\\n        }\\n        ListNode*ref=ptr;\\n        if(ref==NULL|| ref->next==NULL) return ref;\\n        int i=1;\\n        while(i!=n-1){\\n            ref=ref->next;\\n            i++;\\n        }\\n        ListNode*q=ref->next;\\n        ref->next=ref->next->next;\\n        delete(q);\\n        ListNode*adi=reverselist(ptr);\\n        return adi;\\n    }"
                    },
                    {
                        "username": "rampanda",
                        "content": "# Python solution simple and easy. Explained properly\n\n\nAproach1: We can traverse through the whole linked list once and get the lenght of the list, then subtract the\n                  nth node from end to ge that nth position from the start, again traverse untill you reach n-1th node \n\nApproach2: Here instead of traversing twice we will try to traverse only once. \n                   Create two node pointers i, j. Start j from (i+n)th node, so that when we reach end for jth node that \n                   time we will have ith node at nth from behind\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        tempi, tempj = head, head\n        i = 0 \n\n        # this condition will handle when we have only one element in the linked list\n        if not tempi.next:\n            return None\n\n        while i<n:\n            tempj = tempj.next\n            i+=1\n\n        # this condition handles when we need to remove head of the linked list\n        # only while will cause error, because tempj will be None,  So None.next will give error\n        if not tempj:\n            head = tempi.next\n        else:\n            while tempj.next: \n                tempi = tempi.next\n                tempj = tempj.next\n        tempi.next = tempi.next.next\n\n        return head \n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "This question is silly in Python and super easy in C++, where you can pass by reference."
                    },
                    {
                        "username": "jmat",
                        "content": "Why is this code not working?\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        curr = head\\n        second_pointer = head\\n        count = 1\\n        while curr.next:\\n            curr=curr.next\\n            if count > n:\\n                second_pointer = second_pointer.next\\n                print(curr.val, second_pointer.val)\\n            count +=1\\n\\n        second_pointer.next = second_pointer.next.next\\n\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        head.pop(-n)\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, list, n):\\n        list.pop(-n)\\n        return list\\n\\n\\nl = Solution()\\nprint(l.removeNthFromEnd([1,2,3,4,5], 2))\\nprint(l.removeNthFromEnd([1], 1))\\nprint(l.removeNthFromEnd([1,2], 1))\\n"
                    },
                    {
                        "username": "PriyankaTaneja",
                        "content": "java.lang.NullPointerException: Cannot read field \"next\" because \"<local6>.next\" is null\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        int count = 0;\\n        ListNode temp = head;\\n            while(temp != null) {\\n                temp = temp.next;\\n                count++;\\n            }\\n        int pos = count-n+1;\\n    \\n        ListNode slow = head;\\n        for(int i=1;i<pos-1;i++) {  \\n            slow = slow.next;     \\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n\\nWhat\\'s wrong with this code, Can anyone suggest."
                    },
                    {
                        "username": "heyharshit",
                        "content": "dekho bakchodi toh karo mat"
                    }
                ]
            },
            {
                "id": 1673854,
                "content": [
                    {
                        "username": "adityamishra19_",
                        "content": "//c++\\nListNode*reverselist(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode*recursedhead = reverselist(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return recursedhead;\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode*ptr=reverselist(head);\\n        if(ptr==NULL || ptr->next==NULL) return NULL;\\n        if(n==1){\\n            ptr=ptr->next;\\n            return reverselist(ptr);\\n        }\\n        ListNode*ref=ptr;\\n        if(ref==NULL|| ref->next==NULL) return ref;\\n        int i=1;\\n        while(i!=n-1){\\n            ref=ref->next;\\n            i++;\\n        }\\n        ListNode*q=ref->next;\\n        ref->next=ref->next->next;\\n        delete(q);\\n        ListNode*adi=reverselist(ptr);\\n        return adi;\\n    }"
                    },
                    {
                        "username": "rampanda",
                        "content": "# Python solution simple and easy. Explained properly\n\n\nAproach1: We can traverse through the whole linked list once and get the lenght of the list, then subtract the\n                  nth node from end to ge that nth position from the start, again traverse untill you reach n-1th node \n\nApproach2: Here instead of traversing twice we will try to traverse only once. \n                   Create two node pointers i, j. Start j from (i+n)th node, so that when we reach end for jth node that \n                   time we will have ith node at nth from behind\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        tempi, tempj = head, head\n        i = 0 \n\n        # this condition will handle when we have only one element in the linked list\n        if not tempi.next:\n            return None\n\n        while i<n:\n            tempj = tempj.next\n            i+=1\n\n        # this condition handles when we need to remove head of the linked list\n        # only while will cause error, because tempj will be None,  So None.next will give error\n        if not tempj:\n            head = tempi.next\n        else:\n            while tempj.next: \n                tempi = tempi.next\n                tempj = tempj.next\n        tempi.next = tempi.next.next\n\n        return head \n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "This question is silly in Python and super easy in C++, where you can pass by reference."
                    },
                    {
                        "username": "jmat",
                        "content": "Why is this code not working?\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        curr = head\\n        second_pointer = head\\n        count = 1\\n        while curr.next:\\n            curr=curr.next\\n            if count > n:\\n                second_pointer = second_pointer.next\\n                print(curr.val, second_pointer.val)\\n            count +=1\\n\\n        second_pointer.next = second_pointer.next.next\\n\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        head.pop(-n)\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, list, n):\\n        list.pop(-n)\\n        return list\\n\\n\\nl = Solution()\\nprint(l.removeNthFromEnd([1,2,3,4,5], 2))\\nprint(l.removeNthFromEnd([1], 1))\\nprint(l.removeNthFromEnd([1,2], 1))\\n"
                    },
                    {
                        "username": "PriyankaTaneja",
                        "content": "java.lang.NullPointerException: Cannot read field \"next\" because \"<local6>.next\" is null\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        int count = 0;\\n        ListNode temp = head;\\n            while(temp != null) {\\n                temp = temp.next;\\n                count++;\\n            }\\n        int pos = count-n+1;\\n    \\n        ListNode slow = head;\\n        for(int i=1;i<pos-1;i++) {  \\n            slow = slow.next;     \\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n\\nWhat\\'s wrong with this code, Can anyone suggest."
                    },
                    {
                        "username": "heyharshit",
                        "content": "dekho bakchodi toh karo mat"
                    }
                ]
            },
            {
                "id": 1671271,
                "content": [
                    {
                        "username": "adityamishra19_",
                        "content": "//c++\\nListNode*reverselist(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode*recursedhead = reverselist(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return recursedhead;\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode*ptr=reverselist(head);\\n        if(ptr==NULL || ptr->next==NULL) return NULL;\\n        if(n==1){\\n            ptr=ptr->next;\\n            return reverselist(ptr);\\n        }\\n        ListNode*ref=ptr;\\n        if(ref==NULL|| ref->next==NULL) return ref;\\n        int i=1;\\n        while(i!=n-1){\\n            ref=ref->next;\\n            i++;\\n        }\\n        ListNode*q=ref->next;\\n        ref->next=ref->next->next;\\n        delete(q);\\n        ListNode*adi=reverselist(ptr);\\n        return adi;\\n    }"
                    },
                    {
                        "username": "rampanda",
                        "content": "# Python solution simple and easy. Explained properly\n\n\nAproach1: We can traverse through the whole linked list once and get the lenght of the list, then subtract the\n                  nth node from end to ge that nth position from the start, again traverse untill you reach n-1th node \n\nApproach2: Here instead of traversing twice we will try to traverse only once. \n                   Create two node pointers i, j. Start j from (i+n)th node, so that when we reach end for jth node that \n                   time we will have ith node at nth from behind\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        tempi, tempj = head, head\n        i = 0 \n\n        # this condition will handle when we have only one element in the linked list\n        if not tempi.next:\n            return None\n\n        while i<n:\n            tempj = tempj.next\n            i+=1\n\n        # this condition handles when we need to remove head of the linked list\n        # only while will cause error, because tempj will be None,  So None.next will give error\n        if not tempj:\n            head = tempi.next\n        else:\n            while tempj.next: \n                tempi = tempi.next\n                tempj = tempj.next\n        tempi.next = tempi.next.next\n\n        return head \n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "This question is silly in Python and super easy in C++, where you can pass by reference."
                    },
                    {
                        "username": "jmat",
                        "content": "Why is this code not working?\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        curr = head\\n        second_pointer = head\\n        count = 1\\n        while curr.next:\\n            curr=curr.next\\n            if count > n:\\n                second_pointer = second_pointer.next\\n                print(curr.val, second_pointer.val)\\n            count +=1\\n\\n        second_pointer.next = second_pointer.next.next\\n\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        head.pop(-n)\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, list, n):\\n        list.pop(-n)\\n        return list\\n\\n\\nl = Solution()\\nprint(l.removeNthFromEnd([1,2,3,4,5], 2))\\nprint(l.removeNthFromEnd([1], 1))\\nprint(l.removeNthFromEnd([1,2], 1))\\n"
                    },
                    {
                        "username": "PriyankaTaneja",
                        "content": "java.lang.NullPointerException: Cannot read field \"next\" because \"<local6>.next\" is null\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        int count = 0;\\n        ListNode temp = head;\\n            while(temp != null) {\\n                temp = temp.next;\\n                count++;\\n            }\\n        int pos = count-n+1;\\n    \\n        ListNode slow = head;\\n        for(int i=1;i<pos-1;i++) {  \\n            slow = slow.next;     \\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n\\nWhat\\'s wrong with this code, Can anyone suggest."
                    },
                    {
                        "username": "heyharshit",
                        "content": "dekho bakchodi toh karo mat"
                    }
                ]
            },
            {
                "id": 1671268,
                "content": [
                    {
                        "username": "adityamishra19_",
                        "content": "//c++\\nListNode*reverselist(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode*recursedhead = reverselist(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return recursedhead;\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode*ptr=reverselist(head);\\n        if(ptr==NULL || ptr->next==NULL) return NULL;\\n        if(n==1){\\n            ptr=ptr->next;\\n            return reverselist(ptr);\\n        }\\n        ListNode*ref=ptr;\\n        if(ref==NULL|| ref->next==NULL) return ref;\\n        int i=1;\\n        while(i!=n-1){\\n            ref=ref->next;\\n            i++;\\n        }\\n        ListNode*q=ref->next;\\n        ref->next=ref->next->next;\\n        delete(q);\\n        ListNode*adi=reverselist(ptr);\\n        return adi;\\n    }"
                    },
                    {
                        "username": "rampanda",
                        "content": "# Python solution simple and easy. Explained properly\n\n\nAproach1: We can traverse through the whole linked list once and get the lenght of the list, then subtract the\n                  nth node from end to ge that nth position from the start, again traverse untill you reach n-1th node \n\nApproach2: Here instead of traversing twice we will try to traverse only once. \n                   Create two node pointers i, j. Start j from (i+n)th node, so that when we reach end for jth node that \n                   time we will have ith node at nth from behind\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        tempi, tempj = head, head\n        i = 0 \n\n        # this condition will handle when we have only one element in the linked list\n        if not tempi.next:\n            return None\n\n        while i<n:\n            tempj = tempj.next\n            i+=1\n\n        # this condition handles when we need to remove head of the linked list\n        # only while will cause error, because tempj will be None,  So None.next will give error\n        if not tempj:\n            head = tempi.next\n        else:\n            while tempj.next: \n                tempi = tempi.next\n                tempj = tempj.next\n        tempi.next = tempi.next.next\n\n        return head \n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "This question is silly in Python and super easy in C++, where you can pass by reference."
                    },
                    {
                        "username": "jmat",
                        "content": "Why is this code not working?\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        curr = head\\n        second_pointer = head\\n        count = 1\\n        while curr.next:\\n            curr=curr.next\\n            if count > n:\\n                second_pointer = second_pointer.next\\n                print(curr.val, second_pointer.val)\\n            count +=1\\n\\n        second_pointer.next = second_pointer.next.next\\n\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        head.pop(-n)\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, list, n):\\n        list.pop(-n)\\n        return list\\n\\n\\nl = Solution()\\nprint(l.removeNthFromEnd([1,2,3,4,5], 2))\\nprint(l.removeNthFromEnd([1], 1))\\nprint(l.removeNthFromEnd([1,2], 1))\\n"
                    },
                    {
                        "username": "PriyankaTaneja",
                        "content": "java.lang.NullPointerException: Cannot read field \"next\" because \"<local6>.next\" is null\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        int count = 0;\\n        ListNode temp = head;\\n            while(temp != null) {\\n                temp = temp.next;\\n                count++;\\n            }\\n        int pos = count-n+1;\\n    \\n        ListNode slow = head;\\n        for(int i=1;i<pos-1;i++) {  \\n            slow = slow.next;     \\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n\\nWhat\\'s wrong with this code, Can anyone suggest."
                    },
                    {
                        "username": "heyharshit",
                        "content": "dekho bakchodi toh karo mat"
                    }
                ]
            },
            {
                "id": 1670269,
                "content": [
                    {
                        "username": "adityamishra19_",
                        "content": "//c++\\nListNode*reverselist(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode*recursedhead = reverselist(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return recursedhead;\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode*ptr=reverselist(head);\\n        if(ptr==NULL || ptr->next==NULL) return NULL;\\n        if(n==1){\\n            ptr=ptr->next;\\n            return reverselist(ptr);\\n        }\\n        ListNode*ref=ptr;\\n        if(ref==NULL|| ref->next==NULL) return ref;\\n        int i=1;\\n        while(i!=n-1){\\n            ref=ref->next;\\n            i++;\\n        }\\n        ListNode*q=ref->next;\\n        ref->next=ref->next->next;\\n        delete(q);\\n        ListNode*adi=reverselist(ptr);\\n        return adi;\\n    }"
                    },
                    {
                        "username": "rampanda",
                        "content": "# Python solution simple and easy. Explained properly\n\n\nAproach1: We can traverse through the whole linked list once and get the lenght of the list, then subtract the\n                  nth node from end to ge that nth position from the start, again traverse untill you reach n-1th node \n\nApproach2: Here instead of traversing twice we will try to traverse only once. \n                   Create two node pointers i, j. Start j from (i+n)th node, so that when we reach end for jth node that \n                   time we will have ith node at nth from behind\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        tempi, tempj = head, head\n        i = 0 \n\n        # this condition will handle when we have only one element in the linked list\n        if not tempi.next:\n            return None\n\n        while i<n:\n            tempj = tempj.next\n            i+=1\n\n        # this condition handles when we need to remove head of the linked list\n        # only while will cause error, because tempj will be None,  So None.next will give error\n        if not tempj:\n            head = tempi.next\n        else:\n            while tempj.next: \n                tempi = tempi.next\n                tempj = tempj.next\n        tempi.next = tempi.next.next\n\n        return head \n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "This question is silly in Python and super easy in C++, where you can pass by reference."
                    },
                    {
                        "username": "jmat",
                        "content": "Why is this code not working?\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        curr = head\\n        second_pointer = head\\n        count = 1\\n        while curr.next:\\n            curr=curr.next\\n            if count > n:\\n                second_pointer = second_pointer.next\\n                print(curr.val, second_pointer.val)\\n            count +=1\\n\\n        second_pointer.next = second_pointer.next.next\\n\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        head.pop(-n)\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, list, n):\\n        list.pop(-n)\\n        return list\\n\\n\\nl = Solution()\\nprint(l.removeNthFromEnd([1,2,3,4,5], 2))\\nprint(l.removeNthFromEnd([1], 1))\\nprint(l.removeNthFromEnd([1,2], 1))\\n"
                    },
                    {
                        "username": "PriyankaTaneja",
                        "content": "java.lang.NullPointerException: Cannot read field \"next\" because \"<local6>.next\" is null\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        int count = 0;\\n        ListNode temp = head;\\n            while(temp != null) {\\n                temp = temp.next;\\n                count++;\\n            }\\n        int pos = count-n+1;\\n    \\n        ListNode slow = head;\\n        for(int i=1;i<pos-1;i++) {  \\n            slow = slow.next;     \\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n\\nWhat\\'s wrong with this code, Can anyone suggest."
                    },
                    {
                        "username": "heyharshit",
                        "content": "dekho bakchodi toh karo mat"
                    }
                ]
            },
            {
                "id": 1668685,
                "content": [
                    {
                        "username": "adityamishra19_",
                        "content": "//c++\\nListNode*reverselist(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode*recursedhead = reverselist(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return recursedhead;\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode*ptr=reverselist(head);\\n        if(ptr==NULL || ptr->next==NULL) return NULL;\\n        if(n==1){\\n            ptr=ptr->next;\\n            return reverselist(ptr);\\n        }\\n        ListNode*ref=ptr;\\n        if(ref==NULL|| ref->next==NULL) return ref;\\n        int i=1;\\n        while(i!=n-1){\\n            ref=ref->next;\\n            i++;\\n        }\\n        ListNode*q=ref->next;\\n        ref->next=ref->next->next;\\n        delete(q);\\n        ListNode*adi=reverselist(ptr);\\n        return adi;\\n    }"
                    },
                    {
                        "username": "rampanda",
                        "content": "# Python solution simple and easy. Explained properly\n\n\nAproach1: We can traverse through the whole linked list once and get the lenght of the list, then subtract the\n                  nth node from end to ge that nth position from the start, again traverse untill you reach n-1th node \n\nApproach2: Here instead of traversing twice we will try to traverse only once. \n                   Create two node pointers i, j. Start j from (i+n)th node, so that when we reach end for jth node that \n                   time we will have ith node at nth from behind\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        tempi, tempj = head, head\n        i = 0 \n\n        # this condition will handle when we have only one element in the linked list\n        if not tempi.next:\n            return None\n\n        while i<n:\n            tempj = tempj.next\n            i+=1\n\n        # this condition handles when we need to remove head of the linked list\n        # only while will cause error, because tempj will be None,  So None.next will give error\n        if not tempj:\n            head = tempi.next\n        else:\n            while tempj.next: \n                tempi = tempi.next\n                tempj = tempj.next\n        tempi.next = tempi.next.next\n\n        return head \n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "This question is silly in Python and super easy in C++, where you can pass by reference."
                    },
                    {
                        "username": "jmat",
                        "content": "Why is this code not working?\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        curr = head\\n        second_pointer = head\\n        count = 1\\n        while curr.next:\\n            curr=curr.next\\n            if count > n:\\n                second_pointer = second_pointer.next\\n                print(curr.val, second_pointer.val)\\n            count +=1\\n\\n        second_pointer.next = second_pointer.next.next\\n\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        head.pop(-n)\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, list, n):\\n        list.pop(-n)\\n        return list\\n\\n\\nl = Solution()\\nprint(l.removeNthFromEnd([1,2,3,4,5], 2))\\nprint(l.removeNthFromEnd([1], 1))\\nprint(l.removeNthFromEnd([1,2], 1))\\n"
                    },
                    {
                        "username": "PriyankaTaneja",
                        "content": "java.lang.NullPointerException: Cannot read field \"next\" because \"<local6>.next\" is null\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        int count = 0;\\n        ListNode temp = head;\\n            while(temp != null) {\\n                temp = temp.next;\\n                count++;\\n            }\\n        int pos = count-n+1;\\n    \\n        ListNode slow = head;\\n        for(int i=1;i<pos-1;i++) {  \\n            slow = slow.next;     \\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n\\nWhat\\'s wrong with this code, Can anyone suggest."
                    },
                    {
                        "username": "heyharshit",
                        "content": "dekho bakchodi toh karo mat"
                    }
                ]
            },
            {
                "id": 1664371,
                "content": [
                    {
                        "username": "adityamishra19_",
                        "content": "//c++\\nListNode*reverselist(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode*recursedhead = reverselist(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return recursedhead;\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode*ptr=reverselist(head);\\n        if(ptr==NULL || ptr->next==NULL) return NULL;\\n        if(n==1){\\n            ptr=ptr->next;\\n            return reverselist(ptr);\\n        }\\n        ListNode*ref=ptr;\\n        if(ref==NULL|| ref->next==NULL) return ref;\\n        int i=1;\\n        while(i!=n-1){\\n            ref=ref->next;\\n            i++;\\n        }\\n        ListNode*q=ref->next;\\n        ref->next=ref->next->next;\\n        delete(q);\\n        ListNode*adi=reverselist(ptr);\\n        return adi;\\n    }"
                    },
                    {
                        "username": "rampanda",
                        "content": "# Python solution simple and easy. Explained properly\n\n\nAproach1: We can traverse through the whole linked list once and get the lenght of the list, then subtract the\n                  nth node from end to ge that nth position from the start, again traverse untill you reach n-1th node \n\nApproach2: Here instead of traversing twice we will try to traverse only once. \n                   Create two node pointers i, j. Start j from (i+n)th node, so that when we reach end for jth node that \n                   time we will have ith node at nth from behind\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        tempi, tempj = head, head\n        i = 0 \n\n        # this condition will handle when we have only one element in the linked list\n        if not tempi.next:\n            return None\n\n        while i<n:\n            tempj = tempj.next\n            i+=1\n\n        # this condition handles when we need to remove head of the linked list\n        # only while will cause error, because tempj will be None,  So None.next will give error\n        if not tempj:\n            head = tempi.next\n        else:\n            while tempj.next: \n                tempi = tempi.next\n                tempj = tempj.next\n        tempi.next = tempi.next.next\n\n        return head \n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "This question is silly in Python and super easy in C++, where you can pass by reference."
                    },
                    {
                        "username": "jmat",
                        "content": "Why is this code not working?\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        curr = head\\n        second_pointer = head\\n        count = 1\\n        while curr.next:\\n            curr=curr.next\\n            if count > n:\\n                second_pointer = second_pointer.next\\n                print(curr.val, second_pointer.val)\\n            count +=1\\n\\n        second_pointer.next = second_pointer.next.next\\n\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        head.pop(-n)\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, list, n):\\n        list.pop(-n)\\n        return list\\n\\n\\nl = Solution()\\nprint(l.removeNthFromEnd([1,2,3,4,5], 2))\\nprint(l.removeNthFromEnd([1], 1))\\nprint(l.removeNthFromEnd([1,2], 1))\\n"
                    },
                    {
                        "username": "PriyankaTaneja",
                        "content": "java.lang.NullPointerException: Cannot read field \"next\" because \"<local6>.next\" is null\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        int count = 0;\\n        ListNode temp = head;\\n            while(temp != null) {\\n                temp = temp.next;\\n                count++;\\n            }\\n        int pos = count-n+1;\\n    \\n        ListNode slow = head;\\n        for(int i=1;i<pos-1;i++) {  \\n            slow = slow.next;     \\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n\\nWhat\\'s wrong with this code, Can anyone suggest."
                    },
                    {
                        "username": "heyharshit",
                        "content": "dekho bakchodi toh karo mat"
                    }
                ]
            },
            {
                "id": 1662071,
                "content": [
                    {
                        "username": "adityamishra19_",
                        "content": "//c++\\nListNode*reverselist(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode*recursedhead = reverselist(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return recursedhead;\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode*ptr=reverselist(head);\\n        if(ptr==NULL || ptr->next==NULL) return NULL;\\n        if(n==1){\\n            ptr=ptr->next;\\n            return reverselist(ptr);\\n        }\\n        ListNode*ref=ptr;\\n        if(ref==NULL|| ref->next==NULL) return ref;\\n        int i=1;\\n        while(i!=n-1){\\n            ref=ref->next;\\n            i++;\\n        }\\n        ListNode*q=ref->next;\\n        ref->next=ref->next->next;\\n        delete(q);\\n        ListNode*adi=reverselist(ptr);\\n        return adi;\\n    }"
                    },
                    {
                        "username": "rampanda",
                        "content": "# Python solution simple and easy. Explained properly\n\n\nAproach1: We can traverse through the whole linked list once and get the lenght of the list, then subtract the\n                  nth node from end to ge that nth position from the start, again traverse untill you reach n-1th node \n\nApproach2: Here instead of traversing twice we will try to traverse only once. \n                   Create two node pointers i, j. Start j from (i+n)th node, so that when we reach end for jth node that \n                   time we will have ith node at nth from behind\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        tempi, tempj = head, head\n        i = 0 \n\n        # this condition will handle when we have only one element in the linked list\n        if not tempi.next:\n            return None\n\n        while i<n:\n            tempj = tempj.next\n            i+=1\n\n        # this condition handles when we need to remove head of the linked list\n        # only while will cause error, because tempj will be None,  So None.next will give error\n        if not tempj:\n            head = tempi.next\n        else:\n            while tempj.next: \n                tempi = tempi.next\n                tempj = tempj.next\n        tempi.next = tempi.next.next\n\n        return head \n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "This question is silly in Python and super easy in C++, where you can pass by reference."
                    },
                    {
                        "username": "jmat",
                        "content": "Why is this code not working?\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        curr = head\\n        second_pointer = head\\n        count = 1\\n        while curr.next:\\n            curr=curr.next\\n            if count > n:\\n                second_pointer = second_pointer.next\\n                print(curr.val, second_pointer.val)\\n            count +=1\\n\\n        second_pointer.next = second_pointer.next.next\\n\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        head.pop(-n)\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, list, n):\\n        list.pop(-n)\\n        return list\\n\\n\\nl = Solution()\\nprint(l.removeNthFromEnd([1,2,3,4,5], 2))\\nprint(l.removeNthFromEnd([1], 1))\\nprint(l.removeNthFromEnd([1,2], 1))\\n"
                    },
                    {
                        "username": "PriyankaTaneja",
                        "content": "java.lang.NullPointerException: Cannot read field \"next\" because \"<local6>.next\" is null\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        int count = 0;\\n        ListNode temp = head;\\n            while(temp != null) {\\n                temp = temp.next;\\n                count++;\\n            }\\n        int pos = count-n+1;\\n    \\n        ListNode slow = head;\\n        for(int i=1;i<pos-1;i++) {  \\n            slow = slow.next;     \\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n\\nWhat\\'s wrong with this code, Can anyone suggest."
                    },
                    {
                        "username": "heyharshit",
                        "content": "dekho bakchodi toh karo mat"
                    }
                ]
            },
            {
                "id": 1651400,
                "content": [
                    {
                        "username": "adityamishra19_",
                        "content": "//c++\\nListNode*reverselist(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode*recursedhead = reverselist(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return recursedhead;\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode*ptr=reverselist(head);\\n        if(ptr==NULL || ptr->next==NULL) return NULL;\\n        if(n==1){\\n            ptr=ptr->next;\\n            return reverselist(ptr);\\n        }\\n        ListNode*ref=ptr;\\n        if(ref==NULL|| ref->next==NULL) return ref;\\n        int i=1;\\n        while(i!=n-1){\\n            ref=ref->next;\\n            i++;\\n        }\\n        ListNode*q=ref->next;\\n        ref->next=ref->next->next;\\n        delete(q);\\n        ListNode*adi=reverselist(ptr);\\n        return adi;\\n    }"
                    },
                    {
                        "username": "rampanda",
                        "content": "# Python solution simple and easy. Explained properly\n\n\nAproach1: We can traverse through the whole linked list once and get the lenght of the list, then subtract the\n                  nth node from end to ge that nth position from the start, again traverse untill you reach n-1th node \n\nApproach2: Here instead of traversing twice we will try to traverse only once. \n                   Create two node pointers i, j. Start j from (i+n)th node, so that when we reach end for jth node that \n                   time we will have ith node at nth from behind\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        tempi, tempj = head, head\n        i = 0 \n\n        # this condition will handle when we have only one element in the linked list\n        if not tempi.next:\n            return None\n\n        while i<n:\n            tempj = tempj.next\n            i+=1\n\n        # this condition handles when we need to remove head of the linked list\n        # only while will cause error, because tempj will be None,  So None.next will give error\n        if not tempj:\n            head = tempi.next\n        else:\n            while tempj.next: \n                tempi = tempi.next\n                tempj = tempj.next\n        tempi.next = tempi.next.next\n\n        return head \n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "This question is silly in Python and super easy in C++, where you can pass by reference."
                    },
                    {
                        "username": "jmat",
                        "content": "Why is this code not working?\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        curr = head\\n        second_pointer = head\\n        count = 1\\n        while curr.next:\\n            curr=curr.next\\n            if count > n:\\n                second_pointer = second_pointer.next\\n                print(curr.val, second_pointer.val)\\n            count +=1\\n\\n        second_pointer.next = second_pointer.next.next\\n\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        head.pop(-n)\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, list, n):\\n        list.pop(-n)\\n        return list\\n\\n\\nl = Solution()\\nprint(l.removeNthFromEnd([1,2,3,4,5], 2))\\nprint(l.removeNthFromEnd([1], 1))\\nprint(l.removeNthFromEnd([1,2], 1))\\n"
                    },
                    {
                        "username": "PriyankaTaneja",
                        "content": "java.lang.NullPointerException: Cannot read field \"next\" because \"<local6>.next\" is null\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        int count = 0;\\n        ListNode temp = head;\\n            while(temp != null) {\\n                temp = temp.next;\\n                count++;\\n            }\\n        int pos = count-n+1;\\n    \\n        ListNode slow = head;\\n        for(int i=1;i<pos-1;i++) {  \\n            slow = slow.next;     \\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n\\nWhat\\'s wrong with this code, Can anyone suggest."
                    },
                    {
                        "username": "heyharshit",
                        "content": "dekho bakchodi toh karo mat"
                    }
                ]
            },
            {
                "id": 1632513,
                "content": [
                    {
                        "username": "adityamishra19_",
                        "content": "//c++\\nListNode*reverselist(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode*recursedhead = reverselist(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return recursedhead;\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode*ptr=reverselist(head);\\n        if(ptr==NULL || ptr->next==NULL) return NULL;\\n        if(n==1){\\n            ptr=ptr->next;\\n            return reverselist(ptr);\\n        }\\n        ListNode*ref=ptr;\\n        if(ref==NULL|| ref->next==NULL) return ref;\\n        int i=1;\\n        while(i!=n-1){\\n            ref=ref->next;\\n            i++;\\n        }\\n        ListNode*q=ref->next;\\n        ref->next=ref->next->next;\\n        delete(q);\\n        ListNode*adi=reverselist(ptr);\\n        return adi;\\n    }"
                    },
                    {
                        "username": "rampanda",
                        "content": "# Python solution simple and easy. Explained properly\n\n\nAproach1: We can traverse through the whole linked list once and get the lenght of the list, then subtract the\n                  nth node from end to ge that nth position from the start, again traverse untill you reach n-1th node \n\nApproach2: Here instead of traversing twice we will try to traverse only once. \n                   Create two node pointers i, j. Start j from (i+n)th node, so that when we reach end for jth node that \n                   time we will have ith node at nth from behind\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        tempi, tempj = head, head\n        i = 0 \n\n        # this condition will handle when we have only one element in the linked list\n        if not tempi.next:\n            return None\n\n        while i<n:\n            tempj = tempj.next\n            i+=1\n\n        # this condition handles when we need to remove head of the linked list\n        # only while will cause error, because tempj will be None,  So None.next will give error\n        if not tempj:\n            head = tempi.next\n        else:\n            while tempj.next: \n                tempi = tempi.next\n                tempj = tempj.next\n        tempi.next = tempi.next.next\n\n        return head \n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "This question is silly in Python and super easy in C++, where you can pass by reference."
                    },
                    {
                        "username": "jmat",
                        "content": "Why is this code not working?\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        curr = head\\n        second_pointer = head\\n        count = 1\\n        while curr.next:\\n            curr=curr.next\\n            if count > n:\\n                second_pointer = second_pointer.next\\n                print(curr.val, second_pointer.val)\\n            count +=1\\n\\n        second_pointer.next = second_pointer.next.next\\n\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        head.pop(-n)\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, list, n):\\n        list.pop(-n)\\n        return list\\n\\n\\nl = Solution()\\nprint(l.removeNthFromEnd([1,2,3,4,5], 2))\\nprint(l.removeNthFromEnd([1], 1))\\nprint(l.removeNthFromEnd([1,2], 1))\\n"
                    },
                    {
                        "username": "PriyankaTaneja",
                        "content": "java.lang.NullPointerException: Cannot read field \"next\" because \"<local6>.next\" is null\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        int count = 0;\\n        ListNode temp = head;\\n            while(temp != null) {\\n                temp = temp.next;\\n                count++;\\n            }\\n        int pos = count-n+1;\\n    \\n        ListNode slow = head;\\n        for(int i=1;i<pos-1;i++) {  \\n            slow = slow.next;     \\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n\\nWhat\\'s wrong with this code, Can anyone suggest."
                    },
                    {
                        "username": "heyharshit",
                        "content": "dekho bakchodi toh karo mat"
                    }
                ]
            }
        ]
    },
    {
        "title": "Pascal's Triangle II",
        "question_content": "<p>Given an integer <code>rowIndex</code>, return the <code>rowIndex<sup>th</sup></code> (<strong>0-indexed</strong>) row of the <strong>Pascal&#39;s triangle</strong>.</p>\n\n<p>In <strong>Pascal&#39;s triangle</strong>, each number is the sum of the two numbers directly above it as shown:</p>\n<img alt=\"\" src=\"https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif\" style=\"height:240px; width:260px\" />\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> rowIndex = 3\n<strong>Output:</strong> [1,3,3,1]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> rowIndex = 0\n<strong>Output:</strong> [1]\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> rowIndex = 1\n<strong>Output:</strong> [1,1]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= rowIndex &lt;= 33</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you optimize your algorithm to use only <code>O(rowIndex)</code> extra space?</p>\n",
        "solutions": [
            {
                "id": 38420,
                "title": "here-is-my-brief-o-k-solution",
                "content": "The basic idea is to iteratively update the array from the end to the beginning. \\n\\n    class Solution {\\n    public:\\n        vector<int> getRow(int rowIndex) {\\n            vector<int> A(rowIndex+1, 0);\\n            A[0] = 1;\\n            for(int i=1; i<rowIndex+1; i++)\\n                for(int j=i; j>=1; j--)\\n                    A[j] += A[j-1];\\n            return A;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> getRow(int rowIndex) {\\n            vector<int> A(rowIndex+1, 0);\\n            A[0] = 1;\\n            for(int i=1; i<rowIndex+1; i++)\\n                for(int j=i; j>=1; j--)\\n                    A[j] += A[j-1];\\n            return A;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 38467,
                "title": "very-simple-python-solution",
                "content": "```\\nclass Solution(object):\\n    def getRow(self, rowIndex):\\n        \"\"\"\\n        :type rowIndex: int\\n        :rtype: List[int]\\n        \"\"\"\\n        row = [1]\\n        for _ in range(rowIndex):\\n            row = [x + y for x, y in zip([0]+row, row+[0])]\\n        return row\\n```\\n\\nUpdated according to @greg-irl 's suggestion below. It runs 30% faster than using ```map()```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def getRow(self, rowIndex):\\n        \"\"\"\\n        :type rowIndex: int\\n        :rtype: List[int]\\n        \"\"\"\\n        row = [1]\\n        for _ in range(rowIndex):\\n            row = [x + y for x, y in zip([0]+row, row+[0])]\\n        return row\\n```\n```map()```",
                "codeTag": "Java"
            },
            {
                "id": 38584,
                "title": "another-accepted-java-solution",
                "content": "    public class Solution {\\n        public List<Integer> getRow(int k) {\\n            Integer[] arr = new Integer[k + 1];\\n            Arrays.fill(arr, 0);\\n            arr[0] = 1;\\n            \\n            for (int i = 1; i <= k; i++) \\n                for (int j = i; j > 0; j--) \\n                    arr[j] = arr[j] + arr[j - 1];\\n            \\n            return Arrays.asList(arr);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Integer> getRow(int k) {\\n            Integer[] arr = new Integer[k + 1];\\n            Arrays.fill(arr, 0);\\n            arr[0] = 1;\\n            \\n            for (int i = 1; i <= k; i++) \\n                for (int j = i; j > 0; j--) \\n                    arr[j] = arr[j] + arr[j - 1];\\n            \\n            return Arrays.asList(arr);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1203260,
                "title": "very-easy-o-n-time-0-ms-beats-100-simple-maths-all-languages",
                "content": "This solution here, is **Linear** in time.\\n\\n---\\nAs you know you can get any element of Pascal\\'s Triangle in **O(N)** time and constant space complexity. \\nfor first row first column we have **1C1**\\nfor second row first column we have **2C1**\\nfor second row second column we have **2C2**\\n..... and so on\\nTherefore we can infer, for ith row and jth column we have the number **iCj**\\n\\nAnd calculating this is pretty easy just in ***N*** time (factorial basically).\\n\\n==> `nCr = n*(n-1)*(n-2)...(r terms) /  1*2*..........*(r-2)*(r-1)*r`\\n\\nNow the question asks us to find the complete row.\\nIf we calculate all the elements in this manner it would be quadratic in time. But, since its formula is pretty sleek, we proceed as follows:\\n\\nsuppose we have **nCr** and we have to find **nC(r+1)**, like **5C3** and **5C4**\\n==> `5C3 = 5*4*3 / 1*2*3`\\n\\nto get the next term we multiply numerator with its next term and denominator with its next term. As, \\n==> `5C4 = 5*4*3 * 2 / 1*2*3 * 4`\\n\\nWe are following this simple maths logic to get the complete row in **O(N)** time.\\n\\n**Note:-** We didnt actually need the variable temp. But the test cases are such that multiplying in one case exceeds the **int range**, and since we cannot change return type we have to take the **long** data type variable as temporary.\\n\\n---\\n**Python Code:**\\nThe result for this code is **8 ms / 13.3 MB** (beats 99.82% / 88.54%): \\n```\\nclass Solution(object):\\n    def getRow(self, r):\\n        ans = [1]*(r+1);\\n        up = r\\n        down = 1\\n        for i in range(1, r):\\n            ans[i] = ans[i-1]*up/down;\\n            up = up - 1\\n            down = down + 1\\n        return ans;\\n```\\n\\n---\\n**Java Code:**\\nThe result for this code is **0 ms / 36.3 MB** (beats 100% / 91.45%): \\n```\\nclass Solution {\\n    public List<Integer> getRow(int r) {\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(1);\\n        long temp = 1;\\n        for(int i=1,up=r,down=1;i<=r;i++,up--, down++){\\n            temp=temp*up/down;\\n            ans.add((int)temp);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n**JavaScript Code:**\\nThe result for this code is **72 ms / 38.7 MB** (beats 90.29% / 40.05%): \\n```\\nvar getRow = function(r) {\\n    var ans = new Array(r+1)\\n    ans[0]=ans[r]=1\\n    for(i=1,up=r;i<r;i++,up--)\\n        ans[i] = ans[i-1]*up/i\\n    return ans\\n};\\n```\\n\\n---\\n**C++ Code:**\\nThe result for this code is **0 ms / 6.2 MB** (beats 100% / 84.20%): \\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int r) {\\n        vector<int>v(r+1);\\n        long temp=1;\\n        v[0]=v[r]=1;\\n        for(int i=1,up=r,down=1;i<r;i++,up--,down++){\\n            temp = temp*up/down;\\n            v[i]=temp;\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\n---\\n**C Code:**\\nThe result for this code is **0 ms / 5.6 MB** (beats 100% / 85.96%): \\n```\\nint* getRow(int r, int* rS){\\n    int*ans = calloc(r + 1, sizeof(int));\\n    long temp=1;\\n    ans[0]=1;\\n    for(int i=1,up=r;i<=r;i++,up--){\\n        temp=temp*up/i;\\n        ans[i]=temp;\\n    }\\n    *rS = r+1;\\n    return ans;\\n}\\n```\\n\\n---\\n\\n**C# Code:**\\nThe result for this code is **188 ms / 26.2 MB** (beats 99.37% / 69.62%): \\n```\\npublic class Solution {\\n    public IList<int> GetRow(int r) {\\n        var ans = new int[r+1];\\n        ans[0]=ans[r]=1;\\n        long temp=1;\\n        for(int i=1,up=r;i<r;i++,up--){\\n            temp = temp * up / i;\\n            ans[i]=(int)temp;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n**Ruby Code:**\\nThe result for this code is **48 ms / 209.8 MB** (beats 80.65% / 35.48%): \\n```\\ndef get_row(r)\\n    return [1] if r==0\\n    ans = [1]\\n    temp = 1\\n    for i in 1...r do\\n        temp = temp * (r-i+1)/i\\n        ans << temp\\n    end\\n    ans << 1\\n    return ans\\nend\\n```\\n\\n---\\n\\n**Switft Code:**\\nThe result for this code is **0 ms / 14 MB** (beats 100.00% / 68.04%)\\n```\\nclass Solution {\\n    func getRow(_ r: Int) -> [Int] {\\n        if r==0 {\\n            return [1]\\n        }\\n        var ans = [Int](repeating: 1, count: r+1)\\n        for i in 1...r {\\n            ans[i] = ans[i-1]*(r-i+1)/i\\n        }\\n        return ans\\n    }\\n}\\n```\\n\\n---\\n\\n**Go Code:**\\nThe result for this code is **0 ms / 2 MB** (beats 100.00% / 100.00%)\\n```\\nfunc getRow(r int) []int {\\n    var ans = make([]int,r+1)\\n    ans[0] = 1\\n    ans[r] = 1\\n    for i:=1; i<=r; i++ {\\n        ans[i] = ans[i-1]*(r-i+1)/i\\n    }\\n    return ans\\n}\\n```\\n\\n---\\n\\n**Scala Code:**\\nThe result for this code is **388 ms / 49.4 MB** (beats 100.00% / 95.00%)\\n**Note:** `implicit def` function is used to implicitly convert array to List\\n```\\nobject Solution {\\n    implicit def arrayToList[A](a: Array[A]) = a.toList\\n    def getRow(r: Int): List[Int] = {\\n        var ans = new Array[Int](r+1)\\n        ans(0) = 1\\n        var temp: Long = 1\\n        for( i <- 1 to r){\\n            temp = temp*(r-i+1)/i\\n            ans(i) = temp.asInstanceOf[Int]\\n        }\\n        return ans\\n    }\\n}\\n```\\n\\n---\\n\\n**Kotlin Code:**\\nThe result for this code is **132 ms / 33.1 MB** (beats 91.67% / 98.81%)\\n```\\nclass Solution {\\n    fun getRow(r: Int): List<Int> {\\n        var ans = MutableList<Int>(r+1){1}\\n        var temp: Long = 1\\n        for (i in 1..r){\\n            temp = temp*(r-i+1)/i\\n            ans[i] = temp.toInt()\\n        }\\n        return ans\\n    }\\n}\\n```\\n\\n---\\n\\n**Rust Code:**\\nThe result for this code is **0 ms /1.9 MB** (beats 100.00% / 92.31%)\\n```\\nimpl Solution {\\n    pub fn get_row(r: i32) -> Vec<i32> {\\n        let mut ans : Vec<i32> = Vec::new();  \\n        ans.push(1);\\n        let mut temp: i64 = 1;\\n        let mut up = r as i64;\\n        let mut down = 1 as i64;\\n        for i in 1..=r {\\n            temp = temp*up/down;\\n            ans.push(temp as i32);\\n            up-=1;\\n            down+=1;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n**PHP Code:**\\nThe result for this code is **0 ms /15.7 MB** (beats 100.00% / 48.15%)\\n```\\nclass Solution {\\n    function getRow($r) {\\n        $ans = array(1);\\n        $temp = 1;\\n        for($i=1;$i<=$r;$i++){\\n            $temp = $temp*($r-$i+1)/$i;\\n            array_push($ans, $temp);\\n        }\\n        return $ans;\\n    }\\n}\\n```\\n\\n---\\n\\n**TypeScript Code:**\\nThe result for this code is **80 ms /39.2 MB** (beats 74.58% / 72.88%)\\n```\\nfunction getRow(r: number): number[] {\\n    var ans:number[] = [1]\\n    var temp:number = 1\\n    for(var i:number=1;i<=r;i++){\\n        temp = temp*(r-i+1)/i\\n        ans.push(temp)\\n    }\\n    return ans\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Ruby",
                    "Swift"
                ],
                "code": "```\\nclass Solution(object):\\n    def getRow(self, r):\\n        ans = [1]*(r+1);\\n        up = r\\n        down = 1\\n        for i in range(1, r):\\n            ans[i] = ans[i-1]*up/down;\\n            up = up - 1\\n            down = down + 1\\n        return ans;\\n```\n```\\nclass Solution {\\n    public List<Integer> getRow(int r) {\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(1);\\n        long temp = 1;\\n        for(int i=1,up=r,down=1;i<=r;i++,up--, down++){\\n            temp=temp*up/down;\\n            ans.add((int)temp);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nvar getRow = function(r) {\\n    var ans = new Array(r+1)\\n    ans[0]=ans[r]=1\\n    for(i=1,up=r;i<r;i++,up--)\\n        ans[i] = ans[i-1]*up/i\\n    return ans\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int r) {\\n        vector<int>v(r+1);\\n        long temp=1;\\n        v[0]=v[r]=1;\\n        for(int i=1,up=r,down=1;i<r;i++,up--,down++){\\n            temp = temp*up/down;\\n            v[i]=temp;\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nint* getRow(int r, int* rS){\\n    int*ans = calloc(r + 1, sizeof(int));\\n    long temp=1;\\n    ans[0]=1;\\n    for(int i=1,up=r;i<=r;i++,up--){\\n        temp=temp*up/i;\\n        ans[i]=temp;\\n    }\\n    *rS = r+1;\\n    return ans;\\n}\\n```\n```\\npublic class Solution {\\n    public IList<int> GetRow(int r) {\\n        var ans = new int[r+1];\\n        ans[0]=ans[r]=1;\\n        long temp=1;\\n        for(int i=1,up=r;i<r;i++,up--){\\n            temp = temp * up / i;\\n            ans[i]=(int)temp;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\ndef get_row(r)\\n    return [1] if r==0\\n    ans = [1]\\n    temp = 1\\n    for i in 1...r do\\n        temp = temp * (r-i+1)/i\\n        ans << temp\\n    end\\n    ans << 1\\n    return ans\\nend\\n```\n```\\nclass Solution {\\n    func getRow(_ r: Int) -> [Int] {\\n        if r==0 {\\n            return [1]\\n        }\\n        var ans = [Int](repeating: 1, count: r+1)\\n        for i in 1...r {\\n            ans[i] = ans[i-1]*(r-i+1)/i\\n        }\\n        return ans\\n    }\\n}\\n```\n```\\nfunc getRow(r int) []int {\\n    var ans = make([]int,r+1)\\n    ans[0] = 1\\n    ans[r] = 1\\n    for i:=1; i<=r; i++ {\\n        ans[i] = ans[i-1]*(r-i+1)/i\\n    }\\n    return ans\\n}\\n```\n```\\nobject Solution {\\n    implicit def arrayToList[A](a: Array[A]) = a.toList\\n    def getRow(r: Int): List[Int] = {\\n        var ans = new Array[Int](r+1)\\n        ans(0) = 1\\n        var temp: Long = 1\\n        for( i <- 1 to r){\\n            temp = temp*(r-i+1)/i\\n            ans(i) = temp.asInstanceOf[Int]\\n        }\\n        return ans\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun getRow(r: Int): List<Int> {\\n        var ans = MutableList<Int>(r+1){1}\\n        var temp: Long = 1\\n        for (i in 1..r){\\n            temp = temp*(r-i+1)/i\\n            ans[i] = temp.toInt()\\n        }\\n        return ans\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn get_row(r: i32) -> Vec<i32> {\\n        let mut ans : Vec<i32> = Vec::new();  \\n        ans.push(1);\\n        let mut temp: i64 = 1;\\n        let mut up = r as i64;\\n        let mut down = 1 as i64;\\n        for i in 1..=r {\\n            temp = temp*up/down;\\n            ans.push(temp as i32);\\n            up-=1;\\n            down+=1;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    function getRow($r) {\\n        $ans = array(1);\\n        $temp = 1;\\n        for($i=1;$i<=$r;$i++){\\n            $temp = $temp*($r-$i+1)/$i;\\n            array_push($ans, $temp);\\n        }\\n        return $ans;\\n    }\\n}\\n```\n```\\nfunction getRow(r: number): number[] {\\n    var ans:number[] = [1]\\n    var temp:number = 1\\n    for(var i:number=1;i<=r;i++){\\n        temp = temp*(r-i+1)/i\\n        ans.push(temp)\\n    }\\n    return ans\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 38478,
                "title": "my-accepted-java-solution-any-better-code",
                "content": "      public List<Integer> getRow(int rowIndex) {\\n\\t\\tList<Integer> list = new ArrayList<Integer>();\\n\\t\\tif (rowIndex < 0)\\n\\t\\t\\treturn list;\\n\\n\\t\\tfor (int i = 0; i < rowIndex + 1; i++) {\\n\\t\\t\\tlist.add(0, 1);\\n\\t\\t\\tfor (int j = 1; j < list.size() - 1; j++) {\\n\\t\\t\\t\\tlist.set(j, list.get(j) + list.get(j + 1));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn list;\\n\\t}",
                "solutionTags": [],
                "code": "      public List<Integer> getRow(int rowIndex) {\\n\\t\\tList<Integer> list = new ArrayList<Integer>();\\n\\t\\tif (rowIndex < 0)\\n\\t\\t\\treturn list;\\n\\n\\t\\tfor (int i = 0; i < rowIndex + 1; i++) {\\n\\t\\t\\tlist.add(0, 1);\\n\\t\\t\\tfor (int j = 1; j < list.size() - 1; j++) {\\n\\t\\t\\t\\tlist.set(j, list.get(j) + list.get(j + 1));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn list;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 38454,
                "title": "sharing-my-c-code-very-simple",
                "content": "    class Solution {\\n    public:\\n        vector<int> getRow(int rowIndex) {\\n            vector<int> vi(rowIndex + 1);\\n           \\tvi[0] = 1;\\n            for (int i = 0; i <= rowIndex ; ++i)\\n            {\\n            \\tfor (int j = i; j > 0; --j)\\n            \\t{\\n    \\t        \\tvi[j] = vi[j] + vi[j-1];\\n            \\t}\\n            }\\n            return vi;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> getRow(int rowIndex) {\\n            vector<int> vi(rowIndex + 1);\\n           \\tvi[0] = 1;\\n            for (int i = 0; i <= rowIndex ; ++i)\\n            {\\n            \\tfor (int j = i; j > 0; --j)\\n            \\t{\\n    \\t        \\tvi[j] = vi[j] + vi[j-1];\\n            \\t}",
                "codeTag": "Java"
            },
            {
                "id": 38437,
                "title": "my-8-lines-java-solution-use-arraylist",
                "content": "    public List<Integer> getRow(int rowIndex) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        for(int i = 0;i<rowIndex+1;i++) {\\n        \\t\\tres.add(1);\\n        \\t\\tfor(int j=i-1;j>0;j--) {\\n        \\t\\t\\tres.set(j, res.get(j-1)+res.get(j));\\n        \\t\\t}\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<Integer> getRow(int rowIndex) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        for(int i = 0;i<rowIndex+1;i++) {\\n        \\t\\tres.add(1);\\n        \\t\\tfor(int j=i-1;j>0;j--) {\\n        \\t\\t\\tres.set(j, res.get(j-1)+res.get(j));\\n        \\t\\t}\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 38473,
                "title": "java-o-k-solution-with-explanation",
                "content": "When generating each row, we can use the previous row directly, so this way we only use O(k) space with k being the number of row.  For each new row, we append a `1`, letting j iterate from `i - 1` backward to `1`, and set the `jth` element as `res.set(j, res.get(j-1) + res.get(j))`.  For example, when `k = 4`, the process goes like this:\\n\\n    k == 0\\n    [1] \\n    k == 1\\n    [11] \\n    k == 2\\n    [111]  add 1\\n    [121]  calculate jth spot\\n    k == 3\\n    [1211]  add 1\\n    [1331]   calculate jth spot\\n    k == 4\\n    [13311]  add 1\\n    [14641]  calculate jth spot\\n\\n\\nJava\\n\\n       public List<Integer> getRow(int rowIndex) {\\n            List<Integer> res = new ArrayList<>();\\n            for(int i = 0; i <= rowIndex; i++) {\\n                res.add(1);\\n                for(int j = i-1; j > 0; j--) {\\n                    res.set(j, res.get(j-1) + res.get(j));\\n                }\\n            }\\n            return res;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "When generating each row, we can use the previous row directly, so this way we only use O(k) space with k being the number of row.  For each new row, we append a `1`, letting j iterate from `i - 1` backward to `1`, and set the `jth` element as `res.set(j, res.get(j-1) + res.get(j))`.  For example, when `k = 4`, the process goes like this:\\n\\n    k == 0\\n    [1] \\n    k == 1\\n    [11] \\n    k == 2\\n    [111]  add 1\\n    [121]  calculate jth spot\\n    k == 3\\n    [1211]  add 1\\n    [1331]   calculate jth spot\\n    k == 4\\n    [13311]  add 1\\n    [14641]  calculate jth spot\\n\\n\\nJava\\n\\n       public List<Integer> getRow(int rowIndex) {\\n            List<Integer> res = new ArrayList<>();\\n            for(int i = 0; i <= rowIndex; i++) {\\n                res.add(1);\\n                for(int j = i-1; j > 0; j--) {\\n                    res.set(j, res.get(j-1) + res.get(j));\\n                }\\n            }\\n            return res;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 38513,
                "title": "my-clean-o-k-java-solution",
                "content": "Based on rules:\\n\\nrow k of Pascal's Triangle: \\n\\n`[C(k,0), C(k,1), ..., C(k, k-1), C(k, k)]`\\n\\nand\\n\\n`C[k,i] = C[k,i-1]*(k-i+1)/i`\\n\\n \\n \\n\\n        public class Solution {\\n            public List<Integer> getRow(int rowIndex) {\\n                Integer[] rowList = new Integer[rowIndex+1];\\n                rowList[0] = 1;\\n                for(int i=1; i<rowList.length;i++) {\\n                    rowList[i] = (int)((long)rowList[i-1]*(rowIndex-(i-1))/(i));\\n                }\\n                return Arrays.asList(rowList);\\n            }\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n            public List<Integer> getRow(int rowIndex) {\\n                Integer[] rowList = new Integer[rowIndex+1];\\n                rowList[0] = 1;\\n                for(int i=1; i<rowList.length;i++) {\\n                    rowList[i] = (int)((long)rowList[i-1]*(rowIndex-(i-1))/(i));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 38482,
                "title": "my-12-lines-of-c-solution-in-2ms-with-only-one-loop-o-k-time-and-o-k-space",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> getRow(int rowIndex) {\\n        vector<int> ans(rowIndex+1,1);\\n        int small = rowIndex/2;\\n        long comb = 1;\\n        int j = 1;\\n        for (int i=rowIndex; i>=small; i--){\\n            comb *= i;\\n            comb /= j;\\n            j ++;\\n            ans[i-1] = (int)comb;\\n            ans[j-1] = (int)comb;\\n        }\\n        return ans;\\n    }\\n\\n};\\n\\nNote that this solution is math derived from number of Combinations. \\n\\nEach line of Pascal's Triangle is a full set of Combination number based on k .\\n\\ncomb(k,p) = k! /( p! *(k-p)!) = comb(k,k-p)\\n\\nif p < k-p\\n\\ncomb(k,p) = comb(k,p-1) * (k-p+1) / p\\n\\n                                          \\nBecause :\\n\\ncomb(k,p) =     [ k * (k-1) * (k-2) *... (k-p+1)] /   [1 * 2      * 3       *...(p)]",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> getRow(int rowIndex) {\\n        vector<int> ans(rowIndex+1,1);\\n        int small = rowIndex/2;\\n        long comb = 1;\\n        int j = 1;\\n        for (int i=rowIndex; i>=small; i--){\\n            comb *= i;\\n            comb /= j;\\n            j ++;\\n            ans[i-1] = (int)comb;\\n            ans[j-1] = (int)comb;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1697627,
                "title": "understand-the-recursive-approach",
                "content": "1. What we know?\\n    - We Know that, if `rowIndex==0` (first row) then we only have `{1}` in the row.\\n    - We also know that first and last element of our row will be `1` **always**.\\n    - We also Know that we can find `currentRow[i]` by adding `previousRow[i-1]` and `previousRow[i]`.\\n2. Data for recursion,\\n    - from above discussion, now we can get 2 important things for recursion\\n    1. **Base Case:** `if(rowIndex==0) return {1};`\\n    2. **Recurrence Relation:** `currentRow[i] = (previousRow[i-1]+previousRow[i]);`\\n> Before reading out please give it a try now.\\n3. Algorithm\\n    - We can start with `currentRow[0] = 1`\\n    - Now **believe** that, we get the previous row with recursive call `previousRow = getRow(rowIndex-1);`\\n    - Then fill the remaining elements of current row with recurrence relation \\n        `currentRow[i] = (previousRow[i-1]+previousRow[i]);`\\n    - As we know, last element of row is 1, push 1 in the vector.\\n    - Return the current row i.e. `currentRow`.\\n\\n### C++\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        if(rowIndex==0) return {1}; // Base Case\\n\\n        vector<int> currentRow = {1}; // current row with 1 value in it\\n        vector<int> previousRow = getRow(rowIndex-1); // get the previous row\\n\\n        // Now fill the current row based on previous row\\n        for(int i=1;i<rowIndex;i++){\\n            currentRow.push_back(previousRow[i-1]+previousRow[i]);\\n        }\\n\\n        currentRow.push_back(1); // fill the last element of current row\\n        return currentRow;\\n    }\\n};\\n```\\n\\n**If you like it then please upvote !**\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        if(rowIndex==0) return {1}; // Base Case\\n\\n        vector<int> currentRow = {1}; // current row with 1 value in it\\n        vector<int> previousRow = getRow(rowIndex-1); // get the previous row\\n\\n        // Now fill the current row based on previous row\\n        for(int i=1;i<rowIndex;i++){\\n            currentRow.push_back(previousRow[i-1]+previousRow[i]);\\n        }\\n\\n        currentRow.push_back(1); // fill the last element of current row\\n        return currentRow;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 38574,
                "title": "simple-python-5-lines-36ms",
                "content": "    def getRow(rowIndex):\\n        pascal = [1]*(rowIndex + 1)\\n        for i in range(2,rowIndex+1):\\n            for j in range(i-1,0,-1):\\n                pascal[j] += pascal[j-1]\\n        return pascal",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def getRow(rowIndex):\\n        pascal = [1]*(rowIndex + 1)\\n        for i in range(2,rowIndex+1):\\n            for j in range(i-1,0,-1):\\n                pascal[j] += pascal[j-1]\\n        return pascal",
                "codeTag": "Python3"
            },
            {
                "id": 38438,
                "title": "7-lines-c-solution-one-pass-o-k-space-for-return-with-detailed-explanation",
                "content": "We know that the elements of the ith line of pascal triangle is just the coefficients of the expansion of \\n\\n> (a + b) ^ i\\n\\nFor example, the 4th line:\\n\\n> 1 4 6 4 1  \\n(a + b) ^ 4 = a^4 + 4a^3b + 6a^2b^2 + 4ab^3 + b^4\\n\\nAnd the we know the coefficients can be computed by composition. For the above example, the coefficients are respectively C(4, 0), C(4, 1), C(4, 2), C(4, 3), C(4, 4).\\n\\nThen we have the following code:\\n\\n    vector<int> getRow(int rowIndex) {\\n        vector<int> ret(rowIndex + 1, 1);\\n        long C = 1;\\n        for (int i = 1; i < rowIndex; i++) {\\n            C = C * (rowIndex - i + 1) / i;\\n            ret[i] = C;\\n        }\\n        return ret;\\n    }\\n\\nNotice that C(n, i) = C(n, n - i). We can optimize the code for only computing the first half.I didn't do the optimization here for simplicity.",
                "solutionTags": [],
                "code": "We know that the elements of the ith line of pascal triangle is just the coefficients of the expansion of \\n\\n> (a + b) ^ i\\n\\nFor example, the 4th line:\\n\\n> 1 4 6 4 1  \\n(a + b) ^ 4 = a^4 + 4a^3b + 6a^2b^2 + 4ab^3 + b^4\\n\\nAnd the we know the coefficients can be computed by composition. For the above example, the coefficients are respectively C(4, 0), C(4, 1), C(4, 2), C(4, 3), C(4, 4).\\n\\nThen we have the following code:\\n\\n    vector<int> getRow(int rowIndex) {\\n        vector<int> ret(rowIndex + 1, 1);\\n        long C = 1;\\n        for (int i = 1; i < rowIndex; i++) {\\n            C = C * (rowIndex - i + 1) / i;\\n            ret[i] = C;\\n        }\\n        return ret;\\n    }\\n\\nNotice that C(n, i) = C(n, n - i). We can optimize the code for only computing the first half.I didn't do the optimization here for simplicity.",
                "codeTag": "Unknown"
            },
            {
                "id": 727336,
                "title": "c-simple-and-short-solution-0-ms-beats-100",
                "content": "```\\n// Please, UpVote, if you like it :-) Thank you\\nvector<int> getRow(int rowIndex) {\\n\\tvector<int> ret { 1 }, cur { 1 };\\n\\tfor (int i = 1; i <= rowIndex; i++) {\\n\\t\\tret.push_back(1);\\n\\t\\tfor (int j = 1; j < i; j++) {\\n\\t\\t\\tret[j] = cur[j] + cur[j - 1];\\n\\t\\t}\\n\\t\\tcur = ret;\\n\\t}\\n\\treturn ret;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Please, UpVote, if you like it :-) Thank you\\nvector<int> getRow(int rowIndex) {\\n\\tvector<int> ret { 1 }, cur { 1 };\\n\\tfor (int i = 1; i <= rowIndex; i++) {\\n\\t\\tret.push_back(1);\\n\\t\\tfor (int j = 1; j < i; j++) {\\n\\t\\t\\tret[j] = cur[j] + cur[j - 1];\\n\\t\\t}\\n\\t\\tcur = ret;\\n\\t}\\n\\treturn ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 38645,
                "title": "c-solution-0ms-one-pass-no-extra-space",
                "content": "Two considerations:\\n1) At Nth row, each k-th element is determined by a well-known formula: C(n, k) = n! / (k!*(n-k)!). Obviously, we don't want to calculate factorial each time since we need to fill in the whole row, so we can just multiply both the numerator and denominator sequentially\\n\\n2) A row in Pascal triangle is always symmetric, so we fill up two elements at each loop iteration\\n\\nA drawback: In order to avoid overflows, we need to employ ugly casts to unsigned long\\n\\n\\n    class Solution {\\n    public:\\n        vector<int> getRow(int rowIndex) {\\n            vector<int> r;\\n            r.resize(rowIndex + 1);\\n            r[0] = r[rowIndex] = 1;\\n            for(auto i = 1; i < (r.size() + 1)/2; ++i)\\n            {\\n                r[i] = r[rowIndex - i] = (unsigned long)r[i - 1]*(unsigned long)(rowIndex - i + 1)/i;\\n            }\\n            return r;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> getRow(int rowIndex) {\\n            vector<int> r;\\n            r.resize(rowIndex + 1);\\n            r[0] = r[rowIndex] = 1;\\n            for(auto i = 1; i < (r.size() + 1)/2; ++i)\\n            {\\n                r[i] = r[rowIndex - i] = (unsigned long)r[i - 1]*(unsigned long)(rowIndex - i + 1)/i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 38598,
                "title": "elegant-javascript-o-k-space-solution",
                "content": "    var getRow = function(rowIndex) {\\n        var row = [1];\\n        \\n        for(var i = 1 ; i <= rowIndex ; i++) {\\n            for(var j = i; j > 0; j--) {\\n                if(j === i)\\n                    row[j] = 1;\\n                else\\n                    row[j] = row[j - 1] + row[j];\\n            }\\n        }\\n        return row;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var getRow = function(rowIndex) {\\n        var row = [1];\\n        \\n        for(var i = 1 ; i <= rowIndex ; i++) {\\n            for(var j = i; j > 0; j--) {\\n                if(j === i)\\n                    row[j] = 1;\\n                else\\n                    row[j] = row[j - 1] + row[j];\\n            }\\n        }\\n        return row;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 1552264,
                "title": "3-lines-code-space-o-1-and-time-o-rowindex-no-dp-no-recursion",
                "content": "let say rowIndex = n\\n```\\nwe have entries like\\n4C0  4C1 , 4C2 4C3 4C4\\n```\\n` #now if we calculate factorial then nCr , will give  `**overflow** \\n\\n## So what we do is calculate nCr+1 from nCr\\n![image](https://assets.leetcode.com/users/images/47267fd3-4d4a-4391-8072-65a53979934f_1635747712.5746357.jpeg)\\n\\n\\n#### *Here n is rowindex , and r is column* \\n\\n```\\n\\nclass Solution {\\n   public List<Integer> getRow(int rowIndex) {\\n        List<Integer> ans = new ArrayList<>();                \\n        long val=1;\\n\\t\\t\\n        for(int j = 0; j <= rowIndex; j++){\\n                ans.add((int)val );\\n                val = (val * (rowIndex - j)) / (j + 1);\\n            }\\n\\t\\t\\t\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nwe have entries like\\n4C0  4C1 , 4C2 4C3 4C4\\n```\n```\\n\\nclass Solution {\\n   public List<Integer> getRow(int rowIndex) {\\n        List<Integer> ans = new ArrayList<>();                \\n        long val=1;\\n\\t\\t\\n        for(int j = 0; j <= rowIndex; j++){\\n                ans.add((int)val );\\n                val = (val * (rowIndex - j)) / (j + 1);\\n            }\\n\\t\\t\\t\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177710,
                "title": "best-c-2-solutions-ever-dp-tabulation-bottom-up-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Two Approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using Dynamic Programming Approach(Tabulation: Bottom Up) With 2D Array(output) Extra Space.\\n2. Solved using Dynamic Programming Approach(Tabulation: Bottom Up) With 1D Array(output) Extra Space.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity : O(N^2). Where N is the rowIndex+1. Here total number of iterations are : N*(N+1)/2 which creates the time complexity.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(1). Constant space. Because we are creating 2D Array(output) as per the demand of program.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N^2). Where N is the rowIndex+1. Here total number of iterations are : N*(N+1)/2 which\\n    creates the time complexity.\\n\\n    Space Complexity : O(1). Constant space. Because we are creating 2D Array(output) as per the demand of\\n    program.\\n\\n    Solved using Dynamic Programming Approach(Tabulation: Bottom Up) With 2D Array(output) Extra Space.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<vector<int>> output(rowIndex+1);\\n        for(int i=0; i<=rowIndex; i++){\\n            output[i].resize(i+1, 1);\\n            for(int j=1; j<i; j++){\\n                output[i][j] = output[i-1][j-1] + output[i-1][j];\\n            }\\n        }\\n        return output.back();\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^2). Where N is the rowIndex+1. Here total number of iterations are : N*(N+1)/2 which\\n    creates the time complexity.\\n\\n    Space Complexity : O(1). Constant space. Because we are creating Array(output) as per the demand of\\n    program.\\n\\n    Solved using Dynamic Programming Approach(Tabulation: Bottom Up) With 1D Array(output) Extra Space.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<int> output(rowIndex+1, 0);\\n        output[0] = 1;\\n        for(int i=0; i<rowIndex; i++){\\n            for(int j=i+1; j>=1; j--){\\n                output[j] += output[j-1];\\n            }\\n        }\\n        return output;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N^2). Where N is the rowIndex+1. Here total number of iterations are : N*(N+1)/2 which\\n    creates the time complexity.\\n\\n    Space Complexity : O(1). Constant space. Because we are creating 2D Array(output) as per the demand of\\n    program.\\n\\n    Solved using Dynamic Programming Approach(Tabulation: Bottom Up) With 2D Array(output) Extra Space.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<vector<int>> output(rowIndex+1);\\n        for(int i=0; i<=rowIndex; i++){\\n            output[i].resize(i+1, 1);\\n            for(int j=1; j<i; j++){\\n                output[i][j] = output[i-1][j-1] + output[i-1][j];\\n            }\\n        }\\n        return output.back();\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^2). Where N is the rowIndex+1. Here total number of iterations are : N*(N+1)/2 which\\n    creates the time complexity.\\n\\n    Space Complexity : O(1). Constant space. Because we are creating Array(output) as per the demand of\\n    program.\\n\\n    Solved using Dynamic Programming Approach(Tabulation: Bottom Up) With 1D Array(output) Extra Space.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<int> output(rowIndex+1, 0);\\n        output[0] = 1;\\n        for(int i=0; i<rowIndex; i++){\\n            for(int j=i+1; j>=1; j--){\\n                output[j] += output[j-1];\\n            }\\n        }\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2626185,
                "title": "0-ms-beats-100-99-19-possibly-best-solution-with-explanation",
                "content": "# Using temp vector || 0ms\\nBased on fact that : nCr = n-1Cr-1 + n-1Cr\\n```\\n\\tvector<int> getRow(int rowIndex) {\\n        vector<int> dp(rowIndex+1, 1);\\n        if(rowIndex <= 1) return dp;\\n        vector<int> temp = dp;\\n        for(int i = 2; i <= rowIndex; i++) {\\n            for(int j = 1; j < i; j++) {\\n                temp[j] = dp[j] + dp[j-1];\\n            }\\n            dp = temp;\\n        }\\n        return dp;\\n    }\\n```\\n\\n# Space optimization\\n```\\n\\tvector<int> getRow(int rowIndex) {\\n        vector<int> dp(rowIndex+1, 1);\\n        if(rowIndex <= 1) return dp;\\n        for(int i = 2; i <= rowIndex; i++) {\\n            for(int j = i-1; j >= 1; j--) {\\n                dp[j] = dp[j] + dp[j-1];\\n            }\\n        }\\n        return dp;\\n    }\\n```\\n\\n# Optimal (beats 100% / 99.19%)\\nBased on fact :\\nSince 4C1 = 4/1 ,  4C2 = 4  *3/1  *2  ,  4C3 = 4*3  *2 /1*2  *3\\nLet up = 4,  down = 1 And we can observe that \\n4C1 = up/down\\n4C2 = 4C1 *[ (up-1) / (down+1) ]\\n......\\n```\\n\\tvector<int> getRow(int n) {\\n        vector<int> res(n+1);\\n        res[0] = res[n] = 1;\\n        long temp = 1;\\n        int up = n, down = 1;\\n        for(int i = 1; i < n; i++) {\\n            temp = temp * up /down;\\n            res[i] = temp;\\n            up--;down++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tvector<int> getRow(int rowIndex) {\\n        vector<int> dp(rowIndex+1, 1);\\n        if(rowIndex <= 1) return dp;\\n        vector<int> temp = dp;\\n        for(int i = 2; i <= rowIndex; i++) {\\n            for(int j = 1; j < i; j++) {\\n                temp[j] = dp[j] + dp[j-1];\\n            }\\n            dp = temp;\\n        }\\n        return dp;\\n    }\\n```\n```\\n\\tvector<int> getRow(int rowIndex) {\\n        vector<int> dp(rowIndex+1, 1);\\n        if(rowIndex <= 1) return dp;\\n        for(int i = 2; i <= rowIndex; i++) {\\n            for(int j = i-1; j >= 1; j--) {\\n                dp[j] = dp[j] + dp[j-1];\\n            }\\n        }\\n        return dp;\\n    }\\n```\n```\\n\\tvector<int> getRow(int n) {\\n        vector<int> res(n+1);\\n        res[0] = res[n] = 1;\\n        long temp = 1;\\n        int up = n, down = 1;\\n        for(int i = 1; i < n; i++) {\\n            temp = temp * up /down;\\n            res[i] = temp;\\n            up--;down++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 38629,
                "title": "my-simple-python-solution",
                "content": "    class Solution(object):\\n        def getRow(self, rowIndex):\\n            row = [1]\\n            for i in range(1, rowIndex + 1):\\n                row = [1] + [ row[x] + row[x - 1] for x in range(1, i)] + [1]\\n            return row",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def getRow(self, rowIndex):\\n            row = [1]\\n            for i in range(1, rowIndex + 1):\\n                row = [1] + [ row[x] + row[x - 1] for x in range(1, i)] + [1]\\n            return row",
                "codeTag": "Java"
            },
            {
                "id": 787858,
                "title": "python-2-solution-using-combination-formula-o-n-o-n-beats-97-submission",
                "content": "When we\\'re talking about Pascal\\'s Triangle, we\\'re acctually discussing about grabbing a specific value, from a specific row.\\nFor example, when doing statistics, we often end up needing to compute \"nCk\" (Binomial Coefficients) which systematically resolve themselves to the \"Kth value of the Nth row of Pascal\\'s Triangle\".\\nThe default algorithm for this is:\\n![image](https://assets.leetcode.com/users/images/9e77ced7-6cc5-47bc-b60b-32ccd72e0c68_1597242485.9083786.png)\\nWe can improve this calculation by using Combination Formula:\\n\\n***C(n,k+1) = C(n,k)  (n-k) / (k+1)***\\n\\n#### **Implemention:**\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        triangle = [1]\\n        \\n        for i in range(1, rowIndex + 1):\\n            triangle.append(int(triangle[i - 1] * (rowIndex - (i - 1)) / i))\\n        \\n        return triangle\\n```\\n\\nThere\\'s some things we can do to above function to improve it\\'s execution time.\\n* We don\\'t need to compute the full row, it mirrors itself at the center. So, we only need to compute the first half.\\n* We shouldn\\'t be calling append in the inner loop so many times. Instead of this we can pre-allocate the full row in one call, and index into it as we need.\\n\\n#### **Implemention:**\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        triangle = [0] * (rowIndex + 1)\\n        triangle[0] = triangle[rowIndex] = 1\\n        \\n        for i in range(0, rowIndex >> 1):\\n            col_val = triangle[ i ] * (rowIndex - i) / (i + 1)\\n            triangle[i + 1]= triangle[rowIndex - 1 - i] = int(col_val)\\n\\n        return triangle\\n```\\n **Study:**\\n [Pascal\\'s Triangle - Wiki Pedia](https://en.wikipedia.org/wiki/Pascal\\'s_triangle)\\n [Pascal\\'s Triangle - Math World](https://mathworld.wolfram.com/PascalsTriangle.html)\\n [Binomial Coefficients](https://mathworld.wolfram.com/BinomialCoefficient.html)\\n \\nPlease feel free to ans any question and give suggestions.\\n***If you like this solutions then please upvote it.***",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        triangle = [1]\\n        \\n        for i in range(1, rowIndex + 1):\\n            triangle.append(int(triangle[i - 1] * (rowIndex - (i - 1)) / i))\\n        \\n        return triangle\\n```\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        triangle = [0] * (rowIndex + 1)\\n        triangle[0] = triangle[rowIndex] = 1\\n        \\n        for i in range(0, rowIndex >> 1):\\n            col_val = triangle[ i ] * (rowIndex - i) / (i + 1)\\n            triangle[i + 1]= triangle[rowIndex - 1 - i] = int(col_val)\\n\\n        return triangle\\n```",
                "codeTag": "Java"
            },
            {
                "id": 38586,
                "title": "c-4-lines-solution-using-math-6-lines-solution-using-for-loop-both-0ms",
                "content": "     \\n\\n Based on math, the kth element for nth row is C(n, k) = n! / (k!*(n-k)!),  then res[k] = res[n - k]\\n \\n\\n so the relationship between res[i] and res[i-1] is  n! / (k!*(n-k)!) / n! **/** ((k-1)!*(n-k + 1)!) = (n - k + 1) / k;\\n   \\n\\n     vector<int> getRow(int rowIndex) {\\n       vector<int> res(rowIndex + 1, 1);\\n       for(int k = 1; k <= (rowIndex + 1)/2; k++)\\n            res[k] = res[rowIndex - k] = (long)res[k - 1]*(long)(rowIndex - k + 1)/k;\\n       return res;\\n    }\\n\\n   // normal loop \\n\\n    vector<int> getRow(int rowIndex) {\\n        vector<int> res;\\n        for (int i = 0; i <= rowIndex; i++) {\\n            res.push_back(1);\\n            for (int j = i - 1; j >= 1; --j) res[j] = res[j] + res[j-1];\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "     \\n\\n Based on math, the kth element for nth row is C(n, k) = n! / (k!*(n-k)!),  then res[k] = res[n - k]\\n \\n\\n so the relationship between res[i] and res[i-1] is  n! / (k!*(n-k)!) / n! **/** ((k-1)!*(n-k + 1)!) = (n - k + 1) / k;\\n   \\n\\n     vector<int> getRow(int rowIndex) {\\n       vector<int> res(rowIndex + 1, 1);\\n       for(int k = 1; k <= (rowIndex + 1)/2; k++)\\n            res[k] = res[rowIndex - k] = (long)res[k - 1]*(long)(rowIndex - k + 1)/k;\\n       return res;\\n    }\\n\\n   // normal loop \\n\\n    vector<int> getRow(int rowIndex) {\\n        vector<int> res;\\n        for (int i = 0; i <= rowIndex; i++) {\\n            res.push_back(1);\\n            for (int j = i - 1; j >= 1; --j) res[j] = res[j] + res[j-1];\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 38444,
                "title": "here-is-my-o-n-solution-and-the-proof",
                "content": "the mth element of  the nth row of the Pascal's triangle is C(n, m) = n!/(m! * (n-m)!)\\n\\nC(n, m-1) = n!/((m-1)! * (n-m+1)!)\\n\\nso C(n, m) = C(n, m-1) * (n-m+1) / m\\n\\nIn additional, C(n, m) == C(n, n-m)\\n\\n      class Solution {\\n        public:\\n            vector<int> getRow(int rowIndex) {\\n                vector<int> row;\\n                if(rowIndex < 0) {\\n                \\treturn row;\\n                }\\n                row.resize(rowIndex + 1);\\n                row[0] = row[rowIndex] = 1;\\n                for(int m =1; m < rowIndex /2 + 1; m++) {\\n                \\trow[m] = row[rowIndex - m] = ((long long int)row[m - 1] * (rowIndex - m + 1)) / m;\\n                }\\n                return row;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            vector<int> getRow(int rowIndex) {\\n                vector<int> row;\\n                if(rowIndex < 0) {\\n                \\treturn row;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 787212,
                "title": "python-two-o-k-memory-oneliners-explained",
                "content": "### Solution 1\\n\\nWhat we need to do in this problem is to follow definition. Let us generate row `r` and do `k` iterations until we reached desired `k`-tho row. How we generate next row, using current? We need:\\n1. Add `1` to the beginning of new row.\\n2. Evaluate sums of elements with indexes differ by `1`.\\n3. Add `1` to the end of new row.\\n\\nThis can be written as `[1]+[r[j]+r[j+1] for j in range(len(r)-1)]+[1]`.\\n\\nWhat we need to do now is to repeat this `k` times and this is all, we can use `reduce` function to do it.\\n\\n**Complexity**: space complexity as it asked is only `O(k)`, each moment of time we have only one(two) rows. Time complexity is `O(k^2)` because for each row we do `k` iterations. Theoretically time complexity can be reduced to `O(k)` if we use direct formulas for elements of pascal triangle, but `k` is very small and there will no be difference in this problem.\\n\\n```\\nclass Solution:\\n    def getRow(self, rowIndex):\\n        return reduce(lambda r,_:[1]+[r[j]+r[j+1] for j in range(len(r)-1)]+[1], range(rowIndex),[1])\\n```\\n\\n### Solution 2\\n\\nLet us note, that `1001^5 = 1 005 010 010 005 001`, so if we want to find row of Pascal triangle for small numbers `k`, then we can just use power of number `1000...001` and then split it into parts. For thes problem it is enough to take `10000000001` and then split by blocks with size `10`. \\n\\n**Complexity**: Space complexity is also `O(k)`, but more like `O(10k)`, because we have string of length `10k` in the end. Time complexity is more difficult to compute, I think it is `O(k)` also.\\n\\n```\\nclass Solution:\\n    def getRow(self, k):\\n        return [1] + [int(str((10**10+1)**k)[-10*(i+1):-10*i]) for i in range(1,k+1)]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex):\\n        return reduce(lambda r,_:[1]+[r[j]+r[j+1] for j in range(len(r)-1)]+[1], range(rowIndex),[1])\\n```\n```\\nclass Solution:\\n    def getRow(self, k):\\n        return [1] + [int(str((10**10+1)**k)[-10*(i+1):-10*i]) for i in range(1,k+1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 712268,
                "title": "python-easy-to-read-recursion",
                "content": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        row = [1] * (rowIndex+1)\\n        if rowIndex == 0: return row\\n        prev_row = self.getRow(rowIndex-1)\\n        for i in range(1, len(row)-1):\\n            row[i] = prev_row[i-1] + prev_row[i]\\n        return row",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        row = [1] * (rowIndex+1)\\n        if rowIndex == 0: return row\\n        prev_row = self.getRow(rowIndex-1)\\n        for i in range(1, len(row)-1):\\n            row[i] = prev_row[i-1] + prev_row[i]\\n        return row",
                "codeTag": "Java"
            },
            {
                "id": 3527485,
                "title": "c-java-python-javascript-5-lines-of-code-easy-to-understand",
                "content": "# Intuition:\\nThis solution is based on Pascal\\'s Triangle, where each element in a row is the sum of the two elements directly above it. By initializing the row with 1s and then calculating each element based on the previous row, we can generate the desired row efficiently.\\n\\n# Approach:\\n1. Initialize a vector called row with rowIndex+1 elements, all of which are set to 1. This is the first row in Pascal\\'s Triangle.\\n2. Iterate through each row of Pascal\\'s Triangle up to and including the desired rowIndex. For each row:\\n   a. Starting from the second last element of the row, iterate backwards to the second element, and update each element as the sum of the two elements directly above it.\\n3. Return the final row.\\n\\n# Complexity:\\n- Time Complexity: O(rowIndex^2)\\n    - The outer loop runs rowIndex times, and the inner loop runs i-1 times for each i, resulting in a total of 1+2+3+...+rowIndex = rowIndex*(rowIndex+1)/2 iterations. Since this is O(rowIndex^2), the time complexity of the algorithm is O(rowIndex^2).\\n\\n- Space Complexity: O(rowIndex)\\n    - The space complexity of the algorithm is O(rowIndex) since we only store a single row of Pascal\\'s Triangle at a time.\\n\\n---\\n# C++\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        // Initialize the row with 1s\\n        vector<int> row(rowIndex + 1, 1);  \\n        // Calculate each element of the row based on the previous row\\n        for (int i = 0; i <= rowIndex; ++i) {\\n            for (int j = i - 1; j > 0; --j) {\\n                row[j] = row[j] + row[j - 1];\\n            }\\n        }\\n        return row;\\n    }\\n};\\n```\\n\\n---\\n\\n# Java\\n```java\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        // Initialize the row with 1s\\n        List<Integer> row = new ArrayList<>(rowIndex + 1);  \\n        // Calculate each element of the row based on the previous row\\n        for (int i = 0; i <= rowIndex; ++i) {\\n            row.add(1);\\n            for (int j = i - 1; j > 0; --j) {\\n                row.set(j, row.get(j) + row.get(j - 1));\\n            }\\n        }\\n        return row;\\n    }\\n}\\n```\\n---\\n\\n# Python\\n```py\\nclass Solution(object):\\n    def getRow(self, rowIndex):\\n        # Initialize the row with 1s\\n        row = [1] * (rowIndex + 1) \\n        # Calculate each element of the row based on the previous row\\n        for i in range(rowIndex + 1):\\n            for j in range(i - 1, 0, -1):\\n                row[j] = row[j] + row[j - 1]\\n        return row\\n\\n```\\n---\\n\\n# JavaScript\\n```js\\nvar getRow = function(rowIndex) {\\n    // Initialize the row with 1s\\n    var row = new Array(rowIndex + 1).fill(1);  \\n    // Calculate each element of the row based on the previous row\\n    for (var i = 0; i <= rowIndex; ++i) {\\n        for (var j = i - 1; j > 0; --j) {\\n            row[j] = row[j] + row[j - 1];\\n        }\\n    }\\n    return row;\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Array"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        // Initialize the row with 1s\\n        vector<int> row(rowIndex + 1, 1);  \\n        // Calculate each element of the row based on the previous row\\n        for (int i = 0; i <= rowIndex; ++i) {\\n            for (int j = i - 1; j > 0; --j) {\\n                row[j] = row[j] + row[j - 1];\\n            }\\n        }\\n        return row;\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        // Initialize the row with 1s\\n        List<Integer> row = new ArrayList<>(rowIndex + 1);  \\n        // Calculate each element of the row based on the previous row\\n        for (int i = 0; i <= rowIndex; ++i) {\\n            row.add(1);\\n            for (int j = i - 1; j > 0; --j) {\\n                row.set(j, row.get(j) + row.get(j - 1));\\n            }\\n        }\\n        return row;\\n    }\\n}\\n```\n```py\\nclass Solution(object):\\n    def getRow(self, rowIndex):\\n        # Initialize the row with 1s\\n        row = [1] * (rowIndex + 1) \\n        # Calculate each element of the row based on the previous row\\n        for i in range(rowIndex + 1):\\n            for j in range(i - 1, 0, -1):\\n                row[j] = row[j] + row[j - 1]\\n        return row\\n\\n```\n```js\\nvar getRow = function(rowIndex) {\\n    // Initialize the row with 1s\\n    var row = new Array(rowIndex + 1).fill(1);  \\n    // Calculate each element of the row based on the previous row\\n    for (var i = 0; i <= rowIndex; ++i) {\\n        for (var j = i - 1; j > 0; --j) {\\n            row[j] = row[j] + row[j - 1];\\n        }\\n    }\\n    return row;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 467945,
                "title": "pythonic-o-k-space-sol-based-on-math-formula-90",
                "content": "[\\u4E2D\\u6587\\u89E3\\u984C\\u6587\\u7AE0](https://vocus.cc/new-editor/65124b7ffd89780001d7ff9e)\\n\\nPythonic O( k ) space sol. based on math formula\\n\\nReference:\\nhttps://en.wikipedia.org/wiki/Pascal\\'s_triangle\\n\\n```\\nfrom math import factorial\\n\\nclass Solution:\\n    \\n    def comb(self, n, m):\\n        \\n        if n == m or m == 0:\\n            return 1\\n        else:\\n            return factorial(n) // ( factorial(m) * factorial(n-m) )\\n\\n        \\n    def getRow(self, rowIndex: int) -> List[int]:\\n        \\n        # the coefficient of level k is as following\\n        #\\n        # C(k,0), C(k,1), ... , C(k,k)\\n        \\n        return [ self.comb(rowIndex,i) for i in range(0, rowIndex+1) ]\\n```\\n\\n---\\n\\nWatch the gif and observe the generation pattern could help a lot\\nhttps://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif\\n\\n\\nAnother **Implementation** by recursion:\\n\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        \\n        if rowIndex == 0:\\n            # Base case\\n            return [1]\\n        \\n        elif rowIndex == 1:\\n            # Base case\\n            return [1, 1]\\n        \\n        else:\\n            # General case:\\n            last_row = self.getRow( rowIndex-1 )\\n            size = len(last_row)\\n            return [ last_row[0] ] + [ last_row[idx] + last_row[idx+1] for idx in range( size-1) ] + [ last_row[-1] ]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nfrom math import factorial\\n\\nclass Solution:\\n    \\n    def comb(self, n, m):\\n        \\n        if n == m or m == 0:\\n            return 1\\n        else:\\n            return factorial(n) // ( factorial(m) * factorial(n-m) )\\n\\n        \\n    def getRow(self, rowIndex: int) -> List[int]:\\n        \\n        # the coefficient of level k is as following\\n        #\\n        # C(k,0), C(k,1), ... , C(k,k)\\n        \\n        return [ self.comb(rowIndex,i) for i in range(0, rowIndex+1) ]\\n```\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        \\n        if rowIndex == 0:\\n            # Base case\\n            return [1]\\n        \\n        elif rowIndex == 1:\\n            # Base case\\n            return [1, 1]\\n        \\n        else:\\n            # General case:\\n            last_row = self.getRow( rowIndex-1 )\\n            size = len(last_row)\\n            return [ last_row[0] ] + [ last_row[idx] + last_row[idx+1] for idx in range( size-1) ] + [ last_row[-1] ]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3122469,
                "title": "c-accepted-easy-explanation-0ms-beats-100",
                "content": "**Approach for Pascal\\'s Triangle II**\\n\\nTaking up the vector array upto the given index, i.e rowIndex.\\n=> push_back(1) to the array at each iteration.\\nBasic flow of calculating the given rowIndex of Pascal\\'s triangle\\uD83D\\uDC47.\\n\\n*First iteration*:\\n```\\n1 \\n```\\n*2nd iteration* :\\n``` \\n1,1 \\n```\\n*3rd iteration*\\n``` \\n1,1,1\\n1,2,1 <= final row\\n```\\n*4th iteration*\\n```\\n1,2,1,1\\n1,3,3,1 <= final row \\n```\\nHere what\\'s happening, we are pushing 1 to the previous row and then modifying it by changing the elements(except first and lastelement).\\nThe modification is => the value of the particular index eg. \\n``` \\n1,2,1,1=> {1,(1+2),(2+1),1} => {1,3,3,1} \\n```\\n``` \\n1,1,1=> {1,(1+1),1} => {1,2,1}\\n```\\n``` \\n1,3,3,1,1=> {1,(1+3),(3+3),(3+1),1} => {1,4,6,4,1}\\n```\\n\\n#### Here\\'s the whole code \\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n       vector<int> r;\\n       for(int i=0;i<=rowIndex;i++){\\n           r.push_back(1);\\n           for(int j=i-1;j>=1;--j){\\n               r[j]=r[j]+r[j-1];\\n           }\\n       }\\n       return r;\\n    }\\n};\\n```\\n### Please upvote if you liked the explaination :) thanks \\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n1 \\n```\n``` \\n1,1 \\n```\n``` \\n1,1,1\\n1,2,1 <= final row\\n```\n```\\n1,2,1,1\\n1,3,3,1 <= final row \\n```\n``` \\n1,2,1,1=> {1,(1+2),(2+1),1} => {1,3,3,1} \\n```\n``` \\n1,1,1=> {1,(1+1),1} => {1,2,1}\\n```\n``` \\n1,3,3,1,1=> {1,(1+3),(3+3),(3+1),1} => {1,4,6,4,1}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n       vector<int> r;\\n       for(int i=0;i<=rowIndex;i++){\\n           r.push_back(1);\\n           for(int j=i-1;j>=1;--j){\\n               r[j]=r[j]+r[j-1];\\n           }\\n       }\\n       return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040210,
                "title": "o-n-time-beats-99-97-memory-speed-0ms-may-2022",
                "content": "```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\npublic List<Integer> getRow(int rowIndex) {\\n    List<Integer> res = new ArrayList<Integer>();\\n    for(int i = 0;i<rowIndex+1;i++) {\\n    \\t\\tres.add(1);\\n    \\t\\tfor(int j=i-1;j>0;j--) {\\n    \\t\\t\\tres.set(j, res.get(j-1)+res.get(j));\\n    \\t\\t}\\n    }\\n    return res;\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\nvector<int> getRow(int rowIndex) {\\n\\tvector<int> ret { 1 }, cur { 1 };\\n\\tfor (int i = 1; i <= rowIndex; i++) {\\n\\t\\tret.push_back(1);\\n\\t\\tfor (int j = 1; j < i; j++) {\\n\\t\\t\\tret[j] = cur[j] + cur[j - 1];\\n\\t\\t}\\n\\t\\tcur = ret;\\n\\t}\\n\\treturn ret;\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        res=[]\\n        for i in range(rowIndex+1):\\n            res.append([])\\n            for j in range(i+1):\\n                if j == 0 or j == i:\\n                    res[i].append(1)\\n                else:\\n                    res[i].append(res[i - 1][j - 1] + res[i - 1][j])\\n        return res[rowIndex]\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nvar getRow = function(rowIndex) {\\n    return findRow([1], rowIndex);\\n};\\n\\nconst findRow = (arr, depth) => {\\n    if (arr.length - 1 === depth) return arr;\\n    \\n    const newArr = new Array(arr.length + 1);\\n    for (let i = 0; i < newArr.length; i++) {\\n        const l = arr[i - 1] || 0;\\n        const r = arr[i] || 0;\\n        newArr[i] = l + r;\\n    }\\n    \\n    return findRow(newArr, depth);\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\nclass Solution {\\n    fun getRow(rowIndex: Int): List<Int> {\\n        var initial = listOf<Int>(1)\\n        if (rowIndex == 0) return initial\\n        for (i in 0..rowIndex) {\\n            val current = mutableListOf<Int>(1)\\n            for (j in 1 until i) {\\n                current.add(initial[j] + initial[j-1])\\n            }\\n            current.add(1)\\n            initial = current\\n        }\\n        return initial\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(k), where k is the rowIndex.\\n    //   - space: O(k), where k is the rowIndex.\\n    \\n    func getRow(_ rowIndex: Int) -> [Int] {\\n        var row = Array(repeating: 0, count: rowIndex + 1)\\n\\t\\trow[0] = 1\\n\\t\\tvar index = 0\\n\\t\\t\\n        while index <= rowIndex {\\n\\t\\t\\tfor i in 0...index / 2 {\\n\\t\\t\\t\\tlet a = i > 0 ? row[i - 1] : 0\\n\\t\\t\\t\\tlet b = row[i]\\n\\t\\t\\t\\trow[index - i] = a + b\\n\\t\\t\\t}\\n\\t\\t\\t\\n            for i in 0...index / 2 {\\n\\t\\t\\t\\trow[i] = row[index - i]\\n\\t\\t\\t}\\n\\t\\t\\t\\n            index += 1\\n\\t\\t}\\n        \\n\\t\\treturn row\\n    }\\n\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\npublic List<Integer> getRow(int rowIndex) {\\n    List<Integer> res = new ArrayList<Integer>();\\n    for(int i = 0;i<rowIndex+1;i++) {\\n    \\t\\tres.add(1);\\n    \\t\\tfor(int j=i-1;j>0;j--) {\\n    \\t\\t\\tres.set(j, res.get(j-1)+res.get(j));\\n    \\t\\t}\\n    }\\n    return res;\\n}\\n```\n```\\n```\n```\\n```\n```\\nvector<int> getRow(int rowIndex) {\\n\\tvector<int> ret { 1 }, cur { 1 };\\n\\tfor (int i = 1; i <= rowIndex; i++) {\\n\\t\\tret.push_back(1);\\n\\t\\tfor (int j = 1; j < i; j++) {\\n\\t\\t\\tret[j] = cur[j] + cur[j - 1];\\n\\t\\t}\\n\\t\\tcur = ret;\\n\\t}\\n\\treturn ret;\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        res=[]\\n        for i in range(rowIndex+1):\\n            res.append([])\\n            for j in range(i+1):\\n                if j == 0 or j == i:\\n                    res[i].append(1)\\n                else:\\n                    res[i].append(res[i - 1][j - 1] + res[i - 1][j])\\n        return res[rowIndex]\\n```\n```\\n```\n```\\n```\n```\\nvar getRow = function(rowIndex) {\\n    return findRow([1], rowIndex);\\n};\\n\\nconst findRow = (arr, depth) => {\\n    if (arr.length - 1 === depth) return arr;\\n    \\n    const newArr = new Array(arr.length + 1);\\n    for (let i = 0; i < newArr.length; i++) {\\n        const l = arr[i - 1] || 0;\\n        const r = arr[i] || 0;\\n        newArr[i] = l + r;\\n    }\\n    \\n    return findRow(newArr, depth);\\n};\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    fun getRow(rowIndex: Int): List<Int> {\\n        var initial = listOf<Int>(1)\\n        if (rowIndex == 0) return initial\\n        for (i in 0..rowIndex) {\\n            val current = mutableListOf<Int>(1)\\n            for (j in 1 until i) {\\n                current.add(initial[j] + initial[j-1])\\n            }\\n            current.add(1)\\n            initial = current\\n        }\\n        return initial\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(k), where k is the rowIndex.\\n    //   - space: O(k), where k is the rowIndex.\\n    \\n    func getRow(_ rowIndex: Int) -> [Int] {\\n        var row = Array(repeating: 0, count: rowIndex + 1)\\n\\t\\trow[0] = 1\\n\\t\\tvar index = 0\\n\\t\\t\\n        while index <= rowIndex {\\n\\t\\t\\tfor i in 0...index / 2 {\\n\\t\\t\\t\\tlet a = i > 0 ? row[i - 1] : 0\\n\\t\\t\\t\\tlet b = row[i]\\n\\t\\t\\t\\trow[index - i] = a + b\\n\\t\\t\\t}\\n\\t\\t\\t\\n            for i in 0...index / 2 {\\n\\t\\t\\t\\trow[i] = row[index - i]\\n\\t\\t\\t}\\n\\t\\t\\t\\n            index += 1\\n\\t\\t}\\n        \\n\\t\\treturn row\\n    }\\n\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1831889,
                "title": "java-simple-detailed-explanation-runtime-0-ms-100-faster",
                "content": "# **Please upvote if you like the solution **\\n\\n```\\nclass Solution {\\n    \\n    /***\\n     *  Lets take example for the below triangle\\n     *\\n     *          1   ------------> Row 0\\n     *        1   1  -----------> Row 1\\n     *       1  2  1  ----------> Row 2\\n     *     1  3  3  1  ---------> Row 3\\n     *    1  4  6  4  1  -------> Row 4\\n     *\\n     *\\n     *    Each of the position can be represented as nCj  (n = row number and j = column number)\\n     *\\n     *                   0c0   ------------> Row 0\\n     *               1c0    1c1  -----------> Row 1\\n     *            2c0   2c1     2c2  ----------> Row 2\\n     *        3c0    3c1    3c2    3c3  ---------> Row 3\\n     *    4c0    4c1    4c2    4c3     4c4  -------> Row 4\\n     *\\n     *   Formula of  NcR = N! / (N - R)! * R!\\n     *\\n     *   Note :  Nc0 >> 1  &   NcN >> 1\\n     *\\n     *   Suppose we have to get the 4th Row\\n     *                              4c0    4c1    4c2    4c3     4c4  -------> Row 4\\n     * This can be represented as : NcR   NcR+1  NcR+2  NcR+3   NcR+4\\n     *\\n     * Properties of combination :  NcR * factor = NcR+1 now if we can figure out the value of factor we can make the whole row.\\n     *\\n     *         n!                         n!\\n     *     ------------ * factor =  ---------------------------\\n     *     (n-r)! * r!                (n - (r+1))! * (r+1)!\\n     *\\n     *                   (n-r)! * r!                      (n-r) *  (n-r-1)!         n - r\\n     *     factor = ----------------------------  =   ------------------------- = ----------\\n     *                (n - r - 1)! * (r+1) * r!            (n - r - 1)! * (r+1)     r + 1\\n     *\\n     *\\n     *    So, the value of factor = (n - r) / ( r + 1)\\n     *\\n     *    With this we can compute the factor and get the next value\\n     */\\n    public List<Integer> getRow(int i) {\\n\\n        List<Integer> result = new ArrayList<>();\\n        long val = 1;\\n\\n        for (int j = 0; j <= i; j++) {\\n            result.add((int) val);\\n            val = val * (i - j) / (j + 1);\\n        }\\n        return result;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    /***\\n     *  Lets take example for the below triangle\\n     *\\n     *          1   ------------> Row 0\\n     *        1   1  -----------> Row 1\\n     *       1  2  1  ----------> Row 2\\n     *     1  3  3  1  ---------> Row 3\\n     *    1  4  6  4  1  -------> Row 4\\n     *\\n     *\\n     *    Each of the position can be represented as nCj  (n = row number and j = column number)\\n     *\\n     *                   0c0   ------------> Row 0\\n     *               1c0    1c1  -----------> Row 1\\n     *            2c0   2c1     2c2  ----------> Row 2\\n     *        3c0    3c1    3c2    3c3  ---------> Row 3\\n     *    4c0    4c1    4c2    4c3     4c4  -------> Row 4\\n     *\\n     *   Formula of  NcR = N! / (N - R)! * R!\\n     *\\n     *   Note :  Nc0 >> 1  &   NcN >> 1\\n     *\\n     *   Suppose we have to get the 4th Row\\n     *                              4c0    4c1    4c2    4c3     4c4  -------> Row 4\\n     * This can be represented as : NcR   NcR+1  NcR+2  NcR+3   NcR+4\\n     *\\n     * Properties of combination :  NcR * factor = NcR+1 now if we can figure out the value of factor we can make the whole row.\\n     *\\n     *         n!                         n!\\n     *     ------------ * factor =  ---------------------------\\n     *     (n-r)! * r!                (n - (r+1))! * (r+1)!\\n     *\\n     *                   (n-r)! * r!                      (n-r) *  (n-r-1)!         n - r\\n     *     factor = ----------------------------  =   ------------------------- = ----------\\n     *                (n - r - 1)! * (r+1) * r!            (n - r - 1)! * (r+1)     r + 1\\n     *\\n     *\\n     *    So, the value of factor = (n - r) / ( r + 1)\\n     *\\n     *    With this we can compute the factor and get the next value\\n     */\\n    public List<Integer> getRow(int i) {\\n\\n        List<Integer> result = new ArrayList<>();\\n        long val = 1;\\n\\n        for (int j = 0; j <= i; j++) {\\n            result.add((int) val);\\n            val = val * (i - j) / (j + 1);\\n        }\\n        return result;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 912234,
                "title": "o-1",
                "content": "JUST FOR FUN! lol\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        return [[1], \\n        [1, 1], \\n        [1, 2, 1], \\n        [1, 3, 3, 1], \\n        [1, 4, 6, 4, 1], \\n        [1, 5, 10, 10, 5, 1], \\n        [1, 6, 15, 20, 15, 6, 1], \\n        [1, 7, 21, 35, 35, 21, 7, 1], \\n        [1, 8, 28, 56, 70, 56, 28, 8, 1], \\n        [1, 9, 36, 84, 126, 126, 84, 36, 9, 1], \\n        [1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1], \\n        [1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1], \\n        [1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1], \\n        [1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1], \\n        [1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1], \\n        [1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1], \\n        [1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1], \\n        [1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1], \\n        [1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1], \\n        [1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1], \\n        [1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1], \\n        [1, 21, 210, 1330, 5985, 20349, 54264, 116280, 203490, 293930, 352716, 352716, 293930, 203490, 116280, 54264, 20349, 5985, 1330, 210, 21, 1], \\n        [1, 22, 231, 1540, 7315, 26334, 74613, 170544, 319770, 497420, 646646, 705432, 646646, 497420, 319770, 170544, 74613, 26334, 7315, 1540, 231, 22, 1], \\n        [1, 23, 253, 1771, 8855, 33649, 100947, 245157, 490314, 817190, 1144066, 1352078, 1352078, 1144066, 817190, 490314, 245157, 100947, 33649, 8855, 1771, 253, 23, 1], \\n        [1, 24, 276, 2024, 10626, 42504, 134596, 346104, 735471, 1307504, 1961256, 2496144, 2704156, 2496144, 1961256, 1307504, 735471, 346104, 134596, 42504, 10626, 2024, 276, 24, 1], \\n        [1, 25, 300, 2300, 12650, 53130, 177100, 480700, 1081575, 2042975, 3268760, 4457400, 5200300, 5200300, 4457400, 3268760, 2042975, 1081575, 480700, 177100, 53130, 12650, 2300, 300, 25, 1], \\n        [1, 26, 325, 2600, 14950, 65780, 230230, 657800, 1562275, 3124550, 5311735, 7726160, 9657700, 10400600, 9657700, 7726160, 5311735, 3124550, 1562275, 657800, 230230, 65780, 14950, 2600, 325, 26, 1], \\n        [1, 27, 351, 2925, 17550, 80730, 296010, 888030, 2220075, 4686825, 8436285, 13037895, 17383860, 20058300, 20058300, 17383860, 13037895, 8436285, 4686825, 2220075, 888030, 296010, 80730, 17550, 2925, 351, 27, 1], \\n        [1, 28, 378, 3276, 20475, 98280, 376740, 1184040, 3108105, 6906900, 13123110, 21474180, 30421755, 37442160, 40116600, 37442160, 30421755, 21474180, 13123110, 6906900, 3108105, 1184040, 376740, 98280, 20475, 3276, 378, 28, 1], \\n        [1, 29, 406, 3654, 23751, 118755, 475020, 1560780, 4292145, 10015005, 20030010, 34597290, 51895935, 67863915, 77558760, 77558760, 67863915, 51895935, 34597290, 20030010, 10015005, 4292145, 1560780, 475020, 118755, 23751, 3654, 406, 29, 1], \\n        [1, 30, 435, 4060, 27405, 142506, 593775, 2035800, 5852925, 14307150, 30045015, 54627300, 86493225, 119759850, 145422675, 155117520, 145422675, 119759850, 86493225, 54627300, 30045015, 14307150, 5852925, 2035800, 593775, 142506, 27405, 4060, 435, 30, 1], \\n        [1, 31, 465, 4495, 31465, 169911, 736281, 2629575, 7888725, 20160075, 44352165, 84672315, 141120525, 206253075, 265182525, 300540195, 300540195, 265182525, 206253075, 141120525, 84672315, 44352165, 20160075, 7888725, 2629575, 736281, 169911, 31465, 4495, 465, 31, 1], \\n        [1, 32, 496, 4960, 35960, 201376, 906192, 3365856, 10518300, 28048800, 64512240, 129024480, 225792840, 347373600, 471435600, 565722720, 601080390, 565722720, 471435600, 347373600, 225792840, 129024480, 64512240, 28048800, 10518300, 3365856, 906192, 201376, 35960, 4960, 496, 32, 1], \\n        [1, 33, 528, 5456, 40920, 237336, 1107568, 4272048, 13884156, 38567100, 92561040, 193536720, 354817320, 573166440, 818809200, 1037158320, 1166803110, 1166803110, 1037158320, 818809200, 573166440, 354817320, 193536720, 92561040, 38567100, 13884156, 4272048, 1107568, 237336, 40920, 5456, 528, 33, 1]][rowIndex]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        return [[1], \\n        [1, 1], \\n        [1, 2, 1], \\n        [1, 3, 3, 1], \\n        [1, 4, 6, 4, 1], \\n        [1, 5, 10, 10, 5, 1], \\n        [1, 6, 15, 20, 15, 6, 1], \\n        [1, 7, 21, 35, 35, 21, 7, 1], \\n        [1, 8, 28, 56, 70, 56, 28, 8, 1], \\n        [1, 9, 36, 84, 126, 126, 84, 36, 9, 1], \\n        [1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1], \\n        [1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1], \\n        [1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1], \\n        [1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1], \\n        [1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1], \\n        [1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1], \\n        [1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1], \\n        [1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1], \\n        [1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1], \\n        [1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1], \\n        [1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1], \\n        [1, 21, 210, 1330, 5985, 20349, 54264, 116280, 203490, 293930, 352716, 352716, 293930, 203490, 116280, 54264, 20349, 5985, 1330, 210, 21, 1], \\n        [1, 22, 231, 1540, 7315, 26334, 74613, 170544, 319770, 497420, 646646, 705432, 646646, 497420, 319770, 170544, 74613, 26334, 7315, 1540, 231, 22, 1], \\n        [1, 23, 253, 1771, 8855, 33649, 100947, 245157, 490314, 817190, 1144066, 1352078, 1352078, 1144066, 817190, 490314, 245157, 100947, 33649, 8855, 1771, 253, 23, 1], \\n        [1, 24, 276, 2024, 10626, 42504, 134596, 346104, 735471, 1307504, 1961256, 2496144, 2704156, 2496144, 1961256, 1307504, 735471, 346104, 134596, 42504, 10626, 2024, 276, 24, 1], \\n        [1, 25, 300, 2300, 12650, 53130, 177100, 480700, 1081575, 2042975, 3268760, 4457400, 5200300, 5200300, 4457400, 3268760, 2042975, 1081575, 480700, 177100, 53130, 12650, 2300, 300, 25, 1], \\n        [1, 26, 325, 2600, 14950, 65780, 230230, 657800, 1562275, 3124550, 5311735, 7726160, 9657700, 10400600, 9657700, 7726160, 5311735, 3124550, 1562275, 657800, 230230, 65780, 14950, 2600, 325, 26, 1], \\n        [1, 27, 351, 2925, 17550, 80730, 296010, 888030, 2220075, 4686825, 8436285, 13037895, 17383860, 20058300, 20058300, 17383860, 13037895, 8436285, 4686825, 2220075, 888030, 296010, 80730, 17550, 2925, 351, 27, 1], \\n        [1, 28, 378, 3276, 20475, 98280, 376740, 1184040, 3108105, 6906900, 13123110, 21474180, 30421755, 37442160, 40116600, 37442160, 30421755, 21474180, 13123110, 6906900, 3108105, 1184040, 376740, 98280, 20475, 3276, 378, 28, 1], \\n        [1, 29, 406, 3654, 23751, 118755, 475020, 1560780, 4292145, 10015005, 20030010, 34597290, 51895935, 67863915, 77558760, 77558760, 67863915, 51895935, 34597290, 20030010, 10015005, 4292145, 1560780, 475020, 118755, 23751, 3654, 406, 29, 1], \\n        [1, 30, 435, 4060, 27405, 142506, 593775, 2035800, 5852925, 14307150, 30045015, 54627300, 86493225, 119759850, 145422675, 155117520, 145422675, 119759850, 86493225, 54627300, 30045015, 14307150, 5852925, 2035800, 593775, 142506, 27405, 4060, 435, 30, 1], \\n        [1, 31, 465, 4495, 31465, 169911, 736281, 2629575, 7888725, 20160075, 44352165, 84672315, 141120525, 206253075, 265182525, 300540195, 300540195, 265182525, 206253075, 141120525, 84672315, 44352165, 20160075, 7888725, 2629575, 736281, 169911, 31465, 4495, 465, 31, 1], \\n        [1, 32, 496, 4960, 35960, 201376, 906192, 3365856, 10518300, 28048800, 64512240, 129024480, 225792840, 347373600, 471435600, 565722720, 601080390, 565722720, 471435600, 347373600, 225792840, 129024480, 64512240, 28048800, 10518300, 3365856, 906192, 201376, 35960, 4960, 496, 32, 1], \\n        [1, 33, 528, 5456, 40920, 237336, 1107568, 4272048, 13884156, 38567100, 92561040, 193536720, 354817320, 573166440, 818809200, 1037158320, 1166803110, 1166803110, 1037158320, 818809200, 573166440, 354817320, 193536720, 92561040, 38567100, 13884156, 4272048, 1107568, 237336, 40920, 5456, 528, 33, 1]][rowIndex]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3190206,
                "title": "single-loop-solution-with-concise-explanation-c-maths-magic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPascal triangle rows can be defined as combinations nCr.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```\\n//           n!\\n// nCr = -----------\\n//        r!.(n-r)!\\n\\n//                  n!\\n// nC(r-1) = -----------------\\n//            (r-1)!.(n-r+1)!\\n\\n//                     n!        (r-1)!x(n-r+1)!\\n// nCr / nC(r-1) = ----------- x ---------------\\n//                  r!.(n-r)!          n!\\n\\n//                 (n-r+1)\\n//               = -------\\n//                    r\\n\\n// nC0 = 1\\n// nCr = nC(r-1) x (n-r+1) / r\\n```\\n\\n# Complexity\\n- Time complexity: $$O(1)$$ ``` because n <= 33```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int n) {\\n        vector<int> vec(n+1, 1);\\n        long long int temp = 1;\\n        for(int i = 1; i < n; i++) {\\n            temp = temp * (n-i+1) / i;\\n            vec[i] = temp;\\n        } return vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//           n!\\n// nCr = -----------\\n//        r!.(n-r)!\\n\\n//                  n!\\n// nC(r-1) = -----------------\\n//            (r-1)!.(n-r+1)!\\n\\n//                     n!        (r-1)!x(n-r+1)!\\n// nCr / nC(r-1) = ----------- x ---------------\\n//                  r!.(n-r)!          n!\\n\\n//                 (n-r+1)\\n//               = -------\\n//                    r\\n\\n// nC0 = 1\\n// nCr = nC(r-1) x (n-r+1) / r\\n```\n``` because n <= 33```\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int n) {\\n        vector<int> vec(n+1, 1);\\n        long long int temp = 1;\\n        for(int i = 1; i < n; i++) {\\n            temp = temp * (n-i+1) / i;\\n            vec[i] = temp;\\n        } return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932131,
                "title": "100-fastest-swift-solution-time-o-k-space-o-k",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(k), where k is the rowIndex.\\n    //   - space: O(k), where k is the rowIndex.\\n    \\n    func getRow(_ rowIndex: Int) -> [Int] {\\n        var row = Array(repeating: 0, count: rowIndex + 1)\\n\\t\\trow[0] = 1\\n\\t\\tvar index = 0\\n\\t\\t\\n        while index <= rowIndex {\\n\\t\\t\\tfor i in 0...index / 2 {\\n\\t\\t\\t\\tlet a = i > 0 ? row[i - 1] : 0\\n\\t\\t\\t\\tlet b = row[i]\\n\\t\\t\\t\\trow[index - i] = a + b\\n\\t\\t\\t}\\n\\t\\t\\t\\n            for i in 0...index / 2 {\\n\\t\\t\\t\\trow[i] = row[index - i]\\n\\t\\t\\t}\\n\\t\\t\\t\\n            index += 1\\n\\t\\t}\\n        \\n\\t\\treturn row\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(k), where k is the rowIndex.\\n    //   - space: O(k), where k is the rowIndex.\\n    \\n    func getRow(_ rowIndex: Int) -> [Int] {\\n        var row = Array(repeating: 0, count: rowIndex + 1)\\n\\t\\trow[0] = 1\\n\\t\\tvar index = 0\\n\\t\\t\\n        while index <= rowIndex {\\n\\t\\t\\tfor i in 0...index / 2 {\\n\\t\\t\\t\\tlet a = i > 0 ? row[i - 1] : 0\\n\\t\\t\\t\\tlet b = row[i]\\n\\t\\t\\t\\trow[index - i] = a + b\\n\\t\\t\\t}\\n\\t\\t\\t\\n            for i in 0...index / 2 {\\n\\t\\t\\t\\trow[i] = row[index - i]\\n\\t\\t\\t}\\n\\t\\t\\t\\n            index += 1\\n\\t\\t}\\n        \\n\\t\\treturn row\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2654390,
                "title": "python-clean-recursion-o-rowindex-space",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe idea here is to return the row at each index. Then use that row to build the next row on the next index.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ - n is rowIndex\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(k)$$ - k is rowIndex\\n# Code\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        if rowIndex == 0:\\n            return [1]\\n        prevRow = self.getRow(rowIndex - 1)\\n        currentRow = [1]\\n        for i in range(len(prevRow) - 1):\\n            currentRow.append(prevRow[i] + prevRow[i + 1])\\n        currentRow.append(1)\\n        return currentRow\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        if rowIndex == 0:\\n            return [1]\\n        prevRow = self.getRow(rowIndex - 1)\\n        currentRow = [1]\\n        for i in range(len(prevRow) - 1):\\n            currentRow.append(prevRow[i] + prevRow[i + 1])\\n        currentRow.append(1)\\n        return currentRow\\n```",
                "codeTag": "Java"
            },
            {
                "id": 311465,
                "title": "python-recursive-solution-95-42-time-91-63-memory",
                "content": "```\\ndef getRow(self, rowIndex: int) -> List[int]:\\n\\n\\tif rowIndex == 0:\\n\\t\\treturn [1]\\n\\n\\tif rowIndex == 1:\\n\\t\\treturn [1, 1]\\n\\n\\tprev = self.getRow(rowIndex - 1)\\n\\n\\tcur = [1] + [prev[i] + prev[i+1] for i in range(len(prev) - 1)] + [1]\\n\\n\\treturn cur\\n```\\n\\n\\nThe list comprehension is with time complexity of O(k). In the recursion, T(k) = O(k) + T(k-1), thus the time complexity would be O(k^2). \\n\\nThe space complexity would be O(k).",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\ndef getRow(self, rowIndex: int) -> List[int]:\\n\\n\\tif rowIndex == 0:\\n\\t\\treturn [1]\\n\\n\\tif rowIndex == 1:\\n\\t\\treturn [1, 1]\\n\\n\\tprev = self.getRow(rowIndex - 1)\\n\\n\\tcur = [1] + [prev[i] + prev[i+1] for i in range(len(prev) - 1)] + [1]\\n\\n\\treturn cur\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 38682,
                "title": "solution-based-on-mathematics",
                "content": "If anyone has ever learnt the mathematics equations related to the pascal triangle, they would know the following:\\n\\nThe nth row of pascal triangle will have the following format: 1 a(1) a(2) ... a(n)\\nhere we have a(1) = n; a(k+1) = a(k) * (n-k)/(k+1).\\n\\nHence, the following code is based on the above knowledge. However, there would be a test case that this solution won't work. Do you know any?\\n\\n    public class Solution {\\n        public List<Integer> getRow(int rowIndex) {\\n            List<Integer> results = new ArrayList<Integer>();\\n            \\n            if(rowIndex<0) return results;\\n            \\n            results.add(1);\\n            if(rowIndex == 0) return results;\\n            long pre = 1;\\n            for(int k = 0; k<rowIndex; k++){\\n                pre = pre * (rowIndex - k) / (k+1);\\n                results.add((int) pre);\\n            }\\n            \\n            return results;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> getRow(int rowIndex) {\\n            List<Integer> results = new ArrayList<Integer>();\\n            \\n            if(rowIndex<0) return results;\\n            \\n            results.add(1);\\n            if(rowIndex == 0) return results;\\n            long pre = 1;\\n            for(int k = 0; k<rowIndex; k++){\\n                pre = pre * (rowIndex - k) / (k+1);\\n                results.add((int) pre);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 38699,
                "title": "my-very-simple-c-solution",
                "content": "Basically, I will insert 1 at the head of vector each iteration and calculate result[j] based on result[j] and result[j+1].\\nFor example, if I want to get [1, 3, 3, 1] from [1, 2, 1], I will first insert 1 and get [1, 1, 2, 1].\\nThen begin with j = 1, result[j] = result[j] + result[j+1]. second position is 1+2=3, third position is 2+1=3\\nFinally we get [1, 3, 3, 1]\\n\\n\\n\\n    #include <vector>\\n    using namespace std;\\n    class Solution {\\n    public:\\n        vector<int> getRow(int rowIndex) {\\n            vector<int> result(1,1);\\n            for(int i=1;i<=rowIndex;i++){\\n                result.insert(result.begin(),1);\\n                for(int j=1;j<result.size()-1;j++){\\n                    result[j] = result[j] + result[j+1];\\n                }\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> getRow(int rowIndex) {\\n            vector<int> result(1,1);\\n            for(int i=1;i<=rowIndex;i++){\\n                result.insert(result.begin(),1);\\n                for(int j=1;j<result.size()-1;j++){\\n                    result[j] = result[j] + result[j+1];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1092502,
                "title": "fast-recursive-solution-for-beginners-for-understanding",
                "content": "Here\\'s how to do it recursively.\\n \\n```\\n class Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n\\t\\t# base cases\\n        if rowIndex < 2:\\n            return [1] * (rowIndex + 1)\\n        \\n\\t\\t# do recursive call to get to the base case\\n        prev_row = self.getRow(rowIndex - 1)\\n\\t\\t\\n\\t\\t# the recurrence relation\\n        new_row = [1] * (len(prev_row) + 1)\\n        for i in range(1, len(new_row)-1):\\n            new_row[i] = prev_row[i-1] + prev_row[i]\\n        \\n        return new_row\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n class Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n\\t\\t# base cases\\n        if rowIndex < 2:\\n            return [1] * (rowIndex + 1)\\n        \\n\\t\\t# do recursive call to get to the base case\\n        prev_row = self.getRow(rowIndex - 1)\\n\\t\\t\\n\\t\\t# the recurrence relation\\n        new_row = [1] * (len(prev_row) + 1)\\n        for i in range(1, len(new_row)-1):\\n            new_row[i] = prev_row[i-1] + prev_row[i]\\n        \\n        return new_row\\n```",
                "codeTag": "Java"
            },
            {
                "id": 38516,
                "title": "recursive-solution-java-3ms",
                "content": "```\\n    public List<Integer> getRow(int rowIndex) {\\n        if (rowIndex == 0) return Arrays.asList(1);\\n        List<Integer> previousList = getRow(rowIndex - 1);\\n        List<Integer> thisList = new ArrayList<>();\\n        for (int i =0; i < previousList.size(); i++) {\\n            if (i == 0) thisList.add(1);\\n            if (i > 0) thisList.add(previousList.get(i) + previousList.get(i-1));\\n            if (i == previousList.size() -1) thisList.add(1);\\n        }\\n        return thisList;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<Integer> getRow(int rowIndex) {\\n        if (rowIndex == 0) return Arrays.asList(1);\\n        List<Integer> previousList = getRow(rowIndex - 1);\\n        List<Integer> thisList = new ArrayList<>();\\n        for (int i =0; i < previousList.size(); i++) {\\n            if (i == 0) thisList.add(1);\\n            if (i > 0) thisList.add(previousList.get(i) + previousList.get(i-1));\\n            if (i == previousList.size() -1) thisList.add(1);\\n        }\\n        return thisList;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 38647,
                "title": "a-concise-7-line-java-solution-o-k",
                "content": "    public class Solution {\\n        public List<Integer> getRow(int rowIndex) {\\n            Integer[] ret = new Integer[rowIndex+1];\\n            Arrays.fill(ret, 0);       \\n            for (int i=0; i<= rowIndex; i++)\\n                for (int j=i; j>0; j--)\\n                    ret[j] = ret[j] + ret[j-1];\\n                ret[0] = 1;\\n            return Arrays.asList(ret);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Integer> getRow(int rowIndex) {\\n            Integer[] ret = new Integer[rowIndex+1];\\n            Arrays.fill(ret, 0);       \\n            for (int i=0; i<= rowIndex; i++)\\n                for (int j=i; j>0; j--)\\n                    ret[j] = ret[j] + ret[j-1];\\n                ret[0] = 1;\\n            return Arrays.asList(ret);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 38695,
                "title": "accepted-java-solution-using-recursion",
                "content": "    public class Solution {\\n        public List<Integer> getRow(int rowIndex) {\\n            if (rowIndex==0) {\\n                List<Integer> r = new ArrayList<Integer>();\\n                r.add(1);\\n                return r;\\n            } \\n            if (rowIndex==1) {\\n                List<Integer> r = new ArrayList<Integer>();\\n                r.add(1);\\n                r.add(1);\\n                return r;\\n            }\\n            List<Integer> oldRow = getRow(rowIndex-1);\\n            List<Integer> newRow = new ArrayList<Integer>();\\n            newRow.add(1);\\n            for(int i=0;i<oldRow.size()-1;i++) {\\n                newRow.add(oldRow.get(i)+oldRow.get(i+1));\\n            }\\n            newRow.add(1);\\n            return newRow;\\n            \\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public List<Integer> getRow(int rowIndex) {\\n            if (rowIndex==0) {\\n                List<Integer> r = new ArrayList<Integer>();\\n                r.add(1);\\n                return r;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3754774,
                "title": "simple-easy-to-understand-solution-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i=0; i<=rowIndex; i++){\\n            List<Integer> sum = new ArrayList<>();\\n            \\n            for(int j=0; j<=i; j++){\\n                if(j==0 || j==i){\\n                    sum.add(1);\\n                }\\n                else{\\n                    sum.add(ans.get(i-1).get(j-1)+ans.get(i-1).get(j));\\n                }\\n            }\\n            ans.add(sum);\\n        }\\n\\n        return ans.get(rowIndex);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i=0; i<=rowIndex; i++){\\n            List<Integer> sum = new ArrayList<>();\\n            \\n            for(int j=0; j<=i; j++){\\n                if(j==0 || j==i){\\n                    sum.add(1);\\n                }\\n                else{\\n                    sum.add(ans.get(i-1).get(j-1)+ans.get(i-1).get(j));\\n                }\\n            }\\n            ans.add(sum);\\n        }\\n\\n        return ans.get(rowIndex);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2644927,
                "title": "java-easy-solution-6-7-liner",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n      Integer arr[] = new Integer[rowIndex + 1];\\n      Arrays.fill(arr, 0);\\n      arr[0] = 1;\\n\\n      for(int i = 1; i <= rowIndex; i ++) {\\n          for(int j = i; j > 0; j --) {\\n              arr[j] = arr[j] + arr[j - 1];\\n          }\\n      }\\n      return Arrays.asList(arr);  \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL !",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n      Integer arr[] = new Integer[rowIndex + 1];\\n      Arrays.fill(arr, 0);\\n      arr[0] = 1;\\n\\n      for(int i = 1; i <= rowIndex; i ++) {\\n          for(int j = i; j > 0; j --) {\\n              arr[j] = arr[j] + arr[j - 1];\\n          }\\n      }\\n      return Arrays.asList(arr);  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2566040,
                "title": "python-beginner-friendly",
                "content": "Upvote if it helped. Thanks\\n\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        numRows = rowIndex+1\\n        l=[1]*numRows\\n        for i in range(numRows):\\n            l[i]=[1]*(i+1)\\n            for j in range(1,i):\\n                l[i][j]=l[i-1][j-1]+l[i-1][j]\\n        return l[rowIndex]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        numRows = rowIndex+1\\n        l=[1]*numRows\\n        for i in range(numRows):\\n            l[i]=[1]*(i+1)\\n            for j in range(1,i):\\n                l[i][j]=l[i-1][j-1]+l[i-1][j]\\n        return l[rowIndex]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1219048,
                "title": "c-faster-then-100-simple-to-understand",
                "content": "```\\n   vector<int> getRow(int rowIndex) {\\n     vector<vector<int>> pt;\\n     for(int i=0;i<=rowIndex;i++){\\n         vector<int>row(i+1,1);\\n         for(int j=1;j<i;j++)row[j]=pt[i-1][j-1]+pt[i-1][j];\\n         pt.push_back(row);\\n     }\\n     return pt[rowIndex];\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\n   vector<int> getRow(int rowIndex) {\\n     vector<vector<int>> pt;\\n     for(int i=0;i<=rowIndex;i++){\\n         vector<int>row(i+1,1);\\n         for(int j=1;j<i;j++)row[j]=pt[i-1][j-1]+pt[i-1][j];\\n         pt.push_back(row);\\n     }\\n     return pt[rowIndex];\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 562371,
                "title": "python-recursion-approach",
                "content": "```\\nclass Solution(object):\\n    def getRow(self, rowIndex):\\n        \"\"\"\\n        :type rowIndex: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if rowIndex == 0:\\n            return [1]\\n        lastRow = self.getRow(rowIndex-1)\\n        res = [1]\\n        for i in range(len(lastRow)-1):\\n            res.append(lastRow[i]+lastRow[i+1])\\n        res.append(1)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def getRow(self, rowIndex):\\n        \"\"\"\\n        :type rowIndex: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if rowIndex == 0:\\n            return [1]\\n        lastRow = self.getRow(rowIndex-1)\\n        res = [1]\\n        for i in range(len(lastRow)-1):\\n            res.append(lastRow[i]+lastRow[i+1])\\n        res.append(1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 471808,
                "title": "c-0ms-o-n",
                "content": "```\\nint* getRow(int rowIndex, int* returnSize){\\n    *returnSize = rowIndex + 1;\\n    \\n    int* ans = malloc(*returnSize * sizeof(int));\\n\\n    ans[0]        = 1;\\n    ans[rowIndex] = 1;\\n    \\n    for (int i = 1; i < rowIndex/2 + 1; ++i) {\\n        ans[i] = (long) ans[i - 1] * (rowIndex - i + 1) / i;       \\n        ans[rowIndex - i] = ans[i];\\n    }\\n    \\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint* getRow(int rowIndex, int* returnSize){\\n    *returnSize = rowIndex + 1;\\n    \\n    int* ans = malloc(*returnSize * sizeof(int));\\n\\n    ans[0]        = 1;\\n    ans[rowIndex] = 1;\\n    \\n    for (int i = 1; i < rowIndex/2 + 1; ++i) {\\n        ans[i] = (long) ans[i - 1] * (rowIndex - i + 1) / i;       \\n        ans[rowIndex - i] = ans[i];\\n    }\\n    \\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3308980,
                "title": "8-lines-dp-solution-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        res=[[1]]\\n        for i in range(rowIndex):\\n            temp=[0]+res[-1]+[0]\\n            row=[]\\n            for j in range(len(res[-1])+1):\\n                row.append(temp[j]+temp[j+1])\\n            res.append(row)\\n        return res[-1]\\n```\\n# plz consider upvoting\\n![4m44lc.jpg](https://assets.leetcode.com/users/images/34e4b956-8c38-499d-bbec-0dad1c9770e8_1679083370.333633.jpeg)\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        res=[[1]]\\n        for i in range(rowIndex):\\n            temp=[0]+res[-1]+[0]\\n            row=[]\\n            for j in range(len(res[-1])+1):\\n                row.append(temp[j]+temp[j+1])\\n            res.append(row)\\n        return res[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055911,
                "title": "c-java-100-solution-using-dynamic-programming-pascal-s-triangle-ii",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```Java []\\npublic class Solution {\\n    public List<Integer> getRow(int k) {\\n        Integer[] arr = new Integer[k + 1];\\n        Arrays.fill(arr, 0);\\n        arr[0] = 1;\\n        \\n        for (int i = 1; i <= k; i++) \\n            for (int j = i; j > 0; j--) \\n                arr[j] = arr[j] + arr[j - 1];\\n        \\n        return Arrays.asList(arr);\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<int> ansArray(rowIndex+1,0);\\n        ansArray[0] = 1;\\n        \\n        for (int i = 1; i <= rowIndex; i++) \\n            for (int j = i; j > 0; j--) \\n                ansArray[j] = ansArray[j] + ansArray[j - 1];\\n        \\n        return ansArray;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```Java []\\npublic class Solution {\\n    public List<Integer> getRow(int k) {\\n        Integer[] arr = new Integer[k + 1];\\n        Arrays.fill(arr, 0);\\n        arr[0] = 1;\\n        \\n        for (int i = 1; i <= k; i++) \\n            for (int j = i; j > 0; j--) \\n                arr[j] = arr[j] + arr[j - 1];\\n        \\n        return Arrays.asList(arr);\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<int> ansArray(rowIndex+1,0);\\n        ansArray[0] = 1;\\n        \\n        for (int i = 1; i <= rowIndex; i++) \\n            for (int j = i; j > 0; j--) \\n                ansArray[j] = ansArray[j] + ansArray[j - 1];\\n        \\n        return ansArray;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1606554,
                "title": "easy-python-solution",
                "content": "```\\nnumRows = rowIndex+1\\nres = [] \\nfor i in range(0,numRows):\\n        res.append([1]*(i+1))\\n       \\nfor i in range(numRows):\\n\\tfor j in range(1,i):\\n\\t\\tres[i][j] = res[i-1][j-1]+res[i-1][j]\\nreturn res[rowIndex]",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nnumRows = rowIndex+1\\nres = [] \\nfor i in range(0,numRows):\\n        res.append([1]*(i+1))\\n       \\nfor i in range(numRows):\\n\\tfor j in range(1,i):\\n\\t\\tres[i][j] = res[i-1][j-1]+res[i-1][j]\\nreturn res[rowIndex]",
                "codeTag": "Unknown"
            },
            {
                "id": 1532130,
                "title": "c-recursive-permutation-and-combinations",
                "content": "using the formula of permutation and combinations we will find that\\nat nth row we have [nCo,nC1,nC2..........nCn]\\nso only considering last line of pascal triangle \\n```class Solution {\\npublic:\\n    long double fact(int n){\\n        if(n<2)\\n            return 1;\\n        return n*fact(n-1);\\n    }\\n    vector<int> getRow(int i) {\\n        vector<int>ans;\\n         for(int j=0;j<=i;j++){\\n                double temp=(fact(i)/(fact(j)*fact(i-j)));\\n                ans.push_back(temp);\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```class Solution {\\npublic:\\n    long double fact(int n){\\n        if(n<2)\\n            return 1;\\n        return n*fact(n-1);\\n    }\\n    vector<int> getRow(int i) {\\n        vector<int>ans;\\n         for(int j=0;j<=i;j++){\\n                double temp=(fact(i)/(fact(j)*fact(i-j)));\\n                ans.push_back(temp);\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1378284,
                "title": "explanation-using-binomial-theorem-runtime-0-ms-memory-usage-36-4-mb-java",
                "content": "**What does every row of Pascal\\'s traingle represents?**\\nnth row represent coefficient of (1+x)^n. Let\\'s observe this\\n\\n0th row: (1+x)^0   = 1                                    = [1]\\n1st row: (1+x)^1   = 1 + x                              = [1, 1]\\n2nd row: (1+x)^2  = 1 + 2x + x^2                 = [1, 2, 1]\\n3rd row: (1+x)^3   = 1 + 3x  + 3x^2 + x^3    = [1, 3, 3, 1]\\nand so on..\\nWe just need to keep the values in increasing order of their power of x.\\n\\n**Binomial Theorem**\\nWe can use [binomial theorem](https://en.wikipedia.org/wiki/Binomial_theorem) to calculate (1+x)^n.\\n\\n\\n![image](https://assets.leetcode.com/users/images/9bb0fb39-bb0a-4099-8c55-d055157f324b_1627894981.7081034.png)\\n\\n\\nWe just need to calculate coefficient of above formula from left to right. First value is `1`, and if we compare any two consecutive values, then we can consume some caluclation from last coefficient in building a new coefficient. \\n\\nTry to find out that comman value in 2 consecutive coefficient.\\n\\n**Code:**\\n\\n```\\nclass Solution {\\n    public List<Integer> getRow(int n) {\\n        // nth row will contain n+1 numbers.\\n        List<Integer> ans = new ArrayList<>(n+1);\\n        \\n\\t\\t// First number will be always 1\\n        ans.add(1);\\n        \\n        long lastCoefficient = 1;\\n        int fact = 1;\\n        \\n\\t\\t// We have already fixed first number as 1, we need to calculate n more numbers\\n        for(int i = n; i >=1; i--) {\\n            lastCoefficient = (lastCoefficient * i)/fact;\\n            ans.add((int)lastCoefficient);\\n            fact++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> getRow(int n) {\\n        // nth row will contain n+1 numbers.\\n        List<Integer> ans = new ArrayList<>(n+1);\\n        \\n\\t\\t// First number will be always 1\\n        ans.add(1);\\n        \\n        long lastCoefficient = 1;\\n        int fact = 1;\\n        \\n\\t\\t// We have already fixed first number as 1, we need to calculate n more numbers\\n        for(int i = n; i >=1; i--) {\\n            lastCoefficient = (lastCoefficient * i)/fact;\\n            ans.add((int)lastCoefficient);\\n            fact++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 788355,
                "title": "pascal-s-triangle-ii-python-easy-solution-with-explanation-beats-98-96",
                "content": "Hints:\\n* Consider the triangle as a collection of rows and each row is a list of numbers where first and the last elements of a row is 1\\n* The number of additional elements in a row except the first and the last element is `length(previous_row) - 1`. For example, if you consider the image below where `row 3` has `[1,3,3,1]` and `row 2` has `[1,2,1]`. Therefore row 3 will have `length(row 2) - 1 = 3-1 = 2` additional numbers between first and the last element. \\n* These additional numbers have a sequence and it\\'s the sum of two numbers from the previous row. If you are looking for a number whose position is `i` in the current row then the resultant number would be `current_row[i] = previous_row[i] + previous_row[i-1]`. \\n* Since any given row can be generated from the immediate previous row, we do not need to store all rows except the current row.\\n* Finally return your current row and you are done :-)\\n![image](https://assets.leetcode.com/users/images/10f8a7b0-51d8-4bc1-99a7-3abe1c36899f_1597262380.3813298.png)\\n\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        row = []\\n\\t\\t\\n\\t\\t# add first 1\\n        row.append(1)\\n        \\n\\t\\tfor i in range(rowIndex):\\n\\t\\t\\t# compute additional numbers in between 1\\'s\\n\\t\\t\\t# iterate from right to left\\n            for j in range(i, 0, -1):\\n                row[j] = row[j-1] + row[j]\\n            \\n\\t\\t\\t# add last 1\\n            row.append(1)\\n            \\n        return row\\n```\\n\\nReference https://www.youtube.com/watch?v=tTYU4PAiqOE",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        row = []\\n\\t\\t\\n\\t\\t# add first 1\\n        row.append(1)\\n        \\n\\t\\tfor i in range(rowIndex):\\n\\t\\t\\t# compute additional numbers in between 1\\'s\\n\\t\\t\\t# iterate from right to left\\n            for j in range(i, 0, -1):\\n                row[j] = row[j-1] + row[j]\\n            \\n\\t\\t\\t# add last 1\\n            row.append(1)\\n            \\n        return row\\n```",
                "codeTag": "Java"
            },
            {
                "id": 375920,
                "title": "cleanest-js-solution",
                "content": "```\\n/**\\n * @param {number} rowIndex\\n * @return {number[]}\\n */\\nconst getRow = rowIndex => {\\n    const res = []\\n    \\n    while (res.length <= rowIndex) {\\n        res.unshift(1)\\n        for(let i = 1; i < res.length - 1; i++) {\\n            res[i] += res[i + 1]\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowIndex\\n * @return {number[]}\\n */\\nconst getRow = rowIndex => {\\n    const res = []\\n    \\n    while (res.length <= rowIndex) {\\n        res.unshift(1)\\n        for(let i = 1; i < res.length - 1; i++) {\\n            res[i] += res[i + 1]\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 311494,
                "title": "python-recursion",
                "content": "\\'\\'\\'\\n\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        if rowIndex == 0:\\n            return [1]\\n        output_pre = self.getRow(rowIndex-1)\\n        output = [1] * (rowIndex+1)\\n        for i in range(1, len(output)-1):\\n            output[i] = output_pre[i-1] + output_pre[i]\\n        return output\\n\\t\\t\\n\\'\\'\\'\\t\\t\\n\\npython recursive solution with time complexity of O(k^2), space complexity of O(k)",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        if rowIndex == 0:\\n            return [1]\\n        output_pre = self.getRow(rowIndex-1)\\n        output = [1] * (rowIndex+1)\\n        for i in range(1, len(output)-1):\\n            output[i] = output_pre[i-1] + output_pre[i]\\n        return output\\n\\t\\t\\n\\'\\'\\'\\t\\t\\n\\npython recursive solution with time complexity of O(k^2), space complexity of O(k)",
                "codeTag": "Python3"
            },
            {
                "id": 4065086,
                "title": "simple-java-solutions-runtime-2ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n         List<List<Integer>> list = new ArrayList<>();\\n        list.add(Arrays.asList(1));\\n\\n        for (int i = 1; i < rowIndex + 1; i++) {\\n            List<Integer> list1 = new LinkedList<>();\\n            list1.add(1);\\n            List<Integer> list2 = list.get(i-1);\\n\\n            for (int k = 0; k < list2.size() - 1 ; k++)\\n            {\\n                list1.add(list2.get(k) + list2.get(k+1));\\n            }\\n            list1.add(1);\\n\\n            list.add(list1);\\n        }\\n\\n\\n        return list.get(rowIndex);\\n    }\\n}\\n```\\n\\n![abcd1.jpeg](https://assets.leetcode.com/users/images/20cb17d7-a2a6-40f4-b950-61eb9393eacc_1695139685.6894486.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n         List<List<Integer>> list = new ArrayList<>();\\n        list.add(Arrays.asList(1));\\n\\n        for (int i = 1; i < rowIndex + 1; i++) {\\n            List<Integer> list1 = new LinkedList<>();\\n            list1.add(1);\\n            List<Integer> list2 = list.get(i-1);\\n\\n            for (int k = 0; k < list2.size() - 1 ; k++)\\n            {\\n                list1.add(list2.get(k) + list2.get(k+1));\\n            }\\n            list1.add(1);\\n\\n            list.add(list1);\\n        }\\n\\n\\n        return list.get(rowIndex);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324397,
                "title": "the-best-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<int> ans;\\n        ans.push_back(1);\\n        for(long i = 1; i <= rowIndex; i++) {\\n            ans.push_back((ans[i-1]*(rowIndex-i+1))/i);\\n        }      \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<int> ans;\\n        ans.push_back(1);\\n        for(long i = 1; i <= rowIndex; i++) {\\n            ans.push_back((ans[i-1]*(rowIndex-i+1))/i);\\n        }      \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765160,
                "title": "c-for-the-win",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<int> A(rowIndex+1, 0);\\n        A[0] = 1;\\n        for(int i=1; i<rowIndex+1; i++)\\n            for(int j=i; j>=1; j--)\\n                A[j] += A[j-1];\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<int> A(rowIndex+1, 0);\\n        A[0] = 1;\\n        for(int i=1; i<rowIndex+1; i++)\\n            for(int j=i; j>=1; j--)\\n                A[j] += A[j-1];\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612506,
                "title": "simple-python3-solution-easy-approach",
                "content": "**UPVOTE** if it is helpful\\n``` \\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        list1 = []\\n        for i in range(rowIndex+1):\\n            temp_list = []\\n            for j in range(i+1):\\n                if j==0 or j==i:\\n                    temp_list.append(1)\\n                else:\\n                    temp_list.append(list1[i-1][j-1] + list1[i-1][j])\\n            list1.append(temp_list)\\n        return list1[rowIndex]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "``` \\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        list1 = []\\n        for i in range(rowIndex+1):\\n            temp_list = []\\n            for j in range(i+1):\\n                if j==0 or j==i:\\n                    temp_list.append(1)\\n                else:\\n                    temp_list.append(list1[i-1][j-1] + list1[i-1][j])\\n            list1.append(temp_list)\\n        return list1[rowIndex]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2055396,
                "title": "c-easy-to-understand-faster-than-100",
                "content": "**//PLEASE UPVOTE IF IT IS HELPFUL**\\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<int> v;\\n        long long int val=1;\\n        for(int i=0; i<=rowIndex; i++){\\n            v.push_back(val);\\n            val = val*(rowIndex-i)/(i+1);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<int> v;\\n        long long int val=1;\\n        for(int i=0; i<=rowIndex; i++){\\n            v.push_back(val);\\n            val = val*(rowIndex-i)/(i+1);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456044,
                "title": "",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n     vector<vector<int>> PAS;\\n     for(int i=0;i<=rowIndex;i++){\\n         vector<int>row(i+1,1);\\n         for(int j=1;j<i;j++)row[j]=PAS[i-1][j-1]+PAS[i-1][j];\\n         PAS.push_back(row);\\n     }\\n     return PAS[rowIndex];\\n    }\\n};\\n\\n//Please upvote if you like the solution!!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n     vector<vector<int>> PAS;\\n     for(int i=0;i<=rowIndex;i++){\\n         vector<int>row(i+1,1);\\n         for(int j=1;j<i;j++)row[j]=PAS[i-1][j-1]+PAS[i-1][j];\\n         PAS.push_back(row);\\n     }",
                "codeTag": "Java"
            },
            {
                "id": 787732,
                "title": "very-simple-python-solution-using-combinatorics-faster-than-98",
                "content": "Easy if you understand what Pascal\\'s Triangle is used for. It\\'s used for [combinatorics](https://mathigon.org/world/Combinatorics). In fact, if you google \"combinatorics\", you\\'ll find a picture of Pascal\\'s Triangle. Each row in the triangle tells us the `n_choose_k` result where `n` is the row index and `k` is `[0 ... n]`, the column index.\\n\\nExamples:\\n```\\nn = 0 (top of the triangle)\\ncomb(0, 0) = 1\\n\\nn = 1\\ncomb(1, 0) = 1\\ncomb(1, 1) = 1\\n\\nn = 2\\ncomb(2, 0) = 1\\ncomb(2, 1) = 2\\ncomb(2, 2) = 1\\n\\nn = 3\\ncomb(3, 0) = 1\\ncomb(3, 1) = 3\\ncomb(3, 2) = 3\\ncomb(3, 3) = 1\\n```\\n\\nWith that the code becomes simple in python as the `math` library has a function for `comb`.\\n```\\nfrom math import comb\\n\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        result = []\\n        for i in range(rowIndex+1):\\n            result.append(comb(rowIndex, i))\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nn = 0 (top of the triangle)\\ncomb(0, 0) = 1\\n\\nn = 1\\ncomb(1, 0) = 1\\ncomb(1, 1) = 1\\n\\nn = 2\\ncomb(2, 0) = 1\\ncomb(2, 1) = 2\\ncomb(2, 2) = 1\\n\\nn = 3\\ncomb(3, 0) = 1\\ncomb(3, 1) = 3\\ncomb(3, 2) = 3\\ncomb(3, 3) = 1\\n```\n```\\nfrom math import comb\\n\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        result = []\\n        for i in range(rowIndex+1):\\n            result.append(comb(rowIndex, i))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 787705,
                "title": "python-simplest-3-line-recursive-solution-faster-than-99",
                "content": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        if rowIndex == 0: return [1]\\n        prev = self.getRow(rowIndex-1)\\n        return [1] + [prev[i]+prev[i+1] for i in range(len(prev)-1)] + [1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        if rowIndex == 0: return [1]\\n        prev = self.getRow(rowIndex-1)\\n        return [1] + [prev[i]+prev[i+1] for i in range(len(prev)-1)] + [1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 787676,
                "title": "javascript-clean-solution",
                "content": "```javascript\\nvar getRow = function(rowIndex) {\\n    if(!rowIndex) return [1];\\n    \\n    let res = [1, 1]\\n    \\n    while(--rowIndex) {\\n        const next = [];\\n        \\n        for(let i = 0; i < res.length-1; i++) {\\n            next.push(res[i] + res[i+1]);\\n        }\\n        res = [1, ...next, 1];\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar getRow = function(rowIndex) {\\n    if(!rowIndex) return [1];\\n    \\n    let res = [1, 1]\\n    \\n    while(--rowIndex) {\\n        const next = [];\\n        \\n        for(let i = 0; i < res.length-1; i++) {\\n            next.push(res[i] + res[i+1]);\\n        }\\n        res = [1, ...next, 1];\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 787291,
                "title": "pascal-s-triangle-one-liner",
                "content": "```\\nfrom math import comb\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        return [comb(rowIndex, i) for i in range(rowIndex+1)]\\n            \\n```\\nhttps://www.dummies.com/education/math/calculus/how-to-find-binomial-coefficients/",
                "solutionTags": [],
                "code": "```\\nfrom math import comb\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        return [comb(rowIndex, i) for i in range(rowIndex+1)]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 787246,
                "title": "java-pascal-triangle-o-k-space",
                "content": "```\\npublic List<Integer> getRow(int rowIndex) {\\n        List<Integer> result = new ArrayList<>();\\n        for (int i=0; i <=rowIndex ; i++){\\n            int j =0;\\n            while (result.size()-1 > j){\\n                result.add(result.get(0) + result.get(1));\\n                result.remove(0);\\n                j++;\\n            }\\n            result.add(1);\\n        }\\n        return  result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> getRow(int rowIndex) {\\n        List<Integer> result = new ArrayList<>();\\n        for (int i=0; i <=rowIndex ; i++){\\n            int j =0;\\n            while (result.size()-1 > j){\\n                result.add(result.get(0) + result.get(1));\\n                result.remove(0);\\n                j++;\\n            }\\n            result.add(1);\\n        }\\n        return  result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 197755,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def getRow(self, rowIndex):\\n        \"\"\"\\n        :type rowIndex: int\\n        :rtype: List[int]\\n        \"\"\"\\n        res = [1]*(rowIndex+1)\\n        for i in range(2, rowIndex+1):\\n            prev = res[0]\\n            for j in range(1,i):\\n                tmp = res[j]\\n                res[j] = prev+res[j]\\n                prev = tmp\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex):\\n        \"\"\"\\n        :type rowIndex: int\\n        :rtype: List[int]\\n        \"\"\"\\n        res = [1]*(rowIndex+1)\\n        for i in range(2, rowIndex+1):\\n            prev = res[0]\\n            for j in range(1,i):\\n                tmp = res[j]\\n                res[j] = prev+res[j]\\n                prev = tmp\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 38537,
                "title": "java-o-n-solution-concise-and-easy-to-understand",
                "content": "    public List<Integer> getRow(int rowIndex) {\\n    \\t\\tList<Integer> row = null, pre = null;\\n    \\t\\tfor (int i = 0; i <= rowIndex; i++) {\\n    \\t\\t\\trow = new ArrayList<>();\\n    \\t\\t\\tfor (int j = 0; j <= i; j++) {\\n    \\t\\t\\t\\trow.add(j == 0 || i == j ? 1 : pre.get(j) + pre.get(j-1));\\n    \\t\\t\\t}\\n    \\t\\t\\tpre = row;\\n    \\t\\t}\\n    \\t\\treturn row;\\n    \\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<Integer> getRow(int rowIndex) {\\n    \\t\\tList<Integer> row = null, pre = null;\\n    \\t\\tfor (int i = 0; i <= rowIndex; i++) {\\n    \\t\\t\\trow = new ArrayList<>();\\n    \\t\\t\\tfor (int j = 0; j <= i; j++) {\\n    \\t\\t\\t\\trow.add(j == 0 || i == j ? 1 : pre.get(j) + pre.get(j-1));\\n    \\t\\t\\t}\\n    \\t\\t\\tpre = row;\\n    \\t\\t}\\n    \\t\\treturn row;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 38670,
                "title": "my-concise-java-solution-within-10-lines",
                "content": "My Concise Java Solution within 10 lines. Any improvement?\\n\\n    public class Solution {\\n        public List<Integer> getRow(int rowIndex) {\\n            List<Integer> ans = new ArrayList<Integer>();\\n            \\n            for(int i=0;i<rowIndex+1;i++){\\n                ans.add(1);\\n                for(int j=i-1;j>0;j--){\\n                    ans.set(j,ans.get(j)+ans.get(j-1));\\n                }\\n            }\\n            \\n            return ans;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> getRow(int rowIndex) {\\n            List<Integer> ans = new ArrayList<Integer>();\\n            \\n            for(int i=0;i<rowIndex+1;i++){\\n                ans.add(1);\\n                for(int j=i-1;j>0;j--){\\n                    ans.set(j,ans.get(j)+ans.get(j-1));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3465917,
                "title": "beats-100-easiest-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<vector<int>> temp;\\n        for(int i=0;i<=rowIndex;i++)\\n        {\\n            vector<int> ans(i+1,1);\\n            for(int j=1;j<i;j++)\\n            {\\n                ans[j]=temp[i-1][j]+temp[i-1][j-1];\\n            }\\n                temp.push_back(ans);\\n                if(i==rowIndex)\\n                {\\n                    return ans;\\n                }\\n        }\\n        vector<int>vis;\\n        return vis;\\n    }\\n};\\n\\nDO UPVOTE if you like\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<vector<int>> temp;\\n        for(int i=0;i<=rowIndex;i++)\\n        {\\n            vector<int> ans(i+1,1);\\n            for(int j=1;j<i;j++)\\n            {\\n                ans[j]=temp[i-1][j]+temp[i-1][j-1];\\n            }\\n                temp.push_back(ans);\\n                if(i==rowIndex)\\n                {\\n                    return ans;\\n                }\\n        }\\n        vector<int>vis;\\n        return vis;\\n    }\\n};\\n\\nDO UPVOTE if you like\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198598,
                "title": "efficiently-compute-the-k-th-row-of-pascal-s-triangle",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks to find the `rowIndex`-th row of the Pascal\\'s triangle. One approach is to calculate the entire Pascal\\'s triangle up to the given row, and then return the row. However, this approach requires calculating all the previous rows, which is inefficient.\\n\\nA better approach is to use the formula for the i-th element of the k-th row of the triangle, which is the binomial coefficient C(k, i-1). This formula allows us to calculate each element of the row separately, without having to compute the entire triangle.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is to iterate from i = 0 to i = rowIndex, and compute each element of the row using the formula for the binomial coefficient. We can use the previously computed value to optimize the calculation of the coefficient. We only store the current row, rather than storing the entire triangle.\\n# Complexity\\n- Time complexity:The algorithm computes each element of the row from scratch, and there are rowIndex elements in the row. Therefore, the time complexity is O(rowIndex).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:The algorithm stores only one row at a time, and there are rowIndex elements in the row. Therefore, the space complexity is O(rowIndex).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        row = [1]\\n        for i in range(1, rowIndex+1):\\n            # compute the i-th element of the current row\\n            element = row[-1] * (rowIndex-i+1) // i\\n            row.append(element)\\n        return row\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        row = [1]\\n        for i in range(1, rowIndex+1):\\n            # compute the i-th element of the current row\\n            element = row[-1] * (rowIndex-i+1) // i\\n            row.append(element)\\n        return row\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195751,
                "title": "with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSolution:\\n\\nTo generate the row of Pascal\\'s triangle at a given index rowIndex, we can use the fact that each element of the kth row is C(k, i), where C(k, i) is the binomial coefficient k choose i, i.e., the number of ways to choose i items from a set of k items. We can calculate the binomial coefficients using the formula C(k, i) = C(k, i-1) * (k-i+1) / i, which can be derived from the fact that C(k, i) = C(k-1, i-1) + C(k-1, i).\\n\\nWe can initialize the row with 1, and then compute each element by multiplying the previous element by (rowIndex-i+1) and dividing by i.\\n\\nWe only need to keep track of the previous element to compute the next element, so we can use only O(rowIndex) extra space.\\n\\n# Complexity\\n- Time complexity:\\nO(rowIndex^2), as we need to compute all binomial coefficients from row 0 to row rowIndex.\\n\\n- Space complexity:\\nO(rowIndex), as we only need to store the previous element to compute the next element.\\n\\n# Code\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        row = [1] * (rowIndex + 1)\\n        for i in range(1, rowIndex):\\n            row[i] = row[i-1] * (rowIndex-i+1) // i\\n        return row\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        row = [1] * (rowIndex + 1)\\n        for i in range(1, rowIndex):\\n            row[i] = row[i-1] * (rowIndex-i+1) // i\\n        return row\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017325,
                "title": "1ms-most-optimal-solution-java-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        List<Integer>prev=new ArrayList<>();\\n        for(int i=0;i<=rowIndex;i++){\\n            List<Integer>temp=new ArrayList<>();\\n            for(int j=0;j<=i;j++){\\n                if(j==0 || j==i){\\n                    temp.add(1);\\n                }\\n                else{\\n                    temp.add(prev.get(j-1)+prev.get(j));\\n                }\\n                \\n            }\\n            prev=temp;\\n            \\n        }\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        List<Integer>prev=new ArrayList<>();\\n        for(int i=0;i<=rowIndex;i++){\\n            List<Integer>temp=new ArrayList<>();\\n            for(int j=0;j<=i;j++){\\n                if(j==0 || j==i){\\n                    temp.add(1);\\n                }\\n                else{\\n                    temp.add(prev.get(j-1)+prev.get(j));\\n                }\\n                \\n            }\\n            prev=temp;\\n            \\n        }\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672163,
                "title": "java-solution-faster-than-100",
                "content": "class Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        List<Integer> row = new ArrayList<>();\\n\\n        double ncr = 1.0;\\n        for(int i = 0; i <= rowIndex; i++){\\n            row.add((int)ncr);\\n            ncr = (ncr * (rowIndex - i)) / (i+1);\\n        }\\n        return row;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        List<Integer> row = new ArrayList<>();\\n\\n        double ncr = 1.0;\\n        for(int i = 0; i <= rowIndex; i++){\\n            row.add((int)ncr);\\n            ncr = (ncr * (rowIndex - i)) / (i+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2626364,
                "title": "java-3-approaches-clean-and-easy",
                "content": "##### 1. Same as **Pascal\\'s Triangle 1**:\\nCreate the whole triangle till that row and at the end return that last row.\\n```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> currRow, prevRow = null;\\n\\n        for (int i = 0; i <= rowIndex; i++) {\\n            currRow = new ArrayList<>();\\n\\n            for (int j = 0; j <= i; j++) {\\n                if (j == 0 || j == i) currRow.add(1);\\n                else {\\n                    currRow.add(\\n                            prevRow.get(j - 1) + prevRow.get(j)\\n                    );\\n                }\\n            }\\n\\n            ans.add(currRow);\\n            prevRow = currRow;\\n        }\\n\\n        return ans.get(rowIndex);\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC; O(n ^ 2)\\n```\\n\\n##### 2. A little memory optimization:\\n```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        Integer[] ans = new Integer[rowIndex + 1];\\n        Arrays.fill(ans, 0);    // O(n)\\n        ans[0] = 1;\\n\\n        for (int i = 1; i <= rowIndex; i++) {\\n            for (int j = i; j > 0; j--) {\\n                ans[j] += ans[j - 1];\\n            }\\n        }\\n\\n        return Arrays.asList(ans);\\n    }\\n}\\n\\n// TC: O(n) + O(n ^ 2) => O(n ^ 2)\\n// SC: O(n)\\n```\\n##### 3. Optimal solution (Using formula):\\nFormula: **```nCr = nC(r - 1) * (n - r + 1) / r;```**\\n```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        Integer[] ans = new Integer[rowIndex + 1];\\n        ans[0] = 1;\\n\\n        for (int r = 1; r <= rowIndex; r++) {\\n            ans[r] = (int) ((long) ans[r - 1] * (rowIndex - r + 1) / r);\\n        }\\n\\n        return Arrays.asList(ans);\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> currRow, prevRow = null;\\n\\n        for (int i = 0; i <= rowIndex; i++) {\\n            currRow = new ArrayList<>();\\n\\n            for (int j = 0; j <= i; j++) {\\n                if (j == 0 || j == i) currRow.add(1);\\n                else {\\n                    currRow.add(\\n                            prevRow.get(j - 1) + prevRow.get(j)\\n                    );\\n                }\\n            }\\n\\n            ans.add(currRow);\\n            prevRow = currRow;\\n        }\\n\\n        return ans.get(rowIndex);\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC; O(n ^ 2)\\n```\n```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        Integer[] ans = new Integer[rowIndex + 1];\\n        Arrays.fill(ans, 0);    // O(n)\\n        ans[0] = 1;\\n\\n        for (int i = 1; i <= rowIndex; i++) {\\n            for (int j = i; j > 0; j--) {\\n                ans[j] += ans[j - 1];\\n            }\\n        }\\n\\n        return Arrays.asList(ans);\\n    }\\n}\\n\\n// TC: O(n) + O(n ^ 2) => O(n ^ 2)\\n// SC: O(n)\\n```\n```nCr = nC(r - 1) * (n - r + 1) / r;```\n```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        Integer[] ans = new Integer[rowIndex + 1];\\n        ans[0] = 1;\\n\\n        for (int r = 1; r <= rowIndex; r++) {\\n            ans[r] = (int) ((long) ans[r - 1] * (rowIndex - r + 1) / r);\\n        }\\n\\n        return Arrays.asList(ans);\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2429494,
                "title": "1-ms-simple-java-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        int n=rowIndex;\\n       List<Integer> res=new ArrayList<Integer>();\\n       res.add(1);\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n           int x= (int) ( ((long)res.get(res.size()-1)*(n-i+1) ) /i);\\n           res.add(x);\\n        }\\n        \\n        return res;\\n    }\\n  \\n}       \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        int n=rowIndex;\\n       List<Integer> res=new ArrayList<Integer>();\\n       res.add(1);\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n           int x= (int) ( ((long)res.get(res.size()-1)*(n-i+1) ) /i);\\n           res.add(x);\\n        }\\n        \\n        return res;\\n    }\\n  \\n}       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1742190,
                "title": "python-3-40ms-iterative-easy-approach",
                "content": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        res=[]\\n        for i in range(rowIndex+1):\\n            res.append([])\\n            for j in range(i+1):\\n                if j == 0 or j == i:\\n                    res[i].append(1)\\n                else:\\n                    res[i].append(res[i - 1][j - 1] + res[i - 1][j])\\n        return res[rowIndex]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        res=[]\\n        for i in range(rowIndex+1):\\n            res.append([])\\n            for j in range(i+1):\\n                if j == 0 or j == i:\\n                    res[i].append(1)\\n                else:\\n                    res[i].append(res[i - 1][j - 1] + res[i - 1][j])\\n        return res[rowIndex]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538576,
                "title": "c-100-faster-simple-solution",
                "content": "This solution is based on the relation between row, column, and digits of pascal\\'s triangle. This way, we don\\'t have to store any rows of the pascal\\'s triangle for further calculation, thus making the program, fast.\\n\\nFeel free to ask any doubts below.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        \\n        vector<int> result;\\n        \\n        long temp = 1;\\n        \\n        for(int i=0; i<=rowIndex; i++){\\n            \\n            for(int j=0; j<=i; j++){\\n                \\n                if(j == 0 || i == 0)\\n                    temp = 1;\\n                \\n                else\\n                    temp = temp * (i-j+1)/j;\\n                \\n                if(i == rowIndex)\\n                    result.push_back(temp);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        \\n        vector<int> result;\\n        \\n        long temp = 1;\\n        \\n        for(int i=0; i<=rowIndex; i++){\\n            \\n            for(int j=0; j<=i; j++){\\n                \\n                if(j == 0 || i == 0)\\n                    temp = 1;\\n                \\n                else\\n                    temp = temp * (i-j+1)/j;\\n                \\n                if(i == rowIndex)\\n                    result.push_back(temp);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1459365,
                "title": "python-top-down-dp-o-n-space-clean-concise",
                "content": "```python\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        dpPrev = [1] * (rowIndex + 1)\\n        dp = [1] * (rowIndex + 1)\\n        for r in range(1, rowIndex+1):\\n            for c in range(1, r):\\n                dp[c] = dpPrev[c-1] + dpPrev[c]\\n            dp, dpPrev = dpPrev, dp\\n        \\n        return dpPrev\\n```\\nComplexity:\\n- Time: `O(rowIndex^2)`, where `rowIndex <= 33)`.\\n- Space: `O(rowIndex)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        dpPrev = [1] * (rowIndex + 1)\\n        dp = [1] * (rowIndex + 1)\\n        for r in range(1, rowIndex+1):\\n            for c in range(1, r):\\n                dp[c] = dpPrev[c-1] + dpPrev[c]\\n            dp, dpPrev = dpPrev, dp\\n        \\n        return dpPrev\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294924,
                "title": "c-o-n-time-and-o-n-space-solution-with-explanation",
                "content": "**Concept: Assuming the rows of pascal triangle to be 0-indexed, the terms of the nth   row will be: nC0,nC1,nC2,nC3.......nCn.**\\n**Now we know that nC0 is equal to 1.Let us store it in variable \\'prev\\'.**\\n**We will calculate next terms of the sequence using standard formula which is: nCr=((nCr-1)(n-r+1))/r**\\n**Let us store this value in a variable named \\'curr\\'.**\\n**Now at each step we will update prev=curr for calculation of next term of sequence.**\\n\\n\\n**Points to Remember:**\\n**while calculating next term the value calculated may overflow for higher values of n. So store \\'previous\\' term in a long long int variable**\\n**Time Complexity: O(n)**\\n**Space Complexity: O(n)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int n) {\\n        if(n==0){\\n            return {1};\\n        }\\n        long long int prev=1;\\n        vector<int>result;\\n        result.push_back(1);\\n        for(int i=1;i<=n;++i){\\n            int curr=(prev*(n-i+1))/i;\\n            prev=curr;\\n            result.push_back(prev);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int n) {\\n        if(n==0){\\n            return {1};\\n        }\\n        long long int prev=1;\\n        vector<int>result;\\n        result.push_back(1);\\n        for(int i=1;i<=n;++i){\\n            int curr=(prev*(n-i+1))/i;\\n            prev=curr;\\n            result.push_back(prev);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1070447,
                "title": "java-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {        \\n        List<Integer> row = new ArrayList<>();\\n        row.add(1);\\n        \\n        if (rowIndex == 0) {\\n            return row;\\n        }\\n\\n        row.add(1);\\n        if (rowIndex == 1) {\\n            return row;\\n        }\\n        \\n        int currentIndex = 1;\\n        while (currentIndex < rowIndex) {\\n            int size = row.size();\\n            int current = 0;\\n            while (current < size - 1) {\\n                row.add(row.get(0) + row.get(1));\\n                row.remove(0);\\n                current++;\\n            }\\n            row.add(1);\\n            currentIndex++;\\n        }\\n        \\n        return row;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {        \\n        List<Integer> row = new ArrayList<>();\\n        row.add(1);\\n        \\n        if (rowIndex == 0) {\\n            return row;\\n        }\\n\\n        row.add(1);\\n        if (rowIndex == 1) {\\n            return row;\\n        }\\n        \\n        int currentIndex = 1;\\n        while (currentIndex < rowIndex) {\\n            int size = row.size();\\n            int current = 0;\\n            while (current < size - 1) {\\n                row.add(row.get(0) + row.get(1));\\n                row.remove(0);\\n                current++;\\n            }\\n            row.add(1);\\n            currentIndex++;\\n        }\\n        \\n        return row;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 913200,
                "title": "python3-just-1-line-using-binomial-theorem",
                "content": "comb function\\uFF1A**comb(n,m) = n!/(m!(n-m)!)**\\nFor line n in Pasca triangle, the numbers from left to right are:\\n`comb(n-1,0), comb(n-1,1),......, comb(n-1, n-2), comb(n-1, n-1)`\\nAnd this is **Binomial Theorem**\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        return [comb(rowIndex,j) for j in range(rowIndex+1)]\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        return [comb(rowIndex,j) for j in range(rowIndex+1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 418061,
                "title": "javascript-solution-recursive",
                "content": "> Runtime: 52 ms, faster than 80.61% of JavaScript online submissions for Pascal\\'s Triangle II.\\n> Memory Usage: 33.7 MB, less than 90.00% of JavaScript online submissions for Pascal\\'s Triangle II.\\n\\n```js\\n/**\\n * @param {number} rowIndex\\n * @return {number[]}\\n */\\nvar getRow = function(rowIndex) {\\n    if (rowIndex === 0) {\\n        return [1]\\n    }\\n    if (rowIndex > 0) {\\n        let a = [1]\\n        let p = getRow(rowIndex - 1)\\n        for (let i = 1; i < rowIndex; i++) {\\n            a[i] = p[i - 1] + p[i]\\n        }\\n        a.push(1)\\n        return a\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```js\\n/**\\n * @param {number} rowIndex\\n * @return {number[]}\\n */\\nvar getRow = function(rowIndex) {\\n    if (rowIndex === 0) {\\n        return [1]\\n    }\\n    if (rowIndex > 0) {\\n        let a = [1]\\n        let p = getRow(rowIndex - 1)\\n        for (let i = 1; i < rowIndex; i++) {\\n            a[i] = p[i - 1] + p[i]\\n        }\\n        a.push(1)\\n        return a\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 245504,
                "title": "python-recursive",
                "content": "```python\\ndef getRow(self, rowIndex: \\'int\\') -> \\'List[int]\\':\\n\\tif rowIndex == 0: return [1]\\n\\tans = self.getRow(rowIndex - 1)\\n\\treturn [1] + [sum(x) for x in zip(ans, ans[1:])] + [1]\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```python\\ndef getRow(self, rowIndex: \\'int\\') -> \\'List[int]\\':\\n\\tif rowIndex == 0: return [1]\\n\\tans = self.getRow(rowIndex - 1)\\n\\treturn [1] + [sum(x) for x in zip(ans, ans[1:])] + [1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 38484,
                "title": "my-0ms-accepted-java-solution-using-a-property-of-ncr",
                "content": "**High level description:**\\nWe know that each element of Pascal's triangle is just nCr, where n is the row number and r is the column number.\\nNow, if we know the value of nCr, then we can calculate the value of nCr+1 (i.e. for the next column).\\nIf you expand nCr+1, it can be written as: nCr * (n-r)/(r+1).\\nThus, I make a for loop which runs k time and calculates nCr+1 by using nCr.\\nHere is the code. Feel free to ask questions and make suggestions.\\n\\n**Code:**\\n```\\npublic class Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        long coeff = 1; // nC0\\n        // n = rowIndex, j=r\\n        List<Integer> result = new ArrayList<Integer>();\\n        for(int j=0;j<=rowIndex;j++){\\n                result.add((int)coeff);\\n                coeff = coeff * (rowIndex-j)/(j+1); // calculating nCr using nCr-1\\n            }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Combinatorics"
                ],
                "code": "```\\npublic class Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        long coeff = 1; // nC0\\n        // n = rowIndex, j=r\\n        List<Integer> result = new ArrayList<Integer>();\\n        for(int j=0;j<=rowIndex;j++){\\n                result.add((int)coeff);\\n                coeff = coeff * (rowIndex-j)/(j+1); // calculating nCr using nCr-1\\n            }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 38560,
                "title": "c-implementation",
                "content": "    class Solution {\\n    public:\\n        vector<int> getRow(int rowIndex) {\\n            vector<int> result(rowIndex+1, 0);\\n            result[0]=1;\\n            for(int i=1; i<=rowIndex; i++){\\n                for(int j=i; j>=1; j--)\\n                    result[j]=result[j]+result[j-1];\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> getRow(int rowIndex) {\\n            vector<int> result(rowIndex+1, 0);\\n            result[0]=1;\\n            for(int i=1; i<=rowIndex; i++){\\n                for(int j=i; j>=1; j--)\\n                    result[j]=result[j]+result[j-1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 38571,
                "title": "o-k-python-code",
                "content": "class Solution(object):\\n\\n    def getRow(self, rowIndex):\\n        \"\"\"\\n        :type rowIndex: int\\n        :rtype: List[int]\\n        \"\"\"\\n        result = []\\n        for i in range(1,rowIndex+2):\\n            # there are i elements\\n            result.append(1)\\n            for j in range(i-2,0,-1):\\n                result[j] += result[j-1]\\n        return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n\\n    def getRow(self, rowIndex):\\n        \"\"\"\\n        :type rowIndex: int\\n        :rtype: List[int]\\n        \"\"\"\\n        result = []\\n        for i in range(1,rowIndex+2):\\n            # there are i elements\\n            result.append(1)\\n            for j in range(i-2,0,-1):\\n                result[j] += result[j-1]\\n        return result",
                "codeTag": "Java"
            },
            {
                "id": 38575,
                "title": "share-my-c-code-easy-understand",
                "content": "int* getRow(int rowIndex, int* returnSize) {\\n\\n    if (rowIndex < 0)\\n        return NULL;\\n\\n    int *res = (int*)malloc(sizeof(int) * (rowIndex + 1));\\n\\n    for (int row = 0; row <= rowIndex; row++)\\n        for (int col = row; col >= 0; col--)\\n            res[col] = (col == 0 || col == row) ? 1 : res[col] + res[col - 1];\\n\\n    *returnSize = rowIndex + 1;\\n    return res;\\n}",
                "solutionTags": [],
                "code": "int* getRow(int rowIndex, int* returnSize) {\\n\\n    if (rowIndex < 0)\\n        return NULL;\\n\\n    int *res = (int*)malloc(sizeof(int) * (rowIndex + 1));\\n\\n    for (int row = 0; row <= rowIndex; row++)\\n        for (int col = row; col >= 0; col--)\\n            res[col] = (col == 0 || col == row) ? 1 : res[col] + res[col - 1];\\n\\n    *returnSize = rowIndex + 1;\\n    return res;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 4034497,
                "title": "python-solution-with-briefly-explanation",
                "content": "# Explanation\\nLet\\'s break down the given code step by step.\\n\\n```python\\ndef getRow(self, rowIndex: int) -> List[int]:\\n    res = [[1]]\\n```\\n- This function is defined as a method within a class, as it has `self` as its first parameter. It takes an integer `rowIndex` as input and is expected to return a list of integers.\\n- `res` is initialized as a list containing a single list with the value `[1]`. This list represents the first row of Pascal\\'s Triangle.\\n\\n```python\\n    for i in range(rowIndex):\\n        temp = [0] + res[-1] + [0]\\n        row = []\\n```\\n- A loop is set up to iterate from 0 to `rowIndex - 1`. This loop is used to calculate the subsequent rows of Pascal\\'s Triangle.\\n- `temp` is initialized as a new list, which is formed by adding `0` at the beginning and end of the last row in `res`. This is done to create a buffer of zeros around the row to calculate the next row.\\n- `row` is initialized as an empty list. This list will store the values of the current row being calculated.\\n\\n```python\\n        for j in range(len(res[-1])+1):\\n            row.append(temp[j] + temp[j+1])\\n```\\n- Another nested loop is set up to iterate over the elements of `temp` and calculate the values of the current row.\\n- For each element at index `j` in `temp`, it adds the value at index `j` and the value at index `j+1` and appends the result to the `row` list.\\n\\n```python\\n        res.append(row)\\n```\\n- After calculating all the values for the current row, the `row` list is appended to the `res` list. This adds a new row to the list, representing the current row of Pascal\\'s Triangle.\\n\\n```python\\n    return res[-1]\\n```\\n- After the loop completes (i.e., all rows up to `rowIndex` have been calculated and added to `res`), the function returns the last row of `res`, which corresponds to the row at index `rowIndex` in Pascal\\'s Triangle.\\n\\nIn summary, this code calculates and returns the `rowIndex`-th row of Pascal\\'s Triangle using a list-based approach, where each row is calculated based on the previous row. It builds up the rows one by one, starting with the first row as `[1]` and using the values from the previous row to calculate the next row.\\n\\n# Python Code\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        res = [[1]]\\n        \\n        for i in range(rowIndex):\\n            temp = [0] + res[-1] + [0]\\n            row = []\\n\\n            for j in range(len(res[-1])+1):\\n                row.append(temp[j] + temp[j+1])\\n            res.append(row)\\n\\n        return res[-1]\\n```\\n**Please upvote if you like the solution & feel free to give your opinion. \\nHappy Coding! \\uD83D\\uDE0A**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```python\\ndef getRow(self, rowIndex: int) -> List[int]:\\n    res = [[1]]\\n```\n```python\\n    for i in range(rowIndex):\\n        temp = [0] + res[-1] + [0]\\n        row = []\\n```\n```python\\n        for j in range(len(res[-1])+1):\\n            row.append(temp[j] + temp[j+1])\\n```\n```python\\n        res.append(row)\\n```\n```python\\n    return res[-1]\\n```\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        res = [[1]]\\n        \\n        for i in range(rowIndex):\\n            temp = [0] + res[-1] + [0]\\n            row = []\\n\\n            for j in range(len(res[-1])+1):\\n                row.append(temp[j] + temp[j+1])\\n            res.append(row)\\n\\n        return res[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977562,
                "title": "intuitive-dynamic-programming-o-n-2",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    \\n    public List<Integer> getRow(int rowIndex) {\\n        List<Integer> prev = new ArrayList<Integer>();\\n        prev.add(1);\\n        for(int i=0;i< rowIndex; i++){\\n            List<Integer> pres = new ArrayList<Integer>();\\n            pres.add(1);\\n            for(int j=1;j < prev.size(); j++){\\n                pres.add(j, prev.get(j)+prev.get(j-1));\\n            }\\n            pres.add(1);\\n            prev = pres;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public List<Integer> getRow(int rowIndex) {\\n        List<Integer> prev = new ArrayList<Integer>();\\n        prev.add(1);\\n        for(int i=0;i< rowIndex; i++){\\n            List<Integer> pres = new ArrayList<Integer>();\\n            pres.add(1);\\n            for(int j=1;j < prev.size(); j++){\\n                pres.add(j, prev.get(j)+prev.get(j-1));\\n            }\\n            pres.add(1);\\n            prev = pres;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231430,
                "title": "easy-to-understand-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n       List<List<Integer>> dp = new ArrayList<List<Integer>>();\\n        ArrayList<Integer> sp = new ArrayList<Integer>();\\n        sp.add(1);\\n        dp.add(sp);\\n        \\n        ArrayList<Integer> sp2 = new ArrayList<Integer>();\\n        sp2.add(1);\\n        sp2.add(1);\\n        dp.add(sp2);\\n        \\n        for(int i = 2; i <= rowIndex; i++){\\n            ArrayList<Integer> sp3 = new ArrayList<Integer>();\\n            sp3.add(1);\\n            List<Integer> use = dp.get(i-1);\\n            int p1 = 0;\\n            int p2 = 1;\\n            while(p2 < use.size()){\\n                int sum = use.get(p1)+use.get(p2);\\n                sp3.add(sum);\\n                p1++;\\n                p2++;\\n            }\\n            sp3.add(1);\\n            dp.add(sp3);\\n        }\\n        return dp.get(rowIndex);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n       List<List<Integer>> dp = new ArrayList<List<Integer>>();\\n        ArrayList<Integer> sp = new ArrayList<Integer>();\\n        sp.add(1);\\n        dp.add(sp);\\n        \\n        ArrayList<Integer> sp2 = new ArrayList<Integer>();\\n        sp2.add(1);\\n        sp2.add(1);\\n        dp.add(sp2);\\n        \\n        for(int i = 2; i <= rowIndex; i++){\\n            ArrayList<Integer> sp3 = new ArrayList<Integer>();\\n            sp3.add(1);\\n            List<Integer> use = dp.get(i-1);\\n            int p1 = 0;\\n            int p2 = 1;\\n            while(p2 < use.size()){\\n                int sum = use.get(p1)+use.get(p2);\\n                sp3.add(sum);\\n                p1++;\\n                p2++;\\n            }\\n            sp3.add(1);\\n            dp.add(sp3);\\n        }\\n        return dp.get(rowIndex);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197044,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n\\n- Space complexity:$$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<vector<int>>v;\\n        for (int i=0; i<rowIndex+1; i++) {\\n            vector<int>v1(i+1, 1);\\n            for (int j=1; j<i; j++) {\\n                v1[j]=v[i-1][j]+v[i-1][j-1];\\n            }\\n            v.push_back(v1);\\n        }\\n        return v[rowIndex];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<vector<int>>v;\\n        for (int i=0; i<rowIndex+1; i++) {\\n            vector<int>v1(i+1, 1);\\n            for (int j=1; j<i; j++) {\\n                v1[j]=v[i-1][j]+v[i-1][j-1];\\n            }\\n            v.push_back(v1);\\n        }\\n        return v[rowIndex];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073377,
                "title": "c-fastest-submission-tc-o-n-sc-o-1-tabulation",
                "content": "TC: O(N^2)\\nSC: O(N)\\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int row) {\\n        \\n        vector<int>prev(row+1);\\n        vector<int>curr(row+1);\\n        prev[0]=1;\\n        for(int i=1;i<=row;i++){\\n            for(int j=0;j<=i;j++){\\n                curr[j] = (j-1<0 ? 0: prev[j-1]) + prev[j];\\n            }\\n            prev=curr;\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int row) {\\n        \\n        vector<int>prev(row+1);\\n        vector<int>curr(row+1);\\n        prev[0]=1;\\n        for(int i=1;i<=row;i++){\\n            for(int j=0;j<=i;j++){\\n                curr[j] = (j-1<0 ? 0: prev[j-1]) + prev[j];\\n            }\\n            prev=curr;\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971864,
                "title": "0ms-c-solution-beats-100-using-just-1-array-returnsize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N^2) - Every single row above rowIndex is iterated, but not stored\\n\\n- Space complexity:\\nO(1) - No extra space used scaling with input size\\n\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* getRow(int rowIndex, int* returnSize){\\n\\n\\n        //challenge to use O(rowIndex) space\\n        //at rowIndex, there are (rowIndex+1) space\\n\\n        int* ret = (int*)malloc(sizeof(int)*(rowIndex+1));\\n        ret[0]=1; // base case on top\\n        for (int i=1; i<rowIndex+1;i++){\\n            ret[i]=1; //sets last index of current row to 1\\n            int o=1;\\n            for (int j=1; j<i;j++){ \\n                //sum up \"prev row\" index j-1 and j and put in j\\n                //-> index j original value needs to be saved\\n                ret[j] = o + ret[j];\\n                o=ret[j]-o;\\n            }\\n        }\\n\\n        *returnSize=rowIndex+1;\\n        return ret;\\n\\n\\n\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* getRow(int rowIndex, int* returnSize){\\n\\n\\n        //challenge to use O(rowIndex) space\\n        //at rowIndex, there are (rowIndex+1) space\\n\\n        int* ret = (int*)malloc(sizeof(int)*(rowIndex+1));\\n        ret[0]=1; // base case on top\\n        for (int i=1; i<rowIndex+1;i++){\\n            ret[i]=1; //sets last index of current row to 1\\n            int o=1;\\n            for (int j=1; j<i;j++){ \\n                //sum up \"prev row\" index j-1 and j and put in j\\n                //-> index j original value needs to be saved\\n                ret[j] = o + ret[j];\\n                o=ret[j]-o;\\n            }\\n        }\\n\\n        *returnSize=rowIndex+1;\\n        return ret;\\n\\n\\n\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2601956,
                "title": "3-lines-answer-for-super-concise-nerd-enthusiast",
                "content": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        List<Integer> list = new ArrayList<Integer>(); list.add(1);\\n        for(long i=1,temp=1,l=rowIndex,r=1;i<=rowIndex;i++)\\n            list.add((int)(temp=(temp*l--)/r++));\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        List<Integer> list = new ArrayList<Integer>(); list.add(1);\\n        for(long i=1,temp=1,l=rowIndex,r=1;i<=rowIndex;i++)\\n            list.add((int)(temp=(temp*l--)/r++));\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469676,
                "title": "javascript-simple-solution-beats-75",
                "content": "```\\nvar getRow = function(rowIndex) {\\n    let res = [];\\n    for(let i=0;i<=rowIndex;i++){\\n        res[i] = [];\\n        res[i][0] = 1;\\n        for(let j=1;j<i;j++){\\n            res[i][j] = res[i-1][j-1]+ res[i-1][j];\\n        }\\n        res[i][i] = 1;\\n    }\\n    return res[rowIndex];\\n};\\n```\\n\\nConsider **Upvote** if you find it useful \\uD83D\\uDE00",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getRow = function(rowIndex) {\\n    let res = [];\\n    for(let i=0;i<=rowIndex;i++){\\n        res[i] = [];\\n        res[i][0] = 1;\\n        for(let j=1;j<i;j++){\\n            res[i][j] = res[i-1][j-1]+ res[i-1][j];\\n        }\\n        res[i][i] = 1;\\n    }\\n    return res[rowIndex];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2415016,
                "title": "c-o-n-2-100-faster-0ms-very-easy-to-understand",
                "content": "**Pascal\\'s Triangle II**\\n **nCr** *approach*\\n **nCr** = **nC(r-1)** *x (n-r)/(r+1)    (main approach)*\\n\\n\\n    vector<int> getRow(int n) {\\n        n++;\\n        vector<int> ans (n,1);\\n        for(int i=1;i<(n+1)/2;i++)\\n\\t\\t\\tans[i]=ans[n-i-1]=((long long)ans[i-1]*(n-i))/i;\\n        return ans;\\n    }\\n\\n\\n**Time Complexity = O(n)** *~O(n/2)*\\n**Space Complexity = O(n)** *~no extra space other then the returning vec*\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "**Pascal\\'s Triangle II**\\n **nCr** *approach*\\n **nCr** = **nC(r-1)** *x (n-r)/(r+1)    (main approach)*\\n\\n\\n    vector<int> getRow(int n) {\\n        n++;\\n        vector<int> ans (n,1);\\n        for(int i=1;i<(n+1)/2;i++)\\n\\t\\t\\tans[i]=ans[n-i-1]=((long long)ans[i-1]*(n-i))/i;\\n        return ans;\\n    }\\n\\n\\n**Time Complexity = O(n)** *~O(n/2)*\\n**Space Complexity = O(n)** *~no extra space other then the returning vec*\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2411635,
                "title": "easy-c-code",
                "content": "public class Solution {\\n    public IList<int> GetRow(int r) {\\n       \\n       int[] v=new int[r+1]; \\n        v[0]=1;\\n        for(int i=0;i<=r;++i)\\n        {\\n            for(int j=i;j>0;--j)\\n            {\\n               v[j]=v[j]+v[j-1];\\n            }\\n        }\\n        return v;\\n    \\n\\t}\\n}\\n\\n",
                "solutionTags": [
                    "C#"
                ],
                "code": "class Solution {\\n    public IList<int> GetRow(int r) {\\n       \\n       int[] v=new int[r+1]; \\n        v[0]=1;\\n        for(int i=0;i<=r;++i)\\n        {\\n            for(int j=i;j>0;--j)\\n            {\\n               v[j]=v[j]+v[j-1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2329211,
                "title": "c-4-lines-combinatroics",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowindex) {\\n     vector<int> res;\\n        int i=rowindex;\\n        long val=1;\\n        for(int j=0;j<=i;j++){\\n            res.push_back(val);\\n        val=val*(i-j)/(j+1);    //formula to generate val of next row\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowindex) {\\n     vector<int> res;\\n        int i=rowindex;\\n        long val=1;\\n        for(int j=0;j<=i;j++){\\n            res.push_back(val);\\n        val=val*(i-j)/(j+1);    //formula to generate val of next row\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994482,
                "title": "100-faster-solution-with-very-less-space",
                "content": "![image](https://assets.leetcode.com/users/images/4e96562f-28f4-44e5-bce7-f9c44d40c179_1651330470.2597287.png)\\n\\n\\'\\'\\' \\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        \\n        vector<int> v(rowIndex+1,1);         // intilizing with 1  \\n        \\n        for( int i=3 ; i <= rowIndex+1 ; i++)            \\n            for( int j=i-1 ; j > 1 ; j--)    \\n                v[ j-1 ] =  v[  j-1 ] + v[ j-2 ] ;\\n        \\n        return v;\\n    }\\n};\\n\\n\\'\\'\\'\\nLet\\'s see solution for rowIndex = 0\\n\\nv={1}  // as v is intialized to rowIndex+1 so 0+1 =1 will be vector size with value 1\\n\\ni=3 and it will check i <= rowIndex+1 i.e  (3<=0+1) which is false so it will not enter inside\\nso it will return v i.e {1} and we got our Correct answer \\n\\n*************************************\\n\\nNow Let\\'s see solution for rowIndex = 1\\n\\nv={1,1}  // as v is intialized to rowIndex+1 so 1+1 =2 will be vector size with values 1\\n\\ni=3 and it will check i <= rowIndex+1 i.e  (3<=1+1) which is false so it will not enter inside\\nso it will return v i.e {1,1} and we got our Correct answer \\n\\n\\n************************************\\n\\nNow last let\\'s see Solution for rowIndex =2\\n\\nv={1,1,1}  // as v is intialized to rowIndex+1 so 2+1 =3 will be vector size with values 1\\n\\ni=3 and it will check i <= rowIndex+1 i.e  (3<=2+1) which is true  so it will enter inside\\n   now j=i-1 i.e 3-1 = 2 and will check 2 > 1 which is true so it will  go inside .\\n   // v is {1 , 1 , 1}\\n   v[j-1] i.e v[2-1] i.e v[1] = v[1] + v[2] means v[1] = 1+1 = 2\\n   so now V is {1 , 2 , 1}\\n   j will become 1 and condition will fail and come out of j loop \\n   and i will increase to 4\\n   \\ni=4 and it will check i <= rowIndex+1 i.e  (4<=2+1) which is false so it will not enter inside\\n \\nso it will return V i.e {1,2,1}  and we Got same Correct Answer .\\n\\n****************************\\n\\nAnd So On .........................\\n\\nIf you feel it\\'s good solution then Upvote it\\n\\nThank You so Much for taking look at my 1st  posted solution !!!\\n   \\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        \\n        vector<int> v(rowIndex+1,1);         // intilizing with 1  \\n        \\n        for( int i=3 ; i <= rowIndex+1 ; i++)            \\n            for( int j=i-1 ; j > 1 ; j--)    \\n                v[ j-1 ] =  v[  j-1 ] + v[ j-2 ] ;\\n        \\n        return v;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1889644,
                "title": "java-solution-three-possible-solutions-1-simple-approach-2-dp-approach-3-ncr-approach",
                "content": "1) Simple approach with O(n^2) Time complexity and O(n^2) Space complexity:\\n```\\n    public List<Integer> getRow(int rowIndex) {\\n        List<List<Integer>> mainPascii=new ArrayList<>();\\n        for(int i=0;i<=rowIndex;i++){\\n            List<Integer> subPascii=new ArrayList<>();\\n            for (int j = 0; j < i; j++) {\\n                if(j==0){\\n                    subPascii.add(1);\\n                    continue;\\n                }\\n                else\\n                {\\n                    subPascii.add(mainPascii.get(i-1).get(j-1)+mainPascii.get(i-1).get(j));\\n                }\\n            }\\n            subPascii.add(1);\\n            mainPascii.add(subPascii);\\n        }\\n        return mainPascii.get(rowIndex);\\n    }\\n```\\n2) DP approach with O(n^2) Time complexity and O(n) Space complexity:\\n```\\n  public List<Integer> getRow(int rowIndex) {\\n        Integer[]dp=new Integer[rowIndex+1];\\n        dp[0]=1;\\n        long prev=1;\\n        long curr=0;\\n        for (int i = 1; i <= rowIndex; i++) {\\n            for (int j = 1; j <i ; j++) {\\n                curr=dp[j];\\n                dp[j]=(int)(prev+curr);\\n                prev=curr;\\n            }\\n            dp[i]=1;\\n        }\\n        return Arrays.asList(dp);\\n    }\\n```\\n3) nCr approach with O(n) Time complexity and O(n) Space complexity:\\n\\nAdded the nCr logic below:\\n\\n       Lets take example for the below triangle\\n     \\n               1   ------------> Row 0\\n             1   1  -----------> Row 1\\n            1  2  1  ----------> Row 2\\n          1  3  3  1  ---------> Row 3\\n        1  4  6  4  1  -------> Row 4\\n     \\n     \\n         Each of the position can be represented as nCj  (n = row number and j = column number)\\n     \\n                        0c0   ------------> Row 0\\n                    1c0    1c1  -----------> Row 1\\n                 2c0   2c1     2c2  ----------> Row 2\\n             3c0    3c1    3c2    3c3  ---------> Row 3\\n         4c0    4c1    4c2    4c3     4c4  -------> Row 4\\n     \\n        Formula of  NcR = N! / (N - R)! * R!\\n     \\n        Note :  Nc0 >> 1  &   NcN >> 1\\n     \\n        Suppose we have to get the 4th Row\\n                                  4c0    4c1    4c2    4c3     4c4  -------> Row 4\\n      This can be represented as : NcR   NcR+1  NcR+2  NcR+3   NcR+4\\n     \\n      Properties of combination :  NcR * factor = NcR+1 now if we can figure out the value of factor we can make the whole row.\\n     \\n              n!                         n!\\n          ------------ * factor =  ---------------------------\\n          (n-r)! * r!                (n - (r+1))! * (r+1)!\\n     \\n                        (n-r)! * r!                      (n-r) *  (n-r-1)!         n - r\\n          factor = ----------------------------  =   ------------------------- = ----------\\n                     (n - r - 1)! * (r+1) * r!            (n - r - 1)! * (r+1)     r + 1\\n     \\n     \\n         So, the value of factor = (n - r) / ( r + 1)\\n     \\n         With this we can compute the factor and get the next value\\n     \\n```\\npublic List<Integer> getRow(int rowIndex) {\\n        List<Integer> rowVal=new ArrayList<>();\\n        long val=1;\\n        for (int i = 0; i <= rowIndex; i++) {\\n            rowVal.add((int)val);\\n            val=val*(rowIndex-i)/(i+1);\\n        }\\n        return rowVal;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n    public List<Integer> getRow(int rowIndex) {\\n        List<List<Integer>> mainPascii=new ArrayList<>();\\n        for(int i=0;i<=rowIndex;i++){\\n            List<Integer> subPascii=new ArrayList<>();\\n            for (int j = 0; j < i; j++) {\\n                if(j==0){\\n                    subPascii.add(1);\\n                    continue;\\n                }\\n                else\\n                {\\n                    subPascii.add(mainPascii.get(i-1).get(j-1)+mainPascii.get(i-1).get(j));\\n                }\\n            }\\n            subPascii.add(1);\\n            mainPascii.add(subPascii);\\n        }\\n        return mainPascii.get(rowIndex);\\n    }\\n```\n```\\n  public List<Integer> getRow(int rowIndex) {\\n        Integer[]dp=new Integer[rowIndex+1];\\n        dp[0]=1;\\n        long prev=1;\\n        long curr=0;\\n        for (int i = 1; i <= rowIndex; i++) {\\n            for (int j = 1; j <i ; j++) {\\n                curr=dp[j];\\n                dp[j]=(int)(prev+curr);\\n                prev=curr;\\n            }\\n            dp[i]=1;\\n        }\\n        return Arrays.asList(dp);\\n    }\\n```\n```\\npublic List<Integer> getRow(int rowIndex) {\\n        List<Integer> rowVal=new ArrayList<>();\\n        long val=1;\\n        for (int i = 0; i <= rowIndex; i++) {\\n            rowVal.add((int)val);\\n            val=val*(rowIndex-i)/(i+1);\\n        }\\n        return rowVal;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1594620,
                "title": "c-easy-to-understand-faster-than-100-0ms",
                "content": "class Solution {\\npublic:\\n    vector<int> getRow(int n) \\n    {\\n*         vector<vector<int>> ans;\\n        ans.push_back({1});                // 0th row\\n        ans.push_back({1,1});            // 1st row\\n        \\n        // now build the pascle traingle from the 2nd row till nth row\\n        for(int i=2;i<=n;i++)\\n        {\\n            vector<int> v;              // i th row vector\\n            v.push_back(1);             // first eleement of i th row \\n            \\n            for(int j=1;j<i;j++)\\n            {\\n                int k=ans[i-1][j-1]+ans[i-1][j];\\n                v.push_back(k);\\n            }\\n            v.push_back(1);                        // last element of i th row \\n            ans.push_back(v);\\n        }\\n        return ans[n];\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> getRow(int n) \\n    {\\n*         vector<vector<int>> ans;\\n        ans.push_back({1}",
                "codeTag": "Java"
            },
            {
                "id": 1432491,
                "title": "runtime-0-ms-faster-than-100-00-of-c-online-submissions-for-pascal-s-triangle-ii",
                "content": "# Easy solution using simple mathematical formula\\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int k) {\\n    long long n=1;\\n    vector<int> ans;\\n        for(int i=0;i<=k;i++){\\n            ans.push_back(n);\\n            n=n*(k-i)/(i+1);    //maths\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease upvote if you find it helpful :)",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int k) {\\n    long long n=1;\\n    vector<int> ans;\\n        for(int i=0;i<=k;i++){\\n            ans.push_back(n);\\n            n=n*(k-i)/(i+1);    //maths\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1338801,
                "title": "c-code-beats-100-in-speed-simple-math",
                "content": "//            1           -> row 0\\n//         1   1         -> row 1\\n//         1   2   1       -> row 2\\n//       1   3   3   1     -> row 3\\n//     1   4   6   4   1   -> row 4       \\n//       By analyzing the row of pascal triangle we can find that every element of row-index row (0-indexed) \\n//          and column-index col (0-indexed)  can be find by using formula C(row,col) i.e. combination(row,col)\\n               \\n//                 C(n,r) = n! / ( r! * (n -r)!) \\n                        \\n//                         = (n*(n-1).... r terms) / (r*(r-1)*(r-2)....1)     short form \\n                \\n//                 Example : C(6,3) = (6 * 5 * 4)/(3 * 2 * 1) = 20\\n\\n//  We are using the same method in this solution to find the element of pascal triangle \\n        \\n```\\nvector<int> getRow(int rowIndex) {    \\n        vector<int> result;\\n        long int temp = rowIndex;\\n        int a=rowIndex, b=1;\\n        for(int i=0;i<rowIndex+1;i++){\\n            if(i==0 || i==rowIndex) result.push_back(1);\\n            else {\\n                result.push_back(temp);\\n                temp = (temp*(--a))/++b; \\n            }\\n        }\\n        return result;\\n    }\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> getRow(int rowIndex) {    \\n        vector<int> result;\\n        long int temp = rowIndex;\\n        int a=rowIndex, b=1;\\n        for(int i=0;i<rowIndex+1;i++){\\n            if(i==0 || i==rowIndex) result.push_back(1);\\n            else {\\n                result.push_back(temp);\\n                temp = (temp*(--a))/++b; \\n            }\\n        }\\n        return result;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1336265,
                "title": "my-solution-in-o-n-based-on-properties-of-pascals-s-triangle",
                "content": "The property of pascal triangle used here is Nc(R+1) = NcR * (N-R)/(R+1) where N is the row number 0-indexed and R is the column number also 0-indexed.\\n\\nYou can derive the formulae for yourself by doing some simple math after expanding Nc(R+1).\\n\\n\\n```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n    List<Integer> list = new ArrayList<>();\\n    \\n    list.add(1);\\n    for(int i=1; i<=rowIndex; i++){\\n        long factor = (long)list.get(i-1) * (long)(rowIndex-(i-1));\\n        long num = factor/i;\\n        list.add((int)num);\\n    }\\n    return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n    List<Integer> list = new ArrayList<>();\\n    \\n    list.add(1);\\n    for(int i=1; i<=rowIndex; i++){\\n        long factor = (long)list.get(i-1) * (long)(rowIndex-(i-1));\\n        long num = factor/i;\\n        list.add((int)num);\\n    }\\n    return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1323926,
                "title": "various-solutions-with-python-implementation",
                "content": "## Solution#1 - Using Recursion\\n* We can get the `j`th element in `i`th row using the following recurrence:\\n\\t* Recurrence: `f(i, j) = f(i-1, j-1) + f(i-1, j)`\\n\\t* Base cases: `f(0, j) = f(i, 0) = f(i, j) = 1`\\n* We have to use memoization/caching to save repeated work\\n* Time Complexity: `O(n^2)` where `n = rowIndex`\\n\\t* It computes all the values of the pascal triangle upto the row queried.\\n* Space Complexity: `O(n)` \\n\\t* Stores only the required row.\\n\\t* I believe stack space used is also `O(n)` as at any time there won\\'t be more than `n` recursive calls in the stack\\n```\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        \\n        @cache\\n        def get(i,j):            \\n            if i == 0 or j == 0 or j == i: return 1\\n            return get(i-1,j-1) + get(i-1,j)\\n        \\n        return [get(rowIndex,j) for j in range(rowIndex+1)]\\n```\\n## Solution#2 - Iterative \\n* Same approach as the recursive solution, but implemented in an iterative way.\\n* Time Complexity: `O(n^2)` where `n = rowIndex`\\n\\t* Two nested `O(n)` for loops\\n* Space Complexity: `O(n)` \\n\\t* Stores only the required row.\\n\\n```\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        row = [1]*(rowIndex+1)\\n        for i in range(1, rowIndex):\\n            for j in range(i, 0, -1):\\n                row[j] = row[j-1]+row[j]\\n        return row\\n```\\n\\n## Solution #3 - Using Binomial Coefficients\\n* `nCr = C(n, r)` = number of ways to choose `r` items from a set of `n` items (amonth many other interpretations)\\n* `iCj = C(i, j)` is the `j`th element in the `i`th row of the pascal triangle\\n* Time Complexity: `O(n)` where `n = rowIndex`\\n\\t* We directly compute elements of the required row\\n* Space Complexity: `O(n)` \\n\\t* Stores only the required row.\\n* We compute `nCr = n!/(r!*(n-r)!) = (n * n-1 * n-2 * ....) / (1 * 2 * 3 * ...)`\\n```\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        \\'\\'\\'\\n        using C(n, r) = n!/(r!*(n-r)!)\\n        row-0: C(0,0)\\n        row-1: C(1,0) C(1,1)\\n        row-2: C(2,0) C(2,1) C(2,2)\\n        row-3: C(3,0) C(3,1) C(3,2) C(3,3)\\n        row-4: C(4,0) C(4,1) C(4,2) C(4,3) C(4,4)\\n        \\'\\'\\'\\n        answer = [1]\\n        numerator = rowIndex\\n        denominator = 1\\n        while numerator:\\n            answer.append(answer[-1] * numerator//denominator)\\n            denominator += 1\\n            numerator -= 1\\n        return answer\\n```\\n* To write the same thing in a more compact way:\\n```\\n    def getRow(self, R: int) -> List[int]:\\n        row = [1]\\n        for i in range(R):\\n            row.append(row[-1]*(R-i)//(i+1))\\n        return row\\n```\\n\\n## Solution #4 - Pairwise Sum of two lists\\n* Pairwise sum of two lists is denoted by # below\\n* We can generate a row from the previous row in the following way:\\n\\t* Row#0  `[1]`\\n\\t* Row#1  `[0,1] # [1,0] = [1,1]`\\n\\t* Row#2  `[0,1,1] # [1,1,0] = [1,2,1]`\\n\\t* Row#3  `[0,1,2,1] # [1,2,1,0] = [1,3,3,1]`\\n\\t* Row#4  `[0,1,3,3,1] # [1,3,3,1,0] = [1,4,6,4,1]`\\n\\t* and so on .......\\n* Time Complexity: `O(n^2)` where `n = rowIndex`\\n\\t* We are essentially computing all previous rows to arrive to the required row\\n* Space Complexity: `O(n)` \\n\\t* Needs storage for two (or three) lists of `O(n)` length each.\\n\\n```\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        row = [1]\\n        for _ in range(rowIndex): \\n            row = [x+y for x, y in zip([0]+row, row+[0])]\\n        return row\\n```\\n## Solution#5 - Using the Power of 1000...0001\\n* Every row of the pascal triangle has an interesting relationship with powers of 11, 101, 1001, etc.\\n* This allows us to generate the row using the power `100..001^rowIndex`\\n* Let\\'s take an example:\\n\\t* `rowIndex = 6`\\n\\t* `num = 10^6+1 = 1000001`\\n\\t* `string = num^6 = 1000001^6 = 1000006000015000020000015000006000001`\\n\\t* Split this string into chunks of length `6` from the end (leaving the leading 1 alone)\\n\\t* chunks: `1 000006 000015 000020 000015 000006 000001`\\n\\t* convert these chunks to integers: `1 6 15 20 15 6 1`\\n\\t* This gives us the pascal triangle row #6\\n* Time Complexity: `O(n^2)` where `n = rowIndex`\\n\\t* We are directly computing the elements of the required row\\n\\t* However, we have to process a string of length `1+n^2`\\n* Space Complexity: `O(n^2)` \\n\\t* To store the string of length `1+n^2`\\n* *Note:* Complexity of computing `(1+10^n)^n` renders this solution inefficient and impractical.\\n```\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        if rowIndex == 0 : return [1]\\n        num = 10**rowIndex+1\\n        string = str(num**rowIndex)\\n        row = [1]\\n        # for j in range(1, len(string), rowIndex):\\n        #     row.append(int(string[j:j+rowIndex])\\n        # return row\\n        return [1] + [int(string[j:j+rowIndex]) for j in range(1, len(string), rowIndex)]\\n```\\n\\n### A Possible Solution using 11^n ???\\n**THIS IS NOT A SOLUTION, IT\\'S STILL JUST AN IDEA**\\n* It\\'s a well known fact that every row of pascal triangle corresponds to a power of 11.\\n\\t* Row#0 `11^0 = 1`\\n\\t* Row#1  `11^1 = 11`\\n\\t* Row#2  `11^2 = 121`\\n\\t* Row#3  `11^3 = 1331`\\n\\t* Row#4  `11^4 = 14641`\\n* However things get tricky beyond this. You have to carry over the digits other than the unit digit to the previous element and so on.\\n\\t* Row#5 `1 5 10 10 5 1 >> 161051 = 11^5`\\n* If this process is reversible, it may allow us to compute the `n`th row using the digits of `11^n`.\\n* We have to only compute the first `n/2` numbers.\\n* Following is my attempt to figure this out that works only till `n=7` after which it produces incorrect results. If someone can figure it out, please post in comments. I am unlikely to spend more time on this problem.\\n```\\n    # WORK IN PROGRESS\\n\\t# Following works only upto rowIndex = 7\\n    def getRow_power11(self, rowIndex: int) -> List[int]:\\n        row = []\\n        power11 = 11**rowIndex\\n        for _ in range(1+rowIndex//2):\\n            a = power11%10\\n            power11 = power11//10\\n            # TODO: figure out a way to adjust the \"a\" by borrowing from higher digits\\n            while len(row) > 1 and (a - row[-1]) < (row[-1] - row[-2]):\\n                a += 10\\n                power11 -= 1\\n            row.append(a)\\n        return row + row[:rowIndex//2][::-1]    \\n```\\n\\n*Comments and feedback are welcome*",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        \\n        @cache\\n        def get(i,j):            \\n            if i == 0 or j == 0 or j == i: return 1\\n            return get(i-1,j-1) + get(i-1,j)\\n        \\n        return [get(rowIndex,j) for j in range(rowIndex+1)]\\n```\n```\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        row = [1]*(rowIndex+1)\\n        for i in range(1, rowIndex):\\n            for j in range(i, 0, -1):\\n                row[j] = row[j-1]+row[j]\\n        return row\\n```\n```\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        \\'\\'\\'\\n        using C(n, r) = n!/(r!*(n-r)!)\\n        row-0: C(0,0)\\n        row-1: C(1,0) C(1,1)\\n        row-2: C(2,0) C(2,1) C(2,2)\\n        row-3: C(3,0) C(3,1) C(3,2) C(3,3)\\n        row-4: C(4,0) C(4,1) C(4,2) C(4,3) C(4,4)\\n        \\'\\'\\'\\n        answer = [1]\\n        numerator = rowIndex\\n        denominator = 1\\n        while numerator:\\n            answer.append(answer[-1] * numerator//denominator)\\n            denominator += 1\\n            numerator -= 1\\n        return answer\\n```\n```\\n    def getRow(self, R: int) -> List[int]:\\n        row = [1]\\n        for i in range(R):\\n            row.append(row[-1]*(R-i)//(i+1))\\n        return row\\n```\n```\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        row = [1]\\n        for _ in range(rowIndex): \\n            row = [x+y for x, y in zip([0]+row, row+[0])]\\n        return row\\n```\n```\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        if rowIndex == 0 : return [1]\\n        num = 10**rowIndex+1\\n        string = str(num**rowIndex)\\n        row = [1]\\n        # for j in range(1, len(string), rowIndex):\\n        #     row.append(int(string[j:j+rowIndex])\\n        # return row\\n        return [1] + [int(string[j:j+rowIndex]) for j in range(1, len(string), rowIndex)]\\n```\n```\\n    # WORK IN PROGRESS\\n\\t# Following works only upto rowIndex = 7\\n    def getRow_power11(self, rowIndex: int) -> List[int]:\\n        row = []\\n        power11 = 11**rowIndex\\n        for _ in range(1+rowIndex//2):\\n            a = power11%10\\n            power11 = power11//10\\n            # TODO: figure out a way to adjust the \"a\" by borrowing from higher digits\\n            while len(row) > 1 and (a - row[-1]) < (row[-1] - row[-2]):\\n                a += 10\\n                power11 -= 1\\n            row.append(a)\\n        return row + row[:rowIndex//2][::-1]    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1078617,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public IList<int> GetRow(int rowIndex) {\\n        IList<int> prev = new List<int> { 1 };\\n        \\n        for (int i = 1; i <= rowIndex; i++)\\n        {\\n            IList<int> cur = new List<int> { 1 };\\n            \\n            for (int j = 1; j < i; j++)\\n                cur.Add(prev[j - 1] + prev[j]);\\n            \\n            cur.Add(1);\\n            \\n            prev = cur;\\n        }\\n        \\n        return prev;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public IList<int> GetRow(int rowIndex) {\\n        IList<int> prev = new List<int> { 1 }",
                "codeTag": "Java"
            },
            {
                "id": 912314,
                "title": "java-beats-100",
                "content": "Java beats 100%  \\nMemory Usage: 37 MB\\n\\n```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n      int [][] pascal = new int [rowIndex+1][rowIndex+1];\\n        \\n      pascal[0][0]=1;\\n      for(int i=1;i<=rowIndex;i++){\\n          for(int j=0;j<=rowIndex;j++){\\n              \\n              if(i==j)\\n                  pascal[i][j]=1;  \\n              \\n             else if(j==0)\\n                   pascal[i][j]=1;\\n            \\n              else{\\n                   pascal[i][j]= pascal[i-1][j-1]+pascal[i-1][j];\\n              }\\n              \\n          }\\n        } \\n        \\n        List<Integer>answer = new ArrayList<>(); \\n        for(int i=0;i<=rowIndex;i++){\\n                answer.add(pascal[rowIndex][i]);\\n        }\\n        \\n        return answer;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n      int [][] pascal = new int [rowIndex+1][rowIndex+1];\\n        \\n      pascal[0][0]=1;\\n      for(int i=1;i<=rowIndex;i++){\\n          for(int j=0;j<=rowIndex;j++){\\n              \\n              if(i==j)\\n                  pascal[i][j]=1;  \\n              \\n             else if(j==0)\\n                   pascal[i][j]=1;\\n            \\n              else{\\n                   pascal[i][j]= pascal[i-1][j-1]+pascal[i-1][j];\\n              }\\n              \\n          }\\n        } \\n        \\n        List<Integer>answer = new ArrayList<>(); \\n        for(int i=0;i<=rowIndex;i++){\\n                answer.add(pascal[rowIndex][i]);\\n        }\\n        \\n        return answer;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 787469,
                "title": "java-clean-code-easy-to-understand",
                "content": "```\\nclass Solution {\\n\\t\\n\\tpublic List<Integer> getRow (int rowIndex) {\\n\\t\\t\\n\\t\\tList<Integer> ans = new ArrayList <>();\\n\\t\\tans.add (1);\\n\\t\\t\\n\\t\\tfor (int row = 1; row <= rowIndex; row++) {\\n\\t\\t\\tList<Integer> list = new ArrayList <>();\\n\\t\\t\\tlist.add (1);\\n\\t\\t\\tfor (int col = 1; col < row; col++) {\\n\\t\\t\\t\\tlist.add (ans.get (col - 1) + ans.get (col));\\n\\t\\t\\t}\\n\\t\\t\\tlist.add (1);\\n\\t\\t\\tans.clear ();\\n\\t\\t\\tans.addAll (list);\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn ans;\\n\\t}\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t\\n\\tpublic List<Integer> getRow (int rowIndex) {\\n\\t\\t\\n\\t\\tList<Integer> ans = new ArrayList <>();\\n\\t\\tans.add (1);\\n\\t\\t\\n\\t\\tfor (int row = 1; row <= rowIndex; row++) {\\n\\t\\t\\tList<Integer> list = new ArrayList <>();\\n\\t\\t\\tlist.add (1);\\n\\t\\t\\tfor (int col = 1; col < row; col++) {\\n\\t\\t\\t\\tlist.add (ans.get (col - 1) + ans.get (col));\\n\\t\\t\\t}\\n\\t\\t\\tlist.add (1);\\n\\t\\t\\tans.clear ();\\n\\t\\t\\tans.addAll (list);\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 659031,
                "title": "clean-java-recursive-solution",
                "content": "```\\n    public List<Integer> getRow(int i) {\\n        if(i  < 0) return new ArrayList();\\n        if(i == 0) return Arrays.asList(1);\\n        if(i == 1) return Arrays.asList(1,1);\\n\\n        List<Integer> op = getRow(i-1);\\n        List<Integer> last = new ArrayList<>(Arrays.asList(1));\\n        for (int j = 0; j < op.size() - 1; j++){\\n            last.add(op.get(j) + op.get(j + 1));\\n        }\\n        last.add(1);\\n        return last; \\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n    public List<Integer> getRow(int i) {\\n        if(i  < 0) return new ArrayList();\\n        if(i == 0) return Arrays.asList(1);\\n        if(i == 1) return Arrays.asList(1,1);\\n\\n        List<Integer> op = getRow(i-1);\\n        List<Integer> last = new ArrayList<>(Arrays.asList(1));\\n        for (int j = 0; j < op.size() - 1; j++){\\n            last.add(op.get(j) + op.get(j + 1));\\n        }\\n        last.add(1);\\n        return last; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 629622,
                "title": "math-formula-based-rust-solution",
                "content": "Procedural:\\n```rust\\nimpl Solution {\\n    pub fn get_row(row_index: i32) -> Vec<i32> {\\n        let row_index = row_index as usize;\\n        let mut res = vec![];\\n        res.push(1);\\n        \\n        for i in 1..row_index + 1 {\\n            let tmp = res[i - 1] as usize * (row_index + 1 - i) / i;\\n            res.push(tmp as i32);\\n        }\\n\\n        res\\n    }\\n}\\n```\\n\\nFunctional:\\n```rust\\nuse std::iter;\\n\\nimpl Solution {\\n    pub fn get_row(row_index: i32) -> Vec<i32> {\\n        let row_index = row_index as usize;\\n\\n        iter::once(1)\\n            .chain((1..row_index + 1).scan(1, |prev, i| {\\n                *prev = (*prev as usize * (row_index + 1 - i) / i) as i32;\\n                Some(*prev)\\n            }))\\n            .collect::<Vec<_>>()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn get_row(row_index: i32) -> Vec<i32> {\\n        let row_index = row_index as usize;\\n        let mut res = vec![];\\n        res.push(1);\\n        \\n        for i in 1..row_index + 1 {\\n            let tmp = res[i - 1] as usize * (row_index + 1 - i) / i;\\n            res.push(tmp as i32);\\n        }\\n\\n        res\\n    }\\n}\\n```\n```rust\\nuse std::iter;\\n\\nimpl Solution {\\n    pub fn get_row(row_index: i32) -> Vec<i32> {\\n        let row_index = row_index as usize;\\n\\n        iter::once(1)\\n            .chain((1..row_index + 1).scan(1, |prev, i| {\\n                *prev = (*prev as usize * (row_index + 1 - i) / i) as i32;\\n                Some(*prev)\\n            }))\\n            .collect::<Vec<_>>()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 622596,
                "title": "recursion-with-memoization",
                "content": "Assume that row numbering starts at 1. This will make calculations easy.\\n\\nRecurrence relation:\\n*f(r, c) = f(r-1, c-1) + f(r-1, c)*\\n\\nBase case:\\n*f(r, c) = 1* when r == c or when c = 1\\n\\nWe use memoization as we will make same function calls a number of times\\n\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        rowIndex += 1\\n        \\n        mem = {}\\n        \\n        def getVal(row, col):\\n            if col == 1 or col == row:\\n                return 1\\n            else:\\n                if (row-1, col-1) not in mem:\\n                    mem[(row-1, col-1)] = getVal(row-1, col-1)\\n                v1 = mem[(row-1, col-1)]\\n                \\n                if (row-1, col) not in mem:\\n                    mem[(row-1, col)] = getVal(row-1, col)\\n                v2 = mem[(row-1, col)]\\n                \\n                return v1 + v2\\n        \\n        ans = []\\n        \\n        for i in range(1, rowIndex+1):\\n            ans.append(getVal(rowIndex, i))\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        rowIndex += 1\\n        \\n        mem = {}\\n        \\n        def getVal(row, col):\\n            if col == 1 or col == row:\\n                return 1\\n            else:\\n                if (row-1, col-1) not in mem:\\n                    mem[(row-1, col-1)] = getVal(row-1, col-1)\\n                v1 = mem[(row-1, col-1)]\\n                \\n                if (row-1, col) not in mem:\\n                    mem[(row-1, col)] = getVal(row-1, col)\\n                v2 = mem[(row-1, col)]\\n                \\n                return v1 + v2\\n        \\n        ans = []\\n        \\n        for i in range(1, rowIndex+1):\\n            ans.append(getVal(rowIndex, i))\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 439748,
                "title": "readable-python3-code-o-k-extra-space",
                "content": "This is very similar to question [#118, Pascal\\'s Triangle](https://leetcode.com/problems/pascals-triangle/solution/), but we only need to return the last row, not the whole triangle. Therefore, we do not need to store the whole triangle. It\\'s enough to keep track of the previous row and then calculate the elements of current row based on the previous row. At the end of each main loop, we update the previous row (now it is equal to current row).\\n\\n```\\n        if not rowIndex: return [1]\\n        for i in range(1,rowIndex+1):\\n            row = [1]\\n            for j in range(1,i):\\n                row.append(prev_row[j-1] + prev_row[j]) \\n            row.append(1)\\n            prev_row = row\\n        return row  \\n```",
                "solutionTags": [],
                "code": "```\\n        if not rowIndex: return [1]\\n        for i in range(1,rowIndex+1):\\n            row = [1]\\n            for j in range(1,i):\\n                row.append(prev_row[j-1] + prev_row[j]) \\n            row.append(1)\\n            prev_row = row\\n        return row  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 296455,
                "title": "c-concise-beatss-100",
                "content": "```\\npublic class Solution {\\n    public IList<int> GetRow(int rowIndex) {\\n        var result = new List<int>() {1};\\n        for (int i = 0; i < rowIndex; i++) {\\n            var arr = new List<int>(){1};\\n            arr.AddRange(result.Zip(result.Skip(1), (a, b) => a + b));\\n            arr.Add(1);\\n            result = arr;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<int> GetRow(int rowIndex) {\\n        var result = new List<int>() {1};\\n        for (int i = 0; i < rowIndex; i++) {\\n            var arr = new List<int>(){1};\\n            arr.AddRange(result.Zip(result.Skip(1), (a, b) => a + b));\\n            arr.Add(1);\\n            result = arr;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 210571,
                "title": "simple-python-solution",
                "content": "``` python\\nclass Solution:\\n    def getRow(self, rowIndex):\\n        \"\"\"\\n        :type rowIndex: int\\n        :rtype: List[int]\\n        \"\"\"\\n        ans = [1] * (rowIndex + 1)\\n        \\n        for row in range(2, rowIndex + 1):\\n            for idx in reversed(range(1, row)):\\n                ans[idx] += ans[idx - 1]\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "``` python\\nclass Solution:\\n    def getRow(self, rowIndex):\\n        \"\"\"\\n        :type rowIndex: int\\n        :rtype: List[int]\\n        \"\"\"\\n        ans = [1] * (rowIndex + 1)\\n        \\n        for row in range(2, rowIndex + 1):\\n            for idx in reversed(range(1, row)):\\n                ans[idx] += ans[idx - 1]\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163223,
                "title": "o-k-extra-space-go-solution",
                "content": "if we know the k-1 row, we can get k row.\\nif rowIndex = 1, because rowIndex starts from 0,  my code run like this: \\n\\ni = 0, result is : 1 0 0 \\ni = 1, j = 1, result is : 1 1 0 \\ni = 2, j = 2, result is : 1 1 1\\ni = 2, j = 1, result is : 1 2 1, end the loop \\n\\nHere is my code:\\n```\\nfunc getRow(rowIndex int) []int {\\n    // rowIndex start from 0\\n    rowIndex = rowIndex+1\\n    \\n\\tresult := make([]int, rowIndex)\\n\\tfor i := 0; i < rowIndex; i++ {\\n\\t\\tif i == 0 {\\n\\t\\t\\tresult[i] = 1\\n\\t\\t} else {\\n\\t\\t\\tfor j := rowIndex - 1; j > 0; j-- {\\n\\t\\t\\t\\tresult[j] += result[j-1]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc getRow(rowIndex int) []int {\\n    // rowIndex start from 0\\n    rowIndex = rowIndex+1\\n    \\n\\tresult := make([]int, rowIndex)\\n\\tfor i := 0; i < rowIndex; i++ {\\n\\t\\tif i == 0 {\\n\\t\\t\\tresult[i] = 1\\n\\t\\t} else {\\n\\t\\t\\tfor j := rowIndex - 1; j > 0; j-- {\\n\\t\\t\\t\\tresult[j] += result[j-1]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 38551,
                "title": "java-o-k-concise-solution",
                "content": "    \\n    public List<Integer> getRow(int rowIndex) {\\n        List<Integer> ret = new ArrayList<>(Collections.nCopies(rowIndex+1, 1));\\n        for (int i = 1; i < rowIndex; i++) {\\n            for (int j = rowIndex-i; j < rowIndex; j++) // from left to right\\n                ret.set(j, ret.get(j) + ret.get(j+1));\\n        }\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    \\n    public List<Integer> getRow(int rowIndex) {\\n        List<Integer> ret = new ArrayList<>(Collections.nCopies(rowIndex+1, 1));\\n        for (int i = 1; i < rowIndex; i++) {\\n            for (int j = rowIndex-i; j < rowIndex; j++) // from left to right\\n                ret.set(j, ret.get(j) + ret.get(j+1));\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 38588,
                "title": "10-lines-0ms-c-solution",
                "content": "    vector<int> getRow(int rowIndex) {\\n        vector<int> pascal(rowIndex+1, 0);\\n        pascal[0]=1;\\n        for(int i=1; i<rowIndex+1; ++i){\\n            for(int j=i; j>0; j--){\\n                pascal[j] += pascal[j-1];\\n            }\\n        }\\n        return pascal;\\n    }",
                "solutionTags": [],
                "code": "    vector<int> getRow(int rowIndex) {\\n        vector<int> pascal(rowIndex+1, 0);\\n        pascal[0]=1;\\n        for(int i=1; i<rowIndex+1; ++i){\\n            for(int j=i; j>0; j--){\\n                pascal[j] += pascal[j-1];\\n            }\\n        }\\n        return pascal;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 38665,
                "title": "2ms-short-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<int> getRow(int rowIndex) {\\n            vector<int> result(1,1);\\n            for(int i=1; i<=rowIndex; i++) {\\n                result.push_back(1);\\n                for(int j=result.size()-2; j>0; j--)\\n                    result[j] += result[j-1];\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> getRow(int rowIndex) {\\n            vector<int> result(1,1);\\n            for(int i=1; i<=rowIndex; i++) {\\n                result.push_back(1);\\n                for(int j=result.size()-2; j>0; j--)\\n                    result[j] += result[j-1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 38641,
                "title": "pascal-s-triangle-ii-with-o-1-space",
                "content": "I got an answer with O(1) space.\\n\\nThe idea is that, for n-th row, the value at col j is (n,j) (I mean n choose j here).\\nAnd we have (n,j) = (n, j-1) * (n-j+1) / j. \\n\\nThen we can have the solution as below:\\n\\n    class Solution {\\n    public:\\n        vector<int> getRow(int rowIndex) {\\n            vector<int> res;\\n            if (rowIndex >= 0) {\\n                res.push_back(1);\\n            }\\n            for (int j = 1; j <= rowIndex; j++) {\\n                res.push_back((double)res.back() * (double)(rowIndex - j + 1) / (double)j);\\n            }\\n            return res;\\n        }\\n    };\\n\\nOne further question I'm wondering is, is it possible eliminate type cast here (which was to avoid overflow)?",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> getRow(int rowIndex) {\\n            vector<int> res;\\n            if (rowIndex >= 0) {\\n                res.push_back(1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4081687,
                "title": "100-faster-5-line-code-o-n-derived-easy-permutation-formula",
                "content": "Video Link :\\n\\n[https://youtu.be/LgLcWJrfLmQ?si=MCCrgzemn2LJoaI6]()\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n      vector<int>res;\\n      long long factor = 1 ;\\n      for(int i = 0 ; i <= rowIndex ; i++){\\n        res.push_back(factor);\\n        factor = factor * (rowIndex - i)/(i+1);\\n      }\\n      return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n      vector<int>res;\\n      long long factor = 1 ;\\n      for(int i = 0 ; i <= rowIndex ; i++){\\n        res.push_back(factor);\\n        factor = factor * (rowIndex - i)/(i+1);\\n      }\\n      return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721617,
                "title": "python-simple-and-clean-beats-88",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n# Intuition\\nThe problem asks us to return the `rowIndex`th row of Pascal\\'s triangle. Pascal\\'s triangle is a triangle of numbers where each number is the sum of the two numbers directly above it. The first two rows are always `[1]` and `[1,1]`. We can use this information to generate subsequent rows until we reach the desired row.\\n\\n# Approach\\n1. Initialize a `triangle` list with the first two rows of Pascal\\'s triangle: `[[1],[1,1]]`.\\n2. Check if `rowIndex` is 0 or 1, and return the corresponding row if it is.\\n3. Initialize an empty list `curr` to store the current row, and a list `prev` to store the previous row.\\n4. Use a while loop to iterate from 2 to `rowIndex`, inclusive.\\n5. For each iteration, use a for loop to iterate from 0 to `i+1`, where `i` is the current row index.\\n6. If `j` (the current column index) is 0 or `i`, append 1 to `curr`.\\n7. Otherwise, append the sum of the two numbers directly above (`prev[j-1]` and `prev[j]`) to `curr`.\\n8. Set `prev` to `curr`, and reset `curr` to an empty list.\\n9. Return `prev`.\\n\\n# Complexity\\n- Time complexity: $$O(rowIndex^2)$$\\n- Space complexity: $$O(rowIndex)$$\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        triangle = [[1],[1,1]]\\n        if rowIndex==0:\\n            return triangle[0]\\n        if rowIndex==1:\\n            return triangle[1]\\n        curr = []\\n        prev = [1,1]\\n        i = 2\\n        while i<=rowIndex:\\n            for j in range(i+1):\\n                if j==0 or j==i:\\n                    curr.append(1)\\n                else:\\n                    curr.append(prev[j-1]+prev[j])\\n            prev = curr\\n            curr = []\\n            i+=1\\n        return prev\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        triangle = [[1],[1,1]]\\n        if rowIndex==0:\\n            return triangle[0]\\n        if rowIndex==1:\\n            return triangle[1]\\n        curr = []\\n        prev = [1,1]\\n        i = 2\\n        while i<=rowIndex:\\n            for j in range(i+1):\\n                if j==0 or j==i:\\n                    curr.append(1)\\n                else:\\n                    curr.append(prev[j-1]+prev[j])\\n            prev = curr\\n            curr = []\\n            i+=1\\n        return prev\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532948,
                "title": "pascal-s-triangle-ii-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int i, j;\\n        vector<vector<int>> ans;\\n        vector<int> arr;\\n        for(i=0 ; i<=rowIndex ; i++)\\n        {\\n            if(i==0)\\n            {\\n                arr.push_back(1);\\n            }\\n            else if(i==1)\\n            {\\n                arr.push_back(1);\\n                arr.push_back(1);\\n            }\\n            else\\n            {\\n                arr.push_back(1);\\n                for(j=1 ; j<i ; j++)\\n                {\\n                    arr.push_back(ans[i-1][j-1]+ans[i-1][j]);\\n                }\\n                arr.push_back(1);\\n            }\\n            ans.push_back(arr);\\n            arr.clear();\\n        }\\n        return ans[rowIndex];\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/a7be070f-bc82-4f27-af71-370e04889b67_1684296650.9412372.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int i, j;\\n        vector<vector<int>> ans;\\n        vector<int> arr;\\n        for(i=0 ; i<=rowIndex ; i++)\\n        {\\n            if(i==0)\\n            {\\n                arr.push_back(1);\\n            }\\n            else if(i==1)\\n            {\\n                arr.push_back(1);\\n                arr.push_back(1);\\n            }\\n            else\\n            {\\n                arr.push_back(1);\\n                for(j=1 ; j<i ; j++)\\n                {\\n                    arr.push_back(ans[i-1][j-1]+ans[i-1][j]);\\n                }\\n                arr.push_back(1);\\n            }\\n            ans.push_back(arr);\\n            arr.clear();\\n        }\\n        return ans[rowIndex];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518583,
                "title": "java-solution-for-pascal-s-triangle-ii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code leverages the pattern observed in Pascal\\'s Triangle, where each element in a row can be obtained by adding the two elements directly above it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create an ArrayList named result to store the elements of the row.\\n2. Handle the edge case where rowIndex is less than 0 by returning an empty list.\\n3. Add the first element, which is always 1, to the result list.\\n4. Iterate from row 1 to rowIndex (inclusive):\\n- Within each row, iterate backwards starting from the second-to-last element to the first element.\\n- Update each element by setting it to the sum of the current element and the next element in the result list.\\n- This operation effectively calculates the value at each position in the current row using the values from the previous row.\\n5. After the inner loop completes, add the last element (which is always 1) to the result list.\\n6. Return the result list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the code is O(rowIndex^2). This is because for each row from 1 to rowIndex, the inner loop iterates from the second-to-last element to the first element, which takes roughly rowIndex/2 iterations on average. Therefore, the overall time complexity is proportional to the sum of 1 + 2 + 3 + ... + rowIndex, which is equivalent to rowIndex * (rowIndex + 1) / 2, resulting in O(rowIndex^2) time complexity.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(rowIndex) since the size of the result list is equal to rowIndex + 1, which stores the elements of the generated row. The additional space required is negligible compared to the size of the result list, making the space complexity O(rowIndex).  \\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        ArrayList<Integer> result = new ArrayList<Integer>();\\n        if (rowIndex < 0)\\n            return result;\\n        result.add(1);\\n        for (int i = 1; i <= rowIndex; i++) \\n        {\\n            for (int j = result.size() - 2; j >= 0; j--) \\n            {\\n                result.set(j + 1, result.get(j) + result.get(j + 1));\\n            }\\n            result.add(1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        ArrayList<Integer> result = new ArrayList<Integer>();\\n        if (rowIndex < 0)\\n            return result;\\n        result.add(1);\\n        for (int i = 1; i <= rowIndex; i++) \\n        {\\n            for (int j = result.size() - 2; j >= 0; j--) \\n            {\\n                result.set(j + 1, result.get(j) + result.get(j + 1));\\n            }\\n            result.add(1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303968,
                "title": "normal-math-approach-two-approches-python3",
                "content": "\\n# Brute Force\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        list1=[]\\n        for i in range(rowIndex+1):\\n            level=[]\\n            for j in range(i+1):\\n                if j==0 or j==i:\\n                    level.append(1)\\n                else:\\n                    level.append(list1[i-1][j-1]+list1[i-1][j])\\n            list1.append(level)\\n        return list1[-1]\\n```\\n# Smart Approches\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        def value(numRows,col):\\n            ans=1\\n            for i in range(col):\\n                ans=ans*(numRows-i)\\n                ans=ans//(i+1)\\n            return ans\\n        res=[]\\n        for k in range(1,rowIndex+):\\n            res.append(value(rowIndex,k-1))\\n        return res\\n            \\n  ```\\n # please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        list1=[]\\n        for i in range(rowIndex+1):\\n            level=[]\\n            for j in range(i+1):\\n                if j==0 or j==i:\\n                    level.append(1)\\n                else:\\n                    level.append(list1[i-1][j-1]+list1[i-1][j])\\n            list1.append(level)\\n        return list1[-1]\\n```\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        def value(numRows,col):\\n            ans=1\\n            for i in range(col):\\n                ans=ans*(numRows-i)\\n                ans=ans//(i+1)\\n            return ans\\n        res=[]\\n        for k in range(1,rowIndex+):\\n            res.append(value(rowIndex,k-1))\\n        return res\\n            \\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 3266408,
                "title": "iterative-o-n-solution-using-binomial-coefficients",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first thought that comes to mind is to straight up use the algorithm for constructing such triangle, from the problem\\'s description. But then, it is easy to realise, that there must be some kind of solution, which doesn\\'t require calculating all values in each row from top to bottom (which is O(n^2)).\\n\\nAfter a short while, I remembered, that the values in Pascal\\'s triangle are connected with a thing called Binomial coefficient.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nSince each value in such triangle can be calculated using the formula for binomial coefficient (n over k) = n! / (k! * (n-k)!), where n is the row of the Pascal\\'s triangle and k is the \"column\". \\n\\nExpanding the above formula and considering the fact, that the triangle is vertically symmetrical, each row can be expressed as:\\n\\n$$n! / (0! * (n-0)!)$$  |  $$n! / (1! * (n-1)!)$$  |  $$n! / (2! * (n-2)!)$$  ...  $$n! / ((1 + n//2)! * (n-(1 + n//2)!)$$   ...   $$n! / (2! * (n-2)!)$$  |  $$n! / (1! * (n-1)!)$$  |  $$n! / (0! * (n-0)!)$$\\n\\nand after manipulating the factorials:\\n\\n$$1 / 0!$$  |  $$n! / 1!$$  |  $$(n * (n-1)) / 2!$$   ...  $$(n * (n-1) * ... * (n//2)) / (1+n//2)!$$  ...   $$(n * (n-1)) / 2!  |  n! / 1!$$  |  $$1 / 0!$$\\n\\nIt can be noticed, that after calculating the first element of a given row, the i-th element can be calculated by multiplying the previous one by (n - i + 1) and dividing it by i (assuming the elements are indexed from 0).\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSince we only iterate over the row, we\\'re interested in, the time complexity is: $$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe only space we use, dependent on $$rowIndex$$ is the array, we\\'re supposed to return, the space complexity is: $$O(n)$$\\n# Code\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        ar = [1 for i in range(rowIndex + 1)]\\n        \\n        for i in range(1, rowIndex//2+1):\\n            ar[i] = ar[i-1] * (rowIndex - i + 1)//i\\n            ar[rowIndex - i] = ar[i]\\n      \\n        return ar\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        ar = [1 for i in range(rowIndex + 1)]\\n        \\n        for i in range(1, rowIndex//2+1):\\n            ar[i] = ar[i-1] * (rowIndex - i + 1)//i\\n            ar[rowIndex - i] = ar[i]\\n      \\n        return ar\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244594,
                "title": "o-n-solution-c-simple-approach",
                "content": "# Intuition Pascal\\'s Triangle II\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nutilizing the concept of nCr $${N}\\\\choose{k}\\n$$\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe know from binomial theorem that $${N}\\\\choose{R}\\n$$ = $${N}\\\\choose{N-R}$$  \\n1st element is 1 \\n2nd element is N\\n3rd element is N*(N-1)/2  ie a[1]*(N-1)/2\\n4th element is  N*(N-1)(N-3)/(2*3) ie a[3]*(n-2)/3 \\n\\nthis way we can build till (N+1)/2 th element then we can copy the value of rth to N-r index\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        if(rowIndex==0) return {1};\\n        if(rowIndex==1) return {1,1};\\n        vector<int> result(rowIndex+1, 1);\\n        int m=rowIndex/2;  //getting the mid element index as it\\'s zero based index. Had it been N given then (N+1)/2\\n        result[1]=rowIndex;\\n        for(int i=2; i<=m; i++ ){\\n            result[i] =( ((long)result[i-1]) * (rowIndex-i+1) )/i; //(used (long) to avoid Integer OverFlow)\\n        }\\n        int r=rowIndex;\\n        int l=0;\\n        while(r>l) result[r--]=result[l++]; // rth value to (N-r)\\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        if(rowIndex==0) return {1};\\n        if(rowIndex==1) return {1,1};\\n        vector<int> result(rowIndex+1, 1);\\n        int m=rowIndex/2;  //getting the mid element index as it\\'s zero based index. Had it been N given then (N+1)/2\\n        result[1]=rowIndex;\\n        for(int i=2; i<=m; i++ ){\\n            result[i] =( ((long)result[i-1]) * (rowIndex-i+1) )/i; //(used (long) to avoid Integer OverFlow)\\n        }\\n        int r=rowIndex;\\n        int l=0;\\n        while(r>l) result[r--]=result[l++]; // rth value to (N-r)\\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2988509,
                "title": "4-lines-java-code-with-readable-comments",
                "content": "```\\n    public List<Integer> getRow(int rowIndex) {\\n        // first we initialize arrayList\\n        List<Integer> list = new ArrayList<>();\\n        // iterate over list with respect to the rowIndex\\n        for (int i = 0; i <= rowIndex; i++) {\\n            // normaly add 1 at the starting\\n            list.add(0,1);\\n            // now this loop will remains last one\\'s(1)\\n            for(int j = 1; j < i; j ++) {\\n                // everytime set list to the new value\\n                list.set(j, list.get(j) + list.get(j + 1));\\n            }\\n        }\\n        return list;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public List<Integer> getRow(int rowIndex) {\\n        // first we initialize arrayList\\n        List<Integer> list = new ArrayList<>();\\n        // iterate over list with respect to the rowIndex\\n        for (int i = 0; i <= rowIndex; i++) {\\n            // normaly add 1 at the starting\\n            list.add(0,1);\\n            // now this loop will remains last one\\'s(1)\\n            for(int j = 1; j < i; j ++) {\\n                // everytime set list to the new value\\n                list.set(j, list.get(j) + list.get(j + 1));\\n            }\\n        }\\n        return list;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2986458,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<vector<int>> ans;\\n        for(int i=0; i<=rowIndex; i++) {\\n            vector<int> tmp;\\n            for(int j=0; j<=i; j++) tmp.push_back(1);\\n            ans.push_back(tmp);\\n        }\\n        for(int i=2; i<=rowIndex; i++) {\\n            for(int j=1; j<i; j++) {\\n                ans[i][j] = ans[i-1][j-1] + ans[i-1][j];\\n            }\\n        }\\n        return ans[rowIndex];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<vector<int>> ans;\\n        for(int i=0; i<=rowIndex; i++) {\\n            vector<int> tmp;\\n            for(int j=0; j<=i; j++) tmp.push_back(1);\\n            ans.push_back(tmp);\\n        }\\n        for(int i=2; i<=rowIndex; i++) {\\n            for(int j=1; j<i; j++) {\\n                ans[i][j] = ans[i-1][j-1] + ans[i-1][j];\\n            }\\n        }\\n        return ans[rowIndex];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938432,
                "title": "easy-solution-with-the-written-dry-run-photo",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<int>A(rowIndex+1,0);\\n        A[0]=1;\\n        for(int i=1;i<=rowIndex;++i){\\n            for(int j=i;j>=1;--j){\\n                A[j]+=A[j-1];\\n            }\\n        }\\n        return A;\\n    }\\n};\\n```\\n![WhatsApp Image 2022-12-22 at 3.02.14 PM.jpeg](https://assets.leetcode.com/users/images/5da9ef8b-22a4-42cf-8c3d-0812940d28a8_1671701567.4670691.jpeg)\\n![WhatsApp Image 2022-12-22 at 3.02.25 PM.jpeg](https://assets.leetcode.com/users/images/5e1ee3e1-6291-4e37-87eb-32136a1cc36f_1671701582.1436455.jpeg)\\n\\n***like it then UpVote***\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<int>A(rowIndex+1,0);\\n        A[0]=1;\\n        for(int i=1;i<=rowIndex;++i){\\n            for(int j=i;j>=1;--j){\\n                A[j]+=A[j-1];\\n            }\\n        }\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717014,
                "title": "easy-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n  vector<int> getRow(int rowIndex)\\n  {\\n  vector<vector<int>> result(rowIndex+1);\\n  int i;\\n  for(i=0;i<=rowIndex;i++)\\n  {\\n      result[i].resize(i+1);\\n      result[i][0]=result[i][i]=1;\\n      for(int j=1;j<i;j++)\\n      {\\n          result[i][j]=result[i-1][j-1]+result[i-1][j];\\n      }\\n  }\\n      return result[i-1]; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<int> getRow(int rowIndex)\\n  {\\n  vector<vector<int>> result(rowIndex+1);\\n  int i;\\n  for(i=0;i<=rowIndex;i++)\\n  {\\n      result[i].resize(i+1);\\n      result[i][0]=result[i][i]=1;\\n      for(int j=1;j<i;j++)\\n      {\\n          result[i][j]=result[i-1][j-1]+result[i-1][j];\\n      }\\n  }\\n      return result[i-1]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2601569,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        List<Integer> row, prev_row = null;\\n        List<Integer> res = new ArrayList<>();\\n        for(int i = 0; i <= rowIndex; i++){\\n            row = new ArrayList<>();\\n            for(int j = 0; j <= i; j++){\\n                if(j == 0 || j == i){\\n                    row.add(1);\\n                }else{\\n                    row.add(prev_row.get(j-1) + prev_row.get(j));\\n                }\\n            }\\n            prev_row = row;\\n            res = row;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        List<Integer> row, prev_row = null;\\n        List<Integer> res = new ArrayList<>();\\n        for(int i = 0; i <= rowIndex; i++){\\n            row = new ArrayList<>();\\n            for(int j = 0; j <= i; j++){\\n                if(j == 0 || j == i){\\n                    row.add(1);\\n                }else{\\n                    row.add(prev_row.get(j-1) + prev_row.get(j));\\n                }\\n            }\\n            prev_row = row;\\n            res = row;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586299,
                "title": "python3-solution-faster-than-94-4-using-binomial-theorem",
                "content": "Pascals triangle can also demonstrated through the used of combinations:\\n\\n\\t\\t\\t\\t\\t\\t1                                           0C0\\n\\t\\t\\t\\t\\t1      1                                   1C0      1C0\\n\\t\\t\\t\\t1       2     1                            2C0      2C1     2C2\\n\\t\\t\\t1      3       3     1                     3C0     3C1      3C2     3C3\\n\\t\\t\\t\\n\\nWhere nCr is equivilent to: n! / r! x (n - r)!\\n\\nnCr is a method of finding the number of combinations where repetition doesn\\'t matter for example you might use it to find the number of ways a committies could be chosen with a certain number of male and female members\\n\\nSolution:\\n\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n\\t\\tarr = []\\n\\n\\t\\t# Factorial function (e.g. 4! would be 4 x 3 x 2 x 1 and 6! would be 6 x 5 x 4 x 3 x 2 x 1 and 0! would be 1)\\n\\t\\tdef factorial(num):\\n\\t\\t\\tans = 1\\n\\t\\t\\tfor x in range(1, num+1):\\n\\t\\t\\t\\tans *= x\\n\\t\\t\\treturn ans\\n\\n\\t\\t# This is just the nCr formula from above\\n\\n\\t\\tdef nCr(n, r):\\n\\t\\t\\treturn int(factorial(n) / ((factorial(r)) * factorial(n - r)))\\n\\n\\n\\t\\tfor y in range(0, rowIndex + 1):\\n\\t\\t\\tarr.append(int(factorial(rowIndex) / ((factorial(y)) * factorial(rowIndex - y)))) # rowIndex represents n in the nCr formula and y represents r\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n\\t\\tarr = []\\n\\n\\t\\t# Factorial function (e.g. 4! would be 4 x 3 x 2 x 1 and 6! would be 6 x 5 x 4 x 3 x 2 x 1 and 0! would be 1)\\n\\t\\tdef factorial(num):\\n\\t\\t\\tans = 1\\n\\t\\t\\tfor x in range(1, num+1):\\n\\t\\t\\t\\tans *= x\\n\\t\\t\\treturn ans\\n\\n\\t\\t# This is just the nCr formula from above\\n\\n\\t\\tdef nCr(n, r):\\n\\t\\t\\treturn int(factorial(n) / ((factorial(r)) * factorial(n - r)))\\n\\n\\n\\t\\tfor y in range(0, rowIndex + 1):\\n\\t\\t\\tarr.append(int(factorial(rowIndex) / ((factorial(y)) * factorial(rowIndex - y)))) # rowIndex represents n in the nCr formula and y represents r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1862508,
                "title": "java-solution-simple",
                "content": "```\\nList<Integer> list = new ArrayList<Integer>();\\n        for(int i = 0;i<n+1;i++) {\\n                list.add(1);\\n                for(int j=i-1;j>0;j--) {\\n                    list.set(j, list.get(j-1)+list.get(j));\\n                }\\n        }\\n        return list;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nList<Integer> list = new ArrayList<Integer>();\\n        for(int i = 0;i<n+1;i++) {\\n                list.add(1);\\n                for(int j=i-1;j>0;j--) {\\n                    list.set(j, list.get(j-1)+list.get(j));\\n                }\\n        }\\n        return list;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1840543,
                "title": "rust-dp-without-extra-space",
                "content": "```rust\\nimpl Solution {\\n    pub fn get_row(row_index: i32) -> Vec<i32> {\\n        // 1 0 0 0\\n        // 1 1 0 0\\n        // 1 2 1 0\\n        // 1 3 3 1\\n        // f(x, y) = f(x - 1, y - 1) + f(x, y - 1)\\n\\n        let row_index = row_index as usize;\\n        let mut arr = vec![0; row_index + 1];\\n        arr[0] = 1;\\n\\n        for i in 1..arr.len() {\\n            for j in (1..=i).rev() {\\n                arr[j] = arr[j] + arr[j - 1]\\n            }\\n        }\\n\\n        arr\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn get_row(row_index: i32) -> Vec<i32> {\\n        // 1 0 0 0\\n        // 1 1 0 0\\n        // 1 2 1 0\\n        // 1 3 3 1\\n        // f(x, y) = f(x - 1, y - 1) + f(x, y - 1)\\n\\n        let row_index = row_index as usize;\\n        let mut arr = vec![0; row_index + 1];\\n        arr[0] = 1;\\n\\n        for i in 1..arr.len() {\\n            for j in (1..=i).rev() {\\n                arr[j] = arr[j] + arr[j - 1]\\n            }\\n        }\\n\\n        arr\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1788852,
                "title": "c-100-faster",
                "content": "```\\n vector<int> getRow(int row) {\\n        vector<vector<int>> v;\\n        \\n        for(int i=0;i<=row;++i)\\n        {\\n            vector<int> temp;\\n            for(int j=0;j<=i;++j)\\n            {\\n                if(j==0 || j==i)\\n                {\\n                    temp.push_back(1);\\n                }\\n                else\\n                    temp.push_back(v[i-1][j-1]+v[i-1][j]);\\n            }\\n            v.push_back(temp);\\n        }\\n        return v[row];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n vector<int> getRow(int row) {\\n        vector<vector<int>> v;\\n        \\n        for(int i=0;i<=row;++i)\\n        {\\n            vector<int> temp;\\n            for(int j=0;j<=i;++j)\\n            {\\n                if(j==0 || j==i)\\n                {\\n                    temp.push_back(1);\\n                }\\n                else\\n                    temp.push_back(v[i-1][j-1]+v[i-1][j]);\\n            }\\n            v.push_back(temp);\\n        }\\n        return v[row];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1764731,
                "title": "c-100-fast-o-n-solution-no-extra-space-with-simple-math-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/498f5e25-e3d6-46da-b657-71f503f048d1_1644647839.7259436.png)\\nlets take row index as 6. as first element is always 1, intilize a varibale called x=1 and two more variables n=6, and c=1( you can assume c as column number ) now next element will be (xn/c)  and then decrease n and increase c  and keep this till half way as after that same elements will repeat themselves just in reverse order.\\n\\n**Edit**- I did not explain exactly how i come up to this solution. So here is the explanation-\\npascle triangle actually represent coefficients of  biionomial expention\\nso lets take a example to understand how\\nhere when i talk about power it means sum of power of **a** and **b**\\n\\nlets take x(row index) =0, which is equal to (a+b)^0 which is equal to 1 and as total power will be zero , so only 1 way to represent it.\\n\\nlets take x =1, which is equal to ((a+b)^0) *(a+b) and as we know it will be [1,1]  as now we want to represent power 1 and it can either be done as \\'a\\' or \\'b\\'.\\n\\nlets  take x=2, which is (a+b)(a+b), now as we want to represent power 2, we can do it by  a^2, ab,b^2. we have already got [1,1] for (a+b) and now we want a^2 so it can only possible if we take \\'a\\' from (a+b) and it can be done in only one way. For \\'ab\\' we  can take \\'a\\'from (a+b) and then b from next (a+b) or \\'b\\' from (a+b) and then \\'a\\' from next (a+b). We can get b^2 same way as a^2.  So answer is [1,2,1]\\n\\nlets take x=3, which is (a+b)^2(a+b). as we already got [1,2,1] from (a+b)^2. Now we want to represent power 3 and it can be done as a^3,a^2b,ab^2,b^3. Now to represent a^3, we need a^2 from (a+b)^2 and it can be done in only one way, for a^2b we can done it by using following combinations (ab,a), (a^2,b). as \\'ab\\' can be represented by 2 ways in (a+b)^2. So, total 3 ways for a^b. After, that we can take similar action to get other values.\\n\\nHonestly when I solve this question I did not solve it by using this explanation. I have solved some \\'find next number in series\\' aptitude  questions in past  and I applied same logic in it and came with this formula. Then i thought of some logical reason and find its just binomial coefficients.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int r) {\\n        vector<int>v(r+1,0);\\n        long long x=1,n=r;\\n        for(int i=0;i<=r/2;i++,n--){\\n             v[i]=x;\\n             v[r-i]=x;\\n             x=x*n/(i+1);\\n         }\\n        return v;\\n       \\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> getRow(int r) {\\n        vector<int>v(r+1,0);\\n        long long x=1,n=r;\\n        for(int i=0;i<=r/2;i++,n--){\\n             v[i]=x;\\n             v[r-i]=x;\\n             x=x*n/(i+1);\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 1741684,
                "title": "python3-faster-solution-easiest-beginner-friendly",
                "content": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        res = []\\n        for i in range(rowIndex+1):\\n            res.append([])\\n            for j in range(i + 1):\\n                if j == 0 or j == i:\\n                    res[i].append(1)\\n                else:\\n                    res[i].append(res[i - 1][j - 1] + res[i - 1][j])\\n        return res[rowIndex]\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        res = []\\n        for i in range(rowIndex+1):\\n            res.append([])\\n            for j in range(i + 1):\\n                if j == 0 or j == i:\\n                    res[i].append(1)\\n                else:\\n                    res[i].append(res[i - 1][j - 1] + res[i - 1][j])\\n        return res[rowIndex]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701770,
                "title": "easy-java-solution-0-ms-recursion-with-memoization",
                "content": "```\\nclass Solution {\\n  private int getNum(int row, int col, int[][]memo) {\\n    if (row == 0 || col == 0 || row == col) {\\n      return 1;\\n    }\\n    if (memo[row][col] != 0) {\\n        return memo[row][col];\\n    }\\n    int sum = getNum(row - 1, col - 1, memo) + getNum(row - 1, col, memo);\\n    memo[row][col] = sum;\\n    return sum;\\n  }\\n\\n  public List<Integer> getRow(int rowIndex) {\\n    List<Integer> ans = new ArrayList<>();\\n    int[][] memo = new int[rowIndex + 1][rowIndex + 1];\\n\\n    for (int i = 0; i <= rowIndex; i++) {\\n      ans.add(getNum(rowIndex, i, memo));\\n    }\\n\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n  private int getNum(int row, int col, int[][]memo) {\\n    if (row == 0 || col == 0 || row == col) {\\n      return 1;\\n    }\\n    if (memo[row][col] != 0) {\\n        return memo[row][col];\\n    }\\n    int sum = getNum(row - 1, col - 1, memo) + getNum(row - 1, col, memo);\\n    memo[row][col] = sum;\\n    return sum;\\n  }\\n\\n  public List<Integer> getRow(int rowIndex) {\\n    List<Integer> ans = new ArrayList<>();\\n    int[][] memo = new int[rowIndex + 1][rowIndex + 1];\\n\\n    for (int i = 0; i <= rowIndex; i++) {\\n      ans.add(getNum(rowIndex, i, memo));\\n    }\\n\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537135,
                "title": "java-simplest-solution-must-watch-0ms",
                "content": "class Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        \\n        List <Integer> res = new ArrayList <> ();\\n        \\n        if(rowIndex == 0){\\n            res.add(1);\\n            return res;\\n        }\\n        \\n        \\n        long val = 1;          \\n        for(int i=0; i<=rowIndex; ++i){\\n            \\n            res.add( (int) val);            // To avoid OverFLow\\n            \\n            val = val * (rowIndex - i) / (i + 1);      //Using Binomial Theorem\\n            \\n        }\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        \\n        List <Integer> res = new ArrayList <> ();\\n        \\n        if(rowIndex == 0){\\n            res.add(1);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1527391,
                "title": "4-line-in-python",
                "content": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        r = [1]\\n        for _ in range(rowIndex):\\n            r = [1, *(map(sum, zip(r, r[1:]))), 1]\\n        return r\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        r = [1]\\n        for _ in range(rowIndex):\\n            r = [1, *(map(sum, zip(r, r[1:]))), 1]\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525804,
                "title": "c-100-fast-90-space-efficient-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n        //initialise ans vector for if rowIndex is 0 or 1\\n        vector<int>ans(n+1,1);\\n        if(n==0||n==1)\\n        return ans;\\n        \\n        //make prev <1,1> \\n        vector<int>prev(2,1);\\n        \\n        n=rowIndex-1;\\n        \\n        //increase size of ans by 1. start updating ans from previous. Once loop is completed,store ans in           prev \\n        \\n        while(n--){\\n            ans.resize(prev.size()+1,1);\\n            for(int i=1;i<ans.size()-1;i++){\\n                ans[i]=prev[i-1]+prev[i];\\n            }    \\n                prev = ans;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n        //initialise ans vector for if rowIndex is 0 or 1\\n        vector<int>ans(n+1,1);\\n        if(n==0||n==1)\\n        return ans;\\n        \\n        //make prev <1,1> \\n        vector<int>prev(2,1);\\n        \\n        n=rowIndex-1;\\n        \\n        //increase size of ans by 1. start updating ans from previous. Once loop is completed,store ans in           prev \\n        \\n        while(n--){\\n            ans.resize(prev.size()+1,1);\\n            for(int i=1;i<ans.size()-1;i++){\\n                ans[i]=prev[i-1]+prev[i];\\n            }    \\n                prev = ans;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1517650,
                "title": "c-easy-to-understand-solution-short-simple-dp-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int r) {\\n        vector<int>v(r+1,1);\\n        for(int i=1;i<=r-1;i++){\\n            int prev=1,c;\\n            for(int j=1;j<=i;j++){\\n                c=v[j];\\n                v[j]+=prev;\\n                prev=c;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\n***Time Complexity : O(r^2) \\nSpace Complexity : O(1)** - (not including the vector to be returned)*",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int r) {\\n        vector<int>v(r+1,1);\\n        for(int i=1;i<=r-1;i++){\\n            int prev=1,c;\\n            for(int j=1;j<=i;j++){\\n                c=v[j];\\n                v[j]+=prev;\\n                prev=c;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434922,
                "title": "java-0ms-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        List<Integer> res = new ArrayList<>();\\n        long val = 1;\\n        for(int i=0;i<=rowIndex;i++)\\n        {\\n            res.add((int)val);\\n            val = val*(rowIndex-i)/(i+1);\\n        }\\n        return res;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        List<Integer> res = new ArrayList<>();\\n        long val = 1;\\n        for(int i=0;i<=rowIndex;i++)\\n        {\\n            res.add((int)val);\\n            val = val*(rowIndex-i)/(i+1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365320,
                "title": "js-recursive-solution",
                "content": "```\\nvar getRow = function(rowIndex) {\\n    if (rowIndex === 0) return [1]\\n    if (rowIndex === 1) return [1, 1]\\n    \\n    const row = getRow(rowIndex - 1)\\n    let prev = 1\\n    let tmp = prev\\n\\n    row.push(1)\\n\\n    for (let i = 1; i < rowIndex; i++) {\\n        tmp = row[i]\\n        row[i] = prev + row[i]\\n        prev = tmp\\n    }\\n    \\n    return row\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar getRow = function(rowIndex) {\\n    if (rowIndex === 0) return [1]\\n    if (rowIndex === 1) return [1, 1]\\n    \\n    const row = getRow(rowIndex - 1)\\n    let prev = 1\\n    let tmp = prev\\n\\n    row.push(1)\\n\\n    for (let i = 1; i < rowIndex; i++) {\\n        tmp = row[i]\\n        row[i] = prev + row[i]\\n        prev = tmp\\n    }\\n    \\n    return row\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1158468,
                "title": "two-golang-solutions-100-100-with-explanation",
                "content": "[119. Pascal\\'s Triangle II](https://leetcode.com/problems/pascals-triangle-ii/)\\n\\nI will explain the first solution.\\n\\nIf you want to understand the second solution, click on the link above the code.\\n\\nSo the first solution only wants us to return the last row of the triangle.\\n\\nSince we always need two rows for this problem, the current row, and the previous row, in this problem, `res` is the current row and `temp` is the previous row.\\n\\nHere is how the problem works\\n\\n* We have `res[0]` equal to `1`, so all we have to do is keep on appending `1` to `res` every time we iterate.\\n* Then we have to loop through `res`\\'s indexes starting at `1` and ending at `len(res) - 1` because we don\\'t want to count the start and end `1`\\'s.\\n* Inside the nested for we can make `res[j] = temp[j-1] + temp[j]`. If you don\\'t understand why this works, look at the image below: ![](https://i.imgur.com/vPafRCe.png)\\n* After iterating through everything we can return `res`.\\n\\n\\n**The Code:** *This is the one that is 100%, 100%*\\n\\n``` go\\nfunc getRow(rowIndex int) []int {\\n    res := []int{}\\n\\n    for i := 0; i <= rowIndex; i++ {\\n        temp := make([]int, len(res))\\n        copy(temp, res)\\n        res = append(res, 1)\\n        for j := 1; j < len(res)-1; j++ {\\n            res[j] = temp[j-1] + temp[j]\\n        }\\n    }\\n    return res\\n}\\n```\\n\\n**We could do something similar to what we did in [Leetcode 118](https://nathannaveen.dev/posts/leetcode-118/) But it is a pretty brute force solution for this problem:** \\n\\n``` go\\nfunc getRow(rowIndex int) []int {\\n    res := [][]int{}\\n\\n    for i := 0; i < rowIndex; i++ {\\n        temp := make([]int, i+1)\\n        temp[0], temp[len(temp)-1] = 1, 1\\n        for j := 1; j < len(temp)-1; j++ {\\n            temp[j] = res[i-1][j-1] + res[i-1][j]\\n        }\\n        res = append(res, temp)\\n    }\\n\\n    return res[len(res) - 1]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nfunc getRow(rowIndex int) []int {\\n    res := []int{}\\n\\n    for i := 0; i <= rowIndex; i++ {\\n        temp := make([]int, len(res))\\n        copy(temp, res)\\n        res = append(res, 1)\\n        for j := 1; j < len(res)-1; j++ {\\n            res[j] = temp[j-1] + temp[j]\\n        }\\n    }\\n    return res\\n}\\n```\n``` go\\nfunc getRow(rowIndex int) []int {\\n    res := [][]int{}\\n\\n    for i := 0; i < rowIndex; i++ {\\n        temp := make([]int, i+1)\\n        temp[0], temp[len(temp)-1] = 1, 1\\n        for j := 1; j < len(temp)-1; j++ {\\n            temp[j] = res[i-1][j-1] + res[i-1][j]\\n        }\\n        res = append(res, temp)\\n    }\\n\\n    return res[len(res) - 1]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 906279,
                "title": "c-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        \\n        if(rowIndex == 0)\\n            return {1};\\n        \\n        if(rowIndex == 1)\\n            return {1, 1};\\n        \\n        vector<int> row, prev = getRow(rowIndex - 1);\\n        \\n        row.push_back(1);\\n        for(int n = 1; n < prev.size(); n++)\\n        {\\n            row.push_back(prev[n] + prev[n-1]);\\n        }\\n        row.push_back(1);\\n                                       \\n        return row;  \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        \\n        if(rowIndex == 0)\\n            return {1};\\n        \\n        if(rowIndex == 1)\\n            return {1, 1};\\n        \\n        vector<int> row, prev = getRow(rowIndex - 1);\\n        \\n        row.push_back(1);\\n        for(int n = 1; n < prev.size(); n++)\\n        {\\n            row.push_back(prev[n] + prev[n-1]);\\n        }\\n        row.push_back(1);\\n                                       \\n        return row;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 897377,
                "title": "c-solution",
                "content": "```\\nint* getRow(int rowIndex, int* returnSize){\\n\\tint *ret = NULL;\\n\\t*returnSize = rowIndex + 1;\\n\\tret = malloc(sizeof(int)* (rowIndex + 1));\\n\\n\\tret[0] = 1;\\n\\tif(rowIndex == 0) \\n\\t\\treturn ret;\\n\\n\\tret[1] = 1;\\n\\tif(rowIndex == 1)\\n\\t\\treturn ret;\\n\\n\\tfor(int row = 2; row <= rowIndex; row++) {\\n        int prev = ret[0];\\n\\t\\tfor(int col = 1; col <= row - 1; col++) {\\n            int temp = prev + ret[col];\\n            prev = ret[col];\\n\\t\\t\\tret[col] = temp;\\n\\t\\t}\\n\\t\\tret[row] = 1;\\n\\t}\\n\\treturn ret;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint* getRow(int rowIndex, int* returnSize){\\n\\tint *ret = NULL;\\n\\t*returnSize = rowIndex + 1;\\n\\tret = malloc(sizeof(int)* (rowIndex + 1));\\n\\n\\tret[0] = 1;\\n\\tif(rowIndex == 0) \\n\\t\\treturn ret;\\n\\n\\tret[1] = 1;\\n\\tif(rowIndex == 1)\\n\\t\\treturn ret;\\n\\n\\tfor(int row = 2; row <= rowIndex; row++) {\\n        int prev = ret[0];\\n\\t\\tfor(int col = 1; col <= row - 1; col++) {\\n            int temp = prev + ret[col];\\n            prev = ret[col];\\n\\t\\t\\tret[col] = temp;\\n\\t\\t}\\n\\t\\tret[row] = 1;\\n\\t}\\n\\treturn ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 789241,
                "title": "python-3-solution-faster-than-95-36",
                "content": "\\n```\\n\\tclass Solution:\\n\\t\\tdef getRow(self, rowIndex: int) -> List[int]:\\n\\t\\t\\ttri=[[1], [1,1]]\\n\\t\\t\\tfor i in range(2, rowIndex+1):\\n\\t\\t\\t\\trow=[None]*(i+1)\\n\\t\\t\\t\\trow[0]=1\\n\\t\\t\\t\\trow[i]=1\\n\\t\\t\\t\\tfor j in range(1,i):\\n\\t\\t\\t\\t\\trow[j]=tri[i-1][j]+tri[i-1][j-1]\\n\\t\\t\\t\\ttri.append(row)\\n\\t\\t\\treturn tri[rowIndex]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\tclass Solution:\\n\\t\\tdef getRow(self, rowIndex: int) -> List[int]:\\n\\t\\t\\ttri=[[1], [1,1]]\\n\\t\\t\\tfor i in range(2, rowIndex+1):\\n\\t\\t\\t\\trow=[None]*(i+1)\\n\\t\\t\\t\\trow[0]=1\\n\\t\\t\\t\\trow[i]=1\\n\\t\\t\\t\\tfor j in range(1,i):\\n\\t\\t\\t\\t\\trow[j]=tri[i-1][j]+tri[i-1][j-1]\\n\\t\\t\\t\\ttri.append(row)\\n\\t\\t\\treturn tri[rowIndex]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 787379,
                "title": "java-simple-list-beats-100",
                "content": "\\t\\tList<Integer> res = new ArrayList<>();\\n        res.add(1);\\n        if(rowIndex == 0)return res;\\n        for(int i = 1; i <= rowIndex; i++){\\n            long num = ((long)res.get(i-1)*(long)(rowIndex-i+1))/i;\\n            res.add((int)num);\\n        }\\n        return res;",
                "solutionTags": [],
                "code": "\\t\\tList<Integer> res = new ArrayList<>();\\n        res.add(1);\\n        if(rowIndex == 0)return res;\\n        for(int i = 1; i <= rowIndex; i++){\\n            long num = ((long)res.get(i-1)*(long)(rowIndex-i+1))/i;\\n            res.add((int)num);\\n        }\\n        return res;",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1574945,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 1574200,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 1567863,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 1762280,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 2071808,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 1930720,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 1918945,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 1867901,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 1803740,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 1799687,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 1574945,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 1574200,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 1567863,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 1762280,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 2071808,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 1930720,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 1918945,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 1867901,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 1803740,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 1799687,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            }
        ]
    },
    {
        "title": "Contains Duplicate II",
        "question_content": "<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <code>true</code> <em>if there are two <strong>distinct indices</strong> </em><code>i</code><em> and </em><code>j</code><em> in the array such that </em><code>nums[i] == nums[j]</code><em> and </em><code>abs(i - j) &lt;= k</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,1], k = 3\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,0,1,1], k = 1\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,1,2,3], k = 2\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 61372,
                "title": "simple-java-solution",
                "content": "    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n            Set<Integer> set = new HashSet<Integer>();\\n            for(int i = 0; i < nums.length; i++){\\n                if(i > k) set.remove(nums[i-k-1]);\\n                if(!set.add(nums[i])) return true;\\n            }\\n            return false;\\n     }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n            Set<Integer> set = new HashSet<Integer>();\\n            for(int i = 0; i < nums.length; i++){\\n                if(i > k) set.remove(nums[i-k-1]);\\n                if(!set.add(nums[i])) return true;\\n            }\\n            return false;\\n     }",
                "codeTag": "Unknown"
            },
            {
                "id": 61375,
                "title": "python-concise-solution-with-dictionary",
                "content": "        \\n    def containsNearbyDuplicate(self, nums, k):\\n        dic = {}\\n        for i, v in enumerate(nums):\\n            if v in dic and i - dic[v] <= k:\\n                return True\\n            dic[v] = i\\n        return False",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    def containsNearbyDuplicate(self, nums, k):\\n        dic = {}\\n        for i, v in enumerate(nums):\\n            if v in dic and i - dic[v] <= k:\\n                return True\\n            dic[v] = i\\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 2727290,
                "title": "c-easy-detailed-explaination-optimized",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n**Time** and **Space** Complexity => `O(n)`, where n is the size of nums\\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        int n = nums.size();\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            // mp.count() will tell whatever ith index that I want, have I seen it before?\\n            if(mp.count(nums[i]))\\n            {\\n                // if I have already seen this number, then check for condition abs(i - j) <= k\\n                if(abs(i-mp[nums[i]])<=k)\\n                    return true;\\n            }\\n            // if I have not seen this number before, insert the number with its position in the map\\n            // and if the number is already present in the map, then update the position of that number\\n            mp[nums[i]] = i;\\n        }\\n        // after the complete traversal, if we don\\'t find a pair to satisfy the condition, return false\\n        return false;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/6b590819-3b5e-482d-ac95-2c94d997ad76_1666313784.690029.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        int n = nums.size();\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            // mp.count() will tell whatever ith index that I want, have I seen it before?\\n            if(mp.count(nums[i]))\\n            {\\n                // if I have already seen this number, then check for condition abs(i - j) <= k\\n                if(abs(i-mp[nums[i]])<=k)\\n                    return true;\\n            }\\n            // if I have not seen this number before, insert the number with its position in the map\\n            // and if the number is already present in the map, then update the position of that number\\n            mp[nums[i]] = i;\\n        }\\n        // after the complete traversal, if we don\\'t find a pair to satisfy the condition, return false\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61390,
                "title": "c-solution-with-unordered-set",
                "content": "    class Solution {\\n    public:\\n        bool containsNearbyDuplicate(vector<int>& nums, int k)\\n        {\\n           unordered_set<int> s;\\n           \\n           if (k <= 0) return false;\\n           if (k >= nums.size()) k = nums.size() - 1;\\n           \\n           for (int i = 0; i < nums.size(); i++)\\n           {\\n               if (i > k) s.erase(nums[i - k - 1]);\\n               if (s.find(nums[i]) != s.end()) return true;\\n               s.insert(nums[i]);\\n           }\\n           \\n           return false;\\n        }\\n    };\\n\\nThe basic idea is to maintain a set s which contain unique values from nums[i  - k] to nums[i - 1],\\nif nums[i] is in set s then return true else update the set.",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool containsNearbyDuplicate(vector<int>& nums, int k)\\n        {\\n           unordered_set<int> s;\\n           \\n           if (k <= 0) return false;\\n           if (k >= nums.size()) k = nums.size() - 1;\\n           \\n           for (int i = 0; i < nums.size(); i++)\\n           {\\n               if (i > k) s.erase(nums[i - k - 1]);\\n               if (s.find(nums[i]) != s.end()) return true;\\n               s.insert(nums[i]);\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 61397,
                "title": "short-ac-java-solution",
                "content": "    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i])) {\\n                if (i - map.get(nums[i]) <= k) return true;\\n            }\\n            map.put(nums[i], i);\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i])) {\\n                if (i - map.get(nums[i]) <= k) return true;\\n            }\\n            map.put(nums[i], i);\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2463150,
                "title": "very-easy-100-fully-explained-java-c-python-javascript-python3-using-hashset",
                "content": "# **Java Solution (Using HashSet):**\\n```\\n// Time Complexity : O(n)\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        // Base case...\\n        if(nums == null || nums.length < 2 || k == 0)\\n            return false;\\n        int i = 0;\\n        // Create a Hash Set for storing previous of k elements...\\n        HashSet<Integer> hset = new HashSet<Integer>();\\n        // Traverse for all elements of the given array in a for loop...\\n        for(int j = 0; j < nums.length; j++) {\\n            // If duplicate element is present at distance less than equal to k, return true...\\n            if(!hset.add(nums[j])){\\n                return true;\\n            }\\n            // If size of the Hash Set becomes greater than k...\\n            if(hset.size() >= k+1){\\n                // Remove the last visited element from the set...\\n                hset.remove(nums[i++]);\\n            }\\n        }\\n        // If no duplicate element is found then return false...\\n        return false;\\n    }\\n}\\n```\\n--------------------------------------------------------------------------------------------------\\n# **C++ Solution:**\\n```\\n// Time Complexity : O(n)\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        // Create a Set for storing previous of k elements...\\n        unordered_set<int> hset;\\n        // Traverse for all elements of the given array in a for loop...\\n        for(int idx = 0; idx < nums.size(); idx++) {\\n            // Check if set already contains nums[idx] or not...\\n            // If duplicate element is present at distance less than equal to k, return true...\\n            if(hset.count(nums[idx]))\\n                return true;\\n            // Otherwise, add nums[idx] to the set...\\n            hset.insert(nums[idx]);\\n            // If size of the set becomes greater than k...\\n            if(hset.size() > k)\\n                // Remove the last visited element from the set...\\n                hset.erase(nums[idx - k]);\\n        }\\n        // If no duplicate element is found then return false...\\n        return false;\\n    }\\n};\\n```\\n---------------------------------------------------------------------------------------------------\\n# **Python/Python3 Solution:**\\n```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        # Create hset for storing previous of k elements...\\n        hset = {}\\n        # Traverse for all elements of the given array in a for loop...\\n        for idx in range(len(nums)):\\n            # If duplicate element is present at distance less than equal to k, return true...\\n            if nums[idx] in hset and abs(idx - hset[nums[idx]]) <= k:\\n                return True\\n            hset[nums[idx]] = idx\\n        # If no duplicate element is found then return false...\\n        return False\\n```\\n-----------------------------------------------------------------------------------------------------\\n# **JavaScript Solution:**\\n```\\n// Time Complexity : O(n)\\n// Space Complexity : O(n)\\nvar containsNearbyDuplicate = function(nums, k) {\\n    const hasmap = new Map();\\n    for (let idx = 0; idx < nums.length; idx++) {\\n        // Check if the difference betweend duplicates is less than k\\n        if (idx - hasmap.get(nums[idx]) <= k) {\\n            return true;\\n        }\\n        hasmap.set(nums[idx], idx);\\n    }\\n    return false;\\n};\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\n// Time Complexity : O(n)\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        // Base case...\\n        if(nums == null || nums.length < 2 || k == 0)\\n            return false;\\n        int i = 0;\\n        // Create a Hash Set for storing previous of k elements...\\n        HashSet<Integer> hset = new HashSet<Integer>();\\n        // Traverse for all elements of the given array in a for loop...\\n        for(int j = 0; j < nums.length; j++) {\\n            // If duplicate element is present at distance less than equal to k, return true...\\n            if(!hset.add(nums[j])){\\n                return true;\\n            }\\n            // If size of the Hash Set becomes greater than k...\\n            if(hset.size() >= k+1){\\n                // Remove the last visited element from the set...\\n                hset.remove(nums[i++]);\\n            }\\n        }\\n        // If no duplicate element is found then return false...\\n        return false;\\n    }\\n}\\n```\n```\\n// Time Complexity : O(n)\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        // Create a Set for storing previous of k elements...\\n        unordered_set<int> hset;\\n        // Traverse for all elements of the given array in a for loop...\\n        for(int idx = 0; idx < nums.size(); idx++) {\\n            // Check if set already contains nums[idx] or not...\\n            // If duplicate element is present at distance less than equal to k, return true...\\n            if(hset.count(nums[idx]))\\n                return true;\\n            // Otherwise, add nums[idx] to the set...\\n            hset.insert(nums[idx]);\\n            // If size of the set becomes greater than k...\\n            if(hset.size() > k)\\n                // Remove the last visited element from the set...\\n                hset.erase(nums[idx - k]);\\n        }\\n        // If no duplicate element is found then return false...\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        # Create hset for storing previous of k elements...\\n        hset = {}\\n        # Traverse for all elements of the given array in a for loop...\\n        for idx in range(len(nums)):\\n            # If duplicate element is present at distance less than equal to k, return true...\\n            if nums[idx] in hset and abs(idx - hset[nums[idx]]) <= k:\\n                return True\\n            hset[nums[idx]] = idx\\n        # If no duplicate element is found then return false...\\n        return False\\n```\n```\\n// Time Complexity : O(n)\\n// Space Complexity : O(n)\\nvar containsNearbyDuplicate = function(nums, k) {\\n    const hasmap = new Map();\\n    for (let idx = 0; idx < nums.length; idx++) {\\n        // Check if the difference betweend duplicates is less than k\\n        if (idx - hasmap.get(nums[idx]) <= k) {\\n            return true;\\n        }\\n        hasmap.set(nums[idx], idx);\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61572,
                "title": "java-solution-using-hashmap-s-put",
                "content": "    public class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n\\t\\t\\n\\t\\tfor(int i = 0; i <  nums.length; i++) {\\n\\t\\t\\tInteger ord = map.put(nums[i], i);\\n\\t\\t\\tif(ord != null && i - ord <= k) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn false;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n\\t\\t\\n\\t\\tfor(int i = 0; i <  nums.length; i++) {\\n\\t\\t\\tInteger ord = map.put(nums[i], i);\\n\\t\\t\\tif(ord != null && i - ord <= k) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 61599,
                "title": "c-unordered-map-and-unordered-set",
                "content": "The easy idea is to map each distinct number to its latest index and check/update for the difference betwen indices each time a number is seen again.\\n\\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (mp.find(nums[i]) != mp.end() && i - mp[nums[i]] <= k) {\\n                return true;\\n            }\\n            mp[nums[i]] = i;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\nBut this problem can also be solved using a set. And the set will only keep the latest `k` elements. The `insert` of `unordered_set` returns a pair with the `second` element representing whether the element is actually inserted.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        unordered_set<int> st;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (i > k) {\\n                st.erase(nums[i - k - 1]);\\n            }\\n            if (!st.insert(nums[i]).second) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (mp.find(nums[i]) != mp.end() && i - mp[nums[i]] <= k) {\\n                return true;\\n            }\\n            mp[nums[i]] = i;\\n        }\\n        return false;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        unordered_set<int> st;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (i > k) {\\n                st.erase(nums[i - k - 1]);\\n            }\\n            if (!st.insert(nums[i]).second) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332374,
                "title": "c-solution-o-n",
                "content": "***Time complexity - O(N)***\\n***Space complexity - O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(mp.count(nums[i])){\\n                int diff = abs(mp[nums[i]] - i);\\n                if (diff <= k)return true;  \\n            }\\n            mp[nums[i]] = i;\\n        }\\n        return false;\\n    }\\n};\\n```\\n**Please upvote if you like the solution nad comment if have doubts**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(mp.count(nums[i])){\\n                int diff = abs(mp[nums[i]] - i);\\n                if (diff <= k)return true;  \\n            }\\n            mp[nums[i]] = i;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2727210,
                "title": "java-explained-in-detail-simple-fast-solution-hashmap-sliding-window",
                "content": "I do my best everyday to give a clear explanation, so to help everyone improve their skills.\\n\\nIf you find this **helpful**, please \\uD83D\\uDC4D **upvote** this post and watch my [Github Repository](https://github.com/cheehwatang/leetcode-java).\\n\\nThank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.\\n\\n---\\n\\n### Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(N)\\nwhere N is the length of \\'nums\\'.\\n\\n---\\n\\n#### Java - Hash Table (Clean Code)\\n```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        if (k == 0) return false;\\n\\n        Map<Integer, Integer> hashMap = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            int integer = nums[i];\\n            if (hashMap.containsKey(integer) && i - hashMap.get(integer) <= k)\\n                return true;\\n            hashMap.put(integer, i);\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n#### Java - Hash Table (With Explanation)\\n```\\nclass Solution {\\n\\n    // Approach:\\n    // We will use a HashMap to keep track of the last seen index of the integer.\\n    // Since we only concern about the i - j <= k, any prior j indices is not needed.\\n\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        // If k is 0, then i and j cannot be distinct.\\n        if (k == 0) return false;\\n\\n        // Set up the HashMap, with key = integer in \\'nums\\' and value = index.\\n        Map<Integer, Integer> hashMap = new HashMap<>();\\n\\n        // Traverse the \\'nums\\'.\\n        for (int i = 0; i < nums.length; i++) {\\n            int integer = nums[i];\\n            // If contains key and i - j <= k, return true.\\n            if (hashMap.containsKey(integer) && i - hashMap.get(integer) <= k) {\\n                return true;\\n            }\\n            // Either put a new <Integer, Index> pair, or update index of existing integer in the HashMap.\\n            hashMap.put(integer, i);\\n        }\\n        // If successfully traverse the whole array, meaning we fail to find any integers fulfilling the conditions.\\n        return false;\\n    }\\n}\\n```\\n---\\n\\n#### Java - Sliding Window (Clean Code)\\n```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        if (k == 0) return false;\\n\\n        Set<Integer> slidingWindow = new HashSet<>();\\n        for (int index = 0; index < nums.length; index++) {\\n            if (slidingWindow.contains(nums[index]))\\n                return true;\\n            if (index >= k)\\n                slidingWindow.remove(nums[index - k]);\\n            slidingWindow.add(nums[index]);\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n#### Java - Sliding Window (With Explanation)\\n```\\nclass Solution {\\n\\n    // Approach:\\n    // Using sliding window technique.\\n    // Traversing from left to right, we use a HashSet to store the integers that we saw.\\n    // If the same integer is seen again, we have found the duplicate.\\n    // Then, we update the window again to be within \\'k\\' index from \\'index\\'.\\n\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        // If k is 0, then i and j cannot be distinct.\\n        if (k == 0) return false;\\n\\n        // Set up the HashSet.\\n        Set<Integer> slidingWindow = new HashSet<>();\\n\\n        // Start sliding the slidingWindow to the right.\\n        for (int index = 0; index < nums.length; index++) {\\n            // Return true when found duplicates in the slidingWindow.\\n            if (slidingWindow.contains(nums[index]))\\n                return true;\\n\\n            // Update the state of the window, but removing the leftmost integer and add the new integer.\\n            if (index >= k)\\n                slidingWindow.remove(nums[index - k]);\\n\\n            slidingWindow.add(nums[index]);\\n        }\\n        // If successfully traverse the whole array, meaning we fail to find any integers fulfilling the conditions.\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        if (k == 0) return false;\\n\\n        Map<Integer, Integer> hashMap = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            int integer = nums[i];\\n            if (hashMap.containsKey(integer) && i - hashMap.get(integer) <= k)\\n                return true;\\n            hashMap.put(integer, i);\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n\\n    // Approach:\\n    // We will use a HashMap to keep track of the last seen index of the integer.\\n    // Since we only concern about the i - j <= k, any prior j indices is not needed.\\n\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        // If k is 0, then i and j cannot be distinct.\\n        if (k == 0) return false;\\n\\n        // Set up the HashMap, with key = integer in \\'nums\\' and value = index.\\n        Map<Integer, Integer> hashMap = new HashMap<>();\\n\\n        // Traverse the \\'nums\\'.\\n        for (int i = 0; i < nums.length; i++) {\\n            int integer = nums[i];\\n            // If contains key and i - j <= k, return true.\\n            if (hashMap.containsKey(integer) && i - hashMap.get(integer) <= k) {\\n                return true;\\n            }\\n            // Either put a new <Integer, Index> pair, or update index of existing integer in the HashMap.\\n            hashMap.put(integer, i);\\n        }\\n        // If successfully traverse the whole array, meaning we fail to find any integers fulfilling the conditions.\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        if (k == 0) return false;\\n\\n        Set<Integer> slidingWindow = new HashSet<>();\\n        for (int index = 0; index < nums.length; index++) {\\n            if (slidingWindow.contains(nums[index]))\\n                return true;\\n            if (index >= k)\\n                slidingWindow.remove(nums[index - k]);\\n            slidingWindow.add(nums[index]);\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n\\n    // Approach:\\n    // Using sliding window technique.\\n    // Traversing from left to right, we use a HashSet to store the integers that we saw.\\n    // If the same integer is seen again, we have found the duplicate.\\n    // Then, we update the window again to be within \\'k\\' index from \\'index\\'.\\n\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        // If k is 0, then i and j cannot be distinct.\\n        if (k == 0) return false;\\n\\n        // Set up the HashSet.\\n        Set<Integer> slidingWindow = new HashSet<>();\\n\\n        // Start sliding the slidingWindow to the right.\\n        for (int index = 0; index < nums.length; index++) {\\n            // Return true when found duplicates in the slidingWindow.\\n            if (slidingWindow.contains(nums[index]))\\n                return true;\\n\\n            // Update the state of the window, but removing the leftmost integer and add the new integer.\\n            if (index >= k)\\n                slidingWindow.remove(nums[index - k]);\\n\\n            slidingWindow.add(nums[index]);\\n        }\\n        // If successfully traverse the whole array, meaning we fail to find any integers fulfilling the conditions.\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61378,
                "title": "c-6-line-solution-simple-code-and-easy-understanding",
                "content": "    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        set<int> cand;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (i > k) cand.erase(nums[i-k-1]);\\n            if (!cand.insert(nums[i]).second) return true;\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        set<int> cand;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (i > k) cand.erase(nums[i-k-1]);\\n            if (!cand.insert(nums[i]).second) return true;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1500887,
                "title": "java-tc-o-n-sc-o-min-n-k-sliding-window-using-hashset",
                "content": "```java\\n/**\\n * Using HashSet to maintain the sliding window.\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(min(N, K+1))\\n *\\n * N = Length of input array. K = Input window size.\\n */\\nclass Solution1 {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        if (nums == null || k < 0) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n        if (nums.length <= 1 || k == 0) {\\n            return false;\\n        }\\n\\n        HashSet<Integer> window = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i > k) {\\n                window.remove(nums[i - k - 1]);\\n            }\\n            if (!window.add(nums[i])) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n/**\\n * Using HashMap to store the number and its index.\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(N)\\n */\\nclass Solution2 {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        if (nums == null || nums.length < 2 || k < 1) {\\n            return false;\\n        }\\n\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i]) && i - map.get(nums[i]) <= k) {\\n                return true;\\n            }\\n            map.put(nums[i], i);\\n        }\\n\\n        return false;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other parts of Contains Duplicate question on LeetCode:\\n- [217. Contains Duplicate](https://leetcode.com/problems/contains-duplicate/discuss/1500880/Java-or-TC:-O(N)-or-SC:-O(N)-or-Clean-and-concise-solution-using-HashSet)\\n- [220. Contains Duplicate III](https://leetcode.com/problems/contains-duplicate-iii/discuss/1500895/Java-or-TC:-O(N)-or-SC:-O(min(NK))-or-Sliding-Window-using-Buckets)\\n\\n---\\n\\nSolutions to other Sliding Window questions on LeetCode:\\n- [76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/discuss/1496754/Java-or-TC:-O(S+T)-or-SC:-O(T)-or-Space-optimized-Sliding-Window-using-Two-Pointers)\\n- [340. Longest Substring with At Most K Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/discuss/1496838/Java-or-TC:-O(N)-or-SC:-O(K)-or-One-Pass-Sliding-Window-using-LinkedHashMap)\\n- [159. Longest Substring with At Most Two Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/discuss/1496840/Java-or-TC:-O(N)-or-SC:-O(1)-or-One-Pass-Sliding-Window-using-LinkedHashMap)\\n- [438. Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/discuss/1500039/Java-or-TC:-O(S+P)-or-SC:-O(1)-or-Sliding-window-solution)\\n- [3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1500874/Java-or-TC:-O(N)-or-SC:-O(1)-or-Sliding-Window-using-HashMap-and-Two-Pointers)\\n- [209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/discuss/1500877/Java-or-Both-O(N)-and-O(N-logN)-solutions-with-O(1)-space-or-Sliding-Window-and-Binary-Search-solutions)\\n- [220. Contains Duplicate III](https://leetcode.com/problems/contains-duplicate-iii/discuss/1500895/Java-or-TC:-O(N)-or-SC:-O(min(NK))-or-Sliding-Window-using-Buckets)\\n- [567. Permutation in String](https://leetcode.com/problems/permutation-in-string/discuss/1500902/Java-or-TC:-O(S2)-or-SC:-O(1)-or-Constant-space-Sliding-Window-solution)\\n- [239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/discuss/1506048/Java-or-TC:-O(N)-or-SC:-O(K)-or-Using-Deque-as-Sliding-Window)\\n- [480. Sliding Window Median](https://leetcode.com/problems/sliding-window-median/discuss/1507981/Java-or-TC:-O(N*logK)-or-SC:-(K)-or-Optimized-sliding-window-using-TreeSet)\\n- [487. Max Consecutive Ones II](https://leetcode.com/problems/max-consecutive-ones-ii/discuss/1508045/Java-or-TC:-O(N)-or-SC:-O(1)-or-Four-solutions-with-Follow-up-handled)\\n- [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/discuss/1508044/Java-or-TC:-O(N)-or-SC:-O(1)-or-One-Pass-Optimized-Sliding-Window)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```java\\n/**\\n * Using HashSet to maintain the sliding window.\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(min(N, K+1))\\n *\\n * N = Length of input array. K = Input window size.\\n */\\nclass Solution1 {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        if (nums == null || k < 0) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n        if (nums.length <= 1 || k == 0) {\\n            return false;\\n        }\\n\\n        HashSet<Integer> window = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i > k) {\\n                window.remove(nums[i - k - 1]);\\n            }\\n            if (!window.add(nums[i])) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n/**\\n * Using HashMap to store the number and its index.\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(N)\\n */\\nclass Solution2 {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        if (nums == null || nums.length < 2 || k < 1) {\\n            return false;\\n        }\\n\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i]) && i - map.get(nums[i]) <= k) {\\n                return true;\\n            }\\n            map.put(nums[i], i);\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1512861,
                "title": "python-simple-solution",
                "content": "**Python :**\\n\\n```\\ndef containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n\\tindex_dict = {}\\n\\n\\n\\tfor i, n in enumerate(nums):\\n\\t\\tif n in index_dict and i - index_dict[n] <= k:\\n\\t\\t\\treturn True\\n\\n\\t\\tindex_dict[n] = i\\n\\n\\treturn False\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n\\tindex_dict = {}\\n\\n\\n\\tfor i, n in enumerate(nums):\\n\\t\\tif n in index_dict and i - index_dict[n] <= k:\\n\\t\\t\\treturn True\\n\\n\\t\\tindex_dict[n] = i\\n\\n\\treturn False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 61631,
                "title": "only-one-test-per-element",
                "content": "Standard solution with a little trick. I walk over the array once, remembering where I last saw each number, and use that to answer. But the way I do it, I don't need the *\"have I already seen this\"* safety test before accessing *where* I have last seen it.\\n\\n---\\n\\n**Python**\\n\\nIn Python 2, `dict.get(key)` returns `None` if the key doesn't exist, and `somenumber <= None` always returns `False`. So I don't have to first check whether the number has occurred before and then check whether it has occurred recently.\\n\\n    class Solution:\\n        def containsNearbyDuplicate(self, nums, k):\\n            index = {}\\n            for i, n in enumerate(nums):\\n                if i - k <= index.get(n):\\n                    return True\\n                index[n] = i\\n            return False\\n\\n---\\n\\n**Java**\\n\\nSimilar in Java, but using `getOrDefault` with default `-k - 1`:\\n\\n    public class Solution {\\n        public boolean containsNearbyDuplicate(int[] nums, int k) {\\n            Map<Integer, Integer> index = new HashMap<>();\\n            for (int i = 0; i < nums.length; i++) {\\n                if (i - k <= index.getOrDefault(nums[i], -k - 1))\\n                    return true;\\n                index.put(nums[i], i);\\n            }\\n            return false;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "class Solution:\\n        def containsNearbyDuplicate(self, nums, k):\\n            index = {}",
                "codeTag": "Java"
            },
            {
                "id": 1618614,
                "title": "c-sliding-window-2-pointer-approach-with-explanation",
                "content": "The approach is to use sliding window, as we have to find value in a certain range of indices in the nums array , so sliding window is the approach which comes into mind. \\n*The implementation technique of sliding window is as given in the code using comments!!!*\\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n\\t//we will create an unordered map for handling multiple occurence of a number\\n\\t//this will also help us in maintaing the insert , search, update and delete operations in O(1) time complexity\\n        unordered_map<int,int>st;\\n\\t\\t//we will have two pointer 1 at the begin of the window and second at the end of the window\\n        int i = 0,j = 0;\\n\\t\\t\\n        for(; j<nums.size(); j++){\\n\\t\\t//when the size of the window increases than the given size then remove element at the front of the window\\n\\t\\t//here we are using maps so we will do map[key]--, where key = nums[i] element to which 1st pointer is pointing, then we increment the beginning of the window\\n            if(j>k){\\n                st[nums[i++]]--;\\n            }\\n            //we check is the current element has seen before in the window\\n\\t\\t\\t//if the occurence of the element is greater than 0 then it means it was present in the window size\\n            if(st[nums[j]]>0){\\n                return true;\\n            }\\n            //if the above cases are not applicable then we simply insert the current element into the map container\\n            st[nums[j]]++;\\n        }\\n\\t\\t\\n        return false;\\n    }\\n};\\n```\\n\\n***Please do upvote if you liked the solution !!!!!!!!!!!!!!!***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n\\t//we will create an unordered map for handling multiple occurence of a number\\n\\t//this will also help us in maintaing the insert , search, update and delete operations in O(1) time complexity\\n        unordered_map<int,int>st;\\n\\t\\t//we will have two pointer 1 at the begin of the window and second at the end of the window\\n        int i = 0,j = 0;\\n\\t\\t\\n        for(; j<nums.size(); j++){\\n\\t\\t//when the size of the window increases than the given size then remove element at the front of the window\\n\\t\\t//here we are using maps so we will do map[key]--, where key = nums[i] element to which 1st pointer is pointing, then we increment the beginning of the window\\n            if(j>k){\\n                st[nums[i++]]--;\\n            }\\n            //we check is the current element has seen before in the window\\n\\t\\t\\t//if the occurence of the element is greater than 0 then it means it was present in the window size\\n            if(st[nums[j]]>0){\\n                return true;\\n            }\\n            //if the above cases are not applicable then we simply insert the current element into the map container\\n            st[nums[j]]++;\\n        }\\n\\t\\t\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 490689,
                "title": "javascript-easy-understand-98-74-56-ms",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar containsNearbyDuplicate = function(nums, k) {\\n  const map = new Map();\\n  for (let i = 0; i < nums.length; i++) {\\n    if (i - map.get(nums[i]) <= k) {\\n      return true;\\n    }\\n    map.set(nums[i], i);\\n  }\\n  return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar containsNearbyDuplicate = function(nums, k) {\\n  const map = new Map();\\n  for (let i = 0; i < nums.length; i++) {\\n    if (i - map.get(nums[i]) <= k) {\\n      return true;\\n    }\\n    map.set(nums[i], i);\\n  }\\n  return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2727273,
                "title": "python-3-5-lines-dict-w-example-t-m-95-76",
                "content": "```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: list[int], k: int) -> bool:\\n\\n        d = defaultdict(int)                                # d keeps track of most recent index of num (if seen)\\n\\n                                                            #  Ex:  nums = [1,2,3,1,6,0,2],  k = 5\\n                                                            #                               num in d and\\n        for i, num in enumerate(nums):                      #   i   num         d             i - j <= 5\\n                                                            #  \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013 \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013 \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013 \\n            if num in d and i - d[num] <= k: return True    #   0    1   {}                     False\\n                                                            #   1    2   {1: 0}                 False\\n            d[num] = i                                      #   2    3   {1: 0, 2: 1})          False\\n                                                            #   3    1   {1: 0, 2: 1, 3: 2}     True    <= 3 - 0 <5\\n        return False                                        #   |            |                             |   |\\n```\\n[https://leetcode.com/submissions/detail/826947557/](http://)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: list[int], k: int) -> bool:\\n\\n        d = defaultdict(int)                                # d keeps track of most recent index of num (if seen)\\n\\n                                                            #  Ex:  nums = [1,2,3,1,6,0,2],  k = 5\\n                                                            #                               num in d and\\n        for i, num in enumerate(nums):                      #   i   num         d             i - j <= 5\\n                                                            #  \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013 \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013 \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013 \\n            if num in d and i - d[num] <= k: return True    #   0    1   {}                     False\\n                                                            #   1    2   {1: 0}                 False\\n            d[num] = i                                      #   2    3   {1: 0, 2: 1})          False\\n                                                            #   3    1   {1: 0, 2: 1, 3: 2}     True    <= 3 - 0 <5\\n        return False                                        #   |            |                             |   |\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61516,
                "title": "short-hashset-solution",
                "content": "    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        HashSet<Integer> hs=new HashSet<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(hs.add(nums[i])==false) return true;\\n            if(hs.size()==k+1) hs.remove(nums[i-k]);\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        HashSet<Integer> hs=new HashSet<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(hs.add(nums[i])==false) return true;\\n            if(hs.size()==k+1) hs.remove(nums[i-k]);\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 61534,
                "title": "my-simple-solution-in-java-using-hashmap",
                "content": "Iterate through array and use `HashMap` to save `number[i]` as key and `i` as value. If the map already contains `number[i]` - subtract `map.get(number[i])` from `i` and return true if result is less than or equal to `k`.\\n\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i]) && (i - map.get(nums[i])) <= k) {\\n                return true;\\n            }\\n            map.put(nums[i], i);\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Iterate through array and use `HashMap` to save `number[i]` as key and `i` as value. If the map already contains `number[i]` - subtract `map.get(number[i])` from `i` and return true if result is less than or equal to `k`.\\n\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i]) && (i - map.get(nums[i])) <= k) {\\n                return true;\\n            }\\n            map.put(nums[i], i);\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 61619,
                "title": "java-solution-using-set-and-sliding-window",
                "content": "My solution is simple. My set only contain the numbers in the window. slide the  window which is size k, if the new coming number cannot be add to set then return true. The time complexity is O(n), space complexity is O(k).\\n\\n    public class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        \\n        for(int i=0;i<nums.length && i<=k;i++){\\n            if(!set.add(nums[i])){\\n                return true;\\n            }\\n        }\\n        \\n        for(int i=k+1;i<nums.length;i++){\\n            set.remove(nums[i-k-1]);\\n            if(!set.add(nums[i])){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        \\n        for(int i=0;i<nums.length && i<=k;i++){\\n            if(!set.add(nums[i])){\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2727906,
                "title": "java-3-solutions-brute-force-sliding-window-hashmap",
                "content": "**Approach 1: Brute Force ~ TLE**\\n\\n```\\n// Time complexity: O(n\\xB2)\\n// Space complexity: O(1)\\n\\npublic boolean containsNearbyDuplicate(int[] nums, int k) {\\n\\t\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tfor (int j = i + 1; j <= i + k && j < nums.length; j++) {\\n\\t\\t\\tif (nums[i] == nums[j]) \\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\n\\treturn false;\\n}\\n```\\n\\n**Apporoach 2: Sliding Window**\\n\\n```\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\n\\npublic boolean containsNearbyDuplicate(int[] nums, int k) {\\n\\tSet<Integer> set = new HashSet<Integer>();\\n\\t\\n\\tfor(int i = 0; i < nums.length; i++) {\\n\\t\\tif (i > k) \\n\\t\\t\\tset.remove(nums[i-k-1]); \\n\\t\\t\\n\\t\\tif (!set.add(nums[i])) \\n\\t\\t\\treturn true; \\n\\t}\\n\\t\\n\\treturn false;\\n}\\n```\\n\\n**Approach 3: Using HashMap**\\n\\n```\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\n\\npublic boolean containsNearbyDuplicate(int[] nums, int k) {\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tif (map.containsKey(nums[i])) {\\n\\t\\t\\tif (i - map.get(nums[i]) <= k)\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tmap.put(nums[i], i);\\n\\t}\\n\\n\\treturn false;\\t\\n}\\n```\\n\\n**Please upvote if you find these solutions useful. Happy Coding!**",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\n// Time complexity: O(n\\xB2)\\n// Space complexity: O(1)\\n\\npublic boolean containsNearbyDuplicate(int[] nums, int k) {\\n\\t\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tfor (int j = i + 1; j <= i + k && j < nums.length; j++) {\\n\\t\\t\\tif (nums[i] == nums[j]) \\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\n\\treturn false;\\n}\\n```\n```\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\n\\npublic boolean containsNearbyDuplicate(int[] nums, int k) {\\n\\tSet<Integer> set = new HashSet<Integer>();\\n\\t\\n\\tfor(int i = 0; i < nums.length; i++) {\\n\\t\\tif (i > k) \\n\\t\\t\\tset.remove(nums[i-k-1]); \\n\\t\\t\\n\\t\\tif (!set.add(nums[i])) \\n\\t\\t\\treturn true; \\n\\t}\\n\\t\\n\\treturn false;\\n}\\n```\n```\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\n\\npublic boolean containsNearbyDuplicate(int[] nums, int k) {\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tif (map.containsKey(nums[i])) {\\n\\t\\t\\tif (i - map.get(nums[i]) <= k)\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tmap.put(nums[i], i);\\n\\t}\\n\\n\\treturn false;\\t\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 139491,
                "title": "javascript-beats-100",
                "content": "```\\nvar containsNearbyDuplicate = function(nums, k) {\\n    let ind = {}, n = nums.length;\\n    for (let i = 0; i < n; i++) {\\n        if (nums[i] in ind && i - ind[nums[i]] <= k) {\\n            return true;\\n        }\\n        ind[nums[i]] = i;\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar containsNearbyDuplicate = function(nums, k) {\\n    let ind = {}, n = nums.length;\\n    for (let i = 0; i < n; i++) {\\n        if (nums[i] in ind && i - ind[nums[i]] <= k) {\\n            return true;\\n        }\\n        ind[nums[i]] = i;\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 61559,
                "title": "javascript-solution",
                "content": "    function containsNearbyDuplicate(nums, k) {\\n      var map = {};\\n      for (var i = 0; i < nums.length; i++) {\\n        if (map[nums[i]] >= 0 && i - map[nums[i]] <= k) return true;\\n        map[nums[i]] = i;\\n      }\\n      return false;\\n    }",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    function containsNearbyDuplicate(nums, k) {\\n      var map = {};\\n      for (var i = 0; i < nums.length; i++) {\\n        if (map[nums[i]] >= 0 && i - map[nums[i]] <= k) return true;\\n        map[nums[i]] = i;\\n      }\\n      return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2727788,
                "title": "python-s-simple-and-easy-to-understand-solution-o-n-solution-99-faster",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        # Create dictionary for Lookup\\n        lookup = {}\\n        \\n        for i in range(len(nums)):\\n            \\n            # If num is present in lookup and satisfy the condition return True\\n            if nums[i] in lookup and abs(lookup[nums[i]]-i) <= k:\\n                return True\\n            \\n            # If num is not present in lookup then add it to lookup\\n            lookup[nums[i]] = i\\n        \\n        return False\\n```\\n**Visit this blog to learn Python tips and techniques and to find a Leetcode solution with an explanation:  https://www.python-techs.com/**\\n\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        # Create dictionary for Lookup\\n        lookup = {}\\n        \\n        for i in range(len(nums)):\\n            \\n            # If num is present in lookup and satisfy the condition return True\\n            if nums[i] in lookup and abs(lookup[nums[i]]-i) <= k:\\n                return True\\n            \\n            # If num is not present in lookup then add it to lookup\\n            lookup[nums[i]] = i\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3220320,
                "title": "javascript-easiest-logic-ever",
                "content": "# Intuition\\n1 -We could go ahead and check every window of size k, but this is going to take to long. Thus we need to use our knowledge of the previously checked window.\\n\\n2- Set is a good tool, when we want to check for similar values, but it doesn\\'t keep any knowledge of what\\'s been added when\\n\\n3- Queue is a good way to know what was the oldest element added, but not too quick to look for matches..\\n\\nThe idea is to sacrifice some memory to use both structures.\\n\\n# Approach\\nIterate nums from head to end. Add every new number to map, where key- number, value - index of number. If number in map- check condition that current index of number minus index of number from map less or equal \"k\". If true- return true. If false, rewrite value of current number in map by current index.\\nIf iteration is ended - return false\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar containsNearbyDuplicate = function(nums, k) {\\n    for(let i = 0; i <= nums.length-1; i++){\\n        let j = nums.length -1;\\n        while(i < j){\\n            if(nums[i] == nums[j] && Math.abs(i - j) <= k){\\n                return true\\n            }\\n            j--;\\n        }\\n       \\n    }\\n    return false\\n};\\n```\\n\\n# Using HashMap with JavaScript\\n````\\n// Time Complexity : O(n)\\n// Space Complexity : O(n)\\nvar containsNearbyDuplicate = function(nums, k) {\\n    const hasmap = new Map();\\n    for (let i = 0; i < nums.length; i++) {\\n        // Check if the difference betweend duplicates is less than k\\n        if (i - hasmap.get(nums[i]) <= k) {\\n            return true;\\n        }\\n        hasmap.set(nums[i], i);\\n    }\\n    return false;\\n};\\n````\\n##### I am working hard for you guys...\\n##### Please upvote if you found any help with this code...\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar containsNearbyDuplicate = function(nums, k) {\\n    for(let i = 0; i <= nums.length-1; i++){\\n        let j = nums.length -1;\\n        while(i < j){\\n            if(nums[i] == nums[j] && Math.abs(i - j) <= k){\\n                return true\\n            }\\n            j--;\\n        }\\n       \\n    }\\n    return false\\n};\\n```\n````\\n// Time Complexity : O(n)\\n// Space Complexity : O(n)\\nvar containsNearbyDuplicate = function(nums, k) {\\n    const hasmap = new Map();\\n    for (let i = 0; i < nums.length; i++) {\\n        // Check if the difference betweend duplicates is less than k\\n        if (i - hasmap.get(nums[i]) <= k) {\\n            return true;\\n        }\\n        hasmap.set(nums[i], i);\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2727219,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\n//Upvote If You Like The Solution\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        map<int,vector<int>> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]].push_back(i);\\n        }\\n        for(auto &it:mp)\\n        {\\n            if(it.second.size()>1)\\n            {\\n                for(int i=0;i<it.second.size()-1;i++)\\n                {\\n                    if(abs(it.second[i]-it.second[i+1])<=k)\\n                    {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//Upvote If You Like The Solution\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        map<int,vector<int>> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]].push_back(i);\\n        }\\n        for(auto &it:mp)\\n        {\\n            if(it.second.size()>1)\\n            {\\n                for(int i=0;i<it.second.size()-1;i++)\\n                {\\n                    if(abs(it.second[i]-it.second[i+1])<=k)\\n                    {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 832696,
                "title": "three-solutions-in-python-3-straightforward-more-pythonic-and-exotic",
                "content": "**Solution 1**\\n1. Start building a dictionary where a key is a digit and a value is an index of the digit.\\n2. If it\\'s a new element, just add this pair to the dictionary\\n3. If this digit is already in the dictionary, check whether the absolute difference of the current index and the index that is already sitting in the dictionary is ```<=k```.\\n4. If it\\'s the case, return True. Otherwise, rewrite the value in the dictionary.\\n\\n```\\ndef containsNearbyDuplicate(nums, k):  # update a dictionary once you see a duplicate and make a decision\\n\\tif len(nums) <= 1: return False  # no duplicates\\n    if len(set(nums)) == len(nums): return False  # no duplicates\\n    d = {}\\n    for i, n in enumerate(nums):\\n        if n not in d:\\n            d[n] = i\\n        else:\\n            idx_diff = abs(i - d[n])\\n            if idx_diff <= k:\\n                return True\\n            else: \\n\\t\\t\\t\\td[n] = i\\n    return False\\n```\\n\\n**Solution 2**:\\nIt uses ```defaultdict(list)```. \\n1. Create a defaultdict where values are lists with indices of respective elements.\\n2. Then take values that have length of more than 1. It means that a respective number has duplicates. It is saved in ```indices``` that is a list of lists.\\n3. Then I go through every list in this list of lists and check whether there are elements such that when you subtract one from another, the result is ```<= k```.\\n\\n```\\ndef containsNearbyDuplicate_default(nums, k):\\n    if len(nums) <= 1: return False \\n    if len(set(nums)) == len(nums): return False\\n    d = defaultdict(list)\\n    for ix, v in enumerate(nums):\\n        d[v].append(ix)\\n    indices = [v for v in d.values() if len(v) > 1]\\n    for ind in indices:\\n        return True if any(abs(ind[i] - ind[i + 1]) <= k for i in range(len(ind) - 1)) else False\\n```\\n\\n**Solution 3**:\\n1. Start adding elements to the set.\\n2. If you encounter an element that is already in the set, check whether the absolute difference between the index of this element and ```nums.index(nums[i]) <= k.``` If it is, return True. Otherwise, you need to substitute the element at index ```nums.index(nums[i])``` with ```-math.inf``` and keep going. The idea is that ```index()``` returns the index of a first occurance of the element, and you don\\'t longer want to consider this element and its index going forward. \\n3. This whole thing works iff you list doesn\\'t contain ```-math.inf```. But it\\'s the case for this question. Overall, you want to substitute with something that cannot be used in the list \\n\\n```\\ndef containsNearbyDuplicate_set(nums, k):\\n    s = set()\\n    for i in range(len(nums)):\\n        if nums[i] not in s:\\n            s.add(nums[i])\\n        else:\\n            if abs(i - nums.index(nums[i])) <= k:\\n                return True\\n            nums[nums.index(nums[i])] = -math.inf\\n    return False\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```<=k```\n```\\ndef containsNearbyDuplicate(nums, k):  # update a dictionary once you see a duplicate and make a decision\\n\\tif len(nums) <= 1: return False  # no duplicates\\n    if len(set(nums)) == len(nums): return False  # no duplicates\\n    d = {}\\n    for i, n in enumerate(nums):\\n        if n not in d:\\n            d[n] = i\\n        else:\\n            idx_diff = abs(i - d[n])\\n            if idx_diff <= k:\\n                return True\\n            else: \\n\\t\\t\\t\\td[n] = i\\n    return False\\n```\n```defaultdict(list)```\n```indices```\n```<= k```\n```\\ndef containsNearbyDuplicate_default(nums, k):\\n    if len(nums) <= 1: return False \\n    if len(set(nums)) == len(nums): return False\\n    d = defaultdict(list)\\n    for ix, v in enumerate(nums):\\n        d[v].append(ix)\\n    indices = [v for v in d.values() if len(v) > 1]\\n    for ind in indices:\\n        return True if any(abs(ind[i] - ind[i + 1]) <= k for i in range(len(ind) - 1)) else False\\n```\n```nums.index(nums[i]) <= k.```\n```nums.index(nums[i])```\n```-math.inf```\n```index()```\n```-math.inf```\n```\\ndef containsNearbyDuplicate_set(nums, k):\\n    s = set()\\n    for i in range(len(nums)):\\n        if nums[i] not in s:\\n            s.add(nums[i])\\n        else:\\n            if abs(i - nums.index(nums[i])) <= k:\\n                return True\\n            nums[nums.index(nums[i])] = -math.inf\\n    return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 734017,
                "title": "c-using-hashmap-with-explanation",
                "content": "In our map, we will use array elements as key and their index as value. Whenever an element is repeated, we just have to check whether the difference between previous value(using current element as key) and the current index is at most k.\\n\\t\\n\\tbool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        int l = nums.size();\\n        unordered_map<int,int> m;\\n        \\n        for(auto i=0;i<l;i++) {\\n            if(!m.count(nums[i])) // if element is not present in m\\n                m[nums[i]] = i;\\n            else  {\\n                if(abs(m[nums[i]]-i)<=k) // if the diff is at most k\\n                    return true;\\n                else\\n                    m[nums[i]] =i;   } }\\n        return false;   \\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "In our map, we will use array elements as key and their index as value. Whenever an element is repeated, we just have to check whether the difference between previous value(using current element as key) and the current index is at most k.\\n\\t\\n\\tbool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        int l = nums.size();\\n        unordered_map<int,int> m;\\n        \\n        for(auto i=0;i<l;i++) {\\n            if(!m.count(nums[i])) // if element is not present in m\\n                m[nums[i]] = i;\\n            else  {\\n                if(abs(m[nums[i]]-i)<=k) // if the diff is at most k\\n                    return true;\\n                else\\n                    m[nums[i]] =i;   } }\\n        return false;   \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 61503,
                "title": "c-5-lines-32ms-solution",
                "content": "    bool containsNearbyDuplicate(vector<int>& nums, int k)  {\\n        unordered_map<int,int> map;\\n        for(int i = 0; i < nums.size(); i++){\\n          if(map.count(nums[i]) && (i - map[nums[i]] <= k)) return true;\\n          map[nums[i]] = i;\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "    bool containsNearbyDuplicate(vector<int>& nums, int k)  {\\n        unordered_map<int,int> map;\\n        for(int i = 0; i < nums.size(); i++){\\n          if(map.count(nums[i]) && (i - map[nums[i]] <= k)) return true;\\n          map[nums[i]] = i;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3558557,
                "title": "beats-99-97-linear-time-complexity",
                "content": "# Simple to Understand a Solution\\n# Code\\n```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        d1 = {}\\n        for key, val in enumerate(nums):\\n            if val not in d1:\\n                d1[val] = key\\n            else:\\n                if abs(d1.get(val) - key) <= k:\\n                    return True\\n                else:\\n                    d1[val] = key\\n\\n        return False\\n```\\n\\n# Please Upvote if you can",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        d1 = {}\\n        for key, val in enumerate(nums):\\n            if val not in d1:\\n                d1[val] = key\\n            else:\\n                if abs(d1.get(val) - key) <= k:\\n                    return True\\n                else:\\n                    d1[val] = key\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227545,
                "title": "219-96-58-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nOne approach to solve this problem is by using a hash map. We will keep track of the indices of each element in the hash map. If we find a repeated element, we can check if the absolute difference between its current index and the previous index is less than or equal to k.\\n\\nIf the difference is less than or equal to k, we return true. If we iterate over the entire array and do not find any repeated elements with the required absolute difference, we return false.\\n\\n# Complexity\\n- Time complexity:\\nBeats\\n96.58% O(n) since we iterate over the array once.\\n\\n- Space complexity:\\nBeats\\n41.62% O(min(n,k)) since we can have at most min(n,k) elements in the hash map.\\n\\n# Code\\n```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        # create a hash map to store the indices of each element\\n        num_indices = {}\\n        \\n        # iterate over the array\\n        for i, num in enumerate(nums):\\n            # if the element is already in the hash map and its index difference is <= k, return True\\n            if num in num_indices and i - num_indices[num] <= k:\\n                return True\\n            \\n            # add the element to the hash map with its index\\n            num_indices[num] = i\\n        \\n        # if we don\\'t find any repeated elements with the required index difference, return False\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        # create a hash map to store the indices of each element\\n        num_indices = {}\\n        \\n        # iterate over the array\\n        for i, num in enumerate(nums):\\n            # if the element is already in the hash map and its index difference is <= k, return True\\n            if num in num_indices and i - num_indices[num] <= k:\\n                return True\\n            \\n            # add the element to the hash map with its index\\n            num_indices[num] = i\\n        \\n        # if we don\\'t find any repeated elements with the required index difference, return False\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918012,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        \\n        myDict={}\\n        \\n        for i in range(len(nums)):\\n            \\n            if nums[i] in myDict and abs(i-myDict[nums[i]])<=k:\\n                return True\\n            myDict[nums[i]]=i\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        \\n        myDict={}\\n        \\n        for i in range(len(nums)):\\n            \\n            if nums[i] in myDict and abs(i-myDict[nums[i]])<=k:\\n                return True\\n            myDict[nums[i]]=i\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805621,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        int n = nums.size();\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            // mp.count() will tell whatever ith index that I want, have I seen it before?\\n            if(mp.count(nums[i]))\\n            {\\n                // if I have already seen this number, then check for condition abs(i - j) <= k\\n                if(abs(i-mp[nums[i]])<=k)\\n                    return true;\\n            }\\n            // if I have not seen this number before, insert the number with its position in the map\\n            // and if the number is already present in the map, then update the position of that number\\n            mp[nums[i]] = i;\\n        }\\n        // after the complete traversal, if we don\\'t find a pair to satisfy the condition, return false\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        int n = nums.size();\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            // mp.count() will tell whatever ith index that I want, have I seen it before?\\n            if(mp.count(nums[i]))\\n            {\\n                // if I have already seen this number, then check for condition abs(i - j) <= k\\n                if(abs(i-mp[nums[i]])<=k)\\n                    return true;\\n            }\\n            // if I have not seen this number before, insert the number with its position in the map\\n            // and if the number is already present in the map, then update the position of that number\\n            mp[nums[i]] = i;\\n        }\\n        // after the complete traversal, if we don\\'t find a pair to satisfy the condition, return false\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1503118,
                "title": "contains-duplicate-java-hashmap-solution",
                "content": "```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<nums.length; i++) {\\n            int ithValue = nums[i];\\n            if(map.containsKey(ithValue) && Math.abs(map.get(ithValue)-i) <= k) {\\n                return true;\\n            } else {\\n                map.put(ithValue, i);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\nIf it helped, please UPVOTE. Happy Coding and keep up the good work.\\nFeel free to give your suggestions or correct me in the comments.\\nThanks for reading.\\uD83D\\uDE43",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<nums.length; i++) {\\n            int ithValue = nums[i];\\n            if(map.containsKey(ithValue) && Math.abs(map.get(ithValue)-i) <= k) {\\n                return true;\\n            } else {\\n                map.put(ithValue, i);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757974,
                "title": "simple-easy-to-understand-solution-using-hashmap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n\\n        for(int i=0; i<nums.length; i++){\\n            if(map.containsKey(nums[i]) && Math.abs(map.get(nums[i])-i)<=k){\\n                return true;\\n            }\\n            else{\\n                map.put(nums[i],i);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n\\n        for(int i=0; i<nums.length; i++){\\n            if(map.containsKey(nums[i]) && Math.abs(map.get(nums[i])-i)<=k){\\n                return true;\\n            }\\n            else{\\n                map.put(nums[i],i);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682275,
                "title": "3-approach-s-contains-duplicate-2-in-java",
                "content": "#### Brute Force\\n```\\n public boolean containsNearbyDuplicate(int[] nums, int k) {\\n    for(int i = 0; i < nums.length; i++){\\n        for(int j = i + 1; j < nums.length; j++){\\n            if(nums[i] == nums[j] && Math.abs(i - j) <= k){\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n }\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n#### HashMap\\n```\\n public boolean containsNearbyDuplicate(int[] nums, int k) {\\n    HashMap<Integer,Integer> map = new HashMap<>();\\n    for(int i = 0; i < nums.length; i++){\\n        if(map.containsKey(nums[i])){\\n            if(Math.abs(i - map.get(nums[i])) <= k ){\\n                return true;\\n            }\\n        }\\n        map.put(nums[i],i);\\n    }\\n    return false;\\n }\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n#### Sliding Window\\n```\\n public boolean containsNearbyDuplicate(int[] nums, int k) {\\n    HashSet<Integer> set = new HashSet<>();\\n    for(int i = 0; i < nums.length; i++){\\n        if(i > k){\\n            set.remove(nums[i - k - 1]);\\n        }\\n        if(!set.add(nums[i])){\\n            return true;\\n        }\\n    }\\n    return false;\\n }\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "```\\n public boolean containsNearbyDuplicate(int[] nums, int k) {\\n    for(int i = 0; i < nums.length; i++){\\n        for(int j = i + 1; j < nums.length; j++){\\n            if(nums[i] == nums[j] && Math.abs(i - j) <= k){\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n }\\n```\n```\\n public boolean containsNearbyDuplicate(int[] nums, int k) {\\n    HashMap<Integer,Integer> map = new HashMap<>();\\n    for(int i = 0; i < nums.length; i++){\\n        if(map.containsKey(nums[i])){\\n            if(Math.abs(i - map.get(nums[i])) <= k ){\\n                return true;\\n            }\\n        }\\n        map.put(nums[i],i);\\n    }\\n    return false;\\n }\\n```\n```\\n public boolean containsNearbyDuplicate(int[] nums, int k) {\\n    HashSet<Integer> set = new HashSet<>();\\n    for(int i = 0; i < nums.length; i++){\\n        if(i > k){\\n            set.remove(nums[i - k - 1]);\\n        }\\n        if(!set.add(nums[i])){\\n            return true;\\n        }\\n    }\\n    return false;\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2161965,
                "title": "python-hashmap-easily-explained",
                "content": "# Python Hashmap Easy Solution.\\n```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n\\t# when we see a num present in d, we check (if the current index - the index of d[num] ) <= k, \\n\\t# we return True, otherwise loop goes on and the duplicate key\\'s value gets updated with current index\\n\\t# and ofcourse we return False.\\n        d = {}\\n        for i, num in enumerate(nums):\\n            if num in d and i - d[num] <= k: # similar to (j - i) <= k, where the i==j(cur idx) and d[num] holds i\\n                return True\\n            d[num] = i\\n        return False\\n```\\n## Give it a **Upvote** If You Like My Explanation.\\n### Have a Great Day/Night.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n\\t# when we see a num present in d, we check (if the current index - the index of d[num] ) <= k, \\n\\t# we return True, otherwise loop goes on and the duplicate key\\'s value gets updated with current index\\n\\t# and ofcourse we return False.\\n        d = {}\\n        for i, num in enumerate(nums):\\n            if num in d and i - d[num] <= k: # similar to (j - i) <= k, where the i==j(cur idx) and d[num] holds i\\n                return True\\n            d[num] = i\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417053,
                "title": "easiest-c-solution-95-faster-hashmap",
                "content": "class Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n     \\n//please Upvote If It Helped.........\\t \\n    unordered_map<int,int>  m;  \\n        \\n    for(int i=0;i<nums.size();i++){\\n        \\n      if(m.count(nums[i])!=0 and (i-m[nums[i]]<=k)){\\n          return true;\\n      }   \\n        \\n      m[nums[i]]=i; \\n          \\n    }\\n   \\n        return false;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n     \\n//please Upvote If It Helped.........\\t \\n    unordered_map<int,int>  m;  \\n        \\n    for(int i=0;i<nums.size();i++){\\n        \\n      if(m.count(nums[i])!=0 and (i-m[nums[i]]<=k)){\\n          return true;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 61596,
                "title": "c-solution-with-hashtable",
                "content": "\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        unordered_map<int,int> m;\\n        for(int i=0;i<nums.size();i++){\\n            if(m.find(nums[i])!=m.end()&&m[nums[i]]>=i-k)\\n            return true;\\n            m[nums[i]]=i;\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        unordered_map<int,int> m;\\n        for(int i=0;i<nums.size();i++){\\n            if(m.find(nums[i])!=m.end()&&m[nums[i]]>=i-k)\\n            return true;\\n            m[nums[i]]=i;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3871961,
                "title": "deadly-simple-code-beats-90-46-in-runtime-87-12-in-memory-only-6-lines",
                "content": "\\n\\nPlease UPVOTE !!!\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/1ac86e7e-f1d1-4759-8419-bdfa74992c52_1691323623.0684834.png)\\n\\n\\n```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        if k==0:return False\\n        set_=set()\\n        for r in range(len(nums)):\\n            if nums[r] in set_:return True\\n            set_.add(nums[r])\\n            if len(set_)==k+1:set_.remove(nums[r-k])\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        if k==0:return False\\n        set_=set()\\n        for r in range(len(nums)):\\n            if nums[r] in set_:return True\\n            set_.add(nums[r])\\n            if len(set_)==k+1:set_.remove(nums[r-k])\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2727646,
                "title": "c-easy-daily-leetcoding-challenge-21st-october-2022",
                "content": "# Easy to understand(C++)\\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        unordered_map<int,int> Map;\\n        int n = nums.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            if(Map.count(nums[i]))\\n            {\\n                if(abs(i-Map[nums[i]])<=k)\\n                    return true;\\n            }\\n         Map[nums[i]] = i;\\n        }\\n        return false;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        unordered_map<int,int> Map;\\n        int n = nums.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            if(Map.count(nums[i]))\\n            {\\n                if(abs(i-Map[nums[i]])<=k)\\n                    return true;\\n            }\\n         Map[nums[i]] = i;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2727542,
                "title": "java-easy-explaination-hashmap-sliding-window",
                "content": "IF YOU LIKE THE SOLUTION \\nMAKE SURE TO UPVOTE IT.\\n\\nUSING HASHMAP :\\n```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        //Create a hashmap to store value of nums with their index.\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i = 0; i<nums.length; i++){\\n            // If nums[i] not present put it normally.\\n            if(map.get(nums[i]) == null)\\n                map.put(nums[i],i);\\n            else{\\n                //If already present get the value first\\n                Integer in = map.get(nums[i]);\\n                //Check out condition after getting the value\\n                //If satisfied return true here.\\n                if(Math.abs(in-i) <= k) return true;\\n                //If above statement return false it means we have \\n                // larger value than k, we need to update the value till now.\\n                map.put(nums[i],i);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\nSLIDING WINDOW USING HASHSET !\\n```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        \\n        // It means both i,j are same.\\n        if(k == 0) return false;\\n        \\n        HashSet<Integer> set = new HashSet<>();\\n        \\n        for(int i = 0; i<nums.length; i++){\\n            // Check if already present in set\\n            // Only that element is present in set who fulfil the given condition\\n            // abs(i-j) <=k\\n            if(set.contains(nums[i]))\\n                return true;\\n            // We are removing the elements who are unable to fulfil the given condition.\\n            if(i >= k)\\n                set.remove(nums[i-k]);\\n            // finally add the element\\n            set.add(nums[i]);\\n            \\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        //Create a hashmap to store value of nums with their index.\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i = 0; i<nums.length; i++){\\n            // If nums[i] not present put it normally.\\n            if(map.get(nums[i]) == null)\\n                map.put(nums[i],i);\\n            else{\\n                //If already present get the value first\\n                Integer in = map.get(nums[i]);\\n                //Check out condition after getting the value\\n                //If satisfied return true here.\\n                if(Math.abs(in-i) <= k) return true;\\n                //If above statement return false it means we have \\n                // larger value than k, we need to update the value till now.\\n                map.put(nums[i],i);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        \\n        // It means both i,j are same.\\n        if(k == 0) return false;\\n        \\n        HashSet<Integer> set = new HashSet<>();\\n        \\n        for(int i = 0; i<nums.length; i++){\\n            // Check if already present in set\\n            // Only that element is present in set who fulfil the given condition\\n            // abs(i-j) <=k\\n            if(set.contains(nums[i]))\\n                return true;\\n            // We are removing the elements who are unable to fulfil the given condition.\\n            if(i >= k)\\n                set.remove(nums[i-k]);\\n            // finally add the element\\n            set.add(nums[i]);\\n            \\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841854,
                "title": "c-easy-sliding-window-tc-o-n-sc-o-k",
                "content": "#### **SLIDING WINDOW :**\\n\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n\\t\\n\\tunordered_map<int, int> mp;\\n\\t\\n        for(int i=0, j=0; i<nums.size(); i++){\\n\\t\\t\\n\\t\\t//  Cheking if element find or not and if find then is the win-size <= k\\n            if(mp.count(nums[i])  &&  mp.size() <= k)  return true;\\n            \\n\\t\\t\\t//  If not found then insert the element\\n            mp[nums[i]] = i;\\n            \\n\\t\\t\\t//  If map size > k then remove the j th element\\n            if(mp.size() > k){\\n                mp.erase(nums[j]);\\n                j ++;\\n\\t\\t\\t}\\n\\t\\t}\\n        return false;\\n    }\\n};\\n**Time Complexity : O(N)    Space Complexity : O(K)**\\n\\n\\n\\n#### **Without SLIDING WINDOW :**\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n\\t\\n        unordered_map<int, int> mp;\\n        for(int i=0; i<nums.size(); i++){\\n\\t\\t\\n\\t\\t//  If element not found then insert it\\n            if(mp.find(nums[i])  ==  mp.end())\\n                mp[nums[i]] = i;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//  Otherwise if found then check the window size\\n            else{\\n\\t\\t\\t\\n\\t\\t\\t//  If window-size <= k  --->>  return true;\\n                if((i - mp[nums[i]])  <=  k)\\n                    return true;\\n                else\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//  Otherwise update key value\\n                    mp[nums[i]] = i;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n**Time Complexity : O(N)    Space Complexity : O(N)**\\n\\n### **Please please please up-vote if you like the solution**",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n\\t\\n\\tunordered_map<int, int> mp;\\n\\t\\n        for(int i=0, j=0; i<nums.size(); i++){\\n\\t\\t\\n\\t\\t//  Cheking if element find or not and if find then is the win-size <= k\\n            if(mp.count(nums[i])  &&  mp.size() <= k)  return true;\\n            \\n\\t\\t\\t//  If not found then insert the element\\n            mp[nums[i]] = i;\\n            \\n\\t\\t\\t//  If map size > k then remove the j th element\\n            if(mp.size() > k){\\n                mp.erase(nums[j]);\\n                j ++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 302661,
                "title": "c-concise-straightforward",
                "content": "```\\npublic class Solution {\\n    public bool ContainsNearbyDuplicate(int[] nums, int k) {\\n        Dictionary<int, int> dict = new Dictionary<int, int>();\\n        for (int i = 0; i < nums.Length; i++) {\\n            if (dict.ContainsKey(nums[i]) && i - dict[nums[i]] <= k)\\n                return true;\\n            dict[nums[i]] = i;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool ContainsNearbyDuplicate(int[] nums, int k) {\\n        Dictionary<int, int> dict = new Dictionary<int, int>();\\n        for (int i = 0; i < nums.Length; i++) {\\n            if (dict.ContainsKey(nums[i]) && i - dict[nums[i]] <= k)\\n                return true;\\n            dict[nums[i]] = i;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 281531,
                "title": "python-dictionary-solution-simply-explained",
                "content": "We want to check if there exists a pair of indices (`i` & `j`) whose absolute difference is at most `k` in the case that `nums[i]` == `nums[j]`.\\n* Initialize a hashmap and iterate through each index `i` and value `v` in `enumerate(nums)`. \\n* If `v` exists as a key in `hashmap` and the difference between the current index and the value of the existing index in the hashmp is at most `k`, then return `True`\\n* If `v` does not exist as a key in `hashmap`, add it as `hashmap[v] = i`\\n* If we reach the end of iteration, return `False`\\n\\n```\\ndef containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n\\thashmap = {}\\n\\tfor i,v in enumerate(nums):\\n\\t\\tif v in hashmap and i - hashmap[v] <= k:\\n\\t\\t\\treturn True\\n\\t\\thashmap[v] = i\\n\\treturn False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n\\thashmap = {}\\n\\tfor i,v in enumerate(nums):\\n\\t\\tif v in hashmap and i - hashmap[v] <= k:\\n\\t\\t\\treturn True\\n\\t\\thashmap[v] = i\\n\\treturn False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3108401,
                "title": "aditya-verma-approach-sliding-window-with-fixed-size-window",
                "content": "# Intuition\\nSliding window with fixed size window\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        int i=0,j=0,n=nums.size();\\n        if(k<n){\\n            k=k+1;\\n        }\\n        else{\\n            k=n;\\n        }\\n        unordered_map<int,int>mp;\\n        while(j<n){\\n            mp[nums[j]]++;\\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n                if(mp.size()<k){\\n                    return true;\\n                }\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0){\\n                    mp.erase(nums[i]);\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        int i=0,j=0,n=nums.size();\\n        if(k<n){\\n            k=k+1;\\n        }\\n        else{\\n            k=n;\\n        }\\n        unordered_map<int,int>mp;\\n        while(j<n){\\n            mp[nums[j]]++;\\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n                if(mp.size()<k){\\n                    return true;\\n                }\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0){\\n                    mp.erase(nums[i]);\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2603210,
                "title": "javascript-solution-top-99-speed-95-ms",
                "content": "### Solution:\\n\\n```js\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar containsNearbyDuplicate = function(nums, k) {\\n    let set = new Set();\\n    for (let i = 0; i < nums.length; ++i) {\\n        if (set.has(nums[i])) {\\n            return true;\\n        }\\n        \\n        set.add(nums[i]);\\n        \\n        if (set.size > k) {\\n            set.delete(nums[i - k]);\\n        }\\n    }\\n    return false;\\n\\t\\n};\\n```\\n\\n### LeetCode Output\\nRuntime: **95 ms**, faster than **99.60%** of JavaScript online submissions for Contains Duplicate II.\\nMemory Usage: **56.2 MB**, less than **78.05%** of JavaScript online submissions for Contains Duplicate II.\\n\\n[Link to submission](https://leetcode.com/submissions/detail/804890176/)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar containsNearbyDuplicate = function(nums, k) {\\n    let set = new Set();\\n    for (let i = 0; i < nums.length; ++i) {\\n        if (set.has(nums[i])) {\\n            return true;\\n        }\\n        \\n        set.add(nums[i]);\\n        \\n        if (set.size > k) {\\n            set.delete(nums[i - k]);\\n        }\\n    }\\n    return false;\\n\\t\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 381965,
                "title": "python-solutions",
                "content": "# Using dictionary\\n\\n```python\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        positions = {}\\n        for idx, num in enumerate(nums):\\n            if num in positions and (idx - positions[num] <= k):\\n                return True\\n            positions[num] = idx\\n        return False\\n```\\n\\nTime `O(n)` / Space `O(n)`\\n\\n# Using set\\n\\n```python\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        rolling_window = set()\\n        for idx, num in enumerate(nums):\\n            if idx > k:\\n                rolling_window.remove(nums[idx-k-1])\\n            if num in rolling_window:\\n                return True\\n            rolling_window.add(num)\\n        return False\\n```\\n\\nTime `O(n)` / Space `O(k)`",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        positions = {}\\n        for idx, num in enumerate(nums):\\n            if num in positions and (idx - positions[num] <= k):\\n                return True\\n            positions[num] = idx\\n        return False\\n```\n```python\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        rolling_window = set()\\n        for idx, num in enumerate(nums):\\n            if idx > k:\\n                rolling_window.remove(nums[idx-k-1])\\n            if num in rolling_window:\\n                return True\\n            rolling_window.add(num)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141077,
                "title": "python-sliding-window-solution",
                "content": "```\\nclass Solution(object):\\n    def containsNearbyDuplicate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: bool\\n        \"\"\"\\n        window = set()\\n        for i in xrange(0, len(nums)):\\n            if len(window) >= k+1:\\n                window.remove(nums[i-k-1])\\n            if nums[i] in window:\\n                return True\\n            window.add(nums[i])\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def containsNearbyDuplicate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: bool\\n        \"\"\"\\n        window = set()\\n        for i in xrange(0, len(nums)):\\n            if len(window) >= k+1:\\n                window.remove(nums[i-k-1])\\n            if nums[i] in window:\\n                return True\\n            window.add(nums[i])\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61396,
                "title": "use-hashset-40ms-python-beat-94",
                "content": "hash a K-length moving window of nums.  When moving along, do not reconstruct the set, just add the new one, and remove the earliest element.\\n\\n    class Solution(object):\\n        def containsNearbyDuplicate(self, nums, k):\\n            \"\"\"\\n            :type nums: List[int]\\n            :type k: int\\n            :rtype: bool\\n            \"\"\"\\n            if len(nums)<=k:\\n                return len(nums) >  len(set(nums))\\n    \\n            hashSet=set(nums[:k])\\n            if len(hashSet) < k:\\n                return True\\n    \\n            for i in xrange(k,len(nums)):\\n                hashSet.add(nums[i])\\n                if len(hashSet)==k:\\n                    return True\\n                else:\\n                    hashSet.remove(nums[i-k])\\n            return False",
                "solutionTags": [],
                "code": "hash a K-length moving window of nums.  When moving along, do not reconstruct the set, just add the new one, and remove the earliest element.\\n\\n    class Solution(object):\\n        def containsNearbyDuplicate(self, nums, k):\\n            \"\"\"\\n            :type nums: List[int]\\n            :type k: int\\n            :rtype: bool\\n            \"\"\"\\n            if len(nums)<=k:\\n                return len(nums) >  len(set(nums))\\n    \\n            hashSet=set(nums[:k])\\n            if len(hashSet) < k:\\n                return True\\n    \\n            for i in xrange(k,len(nums)):\\n                hashSet.add(nums[i])\\n                if len(hashSet)==k:\\n                    return True\\n                else:\\n                    hashSet.remove(nums[i-k])\\n            return False",
                "codeTag": "Java"
            },
            {
                "id": 2729255,
                "title": "java-easy-and-fast-solution-using-hashmap",
                "content": "```\\n// class Solution {\\n//     public boolean containsNearbyDuplicate(int[] nums, int k) {\\n//         int n=nums.length;\\n//         for(int i=0;i<n;i++){\\n//             for(int j=i+1;j<n && j<=i+k;j++){\\n//                 if(nums[i]==nums[j]){\\n//                     return true;\\n//                 }\\n//             }\\n//         }\\n//         return false;\\n//     }\\n// }\\n\\n/*--------------------using HashMap--------------------*/\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        int n=nums.length;\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            if(hm.containsKey(nums[i])){\\n                if(i-hm.get(nums[i])<=k){\\n                    return true;\\n                }\\n            }\\n            hm.put(nums[i],i);\\n        }\\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n// class Solution {\\n//     public boolean containsNearbyDuplicate(int[] nums, int k) {\\n//         int n=nums.length;\\n//         for(int i=0;i<n;i++){\\n//             for(int j=i+1;j<n && j<=i+k;j++){\\n//                 if(nums[i]==nums[j]){\\n//                     return true;\\n//                 }\\n//             }\\n//         }\\n//         return false;\\n//     }\\n// }\\n\\n/*--------------------using HashMap--------------------*/\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        int n=nums.length;\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            if(hm.containsKey(nums[i])){\\n                if(i-hm.get(nums[i])<=k){\\n                    return true;\\n                }\\n            }\\n            hm.put(nums[i],i);\\n        }\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2728450,
                "title": "python-rust-c-fast-concise-using-hashmap-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a hashmap/dictionary to store all encountered numbers and their corresponding indices. Time complexity is linear: **O(n)**. Space complexity is linear: **O(n)**. \\n\\n| Language | Runtime | Memory |\\n|---|---|---|\\n| [**Python**](https://leetcode.com/submissions/detail/827150754/) | **619 ms (97.66%)** | **27.3 MB  (53.63%)** |\\n| [**Rust**](https://leetcode.com/submissions/detail/827155470/) | **14 ms (100.00%)** | **5.4 MB (49.19%)** |\\n| [**C++**](https://leetcode.com/submissions/detail/827160947/) | **152 ms (99.69%)** | **77.2 MB  (33.65%)** |\\n\\n<iframe src=\"https://leetcode.com/playground/9Vj3rbyy/shared\" frameBorder=\"0\" width=\"800\" height=\"480\"></iframe>\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "Rust"
                ],
                "code": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a hashmap/dictionary to store all encountered numbers and their corresponding indices. Time complexity is linear: **O(n)**. Space complexity is linear: **O(n)**. \\n\\n| Language | Runtime | Memory |\\n|---|---|---|\\n| [**Python**](https://leetcode.com/submissions/detail/827150754/) | **619 ms (97.66%)** | **27.3 MB  (53.63%)** |\\n| [**Rust**](https://leetcode.com/submissions/detail/827155470/) | **14 ms (100.00%)** | **5.4 MB (49.19%)** |\\n| [**C++**](https://leetcode.com/submissions/detail/827160947/) | **152 ms (99.69%)** | **77.2 MB  (33.65%)** |\\n\\n<iframe src=\"https://leetcode.com/playground/9Vj3rbyy/shared\" frameBorder=\"0\" width=\"800\" height=\"480\"></iframe>\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2727975,
                "title": "javascript-3-solutions-brute-force-sliding-window-map",
                "content": "**Approach 1: Brute Force**\\n\\n```\\n// Time complexity: O(n\\xB2)\\n// Space complexity: O(1)\\n\\nvar containsNearbyDuplicate = function(nums, k) {\\n\\t\\n\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\tfor (let j = i + 1; j <= i + k && j < nums.length; j++) {\\n\\t\\t\\tif (nums[i] === nums[j]) \\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\n\\treturn false;\\n};\\n```\\n\\n**Apporoach 2: Sliding Window**\\n\\n```\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\n\\nvar containsNearbyDuplicate = function(nums, k) {\\n\\tconst set = new Set();\\n\\t\\n\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\tif (i > k) \\n\\t\\t\\tset.delete(nums[i - k - 1]); \\n\\t\\t\\n\\t\\tif (!set.has(nums[i])) \\n            set.add(nums[i]);\\n        else\\n            return true;\\n\\t}\\n\\t\\n\\treturn false;\\n};\\n```\\n\\n**Approach 3: Using Map**\\n\\n```\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\n\\nvar containsNearbyDuplicate = function(nums, k) {\\n\\tconst map = new Map();\\n\\n\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\tif (map.has(nums[i])) {\\n\\t\\t\\tif (i - map.get(nums[i]) <= k)\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tmap.set(nums[i], i);\\n\\t}\\n\\n\\treturn false;\\t\\n};\\n```\\n\\n**Please upvote if you find these solutions useful. Happy Coding!**",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\n// Time complexity: O(n\\xB2)\\n// Space complexity: O(1)\\n\\nvar containsNearbyDuplicate = function(nums, k) {\\n\\t\\n\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\tfor (let j = i + 1; j <= i + k && j < nums.length; j++) {\\n\\t\\t\\tif (nums[i] === nums[j]) \\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\n\\treturn false;\\n};\\n```\n```\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\n\\nvar containsNearbyDuplicate = function(nums, k) {\\n\\tconst set = new Set();\\n\\t\\n\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\tif (i > k) \\n\\t\\t\\tset.delete(nums[i - k - 1]); \\n\\t\\t\\n\\t\\tif (!set.has(nums[i])) \\n            set.add(nums[i]);\\n        else\\n            return true;\\n\\t}\\n\\t\\n\\treturn false;\\n};\\n```\n```\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\n\\nvar containsNearbyDuplicate = function(nums, k) {\\n\\tconst map = new Map();\\n\\n\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\tif (map.has(nums[i])) {\\n\\t\\t\\tif (i - map.get(nums[i]) <= k)\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tmap.set(nums[i], i);\\n\\t}\\n\\n\\treturn false;\\t\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2727193,
                "title": "daily-leetcoding-challenge-october-day-21",
                "content": "This problem is the Daily LeetCoding Challenge for October, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/contains-duplicate-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Naive Linear Search\n\n  \n**Approach 2:** Binary Search Tree\n\n  \n**Approach 3:** Hash Table\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/contains-duplicate-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2189626,
                "title": "python3-sliding-window",
                "content": "```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        l = set()\\n        for i in range(len(nums)):\\n            if len(l) >= k+1:\\n                l.remove(nums[i-k-1]) # remove left-most elem\\n            if nums[i] in l:\\n                return True\\n            l.add(nums[i])\\n        return False\\n```\\t\\n\\t",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        l = set()\\n        for i in range(len(nums)):\\n            if len(l) >= k+1:\\n                l.remove(nums[i-k-1]) # remove left-most elem\\n            if nums[i] in l:\\n                return True\\n            l.add(nums[i])\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61410,
                "title": "python-solution-with-detailed-discussion",
                "content": "**Solution with discussion**https://discuss.leetcode.com/topic/79863/python-solution-with-detailed-discussion\\n\\n**Contains Duplicate II** https://leetcode.com/problems/contains-duplicate-ii/\\n\\n* When we iterate the array, we receive the indces of the same element in ascending order. This is an important insight to remember.\\n* Assume k = 3. Say we see x=5 at index 4. Then we see it again at index 8. 8-4 > 3 and this doesnt meet our criterion. Now any other index of 5 will definitely not meet meet the criterion with respect to index 4, since the difference will surely be more than 4.\\n* This means that we can build a last_seen_index dictionary and update the last_seen index when we do not meet the criterion or return True if we do.\\n\\n```\\nclass Solution(object):\\n    def containsNearbyDuplicate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: bool\\n        \"\"\"\\n        last_seen_index = {}\\n        for idx, x in enumerate(nums):\\n            if x in last_seen_index and idx - last_seen_index[x] <= k:\\n                return True\\n            last_seen_index[x] = idx\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def containsNearbyDuplicate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: bool\\n        \"\"\"\\n        last_seen_index = {}\\n        for idx, x in enumerate(nums):\\n            if x in last_seen_index and idx - last_seen_index[x] <= k:\\n                return True\\n            last_seen_index[x] = idx\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069377,
                "title": "python-99-runtime-hash-table-easy-to-understand",
                "content": "**Plz Upvote ..if you got help from this.**\\n# Code\\n```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        d = {}\\n\\n        for i, n in enumerate(nums):\\n          if n in d and abs(i - d[n]) <= k:\\n            return True\\n          else:\\n            d[n] = i\\n        \\n        return False\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        d = {}\\n\\n        for i, n in enumerate(nums):\\n          if n in d and abs(i - d[n]) <= k:\\n            return True\\n          else:\\n            d[n] = i\\n        \\n        return False\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447001,
                "title": "simple-solution-on-c-using-map",
                "content": "# Approach\\n1. Crete map and go through the array\\n2. If element isn\\'t in the array, we add key with curret index into map\\n3. If element is in the array, we check if difference between i and map[nums[i]] <=k\\n4. If is true6 return true\\n5. Else update value (index) for key\\n\\n# Complexity\\n- Time complexity: O(N * log(N)))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        std::map<int, int> m;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (m.count(nums[i]) > 0) {\\n                if (i - m[nums[i]] <= k)\\n                    return true;\\n                else\\n                    m[nums[i]] = i;\\n            } else {\\n                m.insert({nums[i], i});\\n            }\\n\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        std::map<int, int> m;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (m.count(nums[i]) > 0) {\\n                if (i - m[nums[i]] <= k)\\n                    return true;\\n                else\\n                    m[nums[i]] = i;\\n            } else {\\n                m.insert({nums[i], i});\\n            }\\n\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2728012,
                "title": "c-easy-c-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        vector<pair<int,int>> v;\\n\\n        for( int i =0; i<nums.size(); i++)\\n             v.push_back({nums[i],i});\\n  \\n        sort(v.begin(),v.end());\\n\\n        for(int i=0; i<nums.size()-1; i++)\\n             if(v[i].first==v[i+1].first and abs(v[i].second- v[i+1].second)<=k)return true;\\n   \\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        vector<pair<int,int>> v;\\n\\n        for( int i =0; i<nums.size(); i++)\\n             v.push_back({nums[i],i});\\n  \\n        sort(v.begin(),v.end());\\n\\n        for(int i=0; i<nums.size()-1; i++)\\n             if(v[i].first==v[i+1].first and abs(v[i].second- v[i+1].second)<=k)return true;\\n   \\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2727854,
                "title": "hashmap-simple-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nu, int k) {\\n        int n = nu.size();\\n        unordered_map<int,int> mp;\\n        for(int p=0;p<n;p++){\\n            mp[nu[p]]++;\\n        }\\n        for(int p=0;p<n;p++){\\n            if(mp[nu[p]]==1){\\n                continue;\\n            }\\n            for(int q=p+1;q<n;q++){\\n                if(nu[q]==nu[p]){\\n                    if((q-p)<=k){\\n                      return true;  \\n                    } \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nu, int k) {\\n        int n = nu.size();\\n        unordered_map<int,int> mp;\\n        for(int p=0;p<n;p++){\\n            mp[nu[p]]++;\\n        }\\n        for(int p=0;p<n;p++){\\n            if(mp[nu[p]]==1){\\n                continue;\\n            }\\n            for(int q=p+1;q<n;q++){\\n                if(nu[q]==nu[p]){\\n                    if((q-p)<=k){\\n                      return true;  \\n                    } \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1914744,
                "title": "python-faster-than-89-dictionary-easy-solution",
                "content": "# Please upvote if it helps.\\n```\\ndef containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        dic = {}\\n        \\n        for i,n in enumerate(nums):\\n            if n in dic and abs(dic.get(n) - i) <= k:\\n                return True\\n            else:\\n                dic[n]=i\\n                \\n        return False\\n```\\n\\n--> Thanks !\\n![image](https://assets.leetcode.com/users/images/9a8e20bd-335f-4a74-ad03-281b92c97a5b_1649100163.8168194.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        dic = {}\\n        \\n        for i,n in enumerate(nums):\\n            if n in dic and abs(dic.get(n) - i) <= k:\\n                return True\\n            else:\\n                dic[n]=i\\n                \\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1777212,
                "title": "c-solution-with-ut-hash",
                "content": "There is no hash solution for C code currently so I am posting my own. Hope it helps \\n```\\nstruct hash_struct {\\n    int id;\\n    int value;\\n    UT_hash_handle hh;\\n};\\n\\nbool containsNearbyDuplicate(int* nums, int numsSize, int k){\\n    struct hash_struct *map = NULL;\\n    for(int i = 0; i < numsSize; i++){\\n        struct hash_struct *temp;\\n        HASH_FIND_INT(map, &nums[i], temp);\\n        if(temp == NULL){\\n            temp = (struct hash_struct *)malloc(sizeof(struct hash_struct));\\n            temp -> id = nums[i];\\n            temp -> value = i;\\n            HASH_ADD_INT(map, id, temp);\\n        } else {\\n            if((i - temp -> value) <= k) {\\n                return true;\\n            } else {\\n                temp -> value = i;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct hash_struct {\\n    int id;\\n    int value;\\n    UT_hash_handle hh;\\n};\\n\\nbool containsNearbyDuplicate(int* nums, int numsSize, int k){\\n    struct hash_struct *map = NULL;\\n    for(int i = 0; i < numsSize; i++){\\n        struct hash_struct *temp;\\n        HASH_FIND_INT(map, &nums[i], temp);\\n        if(temp == NULL){\\n            temp = (struct hash_struct *)malloc(sizeof(struct hash_struct));\\n            temp -> id = nums[i];\\n            temp -> value = i;\\n            HASH_ADD_INT(map, id, temp);\\n        } else {\\n            if((i - temp -> value) <= k) {\\n                return true;\\n            } else {\\n                temp -> value = i;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1631026,
                "title": "easy-solution-python",
                "content": "```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        \\n        if len(set(nums)) == len(nums):\\n            return False    \\n        for i in range(len(nums)):\\n            if len(nums[i:i+k+1])!=len(set(nums[i:i+k+1])):\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        \\n        if len(set(nums)) == len(nums):\\n            return False    \\n        for i in range(len(nums)):\\n            if len(nums[i:i+k+1])!=len(set(nums[i:i+k+1])):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1510002,
                "title": "simple-java-solution-sliding-window",
                "content": "According to question , abs(j-i)<=k is given which means it related to fixed sliding window problem.\\n\\n**why fixed sliding window?**\\n\\tBecause the value of j-i can not be greater than k and once  we reach j-i=k then we will maintain it.\\nso our window size is k=j-i\\n\\n**Why LinkedHashSet?**\\nUsing linkedHashset because we need to maintain the order of the window as well as window does not contain duplicate. If the window contain duplicates we will return TRUE\\n\\n```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        int n=nums.length;\\n        int i=0;\\n        int j=0;\\n        LinkedHashSet<Integer> hs=new LinkedHashSet<>();\\n        \\n        while(j<n)\\n        {\\n            if(hs.contains(nums[j]))\\n                return true;\\n            hs.add(nums[j]);\\n            if(j-i<k)\\n                j++;\\n            else if(j-i==k)\\n            {\\n                hs.remove(nums[i]);\\n                i++;j++;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\nplease **upvote** if u liked>>",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        int n=nums.length;\\n        int i=0;\\n        int j=0;\\n        LinkedHashSet<Integer> hs=new LinkedHashSet<>();\\n        \\n        while(j<n)\\n        {\\n            if(hs.contains(nums[j]))\\n                return true;\\n            hs.add(nums[j]);\\n            if(j-i<k)\\n                j++;\\n            else if(j-i==k)\\n            {\\n                hs.remove(nums[i]);\\n                i++;j++;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1364843,
                "title": "easy-to-understand",
                "content": "```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        if len(set(nums)) == len(nums):\\n            return False\\n        for i in range(len(nums)):\\n            if len(set(nums[i : i+k+1])) < len(nums[i : i+k+1]):\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        if len(set(nums)) == len(nums):\\n            return False\\n        for i in range(len(nums)):\\n            if len(set(nums[i : i+k+1])) < len(nums[i : i+k+1]):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065540,
                "title": "c-easy-unordered-set-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        unordered_set<int> set;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(set.count(nums[i])>0)\\n                return true;\\n            set.insert(nums[i]);\\n            if(set.size()>k)\\n            {\\n                set.erase(nums[i-k]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        unordered_set<int> set;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(set.count(nums[i])>0)\\n                return true;\\n            set.insert(nums[i]);\\n            if(set.size()>k)\\n            {\\n                set.erase(nums[i-k]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61473,
                "title": "6-lines-python-solution",
                "content": "```\\nclass Solution(object):\\n    def containsNearbyDuplicate(self, nums, k):\\n        h = {}\\n        for i, num in enumerate(nums):\\n            if num in h and i - h[num] <= k:\\n                return True\\n            h[num] = i\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def containsNearbyDuplicate(self, nums, k):\\n        h = {}\\n        for i, num in enumerate(nums):\\n            if num in h and i - h[num] <= k:\\n                return True\\n            h[num] = i\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61518,
                "title": "c-12ms-by-hashtable",
                "content": "    struct LinkedNode\\n    {\\n        int val;\\n        LinkedNode *next;\\n        LinkedNode(int x = 0) : val(x), next(NULL) {}\\n    };\\n    \\n    bool containsNearbyDuplicate(vector<int>& nums, int k)\\n    {\\n        int len = nums.size();\\n        if(len <= 1) return false;\\n        int D = len;\\n        LinkedNode *nodes = new LinkedNode[D];\\n        for(int i = 0;i < len;++i)\\n        {\\n            int bucket = abs(nums[i]) % D;\\n            LinkedNode *node = nodes[bucket].next;\\n            while(node)\\n            {\\n                int j = node->val;\\n                if(nums[i] == nums[j] && i - j <= k) return true;\\n                node = node->next;\\n            }\\n            node = nodes[bucket].next;\\n            nodes[bucket].next = new LinkedNode(i);\\n            nodes[bucket].next->next = node;\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "    struct LinkedNode\\n    {\\n        int val;\\n        LinkedNode *next;\\n        LinkedNode(int x = 0) : val(x), next(NULL) {}\\n    };\\n    \\n    bool containsNearbyDuplicate(vector<int>& nums, int k)\\n    {\\n        int len = nums.size();\\n        if(len <= 1) return false;\\n        int D = len;\\n        LinkedNode *nodes = new LinkedNode[D];\\n        for(int i = 0;i < len;++i)\\n        {\\n            int bucket = abs(nums[i]) % D;\\n            LinkedNode *node = nodes[bucket].next;\\n            while(node)\\n            {\\n                int j = node->val;\\n                if(nums[i] == nums[j] && i - j <= k) return true;\\n                node = node->next;\\n            }\\n            node = nodes[bucket].next;\\n            nodes[bucket].next = new LinkedNode(i);\\n            nodes[bucket].next->next = node;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 61588,
                "title": "i-use-set-instead-of-map",
                "content": "    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        unordered_set<int> hashSet;\\n        if (!k) return false;\\n        if (k >= nums.size()) k = nums.size()-1;\\n        for (int i = 0;i <= k;++i)\\n            if (hashSet.find(nums[i]) == hashSet.end())\\n                hashSet.insert(nums[i]);\\n            else\\n                return true;\\n        for (int i = k+1;i < nums.size();++i) {\\n            hashSet.erase(nums[i-k-1]);\\n            if (hashSet.find(nums[i]) == hashSet.end())\\n                hashSet.insert(nums[i]);\\n            else\\n                return true;\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        unordered_set<int> hashSet;\\n        if (!k) return false;\\n        if (k >= nums.size()) k = nums.size()-1;\\n        for (int i = 0;i <= k;++i)\\n            if (hashSet.find(nums[i]) == hashSet.end())\\n                hashSet.insert(nums[i]);\\n            else\\n                return true;\\n        for (int i = k+1;i < nums.size();++i) {\\n            hashSet.erase(nums[i-k-1]);\\n            if (hashSet.find(nums[i]) == hashSet.end())\\n                hashSet.insert(nums[i]);\\n            else\\n                return true;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2730592,
                "title": "aproach-using-maps-2-pass-1-pass",
                "content": "I\\'ll go from an unimproved to the improved version.\\n\\nMain Idea (2-pass) -\\n* Store the indices of same nums[i] and compare them.\\n* **We need to only compare the adjacent ones as we need abs(i-j) less than/equal to k. Having to compare values which are not adjacent will only give a worse answer.**\\n* Thus we can store a map of vectors, where a value will point to the different indices, stored in a vector. In other words, we need to have a `map<int, vector<int>>`  and then iterate compute for all adjacent elements of different vectors in the map.\\n* Time Complexity : `O(n)` Since the **size of all vectors which we are iterating sums up to the actual size of the array.**\\n* Space Complexity : `O(n)` Additional space due to the map used.\\n\\nCode :\\n```c++\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n\\n        int n = nums.size();\\n\\n        map<int, vector<int>> mp;\\n        for(int i=0; i<n; i++) \\n            mp[nums[i]].push_back(i);\\n        \\n        map<int, vector<int>> :: iterator itr;\\n        \\n        for(itr = mp.begin(); itr != mp.end(); itr++) {\\n            int sz = (itr->second).size();\\n            for(int i=0; i<sz-1; i++)\\n                if(abs(itr->second[i] - itr->second[i+1]) <= k)\\n                    return true;\\n        }\\n        \\n        return false;\\n    }\\n        \\n};\\n```\\n\\nIdea for (1-pass) Solution :\\n* Since we only need to compare adjacent values and indices are increasing as we traverse ahead, **it is only required to store the greatest index of num[i] encountered till then.** Thus, `mp[nums[i]] = idx;`\\n* If we encounter the the same element with different index we just calculate `abs(i - mp[num[i]])`. If it is `<= k` return `true`, else we just update the map with `i` for next comparison.\\n* Time Complexity : `O(nlogn)`. **One Pass is needed. + We need to check .find() which is logarithmic. in a map**\\n* Space Complexity : `O(n)`. Size of the map equal total number of unique numbers. \\n\\nCode :\\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n\\n        int n = nums.size();\\n        \\n        map<int, int> mp;\\n        for(int i=0; i<n; i++) {\\n\\t\\t\\t// element already exists\\n\\t\\t\\t// check takes O(logn) in a map and O(1) in unordered map \\n            if(mp.find(nums[i]) != mp.end()) {\\n                if(abs(mp[nums[i]] - i) <= k)\\n                    return true; // condition satisfied\\n                else\\n                    mp[nums[i]] = i;\\n\\t\\t\\t\\t\\t// just update with latest index for next check.\\n            }\\n            \\n\\t\\t\\t// adding new element\\n            else \\n\\t\\t\\t\\tmp[nums[i]] = i; \\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n\\nFinal Optimization Step -\\n**Likewise, we can use `unordered map<int, int>` in the 1-pass case and Time Complexity reduces to `O(n)`.**",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n\\n        int n = nums.size();\\n\\n        map<int, vector<int>> mp;\\n        for(int i=0; i<n; i++) \\n            mp[nums[i]].push_back(i);\\n        \\n        map<int, vector<int>> :: iterator itr;\\n        \\n        for(itr = mp.begin(); itr != mp.end(); itr++) {\\n            int sz = (itr->second).size();\\n            for(int i=0; i<sz-1; i++)\\n                if(abs(itr->second[i] - itr->second[i+1]) <= k)\\n                    return true;\\n        }\\n        \\n        return false;\\n    }\\n        \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n\\n        int n = nums.size();\\n        \\n        map<int, int> mp;\\n        for(int i=0; i<n; i++) {\\n\\t\\t\\t// element already exists\\n\\t\\t\\t// check takes O(logn) in a map and O(1) in unordered map \\n            if(mp.find(nums[i]) != mp.end()) {\\n                if(abs(mp[nums[i]] - i) <= k)\\n                    return true; // condition satisfied\\n                else\\n                    mp[nums[i]] = i;\\n\\t\\t\\t\\t\\t// just update with latest index for next check.\\n            }\\n            \\n\\t\\t\\t// adding new element\\n            else \\n\\t\\t\\t\\tmp[nums[i]] = i; \\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2729730,
                "title": "c-qsort-sort-by-value-and-index-o-nlogn",
                "content": "```\\ntypedef struct {\\n    int val;\\n    int idx;\\n} Arr_t;\\n\\nint cmp (const void * a, const void * b) {\\n    Arr_t *m = (Arr_t *)a;\\n    Arr_t *n = (Arr_t *)b;\\n    if (m->val != n->val) {\\n        return m->val - n->val;\\n    }\\n    else {\\n        return m->idx - n->idx;\\n    }\\n}\\n\\nint absdiff(int a, int b) {\\n    return a > b ? a - b : b - a;\\n}\\n\\nbool containsNearbyDuplicate(int* nums, int numsSize, int k){\\n    Arr_t *arr = (Arr_t*) malloc(numsSize * sizeof(Arr_t));\\n    for (int i = 0; i < numsSize; i++) {\\n        arr[i].val = nums[i];\\n        arr[i].idx = i;\\n    }\\n    \\n    qsort(arr, numsSize, sizeof(Arr_t), cmp);\\n    \\n    for (int i = 1; i < numsSize; i++) {\\n        if (arr[i].val == arr[i-1].val && absdiff(arr[i].idx, arr[i-1].idx) <= k) {\\n            return true;\\n        }\\n    }\\n    \\n    return false;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef struct {\\n    int val;\\n    int idx;\\n} Arr_t;\\n\\nint cmp (const void * a, const void * b) {\\n    Arr_t *m = (Arr_t *)a;\\n    Arr_t *n = (Arr_t *)b;\\n    if (m->val != n->val) {\\n        return m->val - n->val;\\n    }\\n    else {\\n        return m->idx - n->idx;\\n    }\\n}\\n\\nint absdiff(int a, int b) {\\n    return a > b ? a - b : b - a;\\n}\\n\\nbool containsNearbyDuplicate(int* nums, int numsSize, int k){\\n    Arr_t *arr = (Arr_t*) malloc(numsSize * sizeof(Arr_t));\\n    for (int i = 0; i < numsSize; i++) {\\n        arr[i].val = nums[i];\\n        arr[i].idx = i;\\n    }\\n    \\n    qsort(arr, numsSize, sizeof(Arr_t), cmp);\\n    \\n    for (int i = 1; i < numsSize; i++) {\\n        if (arr[i].val == arr[i-1].val && absdiff(arr[i].idx, arr[i-1].idx) <= k) {\\n            return true;\\n        }\\n    }\\n    \\n    return false;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2728073,
                "title": "c-unordered-map-sliding-window-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        unordered_map<int,int> a;\\n        for(int i=0;i<=k&&i<nums.size();i++){\\n            if(a.count(nums[i])==0){\\n                a.insert({nums[i],1});\\n            }\\n            else{\\n                return true;\\n            }\\n        }\\n        for(int i=k;i<nums.size()-1;i++){\\n            a.erase(nums[i-k]);\\n            if(a.count(nums[i+1])==0){\\n                a.insert({nums[i+1],1});\\n            }\\n            else{\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        unordered_map<int,int> a;\\n        for(int i=0;i<=k&&i<nums.size();i++){\\n            if(a.count(nums[i])==0){\\n                a.insert({nums[i],1});\\n            }\\n            else{\\n                return true;\\n            }\\n        }\\n        for(int i=k;i<nums.size()-1;i++){\\n            a.erase(nums[i-k]);\\n            if(a.count(nums[i+1])==0){\\n                a.insert({nums[i+1],1});\\n            }\\n            else{\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2727274,
                "title": "c-o-n-easy-solution",
                "content": "**With Count():**\\n```\\nbool containsNearbyDuplicate(vector<int>& nums, int k) {\\n\\tunordered_map<int, int> mp;\\n\\tfor(int i=0; i<nums.size(); i++) {\\n\\t\\tif(mp.count(nums[i]) > 0 && abs(mp[nums[i]] - i) <= k)\\n\\t\\t\\treturn true;\\n\\t\\tmp[nums[i]] = i;\\n\\t}\\n\\treturn false;\\n}\\n```\\n\\n\\n**O(N) | Without Count():**\\n```\\nbool containsNearbyDuplicate(vector<int>& nums, int k) {\\n\\tunordered_map<int, int> mp;\\n\\tfor(int i=1; i<=nums.size(); i++) {\\n\\t\\tif(mp[nums[i-1]] > 0 && abs(mp[nums[i-1]] - i) <= k)\\n\\t\\t\\treturn true;\\n\\t\\tmp[nums[i-1]] = i;\\n\\t}\\n\\treturn false;\\n}\\n```\\n\\n**Kindly do upvote if found useful**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool containsNearbyDuplicate(vector<int>& nums, int k) {\\n\\tunordered_map<int, int> mp;\\n\\tfor(int i=0; i<nums.size(); i++) {\\n\\t\\tif(mp.count(nums[i]) > 0 && abs(mp[nums[i]] - i) <= k)\\n\\t\\t\\treturn true;\\n\\t\\tmp[nums[i]] = i;\\n\\t}\\n\\treturn false;\\n}\\n```\n```\\nbool containsNearbyDuplicate(vector<int>& nums, int k) {\\n\\tunordered_map<int, int> mp;\\n\\tfor(int i=1; i<=nums.size(); i++) {\\n\\t\\tif(mp[nums[i-1]] > 0 && abs(mp[nums[i-1]] - i) <= k)\\n\\t\\t\\treturn true;\\n\\t\\tmp[nums[i-1]] = i;\\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2503980,
                "title": "python-easy-solution",
                "content": "```\\ndef containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        seen = {}\\n        for i in range(len(nums)):\\n            if nums[i] in seen and i-seen[nums[i]] <= k:\\n                return True\\n            seen[nums[i]] = i\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        seen = {}\\n        for i in range(len(nums)):\\n            if nums[i] in seen and i-seen[nums[i]] <= k:\\n                return True\\n            seen[nums[i]] = i\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2147894,
                "title": "easy-c-sol-naive-efficient-approach-hashmap",
                "content": "```\\n// Naive Solution :: Time : O(N^2) :: Aux_Space : O(1)\\n\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n\\n        int n = nums.size();\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(nums[i] == nums[j] && (abs(i-j) <= k)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n// Efficient Solution :: Time : O(N) :: Aux_Space : O(N)\\n\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n\\n        int n = nums.size();\\n\\n        unordered_map<int,int> mp;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(mp.find(nums[i]) != mp.end() && abs(mp[nums[i]] - i) <= k){\\n                return true;\\n            }else{\\n                mp[nums[i]] = i;\\n            }\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n\\n        int n = nums.size();\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(nums[i] == nums[j] && (abs(i-j) <= k)){\\n                    return true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2001795,
                "title": "javascript-o-n-time-o-min-n-k-complexity-using-hashmap-with-explanation",
                "content": "The idea is while looping through the nums array, we do not only remember the element that has been seen (hence, hashmap is used), but also the **index** where it was seen in order to compare that index with the current looping index and check if the distance is within ```k``` (hence, hashmap key with associated value as the index value).\\nSo, two key operations here: \\n* ```hashMap.set(nums[i], i);``` : for adding to hashmap if first seen **OR** update existing value when seen again but too far away from the previous first seen (**because it may qualify for subsequent duplicates**).\\n* ```Math.abs(hashMap.get(nums[i]) - i) <= k```: for checking distance between the previous seen element and the current seen element.\\n\\nThis is an extension of a previous problem \"Contains Duplicate\" (https://leetcode.com/problems/contains-duplicate/), where we can also return the ```(i,j)``` index of the duplicates, rather than just ```true/false``` boolean flag.\\n\\nFood for thoughts: what about returning all indices of the most duplicate occurrences within a k-width window, assuming unique solution can be found only? e.g. ```input: nums = [1, 2, 3, 3, 2, 3, 5], k = 4 || output : [2,3,5]```\\n\\nPlease upvote if this helps :)\\n```\\nvar containsNearbyDuplicate = function(nums, k) {\\n    let hashMap = new Map();\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        if (hashMap.has(nums[i])) {\\n            if (Math.abs(hashMap.get(nums[i]) - i) <= k) {\\n                return true;\\n            } else {\\n                hashMap.set(nums[i], i);\\n            }\\n        } else {\\n            hashMap.set(nums[i], i);\\n        }\\n    }\\n    \\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```k```\n```hashMap.set(nums[i], i);```\n```Math.abs(hashMap.get(nums[i]) - i) <= k```\n```(i,j)```\n```true/false```\n```input: nums = [1, 2, 3, 3, 2, 3, 5], k = 4 || output : [2,3,5]```\n```\\nvar containsNearbyDuplicate = function(nums, k) {\\n    let hashMap = new Map();\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        if (hashMap.has(nums[i])) {\\n            if (Math.abs(hashMap.get(nums[i]) - i) <= k) {\\n                return true;\\n            } else {\\n                hashMap.set(nums[i], i);\\n            }\\n        } else {\\n            hashMap.set(nums[i], i);\\n        }\\n    }\\n    \\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1997861,
                "title": "c-short-and-simple-4lines-logic-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        \\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<nums.size();i++) {\\n            \\n            if(mp.find(nums[i])!=mp.end()) {  //check if the element is in map or not \\n                if(abs(i-mp[nums[i]])<=k)    //at mp [ nums[i] ] we have the last index of that element, get difference of that value and current index we are on\\n                    return true; \\n            }   \\n            mp[nums[i]]=i;  //element :  index\\n        } \\n        return false; \\n    }\\n};\\n\\nif(helpful)\\n\\tupVote();",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        \\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<nums.size();i++) {\\n            \\n            if(mp.find(nums[i])!=mp.end()) {  //check if the element is in map or not \\n                if(abs(i-mp[nums[i]])<=k)    //at mp [ nums[i] ] we have the last index of that element, get difference of that value and current index we are on\\n                    return true; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1548522,
                "title": "c-solution-using-unordered-map",
                "content": "```\\n  bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        unordered_map<int, int> mp;\\n        for(int i = 0; i < n; i++){\\n            if(mp.find(nums[i]) != mp.end()){\\n                if(i - mp[nums[i]] <= k) return true;\\n                else mp[nums[i]] = i;\\n            }\\n            else mp[nums[i]] = i;\\n        }\\n        return false;\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        unordered_map<int, int> mp;\\n        for(int i = 0; i < n; i++){\\n            if(mp.find(nums[i]) != mp.end()){\\n                if(i - mp[nums[i]] <= k) return true;\\n                else mp[nums[i]] = i;\\n            }\\n            else mp[nums[i]] = i;\\n        }\\n        return false;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1103518,
                "title": "c-linear-time-using-one-dictionary",
                "content": "```\\npublic class Solution {\\n    public bool ContainsNearbyDuplicate(int[] nums, int k) {\\n        \\n        Dictionary<int, int> duplicateIndex = new Dictionary<int, int>();\\n        \\n        for(int i = 0; i < nums.Length; i++) {\\n            \\n            //Add value to dictionary when seen for first time; key is the number, value is its index in nums\\n            if(!duplicateIndex.ContainsKey(nums[i])){\\n                duplicateIndex.Add(nums[i], i);\\n            }\\n            //Already is in dictionary\\n            else{\\n                //What is the difference between this index and where it was last seen?\\n                int indexDifference = i - duplicateIndex[nums[i]];\\n                //less than k, return true\\n                if(indexDifference <= k) {\\n                    return true;\\n                }\\n                //If not, update last seen to this current position since last position and next time seen are greater than this position and next time seen by definition\\n                else {\\n                    duplicateIndex[nums[i]] = i;\\n                }                \\n            }            \\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool ContainsNearbyDuplicate(int[] nums, int k) {\\n        \\n        Dictionary<int, int> duplicateIndex = new Dictionary<int, int>();\\n        \\n        for(int i = 0; i < nums.Length; i++) {\\n            \\n            //Add value to dictionary when seen for first time; key is the number, value is its index in nums\\n            if(!duplicateIndex.ContainsKey(nums[i])){\\n                duplicateIndex.Add(nums[i], i);\\n            }\\n            //Already is in dictionary\\n            else{\\n                //What is the difference between this index and where it was last seen?\\n                int indexDifference = i - duplicateIndex[nums[i]];\\n                //less than k, return true\\n                if(indexDifference <= k) {\\n                    return true;\\n                }\\n                //If not, update last seen to this current position since last position and next time seen are greater than this position and next time seen by definition\\n                else {\\n                    duplicateIndex[nums[i]] = i;\\n                }                \\n            }            \\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1057965,
                "title": "kotlin-simple",
                "content": "```\\nfun containsNearbyDuplicate(nums: IntArray, k: Int): Boolean {\\n        val map = HashMap<Int, Int>()\\n        nums.forEachIndexed { i, num ->\\n            if (map.containsKey(num) && i - map[num]!! <= k) return true\\n            map[num] = i\\n        }\\n\\n        return false\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun containsNearbyDuplicate(nums: IntArray, k: Int): Boolean {\\n        val map = HashMap<Int, Int>()\\n        nums.forEachIndexed { i, num ->\\n            if (map.containsKey(num) && i - map[num]!! <= k) return true\\n            map[num] = i\\n        }\\n\\n        return false\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1015739,
                "title": "easy-clear-solution-python-3",
                "content": "```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        if len(nums)<2 :\\n            return False\\n        if k>=len(nums):\\n            return len(set(nums))<len(nums)\\n        aux=set(nums[0:k+1])\\n        if len(aux)!=k+1:\\n            return True\\n        for i in range(1,len(nums)-k):\\n            aux.remove(nums[i-1])\\n            aux.add(nums[i+k])\\n            if len(aux)!=k+1:\\n                return True\\n        return False    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        if len(nums)<2 :\\n            return False\\n        if k>=len(nums):\\n            return len(set(nums))<len(nums)\\n        aux=set(nums[0:k+1])\\n        if len(aux)!=k+1:\\n            return True\\n        for i in range(1,len(nums)-k):\\n            aux.remove(nums[i-1])\\n            aux.add(nums[i+k])\\n            if len(aux)!=k+1:\\n                return True\\n        return False    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 776670,
                "title": "simple-java-solution-using-hashset",
                "content": "```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int i=0; i<nums.length; i++) {\\n            if(set.contains(nums[i]))\\n                return true;\\n            set.add(nums[i]);\\n            if(set.size() > k)\\n                set.remove(nums[i - k]);\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int i=0; i<nums.length; i++) {\\n            if(set.contains(nums[i]))\\n                return true;\\n            set.add(nums[i]);\\n            if(set.size() > k)\\n                set.remove(nums[i - k]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 518824,
                "title": "c-faster-than-99-07-less-than-33-33-mem-o-n",
                "content": "Runtime: 92 ms\\nMemory Usage: 29.1 MB\\n\\n```\\n  public bool ContainsNearbyDuplicate(int[] nums, int k) {\\n        Dictionary<int, int> lookup = new Dictionary<int, int>();\\n            \\n        for(int i=0; i< nums.Length; i++)\\n        {\\n            if (lookup.ContainsKey(nums[i]) && i - lookup[nums[i]] <= k) { return true; }\\n            \\n            lookup[nums[i]] = i;\\n        }\\n        \\n        return false;\\n    }",
                "solutionTags": [],
                "code": "Runtime: 92 ms\\nMemory Usage: 29.1 MB\\n\\n```\\n  public bool ContainsNearbyDuplicate(int[] nums, int k) {\\n        Dictionary<int, int> lookup = new Dictionary<int, int>();\\n            \\n        for(int i=0; i< nums.Length; i++)\\n        {\\n            if (lookup.ContainsKey(nums[i]) && i - lookup[nums[i]] <= k) { return true; }\\n            \\n            lookup[nums[i]] = i;\\n        }\\n        \\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 448669,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums, k):\\n        dict = {}\\n        for i in range(len(nums)):\\n            if nums[i] in dict and i - dict[nums[i]] <= k:\\n                return True\\n            dict[nums[i]] = i\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums, k):\\n        dict = {}\\n        for i in range(len(nums)):\\n            if nums[i] in dict and i - dict[nums[i]] <= k:\\n                return True\\n            dict[nums[i]] = i\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226093,
                "title": "c-4-ms-100",
                "content": "```\\n#define abs(a,b) (a > b ? a - b : b - a)\\nbool containsNearbyDuplicate(int* nums, int numsSize, int k) {\\n    int* order = malloc(sizeof(int)*numsSize);\\n    int flag = 1;\\n    for (int i = 0; i < numsSize; i++)\\n    {\\n        order[i] = i;\\n    }\\n    while (flag)\\n    {\\n        flag = 0;\\n        for(int i = 0; i < numsSize-1; i++)\\n        {\\n            if (nums[i] > nums[i+1])\\n            {\\n                nums[i] ^= nums[i+1];\\n                nums[i+1] ^= nums[i];\\n                nums[i] ^= nums[i+1];\\n                \\n                order[i] ^= order[i+1];\\n                order[i+1] ^= order[i];\\n                order[i] ^= order[i+1];\\n                flag = 1;\\n            }\\n            else if(nums[i] == nums[i+1] && abs(order[i], order[i+1]) <= k)\\n            {\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n#define abs(a,b) (a > b ? a - b : b - a)\\nbool containsNearbyDuplicate(int* nums, int numsSize, int k) {\\n    int* order = malloc(sizeof(int)*numsSize);\\n    int flag = 1;\\n    for (int i = 0; i < numsSize; i++)\\n    {\\n        order[i] = i;\\n    }\\n    while (flag)\\n    {\\n        flag = 0;\\n        for(int i = 0; i < numsSize-1; i++)\\n        {\\n            if (nums[i] > nums[i+1])\\n            {\\n                nums[i] ^= nums[i+1];\\n                nums[i+1] ^= nums[i];\\n                nums[i] ^= nums[i+1];\\n                \\n                order[i] ^= order[i+1];\\n                order[i+1] ^= order[i];\\n                order[i] ^= order[i+1];\\n                flag = 1;\\n            }\\n            else if(nums[i] == nums[i+1] && abs(order[i], order[i+1]) <= k)\\n            {\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 61482,
                "title": "5-line-java-code-solution",
                "content": "    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n            Set<Integer> set = new HashSet<Integer>();\\n    \\n            for(int j = 0; j < nums.length; j++){\\n                if(j > k) set.remove(nums[j - k - 1]);\\n                if(!set.add(nums[j]))  return true;\\n            }\\n            return false;\\n    }",
                "solutionTags": [],
                "code": "    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n            Set<Integer> set = new HashSet<Integer>();\\n    \\n            for(int j = 0; j < nums.length; j++){\\n                if(j > k) set.remove(nums[j - k - 1]);\\n                if(!set.add(nums[j]))  return true;\\n            }\\n            return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 61476,
                "title": "why-i-can-not-use-hashtable-in-java",
                "content": "I noticed this problem on other tasks also. When I try to compile the following snipet: \\n\\n    Hashtable<Integer, Integer> ht = new Hashtable<Integer, Integer>();\\n\\nI got the following error message:\\n\\n> error: cannot find symbol: class Hashtable\\n\\nWhy?",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "I noticed this problem on other tasks also. When I try to compile the following snipet: \\n\\n    Hashtable<Integer, Integer> ht = new Hashtable<Integer, Integer>();\\n\\nI got the following error message:\\n\\n> error: cannot find symbol: class Hashtable\\n\\nWhy?",
                "codeTag": "Java"
            },
            {
                "id": 61499,
                "title": "7-lines-cpp-solution-32ms-easy-to-understand",
                "content": "    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        unordered_set<int> hash_table;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (hash_table.find(nums[i]) != hash_table.end()) return true;\\n            hash_table.emplace(nums[i]);\\n            if (hash_table.size() > k) hash_table.erase(hash_table.find(nums[i - k]));\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        unordered_set<int> hash_table;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (hash_table.find(nums[i]) != hash_table.end()) return true;\\n            hash_table.emplace(nums[i]);\\n            if (hash_table.size() > k) hash_table.erase(hash_table.find(nums[i - k]));\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 61525,
                "title": "7-lines-concise-and-easy-understand-c-solution",
                "content": "    class Solution {\\n    public:\\n        bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n            unordered_map<int, int> mp;\\n            int i = 0;\\n            for(auto num : nums){\\n                if(mp.count(num) && mp[num] >= i - k) return true;\\n                mp[num] = i++;\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n            unordered_map<int, int> mp;\\n            int i = 0;\\n            for(auto num : nums){\\n                if(mp.count(num) && mp[num] >= i - k) return true;\\n                mp[num] = i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 61546,
                "title": "c-short-solution",
                "content": "        \\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        unordered_map<int, int> myMap;\\n        for (unsigned int i=0; i<nums.size(); i++) {\\n            if (myMap.find(nums[i]) != myMap.end() && i-myMap[nums[i]]<=k)\\n                return true;\\n            myMap[nums[i]] = i;\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "        \\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        unordered_map<int, int> myMap;\\n        for (unsigned int i=0; i<nums.size(); i++) {\\n            if (myMap.find(nums[i]) != myMap.end() && i-myMap[nums[i]]<=k)\\n                return true;\\n            myMap[nums[i]] = i;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 61610,
                "title": "my-js-solution-115ms",
                "content": "    var containsNearbyDuplicate = function(nums, k) {\\n        if(nums.length <= 1 || k < 1)\\n        {\\n            return false;\\n        }\\n        var map = {};\\n        for(var i=0; i<nums.length; i++)\\n        {\\n            if(map[nums[i]] !== undefined)\\n            {\\n                return true;\\n            }\\n            else \\n            {\\n                if(i - k >=0)\\n                {\\n                    map[nums[i-k]] = undefined;\\n                }\\n                map[nums[i]] = true;\\n            }\\n        }\\n        return false;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var containsNearbyDuplicate = function(nums, k) {\\n        if(nums.length <= 1 || k < 1)\\n        {\\n            return false;\\n        }\\n        var map = {};\\n        for(var i=0; i<nums.length; i++)\\n        {\\n            if(map[nums[i]] !== undefined)\\n            {\\n                return true;\\n            }\\n            else \\n            {\\n                if(i - k >=0)\\n                {\\n                    map[nums[i-k]] = undefined;\\n                }\\n                map[nums[i]] = true;\\n            }\\n        }\\n        return false;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3842285,
                "title": "beats-97-easy-optimized",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(min(n,k))$$\\n\\n# Code\\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar containsNearbyDuplicate = function(nums, k) {\\n  const hi = new Map();\\n  for (let i = 0; i < nums.length; i++) {\\n    \\n    if (hi.has(nums[i]) && i - hi.get(nums[i])<= k) {\\n      return true;\\n    }\\n    hi.set(nums[i],i)\\n // console.log(hi.set(nums[i],i));\\n  }  \\n  return false;\\n};\\n```\\n```python []\\nclass Solution(object):\\n    def containsNearbyDuplicate(self, nums, k):\\n        num_dict = {}\\n\\n        for i, num in enumerate(nums):\\n            if num in num_dict and i - num_dict[num] <= k:\\n                return True\\n            num_dict[num] = i\\n\\n        return False\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(std::vector<int>& nums, int k) {\\n        std::unordered_map<int, int> numMap;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (numMap.find(nums[i]) != numMap.end() && i - numMap[nums[i]] <= k) {\\n                return true;\\n            }\\n            numMap[nums[i]] = i;\\n        }\\n\\n        return false;\\n    }\\n};\\n```\\n\\n\\n\\n\\n---\\n\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "JavaScript",
                    "Array",
                    "Hash Table"
                ],
                "code": "```javascript []\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar containsNearbyDuplicate = function(nums, k) {\\n  const hi = new Map();\\n  for (let i = 0; i < nums.length; i++) {\\n    \\n    if (hi.has(nums[i]) && i - hi.get(nums[i])<= k) {\\n      return true;\\n    }\\n    hi.set(nums[i],i)\\n // console.log(hi.set(nums[i],i));\\n  }  \\n  return false;\\n};\\n```\n```python []\\nclass Solution(object):\\n    def containsNearbyDuplicate(self, nums, k):\\n        num_dict = {}\\n\\n        for i, num in enumerate(nums):\\n            if num in num_dict and i - num_dict[num] <= k:\\n                return True\\n            num_dict[num] = i\\n\\n        return False\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(std::vector<int>& nums, int k) {\\n        std::unordered_map<int, int> numMap;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (numMap.find(nums[i]) != numMap.end() && i - numMap[nums[i]] <= k) {\\n                return true;\\n            }\\n            numMap[nums[i]] = i;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634867,
                "title": "easy-efficient-and-simple-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNow, at first, the brute force solution is checking every element for every element. Now this sounds absurd, and it is quite honestly... Very Inefficient!\\nNow, whenever we need to check if an element has previously occurred, the best approach is using a HashMAP or SET. I went with map because of constant search time!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor every element, we check if it is already present in the map. \\nIf it is not, we add it with the element being the key and the index being the value.\\nOtherwise, we check if the difference between the indices is less than K. Now what we do next is THE CRUCIAL part, If the difference is NOT less than or equal to K, we UPDATE the index of the element in the map.\\n\\n*WHY?*\\nSee, if i - j > k, then i - x (where x > j) >> k, so NO point in checking. Thus we update i with j so that in future, if there is another match, then we compute the difference with j instead!\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int abs(int a, int b){\\n        return (a < b) ? (b - a) : (a - b);\\n    }\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        unordered_map<int,int> umap;\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            if(umap.find(nums[i]) == umap.end()){\\n                umap[nums[i]] = i;\\n            }\\n            else{\\n                auto it = umap.find(nums[i]);\\n                int diff = abs(it->second, i);\\n                if(diff <= k)\\n                   return true;\\n                else\\n                    umap[nums[i]] = i;\\n            }\\n        }\\n        return\\xA0false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int abs(int a, int b){\\n        return (a < b) ? (b - a) : (a - b);\\n    }\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        unordered_map<int,int> umap;\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            if(umap.find(nums[i]) == umap.end()){\\n                umap[nums[i]] = i;\\n            }\\n            else{\\n                auto it = umap.find(nums[i]);\\n                int diff = abs(it->second, i);\\n                if(diff <= k)\\n                   return true;\\n                else\\n                    umap[nums[i]] = i;\\n            }\\n        }\\n        return\\xA0false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282250,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic boolean containsNearbyDuplicate(int[] nums, int k) {\\n\\tSet<Integer> set = new HashSet<Integer>();\\n\\t\\n\\tfor(int i = 0; i < nums.length; i++) {\\n\\t\\tif (i > k) //abs value\\n\\t\\t\\tset.remove(nums[i-k-1]); //i cross range remove prev \\n\\t\\t\\n\\t\\tif (!set.add(nums[i])) //set.add returns false if duplicate \\n\\t\\t\\treturn true; \\n\\t}\\n\\t\\n\\treturn false;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic boolean containsNearbyDuplicate(int[] nums, int k) {\\n\\tSet<Integer> set = new HashSet<Integer>();\\n\\t\\n\\tfor(int i = 0; i < nums.length; i++) {\\n\\t\\tif (i > k) //abs value\\n\\t\\t\\tset.remove(nums[i-k-1]); //i cross range remove prev \\n\\t\\t\\n\\t\\tif (!set.add(nums[i])) //set.add returns false if duplicate \\n\\t\\t\\treturn true; \\n\\t}\\n\\t\\n\\treturn false;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235600,
                "title": "python-easy-solution-beats-98-99-runtime-585ms",
                "content": "<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSimply, we identify the duplicate number in a range from ith element to the ith+kth range by using checking the length of list to the length of set of list.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        if len(nums)==len(set(nums)):\\n            return False\\n        for i in range(len(nums)):\\n            if len(nums[i:i+1+k])!=len(set(nums[i:i+1+k])):\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        if len(nums)==len(set(nums)):\\n            return False\\n        for i in range(len(nums)):\\n            if len(nums[i:i+1+k])!=len(set(nums[i:i+1+k])):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041735,
                "title": "optimized-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nWe need our i and j to be at max distance of k. Thus we can use a Sliding Window in which we can use a map to store whether we found an element before or not in constant time, reducing our time complexity.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1) Initialise an unordered map (HASH MAP) and store in the elements in subarray nums[0...k-1].\\n\\n2) Initialise two pointers i and j to 0 and k respectively.\\n\\n3) Check whether the jth element already exists in our map? If yes, then return true, else continue.\\n\\n3) Add the jth element and remove the ith element from the map. Remember we can do this is constant time by making use of a boolean map.\\n\\n4) We continue this untill j crosses n.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        int n = nums.size(),i = 0,j = 0;\\n        unordered_map<int,bool> found;\\n        while(j<k && j<n){\\n            if(found[nums[j]])\\n                return true;\\n            found[nums[j++]] = true;\\n        }\\n        while(j<n){\\n            if(found[nums[j]])\\n                return true;\\n            found[nums[j]] = true;\\n            found[nums[i]] = false;\\n            i++;\\n            j++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        int n = nums.size(),i = 0,j = 0;\\n        unordered_map<int,bool> found;\\n        while(j<k && j<n){\\n            if(found[nums[j]])\\n                return true;\\n            found[nums[j++]] = true;\\n        }\\n        while(j<n){\\n            if(found[nums[j]])\\n                return true;\\n            found[nums[j]] = true;\\n            found[nums[i]] = false;\\n            i++;\\n            j++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2729327,
                "title": "javascript-easy-hashmap-solution-in-o-nums-length-time",
                "content": "* We are doing a **sliding window** technique, which means that we are making a window the size of `k`, and when a number enters this window we add it to a hashmap, and when a number leaves we remove it from the hashmap\\n* If nums[i] ever equals to 2, then we return true; otherwise false\\n\\n```\\n// Time: O(nums.length)\\n// Space: O(k)\\nconst containsNearbyDuplicate = (nums, k) => {\\n    let hash = {};\\n\\n    for (let i = 0; i <= nums.length - 1; i++) {\\n        if (i - k > 0) {\\n            hash[nums[i - k - 1]]--;\\n        }\\n\\n        hash[nums[i]] = nums[i] in hash ? hash[nums[i]] + 1 : 1;\\n\\n        if (hash[nums[i]] === 2) {\\n            return true;\\n        }\\n    }\\n\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Time: O(nums.length)\\n// Space: O(k)\\nconst containsNearbyDuplicate = (nums, k) => {\\n    let hash = {};\\n\\n    for (let i = 0; i <= nums.length - 1; i++) {\\n        if (i - k > 0) {\\n            hash[nums[i - k - 1]]--;\\n        }\\n\\n        hash[nums[i]] = nums[i] in hash ? hash[nums[i]] + 1 : 1;\\n\\n        if (hash[nums[i]] === 2) {\\n            return true;\\n        }\\n    }\\n\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2729246,
                "title": "javascript-simple-and-fast-solution",
                "content": "\\n```\\nvar containsNearbyDuplicate = function(nums, k) {\\n    const obj = {}\\n    for(let i = 0 ; i< nums.length; i++){\\n        if( i - obj[nums[i]] <= k) return true\\n          obj[nums[i]] = i || 0\\n    }\\n  return false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar containsNearbyDuplicate = function(nums, k) {\\n    const obj = {}\\n    for(let i = 0 ; i< nums.length; i++){\\n        if( i - obj[nums[i]] <= k) return true\\n          obj[nums[i]] = i || 0\\n    }\\n  return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2728808,
                "title": "c-set-and-sliding-window",
                "content": "```\\n bool containsNearbyDuplicate(vector<int>& nums, int k) \\n    {\\n       int n=nums.size();\\n       unordered_set<int>st;\\n        \\n        int i=0,j=0;\\n        \\n        while(j < n){\\n            \\n            if(j-i <= k){\\n                if(st.find(nums[j]) == st.end()){\\n                    st.insert(nums[j]);\\n                    j++;\\n                }\\n                else return true;\\n            }\\n            else{\\n                st.erase(nums[i]);\\n                i++;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```\\n\\nComment in case of any doubts !",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "```\\n bool containsNearbyDuplicate(vector<int>& nums, int k) \\n    {\\n       int n=nums.size();\\n       unordered_set<int>st;\\n        \\n        int i=0,j=0;\\n        \\n        while(j < n){\\n            \\n            if(j-i <= k){\\n                if(st.find(nums[j]) == st.end()){\\n                    st.insert(nums[j]);\\n                    j++;\\n                }\\n                else return true;\\n            }\\n            else{\\n                st.erase(nums[i]);\\n                i++;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2728134,
                "title": "python-dict-and-deque-solution-o-n",
                "content": "```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        stat, q = defaultdict(int), deque([])\\n        for num in nums:\\n            stat[num] += 1\\n            q.append(num)\\n            if stat[num] > 1:\\n                return True\\n            if len(q) == k + 1:\\n                stat[q.popleft()] -= 1\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        stat, q = defaultdict(int), deque([])\\n        for num in nums:\\n            stat[num] += 1\\n            q.append(num)\\n            if stat[num] > 1:\\n                return True\\n            if len(q) == k + 1:\\n                stat[q.popleft()] -= 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2727704,
                "title": "c-short-simple-code",
                "content": "***DO UPVOTE IF IT HELPS !!!!!***\\n\\n------------------------------------\\n\\n**TC** = O(N), **SC** = O(N)\\n\\t\\n\\tbool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        unordered_map<int,int> mp;                       //key = element, value = index\\n        \\n        for(int i=0;i<n;i++){\\n            int curr=nums[i];\\n\\t\\t\\t\\n            if(mp.find(curr)!=mp.end()){                 //if curr_element is present in map\\n                if(abs(i-mp[curr]) <= k) return true;    //then check abs(i-mp[curr]) <= k, return true;\\n                mp[curr]=i;                              //else update the index of curr_element;\\n            }\\n            mp[curr]=i;                                  //else, push element and it\\'s index into map\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!!***\\n\\n------------------------------------\\n\\n**TC** = O(N), **SC** = O(N)\\n\\t\\n\\tbool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        unordered_map<int,int> mp;                       //key = element, value = index\\n        \\n        for(int i=0;i<n;i++){\\n            int curr=nums[i];\\n\\t\\t\\t\\n            if(mp.find(curr)!=mp.end()){                 //if curr_element is present in map\\n                if(abs(i-mp[curr]) <= k) return true;    //then check abs(i-mp[curr]) <= k, return true;\\n                mp[curr]=i;                              //else update the index of curr_element;\\n            }\\n            mp[curr]=i;                                  //else, push element and it\\'s index into map\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2727550,
                "title": "java-easy-hashmap-solution",
                "content": "I used Hashmap to store number and its index, when we encounter a duplicate element , we will check if absolute difference of current index and the one stored in hashmap is less than or equal to k, we will return true, or else, we will update value with current index. \\n Map<Integer,Integer>m = new HashMap<>();\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            if(!m.containsKey(nums[i]))\\n                m.put(nums[i],i);\\n            else\\n            {\\n                int j = m.get(nums[i]);\\n                if(Math.abs(i-j)<=k)\\n                    return true;\\n                else\\n                    m.put(nums[i],i);\\n            }\\n        }\\n        return false;\\n\\t\\t\\n\\t\\tTC: O(n)\\n\\t\\tSC : O(N)",
                "solutionTags": [],
                "code": "I used Hashmap to store number and its index, when we encounter a duplicate element , we will check if absolute difference of current index and the one stored in hashmap is less than or equal to k, we will return true, or else, we will update value with current index. \\n Map<Integer,Integer>m = new HashMap<>();\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            if(!m.containsKey(nums[i]))\\n                m.put(nums[i],i);\\n            else\\n            {\\n                int j = m.get(nums[i]);\\n                if(Math.abs(i-j)<=k)\\n                    return true;\\n                else\\n                    m.put(nums[i],i);\\n            }\\n        }\\n        return false;\\n\\t\\t\\n\\t\\tTC: O(n)\\n\\t\\tSC : O(N)",
                "codeTag": "Unknown"
            },
            {
                "id": 2727374,
                "title": "simple-and-easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        map<int,int> m;\\n        for(int i=0;i<nums.size();i++){\\n            \\n            if(m.count(nums[i])){\\n                if(abs(m[nums[i]]-i) <=k)\\n                    return true;     \\n            }\\n            m[nums[i]]=i;\\n            }\\n            return false;\\n        }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        map<int,int> m;\\n        for(int i=0;i<nums.size();i++){\\n            \\n            if(m.count(nums[i])){\\n                if(abs(m[nums[i]]-i) <=k)\\n                    return true;     \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2726295,
                "title": "java-and-python-solution-faster-than-97-7",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n\\n# Java\\n```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i <nums.length; i++){\\n            if(map.containsKey(nums[i]) && Math.abs(i - map.get(nums[i])) <= k){\\n                return true;\\n            }\\n            map.put(nums[i], i);\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n# Python\\n\\n```\\ndef containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        dic = {}\\n        for i in range(len(nums)):\\n            if nums[i] not in dic:\\n                dic[nums[i]] = i\\n            else:\\n                if i - dic[nums[i]] <= k:\\n                    return True\\n                dic[nums[i]] = i\\n        return False\\n```\\n\\nconcise solution:\\n\\n```\\n def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        dic = {}\\n        for i in range(len(nums)):\\n            if nums[i] in dic and i - dic[nums[i]] <= k:\\n                return True\\n            dic[nums[i]] = i\\n        return False\\n        \\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i <nums.length; i++){\\n            if(map.containsKey(nums[i]) && Math.abs(i - map.get(nums[i])) <= k){\\n                return true;\\n            }\\n            map.put(nums[i], i);\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\ndef containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        dic = {}\\n        for i in range(len(nums)):\\n            if nums[i] not in dic:\\n                dic[nums[i]] = i\\n            else:\\n                if i - dic[nums[i]] <= k:\\n                    return True\\n                dic[nums[i]] = i\\n        return False\\n```\n```\\n def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        dic = {}\\n        for i in range(len(nums)):\\n            if nums[i] in dic and i - dic[nums[i]] <= k:\\n                return True\\n            dic[nums[i]] = i\\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266026,
                "title": "using-unordered-set-comments-included-c",
                "content": "Implementation\\n\\n**Using Unordered Set\\nTime Complexity = O(N),\\nSpace Complexity = O(min(N, K))**\\n\\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        unordered_set<int> st;\\n        for(int i = 0; i < nums.size(); i++){\\n            \\n            // if found return true\\n            if(st.find(nums[i]) != st.end()) return true;\\n            \\n            // otherwise insert into set\\n            st.insert(nums[i]);\\n            \\n            // if set size is greater than k, then remove (i-k)th element\\n            if(st.size() > k){\\n                st.erase(nums[i-k]);\\n            }\\n        }\\n        \\n        // if didn\\'t found return false\\n        return false;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        unordered_set<int> st;\\n        for(int i = 0; i < nums.size(); i++){\\n            \\n            // if found return true\\n            if(st.find(nums[i]) != st.end()) return true;\\n            \\n            // otherwise insert into set\\n            st.insert(nums[i]);\\n            \\n            // if set size is greater than k, then remove (i-k)th element\\n            if(st.size() > k){\\n                st.erase(nums[i-k]);\\n            }\\n        }\\n        \\n        // if didn\\'t found return false\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200965,
                "title": "python3-easy-to-understand-dictionary",
                "content": "```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        seen = {}\\n        \\n        for i in range(len(nums)):\\n            if nums[i] in seen and abs(i - seen[nums[i]]) <= k:\\n                return True\\n            seen[nums[i]] = i\\n        return False\\n```\\nPlease upvote if it is helpful.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        seen = {}\\n        \\n        for i in range(len(nums)):\\n            if nums[i] in seen and abs(i - seen[nums[i]]) <= k:\\n                return True\\n            seen[nums[i]] = i\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164119,
                "title": "go-o-n",
                "content": "```\\nfunc containsNearbyDuplicate(nums []int, k int) bool {\\n    m := make(map[int]int)\\n    \\n    for i, num := range nums {\\n        if value, ok := m[num]; ok {\\n            if absInt(i, value) <= k {\\n                return true\\n            } else {\\n                m[num] = i\\n            }\\n        } else {\\n            m[num] = i\\n        }\\n    }\\n    \\n    return false\\n}\\n\\nfunc absInt(a, b int) int {\\n    if a - b < 0 {\\n        return b - a\\n    }\\n    \\n    return a - b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc containsNearbyDuplicate(nums []int, k int) bool {\\n    m := make(map[int]int)\\n    \\n    for i, num := range nums {\\n        if value, ok := m[num]; ok {\\n            if absInt(i, value) <= k {\\n                return true\\n            } else {\\n                m[num] = i\\n            }\\n        } else {\\n            m[num] = i\\n        }\\n    }\\n    \\n    return false\\n}\\n\\nfunc absInt(a, b int) int {\\n    if a - b < 0 {\\n        return b - a\\n    }\\n    \\n    return a - b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2132237,
                "title": "sliding-window-explanation-java",
                "content": "```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        \\n        //SLIDING WINDOW \\n        \\n        Set<Integer> set= new HashSet<Integer>();        \\n        \\n        for (int i=0; i<nums.length; i++){\\n            \\n            if (!set.add(nums[i])) return true; \\n            // if duplicate is in k sized window and cant be readded then return true\\n            \\n            \\n            if (set.size()>k) set.remove(nums[i-k]); \\n            /*if the size of window has risen above k, we need to trim the initial elements of window since \\n\\t\\t\\ttheir duplicate doesn\\'t lie in the window of range k anymore, and we will look for duplicates within the current window.... */\\n            \\n            /* \\n            for example --->\\n            in 1,2,3,1 k=2, set is [1,2] till second element.. \\n            on third element set=[2,3]\\n            on fourth element set=[3,1]\\n            set doesn\\'t hold 1 now so it can be said that 1 has duplicate but not within k next elements, so false\\n            */\\n            \\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        \\n        //SLIDING WINDOW \\n        \\n        Set<Integer> set= new HashSet<Integer>();        \\n        \\n        for (int i=0; i<nums.length; i++){\\n            \\n            if (!set.add(nums[i])) return true; \\n            // if duplicate is in k sized window and cant be readded then return true\\n            \\n            \\n            if (set.size()>k) set.remove(nums[i-k]); \\n            /*if the size of window has risen above k, we need to trim the initial elements of window since \\n\\t\\t\\ttheir duplicate doesn\\'t lie in the window of range k anymore, and we will look for duplicates within the current window.... */\\n            \\n            /* \\n            for example --->\\n            in 1,2,3,1 k=2, set is [1,2] till second element.. \\n            on third element set=[2,3]\\n            on fourth element set=[3,1]\\n            set doesn\\'t hold 1 now so it can be said that 1 has duplicate but not within k next elements, so false\\n            */\\n            \\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921862,
                "title": "java-beats-99-with-using-hashmap",
                "content": "***What surprises me a lot is that using HashMap to specify the length in advance is faster than do nothing.***\\n![image](https://assets.leetcode.com/users/images/a0b1f86e-33e8-4dee-ae2a-6615e4529597_1649309408.071772.png)\\n**1\\u3001Specify the length in advanve (Beats 99.96%)**\\n```\\nclass SolutionContainsDuplicateII {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        HashMap<Integer,Integer> map = new HashMap<>(nums.length);// Here is the key point.\\n        for(int i = 0;i < nums.length;i++){\\n            if(!map.containsKey(nums[i])) map.put(nums[i],i);\\n            else if (i - map.get(nums[i]) <= k) return true;\\n            else map.put(nums[i],i);\\n        }\\n        return false;\\n    }\\n}\\n```\\n**2\\u3001Do not specify the length in advanve (Beats 23.14%)**\\n```\\nclass SolutionContainsDuplicateII {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        HashMap<Integer,Integer> map = new HashMap<>();// Have not the nums.length\\n        for(int i = 0;i < nums.length;i++){\\n            if(!map.containsKey(nums[i])) map.put(nums[i],i);\\n            else if (i - map.get(nums[i]) <= k) return true;\\n            else map.put(nums[i],i);\\n        }\\n        return false;\\n    }\\n}\\n```\\n***Please upvote if it helps, feel free to ask if you have any questions\\uD83D\\uDE0A~***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SolutionContainsDuplicateII {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        HashMap<Integer,Integer> map = new HashMap<>(nums.length);// Here is the key point.\\n        for(int i = 0;i < nums.length;i++){\\n            if(!map.containsKey(nums[i])) map.put(nums[i],i);\\n            else if (i - map.get(nums[i]) <= k) return true;\\n            else map.put(nums[i],i);\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass SolutionContainsDuplicateII {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        HashMap<Integer,Integer> map = new HashMap<>();// Have not the nums.length\\n        for(int i = 0;i < nums.length;i++){\\n            if(!map.containsKey(nums[i])) map.put(nums[i],i);\\n            else if (i - map.get(nums[i]) <= k) return true;\\n            else map.put(nums[i],i);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868785,
                "title": "3-approaches-brute-force-hashmap-and-sliding-window",
                "content": "[Leetcode](https://leetcode.com/) [219. Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/).\\n\\nHere are $3$ approaches to solve this problem in Java, which is **Brute Force**, **HashMap** and **Sliding Window**.\\n\\n# Brute Force\\n\\nEasy, using $2$ loops to determine whether there is the same number.\\n\\nobviously, it will **time out**.\\n\\n```java\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        if (nums == null || nums.length <= 1 || k <= 0) {\\n            return false;\\n        }\\n\\n        int len = nums.length;\\n        for (int i = 0; i < len; i++) {\\n            for (int j = i + 1; j < len; j++) {\\n                if (nums[i] == nums[j]) {\\n                    if (Math.abs(i - j) <= k) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n^2)$\\n- **Space Complexity**: $O(1)$\\n\\n# HashMap\\n\\nWe use a $\\\\texttt{HashMap}$ to record the maximum index of each element. When scanning the array from left to right, the process:\\n\\n- If an element $\\\\textit{nums}[i]$ already exists in the hash table and the index $j$ of the element recorded in the hash table satisfies $abs(i - j) \\\\le k$, return $\\\\text{true}$;\\n\\n- Recording $\\\\textit{nums}[i]$ and index $i$ into the hash table, where $i$ is the largest index of $\\\\textit{nums}[i]$.\\n\\nThe order of the above two-step operations cannot be changed, when the index $i$ is traversed, the element equal to the current element and the maximum index of the element can only be found in the elements before the index $i$.\\n\\n```java\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        if (nums == null || nums.length <= 1 || k <= 0) {\\n            return false;\\n        }\\n\\n        int len = nums.length;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < len; i++) {\\n            if (map.containsKey(nums[i])) {\\n                int idx = map.get(nums[i]);\\n                if (Math.abs(i - idx) <= k) {\\n                    return true;\\n                }\\n                map.put(nums[i], i);\\n            } else {\\n                map.put(nums[i], i);\\n            }\\n        }\\n\\n        return false;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n# Sliding Window\\n\\nMaintain a sliding window whose length does not exceed $k + 1$ in the array $\\\\textit{nums}$, and the abs value of any two index delta in the same sliding window does not exceed $k$. \\n\\nIf the sliding window has repeated elements, then there are two different index $i$ and $j$ such that $\\\\textit{nums}[i] = \\\\textit{nums}[j]$ and $i - j \\\\le k$. \\n\\nIf there are no repeating elements in the sliding window, there is no index that meets the requirements. \\n\\nTherefore, it is only necessary to traverse each sliding window and determine whether there are duplicate elements in the sliding window.\\n\\nWe use a HashSet to store the elements in the sliding window. \\n\\nIf $i > k$, the element whose index is $i - k - 1$ will be removed from the sliding window.\\n\\nIf a element already exists in the $\\\\texttt{HashSet}$, there are duplicate elements, return $\\\\textit{true}$, if not in the hash set add it to the hash set.\\n\\n```java\\npublic boolean containsNearbyDuplicate(int[] nums, int k) {\\n\\tif (nums == null || nums.length <= 1 || k <= 0) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\tint len = nums.length;\\n\\tSet<Integer> set = new HashSet<>();\\n\\tfor (int i = 0; i < len; i++) {\\n\\t\\tif (i > k) {\\n\\t\\t\\tset.remove(nums[i - k - 1]);\\n\\t\\t}\\n\\n\\t\\tif (set.contains(nums[i])) {\\n\\t\\t\\treturn true;\\n\\t\\t} else {\\n\\t\\t\\tset.add(nums[i]);\\n\\t\\t}\\n\\t}\\n\\n\\treturn false;\\n}\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n)$.\\n- **Space Complexity**: $O(k)$.\\n\\n--------------------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```java\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        if (nums == null || nums.length <= 1 || k <= 0) {\\n            return false;\\n        }\\n\\n        int len = nums.length;\\n        for (int i = 0; i < len; i++) {\\n            for (int j = i + 1; j < len; j++) {\\n                if (nums[i] == nums[j]) {\\n                    if (Math.abs(i - j) <= k) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n```\n```java\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        if (nums == null || nums.length <= 1 || k <= 0) {\\n            return false;\\n        }\\n\\n        int len = nums.length;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < len; i++) {\\n            if (map.containsKey(nums[i])) {\\n                int idx = map.get(nums[i]);\\n                if (Math.abs(i - idx) <= k) {\\n                    return true;\\n                }\\n                map.put(nums[i], i);\\n            } else {\\n                map.put(nums[i], i);\\n            }\\n        }\\n\\n        return false;\\n    }\\n```\n```java\\npublic boolean containsNearbyDuplicate(int[] nums, int k) {\\n\\tif (nums == null || nums.length <= 1 || k <= 0) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\tint len = nums.length;\\n\\tSet<Integer> set = new HashSet<>();\\n\\tfor (int i = 0; i < len; i++) {\\n\\t\\tif (i > k) {\\n\\t\\t\\tset.remove(nums[i - k - 1]);\\n\\t\\t}\\n\\n\\t\\tif (set.contains(nums[i])) {\\n\\t\\t\\treturn true;\\n\\t\\t} else {\\n\\t\\t\\tset.add(nums[i]);\\n\\t\\t}\\n\\t}\\n\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1846605,
                "title": "ts-map-and-2-pointer-approaches",
                "content": "```\\n// Complexity analysis - Hashmap approach\\n// Optimised Approach.\\n// Time: O(n)\\n// Space: O(n)\\n//\\n// Submission: 42% Time, 26% memory.\\n//\\nconst containsNearbyDuplicate = (nums: number[], k: number): boolean => {\\n  const lastIndexMap = new Map<number, number>();\\n  for (let i = 0; i < nums.length; i++) {\\n    if (i - lastIndexMap.get(nums[i]) <= k) {\\n      return true;\\n    }\\n    lastIndexMap.set(nums[i], i);\\n  }\\n  return false;\\n};\\n\\n\\n// Complexity analysis - Hashmap approach\\n// Time: O(n)\\n// Space: O(n)\\n//\\n// Submission: 15% Time, 15% memory.\\n//\\nconst containsNearbyDuplicate = (nums: number[], k: number): boolean => {\\n    const numsMap = new Map<number, number[]>();\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        numsMap.set(nums[i], [...(numsMap.get(nums[i])||[]), i]);\\n    };\\n    \\n    for (let indexes of numsMap.values()) {\\n        if (indexes.length < 2) continue;\\n        \\n        for (let x = 1; x < indexes.length; x++) {\\n            if ((indexes[x] - indexes[x-1]) <= k) return true;\\n        }\\n    }\\n    \\n    return false;\\n}\\n\\n// Complexity analysis - Two pointer approach.\\n// Time: O(n^2)\\n// Space: O(1)\\n//\\n// Submission: 10% Time, 90% memory.\\n//\\nfunction containsNearbyDuplicate(nums: number[], k: number): boolean {\\n    if (nums.length === 1) return false;\\n    \\n    let left = 0, right = 1;\\n    \\n    while(left < right && left <= nums.length) {\\n        if (right - left > k || right >= nums.length) {\\n            left++;\\n            right = left+1;\\n            continue;\\n        }\\n        \\n        if (nums[left] === nums[right]) return true;\\n        \\n        right++;\\n    }\\n    \\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Two Pointers",
                    "Iterator"
                ],
                "code": "```\\n// Complexity analysis - Hashmap approach\\n// Optimised Approach.\\n// Time: O(n)\\n// Space: O(n)\\n//\\n// Submission: 42% Time, 26% memory.\\n//\\nconst containsNearbyDuplicate = (nums: number[], k: number): boolean => {\\n  const lastIndexMap = new Map<number, number>();\\n  for (let i = 0; i < nums.length; i++) {\\n    if (i - lastIndexMap.get(nums[i]) <= k) {\\n      return true;\\n    }\\n    lastIndexMap.set(nums[i], i);\\n  }\\n  return false;\\n};\\n\\n\\n// Complexity analysis - Hashmap approach\\n// Time: O(n)\\n// Space: O(n)\\n//\\n// Submission: 15% Time, 15% memory.\\n//\\nconst containsNearbyDuplicate = (nums: number[], k: number): boolean => {\\n    const numsMap = new Map<number, number[]>();\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        numsMap.set(nums[i], [...(numsMap.get(nums[i])||[]), i]);\\n    };\\n    \\n    for (let indexes of numsMap.values()) {\\n        if (indexes.length < 2) continue;\\n        \\n        for (let x = 1; x < indexes.length; x++) {\\n            if ((indexes[x] - indexes[x-1]) <= k) return true;\\n        }\\n    }\\n    \\n    return false;\\n}\\n\\n// Complexity analysis - Two pointer approach.\\n// Time: O(n^2)\\n// Space: O(1)\\n//\\n// Submission: 10% Time, 90% memory.\\n//\\nfunction containsNearbyDuplicate(nums: number[], k: number): boolean {\\n    if (nums.length === 1) return false;\\n    \\n    let left = 0, right = 1;\\n    \\n    while(left < right && left <= nums.length) {\\n        if (right - left > k || right >= nums.length) {\\n            left++;\\n            right = left+1;\\n            continue;\\n        }\\n        \\n        if (nums[left] === nums[right]) return true;\\n        \\n        right++;\\n    }\\n    \\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1793248,
                "title": "ruby-solution",
                "content": "```\\n# @param {Integer[]} nums\\n# @param {Integer} k\\n# @return {Boolean}\\ndef contains_nearby_duplicate(nums, k)\\n  h = Hash.new\\n\\n  nums.each_with_index do |num, index|\\n    return true if h[num] != nil && (h[num] - index).abs <= k\\n\\n    h[num] = index\\n  end\\n\\n  false\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @param {Integer} k\\n# @return {Boolean}\\ndef contains_nearby_duplicate(nums, k)\\n  h = Hash.new\\n\\n  nums.each_with_index do |num, index|\\n    return true if h[num] != nil && (h[num] - index).abs <= k\\n\\n    h[num] = index\\n  end\\n\\n  false\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1616336,
                "title": "python-sliding-window",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        counter = Counter(nums[: k + 1])\\n        if any(val >= 2 for val in counter.values()):\\n            return True\\n        \\n        for i in range(k + 1, len(nums)):\\n            curr_num, pop_num = nums[i], nums[i - k - 1]\\n            counter[curr_num] += 1\\n            counter[pop_num] -= 1\\n            if counter[curr_num] >= 2:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        counter = Counter(nums[: k + 1])\\n        if any(val >= 2 for val in counter.values()):\\n            return True\\n        \\n        for i in range(k + 1, len(nums)):\\n            curr_num, pop_num = nums[i], nums[i - k - 1]\\n            counter[curr_num] += 1\\n            counter[pop_num] -= 1\\n            if counter[curr_num] >= 2:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1559618,
                "title": "simple-python-solution-using-dictionary",
                "content": "```\\ndic = {}\\n        \\n        for i in range(0,len(nums)):\\n            if nums[i] in dic:\\n                if(abs(dic[nums[i]] - i) <=k ):\\n                    return True\\n                else:\\n                    dic[nums[i]] = i\\n            else:\\n                dic[nums[i]] = i\\n        \\n        return False\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndic = {}\\n        \\n        for i in range(0,len(nums)):\\n            if nums[i] in dic:\\n                if(abs(dic[nums[i]] - i) <=k ):\\n                    return True\\n                else:\\n                    dic[nums[i]] = i\\n            else:\\n                dic[nums[i]] = i\\n        \\n        return False\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1490027,
                "title": "c-simple-solution-using-hash-maps-with-explanation",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) \\n    {\\n        \\n        unordered_map<int,int> map;        // key-value pair using hashing\\n\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n// checking the count of duplicate numbers and subtracting the index no with the given value at that number\\n\\n             if( (map.count(nums[i])) != 0 and (i-map[nums[i]] <= k) )\\n        {\\n             return true;\\n        }   \\n\\n             map[nums[i]]=i;                                   //incrementing for next val\\n\\n        }\\n\\n         return false;\\n    \\n    }\\n};\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) \\n    {\\n        \\n        unordered_map<int,int> map;        // key-value pair using hashing\\n\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n// checking the count of duplicate numbers and subtracting the index no with the given value at that number\\n\\n             if( (map.count(nums[i])) != 0 and (i-map[nums[i]] <= k) )\\n        {\\n             return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1416052,
                "title": "java-concise-solution-o-n",
                "content": "**Runtime: 18 ms, faster than 52.91% of Java online submissions for Contains Duplicate II.\\nMemory Usage: 48.2 MB, less than 49.94% of Java online submissions for Contains Duplicate II.**\\n```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i = 0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])){\\n                if(Math.abs(map.get(nums[i]) - i) <= k)return true;\\n            }\\n            map.put(nums[i],i);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i = 0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])){\\n                if(Math.abs(map.get(nums[i]) - i) <= k)return true;\\n            }\\n            map.put(nums[i],i);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1297513,
                "title": "simple-solution-in-swift",
                "content": "```\\nfunc containsNearbyDuplicate(_ nums: [Int], _ k: Int) -> Bool {\\n        var dict = [Int: Int]()\\n        for (currentIndex, num) in nums.enumerated() {\\n            if let duplicateIndex = dict[num], currentIndex - duplicateIndex <= k {\\n                return true\\n            }\\n            dict[num] = currentIndex\\n        }\\n        return false\\n    }\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc containsNearbyDuplicate(_ nums: [Int], _ k: Int) -> Bool {\\n        var dict = [Int: Int]()\\n        for (currentIndex, num) in nums.enumerated() {\\n            if let duplicateIndex = dict[num], currentIndex - duplicateIndex <= k {\\n                return true\\n            }\\n            dict[num] = currentIndex\\n        }\\n        return false\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1282513,
                "title": "python-o-n-using-dict",
                "content": "```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: [int], k: int) -> bool:\\n        dictionary = dict()\\n\\n        for index, val in enumerate(nums):\\n            if val in dictionary and abs(index - dictionary[val]) <= k:\\n                return True\\n\\n            dictionary[val] = index\\n\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: [int], k: int) -> bool:\\n        dictionary = dict()\\n\\n        for index, val in enumerate(nums):\\n            if val in dictionary and abs(index - dictionary[val]) <= k:\\n                return True\\n\\n            dictionary[val] = index\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1201633,
                "title": "c-solution",
                "content": "Not the most efficient way, but easy to undetstnad\\n\\n```\\nbool containsNearbyDuplicate(int* nums, int numsSize, int k){\\n    for (int i=0; i<numsSize; i++) {\\n        int upper = (k+i+1>numsSize)?numsSize:k+i+1;\\n        for (int j=i+1; j<upper; j++) {\\n            if (nums[i]==nums[j])\\n                return true;\\n        }\\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool containsNearbyDuplicate(int* nums, int numsSize, int k){\\n    for (int i=0; i<numsSize; i++) {\\n        int upper = (k+i+1>numsSize)?numsSize:k+i+1;\\n        for (int j=i+1; j<upper; j++) {\\n            if (nums[i]==nums[j])\\n                return true;\\n        }\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1000208,
                "title": "python-solution",
                "content": "\\th = {}\\n\\tfor i in range(len(nums)):\\n\\t\\tif nums[i] in h:\\n\\t\\t\\tif i - h[nums[i]] <= k:\\n\\t\\t\\t\\treturn True\\n\\t\\th[nums[i]] = i\\n\\treturn False",
                "solutionTags": [],
                "code": "\\th = {}\\n\\tfor i in range(len(nums)):\\n\\t\\tif nums[i] in h:\\n\\t\\t\\tif i - h[nums[i]] <= k:\\n\\t\\t\\t\\treturn True\\n\\t\\th[nums[i]] = i\\n\\treturn False",
                "codeTag": "Unknown"
            },
            {
                "id": 828158,
                "title": "python-js-java-go-c-o-n-by-dictionary-map-w-comment",
                "content": "Python O(n) by dictionary\\n\\n---\\n\\n**Implementation**:\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        \\n        # key: number\\n        # value: last position on the left hand side\\n        lastPosition  = {}\\n        \\n        for idx, number in enumerate(nums):\\n            \\n            # Do we have duplicate numbers within distance k ?\\n            if idx - lastPosition .get(number, -float(inf) ) <= k:\\n                return True\\n           \\n            # update last position of current number\\n            lastPosition [number] = idx\\n        \\n        return False\\n```\\n\\n---\\n\\nJava:\\n\\n```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        \\n        // key: number\\n        // value: last position on the left hand side\\n        HashMap<Integer, Integer> lastPosition = new HashMap<Integer, Integer>();\\n        \\n        for(int i = 0 ; i < nums.length ; i++){\\n            \\n            int curNum = nums[i];\\n            \\n            // Do we have duplicate numbers within distance k ?\\n            if( lastPosition.containsKey(curNum) && ( i - lastPosition.get(curNum) ) <= k ){\\n                return true;\\n            }\\n            \\n            // update last position of current number\\n            lastPosition.put(curNum, i);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n\\n---\\n\\nJavscript:\\n\\n```\\nvar containsNearbyDuplicate = function(nums, k) {\\n    \\n    // key: number\\n    // value: last position on the left hand side\\n    lastPosition = new Map();\\n    \\n    for(let i = 0 ; i < nums.length ; i++){\\n        \\n        const curNum = nums[i];\\n        \\n        // Do we have duplicate numbers within distance k ?\\n        if( lastPosition.has(curNum) && ( i - lastPosition.get(curNum) ) <= k ){\\n            return true;\\n        }\\n        \\n        // update last position of current number\\n        lastPosition.set(curNum, i);\\n    }\\n    \\n    return false;\\n};\\n```\\n\\n---\\n\\nGo:\\n\\n```\\nfunc containsNearbyDuplicate(nums []int, k int) bool {\\n    \\n    // key: number\\n    // value: last position on the left hand side\\n    lastPosition := make( map[int]int )\\n    \\n    for idx, curNum := range nums{\\n        \\n        lastPos, exist := lastPosition[curNum]\\n        \\n        // Do we have duplicate numbers within distance k ?\\n        if exist && ( idx - lastPos ) <= k {\\n            return true;\\n        }\\n        \\n        // update last position of current number\\n        lastPosition[ curNum ] = idx\\n    }\\n    \\n    return false;\\n    \\n}\\n```\\n\\n---\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        \\n        // key: number\\n        // value: last position on the left hand side\\n        unordered_map<int, int> lastPosition;\\n        \\n        for(size_t i = 0 ; i < nums.size() ; i++){\\n            \\n            const int curNum = nums[i];\\n            \\n            // Do we have duplicate numbers within distance k ?\\n            if( lastPosition.count(curNum) && ( i - lastPosition[curNum] ) <= k ){\\n                return true;\\n            }\\n            \\n            // update last position of current number\\n            lastPosition[curNum] = i;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n\\n[Leetcode #217 Contains Duplicate](https://leetcode.com/problems/contains-duplicate/)\\n\\n[Leetcode #219 Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii)\\n\\n[Leetcode #220 Contains Duplicate III](https://leetcode.com/problems/contains-duplicate-iii)\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        \\n        # key: number\\n        # value: last position on the left hand side\\n        lastPosition  = {}\\n        \\n        for idx, number in enumerate(nums):\\n            \\n            # Do we have duplicate numbers within distance k ?\\n            if idx - lastPosition .get(number, -float(inf) ) <= k:\\n                return True\\n           \\n            # update last position of current number\\n            lastPosition [number] = idx\\n        \\n        return False\\n```\n```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        \\n        // key: number\\n        // value: last position on the left hand side\\n        HashMap<Integer, Integer> lastPosition = new HashMap<Integer, Integer>();\\n        \\n        for(int i = 0 ; i < nums.length ; i++){\\n            \\n            int curNum = nums[i];\\n            \\n            // Do we have duplicate numbers within distance k ?\\n            if( lastPosition.containsKey(curNum) && ( i - lastPosition.get(curNum) ) <= k ){\\n                return true;\\n            }\\n            \\n            // update last position of current number\\n            lastPosition.put(curNum, i);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\n```\\nvar containsNearbyDuplicate = function(nums, k) {\\n    \\n    // key: number\\n    // value: last position on the left hand side\\n    lastPosition = new Map();\\n    \\n    for(let i = 0 ; i < nums.length ; i++){\\n        \\n        const curNum = nums[i];\\n        \\n        // Do we have duplicate numbers within distance k ?\\n        if( lastPosition.has(curNum) && ( i - lastPosition.get(curNum) ) <= k ){\\n            return true;\\n        }\\n        \\n        // update last position of current number\\n        lastPosition.set(curNum, i);\\n    }\\n    \\n    return false;\\n};\\n```\n```\\nfunc containsNearbyDuplicate(nums []int, k int) bool {\\n    \\n    // key: number\\n    // value: last position on the left hand side\\n    lastPosition := make( map[int]int )\\n    \\n    for idx, curNum := range nums{\\n        \\n        lastPos, exist := lastPosition[curNum]\\n        \\n        // Do we have duplicate numbers within distance k ?\\n        if exist && ( idx - lastPos ) <= k {\\n            return true;\\n        }\\n        \\n        // update last position of current number\\n        lastPosition[ curNum ] = idx\\n    }\\n    \\n    return false;\\n    \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        \\n        // key: number\\n        // value: last position on the left hand side\\n        unordered_map<int, int> lastPosition;\\n        \\n        for(size_t i = 0 ; i < nums.size() ; i++){\\n            \\n            const int curNum = nums[i];\\n            \\n            // Do we have duplicate numbers within distance k ?\\n            if( lastPosition.count(curNum) && ( i - lastPosition[curNum] ) <= k ){\\n                return true;\\n            }\\n            \\n            // update last position of current number\\n            lastPosition[curNum] = i;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826563,
                "title": "javascript-easy-solution-faster-than-95",
                "content": "```\\nvar containsNearbyDuplicate = function(nums, k) {\\n    let map = new Map();\\n    for(let i=0; i<nums.length; i++){\\n        let current = nums[i]\\n        if(map.has(current) && Math.abs(map.get(current)-i)<=k){\\n            return true;\\n        } else{\\n            map.set(current, i);\\n        }\\n    }\\n    return false;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar containsNearbyDuplicate = function(nums, k) {\\n    let map = new Map();\\n    for(let i=0; i<nums.length; i++){\\n        let current = nums[i]\\n        if(map.has(current) && Math.abs(map.get(current)-i)<=k){\\n            return true;\\n        } else{\\n            map.set(current, i);\\n        }\\n    }\\n    return false;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 805006,
                "title": "ruby-solution",
                "content": "```\\n# @param {Integer[]} nums\\n# @param {Integer} k\\n# @return {Boolean}\\ndef contains_nearby_duplicate(nums, k)\\n    num_hash = Hash.new\\n    for i in 0...nums.length\\n        if num_hash[nums[i]]==nil\\n            num_hash[nums[i]]=i\\n        else\\n            return true if i-num_hash[nums[i]]<=k\\n            num_hash[nums[i]]=i\\n        end\\n    end\\n    false\\nend\\n",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} nums\\n# @param {Integer} k\\n# @return {Boolean}\\ndef contains_nearby_duplicate(nums, k)\\n    num_hash = Hash.new\\n    for i in 0...nums.length\\n        if num_hash[nums[i]]==nil\\n            num_hash[nums[i]]=i\\n        else\\n            return true if i-num_hash[nums[i]]<=k\\n            num_hash[nums[i]]=i\\n        end\\n    end\\n    false\\nend\\n",
                "codeTag": "Python3"
            },
            {
                "id": 549053,
                "title": "python-simple-solution-72-ms-faster-than-90-80",
                "content": "```\\nclass Solution(object):\\n    def containsNearbyDuplicate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: bool\\n        \"\"\"\\n        if len(nums) == len(set(nums)):\\n            return False\\n\\n        for i in range(len(nums)):\\n            for j in range(i + 1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    if j - i <= k:\\n                        return True\\n        return False\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def containsNearbyDuplicate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: bool\\n        \"\"\"\\n        if len(nums) == len(set(nums)):\\n            return False\\n\\n        for i in range(len(nums)):\\n            for j in range(i + 1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    if j - i <= k:\\n                        return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 439454,
                "title": "o-n-time-o-k-space-hashset-with-least-recently-seen-eviction-policy",
                "content": "Space optimisation using a fixed-size Set with a least-recently seen Eviction Policy,\\n\\n```\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        seen = set()\\n        for i,num in enumerate(nums):\\n            if num in seen:\\n                return True\\n            seen.add(num)\\n            if len(seen) > k:\\n                seen.remove(nums[i - k])\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        seen = set()\\n        for i,num in enumerate(nums):\\n            if num in seen:\\n                return True\\n            seen.add(num)\\n            if len(seen) > k:\\n                seen.remove(nums[i - k])\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 346789,
                "title": "c-simple-solution-hope-you-like-it",
                "content": "\\'\\'\\'\\n\\n\\t// Lookup table and Sliding window\\n\\n\\tunordered_set<int> record;\\n\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\tif (record.find(nums[i]) != record.end())\\n\\t\\t\\treturn true;\\n\\n\\t\\trecord.insert(nums[i]);\\n\\n\\t\\tif (record.size() == k + 1)\\n\\t\\t\\trecord.erase(nums[i - k]);\\n\\t}\\n\\n\\treturn false;\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n\\t// Lookup table and Sliding window\\n\\n\\tunordered_set<int> record;\\n\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\tif (record.find(nums[i]) != record.end())\\n\\t\\t\\treturn true;\\n\\n\\t\\trecord.insert(nums[i]);\\n\\n\\t\\tif (record.size() == k + 1)\\n\\t\\t\\trecord.erase(nums[i - k]);\\n\\t}\\n\\n\\treturn false;\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 338831,
                "title": "why-is-hashmap-much-faster-than-hashset",
                "content": "```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        Map<Integer, Integer> record = new HashMap();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (record.containsKey(nums[i])) {\\n                if (i - record.get(nums[i]) <= k) return true;\\n            }\\n            record.put(nums[i], i);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\nThis solution is 8ms.\\nBut when I used the 3rd official solution , the runtime is around 30ms.\\nCan someone tell me why this happened?\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        Map<Integer, Integer> record = new HashMap();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (record.containsKey(nums[i])) {\\n                if (i - record.get(nums[i]) <= k) return true;\\n            }\\n            record.put(nums[i], i);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 245054,
                "title": "rust-4ms-using-hashmap",
                "content": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn contains_nearby_duplicate(nums: Vec<i32>, k: i32) -> bool {\\n        let mut map = HashMap::new();\\n\\n        for (i, num) in nums.iter().enumerate() {\\n            if let Some(j) = map.insert(num, i) {\\n                if (i as i32) - (j as i32) <= k {\\n                    return true;\\n                }\\n            }\\n        }\\n        false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn contains_nearby_duplicate(nums: Vec<i32>, k: i32) -> bool {\\n        let mut map = HashMap::new();\\n\\n        for (i, num) in nums.iter().enumerate() {\\n            if let Some(j) = map.insert(num, i) {\\n                if (i as i32) - (j as i32) <= k {\\n                    return true;\\n                }\\n            }\\n        }\\n        false\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 61508,
                "title": "straightforward-java-hashset-solution-9ms-beats-90",
                "content": "Iterate over all elements in the list, adding them to a HashSet.  If the element was found in the HashSet, return true.  Since the add method in Java returns a boolean if the value was already in the HashSet, we can use this instead of the contains method to save time.  To satisfy the \"k difference\" requirement, we remove the kth previous element from the HashSet once we reach that point (so the HashSet only ever contains the previous k elements).\\n\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        HashSet<Integer> hs = new HashSet<>();\\n        for(int i = 0; i < nums.length; i++) {\\n            if(i > k) {\\n                hs.remove(nums[i-k-1]);\\n            }\\n            if(!hs.add(nums[i])) return true;\\n        }\\n        return false;\\n    }\\n\\nA naive approach would construct the HashSet for the previous k elements each time we iterate to the next element.  This is unnecessary though, since the next \"window\" will contain k-1 of the same elements.  Since k may range up to n, this optimization makes the algorithm run in O(n) time instead of O(n^2).",
                "solutionTags": [
                    "Java"
                ],
                "code": "Iterate over all elements in the list, adding them to a HashSet.  If the element was found in the HashSet, return true.  Since the add method in Java returns a boolean if the value was already in the HashSet, we can use this instead of the contains method to save time.  To satisfy the \"k difference\" requirement, we remove the kth previous element from the HashSet once we reach that point (so the HashSet only ever contains the previous k elements).\\n\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        HashSet<Integer> hs = new HashSet<>();\\n        for(int i = 0; i < nums.length; i++) {\\n            if(i > k) {\\n                hs.remove(nums[i-k-1]);\\n            }\\n            if(!hs.add(nums[i])) return true;\\n        }\\n        return false;\\n    }\\n\\nA naive approach would construct the HashSet for the previous k elements each time we iterate to the next element.  This is unnecessary though, since the next \"window\" will contain k-1 of the same elements.  Since k may range up to n, this optimization makes the algorithm run in O(n) time instead of O(n^2).",
                "codeTag": "Unknown"
            },
            {
                "id": 61513,
                "title": "5ms-98-8-java-solution",
                "content": "    public class Solution {\\n        public void xwap(int[] a, int i, int j) { \\n            int tmp=a[i]; \\n            a[i]=a[j]; \\n            a[j]=tmp; \\n        } \\n         \\n        public void qsort(int[] a, int[] indice, int s, int t) { \\n            if (s>=t) return; \\n            int mid=a[(s+t)/2], i=s, j=t; \\n            while (i<j) { \\n                while (i<j && a[i]<mid) i++; \\n                while (i<j && a[j]>mid) j--; \\n                if (a[i]==mid && a[j]==mid) j--; \\n                if (i<j) { \\n                    xwap(a,i,j); \\n                    xwap(indice,i,j); \\n                } \\n            } \\n            qsort(a,indice,s,i-1); \\n            qsort(a,indice,i+1,t); \\n        } \\n    \\n        public boolean containsNearbyDuplicate(int[] nums, int k) { \\n            if (nums==null) return false; \\n            if (nums.length<2) return false; \\n            int n=nums.length; \\n            int[] indice = new int[n]; \\n            for (int i=0; i<n; i++) indice[i]=i; \\n            qsort(nums,indice,0,n-1); \\n    \\n            for (int i=0; i<n; i++) {\\n                int j=i+1;\\n                while (j<n && nums[j]==nums[i]) {\\n                    if (Math.abs(indice[i]-indice[j])<=k) return true;\\n                    j++;\\n                }\\n            }\\n                \\n            return false; \\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public void xwap(int[] a, int i, int j) { \\n            int tmp=a[i]; \\n            a[i]=a[j]; \\n            a[j]=tmp; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 61616,
                "title": "c-o-n-solution",
                "content": "class Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n       // int size_num = nums.size();\\n       // if(size_num== 0 || size_num == 1)\\n       //     return false;\\n        \\n        unordered_map<int,int> mymap;\\n        unordered_map<int,int>::iterator inIter;\\n        //result.reserve(20);\\n        int index =0;\\n        for (vector<int>::iterator iter=nums.begin();iter!=nums.end();iter++)\\n        {\\n            int value = *iter;\\n            inIter = mymap.find(value);\\n            if(inIter == mymap.end())\\n                mymap[value] = index;\\n            else\\n            {\\n                int prev_index = (*inIter).second;\\n                if(index - prev_index <= k)\\n                    return true;\\n                else\\n                    mymap[value] = index;\\n            }\\n                \\n        index++;\\n        }\\n        \\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n       // int size_num = nums.size();\\n       // if(size_num== 0 || size_num == 1)\\n       //     return false;\\n        \\n        unordered_map<int,int> mymap;\\n        unordered_map<int,int>::iterator inIter;\\n        //result.reserve(20);\\n        int index =0;\\n        for (vector<int>::iterator iter=nums.begin();iter!=nums.end();iter++)\\n        {\\n            int value = *iter;\\n            inIter = mymap.find(value);\\n            if(inIter == mymap.end())\\n                mymap[value] = index;\\n            else\\n            {\\n                int prev_index = (*inIter).second;\\n                if(index - prev_index <= k)\\n                    return true;\\n                else\\n                    mymap[value] = index;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3835308,
                "title": "python3-beats-99-83",
                "content": "# Approach\\nSimilar to the [Two Sum](https://leetcode.com/problems/two-sum)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$ because there has been used support dictionary to store covered list\\'s items\\n\\n# Code\\n```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        d = {}\\n        for i in range(len(nums)):\\n            if nums[i] in d:\\n                if abs(d[nums[i]] - i) <= k:\\n                    return True\\n            d[nums[i]] = i\\n        return False\\n```\\n\\nUPD: As it was told in comments, unnecessary `else`s were removed. Thanks to [@fck_scl](https://leetcode.com/fck_scl/)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        d = {}\\n        for i in range(len(nums)):\\n            if nums[i] in d:\\n                if abs(d[nums[i]] - i) <= k:\\n                    return True\\n            d[nums[i]] = i\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828030,
                "title": "best-solution-using-hash-table",
                "content": "# Java\\nIn Java hashMap.put(key,value) method returns the previous value associated with key, or null if there was no mapping for key. (A null return can also indicate that the map previously associated null with key.)\\n\\nSo, we iterate through array and put each element in HashMap (key is current element, value is current index), then we check what method put returns. \\n# Go\\nIn Go when you are look up for something in map you get back two parameters value and is this key exist.\\n\\nSo, we iterate through array and try to find is element already present in map. At the end of the loop we put each element in map (key is current element, value is current index).\\n\\n# Both\\nWe check is previous value from map exist and \\ncurrent element - previous value <= k\\n\\nthis is our requirement from task:\\n\\n```nums[i] == nums[j]``` and ```abs(i - j) <= k```\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n```Java []\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n      HashMap<Integer, Integer> cache = new HashMap<>();\\n      int length = nums.length;\\n      for (int i = 0; i < length; i++) {\\n        Integer prev = cache.put(nums[i], i);\\n        if (prev != null && i - prev <= k) {\\n          return true;\\n        }\\n      }\\n    return false;\\n  }\\n}\\n```\\n```Go []\\nfunc containsNearbyDuplicate(nums []int, k int) bool {\\n\\tcache := make(map[int]int)\\n\\tfor i, el := range nums {\\n\\t\\tprev, exist := cache[el]\\n\\t\\tif exist && i-prev <= k {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tcache[el] = i\\n\\t}\\n\\treturn false\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Go"
                ],
                "code": "```nums[i] == nums[j]```\n```abs(i - j) <= k```\n```Java []\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n      HashMap<Integer, Integer> cache = new HashMap<>();\\n      int length = nums.length;\\n      for (int i = 0; i < length; i++) {\\n        Integer prev = cache.put(nums[i], i);\\n        if (prev != null && i - prev <= k) {\\n          return true;\\n        }\\n      }\\n    return false;\\n  }\\n}\\n```\n```Go []\\nfunc containsNearbyDuplicate(nums []int, k int) bool {\\n\\tcache := make(map[int]int)\\n\\tfor i, el := range nums {\\n\\t\\tprev, exist := cache[el]\\n\\t\\tif exist && i-prev <= k {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tcache[el] = i\\n\\t}\\n\\treturn false\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789103,
                "title": "2-c-solutions-hash-table-and-hash-set-approach-100-time-100-space",
                "content": "\\n\\n# Code\\n```\\n// Solution 1 (Hash table)\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        int count = 0;\\n        unordered_map<int, int> mp;\\n        for(int i=0; i<nums.size(); i++){\\n            if(mp.count(nums[i])){\\n                if(abs(i - mp[nums[i]]) <= k)\\n                    return true;\\n            }\\n            mp[nums[i]] = i;\\n        }\\n        return false;\\n    }\\n};\\n\\n// Solution 2 (Hash set)\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k)\\n    {\\n       unordered_set<int> s;\\n       if (k <= 0) return false;\\n       if (k >= nums.size())    k = nums.size() - 1;\\n       for (int i = 0; i < nums.size(); i++)\\n       {\\n            if (i > k) \\n                s.erase(nums[i - k - 1]);\\n            if (s.find(nums[i]) != s.end()) \\n                return true;\\n            s.insert(nums[i]);\\n       }       \\n       return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\n// Solution 1 (Hash table)\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        int count = 0;\\n        unordered_map<int, int> mp;\\n        for(int i=0; i<nums.size(); i++){\\n            if(mp.count(nums[i])){\\n                if(abs(i - mp[nums[i]]) <= k)\\n                    return true;\\n            }\\n            mp[nums[i]] = i;\\n        }\\n        return false;\\n    }\\n};\\n\\n// Solution 2 (Hash set)\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k)\\n    {\\n       unordered_set<int> s;\\n       if (k <= 0) return false;\\n       if (k >= nums.size())    k = nums.size() - 1;\\n       for (int i = 0; i < nums.size(); i++)\\n       {\\n            if (i > k) \\n                s.erase(nums[i - k - 1]);\\n            if (s.find(nums[i]) != s.end()) \\n                return true;\\n            s.insert(nums[i]);\\n       }       \\n       return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712147,
                "title": "the-shortest-code-in-c-using-hash-map-with-simple-explanation",
                "content": "# Intuition\\nFirst I thought about sliding window, but I find a solution with hashing (unordered map).\\n\\n# Approach\\nInitialize an unordered map m to keep track of the last occurrence of each number in the nums array.\\nIterate through the nums array and for each number, check if it already exists in m and if the distance between the current index and the previous index where the number appeared is less than or equal to k. If so, return true as there is a duplicate within the specified distance.\\nUpdate the map m by setting the value of the key to the current index.\\nIf the loop completes without finding any duplicates within the specified distance, return false.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(min(n,k))\\n\\n# UPVOTE IF IT WAS HELPFUL :)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        unordered_map<int, int> m;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (m.count(nums[i]) && i - m[nums[i]] <= k) {\\n                return true;\\n            }\\n            m[nums[i]] = i;\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        unordered_map<int, int> m;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (m.count(nums[i]) && i - m[nums[i]] <= k) {\\n                return true;\\n            }\\n            m[nums[i]] = i;\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468568,
                "title": "simple-java-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(hm.containsKey(nums[i]) && Math.abs(hm.get(nums[i])-i)<=k)return true;\\n            hm.put(nums[i],i);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(hm.containsKey(nums[i]) && Math.abs(hm.get(nums[i])-i)<=k)return true;\\n            hm.put(nums[i],i);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3004199,
                "title": "java-easiest-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        Map<Integer, Integer> x = new HashMap<>();\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (x.containsKey(nums[i]) && i - x.get(nums[i]) <= k) {\\n                return true;\\n            }\\n            x.put(nums[i], i);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        Map<Integer, Integer> x = new HashMap<>();\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (x.containsKey(nums[i]) && i - x.get(nums[i]) <= k) {\\n                return true;\\n            }\\n            x.put(nums[i], i);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2729217,
                "title": "219-contains-duplicate-ii-c-solution-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n\\n        //create an unordered map to store numbers and their indexes\\n        unordered_map<int,int> mp;\\n        \\n        //iterate over the array and check if the number is present in the map or not\\n        for( int i=0; i<nums.size(); i++){\\n            //if number is already present in the map,  it means it is a duplicate number and now we need to check the diffrence of the index of the occurences of the number. \\n            //if we get the diffrence of indexes less than or equals to k,  return true\\n            if(mp.count(nums[i])>0 && abs(mp[nums[i]]-i)<=k){\\n                return true;\\n            }\\n            \\n            //if number in not present in the map, it means it is a new occurence and store it in the map with its index.\\n            mp[nums[i]]= i;\\n        }\\n        //if no duplicate is found in above processes, return false.\\n        return false;\\n    }\\n};\\n```\\n\\n**please UPVOTE if you like the solution/ approach**\\n\\ncomment if you have any query.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n\\n        //create an unordered map to store numbers and their indexes\\n        unordered_map<int,int> mp;\\n        \\n        //iterate over the array and check if the number is present in the map or not\\n        for( int i=0; i<nums.size(); i++){\\n            //if number is already present in the map,  it means it is a duplicate number and now we need to check the diffrence of the index of the occurences of the number. \\n            //if we get the diffrence of indexes less than or equals to k,  return true\\n            if(mp.count(nums[i])>0 && abs(mp[nums[i]]-i)<=k){\\n                return true;\\n            }\\n            \\n            //if number in not present in the map, it means it is a new occurence and store it in the map with its index.\\n            mp[nums[i]]= i;\\n        }\\n        //if no duplicate is found in above processes, return false.\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2729018,
                "title": "hashmap-93-faster-java",
                "content": "```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n      \\n      HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i = 0; i<nums.length; i++){\\n            if(map.containsKey(nums[i])){\\n                if(Math.abs(map.get(nums[i]) - i) <= k)return true;\\n                else{\\n                    map.put(nums[i],i);\\n                }\\n            }else{\\n                map.put(nums[i], i);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n      \\n      HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i = 0; i<nums.length; i++){\\n            if(map.containsKey(nums[i])){\\n                if(Math.abs(map.get(nums[i]) - i) <= k)return true;\\n                else{\\n                    map.put(nums[i],i);\\n                }\\n            }else{\\n                map.put(nums[i], i);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2728781,
                "title": "java-map-solution-easy-solution",
                "content": "```\\nHashMap<Integer, Integer> map = new HashMap<>();\\nfor (int i = 0; i <= nums.length - 1; i++) {\\n\\tif (map.containsKey(nums[i]) && Math.abs(map.get(nums[i]) - i) <= k)\\n\\t\\treturn true;\\n\\tmap.put(nums[i], i);\\n}\\nreturn false;\\n```\\n\\n\\n**1st integer-key to store num[i]-array value\\n2nd integer-value to store i-index**\\n# Please UPVOTE if you like the solution or the explanation, If you have any question, feel free to ask",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nHashMap<Integer, Integer> map = new HashMap<>();\\nfor (int i = 0; i <= nums.length - 1; i++) {\\n\\tif (map.containsKey(nums[i]) && Math.abs(map.get(nums[i]) - i) <= k)\\n\\t\\treturn true;\\n\\tmap.put(nums[i], i);\\n}\\nreturn false;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2728649,
                "title": "simple-solution-without-hashmap",
                "content": "**please upvote if you like**\\n```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        for(int i=0;i<nums.length-1;i++){\\n            for(int j=i+1,m=0;j<nums.length && m<k;j++,m++){\\n                if(nums[i]==nums[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        for(int i=0;i<nums.length-1;i++){\\n            for(int j=i+1,m=0;j<nums.length && m<k;j++,m++){\\n                if(nums[i]==nums[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2728096,
                "title": "c-detailed-simplest-soution-runtime-469-ms-beats-19-51-memory-77-2-mb-beats-33-65",
                "content": "# Approach\\nThe most Naive approach I think is the best solution.\\nThe question is pretty much simple.\\nAll we need to do is to form a hash map and store key value pairs as ```element``` and ```it\\'s index``` respectively in the map.\\nNow check weather the element is present or not.\\n```\\nif(not present){\\n    insert the key value pairs.\\n}\\nelse{\\n    Check the difference between \\n    the new index value and the initial index stored.\\n    if\\n        difference <= k return true\\n    else \\n        update the index of current element.\\n\\n}\\n```\\n***Hope the above flow diagram is clear to all.***\\n```\\nif(loved solution == true)\\n    upvote++;\\nelse\\n    CorrectMe++;\\n```\\n\\n# Complexity\\n- Time complexity:\\nSince the array is traversed completely,\\nTime Complexity = ```O(n)```;\\n\\n- Space complexity:\\nAn extra space of map is used hence,\\nSpace Complexity = ```O(n)```.\\n\\n## ***Happy Coding***\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        map<int, int> m;\\n        int len = nums.size();\\n        for(int i = 0;i<len; i++){\\n            if(m.find(nums[i]) == m.end()) m[nums[i]] = i;\\n            else{\\n                int diff = (abs(i - m[nums[i]]));\\n                if(diff <=k)\\n                    return true;\\n                else\\n                    m[nums[i]] = i;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```element```\n```it\\'s index```\n```\\nif(not present){\\n    insert the key value pairs.\\n}\\nelse{\\n    Check the difference between \\n    the new index value and the initial index stored.\\n    if\\n        difference <= k return true\\n    else \\n        update the index of current element.\\n\\n}\\n```\n```\\nif(loved solution == true)\\n    upvote++;\\nelse\\n    CorrectMe++;\\n```\n```O(n)```\n```O(n)```\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        map<int, int> m;\\n        int len = nums.size();\\n        for(int i = 0;i<len; i++){\\n            if(m.find(nums[i]) == m.end()) m[nums[i]] = i;\\n            else{\\n                int diff = (abs(i - m[nums[i]]));\\n                if(diff <=k)\\n                    return true;\\n                else\\n                    m[nums[i]] = i;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2728013,
                "title": "fast-solution-daily-leetcoding-challenge-october-day-21",
                "content": "![image](https://assets.leetcode.com/users/images/f255cf42-722d-4dff-b35e-e8918545b72c_1666331423.9961147.png)\\n\\n\\n```\\n\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k)\\n    {\\n        unordered_map<int,int> m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(m[nums[i]]==0)\\n                m[nums[i]]=i+1;\\n            else if(m[nums[i]]>0 && abs(m[nums[i]]-(i+1))<=k)\\n                return true;\\n            else\\n                m[nums[i]]=i+1;\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k)\\n    {\\n        unordered_map<int,int> m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(m[nums[i]]==0)\\n                m[nums[i]]=i+1;\\n            else if(m[nums[i]]>0 && abs(m[nums[i]]-(i+1))<=k)\\n                return true;\\n            else\\n                m[nums[i]]=i+1;\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2727734,
                "title": "simplest-and-easiest-c-solution-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            if(mp.count(nums[i])){\\n                int x=i-mp[nums[i]];\\n                if(x<=k)return true;\\n            }\\n            mp[nums[i]]=i;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            if(mp.count(nums[i])){\\n                int x=i-mp[nums[i]];\\n                if(x<=k)return true;\\n            }\\n            mp[nums[i]]=i;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2727551,
                "title": "basic-solution-java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n       Map<Integer,ArrayList<Integer>> map=new HashMap<Integer, ArrayList<Integer>>();\\n\\t\\tfor(int i=0;i<nums.length;i++) {\\n\\t\\t\\tif(map.containsKey(nums[i])) {\\n\\t\\t\\t\\tArrayList<Integer> arr=map.get(nums[i]);\\n\\t\\t\\t\\tarr.add(i);\\n\\t\\t\\t\\tmap.put(nums[i],arr);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tArrayList<Integer> l=new ArrayList<Integer>();\\n\\t\\t\\t\\tl.add(i);\\n\\t\\t\\t\\tmap.put(nums[i],l);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor(int i=0;i<nums.length;i++) {\\n\\t\\t\\tif(map.containsKey(nums[i])) {\\n\\t\\t\\t\\tList<Integer> l=map.get(nums[i]);\\n\\t\\t\\t\\tfor(int j=0;j<l.size();j++) {\\n\\t\\t\\t\\t\\tif(Math.abs(i-l.get(j))<=k && i!=l.get(j)) return true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n    }\\n}\\n```\\n\\nbest solution\\n```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        if (k == 0) return false;\\n\\n        Map<Integer, Integer> hashMap = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            int j = nums[i];\\n            if (hashMap.containsKey(j) && i - hashMap.get(j) <= k) return true;\\n            hashMap.put(j, i);\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n       Map<Integer,ArrayList<Integer>> map=new HashMap<Integer, ArrayList<Integer>>();\\n\\t\\tfor(int i=0;i<nums.length;i++) {\\n\\t\\t\\tif(map.containsKey(nums[i])) {\\n\\t\\t\\t\\tArrayList<Integer> arr=map.get(nums[i]);\\n\\t\\t\\t\\tarr.add(i);\\n\\t\\t\\t\\tmap.put(nums[i],arr);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tArrayList<Integer> l=new ArrayList<Integer>();\\n\\t\\t\\t\\tl.add(i);\\n\\t\\t\\t\\tmap.put(nums[i],l);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor(int i=0;i<nums.length;i++) {\\n\\t\\t\\tif(map.containsKey(nums[i])) {\\n\\t\\t\\t\\tList<Integer> l=map.get(nums[i]);\\n\\t\\t\\t\\tfor(int j=0;j<l.size();j++) {\\n\\t\\t\\t\\t\\tif(Math.abs(i-l.get(j))<=k && i!=l.get(j)) return true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2727361,
                "title": "c-hashmap-beginner-friendly-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nChecking all the indices using hashmaps and updating them.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust we have to traverse through the vector for one time using this approach. First take a map with ke_value pair as integers. Then start traversing the given vector . Check wether if the map contains the key by using map.find() function. If a key is found , subtarct its index with the presesnt index and check the condition , if found return true , else update the value with new index.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        map <int , int> mp;\\n        for(int i = 0; i < nums.size() ; i++)\\n        {\\n            if(mp.find(nums[i])!=mp.end())\\n            {\\n                if(abs(mp[nums[i]]-i)<=k) return true;\\n            }\\n\\n            mp[nums[i]] = i;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        map <int , int> mp;\\n        for(int i = 0; i < nums.size() ; i++)\\n        {\\n            if(mp.find(nums[i])!=mp.end())\\n            {\\n                if(abs(mp[nums[i]]-i)<=k) return true;\\n            }\\n\\n            mp[nums[i]] = i;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2645193,
                "title": "java-hashmap-solution",
                "content": "```\\n\\t\\tHashMap<Integer,Integer>map=new HashMap<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            \\n            if(map.containsKey(nums[i])){\\n                if(i-map.get(nums[i])<=k){\\n                    return true;\\n                }\\n            }\\n            map.put(nums[i],i);\\n        }\\n        \\n        return false;",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\tHashMap<Integer,Integer>map=new HashMap<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            \\n            if(map.containsKey(nums[i])){\\n                if(i-map.get(nums[i])<=k){\\n                    return true;\\n                }\\n            }\\n            map.put(nums[i],i);\\n        }\\n        \\n        return false;",
                "codeTag": "Unknown"
            },
            {
                "id": 2640309,
                "title": "python-easy-solution-in-o-n-time-complexity",
                "content": "```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        n=len(nums)\\n        d=dict()\\n        for i in range(n):\\n            if nums[i] not in d:\\n                d[nums[i]]=i\\n            elif nums[i] in d:\\n                if i-d[nums[i]]<=k:\\n                    return True\\n                else:\\n                    d[nums[i]]=i\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        n=len(nums)\\n        d=dict()\\n        for i in range(n):\\n            if nums[i] not in d:\\n                d[nums[i]]=i\\n            elif nums[i] in d:\\n                if i-d[nums[i]]<=k:\\n                    return True\\n                else:\\n                    d[nums[i]]=i\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2582314,
                "title": "python-solution-time-space-o-n",
                "content": "```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        cheak=dict()\\n        flag=False\\n        for i in range(len(nums)):\\n            if nums[i] not in cheak:\\n                cheak[nums[i]]=i\\n                continue\\n            if abs(i-cheak[nums[i]])<=k:\\n                flag=True\\n            cheak[nums[i]]=i\\n        return flag\\n                \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        cheak=dict()\\n        flag=False\\n        for i in range(len(nums)):\\n            if nums[i] not in cheak:\\n                cheak[nums[i]]=i\\n                continue\\n            if abs(i-cheak[nums[i]])<=k:\\n                flag=True\\n            cheak[nums[i]]=i\\n        return flag\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570441,
                "title": "c-map-detailed-explanation",
                "content": "bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        \\n        unordered_map<int,int> mp;//it will store elemnt and index correspond to that element\\n        \\n        int i =0;\\n        while(i<nums.size())\\n        {\\n            if(mp.find(nums[i])!=mp.end())//element is already presnt in map \\n            {\\n                //check id abs(i-j)<=k or not\\n                if(abs(mp[nums[i]]-i)<=k)\\n                {\\n                    return true;\\n                }\\n            }\\n            //element is not present in arr -->push ele and its index\\n            \\n                mp[nums[i]]=i;\\n            i++;\\n        }\\n        \\n        return false;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        \\n        unordered_map<int,int> mp;//it will store elemnt and index correspond to that element\\n        \\n        int i =0;\\n        while(i<nums.size())\\n        {\\n            if(mp.find(nums[i])!=mp.end())//element is already presnt in map \\n            {\\n                //check id abs(i-j)<=k or not\\n                if(abs(mp[nums[i]]-i)<=k)\\n                {\\n                    return true;\\n                }\\n            }\\n            //element is not present in arr -->push ele and its index\\n            \\n                mp[nums[i]]=i;\\n            i++;\\n        }\\n        \\n        return false;\\n    }",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1568131,
                "content": [
                    {
                        "username": "x4snowman",
                        "content": "I am confused about this description."
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "Case 1:\\nnums = [1,2,3,1], k = 3\\nOutput: true\\n\\nDescription:\\nWe will pick only duplicate elements since nums[i] == nums[j]\\n\\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 3 so result is true\\n\\nCase 2:\\nnums = [1,2,3,1,2,3], k = 2\\nOutput: false\\n\\nDescription: \\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 2  is false condition\\n\\nIndex of first 2 is 1 and index of second 2 is 4\\nabs(1-4) <= 2 is false condition\\n\\nIndex of first 3 is 2 and index of second 3 is 5\\nabs(2-5) <= 2 is false condition\\nso overall result false\\n\\n"
                    },
                    {
                        "username": "D3press3dd",
                        "content": "[@Luna-martinez](/Luna-martinez) can you explain it? because i dont get it"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Yes description was a little confusing, but i get the statement."
                    },
                    {
                        "username": "DontSuCharlie",
                        "content": "Why not just say something along the lines of \"Find 2 numbers in the array that are equal and are at most `k` apart from each other.\"?"
                    },
                    {
                        "username": "enkil2003",
                        "content": "because monkeys write these statements."
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "haha, true :)"
                    },
                    {
                        "username": "NAS380",
                        "content": "thanks for that. now I could understand, question not clear"
                    },
                    {
                        "username": "kbventures",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) This is someone you don\\'t want to work with. "
                    },
                    {
                        "username": "jawaditani",
                        "content": "Actually that helped me understand the question, thank you."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being a condescending bitch in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "That\\'s what programming is all about, that\\'s what problem solving is all about, haven\\'t you saw math problems in school, we have to do the exact same stuff but they set the statement of problem such that it was not obvious to do that\\n"
                    },
                    {
                        "username": "zlgy126",
                        "content": "It feels like the question is super unclear."
                    },
                    {
                        "username": "Kaltu",
                        "content": "it\\'s funny while the description is unclear as fuck but if you literal translate what it says to code you get the correct solution"
                    },
                    {
                        "username": "Maheshkumar_2021",
                        "content": "agree"
                    },
                    {
                        "username": "sarocky",
                        "content": "agree"
                    },
                    {
                        "username": "ankithoney",
                        "content": "For this problem, the below test case is wrong:\\nnums = [99,99]\\nk = 2\\n\\nThe correct testcase should be nums = [99,99], k =1.\\n\\nBecause of it I am not able to submit my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "What kind of arcane implementations do you produce so that relation k to the size of the array matters? Doing loops inside loops? It can be solved in linear time with linear memory usage.\n114ms\nBeats 97.46%of users with C++\n76.73MB\nBeats 86.56%of users with C++\n\nAnd the function body is 9 lines long, it's an absolute STL-based no-brainer. I'll try an AMT-based solution just on general principle to beat the remaining 2.54% and 13.44%, respectively."
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@zabuli](/zabuli) Yaa even i missed that part lol\\uD83D\\uDE02"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Priyanshu_singh08](/Priyanshu_singh08)  the testcase isn\\'t wrong, you should read the description again..."
                    },
                    {
                        "username": "zabuli",
                        "content": "When you read the description, abs(i - j) <= k, so abs(0 - 1) == 1 => 1 <= 2 and also 1 <= 1, so for both cases it\\'s true."
                    },
                    {
                        "username": "Priyanshu_singh08",
                        "content": "same here , this test case is wrong"
                    },
                    {
                        "username": "marinospappas",
                        "content": "fully agree - wrong test cases... my code was also stuck in this one..."
                    },
                    {
                        "username": "naikv94",
                        "content": "same issue\\n"
                    },
                    {
                        "username": "Ajay019",
                        "content": "your whole logic becomes wrong at this test case\\n"
                    },
                    {
                        "username": "user5823Dt",
                        "content": "have the same issue"
                    },
                    {
                        "username": "malegkin",
                        "content": "BE CAREFUL!!! LESS OR EQUAL!!\\nabs(i - j) <= k"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@mrboombox](/mrboombox)  test case is not wrong, its just the window size is greater than the array size, which means you have to find duplicate elements in whole array, do apply a restriction such that you are not accessing element outside the array\\n"
                    },
                    {
                        "username": "mrboombox",
                        "content": "I have the same issue\\n"
                    },
                    {
                        "username": "dddxhh",
                        "content": "The testcases for this problem are too weak.\\n\\nIn my first AC solution, I wrote the code\\n\\n    if (n < k) return false;\\n\\n, where n is the length of the array.\\n\\nClearly, it is wrong(e.g. `nums = {2,2}, k = 3`).\\n\\n\\nI think the admin should do more serious test before a new problem coming online."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "In this example we can satisfy the given condition abs(i - j) <= k"
                    },
                    {
                        "username": "ShuoGuo89",
                        "content": "Could anyone tell me why the test case below is true?\\n\\n[1,0,1,1]\\n1\\n\\nThe largest difference should be 2 which is greater than k = 1. Isn't it?\\nMany thanks!"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "nums[2] == nums[3] also abs(3-2) <=1"
                    },
                    {
                        "username": "Mridul3217",
                        "content": "the question didn\\'t ask for largest difference. It said check if at any index i and j where nums[i] == nums[j] && abs(j-i)<=k. therefore index 2 and 3 fulfils this condition so it is true."
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Do not spam Answers in the Discussion Chat. Avoid it."
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "I\\'m getting TLE like this \\n\\nTime Limit Exceeded\\nLast Executed Input\\n54 / 54 testcases passed\\nnums =\\n\\n"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "same here who tf put that case. "
                    },
                    {
                        "username": "D3press3dd",
                        "content": "Why is this case false? [1,2,3,1,2,3], k = 2\\nthe number 3 is in position 2 and 5, that means Math.abs(2-5) === 3\\n3 >= this is false, so this does not fit the case and i have to return true\\n\\nam i confused?"
                    },
                    {
                        "username": "icancode96",
                        "content": "the result must be <= 2, while 3 > 2"
                    },
                    {
                        "username": "neil90",
                        "content": "Can anybody elaborate on what its asking for?"
                    },
                    {
                        "username": "anchurimanideep1",
                        "content": "[@jithinbp](/jithinbp) crystal clear"
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "[@jithinbp](/jithinbp) then what about testcase 2 , here input is [1,0,1,1] and k=1 .here one comes 0th index and 2nd index. so abs =|0-2| = 2 \\nwhich is not <=1 . so answer  must be false according to your explanation. but the real answer is true. can you clarify this for me .I am totally confused"
                    },
                    {
                        "username": "gautamgupta",
                        "content": "[@jithinbp](/jithinbp)  thats helpfull bro"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@sharforaz_rahman] Happy to hear that bro\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "[@jithinbp](/jithinbp)  Thank you brother, it\\'s indeed a great explanation "
                    },
                    {
                        "username": "jithinbp",
                        "content": "you have been given an integers array nums and an integer K.\\n\\nif you find any duplicate elements and the absolute difference between there indices gives you a value <= k then you can return true.\\n\\nif you couldn\\'t find such element you can return false.\\n\\neg:   nums[] = {4, 3, 1, 4}  k = 5       indices of 4 is : 0 , 3 \\nthe abs value of indices = |0 - 3| = 3 \\nwhich is <= k    so we can return true."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being an ass in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just find a window of size k+1 or less which contains duplicate elements, its as simple as it sound\\n"
                    }
                ]
            },
            {
                "id": 1569267,
                "content": [
                    {
                        "username": "x4snowman",
                        "content": "I am confused about this description."
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "Case 1:\\nnums = [1,2,3,1], k = 3\\nOutput: true\\n\\nDescription:\\nWe will pick only duplicate elements since nums[i] == nums[j]\\n\\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 3 so result is true\\n\\nCase 2:\\nnums = [1,2,3,1,2,3], k = 2\\nOutput: false\\n\\nDescription: \\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 2  is false condition\\n\\nIndex of first 2 is 1 and index of second 2 is 4\\nabs(1-4) <= 2 is false condition\\n\\nIndex of first 3 is 2 and index of second 3 is 5\\nabs(2-5) <= 2 is false condition\\nso overall result false\\n\\n"
                    },
                    {
                        "username": "D3press3dd",
                        "content": "[@Luna-martinez](/Luna-martinez) can you explain it? because i dont get it"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Yes description was a little confusing, but i get the statement."
                    },
                    {
                        "username": "DontSuCharlie",
                        "content": "Why not just say something along the lines of \"Find 2 numbers in the array that are equal and are at most `k` apart from each other.\"?"
                    },
                    {
                        "username": "enkil2003",
                        "content": "because monkeys write these statements."
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "haha, true :)"
                    },
                    {
                        "username": "NAS380",
                        "content": "thanks for that. now I could understand, question not clear"
                    },
                    {
                        "username": "kbventures",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) This is someone you don\\'t want to work with. "
                    },
                    {
                        "username": "jawaditani",
                        "content": "Actually that helped me understand the question, thank you."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being a condescending bitch in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "That\\'s what programming is all about, that\\'s what problem solving is all about, haven\\'t you saw math problems in school, we have to do the exact same stuff but they set the statement of problem such that it was not obvious to do that\\n"
                    },
                    {
                        "username": "zlgy126",
                        "content": "It feels like the question is super unclear."
                    },
                    {
                        "username": "Kaltu",
                        "content": "it\\'s funny while the description is unclear as fuck but if you literal translate what it says to code you get the correct solution"
                    },
                    {
                        "username": "Maheshkumar_2021",
                        "content": "agree"
                    },
                    {
                        "username": "sarocky",
                        "content": "agree"
                    },
                    {
                        "username": "ankithoney",
                        "content": "For this problem, the below test case is wrong:\\nnums = [99,99]\\nk = 2\\n\\nThe correct testcase should be nums = [99,99], k =1.\\n\\nBecause of it I am not able to submit my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "What kind of arcane implementations do you produce so that relation k to the size of the array matters? Doing loops inside loops? It can be solved in linear time with linear memory usage.\n114ms\nBeats 97.46%of users with C++\n76.73MB\nBeats 86.56%of users with C++\n\nAnd the function body is 9 lines long, it's an absolute STL-based no-brainer. I'll try an AMT-based solution just on general principle to beat the remaining 2.54% and 13.44%, respectively."
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@zabuli](/zabuli) Yaa even i missed that part lol\\uD83D\\uDE02"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Priyanshu_singh08](/Priyanshu_singh08)  the testcase isn\\'t wrong, you should read the description again..."
                    },
                    {
                        "username": "zabuli",
                        "content": "When you read the description, abs(i - j) <= k, so abs(0 - 1) == 1 => 1 <= 2 and also 1 <= 1, so for both cases it\\'s true."
                    },
                    {
                        "username": "Priyanshu_singh08",
                        "content": "same here , this test case is wrong"
                    },
                    {
                        "username": "marinospappas",
                        "content": "fully agree - wrong test cases... my code was also stuck in this one..."
                    },
                    {
                        "username": "naikv94",
                        "content": "same issue\\n"
                    },
                    {
                        "username": "Ajay019",
                        "content": "your whole logic becomes wrong at this test case\\n"
                    },
                    {
                        "username": "user5823Dt",
                        "content": "have the same issue"
                    },
                    {
                        "username": "malegkin",
                        "content": "BE CAREFUL!!! LESS OR EQUAL!!\\nabs(i - j) <= k"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@mrboombox](/mrboombox)  test case is not wrong, its just the window size is greater than the array size, which means you have to find duplicate elements in whole array, do apply a restriction such that you are not accessing element outside the array\\n"
                    },
                    {
                        "username": "mrboombox",
                        "content": "I have the same issue\\n"
                    },
                    {
                        "username": "dddxhh",
                        "content": "The testcases for this problem are too weak.\\n\\nIn my first AC solution, I wrote the code\\n\\n    if (n < k) return false;\\n\\n, where n is the length of the array.\\n\\nClearly, it is wrong(e.g. `nums = {2,2}, k = 3`).\\n\\n\\nI think the admin should do more serious test before a new problem coming online."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "In this example we can satisfy the given condition abs(i - j) <= k"
                    },
                    {
                        "username": "ShuoGuo89",
                        "content": "Could anyone tell me why the test case below is true?\\n\\n[1,0,1,1]\\n1\\n\\nThe largest difference should be 2 which is greater than k = 1. Isn't it?\\nMany thanks!"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "nums[2] == nums[3] also abs(3-2) <=1"
                    },
                    {
                        "username": "Mridul3217",
                        "content": "the question didn\\'t ask for largest difference. It said check if at any index i and j where nums[i] == nums[j] && abs(j-i)<=k. therefore index 2 and 3 fulfils this condition so it is true."
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Do not spam Answers in the Discussion Chat. Avoid it."
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "I\\'m getting TLE like this \\n\\nTime Limit Exceeded\\nLast Executed Input\\n54 / 54 testcases passed\\nnums =\\n\\n"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "same here who tf put that case. "
                    },
                    {
                        "username": "D3press3dd",
                        "content": "Why is this case false? [1,2,3,1,2,3], k = 2\\nthe number 3 is in position 2 and 5, that means Math.abs(2-5) === 3\\n3 >= this is false, so this does not fit the case and i have to return true\\n\\nam i confused?"
                    },
                    {
                        "username": "icancode96",
                        "content": "the result must be <= 2, while 3 > 2"
                    },
                    {
                        "username": "neil90",
                        "content": "Can anybody elaborate on what its asking for?"
                    },
                    {
                        "username": "anchurimanideep1",
                        "content": "[@jithinbp](/jithinbp) crystal clear"
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "[@jithinbp](/jithinbp) then what about testcase 2 , here input is [1,0,1,1] and k=1 .here one comes 0th index and 2nd index. so abs =|0-2| = 2 \\nwhich is not <=1 . so answer  must be false according to your explanation. but the real answer is true. can you clarify this for me .I am totally confused"
                    },
                    {
                        "username": "gautamgupta",
                        "content": "[@jithinbp](/jithinbp)  thats helpfull bro"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@sharforaz_rahman] Happy to hear that bro\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "[@jithinbp](/jithinbp)  Thank you brother, it\\'s indeed a great explanation "
                    },
                    {
                        "username": "jithinbp",
                        "content": "you have been given an integers array nums and an integer K.\\n\\nif you find any duplicate elements and the absolute difference between there indices gives you a value <= k then you can return true.\\n\\nif you couldn\\'t find such element you can return false.\\n\\neg:   nums[] = {4, 3, 1, 4}  k = 5       indices of 4 is : 0 , 3 \\nthe abs value of indices = |0 - 3| = 3 \\nwhich is <= k    so we can return true."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being an ass in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just find a window of size k+1 or less which contains duplicate elements, its as simple as it sound\\n"
                    }
                ]
            },
            {
                "id": 1574332,
                "content": [
                    {
                        "username": "x4snowman",
                        "content": "I am confused about this description."
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "Case 1:\\nnums = [1,2,3,1], k = 3\\nOutput: true\\n\\nDescription:\\nWe will pick only duplicate elements since nums[i] == nums[j]\\n\\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 3 so result is true\\n\\nCase 2:\\nnums = [1,2,3,1,2,3], k = 2\\nOutput: false\\n\\nDescription: \\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 2  is false condition\\n\\nIndex of first 2 is 1 and index of second 2 is 4\\nabs(1-4) <= 2 is false condition\\n\\nIndex of first 3 is 2 and index of second 3 is 5\\nabs(2-5) <= 2 is false condition\\nso overall result false\\n\\n"
                    },
                    {
                        "username": "D3press3dd",
                        "content": "[@Luna-martinez](/Luna-martinez) can you explain it? because i dont get it"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Yes description was a little confusing, but i get the statement."
                    },
                    {
                        "username": "DontSuCharlie",
                        "content": "Why not just say something along the lines of \"Find 2 numbers in the array that are equal and are at most `k` apart from each other.\"?"
                    },
                    {
                        "username": "enkil2003",
                        "content": "because monkeys write these statements."
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "haha, true :)"
                    },
                    {
                        "username": "NAS380",
                        "content": "thanks for that. now I could understand, question not clear"
                    },
                    {
                        "username": "kbventures",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) This is someone you don\\'t want to work with. "
                    },
                    {
                        "username": "jawaditani",
                        "content": "Actually that helped me understand the question, thank you."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being a condescending bitch in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "That\\'s what programming is all about, that\\'s what problem solving is all about, haven\\'t you saw math problems in school, we have to do the exact same stuff but they set the statement of problem such that it was not obvious to do that\\n"
                    },
                    {
                        "username": "zlgy126",
                        "content": "It feels like the question is super unclear."
                    },
                    {
                        "username": "Kaltu",
                        "content": "it\\'s funny while the description is unclear as fuck but if you literal translate what it says to code you get the correct solution"
                    },
                    {
                        "username": "Maheshkumar_2021",
                        "content": "agree"
                    },
                    {
                        "username": "sarocky",
                        "content": "agree"
                    },
                    {
                        "username": "ankithoney",
                        "content": "For this problem, the below test case is wrong:\\nnums = [99,99]\\nk = 2\\n\\nThe correct testcase should be nums = [99,99], k =1.\\n\\nBecause of it I am not able to submit my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "What kind of arcane implementations do you produce so that relation k to the size of the array matters? Doing loops inside loops? It can be solved in linear time with linear memory usage.\n114ms\nBeats 97.46%of users with C++\n76.73MB\nBeats 86.56%of users with C++\n\nAnd the function body is 9 lines long, it's an absolute STL-based no-brainer. I'll try an AMT-based solution just on general principle to beat the remaining 2.54% and 13.44%, respectively."
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@zabuli](/zabuli) Yaa even i missed that part lol\\uD83D\\uDE02"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Priyanshu_singh08](/Priyanshu_singh08)  the testcase isn\\'t wrong, you should read the description again..."
                    },
                    {
                        "username": "zabuli",
                        "content": "When you read the description, abs(i - j) <= k, so abs(0 - 1) == 1 => 1 <= 2 and also 1 <= 1, so for both cases it\\'s true."
                    },
                    {
                        "username": "Priyanshu_singh08",
                        "content": "same here , this test case is wrong"
                    },
                    {
                        "username": "marinospappas",
                        "content": "fully agree - wrong test cases... my code was also stuck in this one..."
                    },
                    {
                        "username": "naikv94",
                        "content": "same issue\\n"
                    },
                    {
                        "username": "Ajay019",
                        "content": "your whole logic becomes wrong at this test case\\n"
                    },
                    {
                        "username": "user5823Dt",
                        "content": "have the same issue"
                    },
                    {
                        "username": "malegkin",
                        "content": "BE CAREFUL!!! LESS OR EQUAL!!\\nabs(i - j) <= k"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@mrboombox](/mrboombox)  test case is not wrong, its just the window size is greater than the array size, which means you have to find duplicate elements in whole array, do apply a restriction such that you are not accessing element outside the array\\n"
                    },
                    {
                        "username": "mrboombox",
                        "content": "I have the same issue\\n"
                    },
                    {
                        "username": "dddxhh",
                        "content": "The testcases for this problem are too weak.\\n\\nIn my first AC solution, I wrote the code\\n\\n    if (n < k) return false;\\n\\n, where n is the length of the array.\\n\\nClearly, it is wrong(e.g. `nums = {2,2}, k = 3`).\\n\\n\\nI think the admin should do more serious test before a new problem coming online."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "In this example we can satisfy the given condition abs(i - j) <= k"
                    },
                    {
                        "username": "ShuoGuo89",
                        "content": "Could anyone tell me why the test case below is true?\\n\\n[1,0,1,1]\\n1\\n\\nThe largest difference should be 2 which is greater than k = 1. Isn't it?\\nMany thanks!"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "nums[2] == nums[3] also abs(3-2) <=1"
                    },
                    {
                        "username": "Mridul3217",
                        "content": "the question didn\\'t ask for largest difference. It said check if at any index i and j where nums[i] == nums[j] && abs(j-i)<=k. therefore index 2 and 3 fulfils this condition so it is true."
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Do not spam Answers in the Discussion Chat. Avoid it."
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "I\\'m getting TLE like this \\n\\nTime Limit Exceeded\\nLast Executed Input\\n54 / 54 testcases passed\\nnums =\\n\\n"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "same here who tf put that case. "
                    },
                    {
                        "username": "D3press3dd",
                        "content": "Why is this case false? [1,2,3,1,2,3], k = 2\\nthe number 3 is in position 2 and 5, that means Math.abs(2-5) === 3\\n3 >= this is false, so this does not fit the case and i have to return true\\n\\nam i confused?"
                    },
                    {
                        "username": "icancode96",
                        "content": "the result must be <= 2, while 3 > 2"
                    },
                    {
                        "username": "neil90",
                        "content": "Can anybody elaborate on what its asking for?"
                    },
                    {
                        "username": "anchurimanideep1",
                        "content": "[@jithinbp](/jithinbp) crystal clear"
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "[@jithinbp](/jithinbp) then what about testcase 2 , here input is [1,0,1,1] and k=1 .here one comes 0th index and 2nd index. so abs =|0-2| = 2 \\nwhich is not <=1 . so answer  must be false according to your explanation. but the real answer is true. can you clarify this for me .I am totally confused"
                    },
                    {
                        "username": "gautamgupta",
                        "content": "[@jithinbp](/jithinbp)  thats helpfull bro"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@sharforaz_rahman] Happy to hear that bro\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "[@jithinbp](/jithinbp)  Thank you brother, it\\'s indeed a great explanation "
                    },
                    {
                        "username": "jithinbp",
                        "content": "you have been given an integers array nums and an integer K.\\n\\nif you find any duplicate elements and the absolute difference between there indices gives you a value <= k then you can return true.\\n\\nif you couldn\\'t find such element you can return false.\\n\\neg:   nums[] = {4, 3, 1, 4}  k = 5       indices of 4 is : 0 , 3 \\nthe abs value of indices = |0 - 3| = 3 \\nwhich is <= k    so we can return true."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being an ass in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just find a window of size k+1 or less which contains duplicate elements, its as simple as it sound\\n"
                    }
                ]
            },
            {
                "id": 1569369,
                "content": [
                    {
                        "username": "x4snowman",
                        "content": "I am confused about this description."
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "Case 1:\\nnums = [1,2,3,1], k = 3\\nOutput: true\\n\\nDescription:\\nWe will pick only duplicate elements since nums[i] == nums[j]\\n\\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 3 so result is true\\n\\nCase 2:\\nnums = [1,2,3,1,2,3], k = 2\\nOutput: false\\n\\nDescription: \\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 2  is false condition\\n\\nIndex of first 2 is 1 and index of second 2 is 4\\nabs(1-4) <= 2 is false condition\\n\\nIndex of first 3 is 2 and index of second 3 is 5\\nabs(2-5) <= 2 is false condition\\nso overall result false\\n\\n"
                    },
                    {
                        "username": "D3press3dd",
                        "content": "[@Luna-martinez](/Luna-martinez) can you explain it? because i dont get it"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Yes description was a little confusing, but i get the statement."
                    },
                    {
                        "username": "DontSuCharlie",
                        "content": "Why not just say something along the lines of \"Find 2 numbers in the array that are equal and are at most `k` apart from each other.\"?"
                    },
                    {
                        "username": "enkil2003",
                        "content": "because monkeys write these statements."
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "haha, true :)"
                    },
                    {
                        "username": "NAS380",
                        "content": "thanks for that. now I could understand, question not clear"
                    },
                    {
                        "username": "kbventures",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) This is someone you don\\'t want to work with. "
                    },
                    {
                        "username": "jawaditani",
                        "content": "Actually that helped me understand the question, thank you."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being a condescending bitch in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "That\\'s what programming is all about, that\\'s what problem solving is all about, haven\\'t you saw math problems in school, we have to do the exact same stuff but they set the statement of problem such that it was not obvious to do that\\n"
                    },
                    {
                        "username": "zlgy126",
                        "content": "It feels like the question is super unclear."
                    },
                    {
                        "username": "Kaltu",
                        "content": "it\\'s funny while the description is unclear as fuck but if you literal translate what it says to code you get the correct solution"
                    },
                    {
                        "username": "Maheshkumar_2021",
                        "content": "agree"
                    },
                    {
                        "username": "sarocky",
                        "content": "agree"
                    },
                    {
                        "username": "ankithoney",
                        "content": "For this problem, the below test case is wrong:\\nnums = [99,99]\\nk = 2\\n\\nThe correct testcase should be nums = [99,99], k =1.\\n\\nBecause of it I am not able to submit my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "What kind of arcane implementations do you produce so that relation k to the size of the array matters? Doing loops inside loops? It can be solved in linear time with linear memory usage.\n114ms\nBeats 97.46%of users with C++\n76.73MB\nBeats 86.56%of users with C++\n\nAnd the function body is 9 lines long, it's an absolute STL-based no-brainer. I'll try an AMT-based solution just on general principle to beat the remaining 2.54% and 13.44%, respectively."
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@zabuli](/zabuli) Yaa even i missed that part lol\\uD83D\\uDE02"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Priyanshu_singh08](/Priyanshu_singh08)  the testcase isn\\'t wrong, you should read the description again..."
                    },
                    {
                        "username": "zabuli",
                        "content": "When you read the description, abs(i - j) <= k, so abs(0 - 1) == 1 => 1 <= 2 and also 1 <= 1, so for both cases it\\'s true."
                    },
                    {
                        "username": "Priyanshu_singh08",
                        "content": "same here , this test case is wrong"
                    },
                    {
                        "username": "marinospappas",
                        "content": "fully agree - wrong test cases... my code was also stuck in this one..."
                    },
                    {
                        "username": "naikv94",
                        "content": "same issue\\n"
                    },
                    {
                        "username": "Ajay019",
                        "content": "your whole logic becomes wrong at this test case\\n"
                    },
                    {
                        "username": "user5823Dt",
                        "content": "have the same issue"
                    },
                    {
                        "username": "malegkin",
                        "content": "BE CAREFUL!!! LESS OR EQUAL!!\\nabs(i - j) <= k"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@mrboombox](/mrboombox)  test case is not wrong, its just the window size is greater than the array size, which means you have to find duplicate elements in whole array, do apply a restriction such that you are not accessing element outside the array\\n"
                    },
                    {
                        "username": "mrboombox",
                        "content": "I have the same issue\\n"
                    },
                    {
                        "username": "dddxhh",
                        "content": "The testcases for this problem are too weak.\\n\\nIn my first AC solution, I wrote the code\\n\\n    if (n < k) return false;\\n\\n, where n is the length of the array.\\n\\nClearly, it is wrong(e.g. `nums = {2,2}, k = 3`).\\n\\n\\nI think the admin should do more serious test before a new problem coming online."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "In this example we can satisfy the given condition abs(i - j) <= k"
                    },
                    {
                        "username": "ShuoGuo89",
                        "content": "Could anyone tell me why the test case below is true?\\n\\n[1,0,1,1]\\n1\\n\\nThe largest difference should be 2 which is greater than k = 1. Isn't it?\\nMany thanks!"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "nums[2] == nums[3] also abs(3-2) <=1"
                    },
                    {
                        "username": "Mridul3217",
                        "content": "the question didn\\'t ask for largest difference. It said check if at any index i and j where nums[i] == nums[j] && abs(j-i)<=k. therefore index 2 and 3 fulfils this condition so it is true."
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Do not spam Answers in the Discussion Chat. Avoid it."
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "I\\'m getting TLE like this \\n\\nTime Limit Exceeded\\nLast Executed Input\\n54 / 54 testcases passed\\nnums =\\n\\n"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "same here who tf put that case. "
                    },
                    {
                        "username": "D3press3dd",
                        "content": "Why is this case false? [1,2,3,1,2,3], k = 2\\nthe number 3 is in position 2 and 5, that means Math.abs(2-5) === 3\\n3 >= this is false, so this does not fit the case and i have to return true\\n\\nam i confused?"
                    },
                    {
                        "username": "icancode96",
                        "content": "the result must be <= 2, while 3 > 2"
                    },
                    {
                        "username": "neil90",
                        "content": "Can anybody elaborate on what its asking for?"
                    },
                    {
                        "username": "anchurimanideep1",
                        "content": "[@jithinbp](/jithinbp) crystal clear"
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "[@jithinbp](/jithinbp) then what about testcase 2 , here input is [1,0,1,1] and k=1 .here one comes 0th index and 2nd index. so abs =|0-2| = 2 \\nwhich is not <=1 . so answer  must be false according to your explanation. but the real answer is true. can you clarify this for me .I am totally confused"
                    },
                    {
                        "username": "gautamgupta",
                        "content": "[@jithinbp](/jithinbp)  thats helpfull bro"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@sharforaz_rahman] Happy to hear that bro\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "[@jithinbp](/jithinbp)  Thank you brother, it\\'s indeed a great explanation "
                    },
                    {
                        "username": "jithinbp",
                        "content": "you have been given an integers array nums and an integer K.\\n\\nif you find any duplicate elements and the absolute difference between there indices gives you a value <= k then you can return true.\\n\\nif you couldn\\'t find such element you can return false.\\n\\neg:   nums[] = {4, 3, 1, 4}  k = 5       indices of 4 is : 0 , 3 \\nthe abs value of indices = |0 - 3| = 3 \\nwhich is <= k    so we can return true."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being an ass in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just find a window of size k+1 or less which contains duplicate elements, its as simple as it sound\\n"
                    }
                ]
            },
            {
                "id": 1565317,
                "content": [
                    {
                        "username": "x4snowman",
                        "content": "I am confused about this description."
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "Case 1:\\nnums = [1,2,3,1], k = 3\\nOutput: true\\n\\nDescription:\\nWe will pick only duplicate elements since nums[i] == nums[j]\\n\\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 3 so result is true\\n\\nCase 2:\\nnums = [1,2,3,1,2,3], k = 2\\nOutput: false\\n\\nDescription: \\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 2  is false condition\\n\\nIndex of first 2 is 1 and index of second 2 is 4\\nabs(1-4) <= 2 is false condition\\n\\nIndex of first 3 is 2 and index of second 3 is 5\\nabs(2-5) <= 2 is false condition\\nso overall result false\\n\\n"
                    },
                    {
                        "username": "D3press3dd",
                        "content": "[@Luna-martinez](/Luna-martinez) can you explain it? because i dont get it"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Yes description was a little confusing, but i get the statement."
                    },
                    {
                        "username": "DontSuCharlie",
                        "content": "Why not just say something along the lines of \"Find 2 numbers in the array that are equal and are at most `k` apart from each other.\"?"
                    },
                    {
                        "username": "enkil2003",
                        "content": "because monkeys write these statements."
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "haha, true :)"
                    },
                    {
                        "username": "NAS380",
                        "content": "thanks for that. now I could understand, question not clear"
                    },
                    {
                        "username": "kbventures",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) This is someone you don\\'t want to work with. "
                    },
                    {
                        "username": "jawaditani",
                        "content": "Actually that helped me understand the question, thank you."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being a condescending bitch in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "That\\'s what programming is all about, that\\'s what problem solving is all about, haven\\'t you saw math problems in school, we have to do the exact same stuff but they set the statement of problem such that it was not obvious to do that\\n"
                    },
                    {
                        "username": "zlgy126",
                        "content": "It feels like the question is super unclear."
                    },
                    {
                        "username": "Kaltu",
                        "content": "it\\'s funny while the description is unclear as fuck but if you literal translate what it says to code you get the correct solution"
                    },
                    {
                        "username": "Maheshkumar_2021",
                        "content": "agree"
                    },
                    {
                        "username": "sarocky",
                        "content": "agree"
                    },
                    {
                        "username": "ankithoney",
                        "content": "For this problem, the below test case is wrong:\\nnums = [99,99]\\nk = 2\\n\\nThe correct testcase should be nums = [99,99], k =1.\\n\\nBecause of it I am not able to submit my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "What kind of arcane implementations do you produce so that relation k to the size of the array matters? Doing loops inside loops? It can be solved in linear time with linear memory usage.\n114ms\nBeats 97.46%of users with C++\n76.73MB\nBeats 86.56%of users with C++\n\nAnd the function body is 9 lines long, it's an absolute STL-based no-brainer. I'll try an AMT-based solution just on general principle to beat the remaining 2.54% and 13.44%, respectively."
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@zabuli](/zabuli) Yaa even i missed that part lol\\uD83D\\uDE02"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Priyanshu_singh08](/Priyanshu_singh08)  the testcase isn\\'t wrong, you should read the description again..."
                    },
                    {
                        "username": "zabuli",
                        "content": "When you read the description, abs(i - j) <= k, so abs(0 - 1) == 1 => 1 <= 2 and also 1 <= 1, so for both cases it\\'s true."
                    },
                    {
                        "username": "Priyanshu_singh08",
                        "content": "same here , this test case is wrong"
                    },
                    {
                        "username": "marinospappas",
                        "content": "fully agree - wrong test cases... my code was also stuck in this one..."
                    },
                    {
                        "username": "naikv94",
                        "content": "same issue\\n"
                    },
                    {
                        "username": "Ajay019",
                        "content": "your whole logic becomes wrong at this test case\\n"
                    },
                    {
                        "username": "user5823Dt",
                        "content": "have the same issue"
                    },
                    {
                        "username": "malegkin",
                        "content": "BE CAREFUL!!! LESS OR EQUAL!!\\nabs(i - j) <= k"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@mrboombox](/mrboombox)  test case is not wrong, its just the window size is greater than the array size, which means you have to find duplicate elements in whole array, do apply a restriction such that you are not accessing element outside the array\\n"
                    },
                    {
                        "username": "mrboombox",
                        "content": "I have the same issue\\n"
                    },
                    {
                        "username": "dddxhh",
                        "content": "The testcases for this problem are too weak.\\n\\nIn my first AC solution, I wrote the code\\n\\n    if (n < k) return false;\\n\\n, where n is the length of the array.\\n\\nClearly, it is wrong(e.g. `nums = {2,2}, k = 3`).\\n\\n\\nI think the admin should do more serious test before a new problem coming online."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "In this example we can satisfy the given condition abs(i - j) <= k"
                    },
                    {
                        "username": "ShuoGuo89",
                        "content": "Could anyone tell me why the test case below is true?\\n\\n[1,0,1,1]\\n1\\n\\nThe largest difference should be 2 which is greater than k = 1. Isn't it?\\nMany thanks!"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "nums[2] == nums[3] also abs(3-2) <=1"
                    },
                    {
                        "username": "Mridul3217",
                        "content": "the question didn\\'t ask for largest difference. It said check if at any index i and j where nums[i] == nums[j] && abs(j-i)<=k. therefore index 2 and 3 fulfils this condition so it is true."
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Do not spam Answers in the Discussion Chat. Avoid it."
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "I\\'m getting TLE like this \\n\\nTime Limit Exceeded\\nLast Executed Input\\n54 / 54 testcases passed\\nnums =\\n\\n"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "same here who tf put that case. "
                    },
                    {
                        "username": "D3press3dd",
                        "content": "Why is this case false? [1,2,3,1,2,3], k = 2\\nthe number 3 is in position 2 and 5, that means Math.abs(2-5) === 3\\n3 >= this is false, so this does not fit the case and i have to return true\\n\\nam i confused?"
                    },
                    {
                        "username": "icancode96",
                        "content": "the result must be <= 2, while 3 > 2"
                    },
                    {
                        "username": "neil90",
                        "content": "Can anybody elaborate on what its asking for?"
                    },
                    {
                        "username": "anchurimanideep1",
                        "content": "[@jithinbp](/jithinbp) crystal clear"
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "[@jithinbp](/jithinbp) then what about testcase 2 , here input is [1,0,1,1] and k=1 .here one comes 0th index and 2nd index. so abs =|0-2| = 2 \\nwhich is not <=1 . so answer  must be false according to your explanation. but the real answer is true. can you clarify this for me .I am totally confused"
                    },
                    {
                        "username": "gautamgupta",
                        "content": "[@jithinbp](/jithinbp)  thats helpfull bro"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@sharforaz_rahman] Happy to hear that bro\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "[@jithinbp](/jithinbp)  Thank you brother, it\\'s indeed a great explanation "
                    },
                    {
                        "username": "jithinbp",
                        "content": "you have been given an integers array nums and an integer K.\\n\\nif you find any duplicate elements and the absolute difference between there indices gives you a value <= k then you can return true.\\n\\nif you couldn\\'t find such element you can return false.\\n\\neg:   nums[] = {4, 3, 1, 4}  k = 5       indices of 4 is : 0 , 3 \\nthe abs value of indices = |0 - 3| = 3 \\nwhich is <= k    so we can return true."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being an ass in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just find a window of size k+1 or less which contains duplicate elements, its as simple as it sound\\n"
                    }
                ]
            },
            {
                "id": 1569029,
                "content": [
                    {
                        "username": "x4snowman",
                        "content": "I am confused about this description."
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "Case 1:\\nnums = [1,2,3,1], k = 3\\nOutput: true\\n\\nDescription:\\nWe will pick only duplicate elements since nums[i] == nums[j]\\n\\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 3 so result is true\\n\\nCase 2:\\nnums = [1,2,3,1,2,3], k = 2\\nOutput: false\\n\\nDescription: \\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 2  is false condition\\n\\nIndex of first 2 is 1 and index of second 2 is 4\\nabs(1-4) <= 2 is false condition\\n\\nIndex of first 3 is 2 and index of second 3 is 5\\nabs(2-5) <= 2 is false condition\\nso overall result false\\n\\n"
                    },
                    {
                        "username": "D3press3dd",
                        "content": "[@Luna-martinez](/Luna-martinez) can you explain it? because i dont get it"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Yes description was a little confusing, but i get the statement."
                    },
                    {
                        "username": "DontSuCharlie",
                        "content": "Why not just say something along the lines of \"Find 2 numbers in the array that are equal and are at most `k` apart from each other.\"?"
                    },
                    {
                        "username": "enkil2003",
                        "content": "because monkeys write these statements."
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "haha, true :)"
                    },
                    {
                        "username": "NAS380",
                        "content": "thanks for that. now I could understand, question not clear"
                    },
                    {
                        "username": "kbventures",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) This is someone you don\\'t want to work with. "
                    },
                    {
                        "username": "jawaditani",
                        "content": "Actually that helped me understand the question, thank you."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being a condescending bitch in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "That\\'s what programming is all about, that\\'s what problem solving is all about, haven\\'t you saw math problems in school, we have to do the exact same stuff but they set the statement of problem such that it was not obvious to do that\\n"
                    },
                    {
                        "username": "zlgy126",
                        "content": "It feels like the question is super unclear."
                    },
                    {
                        "username": "Kaltu",
                        "content": "it\\'s funny while the description is unclear as fuck but if you literal translate what it says to code you get the correct solution"
                    },
                    {
                        "username": "Maheshkumar_2021",
                        "content": "agree"
                    },
                    {
                        "username": "sarocky",
                        "content": "agree"
                    },
                    {
                        "username": "ankithoney",
                        "content": "For this problem, the below test case is wrong:\\nnums = [99,99]\\nk = 2\\n\\nThe correct testcase should be nums = [99,99], k =1.\\n\\nBecause of it I am not able to submit my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "What kind of arcane implementations do you produce so that relation k to the size of the array matters? Doing loops inside loops? It can be solved in linear time with linear memory usage.\n114ms\nBeats 97.46%of users with C++\n76.73MB\nBeats 86.56%of users with C++\n\nAnd the function body is 9 lines long, it's an absolute STL-based no-brainer. I'll try an AMT-based solution just on general principle to beat the remaining 2.54% and 13.44%, respectively."
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@zabuli](/zabuli) Yaa even i missed that part lol\\uD83D\\uDE02"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Priyanshu_singh08](/Priyanshu_singh08)  the testcase isn\\'t wrong, you should read the description again..."
                    },
                    {
                        "username": "zabuli",
                        "content": "When you read the description, abs(i - j) <= k, so abs(0 - 1) == 1 => 1 <= 2 and also 1 <= 1, so for both cases it\\'s true."
                    },
                    {
                        "username": "Priyanshu_singh08",
                        "content": "same here , this test case is wrong"
                    },
                    {
                        "username": "marinospappas",
                        "content": "fully agree - wrong test cases... my code was also stuck in this one..."
                    },
                    {
                        "username": "naikv94",
                        "content": "same issue\\n"
                    },
                    {
                        "username": "Ajay019",
                        "content": "your whole logic becomes wrong at this test case\\n"
                    },
                    {
                        "username": "user5823Dt",
                        "content": "have the same issue"
                    },
                    {
                        "username": "malegkin",
                        "content": "BE CAREFUL!!! LESS OR EQUAL!!\\nabs(i - j) <= k"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@mrboombox](/mrboombox)  test case is not wrong, its just the window size is greater than the array size, which means you have to find duplicate elements in whole array, do apply a restriction such that you are not accessing element outside the array\\n"
                    },
                    {
                        "username": "mrboombox",
                        "content": "I have the same issue\\n"
                    },
                    {
                        "username": "dddxhh",
                        "content": "The testcases for this problem are too weak.\\n\\nIn my first AC solution, I wrote the code\\n\\n    if (n < k) return false;\\n\\n, where n is the length of the array.\\n\\nClearly, it is wrong(e.g. `nums = {2,2}, k = 3`).\\n\\n\\nI think the admin should do more serious test before a new problem coming online."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "In this example we can satisfy the given condition abs(i - j) <= k"
                    },
                    {
                        "username": "ShuoGuo89",
                        "content": "Could anyone tell me why the test case below is true?\\n\\n[1,0,1,1]\\n1\\n\\nThe largest difference should be 2 which is greater than k = 1. Isn't it?\\nMany thanks!"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "nums[2] == nums[3] also abs(3-2) <=1"
                    },
                    {
                        "username": "Mridul3217",
                        "content": "the question didn\\'t ask for largest difference. It said check if at any index i and j where nums[i] == nums[j] && abs(j-i)<=k. therefore index 2 and 3 fulfils this condition so it is true."
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Do not spam Answers in the Discussion Chat. Avoid it."
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "I\\'m getting TLE like this \\n\\nTime Limit Exceeded\\nLast Executed Input\\n54 / 54 testcases passed\\nnums =\\n\\n"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "same here who tf put that case. "
                    },
                    {
                        "username": "D3press3dd",
                        "content": "Why is this case false? [1,2,3,1,2,3], k = 2\\nthe number 3 is in position 2 and 5, that means Math.abs(2-5) === 3\\n3 >= this is false, so this does not fit the case and i have to return true\\n\\nam i confused?"
                    },
                    {
                        "username": "icancode96",
                        "content": "the result must be <= 2, while 3 > 2"
                    },
                    {
                        "username": "neil90",
                        "content": "Can anybody elaborate on what its asking for?"
                    },
                    {
                        "username": "anchurimanideep1",
                        "content": "[@jithinbp](/jithinbp) crystal clear"
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "[@jithinbp](/jithinbp) then what about testcase 2 , here input is [1,0,1,1] and k=1 .here one comes 0th index and 2nd index. so abs =|0-2| = 2 \\nwhich is not <=1 . so answer  must be false according to your explanation. but the real answer is true. can you clarify this for me .I am totally confused"
                    },
                    {
                        "username": "gautamgupta",
                        "content": "[@jithinbp](/jithinbp)  thats helpfull bro"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@sharforaz_rahman] Happy to hear that bro\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "[@jithinbp](/jithinbp)  Thank you brother, it\\'s indeed a great explanation "
                    },
                    {
                        "username": "jithinbp",
                        "content": "you have been given an integers array nums and an integer K.\\n\\nif you find any duplicate elements and the absolute difference between there indices gives you a value <= k then you can return true.\\n\\nif you couldn\\'t find such element you can return false.\\n\\neg:   nums[] = {4, 3, 1, 4}  k = 5       indices of 4 is : 0 , 3 \\nthe abs value of indices = |0 - 3| = 3 \\nwhich is <= k    so we can return true."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being an ass in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just find a window of size k+1 or less which contains duplicate elements, its as simple as it sound\\n"
                    }
                ]
            },
            {
                "id": 1699173,
                "content": [
                    {
                        "username": "x4snowman",
                        "content": "I am confused about this description."
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "Case 1:\\nnums = [1,2,3,1], k = 3\\nOutput: true\\n\\nDescription:\\nWe will pick only duplicate elements since nums[i] == nums[j]\\n\\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 3 so result is true\\n\\nCase 2:\\nnums = [1,2,3,1,2,3], k = 2\\nOutput: false\\n\\nDescription: \\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 2  is false condition\\n\\nIndex of first 2 is 1 and index of second 2 is 4\\nabs(1-4) <= 2 is false condition\\n\\nIndex of first 3 is 2 and index of second 3 is 5\\nabs(2-5) <= 2 is false condition\\nso overall result false\\n\\n"
                    },
                    {
                        "username": "D3press3dd",
                        "content": "[@Luna-martinez](/Luna-martinez) can you explain it? because i dont get it"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Yes description was a little confusing, but i get the statement."
                    },
                    {
                        "username": "DontSuCharlie",
                        "content": "Why not just say something along the lines of \"Find 2 numbers in the array that are equal and are at most `k` apart from each other.\"?"
                    },
                    {
                        "username": "enkil2003",
                        "content": "because monkeys write these statements."
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "haha, true :)"
                    },
                    {
                        "username": "NAS380",
                        "content": "thanks for that. now I could understand, question not clear"
                    },
                    {
                        "username": "kbventures",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) This is someone you don\\'t want to work with. "
                    },
                    {
                        "username": "jawaditani",
                        "content": "Actually that helped me understand the question, thank you."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being a condescending bitch in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "That\\'s what programming is all about, that\\'s what problem solving is all about, haven\\'t you saw math problems in school, we have to do the exact same stuff but they set the statement of problem such that it was not obvious to do that\\n"
                    },
                    {
                        "username": "zlgy126",
                        "content": "It feels like the question is super unclear."
                    },
                    {
                        "username": "Kaltu",
                        "content": "it\\'s funny while the description is unclear as fuck but if you literal translate what it says to code you get the correct solution"
                    },
                    {
                        "username": "Maheshkumar_2021",
                        "content": "agree"
                    },
                    {
                        "username": "sarocky",
                        "content": "agree"
                    },
                    {
                        "username": "ankithoney",
                        "content": "For this problem, the below test case is wrong:\\nnums = [99,99]\\nk = 2\\n\\nThe correct testcase should be nums = [99,99], k =1.\\n\\nBecause of it I am not able to submit my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "What kind of arcane implementations do you produce so that relation k to the size of the array matters? Doing loops inside loops? It can be solved in linear time with linear memory usage.\n114ms\nBeats 97.46%of users with C++\n76.73MB\nBeats 86.56%of users with C++\n\nAnd the function body is 9 lines long, it's an absolute STL-based no-brainer. I'll try an AMT-based solution just on general principle to beat the remaining 2.54% and 13.44%, respectively."
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@zabuli](/zabuli) Yaa even i missed that part lol\\uD83D\\uDE02"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Priyanshu_singh08](/Priyanshu_singh08)  the testcase isn\\'t wrong, you should read the description again..."
                    },
                    {
                        "username": "zabuli",
                        "content": "When you read the description, abs(i - j) <= k, so abs(0 - 1) == 1 => 1 <= 2 and also 1 <= 1, so for both cases it\\'s true."
                    },
                    {
                        "username": "Priyanshu_singh08",
                        "content": "same here , this test case is wrong"
                    },
                    {
                        "username": "marinospappas",
                        "content": "fully agree - wrong test cases... my code was also stuck in this one..."
                    },
                    {
                        "username": "naikv94",
                        "content": "same issue\\n"
                    },
                    {
                        "username": "Ajay019",
                        "content": "your whole logic becomes wrong at this test case\\n"
                    },
                    {
                        "username": "user5823Dt",
                        "content": "have the same issue"
                    },
                    {
                        "username": "malegkin",
                        "content": "BE CAREFUL!!! LESS OR EQUAL!!\\nabs(i - j) <= k"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@mrboombox](/mrboombox)  test case is not wrong, its just the window size is greater than the array size, which means you have to find duplicate elements in whole array, do apply a restriction such that you are not accessing element outside the array\\n"
                    },
                    {
                        "username": "mrboombox",
                        "content": "I have the same issue\\n"
                    },
                    {
                        "username": "dddxhh",
                        "content": "The testcases for this problem are too weak.\\n\\nIn my first AC solution, I wrote the code\\n\\n    if (n < k) return false;\\n\\n, where n is the length of the array.\\n\\nClearly, it is wrong(e.g. `nums = {2,2}, k = 3`).\\n\\n\\nI think the admin should do more serious test before a new problem coming online."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "In this example we can satisfy the given condition abs(i - j) <= k"
                    },
                    {
                        "username": "ShuoGuo89",
                        "content": "Could anyone tell me why the test case below is true?\\n\\n[1,0,1,1]\\n1\\n\\nThe largest difference should be 2 which is greater than k = 1. Isn't it?\\nMany thanks!"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "nums[2] == nums[3] also abs(3-2) <=1"
                    },
                    {
                        "username": "Mridul3217",
                        "content": "the question didn\\'t ask for largest difference. It said check if at any index i and j where nums[i] == nums[j] && abs(j-i)<=k. therefore index 2 and 3 fulfils this condition so it is true."
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Do not spam Answers in the Discussion Chat. Avoid it."
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "I\\'m getting TLE like this \\n\\nTime Limit Exceeded\\nLast Executed Input\\n54 / 54 testcases passed\\nnums =\\n\\n"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "same here who tf put that case. "
                    },
                    {
                        "username": "D3press3dd",
                        "content": "Why is this case false? [1,2,3,1,2,3], k = 2\\nthe number 3 is in position 2 and 5, that means Math.abs(2-5) === 3\\n3 >= this is false, so this does not fit the case and i have to return true\\n\\nam i confused?"
                    },
                    {
                        "username": "icancode96",
                        "content": "the result must be <= 2, while 3 > 2"
                    },
                    {
                        "username": "neil90",
                        "content": "Can anybody elaborate on what its asking for?"
                    },
                    {
                        "username": "anchurimanideep1",
                        "content": "[@jithinbp](/jithinbp) crystal clear"
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "[@jithinbp](/jithinbp) then what about testcase 2 , here input is [1,0,1,1] and k=1 .here one comes 0th index and 2nd index. so abs =|0-2| = 2 \\nwhich is not <=1 . so answer  must be false according to your explanation. but the real answer is true. can you clarify this for me .I am totally confused"
                    },
                    {
                        "username": "gautamgupta",
                        "content": "[@jithinbp](/jithinbp)  thats helpfull bro"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@sharforaz_rahman] Happy to hear that bro\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "[@jithinbp](/jithinbp)  Thank you brother, it\\'s indeed a great explanation "
                    },
                    {
                        "username": "jithinbp",
                        "content": "you have been given an integers array nums and an integer K.\\n\\nif you find any duplicate elements and the absolute difference between there indices gives you a value <= k then you can return true.\\n\\nif you couldn\\'t find such element you can return false.\\n\\neg:   nums[] = {4, 3, 1, 4}  k = 5       indices of 4 is : 0 , 3 \\nthe abs value of indices = |0 - 3| = 3 \\nwhich is <= k    so we can return true."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being an ass in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just find a window of size k+1 or less which contains duplicate elements, its as simple as it sound\\n"
                    }
                ]
            },
            {
                "id": 1810608,
                "content": [
                    {
                        "username": "x4snowman",
                        "content": "I am confused about this description."
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "Case 1:\\nnums = [1,2,3,1], k = 3\\nOutput: true\\n\\nDescription:\\nWe will pick only duplicate elements since nums[i] == nums[j]\\n\\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 3 so result is true\\n\\nCase 2:\\nnums = [1,2,3,1,2,3], k = 2\\nOutput: false\\n\\nDescription: \\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 2  is false condition\\n\\nIndex of first 2 is 1 and index of second 2 is 4\\nabs(1-4) <= 2 is false condition\\n\\nIndex of first 3 is 2 and index of second 3 is 5\\nabs(2-5) <= 2 is false condition\\nso overall result false\\n\\n"
                    },
                    {
                        "username": "D3press3dd",
                        "content": "[@Luna-martinez](/Luna-martinez) can you explain it? because i dont get it"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Yes description was a little confusing, but i get the statement."
                    },
                    {
                        "username": "DontSuCharlie",
                        "content": "Why not just say something along the lines of \"Find 2 numbers in the array that are equal and are at most `k` apart from each other.\"?"
                    },
                    {
                        "username": "enkil2003",
                        "content": "because monkeys write these statements."
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "haha, true :)"
                    },
                    {
                        "username": "NAS380",
                        "content": "thanks for that. now I could understand, question not clear"
                    },
                    {
                        "username": "kbventures",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) This is someone you don\\'t want to work with. "
                    },
                    {
                        "username": "jawaditani",
                        "content": "Actually that helped me understand the question, thank you."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being a condescending bitch in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "That\\'s what programming is all about, that\\'s what problem solving is all about, haven\\'t you saw math problems in school, we have to do the exact same stuff but they set the statement of problem such that it was not obvious to do that\\n"
                    },
                    {
                        "username": "zlgy126",
                        "content": "It feels like the question is super unclear."
                    },
                    {
                        "username": "Kaltu",
                        "content": "it\\'s funny while the description is unclear as fuck but if you literal translate what it says to code you get the correct solution"
                    },
                    {
                        "username": "Maheshkumar_2021",
                        "content": "agree"
                    },
                    {
                        "username": "sarocky",
                        "content": "agree"
                    },
                    {
                        "username": "ankithoney",
                        "content": "For this problem, the below test case is wrong:\\nnums = [99,99]\\nk = 2\\n\\nThe correct testcase should be nums = [99,99], k =1.\\n\\nBecause of it I am not able to submit my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "What kind of arcane implementations do you produce so that relation k to the size of the array matters? Doing loops inside loops? It can be solved in linear time with linear memory usage.\n114ms\nBeats 97.46%of users with C++\n76.73MB\nBeats 86.56%of users with C++\n\nAnd the function body is 9 lines long, it's an absolute STL-based no-brainer. I'll try an AMT-based solution just on general principle to beat the remaining 2.54% and 13.44%, respectively."
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@zabuli](/zabuli) Yaa even i missed that part lol\\uD83D\\uDE02"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Priyanshu_singh08](/Priyanshu_singh08)  the testcase isn\\'t wrong, you should read the description again..."
                    },
                    {
                        "username": "zabuli",
                        "content": "When you read the description, abs(i - j) <= k, so abs(0 - 1) == 1 => 1 <= 2 and also 1 <= 1, so for both cases it\\'s true."
                    },
                    {
                        "username": "Priyanshu_singh08",
                        "content": "same here , this test case is wrong"
                    },
                    {
                        "username": "marinospappas",
                        "content": "fully agree - wrong test cases... my code was also stuck in this one..."
                    },
                    {
                        "username": "naikv94",
                        "content": "same issue\\n"
                    },
                    {
                        "username": "Ajay019",
                        "content": "your whole logic becomes wrong at this test case\\n"
                    },
                    {
                        "username": "user5823Dt",
                        "content": "have the same issue"
                    },
                    {
                        "username": "malegkin",
                        "content": "BE CAREFUL!!! LESS OR EQUAL!!\\nabs(i - j) <= k"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@mrboombox](/mrboombox)  test case is not wrong, its just the window size is greater than the array size, which means you have to find duplicate elements in whole array, do apply a restriction such that you are not accessing element outside the array\\n"
                    },
                    {
                        "username": "mrboombox",
                        "content": "I have the same issue\\n"
                    },
                    {
                        "username": "dddxhh",
                        "content": "The testcases for this problem are too weak.\\n\\nIn my first AC solution, I wrote the code\\n\\n    if (n < k) return false;\\n\\n, where n is the length of the array.\\n\\nClearly, it is wrong(e.g. `nums = {2,2}, k = 3`).\\n\\n\\nI think the admin should do more serious test before a new problem coming online."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "In this example we can satisfy the given condition abs(i - j) <= k"
                    },
                    {
                        "username": "ShuoGuo89",
                        "content": "Could anyone tell me why the test case below is true?\\n\\n[1,0,1,1]\\n1\\n\\nThe largest difference should be 2 which is greater than k = 1. Isn't it?\\nMany thanks!"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "nums[2] == nums[3] also abs(3-2) <=1"
                    },
                    {
                        "username": "Mridul3217",
                        "content": "the question didn\\'t ask for largest difference. It said check if at any index i and j where nums[i] == nums[j] && abs(j-i)<=k. therefore index 2 and 3 fulfils this condition so it is true."
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Do not spam Answers in the Discussion Chat. Avoid it."
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "I\\'m getting TLE like this \\n\\nTime Limit Exceeded\\nLast Executed Input\\n54 / 54 testcases passed\\nnums =\\n\\n"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "same here who tf put that case. "
                    },
                    {
                        "username": "D3press3dd",
                        "content": "Why is this case false? [1,2,3,1,2,3], k = 2\\nthe number 3 is in position 2 and 5, that means Math.abs(2-5) === 3\\n3 >= this is false, so this does not fit the case and i have to return true\\n\\nam i confused?"
                    },
                    {
                        "username": "icancode96",
                        "content": "the result must be <= 2, while 3 > 2"
                    },
                    {
                        "username": "neil90",
                        "content": "Can anybody elaborate on what its asking for?"
                    },
                    {
                        "username": "anchurimanideep1",
                        "content": "[@jithinbp](/jithinbp) crystal clear"
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "[@jithinbp](/jithinbp) then what about testcase 2 , here input is [1,0,1,1] and k=1 .here one comes 0th index and 2nd index. so abs =|0-2| = 2 \\nwhich is not <=1 . so answer  must be false according to your explanation. but the real answer is true. can you clarify this for me .I am totally confused"
                    },
                    {
                        "username": "gautamgupta",
                        "content": "[@jithinbp](/jithinbp)  thats helpfull bro"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@sharforaz_rahman] Happy to hear that bro\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "[@jithinbp](/jithinbp)  Thank you brother, it\\'s indeed a great explanation "
                    },
                    {
                        "username": "jithinbp",
                        "content": "you have been given an integers array nums and an integer K.\\n\\nif you find any duplicate elements and the absolute difference between there indices gives you a value <= k then you can return true.\\n\\nif you couldn\\'t find such element you can return false.\\n\\neg:   nums[] = {4, 3, 1, 4}  k = 5       indices of 4 is : 0 , 3 \\nthe abs value of indices = |0 - 3| = 3 \\nwhich is <= k    so we can return true."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being an ass in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just find a window of size k+1 or less which contains duplicate elements, its as simple as it sound\\n"
                    }
                ]
            },
            {
                "id": 1748694,
                "content": [
                    {
                        "username": "x4snowman",
                        "content": "I am confused about this description."
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "Case 1:\\nnums = [1,2,3,1], k = 3\\nOutput: true\\n\\nDescription:\\nWe will pick only duplicate elements since nums[i] == nums[j]\\n\\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 3 so result is true\\n\\nCase 2:\\nnums = [1,2,3,1,2,3], k = 2\\nOutput: false\\n\\nDescription: \\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 2  is false condition\\n\\nIndex of first 2 is 1 and index of second 2 is 4\\nabs(1-4) <= 2 is false condition\\n\\nIndex of first 3 is 2 and index of second 3 is 5\\nabs(2-5) <= 2 is false condition\\nso overall result false\\n\\n"
                    },
                    {
                        "username": "D3press3dd",
                        "content": "[@Luna-martinez](/Luna-martinez) can you explain it? because i dont get it"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Yes description was a little confusing, but i get the statement."
                    },
                    {
                        "username": "DontSuCharlie",
                        "content": "Why not just say something along the lines of \"Find 2 numbers in the array that are equal and are at most `k` apart from each other.\"?"
                    },
                    {
                        "username": "enkil2003",
                        "content": "because monkeys write these statements."
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "haha, true :)"
                    },
                    {
                        "username": "NAS380",
                        "content": "thanks for that. now I could understand, question not clear"
                    },
                    {
                        "username": "kbventures",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) This is someone you don\\'t want to work with. "
                    },
                    {
                        "username": "jawaditani",
                        "content": "Actually that helped me understand the question, thank you."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being a condescending bitch in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "That\\'s what programming is all about, that\\'s what problem solving is all about, haven\\'t you saw math problems in school, we have to do the exact same stuff but they set the statement of problem such that it was not obvious to do that\\n"
                    },
                    {
                        "username": "zlgy126",
                        "content": "It feels like the question is super unclear."
                    },
                    {
                        "username": "Kaltu",
                        "content": "it\\'s funny while the description is unclear as fuck but if you literal translate what it says to code you get the correct solution"
                    },
                    {
                        "username": "Maheshkumar_2021",
                        "content": "agree"
                    },
                    {
                        "username": "sarocky",
                        "content": "agree"
                    },
                    {
                        "username": "ankithoney",
                        "content": "For this problem, the below test case is wrong:\\nnums = [99,99]\\nk = 2\\n\\nThe correct testcase should be nums = [99,99], k =1.\\n\\nBecause of it I am not able to submit my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "What kind of arcane implementations do you produce so that relation k to the size of the array matters? Doing loops inside loops? It can be solved in linear time with linear memory usage.\n114ms\nBeats 97.46%of users with C++\n76.73MB\nBeats 86.56%of users with C++\n\nAnd the function body is 9 lines long, it's an absolute STL-based no-brainer. I'll try an AMT-based solution just on general principle to beat the remaining 2.54% and 13.44%, respectively."
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@zabuli](/zabuli) Yaa even i missed that part lol\\uD83D\\uDE02"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Priyanshu_singh08](/Priyanshu_singh08)  the testcase isn\\'t wrong, you should read the description again..."
                    },
                    {
                        "username": "zabuli",
                        "content": "When you read the description, abs(i - j) <= k, so abs(0 - 1) == 1 => 1 <= 2 and also 1 <= 1, so for both cases it\\'s true."
                    },
                    {
                        "username": "Priyanshu_singh08",
                        "content": "same here , this test case is wrong"
                    },
                    {
                        "username": "marinospappas",
                        "content": "fully agree - wrong test cases... my code was also stuck in this one..."
                    },
                    {
                        "username": "naikv94",
                        "content": "same issue\\n"
                    },
                    {
                        "username": "Ajay019",
                        "content": "your whole logic becomes wrong at this test case\\n"
                    },
                    {
                        "username": "user5823Dt",
                        "content": "have the same issue"
                    },
                    {
                        "username": "malegkin",
                        "content": "BE CAREFUL!!! LESS OR EQUAL!!\\nabs(i - j) <= k"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@mrboombox](/mrboombox)  test case is not wrong, its just the window size is greater than the array size, which means you have to find duplicate elements in whole array, do apply a restriction such that you are not accessing element outside the array\\n"
                    },
                    {
                        "username": "mrboombox",
                        "content": "I have the same issue\\n"
                    },
                    {
                        "username": "dddxhh",
                        "content": "The testcases for this problem are too weak.\\n\\nIn my first AC solution, I wrote the code\\n\\n    if (n < k) return false;\\n\\n, where n is the length of the array.\\n\\nClearly, it is wrong(e.g. `nums = {2,2}, k = 3`).\\n\\n\\nI think the admin should do more serious test before a new problem coming online."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "In this example we can satisfy the given condition abs(i - j) <= k"
                    },
                    {
                        "username": "ShuoGuo89",
                        "content": "Could anyone tell me why the test case below is true?\\n\\n[1,0,1,1]\\n1\\n\\nThe largest difference should be 2 which is greater than k = 1. Isn't it?\\nMany thanks!"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "nums[2] == nums[3] also abs(3-2) <=1"
                    },
                    {
                        "username": "Mridul3217",
                        "content": "the question didn\\'t ask for largest difference. It said check if at any index i and j where nums[i] == nums[j] && abs(j-i)<=k. therefore index 2 and 3 fulfils this condition so it is true."
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Do not spam Answers in the Discussion Chat. Avoid it."
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "I\\'m getting TLE like this \\n\\nTime Limit Exceeded\\nLast Executed Input\\n54 / 54 testcases passed\\nnums =\\n\\n"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "same here who tf put that case. "
                    },
                    {
                        "username": "D3press3dd",
                        "content": "Why is this case false? [1,2,3,1,2,3], k = 2\\nthe number 3 is in position 2 and 5, that means Math.abs(2-5) === 3\\n3 >= this is false, so this does not fit the case and i have to return true\\n\\nam i confused?"
                    },
                    {
                        "username": "icancode96",
                        "content": "the result must be <= 2, while 3 > 2"
                    },
                    {
                        "username": "neil90",
                        "content": "Can anybody elaborate on what its asking for?"
                    },
                    {
                        "username": "anchurimanideep1",
                        "content": "[@jithinbp](/jithinbp) crystal clear"
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "[@jithinbp](/jithinbp) then what about testcase 2 , here input is [1,0,1,1] and k=1 .here one comes 0th index and 2nd index. so abs =|0-2| = 2 \\nwhich is not <=1 . so answer  must be false according to your explanation. but the real answer is true. can you clarify this for me .I am totally confused"
                    },
                    {
                        "username": "gautamgupta",
                        "content": "[@jithinbp](/jithinbp)  thats helpfull bro"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@sharforaz_rahman] Happy to hear that bro\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "[@jithinbp](/jithinbp)  Thank you brother, it\\'s indeed a great explanation "
                    },
                    {
                        "username": "jithinbp",
                        "content": "you have been given an integers array nums and an integer K.\\n\\nif you find any duplicate elements and the absolute difference between there indices gives you a value <= k then you can return true.\\n\\nif you couldn\\'t find such element you can return false.\\n\\neg:   nums[] = {4, 3, 1, 4}  k = 5       indices of 4 is : 0 , 3 \\nthe abs value of indices = |0 - 3| = 3 \\nwhich is <= k    so we can return true."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being an ass in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just find a window of size k+1 or less which contains duplicate elements, its as simple as it sound\\n"
                    }
                ]
            },
            {
                "id": 1572318,
                "content": [
                    {
                        "username": "x4snowman",
                        "content": "I am confused about this description."
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "Case 1:\\nnums = [1,2,3,1], k = 3\\nOutput: true\\n\\nDescription:\\nWe will pick only duplicate elements since nums[i] == nums[j]\\n\\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 3 so result is true\\n\\nCase 2:\\nnums = [1,2,3,1,2,3], k = 2\\nOutput: false\\n\\nDescription: \\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 2  is false condition\\n\\nIndex of first 2 is 1 and index of second 2 is 4\\nabs(1-4) <= 2 is false condition\\n\\nIndex of first 3 is 2 and index of second 3 is 5\\nabs(2-5) <= 2 is false condition\\nso overall result false\\n\\n"
                    },
                    {
                        "username": "D3press3dd",
                        "content": "[@Luna-martinez](/Luna-martinez) can you explain it? because i dont get it"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Yes description was a little confusing, but i get the statement."
                    },
                    {
                        "username": "DontSuCharlie",
                        "content": "Why not just say something along the lines of \"Find 2 numbers in the array that are equal and are at most `k` apart from each other.\"?"
                    },
                    {
                        "username": "enkil2003",
                        "content": "because monkeys write these statements."
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "haha, true :)"
                    },
                    {
                        "username": "NAS380",
                        "content": "thanks for that. now I could understand, question not clear"
                    },
                    {
                        "username": "kbventures",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) This is someone you don\\'t want to work with. "
                    },
                    {
                        "username": "jawaditani",
                        "content": "Actually that helped me understand the question, thank you."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being a condescending bitch in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "That\\'s what programming is all about, that\\'s what problem solving is all about, haven\\'t you saw math problems in school, we have to do the exact same stuff but they set the statement of problem such that it was not obvious to do that\\n"
                    },
                    {
                        "username": "zlgy126",
                        "content": "It feels like the question is super unclear."
                    },
                    {
                        "username": "Kaltu",
                        "content": "it\\'s funny while the description is unclear as fuck but if you literal translate what it says to code you get the correct solution"
                    },
                    {
                        "username": "Maheshkumar_2021",
                        "content": "agree"
                    },
                    {
                        "username": "sarocky",
                        "content": "agree"
                    },
                    {
                        "username": "ankithoney",
                        "content": "For this problem, the below test case is wrong:\\nnums = [99,99]\\nk = 2\\n\\nThe correct testcase should be nums = [99,99], k =1.\\n\\nBecause of it I am not able to submit my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "What kind of arcane implementations do you produce so that relation k to the size of the array matters? Doing loops inside loops? It can be solved in linear time with linear memory usage.\n114ms\nBeats 97.46%of users with C++\n76.73MB\nBeats 86.56%of users with C++\n\nAnd the function body is 9 lines long, it's an absolute STL-based no-brainer. I'll try an AMT-based solution just on general principle to beat the remaining 2.54% and 13.44%, respectively."
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@zabuli](/zabuli) Yaa even i missed that part lol\\uD83D\\uDE02"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Priyanshu_singh08](/Priyanshu_singh08)  the testcase isn\\'t wrong, you should read the description again..."
                    },
                    {
                        "username": "zabuli",
                        "content": "When you read the description, abs(i - j) <= k, so abs(0 - 1) == 1 => 1 <= 2 and also 1 <= 1, so for both cases it\\'s true."
                    },
                    {
                        "username": "Priyanshu_singh08",
                        "content": "same here , this test case is wrong"
                    },
                    {
                        "username": "marinospappas",
                        "content": "fully agree - wrong test cases... my code was also stuck in this one..."
                    },
                    {
                        "username": "naikv94",
                        "content": "same issue\\n"
                    },
                    {
                        "username": "Ajay019",
                        "content": "your whole logic becomes wrong at this test case\\n"
                    },
                    {
                        "username": "user5823Dt",
                        "content": "have the same issue"
                    },
                    {
                        "username": "malegkin",
                        "content": "BE CAREFUL!!! LESS OR EQUAL!!\\nabs(i - j) <= k"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@mrboombox](/mrboombox)  test case is not wrong, its just the window size is greater than the array size, which means you have to find duplicate elements in whole array, do apply a restriction such that you are not accessing element outside the array\\n"
                    },
                    {
                        "username": "mrboombox",
                        "content": "I have the same issue\\n"
                    },
                    {
                        "username": "dddxhh",
                        "content": "The testcases for this problem are too weak.\\n\\nIn my first AC solution, I wrote the code\\n\\n    if (n < k) return false;\\n\\n, where n is the length of the array.\\n\\nClearly, it is wrong(e.g. `nums = {2,2}, k = 3`).\\n\\n\\nI think the admin should do more serious test before a new problem coming online."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "In this example we can satisfy the given condition abs(i - j) <= k"
                    },
                    {
                        "username": "ShuoGuo89",
                        "content": "Could anyone tell me why the test case below is true?\\n\\n[1,0,1,1]\\n1\\n\\nThe largest difference should be 2 which is greater than k = 1. Isn't it?\\nMany thanks!"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "nums[2] == nums[3] also abs(3-2) <=1"
                    },
                    {
                        "username": "Mridul3217",
                        "content": "the question didn\\'t ask for largest difference. It said check if at any index i and j where nums[i] == nums[j] && abs(j-i)<=k. therefore index 2 and 3 fulfils this condition so it is true."
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Do not spam Answers in the Discussion Chat. Avoid it."
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "I\\'m getting TLE like this \\n\\nTime Limit Exceeded\\nLast Executed Input\\n54 / 54 testcases passed\\nnums =\\n\\n"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "same here who tf put that case. "
                    },
                    {
                        "username": "D3press3dd",
                        "content": "Why is this case false? [1,2,3,1,2,3], k = 2\\nthe number 3 is in position 2 and 5, that means Math.abs(2-5) === 3\\n3 >= this is false, so this does not fit the case and i have to return true\\n\\nam i confused?"
                    },
                    {
                        "username": "icancode96",
                        "content": "the result must be <= 2, while 3 > 2"
                    },
                    {
                        "username": "neil90",
                        "content": "Can anybody elaborate on what its asking for?"
                    },
                    {
                        "username": "anchurimanideep1",
                        "content": "[@jithinbp](/jithinbp) crystal clear"
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "[@jithinbp](/jithinbp) then what about testcase 2 , here input is [1,0,1,1] and k=1 .here one comes 0th index and 2nd index. so abs =|0-2| = 2 \\nwhich is not <=1 . so answer  must be false according to your explanation. but the real answer is true. can you clarify this for me .I am totally confused"
                    },
                    {
                        "username": "gautamgupta",
                        "content": "[@jithinbp](/jithinbp)  thats helpfull bro"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@sharforaz_rahman] Happy to hear that bro\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "[@jithinbp](/jithinbp)  Thank you brother, it\\'s indeed a great explanation "
                    },
                    {
                        "username": "jithinbp",
                        "content": "you have been given an integers array nums and an integer K.\\n\\nif you find any duplicate elements and the absolute difference between there indices gives you a value <= k then you can return true.\\n\\nif you couldn\\'t find such element you can return false.\\n\\neg:   nums[] = {4, 3, 1, 4}  k = 5       indices of 4 is : 0 , 3 \\nthe abs value of indices = |0 - 3| = 3 \\nwhich is <= k    so we can return true."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being an ass in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just find a window of size k+1 or less which contains duplicate elements, its as simple as it sound\\n"
                    }
                ]
            },
            {
                "id": 1568131,
                "content": [
                    {
                        "username": "x4snowman",
                        "content": "I am confused about this description."
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "Case 1:\\nnums = [1,2,3,1], k = 3\\nOutput: true\\n\\nDescription:\\nWe will pick only duplicate elements since nums[i] == nums[j]\\n\\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 3 so result is true\\n\\nCase 2:\\nnums = [1,2,3,1,2,3], k = 2\\nOutput: false\\n\\nDescription: \\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 2  is false condition\\n\\nIndex of first 2 is 1 and index of second 2 is 4\\nabs(1-4) <= 2 is false condition\\n\\nIndex of first 3 is 2 and index of second 3 is 5\\nabs(2-5) <= 2 is false condition\\nso overall result false\\n\\n"
                    },
                    {
                        "username": "D3press3dd",
                        "content": "[@Luna-martinez](/Luna-martinez) can you explain it? because i dont get it"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Yes description was a little confusing, but i get the statement."
                    },
                    {
                        "username": "DontSuCharlie",
                        "content": "Why not just say something along the lines of \"Find 2 numbers in the array that are equal and are at most `k` apart from each other.\"?"
                    },
                    {
                        "username": "enkil2003",
                        "content": "because monkeys write these statements."
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "haha, true :)"
                    },
                    {
                        "username": "NAS380",
                        "content": "thanks for that. now I could understand, question not clear"
                    },
                    {
                        "username": "kbventures",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) This is someone you don\\'t want to work with. "
                    },
                    {
                        "username": "jawaditani",
                        "content": "Actually that helped me understand the question, thank you."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being a condescending bitch in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "That\\'s what programming is all about, that\\'s what problem solving is all about, haven\\'t you saw math problems in school, we have to do the exact same stuff but they set the statement of problem such that it was not obvious to do that\\n"
                    },
                    {
                        "username": "zlgy126",
                        "content": "It feels like the question is super unclear."
                    },
                    {
                        "username": "Kaltu",
                        "content": "it\\'s funny while the description is unclear as fuck but if you literal translate what it says to code you get the correct solution"
                    },
                    {
                        "username": "Maheshkumar_2021",
                        "content": "agree"
                    },
                    {
                        "username": "sarocky",
                        "content": "agree"
                    },
                    {
                        "username": "ankithoney",
                        "content": "For this problem, the below test case is wrong:\\nnums = [99,99]\\nk = 2\\n\\nThe correct testcase should be nums = [99,99], k =1.\\n\\nBecause of it I am not able to submit my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "What kind of arcane implementations do you produce so that relation k to the size of the array matters? Doing loops inside loops? It can be solved in linear time with linear memory usage.\n114ms\nBeats 97.46%of users with C++\n76.73MB\nBeats 86.56%of users with C++\n\nAnd the function body is 9 lines long, it's an absolute STL-based no-brainer. I'll try an AMT-based solution just on general principle to beat the remaining 2.54% and 13.44%, respectively."
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@zabuli](/zabuli) Yaa even i missed that part lol\\uD83D\\uDE02"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Priyanshu_singh08](/Priyanshu_singh08)  the testcase isn\\'t wrong, you should read the description again..."
                    },
                    {
                        "username": "zabuli",
                        "content": "When you read the description, abs(i - j) <= k, so abs(0 - 1) == 1 => 1 <= 2 and also 1 <= 1, so for both cases it\\'s true."
                    },
                    {
                        "username": "Priyanshu_singh08",
                        "content": "same here , this test case is wrong"
                    },
                    {
                        "username": "marinospappas",
                        "content": "fully agree - wrong test cases... my code was also stuck in this one..."
                    },
                    {
                        "username": "naikv94",
                        "content": "same issue\\n"
                    },
                    {
                        "username": "Ajay019",
                        "content": "your whole logic becomes wrong at this test case\\n"
                    },
                    {
                        "username": "user5823Dt",
                        "content": "have the same issue"
                    },
                    {
                        "username": "malegkin",
                        "content": "BE CAREFUL!!! LESS OR EQUAL!!\\nabs(i - j) <= k"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@mrboombox](/mrboombox)  test case is not wrong, its just the window size is greater than the array size, which means you have to find duplicate elements in whole array, do apply a restriction such that you are not accessing element outside the array\\n"
                    },
                    {
                        "username": "mrboombox",
                        "content": "I have the same issue\\n"
                    },
                    {
                        "username": "dddxhh",
                        "content": "The testcases for this problem are too weak.\\n\\nIn my first AC solution, I wrote the code\\n\\n    if (n < k) return false;\\n\\n, where n is the length of the array.\\n\\nClearly, it is wrong(e.g. `nums = {2,2}, k = 3`).\\n\\n\\nI think the admin should do more serious test before a new problem coming online."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "In this example we can satisfy the given condition abs(i - j) <= k"
                    },
                    {
                        "username": "ShuoGuo89",
                        "content": "Could anyone tell me why the test case below is true?\\n\\n[1,0,1,1]\\n1\\n\\nThe largest difference should be 2 which is greater than k = 1. Isn't it?\\nMany thanks!"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "nums[2] == nums[3] also abs(3-2) <=1"
                    },
                    {
                        "username": "Mridul3217",
                        "content": "the question didn\\'t ask for largest difference. It said check if at any index i and j where nums[i] == nums[j] && abs(j-i)<=k. therefore index 2 and 3 fulfils this condition so it is true."
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Do not spam Answers in the Discussion Chat. Avoid it."
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "I\\'m getting TLE like this \\n\\nTime Limit Exceeded\\nLast Executed Input\\n54 / 54 testcases passed\\nnums =\\n\\n"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "same here who tf put that case. "
                    },
                    {
                        "username": "D3press3dd",
                        "content": "Why is this case false? [1,2,3,1,2,3], k = 2\\nthe number 3 is in position 2 and 5, that means Math.abs(2-5) === 3\\n3 >= this is false, so this does not fit the case and i have to return true\\n\\nam i confused?"
                    },
                    {
                        "username": "icancode96",
                        "content": "the result must be <= 2, while 3 > 2"
                    },
                    {
                        "username": "neil90",
                        "content": "Can anybody elaborate on what its asking for?"
                    },
                    {
                        "username": "anchurimanideep1",
                        "content": "[@jithinbp](/jithinbp) crystal clear"
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "[@jithinbp](/jithinbp) then what about testcase 2 , here input is [1,0,1,1] and k=1 .here one comes 0th index and 2nd index. so abs =|0-2| = 2 \\nwhich is not <=1 . so answer  must be false according to your explanation. but the real answer is true. can you clarify this for me .I am totally confused"
                    },
                    {
                        "username": "gautamgupta",
                        "content": "[@jithinbp](/jithinbp)  thats helpfull bro"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@sharforaz_rahman] Happy to hear that bro\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "[@jithinbp](/jithinbp)  Thank you brother, it\\'s indeed a great explanation "
                    },
                    {
                        "username": "jithinbp",
                        "content": "you have been given an integers array nums and an integer K.\\n\\nif you find any duplicate elements and the absolute difference between there indices gives you a value <= k then you can return true.\\n\\nif you couldn\\'t find such element you can return false.\\n\\neg:   nums[] = {4, 3, 1, 4}  k = 5       indices of 4 is : 0 , 3 \\nthe abs value of indices = |0 - 3| = 3 \\nwhich is <= k    so we can return true."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being an ass in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just find a window of size k+1 or less which contains duplicate elements, its as simple as it sound\\n"
                    }
                ]
            },
            {
                "id": 1569267,
                "content": [
                    {
                        "username": "x4snowman",
                        "content": "I am confused about this description."
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "Case 1:\\nnums = [1,2,3,1], k = 3\\nOutput: true\\n\\nDescription:\\nWe will pick only duplicate elements since nums[i] == nums[j]\\n\\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 3 so result is true\\n\\nCase 2:\\nnums = [1,2,3,1,2,3], k = 2\\nOutput: false\\n\\nDescription: \\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 2  is false condition\\n\\nIndex of first 2 is 1 and index of second 2 is 4\\nabs(1-4) <= 2 is false condition\\n\\nIndex of first 3 is 2 and index of second 3 is 5\\nabs(2-5) <= 2 is false condition\\nso overall result false\\n\\n"
                    },
                    {
                        "username": "D3press3dd",
                        "content": "[@Luna-martinez](/Luna-martinez) can you explain it? because i dont get it"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Yes description was a little confusing, but i get the statement."
                    },
                    {
                        "username": "DontSuCharlie",
                        "content": "Why not just say something along the lines of \"Find 2 numbers in the array that are equal and are at most `k` apart from each other.\"?"
                    },
                    {
                        "username": "enkil2003",
                        "content": "because monkeys write these statements."
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "haha, true :)"
                    },
                    {
                        "username": "NAS380",
                        "content": "thanks for that. now I could understand, question not clear"
                    },
                    {
                        "username": "kbventures",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) This is someone you don\\'t want to work with. "
                    },
                    {
                        "username": "jawaditani",
                        "content": "Actually that helped me understand the question, thank you."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being a condescending bitch in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "That\\'s what programming is all about, that\\'s what problem solving is all about, haven\\'t you saw math problems in school, we have to do the exact same stuff but they set the statement of problem such that it was not obvious to do that\\n"
                    },
                    {
                        "username": "zlgy126",
                        "content": "It feels like the question is super unclear."
                    },
                    {
                        "username": "Kaltu",
                        "content": "it\\'s funny while the description is unclear as fuck but if you literal translate what it says to code you get the correct solution"
                    },
                    {
                        "username": "Maheshkumar_2021",
                        "content": "agree"
                    },
                    {
                        "username": "sarocky",
                        "content": "agree"
                    },
                    {
                        "username": "ankithoney",
                        "content": "For this problem, the below test case is wrong:\\nnums = [99,99]\\nk = 2\\n\\nThe correct testcase should be nums = [99,99], k =1.\\n\\nBecause of it I am not able to submit my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "What kind of arcane implementations do you produce so that relation k to the size of the array matters? Doing loops inside loops? It can be solved in linear time with linear memory usage.\n114ms\nBeats 97.46%of users with C++\n76.73MB\nBeats 86.56%of users with C++\n\nAnd the function body is 9 lines long, it's an absolute STL-based no-brainer. I'll try an AMT-based solution just on general principle to beat the remaining 2.54% and 13.44%, respectively."
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@zabuli](/zabuli) Yaa even i missed that part lol\\uD83D\\uDE02"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Priyanshu_singh08](/Priyanshu_singh08)  the testcase isn\\'t wrong, you should read the description again..."
                    },
                    {
                        "username": "zabuli",
                        "content": "When you read the description, abs(i - j) <= k, so abs(0 - 1) == 1 => 1 <= 2 and also 1 <= 1, so for both cases it\\'s true."
                    },
                    {
                        "username": "Priyanshu_singh08",
                        "content": "same here , this test case is wrong"
                    },
                    {
                        "username": "marinospappas",
                        "content": "fully agree - wrong test cases... my code was also stuck in this one..."
                    },
                    {
                        "username": "naikv94",
                        "content": "same issue\\n"
                    },
                    {
                        "username": "Ajay019",
                        "content": "your whole logic becomes wrong at this test case\\n"
                    },
                    {
                        "username": "user5823Dt",
                        "content": "have the same issue"
                    },
                    {
                        "username": "malegkin",
                        "content": "BE CAREFUL!!! LESS OR EQUAL!!\\nabs(i - j) <= k"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@mrboombox](/mrboombox)  test case is not wrong, its just the window size is greater than the array size, which means you have to find duplicate elements in whole array, do apply a restriction such that you are not accessing element outside the array\\n"
                    },
                    {
                        "username": "mrboombox",
                        "content": "I have the same issue\\n"
                    },
                    {
                        "username": "dddxhh",
                        "content": "The testcases for this problem are too weak.\\n\\nIn my first AC solution, I wrote the code\\n\\n    if (n < k) return false;\\n\\n, where n is the length of the array.\\n\\nClearly, it is wrong(e.g. `nums = {2,2}, k = 3`).\\n\\n\\nI think the admin should do more serious test before a new problem coming online."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "In this example we can satisfy the given condition abs(i - j) <= k"
                    },
                    {
                        "username": "ShuoGuo89",
                        "content": "Could anyone tell me why the test case below is true?\\n\\n[1,0,1,1]\\n1\\n\\nThe largest difference should be 2 which is greater than k = 1. Isn't it?\\nMany thanks!"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "nums[2] == nums[3] also abs(3-2) <=1"
                    },
                    {
                        "username": "Mridul3217",
                        "content": "the question didn\\'t ask for largest difference. It said check if at any index i and j where nums[i] == nums[j] && abs(j-i)<=k. therefore index 2 and 3 fulfils this condition so it is true."
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Do not spam Answers in the Discussion Chat. Avoid it."
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "I\\'m getting TLE like this \\n\\nTime Limit Exceeded\\nLast Executed Input\\n54 / 54 testcases passed\\nnums =\\n\\n"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "same here who tf put that case. "
                    },
                    {
                        "username": "D3press3dd",
                        "content": "Why is this case false? [1,2,3,1,2,3], k = 2\\nthe number 3 is in position 2 and 5, that means Math.abs(2-5) === 3\\n3 >= this is false, so this does not fit the case and i have to return true\\n\\nam i confused?"
                    },
                    {
                        "username": "icancode96",
                        "content": "the result must be <= 2, while 3 > 2"
                    },
                    {
                        "username": "neil90",
                        "content": "Can anybody elaborate on what its asking for?"
                    },
                    {
                        "username": "anchurimanideep1",
                        "content": "[@jithinbp](/jithinbp) crystal clear"
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "[@jithinbp](/jithinbp) then what about testcase 2 , here input is [1,0,1,1] and k=1 .here one comes 0th index and 2nd index. so abs =|0-2| = 2 \\nwhich is not <=1 . so answer  must be false according to your explanation. but the real answer is true. can you clarify this for me .I am totally confused"
                    },
                    {
                        "username": "gautamgupta",
                        "content": "[@jithinbp](/jithinbp)  thats helpfull bro"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@sharforaz_rahman] Happy to hear that bro\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "[@jithinbp](/jithinbp)  Thank you brother, it\\'s indeed a great explanation "
                    },
                    {
                        "username": "jithinbp",
                        "content": "you have been given an integers array nums and an integer K.\\n\\nif you find any duplicate elements and the absolute difference between there indices gives you a value <= k then you can return true.\\n\\nif you couldn\\'t find such element you can return false.\\n\\neg:   nums[] = {4, 3, 1, 4}  k = 5       indices of 4 is : 0 , 3 \\nthe abs value of indices = |0 - 3| = 3 \\nwhich is <= k    so we can return true."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being an ass in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just find a window of size k+1 or less which contains duplicate elements, its as simple as it sound\\n"
                    }
                ]
            },
            {
                "id": 1574332,
                "content": [
                    {
                        "username": "x4snowman",
                        "content": "I am confused about this description."
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "Case 1:\\nnums = [1,2,3,1], k = 3\\nOutput: true\\n\\nDescription:\\nWe will pick only duplicate elements since nums[i] == nums[j]\\n\\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 3 so result is true\\n\\nCase 2:\\nnums = [1,2,3,1,2,3], k = 2\\nOutput: false\\n\\nDescription: \\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 2  is false condition\\n\\nIndex of first 2 is 1 and index of second 2 is 4\\nabs(1-4) <= 2 is false condition\\n\\nIndex of first 3 is 2 and index of second 3 is 5\\nabs(2-5) <= 2 is false condition\\nso overall result false\\n\\n"
                    },
                    {
                        "username": "D3press3dd",
                        "content": "[@Luna-martinez](/Luna-martinez) can you explain it? because i dont get it"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Yes description was a little confusing, but i get the statement."
                    },
                    {
                        "username": "DontSuCharlie",
                        "content": "Why not just say something along the lines of \"Find 2 numbers in the array that are equal and are at most `k` apart from each other.\"?"
                    },
                    {
                        "username": "enkil2003",
                        "content": "because monkeys write these statements."
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "haha, true :)"
                    },
                    {
                        "username": "NAS380",
                        "content": "thanks for that. now I could understand, question not clear"
                    },
                    {
                        "username": "kbventures",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) This is someone you don\\'t want to work with. "
                    },
                    {
                        "username": "jawaditani",
                        "content": "Actually that helped me understand the question, thank you."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being a condescending bitch in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "That\\'s what programming is all about, that\\'s what problem solving is all about, haven\\'t you saw math problems in school, we have to do the exact same stuff but they set the statement of problem such that it was not obvious to do that\\n"
                    },
                    {
                        "username": "zlgy126",
                        "content": "It feels like the question is super unclear."
                    },
                    {
                        "username": "Kaltu",
                        "content": "it\\'s funny while the description is unclear as fuck but if you literal translate what it says to code you get the correct solution"
                    },
                    {
                        "username": "Maheshkumar_2021",
                        "content": "agree"
                    },
                    {
                        "username": "sarocky",
                        "content": "agree"
                    },
                    {
                        "username": "ankithoney",
                        "content": "For this problem, the below test case is wrong:\\nnums = [99,99]\\nk = 2\\n\\nThe correct testcase should be nums = [99,99], k =1.\\n\\nBecause of it I am not able to submit my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "What kind of arcane implementations do you produce so that relation k to the size of the array matters? Doing loops inside loops? It can be solved in linear time with linear memory usage.\n114ms\nBeats 97.46%of users with C++\n76.73MB\nBeats 86.56%of users with C++\n\nAnd the function body is 9 lines long, it's an absolute STL-based no-brainer. I'll try an AMT-based solution just on general principle to beat the remaining 2.54% and 13.44%, respectively."
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@zabuli](/zabuli) Yaa even i missed that part lol\\uD83D\\uDE02"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Priyanshu_singh08](/Priyanshu_singh08)  the testcase isn\\'t wrong, you should read the description again..."
                    },
                    {
                        "username": "zabuli",
                        "content": "When you read the description, abs(i - j) <= k, so abs(0 - 1) == 1 => 1 <= 2 and also 1 <= 1, so for both cases it\\'s true."
                    },
                    {
                        "username": "Priyanshu_singh08",
                        "content": "same here , this test case is wrong"
                    },
                    {
                        "username": "marinospappas",
                        "content": "fully agree - wrong test cases... my code was also stuck in this one..."
                    },
                    {
                        "username": "naikv94",
                        "content": "same issue\\n"
                    },
                    {
                        "username": "Ajay019",
                        "content": "your whole logic becomes wrong at this test case\\n"
                    },
                    {
                        "username": "user5823Dt",
                        "content": "have the same issue"
                    },
                    {
                        "username": "malegkin",
                        "content": "BE CAREFUL!!! LESS OR EQUAL!!\\nabs(i - j) <= k"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@mrboombox](/mrboombox)  test case is not wrong, its just the window size is greater than the array size, which means you have to find duplicate elements in whole array, do apply a restriction such that you are not accessing element outside the array\\n"
                    },
                    {
                        "username": "mrboombox",
                        "content": "I have the same issue\\n"
                    },
                    {
                        "username": "dddxhh",
                        "content": "The testcases for this problem are too weak.\\n\\nIn my first AC solution, I wrote the code\\n\\n    if (n < k) return false;\\n\\n, where n is the length of the array.\\n\\nClearly, it is wrong(e.g. `nums = {2,2}, k = 3`).\\n\\n\\nI think the admin should do more serious test before a new problem coming online."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "In this example we can satisfy the given condition abs(i - j) <= k"
                    },
                    {
                        "username": "ShuoGuo89",
                        "content": "Could anyone tell me why the test case below is true?\\n\\n[1,0,1,1]\\n1\\n\\nThe largest difference should be 2 which is greater than k = 1. Isn't it?\\nMany thanks!"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "nums[2] == nums[3] also abs(3-2) <=1"
                    },
                    {
                        "username": "Mridul3217",
                        "content": "the question didn\\'t ask for largest difference. It said check if at any index i and j where nums[i] == nums[j] && abs(j-i)<=k. therefore index 2 and 3 fulfils this condition so it is true."
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Do not spam Answers in the Discussion Chat. Avoid it."
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "I\\'m getting TLE like this \\n\\nTime Limit Exceeded\\nLast Executed Input\\n54 / 54 testcases passed\\nnums =\\n\\n"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "same here who tf put that case. "
                    },
                    {
                        "username": "D3press3dd",
                        "content": "Why is this case false? [1,2,3,1,2,3], k = 2\\nthe number 3 is in position 2 and 5, that means Math.abs(2-5) === 3\\n3 >= this is false, so this does not fit the case and i have to return true\\n\\nam i confused?"
                    },
                    {
                        "username": "icancode96",
                        "content": "the result must be <= 2, while 3 > 2"
                    },
                    {
                        "username": "neil90",
                        "content": "Can anybody elaborate on what its asking for?"
                    },
                    {
                        "username": "anchurimanideep1",
                        "content": "[@jithinbp](/jithinbp) crystal clear"
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "[@jithinbp](/jithinbp) then what about testcase 2 , here input is [1,0,1,1] and k=1 .here one comes 0th index and 2nd index. so abs =|0-2| = 2 \\nwhich is not <=1 . so answer  must be false according to your explanation. but the real answer is true. can you clarify this for me .I am totally confused"
                    },
                    {
                        "username": "gautamgupta",
                        "content": "[@jithinbp](/jithinbp)  thats helpfull bro"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@sharforaz_rahman] Happy to hear that bro\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "[@jithinbp](/jithinbp)  Thank you brother, it\\'s indeed a great explanation "
                    },
                    {
                        "username": "jithinbp",
                        "content": "you have been given an integers array nums and an integer K.\\n\\nif you find any duplicate elements and the absolute difference between there indices gives you a value <= k then you can return true.\\n\\nif you couldn\\'t find such element you can return false.\\n\\neg:   nums[] = {4, 3, 1, 4}  k = 5       indices of 4 is : 0 , 3 \\nthe abs value of indices = |0 - 3| = 3 \\nwhich is <= k    so we can return true."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being an ass in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just find a window of size k+1 or less which contains duplicate elements, its as simple as it sound\\n"
                    }
                ]
            },
            {
                "id": 1569369,
                "content": [
                    {
                        "username": "x4snowman",
                        "content": "I am confused about this description."
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "Case 1:\\nnums = [1,2,3,1], k = 3\\nOutput: true\\n\\nDescription:\\nWe will pick only duplicate elements since nums[i] == nums[j]\\n\\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 3 so result is true\\n\\nCase 2:\\nnums = [1,2,3,1,2,3], k = 2\\nOutput: false\\n\\nDescription: \\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 2  is false condition\\n\\nIndex of first 2 is 1 and index of second 2 is 4\\nabs(1-4) <= 2 is false condition\\n\\nIndex of first 3 is 2 and index of second 3 is 5\\nabs(2-5) <= 2 is false condition\\nso overall result false\\n\\n"
                    },
                    {
                        "username": "D3press3dd",
                        "content": "[@Luna-martinez](/Luna-martinez) can you explain it? because i dont get it"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Yes description was a little confusing, but i get the statement."
                    },
                    {
                        "username": "DontSuCharlie",
                        "content": "Why not just say something along the lines of \"Find 2 numbers in the array that are equal and are at most `k` apart from each other.\"?"
                    },
                    {
                        "username": "enkil2003",
                        "content": "because monkeys write these statements."
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "haha, true :)"
                    },
                    {
                        "username": "NAS380",
                        "content": "thanks for that. now I could understand, question not clear"
                    },
                    {
                        "username": "kbventures",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) This is someone you don\\'t want to work with. "
                    },
                    {
                        "username": "jawaditani",
                        "content": "Actually that helped me understand the question, thank you."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being a condescending bitch in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "That\\'s what programming is all about, that\\'s what problem solving is all about, haven\\'t you saw math problems in school, we have to do the exact same stuff but they set the statement of problem such that it was not obvious to do that\\n"
                    },
                    {
                        "username": "zlgy126",
                        "content": "It feels like the question is super unclear."
                    },
                    {
                        "username": "Kaltu",
                        "content": "it\\'s funny while the description is unclear as fuck but if you literal translate what it says to code you get the correct solution"
                    },
                    {
                        "username": "Maheshkumar_2021",
                        "content": "agree"
                    },
                    {
                        "username": "sarocky",
                        "content": "agree"
                    },
                    {
                        "username": "ankithoney",
                        "content": "For this problem, the below test case is wrong:\\nnums = [99,99]\\nk = 2\\n\\nThe correct testcase should be nums = [99,99], k =1.\\n\\nBecause of it I am not able to submit my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "What kind of arcane implementations do you produce so that relation k to the size of the array matters? Doing loops inside loops? It can be solved in linear time with linear memory usage.\n114ms\nBeats 97.46%of users with C++\n76.73MB\nBeats 86.56%of users with C++\n\nAnd the function body is 9 lines long, it's an absolute STL-based no-brainer. I'll try an AMT-based solution just on general principle to beat the remaining 2.54% and 13.44%, respectively."
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@zabuli](/zabuli) Yaa even i missed that part lol\\uD83D\\uDE02"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Priyanshu_singh08](/Priyanshu_singh08)  the testcase isn\\'t wrong, you should read the description again..."
                    },
                    {
                        "username": "zabuli",
                        "content": "When you read the description, abs(i - j) <= k, so abs(0 - 1) == 1 => 1 <= 2 and also 1 <= 1, so for both cases it\\'s true."
                    },
                    {
                        "username": "Priyanshu_singh08",
                        "content": "same here , this test case is wrong"
                    },
                    {
                        "username": "marinospappas",
                        "content": "fully agree - wrong test cases... my code was also stuck in this one..."
                    },
                    {
                        "username": "naikv94",
                        "content": "same issue\\n"
                    },
                    {
                        "username": "Ajay019",
                        "content": "your whole logic becomes wrong at this test case\\n"
                    },
                    {
                        "username": "user5823Dt",
                        "content": "have the same issue"
                    },
                    {
                        "username": "malegkin",
                        "content": "BE CAREFUL!!! LESS OR EQUAL!!\\nabs(i - j) <= k"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@mrboombox](/mrboombox)  test case is not wrong, its just the window size is greater than the array size, which means you have to find duplicate elements in whole array, do apply a restriction such that you are not accessing element outside the array\\n"
                    },
                    {
                        "username": "mrboombox",
                        "content": "I have the same issue\\n"
                    },
                    {
                        "username": "dddxhh",
                        "content": "The testcases for this problem are too weak.\\n\\nIn my first AC solution, I wrote the code\\n\\n    if (n < k) return false;\\n\\n, where n is the length of the array.\\n\\nClearly, it is wrong(e.g. `nums = {2,2}, k = 3`).\\n\\n\\nI think the admin should do more serious test before a new problem coming online."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "In this example we can satisfy the given condition abs(i - j) <= k"
                    },
                    {
                        "username": "ShuoGuo89",
                        "content": "Could anyone tell me why the test case below is true?\\n\\n[1,0,1,1]\\n1\\n\\nThe largest difference should be 2 which is greater than k = 1. Isn't it?\\nMany thanks!"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "nums[2] == nums[3] also abs(3-2) <=1"
                    },
                    {
                        "username": "Mridul3217",
                        "content": "the question didn\\'t ask for largest difference. It said check if at any index i and j where nums[i] == nums[j] && abs(j-i)<=k. therefore index 2 and 3 fulfils this condition so it is true."
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Do not spam Answers in the Discussion Chat. Avoid it."
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "I\\'m getting TLE like this \\n\\nTime Limit Exceeded\\nLast Executed Input\\n54 / 54 testcases passed\\nnums =\\n\\n"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "same here who tf put that case. "
                    },
                    {
                        "username": "D3press3dd",
                        "content": "Why is this case false? [1,2,3,1,2,3], k = 2\\nthe number 3 is in position 2 and 5, that means Math.abs(2-5) === 3\\n3 >= this is false, so this does not fit the case and i have to return true\\n\\nam i confused?"
                    },
                    {
                        "username": "icancode96",
                        "content": "the result must be <= 2, while 3 > 2"
                    },
                    {
                        "username": "neil90",
                        "content": "Can anybody elaborate on what its asking for?"
                    },
                    {
                        "username": "anchurimanideep1",
                        "content": "[@jithinbp](/jithinbp) crystal clear"
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "[@jithinbp](/jithinbp) then what about testcase 2 , here input is [1,0,1,1] and k=1 .here one comes 0th index and 2nd index. so abs =|0-2| = 2 \\nwhich is not <=1 . so answer  must be false according to your explanation. but the real answer is true. can you clarify this for me .I am totally confused"
                    },
                    {
                        "username": "gautamgupta",
                        "content": "[@jithinbp](/jithinbp)  thats helpfull bro"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@sharforaz_rahman] Happy to hear that bro\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "[@jithinbp](/jithinbp)  Thank you brother, it\\'s indeed a great explanation "
                    },
                    {
                        "username": "jithinbp",
                        "content": "you have been given an integers array nums and an integer K.\\n\\nif you find any duplicate elements and the absolute difference between there indices gives you a value <= k then you can return true.\\n\\nif you couldn\\'t find such element you can return false.\\n\\neg:   nums[] = {4, 3, 1, 4}  k = 5       indices of 4 is : 0 , 3 \\nthe abs value of indices = |0 - 3| = 3 \\nwhich is <= k    so we can return true."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being an ass in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just find a window of size k+1 or less which contains duplicate elements, its as simple as it sound\\n"
                    }
                ]
            },
            {
                "id": 1565317,
                "content": [
                    {
                        "username": "x4snowman",
                        "content": "I am confused about this description."
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "Case 1:\\nnums = [1,2,3,1], k = 3\\nOutput: true\\n\\nDescription:\\nWe will pick only duplicate elements since nums[i] == nums[j]\\n\\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 3 so result is true\\n\\nCase 2:\\nnums = [1,2,3,1,2,3], k = 2\\nOutput: false\\n\\nDescription: \\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 2  is false condition\\n\\nIndex of first 2 is 1 and index of second 2 is 4\\nabs(1-4) <= 2 is false condition\\n\\nIndex of first 3 is 2 and index of second 3 is 5\\nabs(2-5) <= 2 is false condition\\nso overall result false\\n\\n"
                    },
                    {
                        "username": "D3press3dd",
                        "content": "[@Luna-martinez](/Luna-martinez) can you explain it? because i dont get it"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Yes description was a little confusing, but i get the statement."
                    },
                    {
                        "username": "DontSuCharlie",
                        "content": "Why not just say something along the lines of \"Find 2 numbers in the array that are equal and are at most `k` apart from each other.\"?"
                    },
                    {
                        "username": "enkil2003",
                        "content": "because monkeys write these statements."
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "haha, true :)"
                    },
                    {
                        "username": "NAS380",
                        "content": "thanks for that. now I could understand, question not clear"
                    },
                    {
                        "username": "kbventures",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) This is someone you don\\'t want to work with. "
                    },
                    {
                        "username": "jawaditani",
                        "content": "Actually that helped me understand the question, thank you."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being a condescending bitch in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "That\\'s what programming is all about, that\\'s what problem solving is all about, haven\\'t you saw math problems in school, we have to do the exact same stuff but they set the statement of problem such that it was not obvious to do that\\n"
                    },
                    {
                        "username": "zlgy126",
                        "content": "It feels like the question is super unclear."
                    },
                    {
                        "username": "Kaltu",
                        "content": "it\\'s funny while the description is unclear as fuck but if you literal translate what it says to code you get the correct solution"
                    },
                    {
                        "username": "Maheshkumar_2021",
                        "content": "agree"
                    },
                    {
                        "username": "sarocky",
                        "content": "agree"
                    },
                    {
                        "username": "ankithoney",
                        "content": "For this problem, the below test case is wrong:\\nnums = [99,99]\\nk = 2\\n\\nThe correct testcase should be nums = [99,99], k =1.\\n\\nBecause of it I am not able to submit my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "What kind of arcane implementations do you produce so that relation k to the size of the array matters? Doing loops inside loops? It can be solved in linear time with linear memory usage.\n114ms\nBeats 97.46%of users with C++\n76.73MB\nBeats 86.56%of users with C++\n\nAnd the function body is 9 lines long, it's an absolute STL-based no-brainer. I'll try an AMT-based solution just on general principle to beat the remaining 2.54% and 13.44%, respectively."
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@zabuli](/zabuli) Yaa even i missed that part lol\\uD83D\\uDE02"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Priyanshu_singh08](/Priyanshu_singh08)  the testcase isn\\'t wrong, you should read the description again..."
                    },
                    {
                        "username": "zabuli",
                        "content": "When you read the description, abs(i - j) <= k, so abs(0 - 1) == 1 => 1 <= 2 and also 1 <= 1, so for both cases it\\'s true."
                    },
                    {
                        "username": "Priyanshu_singh08",
                        "content": "same here , this test case is wrong"
                    },
                    {
                        "username": "marinospappas",
                        "content": "fully agree - wrong test cases... my code was also stuck in this one..."
                    },
                    {
                        "username": "naikv94",
                        "content": "same issue\\n"
                    },
                    {
                        "username": "Ajay019",
                        "content": "your whole logic becomes wrong at this test case\\n"
                    },
                    {
                        "username": "user5823Dt",
                        "content": "have the same issue"
                    },
                    {
                        "username": "malegkin",
                        "content": "BE CAREFUL!!! LESS OR EQUAL!!\\nabs(i - j) <= k"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@mrboombox](/mrboombox)  test case is not wrong, its just the window size is greater than the array size, which means you have to find duplicate elements in whole array, do apply a restriction such that you are not accessing element outside the array\\n"
                    },
                    {
                        "username": "mrboombox",
                        "content": "I have the same issue\\n"
                    },
                    {
                        "username": "dddxhh",
                        "content": "The testcases for this problem are too weak.\\n\\nIn my first AC solution, I wrote the code\\n\\n    if (n < k) return false;\\n\\n, where n is the length of the array.\\n\\nClearly, it is wrong(e.g. `nums = {2,2}, k = 3`).\\n\\n\\nI think the admin should do more serious test before a new problem coming online."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "In this example we can satisfy the given condition abs(i - j) <= k"
                    },
                    {
                        "username": "ShuoGuo89",
                        "content": "Could anyone tell me why the test case below is true?\\n\\n[1,0,1,1]\\n1\\n\\nThe largest difference should be 2 which is greater than k = 1. Isn't it?\\nMany thanks!"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "nums[2] == nums[3] also abs(3-2) <=1"
                    },
                    {
                        "username": "Mridul3217",
                        "content": "the question didn\\'t ask for largest difference. It said check if at any index i and j where nums[i] == nums[j] && abs(j-i)<=k. therefore index 2 and 3 fulfils this condition so it is true."
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Do not spam Answers in the Discussion Chat. Avoid it."
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "I\\'m getting TLE like this \\n\\nTime Limit Exceeded\\nLast Executed Input\\n54 / 54 testcases passed\\nnums =\\n\\n"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "same here who tf put that case. "
                    },
                    {
                        "username": "D3press3dd",
                        "content": "Why is this case false? [1,2,3,1,2,3], k = 2\\nthe number 3 is in position 2 and 5, that means Math.abs(2-5) === 3\\n3 >= this is false, so this does not fit the case and i have to return true\\n\\nam i confused?"
                    },
                    {
                        "username": "icancode96",
                        "content": "the result must be <= 2, while 3 > 2"
                    },
                    {
                        "username": "neil90",
                        "content": "Can anybody elaborate on what its asking for?"
                    },
                    {
                        "username": "anchurimanideep1",
                        "content": "[@jithinbp](/jithinbp) crystal clear"
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "[@jithinbp](/jithinbp) then what about testcase 2 , here input is [1,0,1,1] and k=1 .here one comes 0th index and 2nd index. so abs =|0-2| = 2 \\nwhich is not <=1 . so answer  must be false according to your explanation. but the real answer is true. can you clarify this for me .I am totally confused"
                    },
                    {
                        "username": "gautamgupta",
                        "content": "[@jithinbp](/jithinbp)  thats helpfull bro"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@sharforaz_rahman] Happy to hear that bro\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "[@jithinbp](/jithinbp)  Thank you brother, it\\'s indeed a great explanation "
                    },
                    {
                        "username": "jithinbp",
                        "content": "you have been given an integers array nums and an integer K.\\n\\nif you find any duplicate elements and the absolute difference between there indices gives you a value <= k then you can return true.\\n\\nif you couldn\\'t find such element you can return false.\\n\\neg:   nums[] = {4, 3, 1, 4}  k = 5       indices of 4 is : 0 , 3 \\nthe abs value of indices = |0 - 3| = 3 \\nwhich is <= k    so we can return true."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being an ass in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just find a window of size k+1 or less which contains duplicate elements, its as simple as it sound\\n"
                    }
                ]
            },
            {
                "id": 1569029,
                "content": [
                    {
                        "username": "x4snowman",
                        "content": "I am confused about this description."
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "Case 1:\\nnums = [1,2,3,1], k = 3\\nOutput: true\\n\\nDescription:\\nWe will pick only duplicate elements since nums[i] == nums[j]\\n\\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 3 so result is true\\n\\nCase 2:\\nnums = [1,2,3,1,2,3], k = 2\\nOutput: false\\n\\nDescription: \\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 2  is false condition\\n\\nIndex of first 2 is 1 and index of second 2 is 4\\nabs(1-4) <= 2 is false condition\\n\\nIndex of first 3 is 2 and index of second 3 is 5\\nabs(2-5) <= 2 is false condition\\nso overall result false\\n\\n"
                    },
                    {
                        "username": "D3press3dd",
                        "content": "[@Luna-martinez](/Luna-martinez) can you explain it? because i dont get it"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Yes description was a little confusing, but i get the statement."
                    },
                    {
                        "username": "DontSuCharlie",
                        "content": "Why not just say something along the lines of \"Find 2 numbers in the array that are equal and are at most `k` apart from each other.\"?"
                    },
                    {
                        "username": "enkil2003",
                        "content": "because monkeys write these statements."
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "haha, true :)"
                    },
                    {
                        "username": "NAS380",
                        "content": "thanks for that. now I could understand, question not clear"
                    },
                    {
                        "username": "kbventures",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) This is someone you don\\'t want to work with. "
                    },
                    {
                        "username": "jawaditani",
                        "content": "Actually that helped me understand the question, thank you."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being a condescending bitch in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "That\\'s what programming is all about, that\\'s what problem solving is all about, haven\\'t you saw math problems in school, we have to do the exact same stuff but they set the statement of problem such that it was not obvious to do that\\n"
                    },
                    {
                        "username": "zlgy126",
                        "content": "It feels like the question is super unclear."
                    },
                    {
                        "username": "Kaltu",
                        "content": "it\\'s funny while the description is unclear as fuck but if you literal translate what it says to code you get the correct solution"
                    },
                    {
                        "username": "Maheshkumar_2021",
                        "content": "agree"
                    },
                    {
                        "username": "sarocky",
                        "content": "agree"
                    },
                    {
                        "username": "ankithoney",
                        "content": "For this problem, the below test case is wrong:\\nnums = [99,99]\\nk = 2\\n\\nThe correct testcase should be nums = [99,99], k =1.\\n\\nBecause of it I am not able to submit my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "What kind of arcane implementations do you produce so that relation k to the size of the array matters? Doing loops inside loops? It can be solved in linear time with linear memory usage.\n114ms\nBeats 97.46%of users with C++\n76.73MB\nBeats 86.56%of users with C++\n\nAnd the function body is 9 lines long, it's an absolute STL-based no-brainer. I'll try an AMT-based solution just on general principle to beat the remaining 2.54% and 13.44%, respectively."
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@zabuli](/zabuli) Yaa even i missed that part lol\\uD83D\\uDE02"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Priyanshu_singh08](/Priyanshu_singh08)  the testcase isn\\'t wrong, you should read the description again..."
                    },
                    {
                        "username": "zabuli",
                        "content": "When you read the description, abs(i - j) <= k, so abs(0 - 1) == 1 => 1 <= 2 and also 1 <= 1, so for both cases it\\'s true."
                    },
                    {
                        "username": "Priyanshu_singh08",
                        "content": "same here , this test case is wrong"
                    },
                    {
                        "username": "marinospappas",
                        "content": "fully agree - wrong test cases... my code was also stuck in this one..."
                    },
                    {
                        "username": "naikv94",
                        "content": "same issue\\n"
                    },
                    {
                        "username": "Ajay019",
                        "content": "your whole logic becomes wrong at this test case\\n"
                    },
                    {
                        "username": "user5823Dt",
                        "content": "have the same issue"
                    },
                    {
                        "username": "malegkin",
                        "content": "BE CAREFUL!!! LESS OR EQUAL!!\\nabs(i - j) <= k"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@mrboombox](/mrboombox)  test case is not wrong, its just the window size is greater than the array size, which means you have to find duplicate elements in whole array, do apply a restriction such that you are not accessing element outside the array\\n"
                    },
                    {
                        "username": "mrboombox",
                        "content": "I have the same issue\\n"
                    },
                    {
                        "username": "dddxhh",
                        "content": "The testcases for this problem are too weak.\\n\\nIn my first AC solution, I wrote the code\\n\\n    if (n < k) return false;\\n\\n, where n is the length of the array.\\n\\nClearly, it is wrong(e.g. `nums = {2,2}, k = 3`).\\n\\n\\nI think the admin should do more serious test before a new problem coming online."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "In this example we can satisfy the given condition abs(i - j) <= k"
                    },
                    {
                        "username": "ShuoGuo89",
                        "content": "Could anyone tell me why the test case below is true?\\n\\n[1,0,1,1]\\n1\\n\\nThe largest difference should be 2 which is greater than k = 1. Isn't it?\\nMany thanks!"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "nums[2] == nums[3] also abs(3-2) <=1"
                    },
                    {
                        "username": "Mridul3217",
                        "content": "the question didn\\'t ask for largest difference. It said check if at any index i and j where nums[i] == nums[j] && abs(j-i)<=k. therefore index 2 and 3 fulfils this condition so it is true."
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Do not spam Answers in the Discussion Chat. Avoid it."
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "I\\'m getting TLE like this \\n\\nTime Limit Exceeded\\nLast Executed Input\\n54 / 54 testcases passed\\nnums =\\n\\n"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "same here who tf put that case. "
                    },
                    {
                        "username": "D3press3dd",
                        "content": "Why is this case false? [1,2,3,1,2,3], k = 2\\nthe number 3 is in position 2 and 5, that means Math.abs(2-5) === 3\\n3 >= this is false, so this does not fit the case and i have to return true\\n\\nam i confused?"
                    },
                    {
                        "username": "icancode96",
                        "content": "the result must be <= 2, while 3 > 2"
                    },
                    {
                        "username": "neil90",
                        "content": "Can anybody elaborate on what its asking for?"
                    },
                    {
                        "username": "anchurimanideep1",
                        "content": "[@jithinbp](/jithinbp) crystal clear"
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "[@jithinbp](/jithinbp) then what about testcase 2 , here input is [1,0,1,1] and k=1 .here one comes 0th index and 2nd index. so abs =|0-2| = 2 \\nwhich is not <=1 . so answer  must be false according to your explanation. but the real answer is true. can you clarify this for me .I am totally confused"
                    },
                    {
                        "username": "gautamgupta",
                        "content": "[@jithinbp](/jithinbp)  thats helpfull bro"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@sharforaz_rahman] Happy to hear that bro\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "[@jithinbp](/jithinbp)  Thank you brother, it\\'s indeed a great explanation "
                    },
                    {
                        "username": "jithinbp",
                        "content": "you have been given an integers array nums and an integer K.\\n\\nif you find any duplicate elements and the absolute difference between there indices gives you a value <= k then you can return true.\\n\\nif you couldn\\'t find such element you can return false.\\n\\neg:   nums[] = {4, 3, 1, 4}  k = 5       indices of 4 is : 0 , 3 \\nthe abs value of indices = |0 - 3| = 3 \\nwhich is <= k    so we can return true."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being an ass in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just find a window of size k+1 or less which contains duplicate elements, its as simple as it sound\\n"
                    }
                ]
            },
            {
                "id": 1699173,
                "content": [
                    {
                        "username": "x4snowman",
                        "content": "I am confused about this description."
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "Case 1:\\nnums = [1,2,3,1], k = 3\\nOutput: true\\n\\nDescription:\\nWe will pick only duplicate elements since nums[i] == nums[j]\\n\\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 3 so result is true\\n\\nCase 2:\\nnums = [1,2,3,1,2,3], k = 2\\nOutput: false\\n\\nDescription: \\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 2  is false condition\\n\\nIndex of first 2 is 1 and index of second 2 is 4\\nabs(1-4) <= 2 is false condition\\n\\nIndex of first 3 is 2 and index of second 3 is 5\\nabs(2-5) <= 2 is false condition\\nso overall result false\\n\\n"
                    },
                    {
                        "username": "D3press3dd",
                        "content": "[@Luna-martinez](/Luna-martinez) can you explain it? because i dont get it"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Yes description was a little confusing, but i get the statement."
                    },
                    {
                        "username": "DontSuCharlie",
                        "content": "Why not just say something along the lines of \"Find 2 numbers in the array that are equal and are at most `k` apart from each other.\"?"
                    },
                    {
                        "username": "enkil2003",
                        "content": "because monkeys write these statements."
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "haha, true :)"
                    },
                    {
                        "username": "NAS380",
                        "content": "thanks for that. now I could understand, question not clear"
                    },
                    {
                        "username": "kbventures",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) This is someone you don\\'t want to work with. "
                    },
                    {
                        "username": "jawaditani",
                        "content": "Actually that helped me understand the question, thank you."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being a condescending bitch in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "That\\'s what programming is all about, that\\'s what problem solving is all about, haven\\'t you saw math problems in school, we have to do the exact same stuff but they set the statement of problem such that it was not obvious to do that\\n"
                    },
                    {
                        "username": "zlgy126",
                        "content": "It feels like the question is super unclear."
                    },
                    {
                        "username": "Kaltu",
                        "content": "it\\'s funny while the description is unclear as fuck but if you literal translate what it says to code you get the correct solution"
                    },
                    {
                        "username": "Maheshkumar_2021",
                        "content": "agree"
                    },
                    {
                        "username": "sarocky",
                        "content": "agree"
                    },
                    {
                        "username": "ankithoney",
                        "content": "For this problem, the below test case is wrong:\\nnums = [99,99]\\nk = 2\\n\\nThe correct testcase should be nums = [99,99], k =1.\\n\\nBecause of it I am not able to submit my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "What kind of arcane implementations do you produce so that relation k to the size of the array matters? Doing loops inside loops? It can be solved in linear time with linear memory usage.\n114ms\nBeats 97.46%of users with C++\n76.73MB\nBeats 86.56%of users with C++\n\nAnd the function body is 9 lines long, it's an absolute STL-based no-brainer. I'll try an AMT-based solution just on general principle to beat the remaining 2.54% and 13.44%, respectively."
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@zabuli](/zabuli) Yaa even i missed that part lol\\uD83D\\uDE02"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Priyanshu_singh08](/Priyanshu_singh08)  the testcase isn\\'t wrong, you should read the description again..."
                    },
                    {
                        "username": "zabuli",
                        "content": "When you read the description, abs(i - j) <= k, so abs(0 - 1) == 1 => 1 <= 2 and also 1 <= 1, so for both cases it\\'s true."
                    },
                    {
                        "username": "Priyanshu_singh08",
                        "content": "same here , this test case is wrong"
                    },
                    {
                        "username": "marinospappas",
                        "content": "fully agree - wrong test cases... my code was also stuck in this one..."
                    },
                    {
                        "username": "naikv94",
                        "content": "same issue\\n"
                    },
                    {
                        "username": "Ajay019",
                        "content": "your whole logic becomes wrong at this test case\\n"
                    },
                    {
                        "username": "user5823Dt",
                        "content": "have the same issue"
                    },
                    {
                        "username": "malegkin",
                        "content": "BE CAREFUL!!! LESS OR EQUAL!!\\nabs(i - j) <= k"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@mrboombox](/mrboombox)  test case is not wrong, its just the window size is greater than the array size, which means you have to find duplicate elements in whole array, do apply a restriction such that you are not accessing element outside the array\\n"
                    },
                    {
                        "username": "mrboombox",
                        "content": "I have the same issue\\n"
                    },
                    {
                        "username": "dddxhh",
                        "content": "The testcases for this problem are too weak.\\n\\nIn my first AC solution, I wrote the code\\n\\n    if (n < k) return false;\\n\\n, where n is the length of the array.\\n\\nClearly, it is wrong(e.g. `nums = {2,2}, k = 3`).\\n\\n\\nI think the admin should do more serious test before a new problem coming online."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "In this example we can satisfy the given condition abs(i - j) <= k"
                    },
                    {
                        "username": "ShuoGuo89",
                        "content": "Could anyone tell me why the test case below is true?\\n\\n[1,0,1,1]\\n1\\n\\nThe largest difference should be 2 which is greater than k = 1. Isn't it?\\nMany thanks!"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "nums[2] == nums[3] also abs(3-2) <=1"
                    },
                    {
                        "username": "Mridul3217",
                        "content": "the question didn\\'t ask for largest difference. It said check if at any index i and j where nums[i] == nums[j] && abs(j-i)<=k. therefore index 2 and 3 fulfils this condition so it is true."
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Do not spam Answers in the Discussion Chat. Avoid it."
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "I\\'m getting TLE like this \\n\\nTime Limit Exceeded\\nLast Executed Input\\n54 / 54 testcases passed\\nnums =\\n\\n"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "same here who tf put that case. "
                    },
                    {
                        "username": "D3press3dd",
                        "content": "Why is this case false? [1,2,3,1,2,3], k = 2\\nthe number 3 is in position 2 and 5, that means Math.abs(2-5) === 3\\n3 >= this is false, so this does not fit the case and i have to return true\\n\\nam i confused?"
                    },
                    {
                        "username": "icancode96",
                        "content": "the result must be <= 2, while 3 > 2"
                    },
                    {
                        "username": "neil90",
                        "content": "Can anybody elaborate on what its asking for?"
                    },
                    {
                        "username": "anchurimanideep1",
                        "content": "[@jithinbp](/jithinbp) crystal clear"
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "[@jithinbp](/jithinbp) then what about testcase 2 , here input is [1,0,1,1] and k=1 .here one comes 0th index and 2nd index. so abs =|0-2| = 2 \\nwhich is not <=1 . so answer  must be false according to your explanation. but the real answer is true. can you clarify this for me .I am totally confused"
                    },
                    {
                        "username": "gautamgupta",
                        "content": "[@jithinbp](/jithinbp)  thats helpfull bro"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@sharforaz_rahman] Happy to hear that bro\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "[@jithinbp](/jithinbp)  Thank you brother, it\\'s indeed a great explanation "
                    },
                    {
                        "username": "jithinbp",
                        "content": "you have been given an integers array nums and an integer K.\\n\\nif you find any duplicate elements and the absolute difference between there indices gives you a value <= k then you can return true.\\n\\nif you couldn\\'t find such element you can return false.\\n\\neg:   nums[] = {4, 3, 1, 4}  k = 5       indices of 4 is : 0 , 3 \\nthe abs value of indices = |0 - 3| = 3 \\nwhich is <= k    so we can return true."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being an ass in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just find a window of size k+1 or less which contains duplicate elements, its as simple as it sound\\n"
                    }
                ]
            },
            {
                "id": 1810608,
                "content": [
                    {
                        "username": "x4snowman",
                        "content": "I am confused about this description."
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "Case 1:\\nnums = [1,2,3,1], k = 3\\nOutput: true\\n\\nDescription:\\nWe will pick only duplicate elements since nums[i] == nums[j]\\n\\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 3 so result is true\\n\\nCase 2:\\nnums = [1,2,3,1,2,3], k = 2\\nOutput: false\\n\\nDescription: \\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 2  is false condition\\n\\nIndex of first 2 is 1 and index of second 2 is 4\\nabs(1-4) <= 2 is false condition\\n\\nIndex of first 3 is 2 and index of second 3 is 5\\nabs(2-5) <= 2 is false condition\\nso overall result false\\n\\n"
                    },
                    {
                        "username": "D3press3dd",
                        "content": "[@Luna-martinez](/Luna-martinez) can you explain it? because i dont get it"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Yes description was a little confusing, but i get the statement."
                    },
                    {
                        "username": "DontSuCharlie",
                        "content": "Why not just say something along the lines of \"Find 2 numbers in the array that are equal and are at most `k` apart from each other.\"?"
                    },
                    {
                        "username": "enkil2003",
                        "content": "because monkeys write these statements."
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "haha, true :)"
                    },
                    {
                        "username": "NAS380",
                        "content": "thanks for that. now I could understand, question not clear"
                    },
                    {
                        "username": "kbventures",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) This is someone you don\\'t want to work with. "
                    },
                    {
                        "username": "jawaditani",
                        "content": "Actually that helped me understand the question, thank you."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being a condescending bitch in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "That\\'s what programming is all about, that\\'s what problem solving is all about, haven\\'t you saw math problems in school, we have to do the exact same stuff but they set the statement of problem such that it was not obvious to do that\\n"
                    },
                    {
                        "username": "zlgy126",
                        "content": "It feels like the question is super unclear."
                    },
                    {
                        "username": "Kaltu",
                        "content": "it\\'s funny while the description is unclear as fuck but if you literal translate what it says to code you get the correct solution"
                    },
                    {
                        "username": "Maheshkumar_2021",
                        "content": "agree"
                    },
                    {
                        "username": "sarocky",
                        "content": "agree"
                    },
                    {
                        "username": "ankithoney",
                        "content": "For this problem, the below test case is wrong:\\nnums = [99,99]\\nk = 2\\n\\nThe correct testcase should be nums = [99,99], k =1.\\n\\nBecause of it I am not able to submit my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "What kind of arcane implementations do you produce so that relation k to the size of the array matters? Doing loops inside loops? It can be solved in linear time with linear memory usage.\n114ms\nBeats 97.46%of users with C++\n76.73MB\nBeats 86.56%of users with C++\n\nAnd the function body is 9 lines long, it's an absolute STL-based no-brainer. I'll try an AMT-based solution just on general principle to beat the remaining 2.54% and 13.44%, respectively."
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@zabuli](/zabuli) Yaa even i missed that part lol\\uD83D\\uDE02"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Priyanshu_singh08](/Priyanshu_singh08)  the testcase isn\\'t wrong, you should read the description again..."
                    },
                    {
                        "username": "zabuli",
                        "content": "When you read the description, abs(i - j) <= k, so abs(0 - 1) == 1 => 1 <= 2 and also 1 <= 1, so for both cases it\\'s true."
                    },
                    {
                        "username": "Priyanshu_singh08",
                        "content": "same here , this test case is wrong"
                    },
                    {
                        "username": "marinospappas",
                        "content": "fully agree - wrong test cases... my code was also stuck in this one..."
                    },
                    {
                        "username": "naikv94",
                        "content": "same issue\\n"
                    },
                    {
                        "username": "Ajay019",
                        "content": "your whole logic becomes wrong at this test case\\n"
                    },
                    {
                        "username": "user5823Dt",
                        "content": "have the same issue"
                    },
                    {
                        "username": "malegkin",
                        "content": "BE CAREFUL!!! LESS OR EQUAL!!\\nabs(i - j) <= k"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@mrboombox](/mrboombox)  test case is not wrong, its just the window size is greater than the array size, which means you have to find duplicate elements in whole array, do apply a restriction such that you are not accessing element outside the array\\n"
                    },
                    {
                        "username": "mrboombox",
                        "content": "I have the same issue\\n"
                    },
                    {
                        "username": "dddxhh",
                        "content": "The testcases for this problem are too weak.\\n\\nIn my first AC solution, I wrote the code\\n\\n    if (n < k) return false;\\n\\n, where n is the length of the array.\\n\\nClearly, it is wrong(e.g. `nums = {2,2}, k = 3`).\\n\\n\\nI think the admin should do more serious test before a new problem coming online."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "In this example we can satisfy the given condition abs(i - j) <= k"
                    },
                    {
                        "username": "ShuoGuo89",
                        "content": "Could anyone tell me why the test case below is true?\\n\\n[1,0,1,1]\\n1\\n\\nThe largest difference should be 2 which is greater than k = 1. Isn't it?\\nMany thanks!"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "nums[2] == nums[3] also abs(3-2) <=1"
                    },
                    {
                        "username": "Mridul3217",
                        "content": "the question didn\\'t ask for largest difference. It said check if at any index i and j where nums[i] == nums[j] && abs(j-i)<=k. therefore index 2 and 3 fulfils this condition so it is true."
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Do not spam Answers in the Discussion Chat. Avoid it."
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "I\\'m getting TLE like this \\n\\nTime Limit Exceeded\\nLast Executed Input\\n54 / 54 testcases passed\\nnums =\\n\\n"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "same here who tf put that case. "
                    },
                    {
                        "username": "D3press3dd",
                        "content": "Why is this case false? [1,2,3,1,2,3], k = 2\\nthe number 3 is in position 2 and 5, that means Math.abs(2-5) === 3\\n3 >= this is false, so this does not fit the case and i have to return true\\n\\nam i confused?"
                    },
                    {
                        "username": "icancode96",
                        "content": "the result must be <= 2, while 3 > 2"
                    },
                    {
                        "username": "neil90",
                        "content": "Can anybody elaborate on what its asking for?"
                    },
                    {
                        "username": "anchurimanideep1",
                        "content": "[@jithinbp](/jithinbp) crystal clear"
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "[@jithinbp](/jithinbp) then what about testcase 2 , here input is [1,0,1,1] and k=1 .here one comes 0th index and 2nd index. so abs =|0-2| = 2 \\nwhich is not <=1 . so answer  must be false according to your explanation. but the real answer is true. can you clarify this for me .I am totally confused"
                    },
                    {
                        "username": "gautamgupta",
                        "content": "[@jithinbp](/jithinbp)  thats helpfull bro"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@sharforaz_rahman] Happy to hear that bro\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "[@jithinbp](/jithinbp)  Thank you brother, it\\'s indeed a great explanation "
                    },
                    {
                        "username": "jithinbp",
                        "content": "you have been given an integers array nums and an integer K.\\n\\nif you find any duplicate elements and the absolute difference between there indices gives you a value <= k then you can return true.\\n\\nif you couldn\\'t find such element you can return false.\\n\\neg:   nums[] = {4, 3, 1, 4}  k = 5       indices of 4 is : 0 , 3 \\nthe abs value of indices = |0 - 3| = 3 \\nwhich is <= k    so we can return true."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being an ass in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just find a window of size k+1 or less which contains duplicate elements, its as simple as it sound\\n"
                    }
                ]
            },
            {
                "id": 1748694,
                "content": [
                    {
                        "username": "x4snowman",
                        "content": "I am confused about this description."
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "Case 1:\\nnums = [1,2,3,1], k = 3\\nOutput: true\\n\\nDescription:\\nWe will pick only duplicate elements since nums[i] == nums[j]\\n\\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 3 so result is true\\n\\nCase 2:\\nnums = [1,2,3,1,2,3], k = 2\\nOutput: false\\n\\nDescription: \\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 2  is false condition\\n\\nIndex of first 2 is 1 and index of second 2 is 4\\nabs(1-4) <= 2 is false condition\\n\\nIndex of first 3 is 2 and index of second 3 is 5\\nabs(2-5) <= 2 is false condition\\nso overall result false\\n\\n"
                    },
                    {
                        "username": "D3press3dd",
                        "content": "[@Luna-martinez](/Luna-martinez) can you explain it? because i dont get it"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Yes description was a little confusing, but i get the statement."
                    },
                    {
                        "username": "DontSuCharlie",
                        "content": "Why not just say something along the lines of \"Find 2 numbers in the array that are equal and are at most `k` apart from each other.\"?"
                    },
                    {
                        "username": "enkil2003",
                        "content": "because monkeys write these statements."
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "haha, true :)"
                    },
                    {
                        "username": "NAS380",
                        "content": "thanks for that. now I could understand, question not clear"
                    },
                    {
                        "username": "kbventures",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) This is someone you don\\'t want to work with. "
                    },
                    {
                        "username": "jawaditani",
                        "content": "Actually that helped me understand the question, thank you."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being a condescending bitch in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "That\\'s what programming is all about, that\\'s what problem solving is all about, haven\\'t you saw math problems in school, we have to do the exact same stuff but they set the statement of problem such that it was not obvious to do that\\n"
                    },
                    {
                        "username": "zlgy126",
                        "content": "It feels like the question is super unclear."
                    },
                    {
                        "username": "Kaltu",
                        "content": "it\\'s funny while the description is unclear as fuck but if you literal translate what it says to code you get the correct solution"
                    },
                    {
                        "username": "Maheshkumar_2021",
                        "content": "agree"
                    },
                    {
                        "username": "sarocky",
                        "content": "agree"
                    },
                    {
                        "username": "ankithoney",
                        "content": "For this problem, the below test case is wrong:\\nnums = [99,99]\\nk = 2\\n\\nThe correct testcase should be nums = [99,99], k =1.\\n\\nBecause of it I am not able to submit my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "What kind of arcane implementations do you produce so that relation k to the size of the array matters? Doing loops inside loops? It can be solved in linear time with linear memory usage.\n114ms\nBeats 97.46%of users with C++\n76.73MB\nBeats 86.56%of users with C++\n\nAnd the function body is 9 lines long, it's an absolute STL-based no-brainer. I'll try an AMT-based solution just on general principle to beat the remaining 2.54% and 13.44%, respectively."
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@zabuli](/zabuli) Yaa even i missed that part lol\\uD83D\\uDE02"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Priyanshu_singh08](/Priyanshu_singh08)  the testcase isn\\'t wrong, you should read the description again..."
                    },
                    {
                        "username": "zabuli",
                        "content": "When you read the description, abs(i - j) <= k, so abs(0 - 1) == 1 => 1 <= 2 and also 1 <= 1, so for both cases it\\'s true."
                    },
                    {
                        "username": "Priyanshu_singh08",
                        "content": "same here , this test case is wrong"
                    },
                    {
                        "username": "marinospappas",
                        "content": "fully agree - wrong test cases... my code was also stuck in this one..."
                    },
                    {
                        "username": "naikv94",
                        "content": "same issue\\n"
                    },
                    {
                        "username": "Ajay019",
                        "content": "your whole logic becomes wrong at this test case\\n"
                    },
                    {
                        "username": "user5823Dt",
                        "content": "have the same issue"
                    },
                    {
                        "username": "malegkin",
                        "content": "BE CAREFUL!!! LESS OR EQUAL!!\\nabs(i - j) <= k"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@mrboombox](/mrboombox)  test case is not wrong, its just the window size is greater than the array size, which means you have to find duplicate elements in whole array, do apply a restriction such that you are not accessing element outside the array\\n"
                    },
                    {
                        "username": "mrboombox",
                        "content": "I have the same issue\\n"
                    },
                    {
                        "username": "dddxhh",
                        "content": "The testcases for this problem are too weak.\\n\\nIn my first AC solution, I wrote the code\\n\\n    if (n < k) return false;\\n\\n, where n is the length of the array.\\n\\nClearly, it is wrong(e.g. `nums = {2,2}, k = 3`).\\n\\n\\nI think the admin should do more serious test before a new problem coming online."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "In this example we can satisfy the given condition abs(i - j) <= k"
                    },
                    {
                        "username": "ShuoGuo89",
                        "content": "Could anyone tell me why the test case below is true?\\n\\n[1,0,1,1]\\n1\\n\\nThe largest difference should be 2 which is greater than k = 1. Isn't it?\\nMany thanks!"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "nums[2] == nums[3] also abs(3-2) <=1"
                    },
                    {
                        "username": "Mridul3217",
                        "content": "the question didn\\'t ask for largest difference. It said check if at any index i and j where nums[i] == nums[j] && abs(j-i)<=k. therefore index 2 and 3 fulfils this condition so it is true."
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Do not spam Answers in the Discussion Chat. Avoid it."
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "I\\'m getting TLE like this \\n\\nTime Limit Exceeded\\nLast Executed Input\\n54 / 54 testcases passed\\nnums =\\n\\n"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "same here who tf put that case. "
                    },
                    {
                        "username": "D3press3dd",
                        "content": "Why is this case false? [1,2,3,1,2,3], k = 2\\nthe number 3 is in position 2 and 5, that means Math.abs(2-5) === 3\\n3 >= this is false, so this does not fit the case and i have to return true\\n\\nam i confused?"
                    },
                    {
                        "username": "icancode96",
                        "content": "the result must be <= 2, while 3 > 2"
                    },
                    {
                        "username": "neil90",
                        "content": "Can anybody elaborate on what its asking for?"
                    },
                    {
                        "username": "anchurimanideep1",
                        "content": "[@jithinbp](/jithinbp) crystal clear"
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "[@jithinbp](/jithinbp) then what about testcase 2 , here input is [1,0,1,1] and k=1 .here one comes 0th index and 2nd index. so abs =|0-2| = 2 \\nwhich is not <=1 . so answer  must be false according to your explanation. but the real answer is true. can you clarify this for me .I am totally confused"
                    },
                    {
                        "username": "gautamgupta",
                        "content": "[@jithinbp](/jithinbp)  thats helpfull bro"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@sharforaz_rahman] Happy to hear that bro\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "[@jithinbp](/jithinbp)  Thank you brother, it\\'s indeed a great explanation "
                    },
                    {
                        "username": "jithinbp",
                        "content": "you have been given an integers array nums and an integer K.\\n\\nif you find any duplicate elements and the absolute difference between there indices gives you a value <= k then you can return true.\\n\\nif you couldn\\'t find such element you can return false.\\n\\neg:   nums[] = {4, 3, 1, 4}  k = 5       indices of 4 is : 0 , 3 \\nthe abs value of indices = |0 - 3| = 3 \\nwhich is <= k    so we can return true."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being an ass in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just find a window of size k+1 or less which contains duplicate elements, its as simple as it sound\\n"
                    }
                ]
            },
            {
                "id": 1572318,
                "content": [
                    {
                        "username": "x4snowman",
                        "content": "I am confused about this description."
                    },
                    {
                        "username": "vibhumishra808",
                        "content": "Case 1:\\nnums = [1,2,3,1], k = 3\\nOutput: true\\n\\nDescription:\\nWe will pick only duplicate elements since nums[i] == nums[j]\\n\\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 3 so result is true\\n\\nCase 2:\\nnums = [1,2,3,1,2,3], k = 2\\nOutput: false\\n\\nDescription: \\nIndex of first 1 is 0 and index of second 1 is 3\\nabs(0-3) <= 2  is false condition\\n\\nIndex of first 2 is 1 and index of second 2 is 4\\nabs(1-4) <= 2 is false condition\\n\\nIndex of first 3 is 2 and index of second 3 is 5\\nabs(2-5) <= 2 is false condition\\nso overall result false\\n\\n"
                    },
                    {
                        "username": "D3press3dd",
                        "content": "[@Luna-martinez](/Luna-martinez) can you explain it? because i dont get it"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Yes description was a little confusing, but i get the statement."
                    },
                    {
                        "username": "DontSuCharlie",
                        "content": "Why not just say something along the lines of \"Find 2 numbers in the array that are equal and are at most `k` apart from each other.\"?"
                    },
                    {
                        "username": "enkil2003",
                        "content": "because monkeys write these statements."
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "haha, true :)"
                    },
                    {
                        "username": "NAS380",
                        "content": "thanks for that. now I could understand, question not clear"
                    },
                    {
                        "username": "kbventures",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) This is someone you don\\'t want to work with. "
                    },
                    {
                        "username": "jawaditani",
                        "content": "Actually that helped me understand the question, thank you."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being a condescending bitch in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "That\\'s what programming is all about, that\\'s what problem solving is all about, haven\\'t you saw math problems in school, we have to do the exact same stuff but they set the statement of problem such that it was not obvious to do that\\n"
                    },
                    {
                        "username": "zlgy126",
                        "content": "It feels like the question is super unclear."
                    },
                    {
                        "username": "Kaltu",
                        "content": "it\\'s funny while the description is unclear as fuck but if you literal translate what it says to code you get the correct solution"
                    },
                    {
                        "username": "Maheshkumar_2021",
                        "content": "agree"
                    },
                    {
                        "username": "sarocky",
                        "content": "agree"
                    },
                    {
                        "username": "ankithoney",
                        "content": "For this problem, the below test case is wrong:\\nnums = [99,99]\\nk = 2\\n\\nThe correct testcase should be nums = [99,99], k =1.\\n\\nBecause of it I am not able to submit my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "What kind of arcane implementations do you produce so that relation k to the size of the array matters? Doing loops inside loops? It can be solved in linear time with linear memory usage.\n114ms\nBeats 97.46%of users with C++\n76.73MB\nBeats 86.56%of users with C++\n\nAnd the function body is 9 lines long, it's an absolute STL-based no-brainer. I'll try an AMT-based solution just on general principle to beat the remaining 2.54% and 13.44%, respectively."
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@zabuli](/zabuli) Yaa even i missed that part lol\\uD83D\\uDE02"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@Priyanshu_singh08](/Priyanshu_singh08)  the testcase isn\\'t wrong, you should read the description again..."
                    },
                    {
                        "username": "zabuli",
                        "content": "When you read the description, abs(i - j) <= k, so abs(0 - 1) == 1 => 1 <= 2 and also 1 <= 1, so for both cases it\\'s true."
                    },
                    {
                        "username": "Priyanshu_singh08",
                        "content": "same here , this test case is wrong"
                    },
                    {
                        "username": "marinospappas",
                        "content": "fully agree - wrong test cases... my code was also stuck in this one..."
                    },
                    {
                        "username": "naikv94",
                        "content": "same issue\\n"
                    },
                    {
                        "username": "Ajay019",
                        "content": "your whole logic becomes wrong at this test case\\n"
                    },
                    {
                        "username": "user5823Dt",
                        "content": "have the same issue"
                    },
                    {
                        "username": "malegkin",
                        "content": "BE CAREFUL!!! LESS OR EQUAL!!\\nabs(i - j) <= k"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@mrboombox](/mrboombox)  test case is not wrong, its just the window size is greater than the array size, which means you have to find duplicate elements in whole array, do apply a restriction such that you are not accessing element outside the array\\n"
                    },
                    {
                        "username": "mrboombox",
                        "content": "I have the same issue\\n"
                    },
                    {
                        "username": "dddxhh",
                        "content": "The testcases for this problem are too weak.\\n\\nIn my first AC solution, I wrote the code\\n\\n    if (n < k) return false;\\n\\n, where n is the length of the array.\\n\\nClearly, it is wrong(e.g. `nums = {2,2}, k = 3`).\\n\\n\\nI think the admin should do more serious test before a new problem coming online."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "In this example we can satisfy the given condition abs(i - j) <= k"
                    },
                    {
                        "username": "ShuoGuo89",
                        "content": "Could anyone tell me why the test case below is true?\\n\\n[1,0,1,1]\\n1\\n\\nThe largest difference should be 2 which is greater than k = 1. Isn't it?\\nMany thanks!"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "nums[2] == nums[3] also abs(3-2) <=1"
                    },
                    {
                        "username": "Mridul3217",
                        "content": "the question didn\\'t ask for largest difference. It said check if at any index i and j where nums[i] == nums[j] && abs(j-i)<=k. therefore index 2 and 3 fulfils this condition so it is true."
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "Do not spam Answers in the Discussion Chat. Avoid it."
                    },
                    {
                        "username": "stevewilsonraj",
                        "content": "I\\'m getting TLE like this \\n\\nTime Limit Exceeded\\nLast Executed Input\\n54 / 54 testcases passed\\nnums =\\n\\n"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "same here who tf put that case. "
                    },
                    {
                        "username": "D3press3dd",
                        "content": "Why is this case false? [1,2,3,1,2,3], k = 2\\nthe number 3 is in position 2 and 5, that means Math.abs(2-5) === 3\\n3 >= this is false, so this does not fit the case and i have to return true\\n\\nam i confused?"
                    },
                    {
                        "username": "icancode96",
                        "content": "the result must be <= 2, while 3 > 2"
                    },
                    {
                        "username": "neil90",
                        "content": "Can anybody elaborate on what its asking for?"
                    },
                    {
                        "username": "anchurimanideep1",
                        "content": "[@jithinbp](/jithinbp) crystal clear"
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "[@jithinbp](/jithinbp) then what about testcase 2 , here input is [1,0,1,1] and k=1 .here one comes 0th index and 2nd index. so abs =|0-2| = 2 \\nwhich is not <=1 . so answer  must be false according to your explanation. but the real answer is true. can you clarify this for me .I am totally confused"
                    },
                    {
                        "username": "gautamgupta",
                        "content": "[@jithinbp](/jithinbp)  thats helpfull bro"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@sharforaz_rahman] Happy to hear that bro\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "[@jithinbp](/jithinbp)  Thank you brother, it\\'s indeed a great explanation "
                    },
                    {
                        "username": "jithinbp",
                        "content": "you have been given an integers array nums and an integer K.\\n\\nif you find any duplicate elements and the absolute difference between there indices gives you a value <= k then you can return true.\\n\\nif you couldn\\'t find such element you can return false.\\n\\neg:   nums[] = {4, 3, 1, 4}  k = 5       indices of 4 is : 0 , 3 \\nthe abs value of indices = |0 - 3| = 3 \\nwhich is <= k    so we can return true."
                    },
                    {
                        "username": "AxeCap",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) Stop being an ass in all of your comments."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just find a window of size k+1 or less which contains duplicate elements, its as simple as it sound\\n"
                    }
                ]
            },
            {
                "id": 1870356,
                "content": [
                    {
                        "username": "Valen_04",
                        "content": "sometimes i wonder if i should re-learn my mother language "
                    },
                    {
                        "username": "CristianM92",
                        "content": "class Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        \n       for (int i = 0; i < nums.length; i++) {\n            for (int j = i+1; j < nums.length; j++) {\n                if (nums[i] == nums[j] && Math.abs(i - j) <= k){\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n\nWhy  is this Time Limit Exceeded? "
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "[@ctgallagher4](/ctgallagher4)  Don\\'t use linear search method for this question .\\n"
                    },
                    {
                        "username": "ctgallagher4",
                        "content": "because it is O(n^2) instead of O(n)"
                    },
                    {
                        "username": "rohitdavas",
                        "content": "rather than the solution proposing the self balancing tree, i would propose to using hash set. \\nsince the target using either is to have constant time lookup and constant time delete, the hash set, if implemented correctly provides the same. \\n\\ngive it a try."
                    },
                    {
                        "username": "kiwolarg",
                        "content": "![image](https://assets.leetcode.com/users/kiwolarg/image_1575695319.png)\\n\\nI was searching for the n+k for matching, in this case it should be 2(the 3rd place) and it dosen\\'t exist, so I returned it false. Am I ..... getting the question wrongly?"
                    },
                    {
                        "username": "malegkin",
                        "content": "<= k"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Window size is 3, and you can find two same element inside the window, so true is the ans"
                    },
                    {
                        "username": "AbhayDayma",
                        "content": "It shows me exceeded time limit. But passes all the test cases till 54. "
                    },
                    {
                        "username": "pugalramyaa",
                        "content": "same here "
                    },
                    {
                        "username": "CORSAiRx9",
                        "content": "*** If you're getting `Time Limit Exceeded` then you can compare `len(set(nums))` with `len(nums)`. Most of the time the testcase will just through a huge sequential series e.g. -10001, -10000, -9999, -9998..... So you can quickly use this trick to bypass the long code execution time.\n\n---\nLet's start with the 3rd example:\n-->given: nums = [1,2,3,1,2,3], k = 2\n-->conditions: nums[i]==nums[j], abs(i-j)<=k\n\nnums: [1,    2,    3,    1,    2,    3]\nindex:   0    1     2     3     4     5\n---\n\n                    [1,    2,    3,    1,    2,    3]\n                    [0---------------------->4     5]\n> We can start a loop1:  index 0 to index 4\n\n                    [1,    2,    3,    1,    2,    3]\n                    [0     1---->2     3     4     5]\n> We will start another inner loop2: index 1 to index 2\n\n> `i` as index counter for loop1, `j` as index counter for loop2.\n\n> Since we're using index value in both loops we don't want to compare the numbers with itself i.e. at index 0 both loops will have the same values if i=j. So loop2 will always start from 1 step ahead. Again at last index of `nums` loop2 and loop1 will have the same indices so loop1 has a range of `(0,len(nums)-1)`.\n\n> `max index of loop2` is `i1=(index of loop1 at any moment)+2`. Thus when loop1 starts from index 0 loop2 will have a range of `((index of loop1)+1,i1+2)`.\n..................................\nloop1 at index 0\nloop2: 1-->2\n..................................\nloop1 at index 1\nloop2: 2-->3\n..................................\nloop1 at index 2\nloop2: 3-->4\n\n> Now what would happen if loop1 is at index 4? Here `i1=4+2` which will give 6 with an error `index out of range`.\n..................................\nloop1 at index 4\nloop2: 5-->6\n\n> Till index 3 in loop1 we've maintained the condition `index of loop2 - index of loop1=2`. At index 4 for we still want i1 to be 5 i.e. `len(nums)-1`.\n\n> So we can use `i1=min((index of loop1+2), len(nums)-1)`. This way our loop2 will never get out of the index.\n\n> If someone is wondering what about `abs(i-j)<=k` then we know loop2 will always have greater indices so `abs(i-k)` is basically `index of loop2 - index of loop1`. Till index 3 in loop1 `index of loop2 - index of loop1=2`. But at index 4 `index of loop2 - index of loop1=1`  e.g. 5-4=1 since we've limited our loop2 index to `len(nums)-1`. Thus the value of `abs(i-j)` in our case will be equal to k and then it'll start decreasing and eventually end at 1.\n\n> Now in loop2 we can compare values using both loop1's and loop2's indices i.e. `if nums[i]==nums[j]` and return True.\n\n> If the loop1 runs till it's max range i.e. `len(nums)-1` then we're sure that there's no duplicate values. So we'll return False at the end.\n\n---\nFinal structure:\n---\nuse variable1 to store length of nums\ncompare if variable1 is same with len(set(nums))\n...........return False\nuse i as index counter for loop with range(0,varibale1)\n...........find max limit for j using min\n...........use j as index counter in range(i+1,max limit+1)\n......................compare if both loops have the same values\n......................return True\nreturn False\n\nHope it helps,\nThank you :)"
                    },
                    {
                        "username": "anamika12b",
                        "content": "Thanks for the check suggestion. My time limit issue got resolved because of that"
                    },
                    {
                        "username": "calm27",
                        "content": "Okay, I've managed to figure out finally this description. \nIf someone of you is confused about why sliding window, perhaps, works not perfect here and lot of your test cases failing when it is expected to be True, it is because this task is not really that much about sliding window in most common sense. \nIf you managed to resolve it with sliding window, but using `k+1`... lets say, there is a bit more elegant solution and you tried to approach it in regular way. \n\nMy only hint to not spoil solution is: focus less on fixed sliding window ''regular'' approach and more on actual condition: `abs(i-j)<=k`. Just look at the perspective from another angle and you will find it pretty easily. "
                    },
                    {
                        "username": "ac1dloop",
                        "content": "hint about data structure is helpful!"
                    },
                    {
                        "username": "pwaykar",
                        "content": "Input:\\n[99,99]\\n2\\nOutput:\\nfalse\\nExpected:\\ntrue"
                    },
                    {
                        "username": "Moh_Ghafri",
                        "content": "The question was: abs(i-j) <=k\\n`less than or equal` "
                    },
                    {
                        "username": "malegkin",
                        "content": "<= 3"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Window size is 3, and you can find two same element inside the window, so true is the ans"
                    },
                    {
                        "username": "dav3ydoo",
                        "content": "Input: nums = [1,0,1,1], k = 1\\nOutput: true\\nLet\\'s say i = 0 and j = 3.\\nthen nums[i]=nums[j]\\nThe absolute difference between i and j is 3. Which is bigger than k.  So we should return false.  Not true. Am I misunderstanding something?"
                    },
                    {
                        "username": "atulindore2",
                        "content": "nums[2] and nums[3] are equal and k =1 ...\\nWe only need a single positve case to return true "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "who tf put blank case . I will haunt you to death just you wait.\ncan you any one say how to bypass that. i can't submit for that case.(case no 56)\nit has nothing .... no array , no size nothig "
                    }
                ]
            },
            {
                "id": 1835050,
                "content": [
                    {
                        "username": "Valen_04",
                        "content": "sometimes i wonder if i should re-learn my mother language "
                    },
                    {
                        "username": "CristianM92",
                        "content": "class Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        \n       for (int i = 0; i < nums.length; i++) {\n            for (int j = i+1; j < nums.length; j++) {\n                if (nums[i] == nums[j] && Math.abs(i - j) <= k){\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n\nWhy  is this Time Limit Exceeded? "
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "[@ctgallagher4](/ctgallagher4)  Don\\'t use linear search method for this question .\\n"
                    },
                    {
                        "username": "ctgallagher4",
                        "content": "because it is O(n^2) instead of O(n)"
                    },
                    {
                        "username": "rohitdavas",
                        "content": "rather than the solution proposing the self balancing tree, i would propose to using hash set. \\nsince the target using either is to have constant time lookup and constant time delete, the hash set, if implemented correctly provides the same. \\n\\ngive it a try."
                    },
                    {
                        "username": "kiwolarg",
                        "content": "![image](https://assets.leetcode.com/users/kiwolarg/image_1575695319.png)\\n\\nI was searching for the n+k for matching, in this case it should be 2(the 3rd place) and it dosen\\'t exist, so I returned it false. Am I ..... getting the question wrongly?"
                    },
                    {
                        "username": "malegkin",
                        "content": "<= k"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Window size is 3, and you can find two same element inside the window, so true is the ans"
                    },
                    {
                        "username": "AbhayDayma",
                        "content": "It shows me exceeded time limit. But passes all the test cases till 54. "
                    },
                    {
                        "username": "pugalramyaa",
                        "content": "same here "
                    },
                    {
                        "username": "CORSAiRx9",
                        "content": "*** If you're getting `Time Limit Exceeded` then you can compare `len(set(nums))` with `len(nums)`. Most of the time the testcase will just through a huge sequential series e.g. -10001, -10000, -9999, -9998..... So you can quickly use this trick to bypass the long code execution time.\n\n---\nLet's start with the 3rd example:\n-->given: nums = [1,2,3,1,2,3], k = 2\n-->conditions: nums[i]==nums[j], abs(i-j)<=k\n\nnums: [1,    2,    3,    1,    2,    3]\nindex:   0    1     2     3     4     5\n---\n\n                    [1,    2,    3,    1,    2,    3]\n                    [0---------------------->4     5]\n> We can start a loop1:  index 0 to index 4\n\n                    [1,    2,    3,    1,    2,    3]\n                    [0     1---->2     3     4     5]\n> We will start another inner loop2: index 1 to index 2\n\n> `i` as index counter for loop1, `j` as index counter for loop2.\n\n> Since we're using index value in both loops we don't want to compare the numbers with itself i.e. at index 0 both loops will have the same values if i=j. So loop2 will always start from 1 step ahead. Again at last index of `nums` loop2 and loop1 will have the same indices so loop1 has a range of `(0,len(nums)-1)`.\n\n> `max index of loop2` is `i1=(index of loop1 at any moment)+2`. Thus when loop1 starts from index 0 loop2 will have a range of `((index of loop1)+1,i1+2)`.\n..................................\nloop1 at index 0\nloop2: 1-->2\n..................................\nloop1 at index 1\nloop2: 2-->3\n..................................\nloop1 at index 2\nloop2: 3-->4\n\n> Now what would happen if loop1 is at index 4? Here `i1=4+2` which will give 6 with an error `index out of range`.\n..................................\nloop1 at index 4\nloop2: 5-->6\n\n> Till index 3 in loop1 we've maintained the condition `index of loop2 - index of loop1=2`. At index 4 for we still want i1 to be 5 i.e. `len(nums)-1`.\n\n> So we can use `i1=min((index of loop1+2), len(nums)-1)`. This way our loop2 will never get out of the index.\n\n> If someone is wondering what about `abs(i-j)<=k` then we know loop2 will always have greater indices so `abs(i-k)` is basically `index of loop2 - index of loop1`. Till index 3 in loop1 `index of loop2 - index of loop1=2`. But at index 4 `index of loop2 - index of loop1=1`  e.g. 5-4=1 since we've limited our loop2 index to `len(nums)-1`. Thus the value of `abs(i-j)` in our case will be equal to k and then it'll start decreasing and eventually end at 1.\n\n> Now in loop2 we can compare values using both loop1's and loop2's indices i.e. `if nums[i]==nums[j]` and return True.\n\n> If the loop1 runs till it's max range i.e. `len(nums)-1` then we're sure that there's no duplicate values. So we'll return False at the end.\n\n---\nFinal structure:\n---\nuse variable1 to store length of nums\ncompare if variable1 is same with len(set(nums))\n...........return False\nuse i as index counter for loop with range(0,varibale1)\n...........find max limit for j using min\n...........use j as index counter in range(i+1,max limit+1)\n......................compare if both loops have the same values\n......................return True\nreturn False\n\nHope it helps,\nThank you :)"
                    },
                    {
                        "username": "anamika12b",
                        "content": "Thanks for the check suggestion. My time limit issue got resolved because of that"
                    },
                    {
                        "username": "calm27",
                        "content": "Okay, I've managed to figure out finally this description. \nIf someone of you is confused about why sliding window, perhaps, works not perfect here and lot of your test cases failing when it is expected to be True, it is because this task is not really that much about sliding window in most common sense. \nIf you managed to resolve it with sliding window, but using `k+1`... lets say, there is a bit more elegant solution and you tried to approach it in regular way. \n\nMy only hint to not spoil solution is: focus less on fixed sliding window ''regular'' approach and more on actual condition: `abs(i-j)<=k`. Just look at the perspective from another angle and you will find it pretty easily. "
                    },
                    {
                        "username": "ac1dloop",
                        "content": "hint about data structure is helpful!"
                    },
                    {
                        "username": "pwaykar",
                        "content": "Input:\\n[99,99]\\n2\\nOutput:\\nfalse\\nExpected:\\ntrue"
                    },
                    {
                        "username": "Moh_Ghafri",
                        "content": "The question was: abs(i-j) <=k\\n`less than or equal` "
                    },
                    {
                        "username": "malegkin",
                        "content": "<= 3"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Window size is 3, and you can find two same element inside the window, so true is the ans"
                    },
                    {
                        "username": "dav3ydoo",
                        "content": "Input: nums = [1,0,1,1], k = 1\\nOutput: true\\nLet\\'s say i = 0 and j = 3.\\nthen nums[i]=nums[j]\\nThe absolute difference between i and j is 3. Which is bigger than k.  So we should return false.  Not true. Am I misunderstanding something?"
                    },
                    {
                        "username": "atulindore2",
                        "content": "nums[2] and nums[3] are equal and k =1 ...\\nWe only need a single positve case to return true "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "who tf put blank case . I will haunt you to death just you wait.\ncan you any one say how to bypass that. i can't submit for that case.(case no 56)\nit has nothing .... no array , no size nothig "
                    }
                ]
            },
            {
                "id": 1576635,
                "content": [
                    {
                        "username": "Valen_04",
                        "content": "sometimes i wonder if i should re-learn my mother language "
                    },
                    {
                        "username": "CristianM92",
                        "content": "class Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        \n       for (int i = 0; i < nums.length; i++) {\n            for (int j = i+1; j < nums.length; j++) {\n                if (nums[i] == nums[j] && Math.abs(i - j) <= k){\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n\nWhy  is this Time Limit Exceeded? "
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "[@ctgallagher4](/ctgallagher4)  Don\\'t use linear search method for this question .\\n"
                    },
                    {
                        "username": "ctgallagher4",
                        "content": "because it is O(n^2) instead of O(n)"
                    },
                    {
                        "username": "rohitdavas",
                        "content": "rather than the solution proposing the self balancing tree, i would propose to using hash set. \\nsince the target using either is to have constant time lookup and constant time delete, the hash set, if implemented correctly provides the same. \\n\\ngive it a try."
                    },
                    {
                        "username": "kiwolarg",
                        "content": "![image](https://assets.leetcode.com/users/kiwolarg/image_1575695319.png)\\n\\nI was searching for the n+k for matching, in this case it should be 2(the 3rd place) and it dosen\\'t exist, so I returned it false. Am I ..... getting the question wrongly?"
                    },
                    {
                        "username": "malegkin",
                        "content": "<= k"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Window size is 3, and you can find two same element inside the window, so true is the ans"
                    },
                    {
                        "username": "AbhayDayma",
                        "content": "It shows me exceeded time limit. But passes all the test cases till 54. "
                    },
                    {
                        "username": "pugalramyaa",
                        "content": "same here "
                    },
                    {
                        "username": "CORSAiRx9",
                        "content": "*** If you're getting `Time Limit Exceeded` then you can compare `len(set(nums))` with `len(nums)`. Most of the time the testcase will just through a huge sequential series e.g. -10001, -10000, -9999, -9998..... So you can quickly use this trick to bypass the long code execution time.\n\n---\nLet's start with the 3rd example:\n-->given: nums = [1,2,3,1,2,3], k = 2\n-->conditions: nums[i]==nums[j], abs(i-j)<=k\n\nnums: [1,    2,    3,    1,    2,    3]\nindex:   0    1     2     3     4     5\n---\n\n                    [1,    2,    3,    1,    2,    3]\n                    [0---------------------->4     5]\n> We can start a loop1:  index 0 to index 4\n\n                    [1,    2,    3,    1,    2,    3]\n                    [0     1---->2     3     4     5]\n> We will start another inner loop2: index 1 to index 2\n\n> `i` as index counter for loop1, `j` as index counter for loop2.\n\n> Since we're using index value in both loops we don't want to compare the numbers with itself i.e. at index 0 both loops will have the same values if i=j. So loop2 will always start from 1 step ahead. Again at last index of `nums` loop2 and loop1 will have the same indices so loop1 has a range of `(0,len(nums)-1)`.\n\n> `max index of loop2` is `i1=(index of loop1 at any moment)+2`. Thus when loop1 starts from index 0 loop2 will have a range of `((index of loop1)+1,i1+2)`.\n..................................\nloop1 at index 0\nloop2: 1-->2\n..................................\nloop1 at index 1\nloop2: 2-->3\n..................................\nloop1 at index 2\nloop2: 3-->4\n\n> Now what would happen if loop1 is at index 4? Here `i1=4+2` which will give 6 with an error `index out of range`.\n..................................\nloop1 at index 4\nloop2: 5-->6\n\n> Till index 3 in loop1 we've maintained the condition `index of loop2 - index of loop1=2`. At index 4 for we still want i1 to be 5 i.e. `len(nums)-1`.\n\n> So we can use `i1=min((index of loop1+2), len(nums)-1)`. This way our loop2 will never get out of the index.\n\n> If someone is wondering what about `abs(i-j)<=k` then we know loop2 will always have greater indices so `abs(i-k)` is basically `index of loop2 - index of loop1`. Till index 3 in loop1 `index of loop2 - index of loop1=2`. But at index 4 `index of loop2 - index of loop1=1`  e.g. 5-4=1 since we've limited our loop2 index to `len(nums)-1`. Thus the value of `abs(i-j)` in our case will be equal to k and then it'll start decreasing and eventually end at 1.\n\n> Now in loop2 we can compare values using both loop1's and loop2's indices i.e. `if nums[i]==nums[j]` and return True.\n\n> If the loop1 runs till it's max range i.e. `len(nums)-1` then we're sure that there's no duplicate values. So we'll return False at the end.\n\n---\nFinal structure:\n---\nuse variable1 to store length of nums\ncompare if variable1 is same with len(set(nums))\n...........return False\nuse i as index counter for loop with range(0,varibale1)\n...........find max limit for j using min\n...........use j as index counter in range(i+1,max limit+1)\n......................compare if both loops have the same values\n......................return True\nreturn False\n\nHope it helps,\nThank you :)"
                    },
                    {
                        "username": "anamika12b",
                        "content": "Thanks for the check suggestion. My time limit issue got resolved because of that"
                    },
                    {
                        "username": "calm27",
                        "content": "Okay, I've managed to figure out finally this description. \nIf someone of you is confused about why sliding window, perhaps, works not perfect here and lot of your test cases failing when it is expected to be True, it is because this task is not really that much about sliding window in most common sense. \nIf you managed to resolve it with sliding window, but using `k+1`... lets say, there is a bit more elegant solution and you tried to approach it in regular way. \n\nMy only hint to not spoil solution is: focus less on fixed sliding window ''regular'' approach and more on actual condition: `abs(i-j)<=k`. Just look at the perspective from another angle and you will find it pretty easily. "
                    },
                    {
                        "username": "ac1dloop",
                        "content": "hint about data structure is helpful!"
                    },
                    {
                        "username": "pwaykar",
                        "content": "Input:\\n[99,99]\\n2\\nOutput:\\nfalse\\nExpected:\\ntrue"
                    },
                    {
                        "username": "Moh_Ghafri",
                        "content": "The question was: abs(i-j) <=k\\n`less than or equal` "
                    },
                    {
                        "username": "malegkin",
                        "content": "<= 3"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Window size is 3, and you can find two same element inside the window, so true is the ans"
                    },
                    {
                        "username": "dav3ydoo",
                        "content": "Input: nums = [1,0,1,1], k = 1\\nOutput: true\\nLet\\'s say i = 0 and j = 3.\\nthen nums[i]=nums[j]\\nThe absolute difference between i and j is 3. Which is bigger than k.  So we should return false.  Not true. Am I misunderstanding something?"
                    },
                    {
                        "username": "atulindore2",
                        "content": "nums[2] and nums[3] are equal and k =1 ...\\nWe only need a single positve case to return true "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "who tf put blank case . I will haunt you to death just you wait.\ncan you any one say how to bypass that. i can't submit for that case.(case no 56)\nit has nothing .... no array , no size nothig "
                    }
                ]
            },
            {
                "id": 1573241,
                "content": [
                    {
                        "username": "Valen_04",
                        "content": "sometimes i wonder if i should re-learn my mother language "
                    },
                    {
                        "username": "CristianM92",
                        "content": "class Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        \n       for (int i = 0; i < nums.length; i++) {\n            for (int j = i+1; j < nums.length; j++) {\n                if (nums[i] == nums[j] && Math.abs(i - j) <= k){\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n\nWhy  is this Time Limit Exceeded? "
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "[@ctgallagher4](/ctgallagher4)  Don\\'t use linear search method for this question .\\n"
                    },
                    {
                        "username": "ctgallagher4",
                        "content": "because it is O(n^2) instead of O(n)"
                    },
                    {
                        "username": "rohitdavas",
                        "content": "rather than the solution proposing the self balancing tree, i would propose to using hash set. \\nsince the target using either is to have constant time lookup and constant time delete, the hash set, if implemented correctly provides the same. \\n\\ngive it a try."
                    },
                    {
                        "username": "kiwolarg",
                        "content": "![image](https://assets.leetcode.com/users/kiwolarg/image_1575695319.png)\\n\\nI was searching for the n+k for matching, in this case it should be 2(the 3rd place) and it dosen\\'t exist, so I returned it false. Am I ..... getting the question wrongly?"
                    },
                    {
                        "username": "malegkin",
                        "content": "<= k"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Window size is 3, and you can find two same element inside the window, so true is the ans"
                    },
                    {
                        "username": "AbhayDayma",
                        "content": "It shows me exceeded time limit. But passes all the test cases till 54. "
                    },
                    {
                        "username": "pugalramyaa",
                        "content": "same here "
                    },
                    {
                        "username": "CORSAiRx9",
                        "content": "*** If you're getting `Time Limit Exceeded` then you can compare `len(set(nums))` with `len(nums)`. Most of the time the testcase will just through a huge sequential series e.g. -10001, -10000, -9999, -9998..... So you can quickly use this trick to bypass the long code execution time.\n\n---\nLet's start with the 3rd example:\n-->given: nums = [1,2,3,1,2,3], k = 2\n-->conditions: nums[i]==nums[j], abs(i-j)<=k\n\nnums: [1,    2,    3,    1,    2,    3]\nindex:   0    1     2     3     4     5\n---\n\n                    [1,    2,    3,    1,    2,    3]\n                    [0---------------------->4     5]\n> We can start a loop1:  index 0 to index 4\n\n                    [1,    2,    3,    1,    2,    3]\n                    [0     1---->2     3     4     5]\n> We will start another inner loop2: index 1 to index 2\n\n> `i` as index counter for loop1, `j` as index counter for loop2.\n\n> Since we're using index value in both loops we don't want to compare the numbers with itself i.e. at index 0 both loops will have the same values if i=j. So loop2 will always start from 1 step ahead. Again at last index of `nums` loop2 and loop1 will have the same indices so loop1 has a range of `(0,len(nums)-1)`.\n\n> `max index of loop2` is `i1=(index of loop1 at any moment)+2`. Thus when loop1 starts from index 0 loop2 will have a range of `((index of loop1)+1,i1+2)`.\n..................................\nloop1 at index 0\nloop2: 1-->2\n..................................\nloop1 at index 1\nloop2: 2-->3\n..................................\nloop1 at index 2\nloop2: 3-->4\n\n> Now what would happen if loop1 is at index 4? Here `i1=4+2` which will give 6 with an error `index out of range`.\n..................................\nloop1 at index 4\nloop2: 5-->6\n\n> Till index 3 in loop1 we've maintained the condition `index of loop2 - index of loop1=2`. At index 4 for we still want i1 to be 5 i.e. `len(nums)-1`.\n\n> So we can use `i1=min((index of loop1+2), len(nums)-1)`. This way our loop2 will never get out of the index.\n\n> If someone is wondering what about `abs(i-j)<=k` then we know loop2 will always have greater indices so `abs(i-k)` is basically `index of loop2 - index of loop1`. Till index 3 in loop1 `index of loop2 - index of loop1=2`. But at index 4 `index of loop2 - index of loop1=1`  e.g. 5-4=1 since we've limited our loop2 index to `len(nums)-1`. Thus the value of `abs(i-j)` in our case will be equal to k and then it'll start decreasing and eventually end at 1.\n\n> Now in loop2 we can compare values using both loop1's and loop2's indices i.e. `if nums[i]==nums[j]` and return True.\n\n> If the loop1 runs till it's max range i.e. `len(nums)-1` then we're sure that there's no duplicate values. So we'll return False at the end.\n\n---\nFinal structure:\n---\nuse variable1 to store length of nums\ncompare if variable1 is same with len(set(nums))\n...........return False\nuse i as index counter for loop with range(0,varibale1)\n...........find max limit for j using min\n...........use j as index counter in range(i+1,max limit+1)\n......................compare if both loops have the same values\n......................return True\nreturn False\n\nHope it helps,\nThank you :)"
                    },
                    {
                        "username": "anamika12b",
                        "content": "Thanks for the check suggestion. My time limit issue got resolved because of that"
                    },
                    {
                        "username": "calm27",
                        "content": "Okay, I've managed to figure out finally this description. \nIf someone of you is confused about why sliding window, perhaps, works not perfect here and lot of your test cases failing when it is expected to be True, it is because this task is not really that much about sliding window in most common sense. \nIf you managed to resolve it with sliding window, but using `k+1`... lets say, there is a bit more elegant solution and you tried to approach it in regular way. \n\nMy only hint to not spoil solution is: focus less on fixed sliding window ''regular'' approach and more on actual condition: `abs(i-j)<=k`. Just look at the perspective from another angle and you will find it pretty easily. "
                    },
                    {
                        "username": "ac1dloop",
                        "content": "hint about data structure is helpful!"
                    },
                    {
                        "username": "pwaykar",
                        "content": "Input:\\n[99,99]\\n2\\nOutput:\\nfalse\\nExpected:\\ntrue"
                    },
                    {
                        "username": "Moh_Ghafri",
                        "content": "The question was: abs(i-j) <=k\\n`less than or equal` "
                    },
                    {
                        "username": "malegkin",
                        "content": "<= 3"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Window size is 3, and you can find two same element inside the window, so true is the ans"
                    },
                    {
                        "username": "dav3ydoo",
                        "content": "Input: nums = [1,0,1,1], k = 1\\nOutput: true\\nLet\\'s say i = 0 and j = 3.\\nthen nums[i]=nums[j]\\nThe absolute difference between i and j is 3. Which is bigger than k.  So we should return false.  Not true. Am I misunderstanding something?"
                    },
                    {
                        "username": "atulindore2",
                        "content": "nums[2] and nums[3] are equal and k =1 ...\\nWe only need a single positve case to return true "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "who tf put blank case . I will haunt you to death just you wait.\ncan you any one say how to bypass that. i can't submit for that case.(case no 56)\nit has nothing .... no array , no size nothig "
                    }
                ]
            },
            {
                "id": 1739101,
                "content": [
                    {
                        "username": "Valen_04",
                        "content": "sometimes i wonder if i should re-learn my mother language "
                    },
                    {
                        "username": "CristianM92",
                        "content": "class Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        \n       for (int i = 0; i < nums.length; i++) {\n            for (int j = i+1; j < nums.length; j++) {\n                if (nums[i] == nums[j] && Math.abs(i - j) <= k){\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n\nWhy  is this Time Limit Exceeded? "
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "[@ctgallagher4](/ctgallagher4)  Don\\'t use linear search method for this question .\\n"
                    },
                    {
                        "username": "ctgallagher4",
                        "content": "because it is O(n^2) instead of O(n)"
                    },
                    {
                        "username": "rohitdavas",
                        "content": "rather than the solution proposing the self balancing tree, i would propose to using hash set. \\nsince the target using either is to have constant time lookup and constant time delete, the hash set, if implemented correctly provides the same. \\n\\ngive it a try."
                    },
                    {
                        "username": "kiwolarg",
                        "content": "![image](https://assets.leetcode.com/users/kiwolarg/image_1575695319.png)\\n\\nI was searching for the n+k for matching, in this case it should be 2(the 3rd place) and it dosen\\'t exist, so I returned it false. Am I ..... getting the question wrongly?"
                    },
                    {
                        "username": "malegkin",
                        "content": "<= k"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Window size is 3, and you can find two same element inside the window, so true is the ans"
                    },
                    {
                        "username": "AbhayDayma",
                        "content": "It shows me exceeded time limit. But passes all the test cases till 54. "
                    },
                    {
                        "username": "pugalramyaa",
                        "content": "same here "
                    },
                    {
                        "username": "CORSAiRx9",
                        "content": "*** If you're getting `Time Limit Exceeded` then you can compare `len(set(nums))` with `len(nums)`. Most of the time the testcase will just through a huge sequential series e.g. -10001, -10000, -9999, -9998..... So you can quickly use this trick to bypass the long code execution time.\n\n---\nLet's start with the 3rd example:\n-->given: nums = [1,2,3,1,2,3], k = 2\n-->conditions: nums[i]==nums[j], abs(i-j)<=k\n\nnums: [1,    2,    3,    1,    2,    3]\nindex:   0    1     2     3     4     5\n---\n\n                    [1,    2,    3,    1,    2,    3]\n                    [0---------------------->4     5]\n> We can start a loop1:  index 0 to index 4\n\n                    [1,    2,    3,    1,    2,    3]\n                    [0     1---->2     3     4     5]\n> We will start another inner loop2: index 1 to index 2\n\n> `i` as index counter for loop1, `j` as index counter for loop2.\n\n> Since we're using index value in both loops we don't want to compare the numbers with itself i.e. at index 0 both loops will have the same values if i=j. So loop2 will always start from 1 step ahead. Again at last index of `nums` loop2 and loop1 will have the same indices so loop1 has a range of `(0,len(nums)-1)`.\n\n> `max index of loop2` is `i1=(index of loop1 at any moment)+2`. Thus when loop1 starts from index 0 loop2 will have a range of `((index of loop1)+1,i1+2)`.\n..................................\nloop1 at index 0\nloop2: 1-->2\n..................................\nloop1 at index 1\nloop2: 2-->3\n..................................\nloop1 at index 2\nloop2: 3-->4\n\n> Now what would happen if loop1 is at index 4? Here `i1=4+2` which will give 6 with an error `index out of range`.\n..................................\nloop1 at index 4\nloop2: 5-->6\n\n> Till index 3 in loop1 we've maintained the condition `index of loop2 - index of loop1=2`. At index 4 for we still want i1 to be 5 i.e. `len(nums)-1`.\n\n> So we can use `i1=min((index of loop1+2), len(nums)-1)`. This way our loop2 will never get out of the index.\n\n> If someone is wondering what about `abs(i-j)<=k` then we know loop2 will always have greater indices so `abs(i-k)` is basically `index of loop2 - index of loop1`. Till index 3 in loop1 `index of loop2 - index of loop1=2`. But at index 4 `index of loop2 - index of loop1=1`  e.g. 5-4=1 since we've limited our loop2 index to `len(nums)-1`. Thus the value of `abs(i-j)` in our case will be equal to k and then it'll start decreasing and eventually end at 1.\n\n> Now in loop2 we can compare values using both loop1's and loop2's indices i.e. `if nums[i]==nums[j]` and return True.\n\n> If the loop1 runs till it's max range i.e. `len(nums)-1` then we're sure that there's no duplicate values. So we'll return False at the end.\n\n---\nFinal structure:\n---\nuse variable1 to store length of nums\ncompare if variable1 is same with len(set(nums))\n...........return False\nuse i as index counter for loop with range(0,varibale1)\n...........find max limit for j using min\n...........use j as index counter in range(i+1,max limit+1)\n......................compare if both loops have the same values\n......................return True\nreturn False\n\nHope it helps,\nThank you :)"
                    },
                    {
                        "username": "anamika12b",
                        "content": "Thanks for the check suggestion. My time limit issue got resolved because of that"
                    },
                    {
                        "username": "calm27",
                        "content": "Okay, I've managed to figure out finally this description. \nIf someone of you is confused about why sliding window, perhaps, works not perfect here and lot of your test cases failing when it is expected to be True, it is because this task is not really that much about sliding window in most common sense. \nIf you managed to resolve it with sliding window, but using `k+1`... lets say, there is a bit more elegant solution and you tried to approach it in regular way. \n\nMy only hint to not spoil solution is: focus less on fixed sliding window ''regular'' approach and more on actual condition: `abs(i-j)<=k`. Just look at the perspective from another angle and you will find it pretty easily. "
                    },
                    {
                        "username": "ac1dloop",
                        "content": "hint about data structure is helpful!"
                    },
                    {
                        "username": "pwaykar",
                        "content": "Input:\\n[99,99]\\n2\\nOutput:\\nfalse\\nExpected:\\ntrue"
                    },
                    {
                        "username": "Moh_Ghafri",
                        "content": "The question was: abs(i-j) <=k\\n`less than or equal` "
                    },
                    {
                        "username": "malegkin",
                        "content": "<= 3"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Window size is 3, and you can find two same element inside the window, so true is the ans"
                    },
                    {
                        "username": "dav3ydoo",
                        "content": "Input: nums = [1,0,1,1], k = 1\\nOutput: true\\nLet\\'s say i = 0 and j = 3.\\nthen nums[i]=nums[j]\\nThe absolute difference between i and j is 3. Which is bigger than k.  So we should return false.  Not true. Am I misunderstanding something?"
                    },
                    {
                        "username": "atulindore2",
                        "content": "nums[2] and nums[3] are equal and k =1 ...\\nWe only need a single positve case to return true "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "who tf put blank case . I will haunt you to death just you wait.\ncan you any one say how to bypass that. i can't submit for that case.(case no 56)\nit has nothing .... no array , no size nothig "
                    }
                ]
            },
            {
                "id": 1726381,
                "content": [
                    {
                        "username": "Valen_04",
                        "content": "sometimes i wonder if i should re-learn my mother language "
                    },
                    {
                        "username": "CristianM92",
                        "content": "class Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        \n       for (int i = 0; i < nums.length; i++) {\n            for (int j = i+1; j < nums.length; j++) {\n                if (nums[i] == nums[j] && Math.abs(i - j) <= k){\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n\nWhy  is this Time Limit Exceeded? "
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "[@ctgallagher4](/ctgallagher4)  Don\\'t use linear search method for this question .\\n"
                    },
                    {
                        "username": "ctgallagher4",
                        "content": "because it is O(n^2) instead of O(n)"
                    },
                    {
                        "username": "rohitdavas",
                        "content": "rather than the solution proposing the self balancing tree, i would propose to using hash set. \\nsince the target using either is to have constant time lookup and constant time delete, the hash set, if implemented correctly provides the same. \\n\\ngive it a try."
                    },
                    {
                        "username": "kiwolarg",
                        "content": "![image](https://assets.leetcode.com/users/kiwolarg/image_1575695319.png)\\n\\nI was searching for the n+k for matching, in this case it should be 2(the 3rd place) and it dosen\\'t exist, so I returned it false. Am I ..... getting the question wrongly?"
                    },
                    {
                        "username": "malegkin",
                        "content": "<= k"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Window size is 3, and you can find two same element inside the window, so true is the ans"
                    },
                    {
                        "username": "AbhayDayma",
                        "content": "It shows me exceeded time limit. But passes all the test cases till 54. "
                    },
                    {
                        "username": "pugalramyaa",
                        "content": "same here "
                    },
                    {
                        "username": "CORSAiRx9",
                        "content": "*** If you're getting `Time Limit Exceeded` then you can compare `len(set(nums))` with `len(nums)`. Most of the time the testcase will just through a huge sequential series e.g. -10001, -10000, -9999, -9998..... So you can quickly use this trick to bypass the long code execution time.\n\n---\nLet's start with the 3rd example:\n-->given: nums = [1,2,3,1,2,3], k = 2\n-->conditions: nums[i]==nums[j], abs(i-j)<=k\n\nnums: [1,    2,    3,    1,    2,    3]\nindex:   0    1     2     3     4     5\n---\n\n                    [1,    2,    3,    1,    2,    3]\n                    [0---------------------->4     5]\n> We can start a loop1:  index 0 to index 4\n\n                    [1,    2,    3,    1,    2,    3]\n                    [0     1---->2     3     4     5]\n> We will start another inner loop2: index 1 to index 2\n\n> `i` as index counter for loop1, `j` as index counter for loop2.\n\n> Since we're using index value in both loops we don't want to compare the numbers with itself i.e. at index 0 both loops will have the same values if i=j. So loop2 will always start from 1 step ahead. Again at last index of `nums` loop2 and loop1 will have the same indices so loop1 has a range of `(0,len(nums)-1)`.\n\n> `max index of loop2` is `i1=(index of loop1 at any moment)+2`. Thus when loop1 starts from index 0 loop2 will have a range of `((index of loop1)+1,i1+2)`.\n..................................\nloop1 at index 0\nloop2: 1-->2\n..................................\nloop1 at index 1\nloop2: 2-->3\n..................................\nloop1 at index 2\nloop2: 3-->4\n\n> Now what would happen if loop1 is at index 4? Here `i1=4+2` which will give 6 with an error `index out of range`.\n..................................\nloop1 at index 4\nloop2: 5-->6\n\n> Till index 3 in loop1 we've maintained the condition `index of loop2 - index of loop1=2`. At index 4 for we still want i1 to be 5 i.e. `len(nums)-1`.\n\n> So we can use `i1=min((index of loop1+2), len(nums)-1)`. This way our loop2 will never get out of the index.\n\n> If someone is wondering what about `abs(i-j)<=k` then we know loop2 will always have greater indices so `abs(i-k)` is basically `index of loop2 - index of loop1`. Till index 3 in loop1 `index of loop2 - index of loop1=2`. But at index 4 `index of loop2 - index of loop1=1`  e.g. 5-4=1 since we've limited our loop2 index to `len(nums)-1`. Thus the value of `abs(i-j)` in our case will be equal to k and then it'll start decreasing and eventually end at 1.\n\n> Now in loop2 we can compare values using both loop1's and loop2's indices i.e. `if nums[i]==nums[j]` and return True.\n\n> If the loop1 runs till it's max range i.e. `len(nums)-1` then we're sure that there's no duplicate values. So we'll return False at the end.\n\n---\nFinal structure:\n---\nuse variable1 to store length of nums\ncompare if variable1 is same with len(set(nums))\n...........return False\nuse i as index counter for loop with range(0,varibale1)\n...........find max limit for j using min\n...........use j as index counter in range(i+1,max limit+1)\n......................compare if both loops have the same values\n......................return True\nreturn False\n\nHope it helps,\nThank you :)"
                    },
                    {
                        "username": "anamika12b",
                        "content": "Thanks for the check suggestion. My time limit issue got resolved because of that"
                    },
                    {
                        "username": "calm27",
                        "content": "Okay, I've managed to figure out finally this description. \nIf someone of you is confused about why sliding window, perhaps, works not perfect here and lot of your test cases failing when it is expected to be True, it is because this task is not really that much about sliding window in most common sense. \nIf you managed to resolve it with sliding window, but using `k+1`... lets say, there is a bit more elegant solution and you tried to approach it in regular way. \n\nMy only hint to not spoil solution is: focus less on fixed sliding window ''regular'' approach and more on actual condition: `abs(i-j)<=k`. Just look at the perspective from another angle and you will find it pretty easily. "
                    },
                    {
                        "username": "ac1dloop",
                        "content": "hint about data structure is helpful!"
                    },
                    {
                        "username": "pwaykar",
                        "content": "Input:\\n[99,99]\\n2\\nOutput:\\nfalse\\nExpected:\\ntrue"
                    },
                    {
                        "username": "Moh_Ghafri",
                        "content": "The question was: abs(i-j) <=k\\n`less than or equal` "
                    },
                    {
                        "username": "malegkin",
                        "content": "<= 3"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Window size is 3, and you can find two same element inside the window, so true is the ans"
                    },
                    {
                        "username": "dav3ydoo",
                        "content": "Input: nums = [1,0,1,1], k = 1\\nOutput: true\\nLet\\'s say i = 0 and j = 3.\\nthen nums[i]=nums[j]\\nThe absolute difference between i and j is 3. Which is bigger than k.  So we should return false.  Not true. Am I misunderstanding something?"
                    },
                    {
                        "username": "atulindore2",
                        "content": "nums[2] and nums[3] are equal and k =1 ...\\nWe only need a single positve case to return true "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "who tf put blank case . I will haunt you to death just you wait.\ncan you any one say how to bypass that. i can't submit for that case.(case no 56)\nit has nothing .... no array , no size nothig "
                    }
                ]
            },
            {
                "id": 1716638,
                "content": [
                    {
                        "username": "Valen_04",
                        "content": "sometimes i wonder if i should re-learn my mother language "
                    },
                    {
                        "username": "CristianM92",
                        "content": "class Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        \n       for (int i = 0; i < nums.length; i++) {\n            for (int j = i+1; j < nums.length; j++) {\n                if (nums[i] == nums[j] && Math.abs(i - j) <= k){\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n\nWhy  is this Time Limit Exceeded? "
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "[@ctgallagher4](/ctgallagher4)  Don\\'t use linear search method for this question .\\n"
                    },
                    {
                        "username": "ctgallagher4",
                        "content": "because it is O(n^2) instead of O(n)"
                    },
                    {
                        "username": "rohitdavas",
                        "content": "rather than the solution proposing the self balancing tree, i would propose to using hash set. \\nsince the target using either is to have constant time lookup and constant time delete, the hash set, if implemented correctly provides the same. \\n\\ngive it a try."
                    },
                    {
                        "username": "kiwolarg",
                        "content": "![image](https://assets.leetcode.com/users/kiwolarg/image_1575695319.png)\\n\\nI was searching for the n+k for matching, in this case it should be 2(the 3rd place) and it dosen\\'t exist, so I returned it false. Am I ..... getting the question wrongly?"
                    },
                    {
                        "username": "malegkin",
                        "content": "<= k"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Window size is 3, and you can find two same element inside the window, so true is the ans"
                    },
                    {
                        "username": "AbhayDayma",
                        "content": "It shows me exceeded time limit. But passes all the test cases till 54. "
                    },
                    {
                        "username": "pugalramyaa",
                        "content": "same here "
                    },
                    {
                        "username": "CORSAiRx9",
                        "content": "*** If you're getting `Time Limit Exceeded` then you can compare `len(set(nums))` with `len(nums)`. Most of the time the testcase will just through a huge sequential series e.g. -10001, -10000, -9999, -9998..... So you can quickly use this trick to bypass the long code execution time.\n\n---\nLet's start with the 3rd example:\n-->given: nums = [1,2,3,1,2,3], k = 2\n-->conditions: nums[i]==nums[j], abs(i-j)<=k\n\nnums: [1,    2,    3,    1,    2,    3]\nindex:   0    1     2     3     4     5\n---\n\n                    [1,    2,    3,    1,    2,    3]\n                    [0---------------------->4     5]\n> We can start a loop1:  index 0 to index 4\n\n                    [1,    2,    3,    1,    2,    3]\n                    [0     1---->2     3     4     5]\n> We will start another inner loop2: index 1 to index 2\n\n> `i` as index counter for loop1, `j` as index counter for loop2.\n\n> Since we're using index value in both loops we don't want to compare the numbers with itself i.e. at index 0 both loops will have the same values if i=j. So loop2 will always start from 1 step ahead. Again at last index of `nums` loop2 and loop1 will have the same indices so loop1 has a range of `(0,len(nums)-1)`.\n\n> `max index of loop2` is `i1=(index of loop1 at any moment)+2`. Thus when loop1 starts from index 0 loop2 will have a range of `((index of loop1)+1,i1+2)`.\n..................................\nloop1 at index 0\nloop2: 1-->2\n..................................\nloop1 at index 1\nloop2: 2-->3\n..................................\nloop1 at index 2\nloop2: 3-->4\n\n> Now what would happen if loop1 is at index 4? Here `i1=4+2` which will give 6 with an error `index out of range`.\n..................................\nloop1 at index 4\nloop2: 5-->6\n\n> Till index 3 in loop1 we've maintained the condition `index of loop2 - index of loop1=2`. At index 4 for we still want i1 to be 5 i.e. `len(nums)-1`.\n\n> So we can use `i1=min((index of loop1+2), len(nums)-1)`. This way our loop2 will never get out of the index.\n\n> If someone is wondering what about `abs(i-j)<=k` then we know loop2 will always have greater indices so `abs(i-k)` is basically `index of loop2 - index of loop1`. Till index 3 in loop1 `index of loop2 - index of loop1=2`. But at index 4 `index of loop2 - index of loop1=1`  e.g. 5-4=1 since we've limited our loop2 index to `len(nums)-1`. Thus the value of `abs(i-j)` in our case will be equal to k and then it'll start decreasing and eventually end at 1.\n\n> Now in loop2 we can compare values using both loop1's and loop2's indices i.e. `if nums[i]==nums[j]` and return True.\n\n> If the loop1 runs till it's max range i.e. `len(nums)-1` then we're sure that there's no duplicate values. So we'll return False at the end.\n\n---\nFinal structure:\n---\nuse variable1 to store length of nums\ncompare if variable1 is same with len(set(nums))\n...........return False\nuse i as index counter for loop with range(0,varibale1)\n...........find max limit for j using min\n...........use j as index counter in range(i+1,max limit+1)\n......................compare if both loops have the same values\n......................return True\nreturn False\n\nHope it helps,\nThank you :)"
                    },
                    {
                        "username": "anamika12b",
                        "content": "Thanks for the check suggestion. My time limit issue got resolved because of that"
                    },
                    {
                        "username": "calm27",
                        "content": "Okay, I've managed to figure out finally this description. \nIf someone of you is confused about why sliding window, perhaps, works not perfect here and lot of your test cases failing when it is expected to be True, it is because this task is not really that much about sliding window in most common sense. \nIf you managed to resolve it with sliding window, but using `k+1`... lets say, there is a bit more elegant solution and you tried to approach it in regular way. \n\nMy only hint to not spoil solution is: focus less on fixed sliding window ''regular'' approach and more on actual condition: `abs(i-j)<=k`. Just look at the perspective from another angle and you will find it pretty easily. "
                    },
                    {
                        "username": "ac1dloop",
                        "content": "hint about data structure is helpful!"
                    },
                    {
                        "username": "pwaykar",
                        "content": "Input:\\n[99,99]\\n2\\nOutput:\\nfalse\\nExpected:\\ntrue"
                    },
                    {
                        "username": "Moh_Ghafri",
                        "content": "The question was: abs(i-j) <=k\\n`less than or equal` "
                    },
                    {
                        "username": "malegkin",
                        "content": "<= 3"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Window size is 3, and you can find two same element inside the window, so true is the ans"
                    },
                    {
                        "username": "dav3ydoo",
                        "content": "Input: nums = [1,0,1,1], k = 1\\nOutput: true\\nLet\\'s say i = 0 and j = 3.\\nthen nums[i]=nums[j]\\nThe absolute difference between i and j is 3. Which is bigger than k.  So we should return false.  Not true. Am I misunderstanding something?"
                    },
                    {
                        "username": "atulindore2",
                        "content": "nums[2] and nums[3] are equal and k =1 ...\\nWe only need a single positve case to return true "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "who tf put blank case . I will haunt you to death just you wait.\ncan you any one say how to bypass that. i can't submit for that case.(case no 56)\nit has nothing .... no array , no size nothig "
                    }
                ]
            },
            {
                "id": 1572394,
                "content": [
                    {
                        "username": "Valen_04",
                        "content": "sometimes i wonder if i should re-learn my mother language "
                    },
                    {
                        "username": "CristianM92",
                        "content": "class Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        \n       for (int i = 0; i < nums.length; i++) {\n            for (int j = i+1; j < nums.length; j++) {\n                if (nums[i] == nums[j] && Math.abs(i - j) <= k){\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n\nWhy  is this Time Limit Exceeded? "
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "[@ctgallagher4](/ctgallagher4)  Don\\'t use linear search method for this question .\\n"
                    },
                    {
                        "username": "ctgallagher4",
                        "content": "because it is O(n^2) instead of O(n)"
                    },
                    {
                        "username": "rohitdavas",
                        "content": "rather than the solution proposing the self balancing tree, i would propose to using hash set. \\nsince the target using either is to have constant time lookup and constant time delete, the hash set, if implemented correctly provides the same. \\n\\ngive it a try."
                    },
                    {
                        "username": "kiwolarg",
                        "content": "![image](https://assets.leetcode.com/users/kiwolarg/image_1575695319.png)\\n\\nI was searching for the n+k for matching, in this case it should be 2(the 3rd place) and it dosen\\'t exist, so I returned it false. Am I ..... getting the question wrongly?"
                    },
                    {
                        "username": "malegkin",
                        "content": "<= k"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Window size is 3, and you can find two same element inside the window, so true is the ans"
                    },
                    {
                        "username": "AbhayDayma",
                        "content": "It shows me exceeded time limit. But passes all the test cases till 54. "
                    },
                    {
                        "username": "pugalramyaa",
                        "content": "same here "
                    },
                    {
                        "username": "CORSAiRx9",
                        "content": "*** If you're getting `Time Limit Exceeded` then you can compare `len(set(nums))` with `len(nums)`. Most of the time the testcase will just through a huge sequential series e.g. -10001, -10000, -9999, -9998..... So you can quickly use this trick to bypass the long code execution time.\n\n---\nLet's start with the 3rd example:\n-->given: nums = [1,2,3,1,2,3], k = 2\n-->conditions: nums[i]==nums[j], abs(i-j)<=k\n\nnums: [1,    2,    3,    1,    2,    3]\nindex:   0    1     2     3     4     5\n---\n\n                    [1,    2,    3,    1,    2,    3]\n                    [0---------------------->4     5]\n> We can start a loop1:  index 0 to index 4\n\n                    [1,    2,    3,    1,    2,    3]\n                    [0     1---->2     3     4     5]\n> We will start another inner loop2: index 1 to index 2\n\n> `i` as index counter for loop1, `j` as index counter for loop2.\n\n> Since we're using index value in both loops we don't want to compare the numbers with itself i.e. at index 0 both loops will have the same values if i=j. So loop2 will always start from 1 step ahead. Again at last index of `nums` loop2 and loop1 will have the same indices so loop1 has a range of `(0,len(nums)-1)`.\n\n> `max index of loop2` is `i1=(index of loop1 at any moment)+2`. Thus when loop1 starts from index 0 loop2 will have a range of `((index of loop1)+1,i1+2)`.\n..................................\nloop1 at index 0\nloop2: 1-->2\n..................................\nloop1 at index 1\nloop2: 2-->3\n..................................\nloop1 at index 2\nloop2: 3-->4\n\n> Now what would happen if loop1 is at index 4? Here `i1=4+2` which will give 6 with an error `index out of range`.\n..................................\nloop1 at index 4\nloop2: 5-->6\n\n> Till index 3 in loop1 we've maintained the condition `index of loop2 - index of loop1=2`. At index 4 for we still want i1 to be 5 i.e. `len(nums)-1`.\n\n> So we can use `i1=min((index of loop1+2), len(nums)-1)`. This way our loop2 will never get out of the index.\n\n> If someone is wondering what about `abs(i-j)<=k` then we know loop2 will always have greater indices so `abs(i-k)` is basically `index of loop2 - index of loop1`. Till index 3 in loop1 `index of loop2 - index of loop1=2`. But at index 4 `index of loop2 - index of loop1=1`  e.g. 5-4=1 since we've limited our loop2 index to `len(nums)-1`. Thus the value of `abs(i-j)` in our case will be equal to k and then it'll start decreasing and eventually end at 1.\n\n> Now in loop2 we can compare values using both loop1's and loop2's indices i.e. `if nums[i]==nums[j]` and return True.\n\n> If the loop1 runs till it's max range i.e. `len(nums)-1` then we're sure that there's no duplicate values. So we'll return False at the end.\n\n---\nFinal structure:\n---\nuse variable1 to store length of nums\ncompare if variable1 is same with len(set(nums))\n...........return False\nuse i as index counter for loop with range(0,varibale1)\n...........find max limit for j using min\n...........use j as index counter in range(i+1,max limit+1)\n......................compare if both loops have the same values\n......................return True\nreturn False\n\nHope it helps,\nThank you :)"
                    },
                    {
                        "username": "anamika12b",
                        "content": "Thanks for the check suggestion. My time limit issue got resolved because of that"
                    },
                    {
                        "username": "calm27",
                        "content": "Okay, I've managed to figure out finally this description. \nIf someone of you is confused about why sliding window, perhaps, works not perfect here and lot of your test cases failing when it is expected to be True, it is because this task is not really that much about sliding window in most common sense. \nIf you managed to resolve it with sliding window, but using `k+1`... lets say, there is a bit more elegant solution and you tried to approach it in regular way. \n\nMy only hint to not spoil solution is: focus less on fixed sliding window ''regular'' approach and more on actual condition: `abs(i-j)<=k`. Just look at the perspective from another angle and you will find it pretty easily. "
                    },
                    {
                        "username": "ac1dloop",
                        "content": "hint about data structure is helpful!"
                    },
                    {
                        "username": "pwaykar",
                        "content": "Input:\\n[99,99]\\n2\\nOutput:\\nfalse\\nExpected:\\ntrue"
                    },
                    {
                        "username": "Moh_Ghafri",
                        "content": "The question was: abs(i-j) <=k\\n`less than or equal` "
                    },
                    {
                        "username": "malegkin",
                        "content": "<= 3"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Window size is 3, and you can find two same element inside the window, so true is the ans"
                    },
                    {
                        "username": "dav3ydoo",
                        "content": "Input: nums = [1,0,1,1], k = 1\\nOutput: true\\nLet\\'s say i = 0 and j = 3.\\nthen nums[i]=nums[j]\\nThe absolute difference between i and j is 3. Which is bigger than k.  So we should return false.  Not true. Am I misunderstanding something?"
                    },
                    {
                        "username": "atulindore2",
                        "content": "nums[2] and nums[3] are equal and k =1 ...\\nWe only need a single positve case to return true "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "who tf put blank case . I will haunt you to death just you wait.\ncan you any one say how to bypass that. i can't submit for that case.(case no 56)\nit has nothing .... no array , no size nothig "
                    }
                ]
            },
            {
                "id": 1572106,
                "content": [
                    {
                        "username": "Valen_04",
                        "content": "sometimes i wonder if i should re-learn my mother language "
                    },
                    {
                        "username": "CristianM92",
                        "content": "class Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        \n       for (int i = 0; i < nums.length; i++) {\n            for (int j = i+1; j < nums.length; j++) {\n                if (nums[i] == nums[j] && Math.abs(i - j) <= k){\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n\nWhy  is this Time Limit Exceeded? "
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "[@ctgallagher4](/ctgallagher4)  Don\\'t use linear search method for this question .\\n"
                    },
                    {
                        "username": "ctgallagher4",
                        "content": "because it is O(n^2) instead of O(n)"
                    },
                    {
                        "username": "rohitdavas",
                        "content": "rather than the solution proposing the self balancing tree, i would propose to using hash set. \\nsince the target using either is to have constant time lookup and constant time delete, the hash set, if implemented correctly provides the same. \\n\\ngive it a try."
                    },
                    {
                        "username": "kiwolarg",
                        "content": "![image](https://assets.leetcode.com/users/kiwolarg/image_1575695319.png)\\n\\nI was searching for the n+k for matching, in this case it should be 2(the 3rd place) and it dosen\\'t exist, so I returned it false. Am I ..... getting the question wrongly?"
                    },
                    {
                        "username": "malegkin",
                        "content": "<= k"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Window size is 3, and you can find two same element inside the window, so true is the ans"
                    },
                    {
                        "username": "AbhayDayma",
                        "content": "It shows me exceeded time limit. But passes all the test cases till 54. "
                    },
                    {
                        "username": "pugalramyaa",
                        "content": "same here "
                    },
                    {
                        "username": "CORSAiRx9",
                        "content": "*** If you're getting `Time Limit Exceeded` then you can compare `len(set(nums))` with `len(nums)`. Most of the time the testcase will just through a huge sequential series e.g. -10001, -10000, -9999, -9998..... So you can quickly use this trick to bypass the long code execution time.\n\n---\nLet's start with the 3rd example:\n-->given: nums = [1,2,3,1,2,3], k = 2\n-->conditions: nums[i]==nums[j], abs(i-j)<=k\n\nnums: [1,    2,    3,    1,    2,    3]\nindex:   0    1     2     3     4     5\n---\n\n                    [1,    2,    3,    1,    2,    3]\n                    [0---------------------->4     5]\n> We can start a loop1:  index 0 to index 4\n\n                    [1,    2,    3,    1,    2,    3]\n                    [0     1---->2     3     4     5]\n> We will start another inner loop2: index 1 to index 2\n\n> `i` as index counter for loop1, `j` as index counter for loop2.\n\n> Since we're using index value in both loops we don't want to compare the numbers with itself i.e. at index 0 both loops will have the same values if i=j. So loop2 will always start from 1 step ahead. Again at last index of `nums` loop2 and loop1 will have the same indices so loop1 has a range of `(0,len(nums)-1)`.\n\n> `max index of loop2` is `i1=(index of loop1 at any moment)+2`. Thus when loop1 starts from index 0 loop2 will have a range of `((index of loop1)+1,i1+2)`.\n..................................\nloop1 at index 0\nloop2: 1-->2\n..................................\nloop1 at index 1\nloop2: 2-->3\n..................................\nloop1 at index 2\nloop2: 3-->4\n\n> Now what would happen if loop1 is at index 4? Here `i1=4+2` which will give 6 with an error `index out of range`.\n..................................\nloop1 at index 4\nloop2: 5-->6\n\n> Till index 3 in loop1 we've maintained the condition `index of loop2 - index of loop1=2`. At index 4 for we still want i1 to be 5 i.e. `len(nums)-1`.\n\n> So we can use `i1=min((index of loop1+2), len(nums)-1)`. This way our loop2 will never get out of the index.\n\n> If someone is wondering what about `abs(i-j)<=k` then we know loop2 will always have greater indices so `abs(i-k)` is basically `index of loop2 - index of loop1`. Till index 3 in loop1 `index of loop2 - index of loop1=2`. But at index 4 `index of loop2 - index of loop1=1`  e.g. 5-4=1 since we've limited our loop2 index to `len(nums)-1`. Thus the value of `abs(i-j)` in our case will be equal to k and then it'll start decreasing and eventually end at 1.\n\n> Now in loop2 we can compare values using both loop1's and loop2's indices i.e. `if nums[i]==nums[j]` and return True.\n\n> If the loop1 runs till it's max range i.e. `len(nums)-1` then we're sure that there's no duplicate values. So we'll return False at the end.\n\n---\nFinal structure:\n---\nuse variable1 to store length of nums\ncompare if variable1 is same with len(set(nums))\n...........return False\nuse i as index counter for loop with range(0,varibale1)\n...........find max limit for j using min\n...........use j as index counter in range(i+1,max limit+1)\n......................compare if both loops have the same values\n......................return True\nreturn False\n\nHope it helps,\nThank you :)"
                    },
                    {
                        "username": "anamika12b",
                        "content": "Thanks for the check suggestion. My time limit issue got resolved because of that"
                    },
                    {
                        "username": "calm27",
                        "content": "Okay, I've managed to figure out finally this description. \nIf someone of you is confused about why sliding window, perhaps, works not perfect here and lot of your test cases failing when it is expected to be True, it is because this task is not really that much about sliding window in most common sense. \nIf you managed to resolve it with sliding window, but using `k+1`... lets say, there is a bit more elegant solution and you tried to approach it in regular way. \n\nMy only hint to not spoil solution is: focus less on fixed sliding window ''regular'' approach and more on actual condition: `abs(i-j)<=k`. Just look at the perspective from another angle and you will find it pretty easily. "
                    },
                    {
                        "username": "ac1dloop",
                        "content": "hint about data structure is helpful!"
                    },
                    {
                        "username": "pwaykar",
                        "content": "Input:\\n[99,99]\\n2\\nOutput:\\nfalse\\nExpected:\\ntrue"
                    },
                    {
                        "username": "Moh_Ghafri",
                        "content": "The question was: abs(i-j) <=k\\n`less than or equal` "
                    },
                    {
                        "username": "malegkin",
                        "content": "<= 3"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Window size is 3, and you can find two same element inside the window, so true is the ans"
                    },
                    {
                        "username": "dav3ydoo",
                        "content": "Input: nums = [1,0,1,1], k = 1\\nOutput: true\\nLet\\'s say i = 0 and j = 3.\\nthen nums[i]=nums[j]\\nThe absolute difference between i and j is 3. Which is bigger than k.  So we should return false.  Not true. Am I misunderstanding something?"
                    },
                    {
                        "username": "atulindore2",
                        "content": "nums[2] and nums[3] are equal and k =1 ...\\nWe only need a single positve case to return true "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "who tf put blank case . I will haunt you to death just you wait.\ncan you any one say how to bypass that. i can't submit for that case.(case no 56)\nit has nothing .... no array , no size nothig "
                    }
                ]
            },
            {
                "id": 2046178,
                "content": [
                    {
                        "username": "Valen_04",
                        "content": "sometimes i wonder if i should re-learn my mother language "
                    },
                    {
                        "username": "CristianM92",
                        "content": "class Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        \n       for (int i = 0; i < nums.length; i++) {\n            for (int j = i+1; j < nums.length; j++) {\n                if (nums[i] == nums[j] && Math.abs(i - j) <= k){\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n\nWhy  is this Time Limit Exceeded? "
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "[@ctgallagher4](/ctgallagher4)  Don\\'t use linear search method for this question .\\n"
                    },
                    {
                        "username": "ctgallagher4",
                        "content": "because it is O(n^2) instead of O(n)"
                    },
                    {
                        "username": "rohitdavas",
                        "content": "rather than the solution proposing the self balancing tree, i would propose to using hash set. \\nsince the target using either is to have constant time lookup and constant time delete, the hash set, if implemented correctly provides the same. \\n\\ngive it a try."
                    },
                    {
                        "username": "kiwolarg",
                        "content": "![image](https://assets.leetcode.com/users/kiwolarg/image_1575695319.png)\\n\\nI was searching for the n+k for matching, in this case it should be 2(the 3rd place) and it dosen\\'t exist, so I returned it false. Am I ..... getting the question wrongly?"
                    },
                    {
                        "username": "malegkin",
                        "content": "<= k"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Window size is 3, and you can find two same element inside the window, so true is the ans"
                    },
                    {
                        "username": "AbhayDayma",
                        "content": "It shows me exceeded time limit. But passes all the test cases till 54. "
                    },
                    {
                        "username": "pugalramyaa",
                        "content": "same here "
                    },
                    {
                        "username": "CORSAiRx9",
                        "content": "*** If you're getting `Time Limit Exceeded` then you can compare `len(set(nums))` with `len(nums)`. Most of the time the testcase will just through a huge sequential series e.g. -10001, -10000, -9999, -9998..... So you can quickly use this trick to bypass the long code execution time.\n\n---\nLet's start with the 3rd example:\n-->given: nums = [1,2,3,1,2,3], k = 2\n-->conditions: nums[i]==nums[j], abs(i-j)<=k\n\nnums: [1,    2,    3,    1,    2,    3]\nindex:   0    1     2     3     4     5\n---\n\n                    [1,    2,    3,    1,    2,    3]\n                    [0---------------------->4     5]\n> We can start a loop1:  index 0 to index 4\n\n                    [1,    2,    3,    1,    2,    3]\n                    [0     1---->2     3     4     5]\n> We will start another inner loop2: index 1 to index 2\n\n> `i` as index counter for loop1, `j` as index counter for loop2.\n\n> Since we're using index value in both loops we don't want to compare the numbers with itself i.e. at index 0 both loops will have the same values if i=j. So loop2 will always start from 1 step ahead. Again at last index of `nums` loop2 and loop1 will have the same indices so loop1 has a range of `(0,len(nums)-1)`.\n\n> `max index of loop2` is `i1=(index of loop1 at any moment)+2`. Thus when loop1 starts from index 0 loop2 will have a range of `((index of loop1)+1,i1+2)`.\n..................................\nloop1 at index 0\nloop2: 1-->2\n..................................\nloop1 at index 1\nloop2: 2-->3\n..................................\nloop1 at index 2\nloop2: 3-->4\n\n> Now what would happen if loop1 is at index 4? Here `i1=4+2` which will give 6 with an error `index out of range`.\n..................................\nloop1 at index 4\nloop2: 5-->6\n\n> Till index 3 in loop1 we've maintained the condition `index of loop2 - index of loop1=2`. At index 4 for we still want i1 to be 5 i.e. `len(nums)-1`.\n\n> So we can use `i1=min((index of loop1+2), len(nums)-1)`. This way our loop2 will never get out of the index.\n\n> If someone is wondering what about `abs(i-j)<=k` then we know loop2 will always have greater indices so `abs(i-k)` is basically `index of loop2 - index of loop1`. Till index 3 in loop1 `index of loop2 - index of loop1=2`. But at index 4 `index of loop2 - index of loop1=1`  e.g. 5-4=1 since we've limited our loop2 index to `len(nums)-1`. Thus the value of `abs(i-j)` in our case will be equal to k and then it'll start decreasing and eventually end at 1.\n\n> Now in loop2 we can compare values using both loop1's and loop2's indices i.e. `if nums[i]==nums[j]` and return True.\n\n> If the loop1 runs till it's max range i.e. `len(nums)-1` then we're sure that there's no duplicate values. So we'll return False at the end.\n\n---\nFinal structure:\n---\nuse variable1 to store length of nums\ncompare if variable1 is same with len(set(nums))\n...........return False\nuse i as index counter for loop with range(0,varibale1)\n...........find max limit for j using min\n...........use j as index counter in range(i+1,max limit+1)\n......................compare if both loops have the same values\n......................return True\nreturn False\n\nHope it helps,\nThank you :)"
                    },
                    {
                        "username": "anamika12b",
                        "content": "Thanks for the check suggestion. My time limit issue got resolved because of that"
                    },
                    {
                        "username": "calm27",
                        "content": "Okay, I've managed to figure out finally this description. \nIf someone of you is confused about why sliding window, perhaps, works not perfect here and lot of your test cases failing when it is expected to be True, it is because this task is not really that much about sliding window in most common sense. \nIf you managed to resolve it with sliding window, but using `k+1`... lets say, there is a bit more elegant solution and you tried to approach it in regular way. \n\nMy only hint to not spoil solution is: focus less on fixed sliding window ''regular'' approach and more on actual condition: `abs(i-j)<=k`. Just look at the perspective from another angle and you will find it pretty easily. "
                    },
                    {
                        "username": "ac1dloop",
                        "content": "hint about data structure is helpful!"
                    },
                    {
                        "username": "pwaykar",
                        "content": "Input:\\n[99,99]\\n2\\nOutput:\\nfalse\\nExpected:\\ntrue"
                    },
                    {
                        "username": "Moh_Ghafri",
                        "content": "The question was: abs(i-j) <=k\\n`less than or equal` "
                    },
                    {
                        "username": "malegkin",
                        "content": "<= 3"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Window size is 3, and you can find two same element inside the window, so true is the ans"
                    },
                    {
                        "username": "dav3ydoo",
                        "content": "Input: nums = [1,0,1,1], k = 1\\nOutput: true\\nLet\\'s say i = 0 and j = 3.\\nthen nums[i]=nums[j]\\nThe absolute difference between i and j is 3. Which is bigger than k.  So we should return false.  Not true. Am I misunderstanding something?"
                    },
                    {
                        "username": "atulindore2",
                        "content": "nums[2] and nums[3] are equal and k =1 ...\\nWe only need a single positve case to return true "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "who tf put blank case . I will haunt you to death just you wait.\ncan you any one say how to bypass that. i can't submit for that case.(case no 56)\nit has nothing .... no array , no size nothig "
                    }
                ]
            },
            {
                "id": 2027661,
                "content": [
                    {
                        "username": "faisalasnari432",
                        "content": "how does it give true for \\n[99,99]\\nwhile k=2;"
                    },
                    {
                        "username": "user5279nk",
                        "content": "Is 1 test case wrong?"
                    },
                    {
                        "username": "BlakeE",
                        "content": "I\\'ve asked myself that over and over on this one"
                    },
                    {
                        "username": "Maheshkumar_2021",
                        "content": "no its properly working............"
                    },
                    {
                        "username": "cocoye",
                        "content": "I thought that if the input nums=[1,1,2,1] and k=1, the answer should be false, because  the maximum distance of duplicate number 1 is nums[3]-nums[0]=3>k,but not \"at most k......\""
                    },
                    {
                        "username": "Haeckel",
                        "content": "does it mean that there is only one pair of indices that matches the condition?"
                    },
                    {
                        "username": "luckyjessica",
                        "content": "What if the array is {1,2,3,4,6,2,8,2} and k is 2? \\nShould it return true or false? I think it should be true."
                    },
                    {
                        "username": "srapol",
                        "content": "it should be true for (2,8,2) within the array"
                    },
                    {
                        "username": "yaoqi3245",
                        "content": "Why input [1,0,1,1] 1 the result is true?\nIn this case nums[0]=1, nums[2]=1, j-i=2-0>k, is this true???\nWho can help mt with this?\nShouldn't it be the maximum of the absolute difference between i,j can't be bigger than k?"
                    },
                    {
                        "username": "twittercex000",
                        "content": "this problem is awful"
                    },
                    {
                        "username": "rwatso",
                        "content": "Hint: the code will be VERY similar to Two Sum. Use a hash map."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The problem statement is very unclear"
                    },
                    {
                        "username": "pa-one55",
                        "content": "need current index and prev index only"
                    }
                ]
            },
            {
                "id": 1964959,
                "content": [
                    {
                        "username": "faisalasnari432",
                        "content": "how does it give true for \\n[99,99]\\nwhile k=2;"
                    },
                    {
                        "username": "user5279nk",
                        "content": "Is 1 test case wrong?"
                    },
                    {
                        "username": "BlakeE",
                        "content": "I\\'ve asked myself that over and over on this one"
                    },
                    {
                        "username": "Maheshkumar_2021",
                        "content": "no its properly working............"
                    },
                    {
                        "username": "cocoye",
                        "content": "I thought that if the input nums=[1,1,2,1] and k=1, the answer should be false, because  the maximum distance of duplicate number 1 is nums[3]-nums[0]=3>k,but not \"at most k......\""
                    },
                    {
                        "username": "Haeckel",
                        "content": "does it mean that there is only one pair of indices that matches the condition?"
                    },
                    {
                        "username": "luckyjessica",
                        "content": "What if the array is {1,2,3,4,6,2,8,2} and k is 2? \\nShould it return true or false? I think it should be true."
                    },
                    {
                        "username": "srapol",
                        "content": "it should be true for (2,8,2) within the array"
                    },
                    {
                        "username": "yaoqi3245",
                        "content": "Why input [1,0,1,1] 1 the result is true?\nIn this case nums[0]=1, nums[2]=1, j-i=2-0>k, is this true???\nWho can help mt with this?\nShouldn't it be the maximum of the absolute difference between i,j can't be bigger than k?"
                    },
                    {
                        "username": "twittercex000",
                        "content": "this problem is awful"
                    },
                    {
                        "username": "rwatso",
                        "content": "Hint: the code will be VERY similar to Two Sum. Use a hash map."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The problem statement is very unclear"
                    },
                    {
                        "username": "pa-one55",
                        "content": "need current index and prev index only"
                    }
                ]
            },
            {
                "id": 1571447,
                "content": [
                    {
                        "username": "faisalasnari432",
                        "content": "how does it give true for \\n[99,99]\\nwhile k=2;"
                    },
                    {
                        "username": "user5279nk",
                        "content": "Is 1 test case wrong?"
                    },
                    {
                        "username": "BlakeE",
                        "content": "I\\'ve asked myself that over and over on this one"
                    },
                    {
                        "username": "Maheshkumar_2021",
                        "content": "no its properly working............"
                    },
                    {
                        "username": "cocoye",
                        "content": "I thought that if the input nums=[1,1,2,1] and k=1, the answer should be false, because  the maximum distance of duplicate number 1 is nums[3]-nums[0]=3>k,but not \"at most k......\""
                    },
                    {
                        "username": "Haeckel",
                        "content": "does it mean that there is only one pair of indices that matches the condition?"
                    },
                    {
                        "username": "luckyjessica",
                        "content": "What if the array is {1,2,3,4,6,2,8,2} and k is 2? \\nShould it return true or false? I think it should be true."
                    },
                    {
                        "username": "srapol",
                        "content": "it should be true for (2,8,2) within the array"
                    },
                    {
                        "username": "yaoqi3245",
                        "content": "Why input [1,0,1,1] 1 the result is true?\nIn this case nums[0]=1, nums[2]=1, j-i=2-0>k, is this true???\nWho can help mt with this?\nShouldn't it be the maximum of the absolute difference between i,j can't be bigger than k?"
                    },
                    {
                        "username": "twittercex000",
                        "content": "this problem is awful"
                    },
                    {
                        "username": "rwatso",
                        "content": "Hint: the code will be VERY similar to Two Sum. Use a hash map."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The problem statement is very unclear"
                    },
                    {
                        "username": "pa-one55",
                        "content": "need current index and prev index only"
                    }
                ]
            },
            {
                "id": 1571449,
                "content": [
                    {
                        "username": "faisalasnari432",
                        "content": "how does it give true for \\n[99,99]\\nwhile k=2;"
                    },
                    {
                        "username": "user5279nk",
                        "content": "Is 1 test case wrong?"
                    },
                    {
                        "username": "BlakeE",
                        "content": "I\\'ve asked myself that over and over on this one"
                    },
                    {
                        "username": "Maheshkumar_2021",
                        "content": "no its properly working............"
                    },
                    {
                        "username": "cocoye",
                        "content": "I thought that if the input nums=[1,1,2,1] and k=1, the answer should be false, because  the maximum distance of duplicate number 1 is nums[3]-nums[0]=3>k,but not \"at most k......\""
                    },
                    {
                        "username": "Haeckel",
                        "content": "does it mean that there is only one pair of indices that matches the condition?"
                    },
                    {
                        "username": "luckyjessica",
                        "content": "What if the array is {1,2,3,4,6,2,8,2} and k is 2? \\nShould it return true or false? I think it should be true."
                    },
                    {
                        "username": "srapol",
                        "content": "it should be true for (2,8,2) within the array"
                    },
                    {
                        "username": "yaoqi3245",
                        "content": "Why input [1,0,1,1] 1 the result is true?\nIn this case nums[0]=1, nums[2]=1, j-i=2-0>k, is this true???\nWho can help mt with this?\nShouldn't it be the maximum of the absolute difference between i,j can't be bigger than k?"
                    },
                    {
                        "username": "twittercex000",
                        "content": "this problem is awful"
                    },
                    {
                        "username": "rwatso",
                        "content": "Hint: the code will be VERY similar to Two Sum. Use a hash map."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The problem statement is very unclear"
                    },
                    {
                        "username": "pa-one55",
                        "content": "need current index and prev index only"
                    }
                ]
            },
            {
                "id": 1571448,
                "content": [
                    {
                        "username": "faisalasnari432",
                        "content": "how does it give true for \\n[99,99]\\nwhile k=2;"
                    },
                    {
                        "username": "user5279nk",
                        "content": "Is 1 test case wrong?"
                    },
                    {
                        "username": "BlakeE",
                        "content": "I\\'ve asked myself that over and over on this one"
                    },
                    {
                        "username": "Maheshkumar_2021",
                        "content": "no its properly working............"
                    },
                    {
                        "username": "cocoye",
                        "content": "I thought that if the input nums=[1,1,2,1] and k=1, the answer should be false, because  the maximum distance of duplicate number 1 is nums[3]-nums[0]=3>k,but not \"at most k......\""
                    },
                    {
                        "username": "Haeckel",
                        "content": "does it mean that there is only one pair of indices that matches the condition?"
                    },
                    {
                        "username": "luckyjessica",
                        "content": "What if the array is {1,2,3,4,6,2,8,2} and k is 2? \\nShould it return true or false? I think it should be true."
                    },
                    {
                        "username": "srapol",
                        "content": "it should be true for (2,8,2) within the array"
                    },
                    {
                        "username": "yaoqi3245",
                        "content": "Why input [1,0,1,1] 1 the result is true?\nIn this case nums[0]=1, nums[2]=1, j-i=2-0>k, is this true???\nWho can help mt with this?\nShouldn't it be the maximum of the absolute difference between i,j can't be bigger than k?"
                    },
                    {
                        "username": "twittercex000",
                        "content": "this problem is awful"
                    },
                    {
                        "username": "rwatso",
                        "content": "Hint: the code will be VERY similar to Two Sum. Use a hash map."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The problem statement is very unclear"
                    },
                    {
                        "username": "pa-one55",
                        "content": "need current index and prev index only"
                    }
                ]
            },
            {
                "id": 1571869,
                "content": [
                    {
                        "username": "faisalasnari432",
                        "content": "how does it give true for \\n[99,99]\\nwhile k=2;"
                    },
                    {
                        "username": "user5279nk",
                        "content": "Is 1 test case wrong?"
                    },
                    {
                        "username": "BlakeE",
                        "content": "I\\'ve asked myself that over and over on this one"
                    },
                    {
                        "username": "Maheshkumar_2021",
                        "content": "no its properly working............"
                    },
                    {
                        "username": "cocoye",
                        "content": "I thought that if the input nums=[1,1,2,1] and k=1, the answer should be false, because  the maximum distance of duplicate number 1 is nums[3]-nums[0]=3>k,but not \"at most k......\""
                    },
                    {
                        "username": "Haeckel",
                        "content": "does it mean that there is only one pair of indices that matches the condition?"
                    },
                    {
                        "username": "luckyjessica",
                        "content": "What if the array is {1,2,3,4,6,2,8,2} and k is 2? \\nShould it return true or false? I think it should be true."
                    },
                    {
                        "username": "srapol",
                        "content": "it should be true for (2,8,2) within the array"
                    },
                    {
                        "username": "yaoqi3245",
                        "content": "Why input [1,0,1,1] 1 the result is true?\nIn this case nums[0]=1, nums[2]=1, j-i=2-0>k, is this true???\nWho can help mt with this?\nShouldn't it be the maximum of the absolute difference between i,j can't be bigger than k?"
                    },
                    {
                        "username": "twittercex000",
                        "content": "this problem is awful"
                    },
                    {
                        "username": "rwatso",
                        "content": "Hint: the code will be VERY similar to Two Sum. Use a hash map."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The problem statement is very unclear"
                    },
                    {
                        "username": "pa-one55",
                        "content": "need current index and prev index only"
                    }
                ]
            },
            {
                "id": 2071375,
                "content": [
                    {
                        "username": "faisalasnari432",
                        "content": "how does it give true for \\n[99,99]\\nwhile k=2;"
                    },
                    {
                        "username": "user5279nk",
                        "content": "Is 1 test case wrong?"
                    },
                    {
                        "username": "BlakeE",
                        "content": "I\\'ve asked myself that over and over on this one"
                    },
                    {
                        "username": "Maheshkumar_2021",
                        "content": "no its properly working............"
                    },
                    {
                        "username": "cocoye",
                        "content": "I thought that if the input nums=[1,1,2,1] and k=1, the answer should be false, because  the maximum distance of duplicate number 1 is nums[3]-nums[0]=3>k,but not \"at most k......\""
                    },
                    {
                        "username": "Haeckel",
                        "content": "does it mean that there is only one pair of indices that matches the condition?"
                    },
                    {
                        "username": "luckyjessica",
                        "content": "What if the array is {1,2,3,4,6,2,8,2} and k is 2? \\nShould it return true or false? I think it should be true."
                    },
                    {
                        "username": "srapol",
                        "content": "it should be true for (2,8,2) within the array"
                    },
                    {
                        "username": "yaoqi3245",
                        "content": "Why input [1,0,1,1] 1 the result is true?\nIn this case nums[0]=1, nums[2]=1, j-i=2-0>k, is this true???\nWho can help mt with this?\nShouldn't it be the maximum of the absolute difference between i,j can't be bigger than k?"
                    },
                    {
                        "username": "twittercex000",
                        "content": "this problem is awful"
                    },
                    {
                        "username": "rwatso",
                        "content": "Hint: the code will be VERY similar to Two Sum. Use a hash map."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The problem statement is very unclear"
                    },
                    {
                        "username": "pa-one55",
                        "content": "need current index and prev index only"
                    }
                ]
            },
            {
                "id": 2071308,
                "content": [
                    {
                        "username": "faisalasnari432",
                        "content": "how does it give true for \\n[99,99]\\nwhile k=2;"
                    },
                    {
                        "username": "user5279nk",
                        "content": "Is 1 test case wrong?"
                    },
                    {
                        "username": "BlakeE",
                        "content": "I\\'ve asked myself that over and over on this one"
                    },
                    {
                        "username": "Maheshkumar_2021",
                        "content": "no its properly working............"
                    },
                    {
                        "username": "cocoye",
                        "content": "I thought that if the input nums=[1,1,2,1] and k=1, the answer should be false, because  the maximum distance of duplicate number 1 is nums[3]-nums[0]=3>k,but not \"at most k......\""
                    },
                    {
                        "username": "Haeckel",
                        "content": "does it mean that there is only one pair of indices that matches the condition?"
                    },
                    {
                        "username": "luckyjessica",
                        "content": "What if the array is {1,2,3,4,6,2,8,2} and k is 2? \\nShould it return true or false? I think it should be true."
                    },
                    {
                        "username": "srapol",
                        "content": "it should be true for (2,8,2) within the array"
                    },
                    {
                        "username": "yaoqi3245",
                        "content": "Why input [1,0,1,1] 1 the result is true?\nIn this case nums[0]=1, nums[2]=1, j-i=2-0>k, is this true???\nWho can help mt with this?\nShouldn't it be the maximum of the absolute difference between i,j can't be bigger than k?"
                    },
                    {
                        "username": "twittercex000",
                        "content": "this problem is awful"
                    },
                    {
                        "username": "rwatso",
                        "content": "Hint: the code will be VERY similar to Two Sum. Use a hash map."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The problem statement is very unclear"
                    },
                    {
                        "username": "pa-one55",
                        "content": "need current index and prev index only"
                    }
                ]
            },
            {
                "id": 2061435,
                "content": [
                    {
                        "username": "faisalasnari432",
                        "content": "how does it give true for \\n[99,99]\\nwhile k=2;"
                    },
                    {
                        "username": "user5279nk",
                        "content": "Is 1 test case wrong?"
                    },
                    {
                        "username": "BlakeE",
                        "content": "I\\'ve asked myself that over and over on this one"
                    },
                    {
                        "username": "Maheshkumar_2021",
                        "content": "no its properly working............"
                    },
                    {
                        "username": "cocoye",
                        "content": "I thought that if the input nums=[1,1,2,1] and k=1, the answer should be false, because  the maximum distance of duplicate number 1 is nums[3]-nums[0]=3>k,but not \"at most k......\""
                    },
                    {
                        "username": "Haeckel",
                        "content": "does it mean that there is only one pair of indices that matches the condition?"
                    },
                    {
                        "username": "luckyjessica",
                        "content": "What if the array is {1,2,3,4,6,2,8,2} and k is 2? \\nShould it return true or false? I think it should be true."
                    },
                    {
                        "username": "srapol",
                        "content": "it should be true for (2,8,2) within the array"
                    },
                    {
                        "username": "yaoqi3245",
                        "content": "Why input [1,0,1,1] 1 the result is true?\nIn this case nums[0]=1, nums[2]=1, j-i=2-0>k, is this true???\nWho can help mt with this?\nShouldn't it be the maximum of the absolute difference between i,j can't be bigger than k?"
                    },
                    {
                        "username": "twittercex000",
                        "content": "this problem is awful"
                    },
                    {
                        "username": "rwatso",
                        "content": "Hint: the code will be VERY similar to Two Sum. Use a hash map."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The problem statement is very unclear"
                    },
                    {
                        "username": "pa-one55",
                        "content": "need current index and prev index only"
                    }
                ]
            },
            {
                "id": 2057361,
                "content": [
                    {
                        "username": "faisalasnari432",
                        "content": "how does it give true for \\n[99,99]\\nwhile k=2;"
                    },
                    {
                        "username": "user5279nk",
                        "content": "Is 1 test case wrong?"
                    },
                    {
                        "username": "BlakeE",
                        "content": "I\\'ve asked myself that over and over on this one"
                    },
                    {
                        "username": "Maheshkumar_2021",
                        "content": "no its properly working............"
                    },
                    {
                        "username": "cocoye",
                        "content": "I thought that if the input nums=[1,1,2,1] and k=1, the answer should be false, because  the maximum distance of duplicate number 1 is nums[3]-nums[0]=3>k,but not \"at most k......\""
                    },
                    {
                        "username": "Haeckel",
                        "content": "does it mean that there is only one pair of indices that matches the condition?"
                    },
                    {
                        "username": "luckyjessica",
                        "content": "What if the array is {1,2,3,4,6,2,8,2} and k is 2? \\nShould it return true or false? I think it should be true."
                    },
                    {
                        "username": "srapol",
                        "content": "it should be true for (2,8,2) within the array"
                    },
                    {
                        "username": "yaoqi3245",
                        "content": "Why input [1,0,1,1] 1 the result is true?\nIn this case nums[0]=1, nums[2]=1, j-i=2-0>k, is this true???\nWho can help mt with this?\nShouldn't it be the maximum of the absolute difference between i,j can't be bigger than k?"
                    },
                    {
                        "username": "twittercex000",
                        "content": "this problem is awful"
                    },
                    {
                        "username": "rwatso",
                        "content": "Hint: the code will be VERY similar to Two Sum. Use a hash map."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The problem statement is very unclear"
                    },
                    {
                        "username": "pa-one55",
                        "content": "need current index and prev index only"
                    }
                ]
            },
            {
                "id": 2057118,
                "content": [
                    {
                        "username": "riddhitayal",
                        "content": "Description of this program is not clear. The question is that if any number repeat itself before window(k) or at window (k) it returns true, otherwise return false. Example: nums = { 1,2,1,4,5 } and k = 4\\nthen it return true because 1 repeat itself before k or at k  . "
                    },
                    {
                        "username": "VenkatakrishnanM",
                        "content": "Let me try to explain this question in a easy way. This question asks us to check if two digits are equal and the distance between them is <=k.\\n\\nFirst tip is, calculate the distance using index positions.\\nOne more trick is explained using the test case below. \\n\\nInput: nums = [1,0,1,1], k = 1\\nOutput: true\\n\\nHere we have \"1\" at the index 0,2,3. Note that the distance between 1s present at index 0 and 2 is greater than the \"k\" value. But the distance between 1s present at index 2 and  3 is <=k. \\nTherefore, the catch here is, we should not only consider the first matching value, but all possible matches that are possible."
                    },
                    {
                        "username": "shrutibinani06",
                        "content": "example 2 is trueeee!!!???????????????? like howwww???\\nThis question is really confusing \\nThis question doesnt tell about anything\\nSuper Confusing"
                    },
                    {
                        "username": "vinod95359199",
                        "content": "without using set can we solve this problem....?\nclass Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) \n    {\n        int a=nums.length;\n        for(int i=0;i<a;i++)\n        {\n            for(int j=i+1;j<a;j++)\n            {\n                if(nums[i]==nums[j]&& (i-j)<=k){\n                    return true;\n                    \n                }\n            }\n        }\n       return false;\n    }\n}"
                    },
                    {
                        "username": "Domesan",
                        "content": "Note:  Here nums[i] == nums[j] and abs(i - j) <= k  , At first they compare the value of the elements as if they are equal or not , secondly they compare the index value not the element .  Read the description properly this is kind of sum which took less than 5 min for me to solve"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just squeezed 38ms and 48ms and 67.4 Mb out of a custom container (C++). STL is really deficient at these tasks.\nThe former top record was 72ms from a guy who used quicksort with early exit via exception and as such, got almost O(n) complexity instead of O(n log n). Violent but beautiful. Nevertheless, the true O(n) algorithm now left him far behind..."
                    },
                    {
                        "username": "faisalasnari432",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n      for ( int i=0;i<nums.length-k;i++)\\n      {\\n         int j= i+1;\\n          while ( j<=(i+k))\\n          {\\n             if ( nums[i]==nums[j])\\n             {\\n                \\n                \\n                  return true;\\n                \\n             }\\n             \\n             j++;\\n          }\\n          System.out.println(j);\\n      }\\n      return false;\\n        \\n    }\\n}\\nwhats wrong in this ??"
                    },
                    {
                        "username": "Mohit__k135",
                        "content": "i think ques is not properly describe"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "It is"
                    },
                    {
                        "username": "Farhan_313",
                        "content": "1. hashmap\\n2. if found\\n         *  check condition --> return true;\\n         *   else  overrite the map value to current index to get difference less if again same nums[i present further\\n3. return false;"
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "Is there any approach to solve this question without using linear search ???"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "You can use two for/while loops and check for every substring whose size is <=k. "
                    }
                ]
            },
            {
                "id": 2055948,
                "content": [
                    {
                        "username": "riddhitayal",
                        "content": "Description of this program is not clear. The question is that if any number repeat itself before window(k) or at window (k) it returns true, otherwise return false. Example: nums = { 1,2,1,4,5 } and k = 4\\nthen it return true because 1 repeat itself before k or at k  . "
                    },
                    {
                        "username": "VenkatakrishnanM",
                        "content": "Let me try to explain this question in a easy way. This question asks us to check if two digits are equal and the distance between them is <=k.\\n\\nFirst tip is, calculate the distance using index positions.\\nOne more trick is explained using the test case below. \\n\\nInput: nums = [1,0,1,1], k = 1\\nOutput: true\\n\\nHere we have \"1\" at the index 0,2,3. Note that the distance between 1s present at index 0 and 2 is greater than the \"k\" value. But the distance between 1s present at index 2 and  3 is <=k. \\nTherefore, the catch here is, we should not only consider the first matching value, but all possible matches that are possible."
                    },
                    {
                        "username": "shrutibinani06",
                        "content": "example 2 is trueeee!!!???????????????? like howwww???\\nThis question is really confusing \\nThis question doesnt tell about anything\\nSuper Confusing"
                    },
                    {
                        "username": "vinod95359199",
                        "content": "without using set can we solve this problem....?\nclass Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) \n    {\n        int a=nums.length;\n        for(int i=0;i<a;i++)\n        {\n            for(int j=i+1;j<a;j++)\n            {\n                if(nums[i]==nums[j]&& (i-j)<=k){\n                    return true;\n                    \n                }\n            }\n        }\n       return false;\n    }\n}"
                    },
                    {
                        "username": "Domesan",
                        "content": "Note:  Here nums[i] == nums[j] and abs(i - j) <= k  , At first they compare the value of the elements as if they are equal or not , secondly they compare the index value not the element .  Read the description properly this is kind of sum which took less than 5 min for me to solve"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just squeezed 38ms and 48ms and 67.4 Mb out of a custom container (C++). STL is really deficient at these tasks.\nThe former top record was 72ms from a guy who used quicksort with early exit via exception and as such, got almost O(n) complexity instead of O(n log n). Violent but beautiful. Nevertheless, the true O(n) algorithm now left him far behind..."
                    },
                    {
                        "username": "faisalasnari432",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n      for ( int i=0;i<nums.length-k;i++)\\n      {\\n         int j= i+1;\\n          while ( j<=(i+k))\\n          {\\n             if ( nums[i]==nums[j])\\n             {\\n                \\n                \\n                  return true;\\n                \\n             }\\n             \\n             j++;\\n          }\\n          System.out.println(j);\\n      }\\n      return false;\\n        \\n    }\\n}\\nwhats wrong in this ??"
                    },
                    {
                        "username": "Mohit__k135",
                        "content": "i think ques is not properly describe"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "It is"
                    },
                    {
                        "username": "Farhan_313",
                        "content": "1. hashmap\\n2. if found\\n         *  check condition --> return true;\\n         *   else  overrite the map value to current index to get difference less if again same nums[i present further\\n3. return false;"
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "Is there any approach to solve this question without using linear search ???"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "You can use two for/while loops and check for every substring whose size is <=k. "
                    }
                ]
            },
            {
                "id": 2055282,
                "content": [
                    {
                        "username": "riddhitayal",
                        "content": "Description of this program is not clear. The question is that if any number repeat itself before window(k) or at window (k) it returns true, otherwise return false. Example: nums = { 1,2,1,4,5 } and k = 4\\nthen it return true because 1 repeat itself before k or at k  . "
                    },
                    {
                        "username": "VenkatakrishnanM",
                        "content": "Let me try to explain this question in a easy way. This question asks us to check if two digits are equal and the distance between them is <=k.\\n\\nFirst tip is, calculate the distance using index positions.\\nOne more trick is explained using the test case below. \\n\\nInput: nums = [1,0,1,1], k = 1\\nOutput: true\\n\\nHere we have \"1\" at the index 0,2,3. Note that the distance between 1s present at index 0 and 2 is greater than the \"k\" value. But the distance between 1s present at index 2 and  3 is <=k. \\nTherefore, the catch here is, we should not only consider the first matching value, but all possible matches that are possible."
                    },
                    {
                        "username": "shrutibinani06",
                        "content": "example 2 is trueeee!!!???????????????? like howwww???\\nThis question is really confusing \\nThis question doesnt tell about anything\\nSuper Confusing"
                    },
                    {
                        "username": "vinod95359199",
                        "content": "without using set can we solve this problem....?\nclass Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) \n    {\n        int a=nums.length;\n        for(int i=0;i<a;i++)\n        {\n            for(int j=i+1;j<a;j++)\n            {\n                if(nums[i]==nums[j]&& (i-j)<=k){\n                    return true;\n                    \n                }\n            }\n        }\n       return false;\n    }\n}"
                    },
                    {
                        "username": "Domesan",
                        "content": "Note:  Here nums[i] == nums[j] and abs(i - j) <= k  , At first they compare the value of the elements as if they are equal or not , secondly they compare the index value not the element .  Read the description properly this is kind of sum which took less than 5 min for me to solve"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just squeezed 38ms and 48ms and 67.4 Mb out of a custom container (C++). STL is really deficient at these tasks.\nThe former top record was 72ms from a guy who used quicksort with early exit via exception and as such, got almost O(n) complexity instead of O(n log n). Violent but beautiful. Nevertheless, the true O(n) algorithm now left him far behind..."
                    },
                    {
                        "username": "faisalasnari432",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n      for ( int i=0;i<nums.length-k;i++)\\n      {\\n         int j= i+1;\\n          while ( j<=(i+k))\\n          {\\n             if ( nums[i]==nums[j])\\n             {\\n                \\n                \\n                  return true;\\n                \\n             }\\n             \\n             j++;\\n          }\\n          System.out.println(j);\\n      }\\n      return false;\\n        \\n    }\\n}\\nwhats wrong in this ??"
                    },
                    {
                        "username": "Mohit__k135",
                        "content": "i think ques is not properly describe"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "It is"
                    },
                    {
                        "username": "Farhan_313",
                        "content": "1. hashmap\\n2. if found\\n         *  check condition --> return true;\\n         *   else  overrite the map value to current index to get difference less if again same nums[i present further\\n3. return false;"
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "Is there any approach to solve this question without using linear search ???"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "You can use two for/while loops and check for every substring whose size is <=k. "
                    }
                ]
            },
            {
                "id": 2054554,
                "content": [
                    {
                        "username": "riddhitayal",
                        "content": "Description of this program is not clear. The question is that if any number repeat itself before window(k) or at window (k) it returns true, otherwise return false. Example: nums = { 1,2,1,4,5 } and k = 4\\nthen it return true because 1 repeat itself before k or at k  . "
                    },
                    {
                        "username": "VenkatakrishnanM",
                        "content": "Let me try to explain this question in a easy way. This question asks us to check if two digits are equal and the distance between them is <=k.\\n\\nFirst tip is, calculate the distance using index positions.\\nOne more trick is explained using the test case below. \\n\\nInput: nums = [1,0,1,1], k = 1\\nOutput: true\\n\\nHere we have \"1\" at the index 0,2,3. Note that the distance between 1s present at index 0 and 2 is greater than the \"k\" value. But the distance between 1s present at index 2 and  3 is <=k. \\nTherefore, the catch here is, we should not only consider the first matching value, but all possible matches that are possible."
                    },
                    {
                        "username": "shrutibinani06",
                        "content": "example 2 is trueeee!!!???????????????? like howwww???\\nThis question is really confusing \\nThis question doesnt tell about anything\\nSuper Confusing"
                    },
                    {
                        "username": "vinod95359199",
                        "content": "without using set can we solve this problem....?\nclass Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) \n    {\n        int a=nums.length;\n        for(int i=0;i<a;i++)\n        {\n            for(int j=i+1;j<a;j++)\n            {\n                if(nums[i]==nums[j]&& (i-j)<=k){\n                    return true;\n                    \n                }\n            }\n        }\n       return false;\n    }\n}"
                    },
                    {
                        "username": "Domesan",
                        "content": "Note:  Here nums[i] == nums[j] and abs(i - j) <= k  , At first they compare the value of the elements as if they are equal or not , secondly they compare the index value not the element .  Read the description properly this is kind of sum which took less than 5 min for me to solve"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just squeezed 38ms and 48ms and 67.4 Mb out of a custom container (C++). STL is really deficient at these tasks.\nThe former top record was 72ms from a guy who used quicksort with early exit via exception and as such, got almost O(n) complexity instead of O(n log n). Violent but beautiful. Nevertheless, the true O(n) algorithm now left him far behind..."
                    },
                    {
                        "username": "faisalasnari432",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n      for ( int i=0;i<nums.length-k;i++)\\n      {\\n         int j= i+1;\\n          while ( j<=(i+k))\\n          {\\n             if ( nums[i]==nums[j])\\n             {\\n                \\n                \\n                  return true;\\n                \\n             }\\n             \\n             j++;\\n          }\\n          System.out.println(j);\\n      }\\n      return false;\\n        \\n    }\\n}\\nwhats wrong in this ??"
                    },
                    {
                        "username": "Mohit__k135",
                        "content": "i think ques is not properly describe"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "It is"
                    },
                    {
                        "username": "Farhan_313",
                        "content": "1. hashmap\\n2. if found\\n         *  check condition --> return true;\\n         *   else  overrite the map value to current index to get difference less if again same nums[i present further\\n3. return false;"
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "Is there any approach to solve this question without using linear search ???"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "You can use two for/while loops and check for every substring whose size is <=k. "
                    }
                ]
            },
            {
                "id": 2035835,
                "content": [
                    {
                        "username": "riddhitayal",
                        "content": "Description of this program is not clear. The question is that if any number repeat itself before window(k) or at window (k) it returns true, otherwise return false. Example: nums = { 1,2,1,4,5 } and k = 4\\nthen it return true because 1 repeat itself before k or at k  . "
                    },
                    {
                        "username": "VenkatakrishnanM",
                        "content": "Let me try to explain this question in a easy way. This question asks us to check if two digits are equal and the distance between them is <=k.\\n\\nFirst tip is, calculate the distance using index positions.\\nOne more trick is explained using the test case below. \\n\\nInput: nums = [1,0,1,1], k = 1\\nOutput: true\\n\\nHere we have \"1\" at the index 0,2,3. Note that the distance between 1s present at index 0 and 2 is greater than the \"k\" value. But the distance between 1s present at index 2 and  3 is <=k. \\nTherefore, the catch here is, we should not only consider the first matching value, but all possible matches that are possible."
                    },
                    {
                        "username": "shrutibinani06",
                        "content": "example 2 is trueeee!!!???????????????? like howwww???\\nThis question is really confusing \\nThis question doesnt tell about anything\\nSuper Confusing"
                    },
                    {
                        "username": "vinod95359199",
                        "content": "without using set can we solve this problem....?\nclass Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) \n    {\n        int a=nums.length;\n        for(int i=0;i<a;i++)\n        {\n            for(int j=i+1;j<a;j++)\n            {\n                if(nums[i]==nums[j]&& (i-j)<=k){\n                    return true;\n                    \n                }\n            }\n        }\n       return false;\n    }\n}"
                    },
                    {
                        "username": "Domesan",
                        "content": "Note:  Here nums[i] == nums[j] and abs(i - j) <= k  , At first they compare the value of the elements as if they are equal or not , secondly they compare the index value not the element .  Read the description properly this is kind of sum which took less than 5 min for me to solve"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just squeezed 38ms and 48ms and 67.4 Mb out of a custom container (C++). STL is really deficient at these tasks.\nThe former top record was 72ms from a guy who used quicksort with early exit via exception and as such, got almost O(n) complexity instead of O(n log n). Violent but beautiful. Nevertheless, the true O(n) algorithm now left him far behind..."
                    },
                    {
                        "username": "faisalasnari432",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n      for ( int i=0;i<nums.length-k;i++)\\n      {\\n         int j= i+1;\\n          while ( j<=(i+k))\\n          {\\n             if ( nums[i]==nums[j])\\n             {\\n                \\n                \\n                  return true;\\n                \\n             }\\n             \\n             j++;\\n          }\\n          System.out.println(j);\\n      }\\n      return false;\\n        \\n    }\\n}\\nwhats wrong in this ??"
                    },
                    {
                        "username": "Mohit__k135",
                        "content": "i think ques is not properly describe"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "It is"
                    },
                    {
                        "username": "Farhan_313",
                        "content": "1. hashmap\\n2. if found\\n         *  check condition --> return true;\\n         *   else  overrite the map value to current index to get difference less if again same nums[i present further\\n3. return false;"
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "Is there any approach to solve this question without using linear search ???"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "You can use two for/while loops and check for every substring whose size is <=k. "
                    }
                ]
            },
            {
                "id": 2034491,
                "content": [
                    {
                        "username": "riddhitayal",
                        "content": "Description of this program is not clear. The question is that if any number repeat itself before window(k) or at window (k) it returns true, otherwise return false. Example: nums = { 1,2,1,4,5 } and k = 4\\nthen it return true because 1 repeat itself before k or at k  . "
                    },
                    {
                        "username": "VenkatakrishnanM",
                        "content": "Let me try to explain this question in a easy way. This question asks us to check if two digits are equal and the distance between them is <=k.\\n\\nFirst tip is, calculate the distance using index positions.\\nOne more trick is explained using the test case below. \\n\\nInput: nums = [1,0,1,1], k = 1\\nOutput: true\\n\\nHere we have \"1\" at the index 0,2,3. Note that the distance between 1s present at index 0 and 2 is greater than the \"k\" value. But the distance between 1s present at index 2 and  3 is <=k. \\nTherefore, the catch here is, we should not only consider the first matching value, but all possible matches that are possible."
                    },
                    {
                        "username": "shrutibinani06",
                        "content": "example 2 is trueeee!!!???????????????? like howwww???\\nThis question is really confusing \\nThis question doesnt tell about anything\\nSuper Confusing"
                    },
                    {
                        "username": "vinod95359199",
                        "content": "without using set can we solve this problem....?\nclass Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) \n    {\n        int a=nums.length;\n        for(int i=0;i<a;i++)\n        {\n            for(int j=i+1;j<a;j++)\n            {\n                if(nums[i]==nums[j]&& (i-j)<=k){\n                    return true;\n                    \n                }\n            }\n        }\n       return false;\n    }\n}"
                    },
                    {
                        "username": "Domesan",
                        "content": "Note:  Here nums[i] == nums[j] and abs(i - j) <= k  , At first they compare the value of the elements as if they are equal or not , secondly they compare the index value not the element .  Read the description properly this is kind of sum which took less than 5 min for me to solve"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just squeezed 38ms and 48ms and 67.4 Mb out of a custom container (C++). STL is really deficient at these tasks.\nThe former top record was 72ms from a guy who used quicksort with early exit via exception and as such, got almost O(n) complexity instead of O(n log n). Violent but beautiful. Nevertheless, the true O(n) algorithm now left him far behind..."
                    },
                    {
                        "username": "faisalasnari432",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n      for ( int i=0;i<nums.length-k;i++)\\n      {\\n         int j= i+1;\\n          while ( j<=(i+k))\\n          {\\n             if ( nums[i]==nums[j])\\n             {\\n                \\n                \\n                  return true;\\n                \\n             }\\n             \\n             j++;\\n          }\\n          System.out.println(j);\\n      }\\n      return false;\\n        \\n    }\\n}\\nwhats wrong in this ??"
                    },
                    {
                        "username": "Mohit__k135",
                        "content": "i think ques is not properly describe"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "It is"
                    },
                    {
                        "username": "Farhan_313",
                        "content": "1. hashmap\\n2. if found\\n         *  check condition --> return true;\\n         *   else  overrite the map value to current index to get difference less if again same nums[i present further\\n3. return false;"
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "Is there any approach to solve this question without using linear search ???"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "You can use two for/while loops and check for every substring whose size is <=k. "
                    }
                ]
            },
            {
                "id": 2027665,
                "content": [
                    {
                        "username": "riddhitayal",
                        "content": "Description of this program is not clear. The question is that if any number repeat itself before window(k) or at window (k) it returns true, otherwise return false. Example: nums = { 1,2,1,4,5 } and k = 4\\nthen it return true because 1 repeat itself before k or at k  . "
                    },
                    {
                        "username": "VenkatakrishnanM",
                        "content": "Let me try to explain this question in a easy way. This question asks us to check if two digits are equal and the distance between them is <=k.\\n\\nFirst tip is, calculate the distance using index positions.\\nOne more trick is explained using the test case below. \\n\\nInput: nums = [1,0,1,1], k = 1\\nOutput: true\\n\\nHere we have \"1\" at the index 0,2,3. Note that the distance between 1s present at index 0 and 2 is greater than the \"k\" value. But the distance between 1s present at index 2 and  3 is <=k. \\nTherefore, the catch here is, we should not only consider the first matching value, but all possible matches that are possible."
                    },
                    {
                        "username": "shrutibinani06",
                        "content": "example 2 is trueeee!!!???????????????? like howwww???\\nThis question is really confusing \\nThis question doesnt tell about anything\\nSuper Confusing"
                    },
                    {
                        "username": "vinod95359199",
                        "content": "without using set can we solve this problem....?\nclass Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) \n    {\n        int a=nums.length;\n        for(int i=0;i<a;i++)\n        {\n            for(int j=i+1;j<a;j++)\n            {\n                if(nums[i]==nums[j]&& (i-j)<=k){\n                    return true;\n                    \n                }\n            }\n        }\n       return false;\n    }\n}"
                    },
                    {
                        "username": "Domesan",
                        "content": "Note:  Here nums[i] == nums[j] and abs(i - j) <= k  , At first they compare the value of the elements as if they are equal or not , secondly they compare the index value not the element .  Read the description properly this is kind of sum which took less than 5 min for me to solve"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just squeezed 38ms and 48ms and 67.4 Mb out of a custom container (C++). STL is really deficient at these tasks.\nThe former top record was 72ms from a guy who used quicksort with early exit via exception and as such, got almost O(n) complexity instead of O(n log n). Violent but beautiful. Nevertheless, the true O(n) algorithm now left him far behind..."
                    },
                    {
                        "username": "faisalasnari432",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n      for ( int i=0;i<nums.length-k;i++)\\n      {\\n         int j= i+1;\\n          while ( j<=(i+k))\\n          {\\n             if ( nums[i]==nums[j])\\n             {\\n                \\n                \\n                  return true;\\n                \\n             }\\n             \\n             j++;\\n          }\\n          System.out.println(j);\\n      }\\n      return false;\\n        \\n    }\\n}\\nwhats wrong in this ??"
                    },
                    {
                        "username": "Mohit__k135",
                        "content": "i think ques is not properly describe"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "It is"
                    },
                    {
                        "username": "Farhan_313",
                        "content": "1. hashmap\\n2. if found\\n         *  check condition --> return true;\\n         *   else  overrite the map value to current index to get difference less if again same nums[i present further\\n3. return false;"
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "Is there any approach to solve this question without using linear search ???"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "You can use two for/while loops and check for every substring whose size is <=k. "
                    }
                ]
            },
            {
                "id": 2013835,
                "content": [
                    {
                        "username": "riddhitayal",
                        "content": "Description of this program is not clear. The question is that if any number repeat itself before window(k) or at window (k) it returns true, otherwise return false. Example: nums = { 1,2,1,4,5 } and k = 4\\nthen it return true because 1 repeat itself before k or at k  . "
                    },
                    {
                        "username": "VenkatakrishnanM",
                        "content": "Let me try to explain this question in a easy way. This question asks us to check if two digits are equal and the distance between them is <=k.\\n\\nFirst tip is, calculate the distance using index positions.\\nOne more trick is explained using the test case below. \\n\\nInput: nums = [1,0,1,1], k = 1\\nOutput: true\\n\\nHere we have \"1\" at the index 0,2,3. Note that the distance between 1s present at index 0 and 2 is greater than the \"k\" value. But the distance between 1s present at index 2 and  3 is <=k. \\nTherefore, the catch here is, we should not only consider the first matching value, but all possible matches that are possible."
                    },
                    {
                        "username": "shrutibinani06",
                        "content": "example 2 is trueeee!!!???????????????? like howwww???\\nThis question is really confusing \\nThis question doesnt tell about anything\\nSuper Confusing"
                    },
                    {
                        "username": "vinod95359199",
                        "content": "without using set can we solve this problem....?\nclass Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) \n    {\n        int a=nums.length;\n        for(int i=0;i<a;i++)\n        {\n            for(int j=i+1;j<a;j++)\n            {\n                if(nums[i]==nums[j]&& (i-j)<=k){\n                    return true;\n                    \n                }\n            }\n        }\n       return false;\n    }\n}"
                    },
                    {
                        "username": "Domesan",
                        "content": "Note:  Here nums[i] == nums[j] and abs(i - j) <= k  , At first they compare the value of the elements as if they are equal or not , secondly they compare the index value not the element .  Read the description properly this is kind of sum which took less than 5 min for me to solve"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just squeezed 38ms and 48ms and 67.4 Mb out of a custom container (C++). STL is really deficient at these tasks.\nThe former top record was 72ms from a guy who used quicksort with early exit via exception and as such, got almost O(n) complexity instead of O(n log n). Violent but beautiful. Nevertheless, the true O(n) algorithm now left him far behind..."
                    },
                    {
                        "username": "faisalasnari432",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n      for ( int i=0;i<nums.length-k;i++)\\n      {\\n         int j= i+1;\\n          while ( j<=(i+k))\\n          {\\n             if ( nums[i]==nums[j])\\n             {\\n                \\n                \\n                  return true;\\n                \\n             }\\n             \\n             j++;\\n          }\\n          System.out.println(j);\\n      }\\n      return false;\\n        \\n    }\\n}\\nwhats wrong in this ??"
                    },
                    {
                        "username": "Mohit__k135",
                        "content": "i think ques is not properly describe"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "It is"
                    },
                    {
                        "username": "Farhan_313",
                        "content": "1. hashmap\\n2. if found\\n         *  check condition --> return true;\\n         *   else  overrite the map value to current index to get difference less if again same nums[i present further\\n3. return false;"
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "Is there any approach to solve this question without using linear search ???"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "You can use two for/while loops and check for every substring whose size is <=k. "
                    }
                ]
            },
            {
                "id": 2011140,
                "content": [
                    {
                        "username": "riddhitayal",
                        "content": "Description of this program is not clear. The question is that if any number repeat itself before window(k) or at window (k) it returns true, otherwise return false. Example: nums = { 1,2,1,4,5 } and k = 4\\nthen it return true because 1 repeat itself before k or at k  . "
                    },
                    {
                        "username": "VenkatakrishnanM",
                        "content": "Let me try to explain this question in a easy way. This question asks us to check if two digits are equal and the distance between them is <=k.\\n\\nFirst tip is, calculate the distance using index positions.\\nOne more trick is explained using the test case below. \\n\\nInput: nums = [1,0,1,1], k = 1\\nOutput: true\\n\\nHere we have \"1\" at the index 0,2,3. Note that the distance between 1s present at index 0 and 2 is greater than the \"k\" value. But the distance between 1s present at index 2 and  3 is <=k. \\nTherefore, the catch here is, we should not only consider the first matching value, but all possible matches that are possible."
                    },
                    {
                        "username": "shrutibinani06",
                        "content": "example 2 is trueeee!!!???????????????? like howwww???\\nThis question is really confusing \\nThis question doesnt tell about anything\\nSuper Confusing"
                    },
                    {
                        "username": "vinod95359199",
                        "content": "without using set can we solve this problem....?\nclass Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) \n    {\n        int a=nums.length;\n        for(int i=0;i<a;i++)\n        {\n            for(int j=i+1;j<a;j++)\n            {\n                if(nums[i]==nums[j]&& (i-j)<=k){\n                    return true;\n                    \n                }\n            }\n        }\n       return false;\n    }\n}"
                    },
                    {
                        "username": "Domesan",
                        "content": "Note:  Here nums[i] == nums[j] and abs(i - j) <= k  , At first they compare the value of the elements as if they are equal or not , secondly they compare the index value not the element .  Read the description properly this is kind of sum which took less than 5 min for me to solve"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just squeezed 38ms and 48ms and 67.4 Mb out of a custom container (C++). STL is really deficient at these tasks.\nThe former top record was 72ms from a guy who used quicksort with early exit via exception and as such, got almost O(n) complexity instead of O(n log n). Violent but beautiful. Nevertheless, the true O(n) algorithm now left him far behind..."
                    },
                    {
                        "username": "faisalasnari432",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n      for ( int i=0;i<nums.length-k;i++)\\n      {\\n         int j= i+1;\\n          while ( j<=(i+k))\\n          {\\n             if ( nums[i]==nums[j])\\n             {\\n                \\n                \\n                  return true;\\n                \\n             }\\n             \\n             j++;\\n          }\\n          System.out.println(j);\\n      }\\n      return false;\\n        \\n    }\\n}\\nwhats wrong in this ??"
                    },
                    {
                        "username": "Mohit__k135",
                        "content": "i think ques is not properly describe"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "It is"
                    },
                    {
                        "username": "Farhan_313",
                        "content": "1. hashmap\\n2. if found\\n         *  check condition --> return true;\\n         *   else  overrite the map value to current index to get difference less if again same nums[i present further\\n3. return false;"
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "Is there any approach to solve this question without using linear search ???"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "You can use two for/while loops and check for every substring whose size is <=k. "
                    }
                ]
            },
            {
                "id": 2011118,
                "content": [
                    {
                        "username": "riddhitayal",
                        "content": "Description of this program is not clear. The question is that if any number repeat itself before window(k) or at window (k) it returns true, otherwise return false. Example: nums = { 1,2,1,4,5 } and k = 4\\nthen it return true because 1 repeat itself before k or at k  . "
                    },
                    {
                        "username": "VenkatakrishnanM",
                        "content": "Let me try to explain this question in a easy way. This question asks us to check if two digits are equal and the distance between them is <=k.\\n\\nFirst tip is, calculate the distance using index positions.\\nOne more trick is explained using the test case below. \\n\\nInput: nums = [1,0,1,1], k = 1\\nOutput: true\\n\\nHere we have \"1\" at the index 0,2,3. Note that the distance between 1s present at index 0 and 2 is greater than the \"k\" value. But the distance between 1s present at index 2 and  3 is <=k. \\nTherefore, the catch here is, we should not only consider the first matching value, but all possible matches that are possible."
                    },
                    {
                        "username": "shrutibinani06",
                        "content": "example 2 is trueeee!!!???????????????? like howwww???\\nThis question is really confusing \\nThis question doesnt tell about anything\\nSuper Confusing"
                    },
                    {
                        "username": "vinod95359199",
                        "content": "without using set can we solve this problem....?\nclass Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) \n    {\n        int a=nums.length;\n        for(int i=0;i<a;i++)\n        {\n            for(int j=i+1;j<a;j++)\n            {\n                if(nums[i]==nums[j]&& (i-j)<=k){\n                    return true;\n                    \n                }\n            }\n        }\n       return false;\n    }\n}"
                    },
                    {
                        "username": "Domesan",
                        "content": "Note:  Here nums[i] == nums[j] and abs(i - j) <= k  , At first they compare the value of the elements as if they are equal or not , secondly they compare the index value not the element .  Read the description properly this is kind of sum which took less than 5 min for me to solve"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just squeezed 38ms and 48ms and 67.4 Mb out of a custom container (C++). STL is really deficient at these tasks.\nThe former top record was 72ms from a guy who used quicksort with early exit via exception and as such, got almost O(n) complexity instead of O(n log n). Violent but beautiful. Nevertheless, the true O(n) algorithm now left him far behind..."
                    },
                    {
                        "username": "faisalasnari432",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n      for ( int i=0;i<nums.length-k;i++)\\n      {\\n         int j= i+1;\\n          while ( j<=(i+k))\\n          {\\n             if ( nums[i]==nums[j])\\n             {\\n                \\n                \\n                  return true;\\n                \\n             }\\n             \\n             j++;\\n          }\\n          System.out.println(j);\\n      }\\n      return false;\\n        \\n    }\\n}\\nwhats wrong in this ??"
                    },
                    {
                        "username": "Mohit__k135",
                        "content": "i think ques is not properly describe"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "It is"
                    },
                    {
                        "username": "Farhan_313",
                        "content": "1. hashmap\\n2. if found\\n         *  check condition --> return true;\\n         *   else  overrite the map value to current index to get difference less if again same nums[i present further\\n3. return false;"
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "Is there any approach to solve this question without using linear search ???"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "You can use two for/while loops and check for every substring whose size is <=k. "
                    }
                ]
            },
            {
                "id": 2003478,
                "content": [
                    {
                        "username": "overbound",
                        "content": "You don\\'t need a Hashmap. This can be solved with 2 pointers."
                    },
                    {
                        "username": "nitya_333",
                        "content": "then can you please provide a solution\\n"
                    },
                    {
                        "username": "Tabish111",
                        "content": "in test case 1 , \\nnums = [1,2,3,1], k = 3\\nhow does 3 has distinct indices , i and j ?\\ni and j will be same\\n?"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "i=0 & j=3. So nums[i] == nums[j] and abs(i-j) = 3 which is lesaa than or equal to k."
                    },
                    {
                        "username": "eduard92",
                        "content": "Thanks bro for this shit description..... I am already pissed off because of a girl and I cursed your question 3 minutes straight and I figured out the logic in 2."
                    },
                    {
                        "username": "sopheary",
                        "content": "Easy to get confusing with the description, should tell what is the K. \\nk is number of range that we have to check the value."
                    },
                    {
                        "username": "eduard92",
                        "content": "took me two minutes to figure that out, now I am stuck at test cases [1], k=1, I am doing Sliding Window approach.."
                    },
                    {
                        "username": "saketg54",
                        "content": "my code checks this condition and only then return true but the testcases is giving me true when clearly both the elements are not same\\ncode for this specific conditon:\\ni =0; j =1\\nif(nums[i] == nums[j]){\\n                if(abs(i - j) <= k){\\n                    return true;\\n                }\\ntest case: nums = [1,2] k = 2 output = true; expected = false\\n"
                    },
                    {
                        "username": "Arpit_Sri85",
                        "content": "Please review my code and Give me a hint of problem in my code,    \n\n\nclass Solution {\npublic:\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\n\n        sort(nums.begin(), nums.end());\n\n        int n = nums.size();\n        int i = 0;\n        int j = i - 1;\n        for(; i < n; i++){\n            if(nums[i] == nums[j] && abs(i - j) <= k ){\n                return true;\n            }\n            \n        }\n        return false;\n    }\n};"
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@Arpit_Sri85](/Arpit_Sri85) I won\\'t solve it for you because if you want solution you can just check the Solutions tab and ask the author about their solution. That said, I can try lead you to one. What\\'s your understanding of the question? What reason or what problem make you want to sort the array."
                    },
                    {
                        "username": "Arpit_Sri85",
                        "content": "[@Kaltu](/Kaltu) Can you resolve it, I will be very thankful for you. I am new to Coding, So I am making too much errors "
                    },
                    {
                        "username": "Kaltu",
                        "content": "you lost the original index when sorting"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 just insert the element of a window of size equal to k\\n\\uD83D\\uDFE2 and then slide it one by one and check if there is any repetitive number"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Just a sliding window thing\\n"
                    },
                    {
                        "username": "bimarsh-12",
                        "content": "I get it but I think some of the test cases provided for this question is wrong"
                    },
                    {
                        "username": "stemaboxd",
                        "content": "Better explanation: The objective is to check if in the nums array there are two equal numbers (duplicates) that are at a distance k or less."
                    }
                ]
            },
            {
                "id": 2000576,
                "content": [
                    {
                        "username": "overbound",
                        "content": "You don\\'t need a Hashmap. This can be solved with 2 pointers."
                    },
                    {
                        "username": "nitya_333",
                        "content": "then can you please provide a solution\\n"
                    },
                    {
                        "username": "Tabish111",
                        "content": "in test case 1 , \\nnums = [1,2,3,1], k = 3\\nhow does 3 has distinct indices , i and j ?\\ni and j will be same\\n?"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "i=0 & j=3. So nums[i] == nums[j] and abs(i-j) = 3 which is lesaa than or equal to k."
                    },
                    {
                        "username": "eduard92",
                        "content": "Thanks bro for this shit description..... I am already pissed off because of a girl and I cursed your question 3 minutes straight and I figured out the logic in 2."
                    },
                    {
                        "username": "sopheary",
                        "content": "Easy to get confusing with the description, should tell what is the K. \\nk is number of range that we have to check the value."
                    },
                    {
                        "username": "eduard92",
                        "content": "took me two minutes to figure that out, now I am stuck at test cases [1], k=1, I am doing Sliding Window approach.."
                    },
                    {
                        "username": "saketg54",
                        "content": "my code checks this condition and only then return true but the testcases is giving me true when clearly both the elements are not same\\ncode for this specific conditon:\\ni =0; j =1\\nif(nums[i] == nums[j]){\\n                if(abs(i - j) <= k){\\n                    return true;\\n                }\\ntest case: nums = [1,2] k = 2 output = true; expected = false\\n"
                    },
                    {
                        "username": "Arpit_Sri85",
                        "content": "Please review my code and Give me a hint of problem in my code,    \n\n\nclass Solution {\npublic:\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\n\n        sort(nums.begin(), nums.end());\n\n        int n = nums.size();\n        int i = 0;\n        int j = i - 1;\n        for(; i < n; i++){\n            if(nums[i] == nums[j] && abs(i - j) <= k ){\n                return true;\n            }\n            \n        }\n        return false;\n    }\n};"
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@Arpit_Sri85](/Arpit_Sri85) I won\\'t solve it for you because if you want solution you can just check the Solutions tab and ask the author about their solution. That said, I can try lead you to one. What\\'s your understanding of the question? What reason or what problem make you want to sort the array."
                    },
                    {
                        "username": "Arpit_Sri85",
                        "content": "[@Kaltu](/Kaltu) Can you resolve it, I will be very thankful for you. I am new to Coding, So I am making too much errors "
                    },
                    {
                        "username": "Kaltu",
                        "content": "you lost the original index when sorting"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 just insert the element of a window of size equal to k\\n\\uD83D\\uDFE2 and then slide it one by one and check if there is any repetitive number"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Just a sliding window thing\\n"
                    },
                    {
                        "username": "bimarsh-12",
                        "content": "I get it but I think some of the test cases provided for this question is wrong"
                    },
                    {
                        "username": "stemaboxd",
                        "content": "Better explanation: The objective is to check if in the nums array there are two equal numbers (duplicates) that are at a distance k or less."
                    }
                ]
            },
            {
                "id": 1986348,
                "content": [
                    {
                        "username": "overbound",
                        "content": "You don\\'t need a Hashmap. This can be solved with 2 pointers."
                    },
                    {
                        "username": "nitya_333",
                        "content": "then can you please provide a solution\\n"
                    },
                    {
                        "username": "Tabish111",
                        "content": "in test case 1 , \\nnums = [1,2,3,1], k = 3\\nhow does 3 has distinct indices , i and j ?\\ni and j will be same\\n?"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "i=0 & j=3. So nums[i] == nums[j] and abs(i-j) = 3 which is lesaa than or equal to k."
                    },
                    {
                        "username": "eduard92",
                        "content": "Thanks bro for this shit description..... I am already pissed off because of a girl and I cursed your question 3 minutes straight and I figured out the logic in 2."
                    },
                    {
                        "username": "sopheary",
                        "content": "Easy to get confusing with the description, should tell what is the K. \\nk is number of range that we have to check the value."
                    },
                    {
                        "username": "eduard92",
                        "content": "took me two minutes to figure that out, now I am stuck at test cases [1], k=1, I am doing Sliding Window approach.."
                    },
                    {
                        "username": "saketg54",
                        "content": "my code checks this condition and only then return true but the testcases is giving me true when clearly both the elements are not same\\ncode for this specific conditon:\\ni =0; j =1\\nif(nums[i] == nums[j]){\\n                if(abs(i - j) <= k){\\n                    return true;\\n                }\\ntest case: nums = [1,2] k = 2 output = true; expected = false\\n"
                    },
                    {
                        "username": "Arpit_Sri85",
                        "content": "Please review my code and Give me a hint of problem in my code,    \n\n\nclass Solution {\npublic:\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\n\n        sort(nums.begin(), nums.end());\n\n        int n = nums.size();\n        int i = 0;\n        int j = i - 1;\n        for(; i < n; i++){\n            if(nums[i] == nums[j] && abs(i - j) <= k ){\n                return true;\n            }\n            \n        }\n        return false;\n    }\n};"
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@Arpit_Sri85](/Arpit_Sri85) I won\\'t solve it for you because if you want solution you can just check the Solutions tab and ask the author about their solution. That said, I can try lead you to one. What\\'s your understanding of the question? What reason or what problem make you want to sort the array."
                    },
                    {
                        "username": "Arpit_Sri85",
                        "content": "[@Kaltu](/Kaltu) Can you resolve it, I will be very thankful for you. I am new to Coding, So I am making too much errors "
                    },
                    {
                        "username": "Kaltu",
                        "content": "you lost the original index when sorting"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 just insert the element of a window of size equal to k\\n\\uD83D\\uDFE2 and then slide it one by one and check if there is any repetitive number"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Just a sliding window thing\\n"
                    },
                    {
                        "username": "bimarsh-12",
                        "content": "I get it but I think some of the test cases provided for this question is wrong"
                    },
                    {
                        "username": "stemaboxd",
                        "content": "Better explanation: The objective is to check if in the nums array there are two equal numbers (duplicates) that are at a distance k or less."
                    }
                ]
            },
            {
                "id": 1980398,
                "content": [
                    {
                        "username": "overbound",
                        "content": "You don\\'t need a Hashmap. This can be solved with 2 pointers."
                    },
                    {
                        "username": "nitya_333",
                        "content": "then can you please provide a solution\\n"
                    },
                    {
                        "username": "Tabish111",
                        "content": "in test case 1 , \\nnums = [1,2,3,1], k = 3\\nhow does 3 has distinct indices , i and j ?\\ni and j will be same\\n?"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "i=0 & j=3. So nums[i] == nums[j] and abs(i-j) = 3 which is lesaa than or equal to k."
                    },
                    {
                        "username": "eduard92",
                        "content": "Thanks bro for this shit description..... I am already pissed off because of a girl and I cursed your question 3 minutes straight and I figured out the logic in 2."
                    },
                    {
                        "username": "sopheary",
                        "content": "Easy to get confusing with the description, should tell what is the K. \\nk is number of range that we have to check the value."
                    },
                    {
                        "username": "eduard92",
                        "content": "took me two minutes to figure that out, now I am stuck at test cases [1], k=1, I am doing Sliding Window approach.."
                    },
                    {
                        "username": "saketg54",
                        "content": "my code checks this condition and only then return true but the testcases is giving me true when clearly both the elements are not same\\ncode for this specific conditon:\\ni =0; j =1\\nif(nums[i] == nums[j]){\\n                if(abs(i - j) <= k){\\n                    return true;\\n                }\\ntest case: nums = [1,2] k = 2 output = true; expected = false\\n"
                    },
                    {
                        "username": "Arpit_Sri85",
                        "content": "Please review my code and Give me a hint of problem in my code,    \n\n\nclass Solution {\npublic:\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\n\n        sort(nums.begin(), nums.end());\n\n        int n = nums.size();\n        int i = 0;\n        int j = i - 1;\n        for(; i < n; i++){\n            if(nums[i] == nums[j] && abs(i - j) <= k ){\n                return true;\n            }\n            \n        }\n        return false;\n    }\n};"
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@Arpit_Sri85](/Arpit_Sri85) I won\\'t solve it for you because if you want solution you can just check the Solutions tab and ask the author about their solution. That said, I can try lead you to one. What\\'s your understanding of the question? What reason or what problem make you want to sort the array."
                    },
                    {
                        "username": "Arpit_Sri85",
                        "content": "[@Kaltu](/Kaltu) Can you resolve it, I will be very thankful for you. I am new to Coding, So I am making too much errors "
                    },
                    {
                        "username": "Kaltu",
                        "content": "you lost the original index when sorting"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 just insert the element of a window of size equal to k\\n\\uD83D\\uDFE2 and then slide it one by one and check if there is any repetitive number"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Just a sliding window thing\\n"
                    },
                    {
                        "username": "bimarsh-12",
                        "content": "I get it but I think some of the test cases provided for this question is wrong"
                    },
                    {
                        "username": "stemaboxd",
                        "content": "Better explanation: The objective is to check if in the nums array there are two equal numbers (duplicates) that are at a distance k or less."
                    }
                ]
            },
            {
                "id": 1974214,
                "content": [
                    {
                        "username": "overbound",
                        "content": "You don\\'t need a Hashmap. This can be solved with 2 pointers."
                    },
                    {
                        "username": "nitya_333",
                        "content": "then can you please provide a solution\\n"
                    },
                    {
                        "username": "Tabish111",
                        "content": "in test case 1 , \\nnums = [1,2,3,1], k = 3\\nhow does 3 has distinct indices , i and j ?\\ni and j will be same\\n?"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "i=0 & j=3. So nums[i] == nums[j] and abs(i-j) = 3 which is lesaa than or equal to k."
                    },
                    {
                        "username": "eduard92",
                        "content": "Thanks bro for this shit description..... I am already pissed off because of a girl and I cursed your question 3 minutes straight and I figured out the logic in 2."
                    },
                    {
                        "username": "sopheary",
                        "content": "Easy to get confusing with the description, should tell what is the K. \\nk is number of range that we have to check the value."
                    },
                    {
                        "username": "eduard92",
                        "content": "took me two minutes to figure that out, now I am stuck at test cases [1], k=1, I am doing Sliding Window approach.."
                    },
                    {
                        "username": "saketg54",
                        "content": "my code checks this condition and only then return true but the testcases is giving me true when clearly both the elements are not same\\ncode for this specific conditon:\\ni =0; j =1\\nif(nums[i] == nums[j]){\\n                if(abs(i - j) <= k){\\n                    return true;\\n                }\\ntest case: nums = [1,2] k = 2 output = true; expected = false\\n"
                    },
                    {
                        "username": "Arpit_Sri85",
                        "content": "Please review my code and Give me a hint of problem in my code,    \n\n\nclass Solution {\npublic:\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\n\n        sort(nums.begin(), nums.end());\n\n        int n = nums.size();\n        int i = 0;\n        int j = i - 1;\n        for(; i < n; i++){\n            if(nums[i] == nums[j] && abs(i - j) <= k ){\n                return true;\n            }\n            \n        }\n        return false;\n    }\n};"
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@Arpit_Sri85](/Arpit_Sri85) I won\\'t solve it for you because if you want solution you can just check the Solutions tab and ask the author about their solution. That said, I can try lead you to one. What\\'s your understanding of the question? What reason or what problem make you want to sort the array."
                    },
                    {
                        "username": "Arpit_Sri85",
                        "content": "[@Kaltu](/Kaltu) Can you resolve it, I will be very thankful for you. I am new to Coding, So I am making too much errors "
                    },
                    {
                        "username": "Kaltu",
                        "content": "you lost the original index when sorting"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 just insert the element of a window of size equal to k\\n\\uD83D\\uDFE2 and then slide it one by one and check if there is any repetitive number"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Just a sliding window thing\\n"
                    },
                    {
                        "username": "bimarsh-12",
                        "content": "I get it but I think some of the test cases provided for this question is wrong"
                    },
                    {
                        "username": "stemaboxd",
                        "content": "Better explanation: The objective is to check if in the nums array there are two equal numbers (duplicates) that are at a distance k or less."
                    }
                ]
            },
            {
                "id": 1970059,
                "content": [
                    {
                        "username": "overbound",
                        "content": "You don\\'t need a Hashmap. This can be solved with 2 pointers."
                    },
                    {
                        "username": "nitya_333",
                        "content": "then can you please provide a solution\\n"
                    },
                    {
                        "username": "Tabish111",
                        "content": "in test case 1 , \\nnums = [1,2,3,1], k = 3\\nhow does 3 has distinct indices , i and j ?\\ni and j will be same\\n?"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "i=0 & j=3. So nums[i] == nums[j] and abs(i-j) = 3 which is lesaa than or equal to k."
                    },
                    {
                        "username": "eduard92",
                        "content": "Thanks bro for this shit description..... I am already pissed off because of a girl and I cursed your question 3 minutes straight and I figured out the logic in 2."
                    },
                    {
                        "username": "sopheary",
                        "content": "Easy to get confusing with the description, should tell what is the K. \\nk is number of range that we have to check the value."
                    },
                    {
                        "username": "eduard92",
                        "content": "took me two minutes to figure that out, now I am stuck at test cases [1], k=1, I am doing Sliding Window approach.."
                    },
                    {
                        "username": "saketg54",
                        "content": "my code checks this condition and only then return true but the testcases is giving me true when clearly both the elements are not same\\ncode for this specific conditon:\\ni =0; j =1\\nif(nums[i] == nums[j]){\\n                if(abs(i - j) <= k){\\n                    return true;\\n                }\\ntest case: nums = [1,2] k = 2 output = true; expected = false\\n"
                    },
                    {
                        "username": "Arpit_Sri85",
                        "content": "Please review my code and Give me a hint of problem in my code,    \n\n\nclass Solution {\npublic:\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\n\n        sort(nums.begin(), nums.end());\n\n        int n = nums.size();\n        int i = 0;\n        int j = i - 1;\n        for(; i < n; i++){\n            if(nums[i] == nums[j] && abs(i - j) <= k ){\n                return true;\n            }\n            \n        }\n        return false;\n    }\n};"
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@Arpit_Sri85](/Arpit_Sri85) I won\\'t solve it for you because if you want solution you can just check the Solutions tab and ask the author about their solution. That said, I can try lead you to one. What\\'s your understanding of the question? What reason or what problem make you want to sort the array."
                    },
                    {
                        "username": "Arpit_Sri85",
                        "content": "[@Kaltu](/Kaltu) Can you resolve it, I will be very thankful for you. I am new to Coding, So I am making too much errors "
                    },
                    {
                        "username": "Kaltu",
                        "content": "you lost the original index when sorting"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 just insert the element of a window of size equal to k\\n\\uD83D\\uDFE2 and then slide it one by one and check if there is any repetitive number"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Just a sliding window thing\\n"
                    },
                    {
                        "username": "bimarsh-12",
                        "content": "I get it but I think some of the test cases provided for this question is wrong"
                    },
                    {
                        "username": "stemaboxd",
                        "content": "Better explanation: The objective is to check if in the nums array there are two equal numbers (duplicates) that are at a distance k or less."
                    }
                ]
            },
            {
                "id": 1964568,
                "content": [
                    {
                        "username": "overbound",
                        "content": "You don\\'t need a Hashmap. This can be solved with 2 pointers."
                    },
                    {
                        "username": "nitya_333",
                        "content": "then can you please provide a solution\\n"
                    },
                    {
                        "username": "Tabish111",
                        "content": "in test case 1 , \\nnums = [1,2,3,1], k = 3\\nhow does 3 has distinct indices , i and j ?\\ni and j will be same\\n?"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "i=0 & j=3. So nums[i] == nums[j] and abs(i-j) = 3 which is lesaa than or equal to k."
                    },
                    {
                        "username": "eduard92",
                        "content": "Thanks bro for this shit description..... I am already pissed off because of a girl and I cursed your question 3 minutes straight and I figured out the logic in 2."
                    },
                    {
                        "username": "sopheary",
                        "content": "Easy to get confusing with the description, should tell what is the K. \\nk is number of range that we have to check the value."
                    },
                    {
                        "username": "eduard92",
                        "content": "took me two minutes to figure that out, now I am stuck at test cases [1], k=1, I am doing Sliding Window approach.."
                    },
                    {
                        "username": "saketg54",
                        "content": "my code checks this condition and only then return true but the testcases is giving me true when clearly both the elements are not same\\ncode for this specific conditon:\\ni =0; j =1\\nif(nums[i] == nums[j]){\\n                if(abs(i - j) <= k){\\n                    return true;\\n                }\\ntest case: nums = [1,2] k = 2 output = true; expected = false\\n"
                    },
                    {
                        "username": "Arpit_Sri85",
                        "content": "Please review my code and Give me a hint of problem in my code,    \n\n\nclass Solution {\npublic:\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\n\n        sort(nums.begin(), nums.end());\n\n        int n = nums.size();\n        int i = 0;\n        int j = i - 1;\n        for(; i < n; i++){\n            if(nums[i] == nums[j] && abs(i - j) <= k ){\n                return true;\n            }\n            \n        }\n        return false;\n    }\n};"
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@Arpit_Sri85](/Arpit_Sri85) I won\\'t solve it for you because if you want solution you can just check the Solutions tab and ask the author about their solution. That said, I can try lead you to one. What\\'s your understanding of the question? What reason or what problem make you want to sort the array."
                    },
                    {
                        "username": "Arpit_Sri85",
                        "content": "[@Kaltu](/Kaltu) Can you resolve it, I will be very thankful for you. I am new to Coding, So I am making too much errors "
                    },
                    {
                        "username": "Kaltu",
                        "content": "you lost the original index when sorting"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 just insert the element of a window of size equal to k\\n\\uD83D\\uDFE2 and then slide it one by one and check if there is any repetitive number"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Just a sliding window thing\\n"
                    },
                    {
                        "username": "bimarsh-12",
                        "content": "I get it but I think some of the test cases provided for this question is wrong"
                    },
                    {
                        "username": "stemaboxd",
                        "content": "Better explanation: The objective is to check if in the nums array there are two equal numbers (duplicates) that are at a distance k or less."
                    }
                ]
            },
            {
                "id": 1964566,
                "content": [
                    {
                        "username": "overbound",
                        "content": "You don\\'t need a Hashmap. This can be solved with 2 pointers."
                    },
                    {
                        "username": "nitya_333",
                        "content": "then can you please provide a solution\\n"
                    },
                    {
                        "username": "Tabish111",
                        "content": "in test case 1 , \\nnums = [1,2,3,1], k = 3\\nhow does 3 has distinct indices , i and j ?\\ni and j will be same\\n?"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "i=0 & j=3. So nums[i] == nums[j] and abs(i-j) = 3 which is lesaa than or equal to k."
                    },
                    {
                        "username": "eduard92",
                        "content": "Thanks bro for this shit description..... I am already pissed off because of a girl and I cursed your question 3 minutes straight and I figured out the logic in 2."
                    },
                    {
                        "username": "sopheary",
                        "content": "Easy to get confusing with the description, should tell what is the K. \\nk is number of range that we have to check the value."
                    },
                    {
                        "username": "eduard92",
                        "content": "took me two minutes to figure that out, now I am stuck at test cases [1], k=1, I am doing Sliding Window approach.."
                    },
                    {
                        "username": "saketg54",
                        "content": "my code checks this condition and only then return true but the testcases is giving me true when clearly both the elements are not same\\ncode for this specific conditon:\\ni =0; j =1\\nif(nums[i] == nums[j]){\\n                if(abs(i - j) <= k){\\n                    return true;\\n                }\\ntest case: nums = [1,2] k = 2 output = true; expected = false\\n"
                    },
                    {
                        "username": "Arpit_Sri85",
                        "content": "Please review my code and Give me a hint of problem in my code,    \n\n\nclass Solution {\npublic:\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\n\n        sort(nums.begin(), nums.end());\n\n        int n = nums.size();\n        int i = 0;\n        int j = i - 1;\n        for(; i < n; i++){\n            if(nums[i] == nums[j] && abs(i - j) <= k ){\n                return true;\n            }\n            \n        }\n        return false;\n    }\n};"
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@Arpit_Sri85](/Arpit_Sri85) I won\\'t solve it for you because if you want solution you can just check the Solutions tab and ask the author about their solution. That said, I can try lead you to one. What\\'s your understanding of the question? What reason or what problem make you want to sort the array."
                    },
                    {
                        "username": "Arpit_Sri85",
                        "content": "[@Kaltu](/Kaltu) Can you resolve it, I will be very thankful for you. I am new to Coding, So I am making too much errors "
                    },
                    {
                        "username": "Kaltu",
                        "content": "you lost the original index when sorting"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 just insert the element of a window of size equal to k\\n\\uD83D\\uDFE2 and then slide it one by one and check if there is any repetitive number"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Just a sliding window thing\\n"
                    },
                    {
                        "username": "bimarsh-12",
                        "content": "I get it but I think some of the test cases provided for this question is wrong"
                    },
                    {
                        "username": "stemaboxd",
                        "content": "Better explanation: The objective is to check if in the nums array there are two equal numbers (duplicates) that are at a distance k or less."
                    }
                ]
            },
            {
                "id": 1960850,
                "content": [
                    {
                        "username": "overbound",
                        "content": "You don\\'t need a Hashmap. This can be solved with 2 pointers."
                    },
                    {
                        "username": "nitya_333",
                        "content": "then can you please provide a solution\\n"
                    },
                    {
                        "username": "Tabish111",
                        "content": "in test case 1 , \\nnums = [1,2,3,1], k = 3\\nhow does 3 has distinct indices , i and j ?\\ni and j will be same\\n?"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "i=0 & j=3. So nums[i] == nums[j] and abs(i-j) = 3 which is lesaa than or equal to k."
                    },
                    {
                        "username": "eduard92",
                        "content": "Thanks bro for this shit description..... I am already pissed off because of a girl and I cursed your question 3 minutes straight and I figured out the logic in 2."
                    },
                    {
                        "username": "sopheary",
                        "content": "Easy to get confusing with the description, should tell what is the K. \\nk is number of range that we have to check the value."
                    },
                    {
                        "username": "eduard92",
                        "content": "took me two minutes to figure that out, now I am stuck at test cases [1], k=1, I am doing Sliding Window approach.."
                    },
                    {
                        "username": "saketg54",
                        "content": "my code checks this condition and only then return true but the testcases is giving me true when clearly both the elements are not same\\ncode for this specific conditon:\\ni =0; j =1\\nif(nums[i] == nums[j]){\\n                if(abs(i - j) <= k){\\n                    return true;\\n                }\\ntest case: nums = [1,2] k = 2 output = true; expected = false\\n"
                    },
                    {
                        "username": "Arpit_Sri85",
                        "content": "Please review my code and Give me a hint of problem in my code,    \n\n\nclass Solution {\npublic:\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\n\n        sort(nums.begin(), nums.end());\n\n        int n = nums.size();\n        int i = 0;\n        int j = i - 1;\n        for(; i < n; i++){\n            if(nums[i] == nums[j] && abs(i - j) <= k ){\n                return true;\n            }\n            \n        }\n        return false;\n    }\n};"
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@Arpit_Sri85](/Arpit_Sri85) I won\\'t solve it for you because if you want solution you can just check the Solutions tab and ask the author about their solution. That said, I can try lead you to one. What\\'s your understanding of the question? What reason or what problem make you want to sort the array."
                    },
                    {
                        "username": "Arpit_Sri85",
                        "content": "[@Kaltu](/Kaltu) Can you resolve it, I will be very thankful for you. I am new to Coding, So I am making too much errors "
                    },
                    {
                        "username": "Kaltu",
                        "content": "you lost the original index when sorting"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 just insert the element of a window of size equal to k\\n\\uD83D\\uDFE2 and then slide it one by one and check if there is any repetitive number"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Just a sliding window thing\\n"
                    },
                    {
                        "username": "bimarsh-12",
                        "content": "I get it but I think some of the test cases provided for this question is wrong"
                    },
                    {
                        "username": "stemaboxd",
                        "content": "Better explanation: The objective is to check if in the nums array there are two equal numbers (duplicates) that are at a distance k or less."
                    }
                ]
            },
            {
                "id": 1959185,
                "content": [
                    {
                        "username": "overbound",
                        "content": "You don\\'t need a Hashmap. This can be solved with 2 pointers."
                    },
                    {
                        "username": "nitya_333",
                        "content": "then can you please provide a solution\\n"
                    },
                    {
                        "username": "Tabish111",
                        "content": "in test case 1 , \\nnums = [1,2,3,1], k = 3\\nhow does 3 has distinct indices , i and j ?\\ni and j will be same\\n?"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "i=0 & j=3. So nums[i] == nums[j] and abs(i-j) = 3 which is lesaa than or equal to k."
                    },
                    {
                        "username": "eduard92",
                        "content": "Thanks bro for this shit description..... I am already pissed off because of a girl and I cursed your question 3 minutes straight and I figured out the logic in 2."
                    },
                    {
                        "username": "sopheary",
                        "content": "Easy to get confusing with the description, should tell what is the K. \\nk is number of range that we have to check the value."
                    },
                    {
                        "username": "eduard92",
                        "content": "took me two minutes to figure that out, now I am stuck at test cases [1], k=1, I am doing Sliding Window approach.."
                    },
                    {
                        "username": "saketg54",
                        "content": "my code checks this condition and only then return true but the testcases is giving me true when clearly both the elements are not same\\ncode for this specific conditon:\\ni =0; j =1\\nif(nums[i] == nums[j]){\\n                if(abs(i - j) <= k){\\n                    return true;\\n                }\\ntest case: nums = [1,2] k = 2 output = true; expected = false\\n"
                    },
                    {
                        "username": "Arpit_Sri85",
                        "content": "Please review my code and Give me a hint of problem in my code,    \n\n\nclass Solution {\npublic:\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\n\n        sort(nums.begin(), nums.end());\n\n        int n = nums.size();\n        int i = 0;\n        int j = i - 1;\n        for(; i < n; i++){\n            if(nums[i] == nums[j] && abs(i - j) <= k ){\n                return true;\n            }\n            \n        }\n        return false;\n    }\n};"
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@Arpit_Sri85](/Arpit_Sri85) I won\\'t solve it for you because if you want solution you can just check the Solutions tab and ask the author about their solution. That said, I can try lead you to one. What\\'s your understanding of the question? What reason or what problem make you want to sort the array."
                    },
                    {
                        "username": "Arpit_Sri85",
                        "content": "[@Kaltu](/Kaltu) Can you resolve it, I will be very thankful for you. I am new to Coding, So I am making too much errors "
                    },
                    {
                        "username": "Kaltu",
                        "content": "you lost the original index when sorting"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 just insert the element of a window of size equal to k\\n\\uD83D\\uDFE2 and then slide it one by one and check if there is any repetitive number"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Just a sliding window thing\\n"
                    },
                    {
                        "username": "bimarsh-12",
                        "content": "I get it but I think some of the test cases provided for this question is wrong"
                    },
                    {
                        "username": "stemaboxd",
                        "content": "Better explanation: The objective is to check if in the nums array there are two equal numbers (duplicates) that are at a distance k or less."
                    }
                ]
            },
            {
                "id": 1958871,
                "content": [
                    {
                        "username": "k_17_sawai",
                        "content": "What if I sort the vector here?then i only need to check if 1 <= k but why that does not work here?"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "If we sort the array then, we\\'ll lose the actual position/ indices of the elements. This wouldn\\'t give us correct ans when we compute nums[i] == nums[j] and check the difference between indices abs(i-j)<=k"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "Can any one explained this question??"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "this question is about given the array \"nums\", we need to check if there are same elements exist in the array. if they exist then get their absolute difference of indices {i.e., nums[i] == nums[j] } and if this absolute difference of their indices is less than or equal to k then return true. if no such elements exist then return false."
                    },
                    {
                        "username": "gorota",
                        "content": "Can you suggest me how to improve this code, time exceeding!!!\\n\\ntypedef struct table {\\n    int val;\\n    int index;\\n} Table;\\n\\nbool containsNearbyDuplicate(int* nums, int numsSize, int k) {\\n    Table* hashTable = (Table*)malloc(sizeof(Table) * numsSize);\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (hashTable[j].val == nums[i] && abs(hashTable[j].index - i) <= k) {\\n                free(hashTable);\\n                return true;\\n            }\\n        }\\n        hashTable[i].val = nums[i];\\n        hashTable[i].index = i;\\n    }\\n\\n    free(hashTable);\\n    return false;\\n}"
                    },
                    {
                        "username": "BlakeE",
                        "content": "You only need to search k distance away from i. Searching anything more than that distance is outside of the scope\n"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "store only the index of recently traversed element in the hash-table. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "Why do they say distinct indices? If we iterate over the vector how could the indices not be distinct?"
                    },
                    {
                        "username": "sitanggang",
                        "content": "stil curious, said return true if there are two distinct indices but nums = [1,2,3,1], k = 3 which is 3 only on 1 index and it expected true."
                    },
                    {
                        "username": "tnguyen306",
                        "content": "So why is if nums =[1] and k = 1, then it \\'s false? if the window is 1 and i and j are the same number, shouldnt it be true?"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "in the ques its mentioned the indices should be distinct, so index cant be same. so it returns false."
                    },
                    {
                        "username": "Aditi_Hari",
                        "content": "Can you Please help me for this\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        for (int i = 0 ;i< nums.length ; i++){\\n            for (int j = 0 ; j< nums.length ; j++){\\n                if (nums[i] == nums [j]) {\\n                    if (Math.abs(i-j) <= k){\\n                    return true;}\\n                    \\n                }\\n\\n                } \\n            }\\n        \\n        return false;\\n        \\n    }\\n}\\nWhy third test case is not working for this code?\\n"
                    },
                    {
                        "username": "kshitijpratap2004",
                        "content": "Hi Aditi\n your loop is wrong \ncorrect is j = i + 1\nbecause we have to start second loop by 1 incrementing i\n\nBut sadly this solns is not working \nshowing TLE"
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "Also your Solution is Everytime give true. because you are comparing  same number and the absolute value always give (0-0) 0. "
                    },
                    {
                        "username": "zabuli",
                        "content": "I guess it\\'s because you have mistake in your code. Read properly this part:  \"distinct indices i and j\" => you shouldn\\'t start second loop with same index."
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "you are using second for loop from index number 0. your loop start and end in just one iteration . because for third test case you are compare nums[0]== nums[0] that is true and nested if Math.abs(0-0) <= true . that is the mistake . \\n                     I Will Given a Solution for you . Use hashmap it will give a proper Answer"
                    },
                    {
                        "username": "tejasree438",
                        "content": "The question is if we found the duplicates ,then there duplicate index\\'s difference could be <= k values\\n\\ncase 1: nums = [1,2,3,1], k = 3\\nelement 1 is duplicate\\n1 index is 0 ans 3 therefore 3-0 =3 ans its equal to k.\\n\\ncase 2 : nums = [1,0,1,1], k = 1\\nelement 1 is duplicate\\nindex are =0,2,3\\n2-0= less than or equals k false but\\n3-2 =1 so its less than or equals to k\\n\\ncase 3: [1,2,3,1,2,3], k = 2\\nduplicates 1,2,3 \\n1 index\\'s = 0,3 =3-0 not less than or equals so false;\\n2 index\\'s = 1,4 =4-1 not less than or equals so false;\\n1 index\\'s = 2,5 =5-2 not less than or equals so false;\\n\\n"
                    },
                    {
                        "username": "amitsingh75",
                        "content": "This question is a bit incomplete.  I have tried to explain this very well with the help of examples.---------------------> \nnums=[1,0,1,1]\nk=1\nstep 1->\nindex 0,1-->1 not equal 0\nstep 2->\nindex 0,2-->1 equal 1 but--> abs(0-2) not<= k\nstep 1->\nindex 2,3-->1 equal 1 and abs(2-3) equal k --->Retuen True"
                    },
                    {
                        "username": "ankit_shrez",
                        "content": "I solved the problem with time limit efficiency at the order of nums.length and yet it returns time limit exception. anyone else seeing the same?"
                    }
                ]
            },
            {
                "id": 1953711,
                "content": [
                    {
                        "username": "k_17_sawai",
                        "content": "What if I sort the vector here?then i only need to check if 1 <= k but why that does not work here?"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "If we sort the array then, we\\'ll lose the actual position/ indices of the elements. This wouldn\\'t give us correct ans when we compute nums[i] == nums[j] and check the difference between indices abs(i-j)<=k"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "Can any one explained this question??"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "this question is about given the array \"nums\", we need to check if there are same elements exist in the array. if they exist then get their absolute difference of indices {i.e., nums[i] == nums[j] } and if this absolute difference of their indices is less than or equal to k then return true. if no such elements exist then return false."
                    },
                    {
                        "username": "gorota",
                        "content": "Can you suggest me how to improve this code, time exceeding!!!\\n\\ntypedef struct table {\\n    int val;\\n    int index;\\n} Table;\\n\\nbool containsNearbyDuplicate(int* nums, int numsSize, int k) {\\n    Table* hashTable = (Table*)malloc(sizeof(Table) * numsSize);\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (hashTable[j].val == nums[i] && abs(hashTable[j].index - i) <= k) {\\n                free(hashTable);\\n                return true;\\n            }\\n        }\\n        hashTable[i].val = nums[i];\\n        hashTable[i].index = i;\\n    }\\n\\n    free(hashTable);\\n    return false;\\n}"
                    },
                    {
                        "username": "BlakeE",
                        "content": "You only need to search k distance away from i. Searching anything more than that distance is outside of the scope\n"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "store only the index of recently traversed element in the hash-table. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "Why do they say distinct indices? If we iterate over the vector how could the indices not be distinct?"
                    },
                    {
                        "username": "sitanggang",
                        "content": "stil curious, said return true if there are two distinct indices but nums = [1,2,3,1], k = 3 which is 3 only on 1 index and it expected true."
                    },
                    {
                        "username": "tnguyen306",
                        "content": "So why is if nums =[1] and k = 1, then it \\'s false? if the window is 1 and i and j are the same number, shouldnt it be true?"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "in the ques its mentioned the indices should be distinct, so index cant be same. so it returns false."
                    },
                    {
                        "username": "Aditi_Hari",
                        "content": "Can you Please help me for this\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        for (int i = 0 ;i< nums.length ; i++){\\n            for (int j = 0 ; j< nums.length ; j++){\\n                if (nums[i] == nums [j]) {\\n                    if (Math.abs(i-j) <= k){\\n                    return true;}\\n                    \\n                }\\n\\n                } \\n            }\\n        \\n        return false;\\n        \\n    }\\n}\\nWhy third test case is not working for this code?\\n"
                    },
                    {
                        "username": "kshitijpratap2004",
                        "content": "Hi Aditi\n your loop is wrong \ncorrect is j = i + 1\nbecause we have to start second loop by 1 incrementing i\n\nBut sadly this solns is not working \nshowing TLE"
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "Also your Solution is Everytime give true. because you are comparing  same number and the absolute value always give (0-0) 0. "
                    },
                    {
                        "username": "zabuli",
                        "content": "I guess it\\'s because you have mistake in your code. Read properly this part:  \"distinct indices i and j\" => you shouldn\\'t start second loop with same index."
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "you are using second for loop from index number 0. your loop start and end in just one iteration . because for third test case you are compare nums[0]== nums[0] that is true and nested if Math.abs(0-0) <= true . that is the mistake . \\n                     I Will Given a Solution for you . Use hashmap it will give a proper Answer"
                    },
                    {
                        "username": "tejasree438",
                        "content": "The question is if we found the duplicates ,then there duplicate index\\'s difference could be <= k values\\n\\ncase 1: nums = [1,2,3,1], k = 3\\nelement 1 is duplicate\\n1 index is 0 ans 3 therefore 3-0 =3 ans its equal to k.\\n\\ncase 2 : nums = [1,0,1,1], k = 1\\nelement 1 is duplicate\\nindex are =0,2,3\\n2-0= less than or equals k false but\\n3-2 =1 so its less than or equals to k\\n\\ncase 3: [1,2,3,1,2,3], k = 2\\nduplicates 1,2,3 \\n1 index\\'s = 0,3 =3-0 not less than or equals so false;\\n2 index\\'s = 1,4 =4-1 not less than or equals so false;\\n1 index\\'s = 2,5 =5-2 not less than or equals so false;\\n\\n"
                    },
                    {
                        "username": "amitsingh75",
                        "content": "This question is a bit incomplete.  I have tried to explain this very well with the help of examples.---------------------> \nnums=[1,0,1,1]\nk=1\nstep 1->\nindex 0,1-->1 not equal 0\nstep 2->\nindex 0,2-->1 equal 1 but--> abs(0-2) not<= k\nstep 1->\nindex 2,3-->1 equal 1 and abs(2-3) equal k --->Retuen True"
                    },
                    {
                        "username": "ankit_shrez",
                        "content": "I solved the problem with time limit efficiency at the order of nums.length and yet it returns time limit exception. anyone else seeing the same?"
                    }
                ]
            },
            {
                "id": 1953479,
                "content": [
                    {
                        "username": "k_17_sawai",
                        "content": "What if I sort the vector here?then i only need to check if 1 <= k but why that does not work here?"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "If we sort the array then, we\\'ll lose the actual position/ indices of the elements. This wouldn\\'t give us correct ans when we compute nums[i] == nums[j] and check the difference between indices abs(i-j)<=k"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "Can any one explained this question??"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "this question is about given the array \"nums\", we need to check if there are same elements exist in the array. if they exist then get their absolute difference of indices {i.e., nums[i] == nums[j] } and if this absolute difference of their indices is less than or equal to k then return true. if no such elements exist then return false."
                    },
                    {
                        "username": "gorota",
                        "content": "Can you suggest me how to improve this code, time exceeding!!!\\n\\ntypedef struct table {\\n    int val;\\n    int index;\\n} Table;\\n\\nbool containsNearbyDuplicate(int* nums, int numsSize, int k) {\\n    Table* hashTable = (Table*)malloc(sizeof(Table) * numsSize);\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (hashTable[j].val == nums[i] && abs(hashTable[j].index - i) <= k) {\\n                free(hashTable);\\n                return true;\\n            }\\n        }\\n        hashTable[i].val = nums[i];\\n        hashTable[i].index = i;\\n    }\\n\\n    free(hashTable);\\n    return false;\\n}"
                    },
                    {
                        "username": "BlakeE",
                        "content": "You only need to search k distance away from i. Searching anything more than that distance is outside of the scope\n"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "store only the index of recently traversed element in the hash-table. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "Why do they say distinct indices? If we iterate over the vector how could the indices not be distinct?"
                    },
                    {
                        "username": "sitanggang",
                        "content": "stil curious, said return true if there are two distinct indices but nums = [1,2,3,1], k = 3 which is 3 only on 1 index and it expected true."
                    },
                    {
                        "username": "tnguyen306",
                        "content": "So why is if nums =[1] and k = 1, then it \\'s false? if the window is 1 and i and j are the same number, shouldnt it be true?"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "in the ques its mentioned the indices should be distinct, so index cant be same. so it returns false."
                    },
                    {
                        "username": "Aditi_Hari",
                        "content": "Can you Please help me for this\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        for (int i = 0 ;i< nums.length ; i++){\\n            for (int j = 0 ; j< nums.length ; j++){\\n                if (nums[i] == nums [j]) {\\n                    if (Math.abs(i-j) <= k){\\n                    return true;}\\n                    \\n                }\\n\\n                } \\n            }\\n        \\n        return false;\\n        \\n    }\\n}\\nWhy third test case is not working for this code?\\n"
                    },
                    {
                        "username": "kshitijpratap2004",
                        "content": "Hi Aditi\n your loop is wrong \ncorrect is j = i + 1\nbecause we have to start second loop by 1 incrementing i\n\nBut sadly this solns is not working \nshowing TLE"
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "Also your Solution is Everytime give true. because you are comparing  same number and the absolute value always give (0-0) 0. "
                    },
                    {
                        "username": "zabuli",
                        "content": "I guess it\\'s because you have mistake in your code. Read properly this part:  \"distinct indices i and j\" => you shouldn\\'t start second loop with same index."
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "you are using second for loop from index number 0. your loop start and end in just one iteration . because for third test case you are compare nums[0]== nums[0] that is true and nested if Math.abs(0-0) <= true . that is the mistake . \\n                     I Will Given a Solution for you . Use hashmap it will give a proper Answer"
                    },
                    {
                        "username": "tejasree438",
                        "content": "The question is if we found the duplicates ,then there duplicate index\\'s difference could be <= k values\\n\\ncase 1: nums = [1,2,3,1], k = 3\\nelement 1 is duplicate\\n1 index is 0 ans 3 therefore 3-0 =3 ans its equal to k.\\n\\ncase 2 : nums = [1,0,1,1], k = 1\\nelement 1 is duplicate\\nindex are =0,2,3\\n2-0= less than or equals k false but\\n3-2 =1 so its less than or equals to k\\n\\ncase 3: [1,2,3,1,2,3], k = 2\\nduplicates 1,2,3 \\n1 index\\'s = 0,3 =3-0 not less than or equals so false;\\n2 index\\'s = 1,4 =4-1 not less than or equals so false;\\n1 index\\'s = 2,5 =5-2 not less than or equals so false;\\n\\n"
                    },
                    {
                        "username": "amitsingh75",
                        "content": "This question is a bit incomplete.  I have tried to explain this very well with the help of examples.---------------------> \nnums=[1,0,1,1]\nk=1\nstep 1->\nindex 0,1-->1 not equal 0\nstep 2->\nindex 0,2-->1 equal 1 but--> abs(0-2) not<= k\nstep 1->\nindex 2,3-->1 equal 1 and abs(2-3) equal k --->Retuen True"
                    },
                    {
                        "username": "ankit_shrez",
                        "content": "I solved the problem with time limit efficiency at the order of nums.length and yet it returns time limit exception. anyone else seeing the same?"
                    }
                ]
            },
            {
                "id": 1952820,
                "content": [
                    {
                        "username": "k_17_sawai",
                        "content": "What if I sort the vector here?then i only need to check if 1 <= k but why that does not work here?"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "If we sort the array then, we\\'ll lose the actual position/ indices of the elements. This wouldn\\'t give us correct ans when we compute nums[i] == nums[j] and check the difference between indices abs(i-j)<=k"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "Can any one explained this question??"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "this question is about given the array \"nums\", we need to check if there are same elements exist in the array. if they exist then get their absolute difference of indices {i.e., nums[i] == nums[j] } and if this absolute difference of their indices is less than or equal to k then return true. if no such elements exist then return false."
                    },
                    {
                        "username": "gorota",
                        "content": "Can you suggest me how to improve this code, time exceeding!!!\\n\\ntypedef struct table {\\n    int val;\\n    int index;\\n} Table;\\n\\nbool containsNearbyDuplicate(int* nums, int numsSize, int k) {\\n    Table* hashTable = (Table*)malloc(sizeof(Table) * numsSize);\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (hashTable[j].val == nums[i] && abs(hashTable[j].index - i) <= k) {\\n                free(hashTable);\\n                return true;\\n            }\\n        }\\n        hashTable[i].val = nums[i];\\n        hashTable[i].index = i;\\n    }\\n\\n    free(hashTable);\\n    return false;\\n}"
                    },
                    {
                        "username": "BlakeE",
                        "content": "You only need to search k distance away from i. Searching anything more than that distance is outside of the scope\n"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "store only the index of recently traversed element in the hash-table. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "Why do they say distinct indices? If we iterate over the vector how could the indices not be distinct?"
                    },
                    {
                        "username": "sitanggang",
                        "content": "stil curious, said return true if there are two distinct indices but nums = [1,2,3,1], k = 3 which is 3 only on 1 index and it expected true."
                    },
                    {
                        "username": "tnguyen306",
                        "content": "So why is if nums =[1] and k = 1, then it \\'s false? if the window is 1 and i and j are the same number, shouldnt it be true?"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "in the ques its mentioned the indices should be distinct, so index cant be same. so it returns false."
                    },
                    {
                        "username": "Aditi_Hari",
                        "content": "Can you Please help me for this\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        for (int i = 0 ;i< nums.length ; i++){\\n            for (int j = 0 ; j< nums.length ; j++){\\n                if (nums[i] == nums [j]) {\\n                    if (Math.abs(i-j) <= k){\\n                    return true;}\\n                    \\n                }\\n\\n                } \\n            }\\n        \\n        return false;\\n        \\n    }\\n}\\nWhy third test case is not working for this code?\\n"
                    },
                    {
                        "username": "kshitijpratap2004",
                        "content": "Hi Aditi\n your loop is wrong \ncorrect is j = i + 1\nbecause we have to start second loop by 1 incrementing i\n\nBut sadly this solns is not working \nshowing TLE"
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "Also your Solution is Everytime give true. because you are comparing  same number and the absolute value always give (0-0) 0. "
                    },
                    {
                        "username": "zabuli",
                        "content": "I guess it\\'s because you have mistake in your code. Read properly this part:  \"distinct indices i and j\" => you shouldn\\'t start second loop with same index."
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "you are using second for loop from index number 0. your loop start and end in just one iteration . because for third test case you are compare nums[0]== nums[0] that is true and nested if Math.abs(0-0) <= true . that is the mistake . \\n                     I Will Given a Solution for you . Use hashmap it will give a proper Answer"
                    },
                    {
                        "username": "tejasree438",
                        "content": "The question is if we found the duplicates ,then there duplicate index\\'s difference could be <= k values\\n\\ncase 1: nums = [1,2,3,1], k = 3\\nelement 1 is duplicate\\n1 index is 0 ans 3 therefore 3-0 =3 ans its equal to k.\\n\\ncase 2 : nums = [1,0,1,1], k = 1\\nelement 1 is duplicate\\nindex are =0,2,3\\n2-0= less than or equals k false but\\n3-2 =1 so its less than or equals to k\\n\\ncase 3: [1,2,3,1,2,3], k = 2\\nduplicates 1,2,3 \\n1 index\\'s = 0,3 =3-0 not less than or equals so false;\\n2 index\\'s = 1,4 =4-1 not less than or equals so false;\\n1 index\\'s = 2,5 =5-2 not less than or equals so false;\\n\\n"
                    },
                    {
                        "username": "amitsingh75",
                        "content": "This question is a bit incomplete.  I have tried to explain this very well with the help of examples.---------------------> \nnums=[1,0,1,1]\nk=1\nstep 1->\nindex 0,1-->1 not equal 0\nstep 2->\nindex 0,2-->1 equal 1 but--> abs(0-2) not<= k\nstep 1->\nindex 2,3-->1 equal 1 and abs(2-3) equal k --->Retuen True"
                    },
                    {
                        "username": "ankit_shrez",
                        "content": "I solved the problem with time limit efficiency at the order of nums.length and yet it returns time limit exception. anyone else seeing the same?"
                    }
                ]
            },
            {
                "id": 1946231,
                "content": [
                    {
                        "username": "k_17_sawai",
                        "content": "What if I sort the vector here?then i only need to check if 1 <= k but why that does not work here?"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "If we sort the array then, we\\'ll lose the actual position/ indices of the elements. This wouldn\\'t give us correct ans when we compute nums[i] == nums[j] and check the difference between indices abs(i-j)<=k"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "Can any one explained this question??"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "this question is about given the array \"nums\", we need to check if there are same elements exist in the array. if they exist then get their absolute difference of indices {i.e., nums[i] == nums[j] } and if this absolute difference of their indices is less than or equal to k then return true. if no such elements exist then return false."
                    },
                    {
                        "username": "gorota",
                        "content": "Can you suggest me how to improve this code, time exceeding!!!\\n\\ntypedef struct table {\\n    int val;\\n    int index;\\n} Table;\\n\\nbool containsNearbyDuplicate(int* nums, int numsSize, int k) {\\n    Table* hashTable = (Table*)malloc(sizeof(Table) * numsSize);\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (hashTable[j].val == nums[i] && abs(hashTable[j].index - i) <= k) {\\n                free(hashTable);\\n                return true;\\n            }\\n        }\\n        hashTable[i].val = nums[i];\\n        hashTable[i].index = i;\\n    }\\n\\n    free(hashTable);\\n    return false;\\n}"
                    },
                    {
                        "username": "BlakeE",
                        "content": "You only need to search k distance away from i. Searching anything more than that distance is outside of the scope\n"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "store only the index of recently traversed element in the hash-table. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "Why do they say distinct indices? If we iterate over the vector how could the indices not be distinct?"
                    },
                    {
                        "username": "sitanggang",
                        "content": "stil curious, said return true if there are two distinct indices but nums = [1,2,3,1], k = 3 which is 3 only on 1 index and it expected true."
                    },
                    {
                        "username": "tnguyen306",
                        "content": "So why is if nums =[1] and k = 1, then it \\'s false? if the window is 1 and i and j are the same number, shouldnt it be true?"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "in the ques its mentioned the indices should be distinct, so index cant be same. so it returns false."
                    },
                    {
                        "username": "Aditi_Hari",
                        "content": "Can you Please help me for this\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        for (int i = 0 ;i< nums.length ; i++){\\n            for (int j = 0 ; j< nums.length ; j++){\\n                if (nums[i] == nums [j]) {\\n                    if (Math.abs(i-j) <= k){\\n                    return true;}\\n                    \\n                }\\n\\n                } \\n            }\\n        \\n        return false;\\n        \\n    }\\n}\\nWhy third test case is not working for this code?\\n"
                    },
                    {
                        "username": "kshitijpratap2004",
                        "content": "Hi Aditi\n your loop is wrong \ncorrect is j = i + 1\nbecause we have to start second loop by 1 incrementing i\n\nBut sadly this solns is not working \nshowing TLE"
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "Also your Solution is Everytime give true. because you are comparing  same number and the absolute value always give (0-0) 0. "
                    },
                    {
                        "username": "zabuli",
                        "content": "I guess it\\'s because you have mistake in your code. Read properly this part:  \"distinct indices i and j\" => you shouldn\\'t start second loop with same index."
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "you are using second for loop from index number 0. your loop start and end in just one iteration . because for third test case you are compare nums[0]== nums[0] that is true and nested if Math.abs(0-0) <= true . that is the mistake . \\n                     I Will Given a Solution for you . Use hashmap it will give a proper Answer"
                    },
                    {
                        "username": "tejasree438",
                        "content": "The question is if we found the duplicates ,then there duplicate index\\'s difference could be <= k values\\n\\ncase 1: nums = [1,2,3,1], k = 3\\nelement 1 is duplicate\\n1 index is 0 ans 3 therefore 3-0 =3 ans its equal to k.\\n\\ncase 2 : nums = [1,0,1,1], k = 1\\nelement 1 is duplicate\\nindex are =0,2,3\\n2-0= less than or equals k false but\\n3-2 =1 so its less than or equals to k\\n\\ncase 3: [1,2,3,1,2,3], k = 2\\nduplicates 1,2,3 \\n1 index\\'s = 0,3 =3-0 not less than or equals so false;\\n2 index\\'s = 1,4 =4-1 not less than or equals so false;\\n1 index\\'s = 2,5 =5-2 not less than or equals so false;\\n\\n"
                    },
                    {
                        "username": "amitsingh75",
                        "content": "This question is a bit incomplete.  I have tried to explain this very well with the help of examples.---------------------> \nnums=[1,0,1,1]\nk=1\nstep 1->\nindex 0,1-->1 not equal 0\nstep 2->\nindex 0,2-->1 equal 1 but--> abs(0-2) not<= k\nstep 1->\nindex 2,3-->1 equal 1 and abs(2-3) equal k --->Retuen True"
                    },
                    {
                        "username": "ankit_shrez",
                        "content": "I solved the problem with time limit efficiency at the order of nums.length and yet it returns time limit exception. anyone else seeing the same?"
                    }
                ]
            },
            {
                "id": 1940697,
                "content": [
                    {
                        "username": "k_17_sawai",
                        "content": "What if I sort the vector here?then i only need to check if 1 <= k but why that does not work here?"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "If we sort the array then, we\\'ll lose the actual position/ indices of the elements. This wouldn\\'t give us correct ans when we compute nums[i] == nums[j] and check the difference between indices abs(i-j)<=k"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "Can any one explained this question??"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "this question is about given the array \"nums\", we need to check if there are same elements exist in the array. if they exist then get their absolute difference of indices {i.e., nums[i] == nums[j] } and if this absolute difference of their indices is less than or equal to k then return true. if no such elements exist then return false."
                    },
                    {
                        "username": "gorota",
                        "content": "Can you suggest me how to improve this code, time exceeding!!!\\n\\ntypedef struct table {\\n    int val;\\n    int index;\\n} Table;\\n\\nbool containsNearbyDuplicate(int* nums, int numsSize, int k) {\\n    Table* hashTable = (Table*)malloc(sizeof(Table) * numsSize);\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (hashTable[j].val == nums[i] && abs(hashTable[j].index - i) <= k) {\\n                free(hashTable);\\n                return true;\\n            }\\n        }\\n        hashTable[i].val = nums[i];\\n        hashTable[i].index = i;\\n    }\\n\\n    free(hashTable);\\n    return false;\\n}"
                    },
                    {
                        "username": "BlakeE",
                        "content": "You only need to search k distance away from i. Searching anything more than that distance is outside of the scope\n"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "store only the index of recently traversed element in the hash-table. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "Why do they say distinct indices? If we iterate over the vector how could the indices not be distinct?"
                    },
                    {
                        "username": "sitanggang",
                        "content": "stil curious, said return true if there are two distinct indices but nums = [1,2,3,1], k = 3 which is 3 only on 1 index and it expected true."
                    },
                    {
                        "username": "tnguyen306",
                        "content": "So why is if nums =[1] and k = 1, then it \\'s false? if the window is 1 and i and j are the same number, shouldnt it be true?"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "in the ques its mentioned the indices should be distinct, so index cant be same. so it returns false."
                    },
                    {
                        "username": "Aditi_Hari",
                        "content": "Can you Please help me for this\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        for (int i = 0 ;i< nums.length ; i++){\\n            for (int j = 0 ; j< nums.length ; j++){\\n                if (nums[i] == nums [j]) {\\n                    if (Math.abs(i-j) <= k){\\n                    return true;}\\n                    \\n                }\\n\\n                } \\n            }\\n        \\n        return false;\\n        \\n    }\\n}\\nWhy third test case is not working for this code?\\n"
                    },
                    {
                        "username": "kshitijpratap2004",
                        "content": "Hi Aditi\n your loop is wrong \ncorrect is j = i + 1\nbecause we have to start second loop by 1 incrementing i\n\nBut sadly this solns is not working \nshowing TLE"
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "Also your Solution is Everytime give true. because you are comparing  same number and the absolute value always give (0-0) 0. "
                    },
                    {
                        "username": "zabuli",
                        "content": "I guess it\\'s because you have mistake in your code. Read properly this part:  \"distinct indices i and j\" => you shouldn\\'t start second loop with same index."
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "you are using second for loop from index number 0. your loop start and end in just one iteration . because for third test case you are compare nums[0]== nums[0] that is true and nested if Math.abs(0-0) <= true . that is the mistake . \\n                     I Will Given a Solution for you . Use hashmap it will give a proper Answer"
                    },
                    {
                        "username": "tejasree438",
                        "content": "The question is if we found the duplicates ,then there duplicate index\\'s difference could be <= k values\\n\\ncase 1: nums = [1,2,3,1], k = 3\\nelement 1 is duplicate\\n1 index is 0 ans 3 therefore 3-0 =3 ans its equal to k.\\n\\ncase 2 : nums = [1,0,1,1], k = 1\\nelement 1 is duplicate\\nindex are =0,2,3\\n2-0= less than or equals k false but\\n3-2 =1 so its less than or equals to k\\n\\ncase 3: [1,2,3,1,2,3], k = 2\\nduplicates 1,2,3 \\n1 index\\'s = 0,3 =3-0 not less than or equals so false;\\n2 index\\'s = 1,4 =4-1 not less than or equals so false;\\n1 index\\'s = 2,5 =5-2 not less than or equals so false;\\n\\n"
                    },
                    {
                        "username": "amitsingh75",
                        "content": "This question is a bit incomplete.  I have tried to explain this very well with the help of examples.---------------------> \nnums=[1,0,1,1]\nk=1\nstep 1->\nindex 0,1-->1 not equal 0\nstep 2->\nindex 0,2-->1 equal 1 but--> abs(0-2) not<= k\nstep 1->\nindex 2,3-->1 equal 1 and abs(2-3) equal k --->Retuen True"
                    },
                    {
                        "username": "ankit_shrez",
                        "content": "I solved the problem with time limit efficiency at the order of nums.length and yet it returns time limit exception. anyone else seeing the same?"
                    }
                ]
            },
            {
                "id": 1931712,
                "content": [
                    {
                        "username": "k_17_sawai",
                        "content": "What if I sort the vector here?then i only need to check if 1 <= k but why that does not work here?"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "If we sort the array then, we\\'ll lose the actual position/ indices of the elements. This wouldn\\'t give us correct ans when we compute nums[i] == nums[j] and check the difference between indices abs(i-j)<=k"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "Can any one explained this question??"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "this question is about given the array \"nums\", we need to check if there are same elements exist in the array. if they exist then get their absolute difference of indices {i.e., nums[i] == nums[j] } and if this absolute difference of their indices is less than or equal to k then return true. if no such elements exist then return false."
                    },
                    {
                        "username": "gorota",
                        "content": "Can you suggest me how to improve this code, time exceeding!!!\\n\\ntypedef struct table {\\n    int val;\\n    int index;\\n} Table;\\n\\nbool containsNearbyDuplicate(int* nums, int numsSize, int k) {\\n    Table* hashTable = (Table*)malloc(sizeof(Table) * numsSize);\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (hashTable[j].val == nums[i] && abs(hashTable[j].index - i) <= k) {\\n                free(hashTable);\\n                return true;\\n            }\\n        }\\n        hashTable[i].val = nums[i];\\n        hashTable[i].index = i;\\n    }\\n\\n    free(hashTable);\\n    return false;\\n}"
                    },
                    {
                        "username": "BlakeE",
                        "content": "You only need to search k distance away from i. Searching anything more than that distance is outside of the scope\n"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "store only the index of recently traversed element in the hash-table. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "Why do they say distinct indices? If we iterate over the vector how could the indices not be distinct?"
                    },
                    {
                        "username": "sitanggang",
                        "content": "stil curious, said return true if there are two distinct indices but nums = [1,2,3,1], k = 3 which is 3 only on 1 index and it expected true."
                    },
                    {
                        "username": "tnguyen306",
                        "content": "So why is if nums =[1] and k = 1, then it \\'s false? if the window is 1 and i and j are the same number, shouldnt it be true?"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "in the ques its mentioned the indices should be distinct, so index cant be same. so it returns false."
                    },
                    {
                        "username": "Aditi_Hari",
                        "content": "Can you Please help me for this\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        for (int i = 0 ;i< nums.length ; i++){\\n            for (int j = 0 ; j< nums.length ; j++){\\n                if (nums[i] == nums [j]) {\\n                    if (Math.abs(i-j) <= k){\\n                    return true;}\\n                    \\n                }\\n\\n                } \\n            }\\n        \\n        return false;\\n        \\n    }\\n}\\nWhy third test case is not working for this code?\\n"
                    },
                    {
                        "username": "kshitijpratap2004",
                        "content": "Hi Aditi\n your loop is wrong \ncorrect is j = i + 1\nbecause we have to start second loop by 1 incrementing i\n\nBut sadly this solns is not working \nshowing TLE"
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "Also your Solution is Everytime give true. because you are comparing  same number and the absolute value always give (0-0) 0. "
                    },
                    {
                        "username": "zabuli",
                        "content": "I guess it\\'s because you have mistake in your code. Read properly this part:  \"distinct indices i and j\" => you shouldn\\'t start second loop with same index."
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "you are using second for loop from index number 0. your loop start and end in just one iteration . because for third test case you are compare nums[0]== nums[0] that is true and nested if Math.abs(0-0) <= true . that is the mistake . \\n                     I Will Given a Solution for you . Use hashmap it will give a proper Answer"
                    },
                    {
                        "username": "tejasree438",
                        "content": "The question is if we found the duplicates ,then there duplicate index\\'s difference could be <= k values\\n\\ncase 1: nums = [1,2,3,1], k = 3\\nelement 1 is duplicate\\n1 index is 0 ans 3 therefore 3-0 =3 ans its equal to k.\\n\\ncase 2 : nums = [1,0,1,1], k = 1\\nelement 1 is duplicate\\nindex are =0,2,3\\n2-0= less than or equals k false but\\n3-2 =1 so its less than or equals to k\\n\\ncase 3: [1,2,3,1,2,3], k = 2\\nduplicates 1,2,3 \\n1 index\\'s = 0,3 =3-0 not less than or equals so false;\\n2 index\\'s = 1,4 =4-1 not less than or equals so false;\\n1 index\\'s = 2,5 =5-2 not less than or equals so false;\\n\\n"
                    },
                    {
                        "username": "amitsingh75",
                        "content": "This question is a bit incomplete.  I have tried to explain this very well with the help of examples.---------------------> \nnums=[1,0,1,1]\nk=1\nstep 1->\nindex 0,1-->1 not equal 0\nstep 2->\nindex 0,2-->1 equal 1 but--> abs(0-2) not<= k\nstep 1->\nindex 2,3-->1 equal 1 and abs(2-3) equal k --->Retuen True"
                    },
                    {
                        "username": "ankit_shrez",
                        "content": "I solved the problem with time limit efficiency at the order of nums.length and yet it returns time limit exception. anyone else seeing the same?"
                    }
                ]
            },
            {
                "id": 1920715,
                "content": [
                    {
                        "username": "k_17_sawai",
                        "content": "What if I sort the vector here?then i only need to check if 1 <= k but why that does not work here?"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "If we sort the array then, we\\'ll lose the actual position/ indices of the elements. This wouldn\\'t give us correct ans when we compute nums[i] == nums[j] and check the difference between indices abs(i-j)<=k"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "Can any one explained this question??"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "this question is about given the array \"nums\", we need to check if there are same elements exist in the array. if they exist then get their absolute difference of indices {i.e., nums[i] == nums[j] } and if this absolute difference of their indices is less than or equal to k then return true. if no such elements exist then return false."
                    },
                    {
                        "username": "gorota",
                        "content": "Can you suggest me how to improve this code, time exceeding!!!\\n\\ntypedef struct table {\\n    int val;\\n    int index;\\n} Table;\\n\\nbool containsNearbyDuplicate(int* nums, int numsSize, int k) {\\n    Table* hashTable = (Table*)malloc(sizeof(Table) * numsSize);\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (hashTable[j].val == nums[i] && abs(hashTable[j].index - i) <= k) {\\n                free(hashTable);\\n                return true;\\n            }\\n        }\\n        hashTable[i].val = nums[i];\\n        hashTable[i].index = i;\\n    }\\n\\n    free(hashTable);\\n    return false;\\n}"
                    },
                    {
                        "username": "BlakeE",
                        "content": "You only need to search k distance away from i. Searching anything more than that distance is outside of the scope\n"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "store only the index of recently traversed element in the hash-table. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "Why do they say distinct indices? If we iterate over the vector how could the indices not be distinct?"
                    },
                    {
                        "username": "sitanggang",
                        "content": "stil curious, said return true if there are two distinct indices but nums = [1,2,3,1], k = 3 which is 3 only on 1 index and it expected true."
                    },
                    {
                        "username": "tnguyen306",
                        "content": "So why is if nums =[1] and k = 1, then it \\'s false? if the window is 1 and i and j are the same number, shouldnt it be true?"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "in the ques its mentioned the indices should be distinct, so index cant be same. so it returns false."
                    },
                    {
                        "username": "Aditi_Hari",
                        "content": "Can you Please help me for this\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        for (int i = 0 ;i< nums.length ; i++){\\n            for (int j = 0 ; j< nums.length ; j++){\\n                if (nums[i] == nums [j]) {\\n                    if (Math.abs(i-j) <= k){\\n                    return true;}\\n                    \\n                }\\n\\n                } \\n            }\\n        \\n        return false;\\n        \\n    }\\n}\\nWhy third test case is not working for this code?\\n"
                    },
                    {
                        "username": "kshitijpratap2004",
                        "content": "Hi Aditi\n your loop is wrong \ncorrect is j = i + 1\nbecause we have to start second loop by 1 incrementing i\n\nBut sadly this solns is not working \nshowing TLE"
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "Also your Solution is Everytime give true. because you are comparing  same number and the absolute value always give (0-0) 0. "
                    },
                    {
                        "username": "zabuli",
                        "content": "I guess it\\'s because you have mistake in your code. Read properly this part:  \"distinct indices i and j\" => you shouldn\\'t start second loop with same index."
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "you are using second for loop from index number 0. your loop start and end in just one iteration . because for third test case you are compare nums[0]== nums[0] that is true and nested if Math.abs(0-0) <= true . that is the mistake . \\n                     I Will Given a Solution for you . Use hashmap it will give a proper Answer"
                    },
                    {
                        "username": "tejasree438",
                        "content": "The question is if we found the duplicates ,then there duplicate index\\'s difference could be <= k values\\n\\ncase 1: nums = [1,2,3,1], k = 3\\nelement 1 is duplicate\\n1 index is 0 ans 3 therefore 3-0 =3 ans its equal to k.\\n\\ncase 2 : nums = [1,0,1,1], k = 1\\nelement 1 is duplicate\\nindex are =0,2,3\\n2-0= less than or equals k false but\\n3-2 =1 so its less than or equals to k\\n\\ncase 3: [1,2,3,1,2,3], k = 2\\nduplicates 1,2,3 \\n1 index\\'s = 0,3 =3-0 not less than or equals so false;\\n2 index\\'s = 1,4 =4-1 not less than or equals so false;\\n1 index\\'s = 2,5 =5-2 not less than or equals so false;\\n\\n"
                    },
                    {
                        "username": "amitsingh75",
                        "content": "This question is a bit incomplete.  I have tried to explain this very well with the help of examples.---------------------> \nnums=[1,0,1,1]\nk=1\nstep 1->\nindex 0,1-->1 not equal 0\nstep 2->\nindex 0,2-->1 equal 1 but--> abs(0-2) not<= k\nstep 1->\nindex 2,3-->1 equal 1 and abs(2-3) equal k --->Retuen True"
                    },
                    {
                        "username": "ankit_shrez",
                        "content": "I solved the problem with time limit efficiency at the order of nums.length and yet it returns time limit exception. anyone else seeing the same?"
                    }
                ]
            },
            {
                "id": 1909134,
                "content": [
                    {
                        "username": "k_17_sawai",
                        "content": "What if I sort the vector here?then i only need to check if 1 <= k but why that does not work here?"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "If we sort the array then, we\\'ll lose the actual position/ indices of the elements. This wouldn\\'t give us correct ans when we compute nums[i] == nums[j] and check the difference between indices abs(i-j)<=k"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "Can any one explained this question??"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "this question is about given the array \"nums\", we need to check if there are same elements exist in the array. if they exist then get their absolute difference of indices {i.e., nums[i] == nums[j] } and if this absolute difference of their indices is less than or equal to k then return true. if no such elements exist then return false."
                    },
                    {
                        "username": "gorota",
                        "content": "Can you suggest me how to improve this code, time exceeding!!!\\n\\ntypedef struct table {\\n    int val;\\n    int index;\\n} Table;\\n\\nbool containsNearbyDuplicate(int* nums, int numsSize, int k) {\\n    Table* hashTable = (Table*)malloc(sizeof(Table) * numsSize);\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (hashTable[j].val == nums[i] && abs(hashTable[j].index - i) <= k) {\\n                free(hashTable);\\n                return true;\\n            }\\n        }\\n        hashTable[i].val = nums[i];\\n        hashTable[i].index = i;\\n    }\\n\\n    free(hashTable);\\n    return false;\\n}"
                    },
                    {
                        "username": "BlakeE",
                        "content": "You only need to search k distance away from i. Searching anything more than that distance is outside of the scope\n"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "store only the index of recently traversed element in the hash-table. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "Why do they say distinct indices? If we iterate over the vector how could the indices not be distinct?"
                    },
                    {
                        "username": "sitanggang",
                        "content": "stil curious, said return true if there are two distinct indices but nums = [1,2,3,1], k = 3 which is 3 only on 1 index and it expected true."
                    },
                    {
                        "username": "tnguyen306",
                        "content": "So why is if nums =[1] and k = 1, then it \\'s false? if the window is 1 and i and j are the same number, shouldnt it be true?"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "in the ques its mentioned the indices should be distinct, so index cant be same. so it returns false."
                    },
                    {
                        "username": "Aditi_Hari",
                        "content": "Can you Please help me for this\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        for (int i = 0 ;i< nums.length ; i++){\\n            for (int j = 0 ; j< nums.length ; j++){\\n                if (nums[i] == nums [j]) {\\n                    if (Math.abs(i-j) <= k){\\n                    return true;}\\n                    \\n                }\\n\\n                } \\n            }\\n        \\n        return false;\\n        \\n    }\\n}\\nWhy third test case is not working for this code?\\n"
                    },
                    {
                        "username": "kshitijpratap2004",
                        "content": "Hi Aditi\n your loop is wrong \ncorrect is j = i + 1\nbecause we have to start second loop by 1 incrementing i\n\nBut sadly this solns is not working \nshowing TLE"
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "Also your Solution is Everytime give true. because you are comparing  same number and the absolute value always give (0-0) 0. "
                    },
                    {
                        "username": "zabuli",
                        "content": "I guess it\\'s because you have mistake in your code. Read properly this part:  \"distinct indices i and j\" => you shouldn\\'t start second loop with same index."
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "you are using second for loop from index number 0. your loop start and end in just one iteration . because for third test case you are compare nums[0]== nums[0] that is true and nested if Math.abs(0-0) <= true . that is the mistake . \\n                     I Will Given a Solution for you . Use hashmap it will give a proper Answer"
                    },
                    {
                        "username": "tejasree438",
                        "content": "The question is if we found the duplicates ,then there duplicate index\\'s difference could be <= k values\\n\\ncase 1: nums = [1,2,3,1], k = 3\\nelement 1 is duplicate\\n1 index is 0 ans 3 therefore 3-0 =3 ans its equal to k.\\n\\ncase 2 : nums = [1,0,1,1], k = 1\\nelement 1 is duplicate\\nindex are =0,2,3\\n2-0= less than or equals k false but\\n3-2 =1 so its less than or equals to k\\n\\ncase 3: [1,2,3,1,2,3], k = 2\\nduplicates 1,2,3 \\n1 index\\'s = 0,3 =3-0 not less than or equals so false;\\n2 index\\'s = 1,4 =4-1 not less than or equals so false;\\n1 index\\'s = 2,5 =5-2 not less than or equals so false;\\n\\n"
                    },
                    {
                        "username": "amitsingh75",
                        "content": "This question is a bit incomplete.  I have tried to explain this very well with the help of examples.---------------------> \nnums=[1,0,1,1]\nk=1\nstep 1->\nindex 0,1-->1 not equal 0\nstep 2->\nindex 0,2-->1 equal 1 but--> abs(0-2) not<= k\nstep 1->\nindex 2,3-->1 equal 1 and abs(2-3) equal k --->Retuen True"
                    },
                    {
                        "username": "ankit_shrez",
                        "content": "I solved the problem with time limit efficiency at the order of nums.length and yet it returns time limit exception. anyone else seeing the same?"
                    }
                ]
            },
            {
                "id": 1899715,
                "content": [
                    {
                        "username": "k_17_sawai",
                        "content": "What if I sort the vector here?then i only need to check if 1 <= k but why that does not work here?"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "If we sort the array then, we\\'ll lose the actual position/ indices of the elements. This wouldn\\'t give us correct ans when we compute nums[i] == nums[j] and check the difference between indices abs(i-j)<=k"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "Can any one explained this question??"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "this question is about given the array \"nums\", we need to check if there are same elements exist in the array. if they exist then get their absolute difference of indices {i.e., nums[i] == nums[j] } and if this absolute difference of their indices is less than or equal to k then return true. if no such elements exist then return false."
                    },
                    {
                        "username": "gorota",
                        "content": "Can you suggest me how to improve this code, time exceeding!!!\\n\\ntypedef struct table {\\n    int val;\\n    int index;\\n} Table;\\n\\nbool containsNearbyDuplicate(int* nums, int numsSize, int k) {\\n    Table* hashTable = (Table*)malloc(sizeof(Table) * numsSize);\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (hashTable[j].val == nums[i] && abs(hashTable[j].index - i) <= k) {\\n                free(hashTable);\\n                return true;\\n            }\\n        }\\n        hashTable[i].val = nums[i];\\n        hashTable[i].index = i;\\n    }\\n\\n    free(hashTable);\\n    return false;\\n}"
                    },
                    {
                        "username": "BlakeE",
                        "content": "You only need to search k distance away from i. Searching anything more than that distance is outside of the scope\n"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "store only the index of recently traversed element in the hash-table. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "Why do they say distinct indices? If we iterate over the vector how could the indices not be distinct?"
                    },
                    {
                        "username": "sitanggang",
                        "content": "stil curious, said return true if there are two distinct indices but nums = [1,2,3,1], k = 3 which is 3 only on 1 index and it expected true."
                    },
                    {
                        "username": "tnguyen306",
                        "content": "So why is if nums =[1] and k = 1, then it \\'s false? if the window is 1 and i and j are the same number, shouldnt it be true?"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "in the ques its mentioned the indices should be distinct, so index cant be same. so it returns false."
                    },
                    {
                        "username": "Aditi_Hari",
                        "content": "Can you Please help me for this\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        for (int i = 0 ;i< nums.length ; i++){\\n            for (int j = 0 ; j< nums.length ; j++){\\n                if (nums[i] == nums [j]) {\\n                    if (Math.abs(i-j) <= k){\\n                    return true;}\\n                    \\n                }\\n\\n                } \\n            }\\n        \\n        return false;\\n        \\n    }\\n}\\nWhy third test case is not working for this code?\\n"
                    },
                    {
                        "username": "kshitijpratap2004",
                        "content": "Hi Aditi\n your loop is wrong \ncorrect is j = i + 1\nbecause we have to start second loop by 1 incrementing i\n\nBut sadly this solns is not working \nshowing TLE"
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "Also your Solution is Everytime give true. because you are comparing  same number and the absolute value always give (0-0) 0. "
                    },
                    {
                        "username": "zabuli",
                        "content": "I guess it\\'s because you have mistake in your code. Read properly this part:  \"distinct indices i and j\" => you shouldn\\'t start second loop with same index."
                    },
                    {
                        "username": "Sam_Prakash",
                        "content": "you are using second for loop from index number 0. your loop start and end in just one iteration . because for third test case you are compare nums[0]== nums[0] that is true and nested if Math.abs(0-0) <= true . that is the mistake . \\n                     I Will Given a Solution for you . Use hashmap it will give a proper Answer"
                    },
                    {
                        "username": "tejasree438",
                        "content": "The question is if we found the duplicates ,then there duplicate index\\'s difference could be <= k values\\n\\ncase 1: nums = [1,2,3,1], k = 3\\nelement 1 is duplicate\\n1 index is 0 ans 3 therefore 3-0 =3 ans its equal to k.\\n\\ncase 2 : nums = [1,0,1,1], k = 1\\nelement 1 is duplicate\\nindex are =0,2,3\\n2-0= less than or equals k false but\\n3-2 =1 so its less than or equals to k\\n\\ncase 3: [1,2,3,1,2,3], k = 2\\nduplicates 1,2,3 \\n1 index\\'s = 0,3 =3-0 not less than or equals so false;\\n2 index\\'s = 1,4 =4-1 not less than or equals so false;\\n1 index\\'s = 2,5 =5-2 not less than or equals so false;\\n\\n"
                    },
                    {
                        "username": "amitsingh75",
                        "content": "This question is a bit incomplete.  I have tried to explain this very well with the help of examples.---------------------> \nnums=[1,0,1,1]\nk=1\nstep 1->\nindex 0,1-->1 not equal 0\nstep 2->\nindex 0,2-->1 equal 1 but--> abs(0-2) not<= k\nstep 1->\nindex 2,3-->1 equal 1 and abs(2-3) equal k --->Retuen True"
                    },
                    {
                        "username": "ankit_shrez",
                        "content": "I solved the problem with time limit efficiency at the order of nums.length and yet it returns time limit exception. anyone else seeing the same?"
                    }
                ]
            },
            {
                "id": 1888484,
                "content": [
                    {
                        "username": "Navoditverma",
                        "content": "in the case [99,99] k=2 it show true but it must be false;"
                    },
                    {
                        "username": "zabuli",
                        "content": "no, i == 0, j == 1 abs(0 - 1) == 1 => 1 <= 2, so it\\'s true."
                    },
                    {
                        "username": "cicartaya",
                        "content": "I\\'m a little confused on what a k value of zero (k=0) means. That doesn\\'t make much sense. If k=0, then the absolute value (the distance) between i and j is zero, but then that means that i and j would have to be the same, and that means they would not be distinct, correct? In that case, would we just return false if k=0?"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "what is it?? do we have to consider minimum distance between two same numbers or the max one?"
                    },
                    {
                        "username": "asmaeMouradi",
                        "content": "I did not understand what does the variable k represent\\n"
                    },
                    {
                        "username": "bhaskarshashwath",
                        "content": "The TLE for the solution is very strict. This is my solution\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        int i = 0;\\n        int j = i+1;\\n        while(i < nums.size()-1 && k>0){\\n            if(nums[i] == nums[j]){\\n                return true;\\n            }\\n            else if(j==i+k || j == nums.size()-1){\\n                i++;\\n                j = i+1;\\n            }\\n            else{\\n                j++;\\n            }\\n\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "im getting a tle for the following solution\\n `class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        // im guessing this is a case of variable sluiding window\\n        int i=0, j=i+1;\\n\\n        while(j<nums.length)\\n        {\\n            if(nums[j]==nums[i] && Math.abs(j-i)<= k) return true;\\n            if(j-i + 1< k) j++;\\n            else if(j-i+1 == k){\\n                i++;\\n                j=i+1;\\n            }\\n        }\\n        return false;\\n    }\\n}`\\n\\nany idea why??? do sliding window problems with an unknown k or an unknown window size often have the risk of running into tle?\\n"
                    },
                    {
                        "username": "AnandBawa",
                        "content": "If getting time limit issue and using nested loop; the nested loop doesn\\'t need to run for whole length of array but just the range of +/- k to satisfy (i - j <= k). Took some time to figure it out and it was a good exercise."
                    },
                    {
                        "username": "JeffH",
                        "content": "The description is incredibly confusing AND there is no guidance on what they want when there is 3-4-5+ (see test case 2) of a single value or when there are multiple repeating values (see test case 3).  I shouldn\\'t have to infer what they are looking for it should be explicit in the question. "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n  \\n    bool containsNearbyDuplicate(vector<int>&num,int k){\\n\\n    unordered_map<int,list<int>>m;\\n\\n    for(int i=0;i<num.size();i++){\\n        if(m.find(num[i])!=m.end()){ //if find value \\n\\n            for(auto node : m[num[i]]){ //from these index value \\n\\n               if(abs(i-node)<=k) return true;  //0 index  - suppose 3index 1\\n            }\\n        }\\n        m[num[i]].push_back(i);    //if not then push index as welll in map\\n    }\\n    return false ;\\n    }\\n};"
                    },
                    {
                        "username": "patilrushikesh8683",
                        "content": "if no duplicate elements are not present in the array in this situation what will be returned? "
                    }
                ]
            },
            {
                "id": 1871254,
                "content": [
                    {
                        "username": "Navoditverma",
                        "content": "in the case [99,99] k=2 it show true but it must be false;"
                    },
                    {
                        "username": "zabuli",
                        "content": "no, i == 0, j == 1 abs(0 - 1) == 1 => 1 <= 2, so it\\'s true."
                    },
                    {
                        "username": "cicartaya",
                        "content": "I\\'m a little confused on what a k value of zero (k=0) means. That doesn\\'t make much sense. If k=0, then the absolute value (the distance) between i and j is zero, but then that means that i and j would have to be the same, and that means they would not be distinct, correct? In that case, would we just return false if k=0?"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "what is it?? do we have to consider minimum distance between two same numbers or the max one?"
                    },
                    {
                        "username": "asmaeMouradi",
                        "content": "I did not understand what does the variable k represent\\n"
                    },
                    {
                        "username": "bhaskarshashwath",
                        "content": "The TLE for the solution is very strict. This is my solution\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        int i = 0;\\n        int j = i+1;\\n        while(i < nums.size()-1 && k>0){\\n            if(nums[i] == nums[j]){\\n                return true;\\n            }\\n            else if(j==i+k || j == nums.size()-1){\\n                i++;\\n                j = i+1;\\n            }\\n            else{\\n                j++;\\n            }\\n\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "im getting a tle for the following solution\\n `class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        // im guessing this is a case of variable sluiding window\\n        int i=0, j=i+1;\\n\\n        while(j<nums.length)\\n        {\\n            if(nums[j]==nums[i] && Math.abs(j-i)<= k) return true;\\n            if(j-i + 1< k) j++;\\n            else if(j-i+1 == k){\\n                i++;\\n                j=i+1;\\n            }\\n        }\\n        return false;\\n    }\\n}`\\n\\nany idea why??? do sliding window problems with an unknown k or an unknown window size often have the risk of running into tle?\\n"
                    },
                    {
                        "username": "AnandBawa",
                        "content": "If getting time limit issue and using nested loop; the nested loop doesn\\'t need to run for whole length of array but just the range of +/- k to satisfy (i - j <= k). Took some time to figure it out and it was a good exercise."
                    },
                    {
                        "username": "JeffH",
                        "content": "The description is incredibly confusing AND there is no guidance on what they want when there is 3-4-5+ (see test case 2) of a single value or when there are multiple repeating values (see test case 3).  I shouldn\\'t have to infer what they are looking for it should be explicit in the question. "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n  \\n    bool containsNearbyDuplicate(vector<int>&num,int k){\\n\\n    unordered_map<int,list<int>>m;\\n\\n    for(int i=0;i<num.size();i++){\\n        if(m.find(num[i])!=m.end()){ //if find value \\n\\n            for(auto node : m[num[i]]){ //from these index value \\n\\n               if(abs(i-node)<=k) return true;  //0 index  - suppose 3index 1\\n            }\\n        }\\n        m[num[i]].push_back(i);    //if not then push index as welll in map\\n    }\\n    return false ;\\n    }\\n};"
                    },
                    {
                        "username": "patilrushikesh8683",
                        "content": "if no duplicate elements are not present in the array in this situation what will be returned? "
                    }
                ]
            },
            {
                "id": 1871163,
                "content": [
                    {
                        "username": "Navoditverma",
                        "content": "in the case [99,99] k=2 it show true but it must be false;"
                    },
                    {
                        "username": "zabuli",
                        "content": "no, i == 0, j == 1 abs(0 - 1) == 1 => 1 <= 2, so it\\'s true."
                    },
                    {
                        "username": "cicartaya",
                        "content": "I\\'m a little confused on what a k value of zero (k=0) means. That doesn\\'t make much sense. If k=0, then the absolute value (the distance) between i and j is zero, but then that means that i and j would have to be the same, and that means they would not be distinct, correct? In that case, would we just return false if k=0?"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "what is it?? do we have to consider minimum distance between two same numbers or the max one?"
                    },
                    {
                        "username": "asmaeMouradi",
                        "content": "I did not understand what does the variable k represent\\n"
                    },
                    {
                        "username": "bhaskarshashwath",
                        "content": "The TLE for the solution is very strict. This is my solution\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        int i = 0;\\n        int j = i+1;\\n        while(i < nums.size()-1 && k>0){\\n            if(nums[i] == nums[j]){\\n                return true;\\n            }\\n            else if(j==i+k || j == nums.size()-1){\\n                i++;\\n                j = i+1;\\n            }\\n            else{\\n                j++;\\n            }\\n\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "im getting a tle for the following solution\\n `class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        // im guessing this is a case of variable sluiding window\\n        int i=0, j=i+1;\\n\\n        while(j<nums.length)\\n        {\\n            if(nums[j]==nums[i] && Math.abs(j-i)<= k) return true;\\n            if(j-i + 1< k) j++;\\n            else if(j-i+1 == k){\\n                i++;\\n                j=i+1;\\n            }\\n        }\\n        return false;\\n    }\\n}`\\n\\nany idea why??? do sliding window problems with an unknown k or an unknown window size often have the risk of running into tle?\\n"
                    },
                    {
                        "username": "AnandBawa",
                        "content": "If getting time limit issue and using nested loop; the nested loop doesn\\'t need to run for whole length of array but just the range of +/- k to satisfy (i - j <= k). Took some time to figure it out and it was a good exercise."
                    },
                    {
                        "username": "JeffH",
                        "content": "The description is incredibly confusing AND there is no guidance on what they want when there is 3-4-5+ (see test case 2) of a single value or when there are multiple repeating values (see test case 3).  I shouldn\\'t have to infer what they are looking for it should be explicit in the question. "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n  \\n    bool containsNearbyDuplicate(vector<int>&num,int k){\\n\\n    unordered_map<int,list<int>>m;\\n\\n    for(int i=0;i<num.size();i++){\\n        if(m.find(num[i])!=m.end()){ //if find value \\n\\n            for(auto node : m[num[i]]){ //from these index value \\n\\n               if(abs(i-node)<=k) return true;  //0 index  - suppose 3index 1\\n            }\\n        }\\n        m[num[i]].push_back(i);    //if not then push index as welll in map\\n    }\\n    return false ;\\n    }\\n};"
                    },
                    {
                        "username": "patilrushikesh8683",
                        "content": "if no duplicate elements are not present in the array in this situation what will be returned? "
                    }
                ]
            },
            {
                "id": 1869484,
                "content": [
                    {
                        "username": "Navoditverma",
                        "content": "in the case [99,99] k=2 it show true but it must be false;"
                    },
                    {
                        "username": "zabuli",
                        "content": "no, i == 0, j == 1 abs(0 - 1) == 1 => 1 <= 2, so it\\'s true."
                    },
                    {
                        "username": "cicartaya",
                        "content": "I\\'m a little confused on what a k value of zero (k=0) means. That doesn\\'t make much sense. If k=0, then the absolute value (the distance) between i and j is zero, but then that means that i and j would have to be the same, and that means they would not be distinct, correct? In that case, would we just return false if k=0?"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "what is it?? do we have to consider minimum distance between two same numbers or the max one?"
                    },
                    {
                        "username": "asmaeMouradi",
                        "content": "I did not understand what does the variable k represent\\n"
                    },
                    {
                        "username": "bhaskarshashwath",
                        "content": "The TLE for the solution is very strict. This is my solution\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        int i = 0;\\n        int j = i+1;\\n        while(i < nums.size()-1 && k>0){\\n            if(nums[i] == nums[j]){\\n                return true;\\n            }\\n            else if(j==i+k || j == nums.size()-1){\\n                i++;\\n                j = i+1;\\n            }\\n            else{\\n                j++;\\n            }\\n\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "im getting a tle for the following solution\\n `class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        // im guessing this is a case of variable sluiding window\\n        int i=0, j=i+1;\\n\\n        while(j<nums.length)\\n        {\\n            if(nums[j]==nums[i] && Math.abs(j-i)<= k) return true;\\n            if(j-i + 1< k) j++;\\n            else if(j-i+1 == k){\\n                i++;\\n                j=i+1;\\n            }\\n        }\\n        return false;\\n    }\\n}`\\n\\nany idea why??? do sliding window problems with an unknown k or an unknown window size often have the risk of running into tle?\\n"
                    },
                    {
                        "username": "AnandBawa",
                        "content": "If getting time limit issue and using nested loop; the nested loop doesn\\'t need to run for whole length of array but just the range of +/- k to satisfy (i - j <= k). Took some time to figure it out and it was a good exercise."
                    },
                    {
                        "username": "JeffH",
                        "content": "The description is incredibly confusing AND there is no guidance on what they want when there is 3-4-5+ (see test case 2) of a single value or when there are multiple repeating values (see test case 3).  I shouldn\\'t have to infer what they are looking for it should be explicit in the question. "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n  \\n    bool containsNearbyDuplicate(vector<int>&num,int k){\\n\\n    unordered_map<int,list<int>>m;\\n\\n    for(int i=0;i<num.size();i++){\\n        if(m.find(num[i])!=m.end()){ //if find value \\n\\n            for(auto node : m[num[i]]){ //from these index value \\n\\n               if(abs(i-node)<=k) return true;  //0 index  - suppose 3index 1\\n            }\\n        }\\n        m[num[i]].push_back(i);    //if not then push index as welll in map\\n    }\\n    return false ;\\n    }\\n};"
                    },
                    {
                        "username": "patilrushikesh8683",
                        "content": "if no duplicate elements are not present in the array in this situation what will be returned? "
                    }
                ]
            },
            {
                "id": 1824066,
                "content": [
                    {
                        "username": "Navoditverma",
                        "content": "in the case [99,99] k=2 it show true but it must be false;"
                    },
                    {
                        "username": "zabuli",
                        "content": "no, i == 0, j == 1 abs(0 - 1) == 1 => 1 <= 2, so it\\'s true."
                    },
                    {
                        "username": "cicartaya",
                        "content": "I\\'m a little confused on what a k value of zero (k=0) means. That doesn\\'t make much sense. If k=0, then the absolute value (the distance) between i and j is zero, but then that means that i and j would have to be the same, and that means they would not be distinct, correct? In that case, would we just return false if k=0?"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "what is it?? do we have to consider minimum distance between two same numbers or the max one?"
                    },
                    {
                        "username": "asmaeMouradi",
                        "content": "I did not understand what does the variable k represent\\n"
                    },
                    {
                        "username": "bhaskarshashwath",
                        "content": "The TLE for the solution is very strict. This is my solution\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        int i = 0;\\n        int j = i+1;\\n        while(i < nums.size()-1 && k>0){\\n            if(nums[i] == nums[j]){\\n                return true;\\n            }\\n            else if(j==i+k || j == nums.size()-1){\\n                i++;\\n                j = i+1;\\n            }\\n            else{\\n                j++;\\n            }\\n\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "im getting a tle for the following solution\\n `class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        // im guessing this is a case of variable sluiding window\\n        int i=0, j=i+1;\\n\\n        while(j<nums.length)\\n        {\\n            if(nums[j]==nums[i] && Math.abs(j-i)<= k) return true;\\n            if(j-i + 1< k) j++;\\n            else if(j-i+1 == k){\\n                i++;\\n                j=i+1;\\n            }\\n        }\\n        return false;\\n    }\\n}`\\n\\nany idea why??? do sliding window problems with an unknown k or an unknown window size often have the risk of running into tle?\\n"
                    },
                    {
                        "username": "AnandBawa",
                        "content": "If getting time limit issue and using nested loop; the nested loop doesn\\'t need to run for whole length of array but just the range of +/- k to satisfy (i - j <= k). Took some time to figure it out and it was a good exercise."
                    },
                    {
                        "username": "JeffH",
                        "content": "The description is incredibly confusing AND there is no guidance on what they want when there is 3-4-5+ (see test case 2) of a single value or when there are multiple repeating values (see test case 3).  I shouldn\\'t have to infer what they are looking for it should be explicit in the question. "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n  \\n    bool containsNearbyDuplicate(vector<int>&num,int k){\\n\\n    unordered_map<int,list<int>>m;\\n\\n    for(int i=0;i<num.size();i++){\\n        if(m.find(num[i])!=m.end()){ //if find value \\n\\n            for(auto node : m[num[i]]){ //from these index value \\n\\n               if(abs(i-node)<=k) return true;  //0 index  - suppose 3index 1\\n            }\\n        }\\n        m[num[i]].push_back(i);    //if not then push index as welll in map\\n    }\\n    return false ;\\n    }\\n};"
                    },
                    {
                        "username": "patilrushikesh8683",
                        "content": "if no duplicate elements are not present in the array in this situation what will be returned? "
                    }
                ]
            },
            {
                "id": 1814479,
                "content": [
                    {
                        "username": "Navoditverma",
                        "content": "in the case [99,99] k=2 it show true but it must be false;"
                    },
                    {
                        "username": "zabuli",
                        "content": "no, i == 0, j == 1 abs(0 - 1) == 1 => 1 <= 2, so it\\'s true."
                    },
                    {
                        "username": "cicartaya",
                        "content": "I\\'m a little confused on what a k value of zero (k=0) means. That doesn\\'t make much sense. If k=0, then the absolute value (the distance) between i and j is zero, but then that means that i and j would have to be the same, and that means they would not be distinct, correct? In that case, would we just return false if k=0?"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "what is it?? do we have to consider minimum distance between two same numbers or the max one?"
                    },
                    {
                        "username": "asmaeMouradi",
                        "content": "I did not understand what does the variable k represent\\n"
                    },
                    {
                        "username": "bhaskarshashwath",
                        "content": "The TLE for the solution is very strict. This is my solution\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        int i = 0;\\n        int j = i+1;\\n        while(i < nums.size()-1 && k>0){\\n            if(nums[i] == nums[j]){\\n                return true;\\n            }\\n            else if(j==i+k || j == nums.size()-1){\\n                i++;\\n                j = i+1;\\n            }\\n            else{\\n                j++;\\n            }\\n\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "im getting a tle for the following solution\\n `class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        // im guessing this is a case of variable sluiding window\\n        int i=0, j=i+1;\\n\\n        while(j<nums.length)\\n        {\\n            if(nums[j]==nums[i] && Math.abs(j-i)<= k) return true;\\n            if(j-i + 1< k) j++;\\n            else if(j-i+1 == k){\\n                i++;\\n                j=i+1;\\n            }\\n        }\\n        return false;\\n    }\\n}`\\n\\nany idea why??? do sliding window problems with an unknown k or an unknown window size often have the risk of running into tle?\\n"
                    },
                    {
                        "username": "AnandBawa",
                        "content": "If getting time limit issue and using nested loop; the nested loop doesn\\'t need to run for whole length of array but just the range of +/- k to satisfy (i - j <= k). Took some time to figure it out and it was a good exercise."
                    },
                    {
                        "username": "JeffH",
                        "content": "The description is incredibly confusing AND there is no guidance on what they want when there is 3-4-5+ (see test case 2) of a single value or when there are multiple repeating values (see test case 3).  I shouldn\\'t have to infer what they are looking for it should be explicit in the question. "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n  \\n    bool containsNearbyDuplicate(vector<int>&num,int k){\\n\\n    unordered_map<int,list<int>>m;\\n\\n    for(int i=0;i<num.size();i++){\\n        if(m.find(num[i])!=m.end()){ //if find value \\n\\n            for(auto node : m[num[i]]){ //from these index value \\n\\n               if(abs(i-node)<=k) return true;  //0 index  - suppose 3index 1\\n            }\\n        }\\n        m[num[i]].push_back(i);    //if not then push index as welll in map\\n    }\\n    return false ;\\n    }\\n};"
                    },
                    {
                        "username": "patilrushikesh8683",
                        "content": "if no duplicate elements are not present in the array in this situation what will be returned? "
                    }
                ]
            },
            {
                "id": 1810088,
                "content": [
                    {
                        "username": "Navoditverma",
                        "content": "in the case [99,99] k=2 it show true but it must be false;"
                    },
                    {
                        "username": "zabuli",
                        "content": "no, i == 0, j == 1 abs(0 - 1) == 1 => 1 <= 2, so it\\'s true."
                    },
                    {
                        "username": "cicartaya",
                        "content": "I\\'m a little confused on what a k value of zero (k=0) means. That doesn\\'t make much sense. If k=0, then the absolute value (the distance) between i and j is zero, but then that means that i and j would have to be the same, and that means they would not be distinct, correct? In that case, would we just return false if k=0?"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "what is it?? do we have to consider minimum distance between two same numbers or the max one?"
                    },
                    {
                        "username": "asmaeMouradi",
                        "content": "I did not understand what does the variable k represent\\n"
                    },
                    {
                        "username": "bhaskarshashwath",
                        "content": "The TLE for the solution is very strict. This is my solution\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        int i = 0;\\n        int j = i+1;\\n        while(i < nums.size()-1 && k>0){\\n            if(nums[i] == nums[j]){\\n                return true;\\n            }\\n            else if(j==i+k || j == nums.size()-1){\\n                i++;\\n                j = i+1;\\n            }\\n            else{\\n                j++;\\n            }\\n\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "im getting a tle for the following solution\\n `class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        // im guessing this is a case of variable sluiding window\\n        int i=0, j=i+1;\\n\\n        while(j<nums.length)\\n        {\\n            if(nums[j]==nums[i] && Math.abs(j-i)<= k) return true;\\n            if(j-i + 1< k) j++;\\n            else if(j-i+1 == k){\\n                i++;\\n                j=i+1;\\n            }\\n        }\\n        return false;\\n    }\\n}`\\n\\nany idea why??? do sliding window problems with an unknown k or an unknown window size often have the risk of running into tle?\\n"
                    },
                    {
                        "username": "AnandBawa",
                        "content": "If getting time limit issue and using nested loop; the nested loop doesn\\'t need to run for whole length of array but just the range of +/- k to satisfy (i - j <= k). Took some time to figure it out and it was a good exercise."
                    },
                    {
                        "username": "JeffH",
                        "content": "The description is incredibly confusing AND there is no guidance on what they want when there is 3-4-5+ (see test case 2) of a single value or when there are multiple repeating values (see test case 3).  I shouldn\\'t have to infer what they are looking for it should be explicit in the question. "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n  \\n    bool containsNearbyDuplicate(vector<int>&num,int k){\\n\\n    unordered_map<int,list<int>>m;\\n\\n    for(int i=0;i<num.size();i++){\\n        if(m.find(num[i])!=m.end()){ //if find value \\n\\n            for(auto node : m[num[i]]){ //from these index value \\n\\n               if(abs(i-node)<=k) return true;  //0 index  - suppose 3index 1\\n            }\\n        }\\n        m[num[i]].push_back(i);    //if not then push index as welll in map\\n    }\\n    return false ;\\n    }\\n};"
                    },
                    {
                        "username": "patilrushikesh8683",
                        "content": "if no duplicate elements are not present in the array in this situation what will be returned? "
                    }
                ]
            },
            {
                "id": 1808611,
                "content": [
                    {
                        "username": "Navoditverma",
                        "content": "in the case [99,99] k=2 it show true but it must be false;"
                    },
                    {
                        "username": "zabuli",
                        "content": "no, i == 0, j == 1 abs(0 - 1) == 1 => 1 <= 2, so it\\'s true."
                    },
                    {
                        "username": "cicartaya",
                        "content": "I\\'m a little confused on what a k value of zero (k=0) means. That doesn\\'t make much sense. If k=0, then the absolute value (the distance) between i and j is zero, but then that means that i and j would have to be the same, and that means they would not be distinct, correct? In that case, would we just return false if k=0?"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "what is it?? do we have to consider minimum distance between two same numbers or the max one?"
                    },
                    {
                        "username": "asmaeMouradi",
                        "content": "I did not understand what does the variable k represent\\n"
                    },
                    {
                        "username": "bhaskarshashwath",
                        "content": "The TLE for the solution is very strict. This is my solution\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        int i = 0;\\n        int j = i+1;\\n        while(i < nums.size()-1 && k>0){\\n            if(nums[i] == nums[j]){\\n                return true;\\n            }\\n            else if(j==i+k || j == nums.size()-1){\\n                i++;\\n                j = i+1;\\n            }\\n            else{\\n                j++;\\n            }\\n\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "im getting a tle for the following solution\\n `class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        // im guessing this is a case of variable sluiding window\\n        int i=0, j=i+1;\\n\\n        while(j<nums.length)\\n        {\\n            if(nums[j]==nums[i] && Math.abs(j-i)<= k) return true;\\n            if(j-i + 1< k) j++;\\n            else if(j-i+1 == k){\\n                i++;\\n                j=i+1;\\n            }\\n        }\\n        return false;\\n    }\\n}`\\n\\nany idea why??? do sliding window problems with an unknown k or an unknown window size often have the risk of running into tle?\\n"
                    },
                    {
                        "username": "AnandBawa",
                        "content": "If getting time limit issue and using nested loop; the nested loop doesn\\'t need to run for whole length of array but just the range of +/- k to satisfy (i - j <= k). Took some time to figure it out and it was a good exercise."
                    },
                    {
                        "username": "JeffH",
                        "content": "The description is incredibly confusing AND there is no guidance on what they want when there is 3-4-5+ (see test case 2) of a single value or when there are multiple repeating values (see test case 3).  I shouldn\\'t have to infer what they are looking for it should be explicit in the question. "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n  \\n    bool containsNearbyDuplicate(vector<int>&num,int k){\\n\\n    unordered_map<int,list<int>>m;\\n\\n    for(int i=0;i<num.size();i++){\\n        if(m.find(num[i])!=m.end()){ //if find value \\n\\n            for(auto node : m[num[i]]){ //from these index value \\n\\n               if(abs(i-node)<=k) return true;  //0 index  - suppose 3index 1\\n            }\\n        }\\n        m[num[i]].push_back(i);    //if not then push index as welll in map\\n    }\\n    return false ;\\n    }\\n};"
                    },
                    {
                        "username": "patilrushikesh8683",
                        "content": "if no duplicate elements are not present in the array in this situation what will be returned? "
                    }
                ]
            },
            {
                "id": 1804361,
                "content": [
                    {
                        "username": "Navoditverma",
                        "content": "in the case [99,99] k=2 it show true but it must be false;"
                    },
                    {
                        "username": "zabuli",
                        "content": "no, i == 0, j == 1 abs(0 - 1) == 1 => 1 <= 2, so it\\'s true."
                    },
                    {
                        "username": "cicartaya",
                        "content": "I\\'m a little confused on what a k value of zero (k=0) means. That doesn\\'t make much sense. If k=0, then the absolute value (the distance) between i and j is zero, but then that means that i and j would have to be the same, and that means they would not be distinct, correct? In that case, would we just return false if k=0?"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "what is it?? do we have to consider minimum distance between two same numbers or the max one?"
                    },
                    {
                        "username": "asmaeMouradi",
                        "content": "I did not understand what does the variable k represent\\n"
                    },
                    {
                        "username": "bhaskarshashwath",
                        "content": "The TLE for the solution is very strict. This is my solution\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        int i = 0;\\n        int j = i+1;\\n        while(i < nums.size()-1 && k>0){\\n            if(nums[i] == nums[j]){\\n                return true;\\n            }\\n            else if(j==i+k || j == nums.size()-1){\\n                i++;\\n                j = i+1;\\n            }\\n            else{\\n                j++;\\n            }\\n\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "im getting a tle for the following solution\\n `class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        // im guessing this is a case of variable sluiding window\\n        int i=0, j=i+1;\\n\\n        while(j<nums.length)\\n        {\\n            if(nums[j]==nums[i] && Math.abs(j-i)<= k) return true;\\n            if(j-i + 1< k) j++;\\n            else if(j-i+1 == k){\\n                i++;\\n                j=i+1;\\n            }\\n        }\\n        return false;\\n    }\\n}`\\n\\nany idea why??? do sliding window problems with an unknown k or an unknown window size often have the risk of running into tle?\\n"
                    },
                    {
                        "username": "AnandBawa",
                        "content": "If getting time limit issue and using nested loop; the nested loop doesn\\'t need to run for whole length of array but just the range of +/- k to satisfy (i - j <= k). Took some time to figure it out and it was a good exercise."
                    },
                    {
                        "username": "JeffH",
                        "content": "The description is incredibly confusing AND there is no guidance on what they want when there is 3-4-5+ (see test case 2) of a single value or when there are multiple repeating values (see test case 3).  I shouldn\\'t have to infer what they are looking for it should be explicit in the question. "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n  \\n    bool containsNearbyDuplicate(vector<int>&num,int k){\\n\\n    unordered_map<int,list<int>>m;\\n\\n    for(int i=0;i<num.size();i++){\\n        if(m.find(num[i])!=m.end()){ //if find value \\n\\n            for(auto node : m[num[i]]){ //from these index value \\n\\n               if(abs(i-node)<=k) return true;  //0 index  - suppose 3index 1\\n            }\\n        }\\n        m[num[i]].push_back(i);    //if not then push index as welll in map\\n    }\\n    return false ;\\n    }\\n};"
                    },
                    {
                        "username": "patilrushikesh8683",
                        "content": "if no duplicate elements are not present in the array in this situation what will be returned? "
                    }
                ]
            },
            {
                "id": 1796960,
                "content": [
                    {
                        "username": "Navoditverma",
                        "content": "in the case [99,99] k=2 it show true but it must be false;"
                    },
                    {
                        "username": "zabuli",
                        "content": "no, i == 0, j == 1 abs(0 - 1) == 1 => 1 <= 2, so it\\'s true."
                    },
                    {
                        "username": "cicartaya",
                        "content": "I\\'m a little confused on what a k value of zero (k=0) means. That doesn\\'t make much sense. If k=0, then the absolute value (the distance) between i and j is zero, but then that means that i and j would have to be the same, and that means they would not be distinct, correct? In that case, would we just return false if k=0?"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "what is it?? do we have to consider minimum distance between two same numbers or the max one?"
                    },
                    {
                        "username": "asmaeMouradi",
                        "content": "I did not understand what does the variable k represent\\n"
                    },
                    {
                        "username": "bhaskarshashwath",
                        "content": "The TLE for the solution is very strict. This is my solution\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        int i = 0;\\n        int j = i+1;\\n        while(i < nums.size()-1 && k>0){\\n            if(nums[i] == nums[j]){\\n                return true;\\n            }\\n            else if(j==i+k || j == nums.size()-1){\\n                i++;\\n                j = i+1;\\n            }\\n            else{\\n                j++;\\n            }\\n\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "im getting a tle for the following solution\\n `class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        // im guessing this is a case of variable sluiding window\\n        int i=0, j=i+1;\\n\\n        while(j<nums.length)\\n        {\\n            if(nums[j]==nums[i] && Math.abs(j-i)<= k) return true;\\n            if(j-i + 1< k) j++;\\n            else if(j-i+1 == k){\\n                i++;\\n                j=i+1;\\n            }\\n        }\\n        return false;\\n    }\\n}`\\n\\nany idea why??? do sliding window problems with an unknown k or an unknown window size often have the risk of running into tle?\\n"
                    },
                    {
                        "username": "AnandBawa",
                        "content": "If getting time limit issue and using nested loop; the nested loop doesn\\'t need to run for whole length of array but just the range of +/- k to satisfy (i - j <= k). Took some time to figure it out and it was a good exercise."
                    },
                    {
                        "username": "JeffH",
                        "content": "The description is incredibly confusing AND there is no guidance on what they want when there is 3-4-5+ (see test case 2) of a single value or when there are multiple repeating values (see test case 3).  I shouldn\\'t have to infer what they are looking for it should be explicit in the question. "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n  \\n    bool containsNearbyDuplicate(vector<int>&num,int k){\\n\\n    unordered_map<int,list<int>>m;\\n\\n    for(int i=0;i<num.size();i++){\\n        if(m.find(num[i])!=m.end()){ //if find value \\n\\n            for(auto node : m[num[i]]){ //from these index value \\n\\n               if(abs(i-node)<=k) return true;  //0 index  - suppose 3index 1\\n            }\\n        }\\n        m[num[i]].push_back(i);    //if not then push index as welll in map\\n    }\\n    return false ;\\n    }\\n};"
                    },
                    {
                        "username": "patilrushikesh8683",
                        "content": "if no duplicate elements are not present in the array in this situation what will be returned? "
                    }
                ]
            },
            {
                "id": 1778150,
                "content": [
                    {
                        "username": "RANJITH_G",
                        "content": "Is there any linear method in java without time approach?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "sk0884518",
                        "content": "class Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n               int m = abs(nums[i]-nums[i+1]);\\n               if(m <= k){\\n                   return true;\\n               }\\n            }\\n        }\\n        return false;\\n\\n    }\\n};\\nhelp me with the error in this code as i cant pass first testcase !!"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "bro jo tumne kiya h vo tab sahi hoga agar data structure sorted hoga \\npar agar hum ese sort karenge to i and j bhura man jayenge "
                    },
                    {
                        "username": "DextersLaboratory",
                        "content": "For `nums=[1,2,3,1,2,3]` `k=2`, why is the solution `false`?\n`3-1=2 <= k`\n\n`3-2=1 <= k`"
                    },
                    {
                        "username": "bhaskarshashwath",
                        "content": "because the elements at those indexes are not equal to each other\\n"
                    },
                    {
                        "username": "muhammedkhanem",
                        "content": "The first index is 0 not 1."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "davronbek6",
                        "content": "if we use 2 loops(for i and j) we get time limit issue, so how is it possible to solve?"
                    },
                    {
                        "username": "pinwheelchoi",
                        "content": "No idea what this question wants."
                    },
                    {
                        "username": "rohitmondal2003",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        for(int i=0; i<nums.length-1; i++){\\n            for(int j=1; j<nums.length; j++){\\n                if(nums[i]==nums[j] && Math.abs(i-j)<=k){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n\\n\\nCan someone tell me what is the issue with the solution ?\\nIt is not running for the following test case:  nums= [1,2,3,1,2,3] , k=2 "
                    },
                    {
                        "username": "PRAVEENVISHISTA",
                        "content": "int j=i+1"
                    },
                    {
                        "username": "deezyto",
                        "content": "For JavaScript use Math.abs(i - j) to get a positive number if i - j < 0"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "The time limit is so harsh..."
                    }
                ]
            },
            {
                "id": 1769767,
                "content": [
                    {
                        "username": "RANJITH_G",
                        "content": "Is there any linear method in java without time approach?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "sk0884518",
                        "content": "class Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n               int m = abs(nums[i]-nums[i+1]);\\n               if(m <= k){\\n                   return true;\\n               }\\n            }\\n        }\\n        return false;\\n\\n    }\\n};\\nhelp me with the error in this code as i cant pass first testcase !!"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "bro jo tumne kiya h vo tab sahi hoga agar data structure sorted hoga \\npar agar hum ese sort karenge to i and j bhura man jayenge "
                    },
                    {
                        "username": "DextersLaboratory",
                        "content": "For `nums=[1,2,3,1,2,3]` `k=2`, why is the solution `false`?\n`3-1=2 <= k`\n\n`3-2=1 <= k`"
                    },
                    {
                        "username": "bhaskarshashwath",
                        "content": "because the elements at those indexes are not equal to each other\\n"
                    },
                    {
                        "username": "muhammedkhanem",
                        "content": "The first index is 0 not 1."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "davronbek6",
                        "content": "if we use 2 loops(for i and j) we get time limit issue, so how is it possible to solve?"
                    },
                    {
                        "username": "pinwheelchoi",
                        "content": "No idea what this question wants."
                    },
                    {
                        "username": "rohitmondal2003",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        for(int i=0; i<nums.length-1; i++){\\n            for(int j=1; j<nums.length; j++){\\n                if(nums[i]==nums[j] && Math.abs(i-j)<=k){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n\\n\\nCan someone tell me what is the issue with the solution ?\\nIt is not running for the following test case:  nums= [1,2,3,1,2,3] , k=2 "
                    },
                    {
                        "username": "PRAVEENVISHISTA",
                        "content": "int j=i+1"
                    },
                    {
                        "username": "deezyto",
                        "content": "For JavaScript use Math.abs(i - j) to get a positive number if i - j < 0"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "The time limit is so harsh..."
                    }
                ]
            },
            {
                "id": 1763852,
                "content": [
                    {
                        "username": "RANJITH_G",
                        "content": "Is there any linear method in java without time approach?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "sk0884518",
                        "content": "class Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n               int m = abs(nums[i]-nums[i+1]);\\n               if(m <= k){\\n                   return true;\\n               }\\n            }\\n        }\\n        return false;\\n\\n    }\\n};\\nhelp me with the error in this code as i cant pass first testcase !!"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "bro jo tumne kiya h vo tab sahi hoga agar data structure sorted hoga \\npar agar hum ese sort karenge to i and j bhura man jayenge "
                    },
                    {
                        "username": "DextersLaboratory",
                        "content": "For `nums=[1,2,3,1,2,3]` `k=2`, why is the solution `false`?\n`3-1=2 <= k`\n\n`3-2=1 <= k`"
                    },
                    {
                        "username": "bhaskarshashwath",
                        "content": "because the elements at those indexes are not equal to each other\\n"
                    },
                    {
                        "username": "muhammedkhanem",
                        "content": "The first index is 0 not 1."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "davronbek6",
                        "content": "if we use 2 loops(for i and j) we get time limit issue, so how is it possible to solve?"
                    },
                    {
                        "username": "pinwheelchoi",
                        "content": "No idea what this question wants."
                    },
                    {
                        "username": "rohitmondal2003",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        for(int i=0; i<nums.length-1; i++){\\n            for(int j=1; j<nums.length; j++){\\n                if(nums[i]==nums[j] && Math.abs(i-j)<=k){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n\\n\\nCan someone tell me what is the issue with the solution ?\\nIt is not running for the following test case:  nums= [1,2,3,1,2,3] , k=2 "
                    },
                    {
                        "username": "PRAVEENVISHISTA",
                        "content": "int j=i+1"
                    },
                    {
                        "username": "deezyto",
                        "content": "For JavaScript use Math.abs(i - j) to get a positive number if i - j < 0"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "The time limit is so harsh..."
                    }
                ]
            },
            {
                "id": 1759889,
                "content": [
                    {
                        "username": "RANJITH_G",
                        "content": "Is there any linear method in java without time approach?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "sk0884518",
                        "content": "class Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n               int m = abs(nums[i]-nums[i+1]);\\n               if(m <= k){\\n                   return true;\\n               }\\n            }\\n        }\\n        return false;\\n\\n    }\\n};\\nhelp me with the error in this code as i cant pass first testcase !!"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "bro jo tumne kiya h vo tab sahi hoga agar data structure sorted hoga \\npar agar hum ese sort karenge to i and j bhura man jayenge "
                    },
                    {
                        "username": "DextersLaboratory",
                        "content": "For `nums=[1,2,3,1,2,3]` `k=2`, why is the solution `false`?\n`3-1=2 <= k`\n\n`3-2=1 <= k`"
                    },
                    {
                        "username": "bhaskarshashwath",
                        "content": "because the elements at those indexes are not equal to each other\\n"
                    },
                    {
                        "username": "muhammedkhanem",
                        "content": "The first index is 0 not 1."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "davronbek6",
                        "content": "if we use 2 loops(for i and j) we get time limit issue, so how is it possible to solve?"
                    },
                    {
                        "username": "pinwheelchoi",
                        "content": "No idea what this question wants."
                    },
                    {
                        "username": "rohitmondal2003",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        for(int i=0; i<nums.length-1; i++){\\n            for(int j=1; j<nums.length; j++){\\n                if(nums[i]==nums[j] && Math.abs(i-j)<=k){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n\\n\\nCan someone tell me what is the issue with the solution ?\\nIt is not running for the following test case:  nums= [1,2,3,1,2,3] , k=2 "
                    },
                    {
                        "username": "PRAVEENVISHISTA",
                        "content": "int j=i+1"
                    },
                    {
                        "username": "deezyto",
                        "content": "For JavaScript use Math.abs(i - j) to get a positive number if i - j < 0"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "The time limit is so harsh..."
                    }
                ]
            },
            {
                "id": 1757534,
                "content": [
                    {
                        "username": "RANJITH_G",
                        "content": "Is there any linear method in java without time approach?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "sk0884518",
                        "content": "class Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n               int m = abs(nums[i]-nums[i+1]);\\n               if(m <= k){\\n                   return true;\\n               }\\n            }\\n        }\\n        return false;\\n\\n    }\\n};\\nhelp me with the error in this code as i cant pass first testcase !!"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "bro jo tumne kiya h vo tab sahi hoga agar data structure sorted hoga \\npar agar hum ese sort karenge to i and j bhura man jayenge "
                    },
                    {
                        "username": "DextersLaboratory",
                        "content": "For `nums=[1,2,3,1,2,3]` `k=2`, why is the solution `false`?\n`3-1=2 <= k`\n\n`3-2=1 <= k`"
                    },
                    {
                        "username": "bhaskarshashwath",
                        "content": "because the elements at those indexes are not equal to each other\\n"
                    },
                    {
                        "username": "muhammedkhanem",
                        "content": "The first index is 0 not 1."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "davronbek6",
                        "content": "if we use 2 loops(for i and j) we get time limit issue, so how is it possible to solve?"
                    },
                    {
                        "username": "pinwheelchoi",
                        "content": "No idea what this question wants."
                    },
                    {
                        "username": "rohitmondal2003",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        for(int i=0; i<nums.length-1; i++){\\n            for(int j=1; j<nums.length; j++){\\n                if(nums[i]==nums[j] && Math.abs(i-j)<=k){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n\\n\\nCan someone tell me what is the issue with the solution ?\\nIt is not running for the following test case:  nums= [1,2,3,1,2,3] , k=2 "
                    },
                    {
                        "username": "PRAVEENVISHISTA",
                        "content": "int j=i+1"
                    },
                    {
                        "username": "deezyto",
                        "content": "For JavaScript use Math.abs(i - j) to get a positive number if i - j < 0"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "The time limit is so harsh..."
                    }
                ]
            },
            {
                "id": 1752089,
                "content": [
                    {
                        "username": "RANJITH_G",
                        "content": "Is there any linear method in java without time approach?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "sk0884518",
                        "content": "class Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n               int m = abs(nums[i]-nums[i+1]);\\n               if(m <= k){\\n                   return true;\\n               }\\n            }\\n        }\\n        return false;\\n\\n    }\\n};\\nhelp me with the error in this code as i cant pass first testcase !!"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "bro jo tumne kiya h vo tab sahi hoga agar data structure sorted hoga \\npar agar hum ese sort karenge to i and j bhura man jayenge "
                    },
                    {
                        "username": "DextersLaboratory",
                        "content": "For `nums=[1,2,3,1,2,3]` `k=2`, why is the solution `false`?\n`3-1=2 <= k`\n\n`3-2=1 <= k`"
                    },
                    {
                        "username": "bhaskarshashwath",
                        "content": "because the elements at those indexes are not equal to each other\\n"
                    },
                    {
                        "username": "muhammedkhanem",
                        "content": "The first index is 0 not 1."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "davronbek6",
                        "content": "if we use 2 loops(for i and j) we get time limit issue, so how is it possible to solve?"
                    },
                    {
                        "username": "pinwheelchoi",
                        "content": "No idea what this question wants."
                    },
                    {
                        "username": "rohitmondal2003",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        for(int i=0; i<nums.length-1; i++){\\n            for(int j=1; j<nums.length; j++){\\n                if(nums[i]==nums[j] && Math.abs(i-j)<=k){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n\\n\\nCan someone tell me what is the issue with the solution ?\\nIt is not running for the following test case:  nums= [1,2,3,1,2,3] , k=2 "
                    },
                    {
                        "username": "PRAVEENVISHISTA",
                        "content": "int j=i+1"
                    },
                    {
                        "username": "deezyto",
                        "content": "For JavaScript use Math.abs(i - j) to get a positive number if i - j < 0"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "The time limit is so harsh..."
                    }
                ]
            },
            {
                "id": 1751490,
                "content": [
                    {
                        "username": "RANJITH_G",
                        "content": "Is there any linear method in java without time approach?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "sk0884518",
                        "content": "class Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n               int m = abs(nums[i]-nums[i+1]);\\n               if(m <= k){\\n                   return true;\\n               }\\n            }\\n        }\\n        return false;\\n\\n    }\\n};\\nhelp me with the error in this code as i cant pass first testcase !!"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "bro jo tumne kiya h vo tab sahi hoga agar data structure sorted hoga \\npar agar hum ese sort karenge to i and j bhura man jayenge "
                    },
                    {
                        "username": "DextersLaboratory",
                        "content": "For `nums=[1,2,3,1,2,3]` `k=2`, why is the solution `false`?\n`3-1=2 <= k`\n\n`3-2=1 <= k`"
                    },
                    {
                        "username": "bhaskarshashwath",
                        "content": "because the elements at those indexes are not equal to each other\\n"
                    },
                    {
                        "username": "muhammedkhanem",
                        "content": "The first index is 0 not 1."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "davronbek6",
                        "content": "if we use 2 loops(for i and j) we get time limit issue, so how is it possible to solve?"
                    },
                    {
                        "username": "pinwheelchoi",
                        "content": "No idea what this question wants."
                    },
                    {
                        "username": "rohitmondal2003",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        for(int i=0; i<nums.length-1; i++){\\n            for(int j=1; j<nums.length; j++){\\n                if(nums[i]==nums[j] && Math.abs(i-j)<=k){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n\\n\\nCan someone tell me what is the issue with the solution ?\\nIt is not running for the following test case:  nums= [1,2,3,1,2,3] , k=2 "
                    },
                    {
                        "username": "PRAVEENVISHISTA",
                        "content": "int j=i+1"
                    },
                    {
                        "username": "deezyto",
                        "content": "For JavaScript use Math.abs(i - j) to get a positive number if i - j < 0"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "The time limit is so harsh..."
                    }
                ]
            },
            {
                "id": 1746791,
                "content": [
                    {
                        "username": "RANJITH_G",
                        "content": "Is there any linear method in java without time approach?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "sk0884518",
                        "content": "class Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n               int m = abs(nums[i]-nums[i+1]);\\n               if(m <= k){\\n                   return true;\\n               }\\n            }\\n        }\\n        return false;\\n\\n    }\\n};\\nhelp me with the error in this code as i cant pass first testcase !!"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "bro jo tumne kiya h vo tab sahi hoga agar data structure sorted hoga \\npar agar hum ese sort karenge to i and j bhura man jayenge "
                    },
                    {
                        "username": "DextersLaboratory",
                        "content": "For `nums=[1,2,3,1,2,3]` `k=2`, why is the solution `false`?\n`3-1=2 <= k`\n\n`3-2=1 <= k`"
                    },
                    {
                        "username": "bhaskarshashwath",
                        "content": "because the elements at those indexes are not equal to each other\\n"
                    },
                    {
                        "username": "muhammedkhanem",
                        "content": "The first index is 0 not 1."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "davronbek6",
                        "content": "if we use 2 loops(for i and j) we get time limit issue, so how is it possible to solve?"
                    },
                    {
                        "username": "pinwheelchoi",
                        "content": "No idea what this question wants."
                    },
                    {
                        "username": "rohitmondal2003",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        for(int i=0; i<nums.length-1; i++){\\n            for(int j=1; j<nums.length; j++){\\n                if(nums[i]==nums[j] && Math.abs(i-j)<=k){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n\\n\\nCan someone tell me what is the issue with the solution ?\\nIt is not running for the following test case:  nums= [1,2,3,1,2,3] , k=2 "
                    },
                    {
                        "username": "PRAVEENVISHISTA",
                        "content": "int j=i+1"
                    },
                    {
                        "username": "deezyto",
                        "content": "For JavaScript use Math.abs(i - j) to get a positive number if i - j < 0"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "The time limit is so harsh..."
                    }
                ]
            },
            {
                "id": 1736955,
                "content": [
                    {
                        "username": "RANJITH_G",
                        "content": "Is there any linear method in java without time approach?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "sk0884518",
                        "content": "class Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n               int m = abs(nums[i]-nums[i+1]);\\n               if(m <= k){\\n                   return true;\\n               }\\n            }\\n        }\\n        return false;\\n\\n    }\\n};\\nhelp me with the error in this code as i cant pass first testcase !!"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "bro jo tumne kiya h vo tab sahi hoga agar data structure sorted hoga \\npar agar hum ese sort karenge to i and j bhura man jayenge "
                    },
                    {
                        "username": "DextersLaboratory",
                        "content": "For `nums=[1,2,3,1,2,3]` `k=2`, why is the solution `false`?\n`3-1=2 <= k`\n\n`3-2=1 <= k`"
                    },
                    {
                        "username": "bhaskarshashwath",
                        "content": "because the elements at those indexes are not equal to each other\\n"
                    },
                    {
                        "username": "muhammedkhanem",
                        "content": "The first index is 0 not 1."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "davronbek6",
                        "content": "if we use 2 loops(for i and j) we get time limit issue, so how is it possible to solve?"
                    },
                    {
                        "username": "pinwheelchoi",
                        "content": "No idea what this question wants."
                    },
                    {
                        "username": "rohitmondal2003",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        for(int i=0; i<nums.length-1; i++){\\n            for(int j=1; j<nums.length; j++){\\n                if(nums[i]==nums[j] && Math.abs(i-j)<=k){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n\\n\\nCan someone tell me what is the issue with the solution ?\\nIt is not running for the following test case:  nums= [1,2,3,1,2,3] , k=2 "
                    },
                    {
                        "username": "PRAVEENVISHISTA",
                        "content": "int j=i+1"
                    },
                    {
                        "username": "deezyto",
                        "content": "For JavaScript use Math.abs(i - j) to get a positive number if i - j < 0"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "The time limit is so harsh..."
                    }
                ]
            },
            {
                "id": 1736001,
                "content": [
                    {
                        "username": "RANJITH_G",
                        "content": "Is there any linear method in java without time approach?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "sk0884518",
                        "content": "class Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n               int m = abs(nums[i]-nums[i+1]);\\n               if(m <= k){\\n                   return true;\\n               }\\n            }\\n        }\\n        return false;\\n\\n    }\\n};\\nhelp me with the error in this code as i cant pass first testcase !!"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "bro jo tumne kiya h vo tab sahi hoga agar data structure sorted hoga \\npar agar hum ese sort karenge to i and j bhura man jayenge "
                    },
                    {
                        "username": "DextersLaboratory",
                        "content": "For `nums=[1,2,3,1,2,3]` `k=2`, why is the solution `false`?\n`3-1=2 <= k`\n\n`3-2=1 <= k`"
                    },
                    {
                        "username": "bhaskarshashwath",
                        "content": "because the elements at those indexes are not equal to each other\\n"
                    },
                    {
                        "username": "muhammedkhanem",
                        "content": "The first index is 0 not 1."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "davronbek6",
                        "content": "if we use 2 loops(for i and j) we get time limit issue, so how is it possible to solve?"
                    },
                    {
                        "username": "pinwheelchoi",
                        "content": "No idea what this question wants."
                    },
                    {
                        "username": "rohitmondal2003",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        for(int i=0; i<nums.length-1; i++){\\n            for(int j=1; j<nums.length; j++){\\n                if(nums[i]==nums[j] && Math.abs(i-j)<=k){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n\\n\\nCan someone tell me what is the issue with the solution ?\\nIt is not running for the following test case:  nums= [1,2,3,1,2,3] , k=2 "
                    },
                    {
                        "username": "PRAVEENVISHISTA",
                        "content": "int j=i+1"
                    },
                    {
                        "username": "deezyto",
                        "content": "For JavaScript use Math.abs(i - j) to get a positive number if i - j < 0"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "The time limit is so harsh..."
                    }
                ]
            },
            {
                "id": 1734419,
                "content": [
                    {
                        "username": "rimanshu007",
                        "content": "TLE occur ho raha hai, \\nanyone help me to improve this code........\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {   \\n        int start = 0, end = 0;                    \\n        while (start < nums.size()){\\n            for(int end=start+1;end<nums.size();end++){\\n                if(nums[start]==nums[end] && abs(start-end)<=k){    \\n                    return true;\\n                }\\n                // end++;\\n            }\\n            start++;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "bhaskarshashwath",
                        "content": "This is brute force. Try to optimize your solution using some approach like 2 pointer or somthing."
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "For large input nested loop for n data raise your time complexity O(N^2) so try to come up with a solution using single traversal."
                    },
                    {
                        "username": "rajat_171",
                        "content": "Can anybody help me to optimize this code please.... I \\'m new to coding.\\n `  bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        int i = 0;\\n        int e = nums.size()-1;\\n\\n        while(e > 0){\\n            while( i < e){\\n                if(nums[i] == nums[e] && abs(i-e) <= k ){\\n                    return true;\\n                }\\n                i++;\\n            }\\n            i = 0;\\n            e--;\\n        }\\n        return false;\\n    }`"
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n       HashSet<Integer> numbers = new HashSet<>();\\n\\n       for(int i=0 ; i<nums.length ; i++){\\n           if(numbers.contains(nums[i])){\\n               return true ;}\\n               numbers.add(nums[i]);\\n       }\\n       return false ;\\n    }\\n}\\n\\n\\n\\nwhat is probleam is this solution "
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "nums =\\n[1,2,3,1]\\nk =\\n3\\n45 / 54 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nmycode is\\n int i =0;\\n        int j = 1;\\n        while(i<nums.length && j<nums.length){\\n            if(nums[i]==nums[j]){\\n               int sum =  Math.abs(i-j);\\n                if(sum <= k)\\n                    return true;\\n                \\n            else\\n                return false;\\n                 \\n            \\n            }\\n            else{\\n                j++;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n}\\n\\nCanAny One tell me what is the problem in my code"
                    },
                    {
                        "username": "omajitsinhpatil",
                        "content": "please change the problem description\\n"
                    },
                    {
                        "username": "crazygirl_code",
                        "content": "nums = {2,2}, k = 3\\nthis testcase is clearly wrong and has got my code stuck\\nadmin pls do  something about it!"
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "what\\'s wrong with this test case?"
                    },
                    {
                        "username": "charkhaniakash",
                        "content": "Please anyone tell me y it showing TLE\\n\\n\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if nums[i]!=nums[j]:\\n                    j+=1\\n                else:\\n                    if(abs(i-j)<=k):\\n                        return True\\n        return False"
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "Using nested loop for traversing array of size n is not a Good option as TC will be O(n^2)\n Try to think of an approach in which you can find solution in a single traversal "
                    },
                    {
                        "username": "ss0363626",
                        "content": "Test cases are very bad ,\\n\\nnums = [ 1, 0, 1, 1] and k = 1\\n\\nhere j = 2 and  i = 0\\nso abs( i - j ) = 2     and  2<=1 , the output is False \\n\\nbut the expected output is True \\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "No,  it\\'s true because of j = 3  and i = 2!"
                    },
                    {
                        "username": "Abhishri_Dwivedi",
                        "content": "What is the last test case?\\n"
                    },
                    {
                        "username": "arunkrsingh111",
                        "content": "Simple Java HashMapSolution Sliding window\\n \\npublic boolean containsNearbyDuplicate(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap();\\n        int n = nums.length;\\n        int end = 0;\\n        while(end<n) {\\n            if(!map.containsKey(nums[end])) {\\n                map.put(nums[end], end);\\n                end++;\\n            } else {\\n                int window = Math.abs(map.get(nums[end]) - end);\\n                if(window<=k) {\\n                    return true;\\n                } else {\\n                    map.put(nums[end], end);\\n                    end++;\\n                }\\n            }\\n        }\\n        return false;\\n    }"
                    }
                ]
            },
            {
                "id": 1727805,
                "content": [
                    {
                        "username": "rimanshu007",
                        "content": "TLE occur ho raha hai, \\nanyone help me to improve this code........\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {   \\n        int start = 0, end = 0;                    \\n        while (start < nums.size()){\\n            for(int end=start+1;end<nums.size();end++){\\n                if(nums[start]==nums[end] && abs(start-end)<=k){    \\n                    return true;\\n                }\\n                // end++;\\n            }\\n            start++;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "bhaskarshashwath",
                        "content": "This is brute force. Try to optimize your solution using some approach like 2 pointer or somthing."
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "For large input nested loop for n data raise your time complexity O(N^2) so try to come up with a solution using single traversal."
                    },
                    {
                        "username": "rajat_171",
                        "content": "Can anybody help me to optimize this code please.... I \\'m new to coding.\\n `  bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        int i = 0;\\n        int e = nums.size()-1;\\n\\n        while(e > 0){\\n            while( i < e){\\n                if(nums[i] == nums[e] && abs(i-e) <= k ){\\n                    return true;\\n                }\\n                i++;\\n            }\\n            i = 0;\\n            e--;\\n        }\\n        return false;\\n    }`"
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n       HashSet<Integer> numbers = new HashSet<>();\\n\\n       for(int i=0 ; i<nums.length ; i++){\\n           if(numbers.contains(nums[i])){\\n               return true ;}\\n               numbers.add(nums[i]);\\n       }\\n       return false ;\\n    }\\n}\\n\\n\\n\\nwhat is probleam is this solution "
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "nums =\\n[1,2,3,1]\\nk =\\n3\\n45 / 54 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nmycode is\\n int i =0;\\n        int j = 1;\\n        while(i<nums.length && j<nums.length){\\n            if(nums[i]==nums[j]){\\n               int sum =  Math.abs(i-j);\\n                if(sum <= k)\\n                    return true;\\n                \\n            else\\n                return false;\\n                 \\n            \\n            }\\n            else{\\n                j++;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n}\\n\\nCanAny One tell me what is the problem in my code"
                    },
                    {
                        "username": "omajitsinhpatil",
                        "content": "please change the problem description\\n"
                    },
                    {
                        "username": "crazygirl_code",
                        "content": "nums = {2,2}, k = 3\\nthis testcase is clearly wrong and has got my code stuck\\nadmin pls do  something about it!"
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "what\\'s wrong with this test case?"
                    },
                    {
                        "username": "charkhaniakash",
                        "content": "Please anyone tell me y it showing TLE\\n\\n\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if nums[i]!=nums[j]:\\n                    j+=1\\n                else:\\n                    if(abs(i-j)<=k):\\n                        return True\\n        return False"
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "Using nested loop for traversing array of size n is not a Good option as TC will be O(n^2)\n Try to think of an approach in which you can find solution in a single traversal "
                    },
                    {
                        "username": "ss0363626",
                        "content": "Test cases are very bad ,\\n\\nnums = [ 1, 0, 1, 1] and k = 1\\n\\nhere j = 2 and  i = 0\\nso abs( i - j ) = 2     and  2<=1 , the output is False \\n\\nbut the expected output is True \\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "No,  it\\'s true because of j = 3  and i = 2!"
                    },
                    {
                        "username": "Abhishri_Dwivedi",
                        "content": "What is the last test case?\\n"
                    },
                    {
                        "username": "arunkrsingh111",
                        "content": "Simple Java HashMapSolution Sliding window\\n \\npublic boolean containsNearbyDuplicate(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap();\\n        int n = nums.length;\\n        int end = 0;\\n        while(end<n) {\\n            if(!map.containsKey(nums[end])) {\\n                map.put(nums[end], end);\\n                end++;\\n            } else {\\n                int window = Math.abs(map.get(nums[end]) - end);\\n                if(window<=k) {\\n                    return true;\\n                } else {\\n                    map.put(nums[end], end);\\n                    end++;\\n                }\\n            }\\n        }\\n        return false;\\n    }"
                    }
                ]
            },
            {
                "id": 1726497,
                "content": [
                    {
                        "username": "rimanshu007",
                        "content": "TLE occur ho raha hai, \\nanyone help me to improve this code........\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {   \\n        int start = 0, end = 0;                    \\n        while (start < nums.size()){\\n            for(int end=start+1;end<nums.size();end++){\\n                if(nums[start]==nums[end] && abs(start-end)<=k){    \\n                    return true;\\n                }\\n                // end++;\\n            }\\n            start++;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "bhaskarshashwath",
                        "content": "This is brute force. Try to optimize your solution using some approach like 2 pointer or somthing."
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "For large input nested loop for n data raise your time complexity O(N^2) so try to come up with a solution using single traversal."
                    },
                    {
                        "username": "rajat_171",
                        "content": "Can anybody help me to optimize this code please.... I \\'m new to coding.\\n `  bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        int i = 0;\\n        int e = nums.size()-1;\\n\\n        while(e > 0){\\n            while( i < e){\\n                if(nums[i] == nums[e] && abs(i-e) <= k ){\\n                    return true;\\n                }\\n                i++;\\n            }\\n            i = 0;\\n            e--;\\n        }\\n        return false;\\n    }`"
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n       HashSet<Integer> numbers = new HashSet<>();\\n\\n       for(int i=0 ; i<nums.length ; i++){\\n           if(numbers.contains(nums[i])){\\n               return true ;}\\n               numbers.add(nums[i]);\\n       }\\n       return false ;\\n    }\\n}\\n\\n\\n\\nwhat is probleam is this solution "
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "nums =\\n[1,2,3,1]\\nk =\\n3\\n45 / 54 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nmycode is\\n int i =0;\\n        int j = 1;\\n        while(i<nums.length && j<nums.length){\\n            if(nums[i]==nums[j]){\\n               int sum =  Math.abs(i-j);\\n                if(sum <= k)\\n                    return true;\\n                \\n            else\\n                return false;\\n                 \\n            \\n            }\\n            else{\\n                j++;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n}\\n\\nCanAny One tell me what is the problem in my code"
                    },
                    {
                        "username": "omajitsinhpatil",
                        "content": "please change the problem description\\n"
                    },
                    {
                        "username": "crazygirl_code",
                        "content": "nums = {2,2}, k = 3\\nthis testcase is clearly wrong and has got my code stuck\\nadmin pls do  something about it!"
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "what\\'s wrong with this test case?"
                    },
                    {
                        "username": "charkhaniakash",
                        "content": "Please anyone tell me y it showing TLE\\n\\n\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if nums[i]!=nums[j]:\\n                    j+=1\\n                else:\\n                    if(abs(i-j)<=k):\\n                        return True\\n        return False"
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "Using nested loop for traversing array of size n is not a Good option as TC will be O(n^2)\n Try to think of an approach in which you can find solution in a single traversal "
                    },
                    {
                        "username": "ss0363626",
                        "content": "Test cases are very bad ,\\n\\nnums = [ 1, 0, 1, 1] and k = 1\\n\\nhere j = 2 and  i = 0\\nso abs( i - j ) = 2     and  2<=1 , the output is False \\n\\nbut the expected output is True \\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "No,  it\\'s true because of j = 3  and i = 2!"
                    },
                    {
                        "username": "Abhishri_Dwivedi",
                        "content": "What is the last test case?\\n"
                    },
                    {
                        "username": "arunkrsingh111",
                        "content": "Simple Java HashMapSolution Sliding window\\n \\npublic boolean containsNearbyDuplicate(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap();\\n        int n = nums.length;\\n        int end = 0;\\n        while(end<n) {\\n            if(!map.containsKey(nums[end])) {\\n                map.put(nums[end], end);\\n                end++;\\n            } else {\\n                int window = Math.abs(map.get(nums[end]) - end);\\n                if(window<=k) {\\n                    return true;\\n                } else {\\n                    map.put(nums[end], end);\\n                    end++;\\n                }\\n            }\\n        }\\n        return false;\\n    }"
                    }
                ]
            },
            {
                "id": 1720468,
                "content": [
                    {
                        "username": "rimanshu007",
                        "content": "TLE occur ho raha hai, \\nanyone help me to improve this code........\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {   \\n        int start = 0, end = 0;                    \\n        while (start < nums.size()){\\n            for(int end=start+1;end<nums.size();end++){\\n                if(nums[start]==nums[end] && abs(start-end)<=k){    \\n                    return true;\\n                }\\n                // end++;\\n            }\\n            start++;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "bhaskarshashwath",
                        "content": "This is brute force. Try to optimize your solution using some approach like 2 pointer or somthing."
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "For large input nested loop for n data raise your time complexity O(N^2) so try to come up with a solution using single traversal."
                    },
                    {
                        "username": "rajat_171",
                        "content": "Can anybody help me to optimize this code please.... I \\'m new to coding.\\n `  bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        int i = 0;\\n        int e = nums.size()-1;\\n\\n        while(e > 0){\\n            while( i < e){\\n                if(nums[i] == nums[e] && abs(i-e) <= k ){\\n                    return true;\\n                }\\n                i++;\\n            }\\n            i = 0;\\n            e--;\\n        }\\n        return false;\\n    }`"
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n       HashSet<Integer> numbers = new HashSet<>();\\n\\n       for(int i=0 ; i<nums.length ; i++){\\n           if(numbers.contains(nums[i])){\\n               return true ;}\\n               numbers.add(nums[i]);\\n       }\\n       return false ;\\n    }\\n}\\n\\n\\n\\nwhat is probleam is this solution "
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "nums =\\n[1,2,3,1]\\nk =\\n3\\n45 / 54 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nmycode is\\n int i =0;\\n        int j = 1;\\n        while(i<nums.length && j<nums.length){\\n            if(nums[i]==nums[j]){\\n               int sum =  Math.abs(i-j);\\n                if(sum <= k)\\n                    return true;\\n                \\n            else\\n                return false;\\n                 \\n            \\n            }\\n            else{\\n                j++;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n}\\n\\nCanAny One tell me what is the problem in my code"
                    },
                    {
                        "username": "omajitsinhpatil",
                        "content": "please change the problem description\\n"
                    },
                    {
                        "username": "crazygirl_code",
                        "content": "nums = {2,2}, k = 3\\nthis testcase is clearly wrong and has got my code stuck\\nadmin pls do  something about it!"
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "what\\'s wrong with this test case?"
                    },
                    {
                        "username": "charkhaniakash",
                        "content": "Please anyone tell me y it showing TLE\\n\\n\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if nums[i]!=nums[j]:\\n                    j+=1\\n                else:\\n                    if(abs(i-j)<=k):\\n                        return True\\n        return False"
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "Using nested loop for traversing array of size n is not a Good option as TC will be O(n^2)\n Try to think of an approach in which you can find solution in a single traversal "
                    },
                    {
                        "username": "ss0363626",
                        "content": "Test cases are very bad ,\\n\\nnums = [ 1, 0, 1, 1] and k = 1\\n\\nhere j = 2 and  i = 0\\nso abs( i - j ) = 2     and  2<=1 , the output is False \\n\\nbut the expected output is True \\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "No,  it\\'s true because of j = 3  and i = 2!"
                    },
                    {
                        "username": "Abhishri_Dwivedi",
                        "content": "What is the last test case?\\n"
                    },
                    {
                        "username": "arunkrsingh111",
                        "content": "Simple Java HashMapSolution Sliding window\\n \\npublic boolean containsNearbyDuplicate(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap();\\n        int n = nums.length;\\n        int end = 0;\\n        while(end<n) {\\n            if(!map.containsKey(nums[end])) {\\n                map.put(nums[end], end);\\n                end++;\\n            } else {\\n                int window = Math.abs(map.get(nums[end]) - end);\\n                if(window<=k) {\\n                    return true;\\n                } else {\\n                    map.put(nums[end], end);\\n                    end++;\\n                }\\n            }\\n        }\\n        return false;\\n    }"
                    }
                ]
            },
            {
                "id": 1711842,
                "content": [
                    {
                        "username": "rimanshu007",
                        "content": "TLE occur ho raha hai, \\nanyone help me to improve this code........\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {   \\n        int start = 0, end = 0;                    \\n        while (start < nums.size()){\\n            for(int end=start+1;end<nums.size();end++){\\n                if(nums[start]==nums[end] && abs(start-end)<=k){    \\n                    return true;\\n                }\\n                // end++;\\n            }\\n            start++;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "bhaskarshashwath",
                        "content": "This is brute force. Try to optimize your solution using some approach like 2 pointer or somthing."
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "For large input nested loop for n data raise your time complexity O(N^2) so try to come up with a solution using single traversal."
                    },
                    {
                        "username": "rajat_171",
                        "content": "Can anybody help me to optimize this code please.... I \\'m new to coding.\\n `  bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        int i = 0;\\n        int e = nums.size()-1;\\n\\n        while(e > 0){\\n            while( i < e){\\n                if(nums[i] == nums[e] && abs(i-e) <= k ){\\n                    return true;\\n                }\\n                i++;\\n            }\\n            i = 0;\\n            e--;\\n        }\\n        return false;\\n    }`"
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n       HashSet<Integer> numbers = new HashSet<>();\\n\\n       for(int i=0 ; i<nums.length ; i++){\\n           if(numbers.contains(nums[i])){\\n               return true ;}\\n               numbers.add(nums[i]);\\n       }\\n       return false ;\\n    }\\n}\\n\\n\\n\\nwhat is probleam is this solution "
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "nums =\\n[1,2,3,1]\\nk =\\n3\\n45 / 54 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nmycode is\\n int i =0;\\n        int j = 1;\\n        while(i<nums.length && j<nums.length){\\n            if(nums[i]==nums[j]){\\n               int sum =  Math.abs(i-j);\\n                if(sum <= k)\\n                    return true;\\n                \\n            else\\n                return false;\\n                 \\n            \\n            }\\n            else{\\n                j++;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n}\\n\\nCanAny One tell me what is the problem in my code"
                    },
                    {
                        "username": "omajitsinhpatil",
                        "content": "please change the problem description\\n"
                    },
                    {
                        "username": "crazygirl_code",
                        "content": "nums = {2,2}, k = 3\\nthis testcase is clearly wrong and has got my code stuck\\nadmin pls do  something about it!"
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "what\\'s wrong with this test case?"
                    },
                    {
                        "username": "charkhaniakash",
                        "content": "Please anyone tell me y it showing TLE\\n\\n\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if nums[i]!=nums[j]:\\n                    j+=1\\n                else:\\n                    if(abs(i-j)<=k):\\n                        return True\\n        return False"
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "Using nested loop for traversing array of size n is not a Good option as TC will be O(n^2)\n Try to think of an approach in which you can find solution in a single traversal "
                    },
                    {
                        "username": "ss0363626",
                        "content": "Test cases are very bad ,\\n\\nnums = [ 1, 0, 1, 1] and k = 1\\n\\nhere j = 2 and  i = 0\\nso abs( i - j ) = 2     and  2<=1 , the output is False \\n\\nbut the expected output is True \\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "No,  it\\'s true because of j = 3  and i = 2!"
                    },
                    {
                        "username": "Abhishri_Dwivedi",
                        "content": "What is the last test case?\\n"
                    },
                    {
                        "username": "arunkrsingh111",
                        "content": "Simple Java HashMapSolution Sliding window\\n \\npublic boolean containsNearbyDuplicate(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap();\\n        int n = nums.length;\\n        int end = 0;\\n        while(end<n) {\\n            if(!map.containsKey(nums[end])) {\\n                map.put(nums[end], end);\\n                end++;\\n            } else {\\n                int window = Math.abs(map.get(nums[end]) - end);\\n                if(window<=k) {\\n                    return true;\\n                } else {\\n                    map.put(nums[end], end);\\n                    end++;\\n                }\\n            }\\n        }\\n        return false;\\n    }"
                    }
                ]
            },
            {
                "id": 1711391,
                "content": [
                    {
                        "username": "rimanshu007",
                        "content": "TLE occur ho raha hai, \\nanyone help me to improve this code........\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {   \\n        int start = 0, end = 0;                    \\n        while (start < nums.size()){\\n            for(int end=start+1;end<nums.size();end++){\\n                if(nums[start]==nums[end] && abs(start-end)<=k){    \\n                    return true;\\n                }\\n                // end++;\\n            }\\n            start++;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "bhaskarshashwath",
                        "content": "This is brute force. Try to optimize your solution using some approach like 2 pointer or somthing."
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "For large input nested loop for n data raise your time complexity O(N^2) so try to come up with a solution using single traversal."
                    },
                    {
                        "username": "rajat_171",
                        "content": "Can anybody help me to optimize this code please.... I \\'m new to coding.\\n `  bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        int i = 0;\\n        int e = nums.size()-1;\\n\\n        while(e > 0){\\n            while( i < e){\\n                if(nums[i] == nums[e] && abs(i-e) <= k ){\\n                    return true;\\n                }\\n                i++;\\n            }\\n            i = 0;\\n            e--;\\n        }\\n        return false;\\n    }`"
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n       HashSet<Integer> numbers = new HashSet<>();\\n\\n       for(int i=0 ; i<nums.length ; i++){\\n           if(numbers.contains(nums[i])){\\n               return true ;}\\n               numbers.add(nums[i]);\\n       }\\n       return false ;\\n    }\\n}\\n\\n\\n\\nwhat is probleam is this solution "
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "nums =\\n[1,2,3,1]\\nk =\\n3\\n45 / 54 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nmycode is\\n int i =0;\\n        int j = 1;\\n        while(i<nums.length && j<nums.length){\\n            if(nums[i]==nums[j]){\\n               int sum =  Math.abs(i-j);\\n                if(sum <= k)\\n                    return true;\\n                \\n            else\\n                return false;\\n                 \\n            \\n            }\\n            else{\\n                j++;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n}\\n\\nCanAny One tell me what is the problem in my code"
                    },
                    {
                        "username": "omajitsinhpatil",
                        "content": "please change the problem description\\n"
                    },
                    {
                        "username": "crazygirl_code",
                        "content": "nums = {2,2}, k = 3\\nthis testcase is clearly wrong and has got my code stuck\\nadmin pls do  something about it!"
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "what\\'s wrong with this test case?"
                    },
                    {
                        "username": "charkhaniakash",
                        "content": "Please anyone tell me y it showing TLE\\n\\n\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if nums[i]!=nums[j]:\\n                    j+=1\\n                else:\\n                    if(abs(i-j)<=k):\\n                        return True\\n        return False"
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "Using nested loop for traversing array of size n is not a Good option as TC will be O(n^2)\n Try to think of an approach in which you can find solution in a single traversal "
                    },
                    {
                        "username": "ss0363626",
                        "content": "Test cases are very bad ,\\n\\nnums = [ 1, 0, 1, 1] and k = 1\\n\\nhere j = 2 and  i = 0\\nso abs( i - j ) = 2     and  2<=1 , the output is False \\n\\nbut the expected output is True \\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "No,  it\\'s true because of j = 3  and i = 2!"
                    },
                    {
                        "username": "Abhishri_Dwivedi",
                        "content": "What is the last test case?\\n"
                    },
                    {
                        "username": "arunkrsingh111",
                        "content": "Simple Java HashMapSolution Sliding window\\n \\npublic boolean containsNearbyDuplicate(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap();\\n        int n = nums.length;\\n        int end = 0;\\n        while(end<n) {\\n            if(!map.containsKey(nums[end])) {\\n                map.put(nums[end], end);\\n                end++;\\n            } else {\\n                int window = Math.abs(map.get(nums[end]) - end);\\n                if(window<=k) {\\n                    return true;\\n                } else {\\n                    map.put(nums[end], end);\\n                    end++;\\n                }\\n            }\\n        }\\n        return false;\\n    }"
                    }
                ]
            },
            {
                "id": 1707733,
                "content": [
                    {
                        "username": "rimanshu007",
                        "content": "TLE occur ho raha hai, \\nanyone help me to improve this code........\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {   \\n        int start = 0, end = 0;                    \\n        while (start < nums.size()){\\n            for(int end=start+1;end<nums.size();end++){\\n                if(nums[start]==nums[end] && abs(start-end)<=k){    \\n                    return true;\\n                }\\n                // end++;\\n            }\\n            start++;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "bhaskarshashwath",
                        "content": "This is brute force. Try to optimize your solution using some approach like 2 pointer or somthing."
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "For large input nested loop for n data raise your time complexity O(N^2) so try to come up with a solution using single traversal."
                    },
                    {
                        "username": "rajat_171",
                        "content": "Can anybody help me to optimize this code please.... I \\'m new to coding.\\n `  bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        int i = 0;\\n        int e = nums.size()-1;\\n\\n        while(e > 0){\\n            while( i < e){\\n                if(nums[i] == nums[e] && abs(i-e) <= k ){\\n                    return true;\\n                }\\n                i++;\\n            }\\n            i = 0;\\n            e--;\\n        }\\n        return false;\\n    }`"
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n       HashSet<Integer> numbers = new HashSet<>();\\n\\n       for(int i=0 ; i<nums.length ; i++){\\n           if(numbers.contains(nums[i])){\\n               return true ;}\\n               numbers.add(nums[i]);\\n       }\\n       return false ;\\n    }\\n}\\n\\n\\n\\nwhat is probleam is this solution "
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "nums =\\n[1,2,3,1]\\nk =\\n3\\n45 / 54 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nmycode is\\n int i =0;\\n        int j = 1;\\n        while(i<nums.length && j<nums.length){\\n            if(nums[i]==nums[j]){\\n               int sum =  Math.abs(i-j);\\n                if(sum <= k)\\n                    return true;\\n                \\n            else\\n                return false;\\n                 \\n            \\n            }\\n            else{\\n                j++;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n}\\n\\nCanAny One tell me what is the problem in my code"
                    },
                    {
                        "username": "omajitsinhpatil",
                        "content": "please change the problem description\\n"
                    },
                    {
                        "username": "crazygirl_code",
                        "content": "nums = {2,2}, k = 3\\nthis testcase is clearly wrong and has got my code stuck\\nadmin pls do  something about it!"
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "what\\'s wrong with this test case?"
                    },
                    {
                        "username": "charkhaniakash",
                        "content": "Please anyone tell me y it showing TLE\\n\\n\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if nums[i]!=nums[j]:\\n                    j+=1\\n                else:\\n                    if(abs(i-j)<=k):\\n                        return True\\n        return False"
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "Using nested loop for traversing array of size n is not a Good option as TC will be O(n^2)\n Try to think of an approach in which you can find solution in a single traversal "
                    },
                    {
                        "username": "ss0363626",
                        "content": "Test cases are very bad ,\\n\\nnums = [ 1, 0, 1, 1] and k = 1\\n\\nhere j = 2 and  i = 0\\nso abs( i - j ) = 2     and  2<=1 , the output is False \\n\\nbut the expected output is True \\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "No,  it\\'s true because of j = 3  and i = 2!"
                    },
                    {
                        "username": "Abhishri_Dwivedi",
                        "content": "What is the last test case?\\n"
                    },
                    {
                        "username": "arunkrsingh111",
                        "content": "Simple Java HashMapSolution Sliding window\\n \\npublic boolean containsNearbyDuplicate(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap();\\n        int n = nums.length;\\n        int end = 0;\\n        while(end<n) {\\n            if(!map.containsKey(nums[end])) {\\n                map.put(nums[end], end);\\n                end++;\\n            } else {\\n                int window = Math.abs(map.get(nums[end]) - end);\\n                if(window<=k) {\\n                    return true;\\n                } else {\\n                    map.put(nums[end], end);\\n                    end++;\\n                }\\n            }\\n        }\\n        return false;\\n    }"
                    }
                ]
            },
            {
                "id": 1705306,
                "content": [
                    {
                        "username": "rimanshu007",
                        "content": "TLE occur ho raha hai, \\nanyone help me to improve this code........\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {   \\n        int start = 0, end = 0;                    \\n        while (start < nums.size()){\\n            for(int end=start+1;end<nums.size();end++){\\n                if(nums[start]==nums[end] && abs(start-end)<=k){    \\n                    return true;\\n                }\\n                // end++;\\n            }\\n            start++;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "bhaskarshashwath",
                        "content": "This is brute force. Try to optimize your solution using some approach like 2 pointer or somthing."
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "For large input nested loop for n data raise your time complexity O(N^2) so try to come up with a solution using single traversal."
                    },
                    {
                        "username": "rajat_171",
                        "content": "Can anybody help me to optimize this code please.... I \\'m new to coding.\\n `  bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        int i = 0;\\n        int e = nums.size()-1;\\n\\n        while(e > 0){\\n            while( i < e){\\n                if(nums[i] == nums[e] && abs(i-e) <= k ){\\n                    return true;\\n                }\\n                i++;\\n            }\\n            i = 0;\\n            e--;\\n        }\\n        return false;\\n    }`"
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n       HashSet<Integer> numbers = new HashSet<>();\\n\\n       for(int i=0 ; i<nums.length ; i++){\\n           if(numbers.contains(nums[i])){\\n               return true ;}\\n               numbers.add(nums[i]);\\n       }\\n       return false ;\\n    }\\n}\\n\\n\\n\\nwhat is probleam is this solution "
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "nums =\\n[1,2,3,1]\\nk =\\n3\\n45 / 54 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nmycode is\\n int i =0;\\n        int j = 1;\\n        while(i<nums.length && j<nums.length){\\n            if(nums[i]==nums[j]){\\n               int sum =  Math.abs(i-j);\\n                if(sum <= k)\\n                    return true;\\n                \\n            else\\n                return false;\\n                 \\n            \\n            }\\n            else{\\n                j++;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n}\\n\\nCanAny One tell me what is the problem in my code"
                    },
                    {
                        "username": "omajitsinhpatil",
                        "content": "please change the problem description\\n"
                    },
                    {
                        "username": "crazygirl_code",
                        "content": "nums = {2,2}, k = 3\\nthis testcase is clearly wrong and has got my code stuck\\nadmin pls do  something about it!"
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "what\\'s wrong with this test case?"
                    },
                    {
                        "username": "charkhaniakash",
                        "content": "Please anyone tell me y it showing TLE\\n\\n\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if nums[i]!=nums[j]:\\n                    j+=1\\n                else:\\n                    if(abs(i-j)<=k):\\n                        return True\\n        return False"
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "Using nested loop for traversing array of size n is not a Good option as TC will be O(n^2)\n Try to think of an approach in which you can find solution in a single traversal "
                    },
                    {
                        "username": "ss0363626",
                        "content": "Test cases are very bad ,\\n\\nnums = [ 1, 0, 1, 1] and k = 1\\n\\nhere j = 2 and  i = 0\\nso abs( i - j ) = 2     and  2<=1 , the output is False \\n\\nbut the expected output is True \\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "No,  it\\'s true because of j = 3  and i = 2!"
                    },
                    {
                        "username": "Abhishri_Dwivedi",
                        "content": "What is the last test case?\\n"
                    },
                    {
                        "username": "arunkrsingh111",
                        "content": "Simple Java HashMapSolution Sliding window\\n \\npublic boolean containsNearbyDuplicate(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap();\\n        int n = nums.length;\\n        int end = 0;\\n        while(end<n) {\\n            if(!map.containsKey(nums[end])) {\\n                map.put(nums[end], end);\\n                end++;\\n            } else {\\n                int window = Math.abs(map.get(nums[end]) - end);\\n                if(window<=k) {\\n                    return true;\\n                } else {\\n                    map.put(nums[end], end);\\n                    end++;\\n                }\\n            }\\n        }\\n        return false;\\n    }"
                    }
                ]
            },
            {
                "id": 1695779,
                "content": [
                    {
                        "username": "rimanshu007",
                        "content": "TLE occur ho raha hai, \\nanyone help me to improve this code........\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {   \\n        int start = 0, end = 0;                    \\n        while (start < nums.size()){\\n            for(int end=start+1;end<nums.size();end++){\\n                if(nums[start]==nums[end] && abs(start-end)<=k){    \\n                    return true;\\n                }\\n                // end++;\\n            }\\n            start++;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "bhaskarshashwath",
                        "content": "This is brute force. Try to optimize your solution using some approach like 2 pointer or somthing."
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "For large input nested loop for n data raise your time complexity O(N^2) so try to come up with a solution using single traversal."
                    },
                    {
                        "username": "rajat_171",
                        "content": "Can anybody help me to optimize this code please.... I \\'m new to coding.\\n `  bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        int i = 0;\\n        int e = nums.size()-1;\\n\\n        while(e > 0){\\n            while( i < e){\\n                if(nums[i] == nums[e] && abs(i-e) <= k ){\\n                    return true;\\n                }\\n                i++;\\n            }\\n            i = 0;\\n            e--;\\n        }\\n        return false;\\n    }`"
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n       HashSet<Integer> numbers = new HashSet<>();\\n\\n       for(int i=0 ; i<nums.length ; i++){\\n           if(numbers.contains(nums[i])){\\n               return true ;}\\n               numbers.add(nums[i]);\\n       }\\n       return false ;\\n    }\\n}\\n\\n\\n\\nwhat is probleam is this solution "
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "nums =\\n[1,2,3,1]\\nk =\\n3\\n45 / 54 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nmycode is\\n int i =0;\\n        int j = 1;\\n        while(i<nums.length && j<nums.length){\\n            if(nums[i]==nums[j]){\\n               int sum =  Math.abs(i-j);\\n                if(sum <= k)\\n                    return true;\\n                \\n            else\\n                return false;\\n                 \\n            \\n            }\\n            else{\\n                j++;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n}\\n\\nCanAny One tell me what is the problem in my code"
                    },
                    {
                        "username": "omajitsinhpatil",
                        "content": "please change the problem description\\n"
                    },
                    {
                        "username": "crazygirl_code",
                        "content": "nums = {2,2}, k = 3\\nthis testcase is clearly wrong and has got my code stuck\\nadmin pls do  something about it!"
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "what\\'s wrong with this test case?"
                    },
                    {
                        "username": "charkhaniakash",
                        "content": "Please anyone tell me y it showing TLE\\n\\n\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if nums[i]!=nums[j]:\\n                    j+=1\\n                else:\\n                    if(abs(i-j)<=k):\\n                        return True\\n        return False"
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "Using nested loop for traversing array of size n is not a Good option as TC will be O(n^2)\n Try to think of an approach in which you can find solution in a single traversal "
                    },
                    {
                        "username": "ss0363626",
                        "content": "Test cases are very bad ,\\n\\nnums = [ 1, 0, 1, 1] and k = 1\\n\\nhere j = 2 and  i = 0\\nso abs( i - j ) = 2     and  2<=1 , the output is False \\n\\nbut the expected output is True \\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "No,  it\\'s true because of j = 3  and i = 2!"
                    },
                    {
                        "username": "Abhishri_Dwivedi",
                        "content": "What is the last test case?\\n"
                    },
                    {
                        "username": "arunkrsingh111",
                        "content": "Simple Java HashMapSolution Sliding window\\n \\npublic boolean containsNearbyDuplicate(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap();\\n        int n = nums.length;\\n        int end = 0;\\n        while(end<n) {\\n            if(!map.containsKey(nums[end])) {\\n                map.put(nums[end], end);\\n                end++;\\n            } else {\\n                int window = Math.abs(map.get(nums[end]) - end);\\n                if(window<=k) {\\n                    return true;\\n                } else {\\n                    map.put(nums[end], end);\\n                    end++;\\n                }\\n            }\\n        }\\n        return false;\\n    }"
                    }
                ]
            },
            {
                "id": 1680393,
                "content": [
                    {
                        "username": "rimanshu007",
                        "content": "TLE occur ho raha hai, \\nanyone help me to improve this code........\\nclass Solution {\\npublic:\\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {   \\n        int start = 0, end = 0;                    \\n        while (start < nums.size()){\\n            for(int end=start+1;end<nums.size();end++){\\n                if(nums[start]==nums[end] && abs(start-end)<=k){    \\n                    return true;\\n                }\\n                // end++;\\n            }\\n            start++;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "bhaskarshashwath",
                        "content": "This is brute force. Try to optimize your solution using some approach like 2 pointer or somthing."
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "For large input nested loop for n data raise your time complexity O(N^2) so try to come up with a solution using single traversal."
                    },
                    {
                        "username": "rajat_171",
                        "content": "Can anybody help me to optimize this code please.... I \\'m new to coding.\\n `  bool containsNearbyDuplicate(vector<int>& nums, int k) {\\n        int i = 0;\\n        int e = nums.size()-1;\\n\\n        while(e > 0){\\n            while( i < e){\\n                if(nums[i] == nums[e] && abs(i-e) <= k ){\\n                    return true;\\n                }\\n                i++;\\n            }\\n            i = 0;\\n            e--;\\n        }\\n        return false;\\n    }`"
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n       HashSet<Integer> numbers = new HashSet<>();\\n\\n       for(int i=0 ; i<nums.length ; i++){\\n           if(numbers.contains(nums[i])){\\n               return true ;}\\n               numbers.add(nums[i]);\\n       }\\n       return false ;\\n    }\\n}\\n\\n\\n\\nwhat is probleam is this solution "
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "nums =\\n[1,2,3,1]\\nk =\\n3\\n45 / 54 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nmycode is\\n int i =0;\\n        int j = 1;\\n        while(i<nums.length && j<nums.length){\\n            if(nums[i]==nums[j]){\\n               int sum =  Math.abs(i-j);\\n                if(sum <= k)\\n                    return true;\\n                \\n            else\\n                return false;\\n                 \\n            \\n            }\\n            else{\\n                j++;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n}\\n\\nCanAny One tell me what is the problem in my code"
                    },
                    {
                        "username": "omajitsinhpatil",
                        "content": "please change the problem description\\n"
                    },
                    {
                        "username": "crazygirl_code",
                        "content": "nums = {2,2}, k = 3\\nthis testcase is clearly wrong and has got my code stuck\\nadmin pls do  something about it!"
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "what\\'s wrong with this test case?"
                    },
                    {
                        "username": "charkhaniakash",
                        "content": "Please anyone tell me y it showing TLE\\n\\n\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if nums[i]!=nums[j]:\\n                    j+=1\\n                else:\\n                    if(abs(i-j)<=k):\\n                        return True\\n        return False"
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "Using nested loop for traversing array of size n is not a Good option as TC will be O(n^2)\n Try to think of an approach in which you can find solution in a single traversal "
                    },
                    {
                        "username": "ss0363626",
                        "content": "Test cases are very bad ,\\n\\nnums = [ 1, 0, 1, 1] and k = 1\\n\\nhere j = 2 and  i = 0\\nso abs( i - j ) = 2     and  2<=1 , the output is False \\n\\nbut the expected output is True \\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "No,  it\\'s true because of j = 3  and i = 2!"
                    },
                    {
                        "username": "Abhishri_Dwivedi",
                        "content": "What is the last test case?\\n"
                    },
                    {
                        "username": "arunkrsingh111",
                        "content": "Simple Java HashMapSolution Sliding window\\n \\npublic boolean containsNearbyDuplicate(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap();\\n        int n = nums.length;\\n        int end = 0;\\n        while(end<n) {\\n            if(!map.containsKey(nums[end])) {\\n                map.put(nums[end], end);\\n                end++;\\n            } else {\\n                int window = Math.abs(map.get(nums[end]) - end);\\n                if(window<=k) {\\n                    return true;\\n                } else {\\n                    map.put(nums[end], end);\\n                    end++;\\n                }\\n            }\\n        }\\n        return false;\\n    }"
                    }
                ]
            },
            {
                "id": 1672731,
                "content": [
                    {
                        "username": "noskillzjusthackz",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i]) && Math.abs(map.get(nums[i]) - i) <= k) {\\n                return true;\\n            }\\n            map.put(nums[i], i);\\n\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "calm27",
                        "content": "don\\'t post solutions here. it is `Discussion` section. "
                    },
                    {
                        "username": "cindyzh2011",
                        "content": "python 3\\n"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "why none is checking nums[i] == nums[j] explicitly in any of these solutions ??\\n\\nSomeone pls explain.."
                    },
                    {
                        "username": "calm27",
                        "content": "Perhaps, to check each `i` with each `j` in window `k`, you need to write some kind of brute-force solution. There are planty of data structure that may help us to understand if there are duplicates or not, without actually direct checking them.  "
                    },
                    {
                        "username": "ashwiniranjansingh",
                        "content": "int len=nums.length;\n      for(int i=0;i<nums.length-k+1;i++){\n         \n          for(int j=(k>(len-1)?0:i);j<nums.length;j++){\n             \n              if((nums[i]==nums[j])&&(Math.abs(j-i)<=k)&&(i!=j))\n              \n              return true;\n              \n          }\n      }  \n      return false;\n\nwhat is the problem"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The problem is you need something faster than nested loops buddy. Think about using Maps (HashSet or HashMap) etc..."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The question itself is a bit tricky but understandable and can be considered easy BUT when I submit the code it says \"Time Limit Exceeded\" which does not make sense, tried it on my Eclipse IDE and it works perfectly, less than 0.1s to execute more than 6 cases including an array which length is around 7000.\\n\\nThis question should be reviewed by admins ASAP. I even copied the test that the system is using when I click on submit to create a case here, when I run the code it says \"Invalid Test\" lol!!!"
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "One of the test case length is 54500 which good to test the time limit."
                    },
                    {
                        "username": "malegkin",
                        "content": "BE CAREFUL!!! LESS OR EQUAL!!\\nabs(i - j) <= k "
                    },
                    {
                        "username": "AndyDope",
                        "content": "Hey guys if the test case has nums=[1, 1, 3] and k=0\\nWhat is expected? True or False"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "i - j <= k\\n\\nif k = 0 i don\\'t think you should execute any code, not sure but logically with the constraint it means that i = j in order to get a result i - j = 0 which leads to comparing a value with itself inside the array!"
                    },
                    {
                        "username": "samuelraj349",
                        "content": "Input: nums = [1,0,1,1], k = 1\\nOutput: true \\nhow it is true?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "nums[2] == nums[3] and abs(2-3)<=1, so output is True."
                    },
                    {
                        "username": "adiya",
                        "content": "[99,99] k=2 why is it true?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "nums[0] == nums[1] and abs(0-1)<=2, so output is True."
                    },
                    {
                        "username": "Devilcoder2311",
                        "content": "[1,2,3,4,5,6,7,8,9,9]\\nk=3\\nexpected=true\\noutput=false"
                    },
                    {
                        "username": "sparklingness",
                        "content": "nums[8]==nums[9] and abs(8-9)<=3, so expected output is True."
                    }
                ]
            },
            {
                "id": 1672661,
                "content": [
                    {
                        "username": "noskillzjusthackz",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i]) && Math.abs(map.get(nums[i]) - i) <= k) {\\n                return true;\\n            }\\n            map.put(nums[i], i);\\n\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "calm27",
                        "content": "don\\'t post solutions here. it is `Discussion` section. "
                    },
                    {
                        "username": "cindyzh2011",
                        "content": "python 3\\n"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "why none is checking nums[i] == nums[j] explicitly in any of these solutions ??\\n\\nSomeone pls explain.."
                    },
                    {
                        "username": "calm27",
                        "content": "Perhaps, to check each `i` with each `j` in window `k`, you need to write some kind of brute-force solution. There are planty of data structure that may help us to understand if there are duplicates or not, without actually direct checking them.  "
                    },
                    {
                        "username": "ashwiniranjansingh",
                        "content": "int len=nums.length;\n      for(int i=0;i<nums.length-k+1;i++){\n         \n          for(int j=(k>(len-1)?0:i);j<nums.length;j++){\n             \n              if((nums[i]==nums[j])&&(Math.abs(j-i)<=k)&&(i!=j))\n              \n              return true;\n              \n          }\n      }  \n      return false;\n\nwhat is the problem"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The problem is you need something faster than nested loops buddy. Think about using Maps (HashSet or HashMap) etc..."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The question itself is a bit tricky but understandable and can be considered easy BUT when I submit the code it says \"Time Limit Exceeded\" which does not make sense, tried it on my Eclipse IDE and it works perfectly, less than 0.1s to execute more than 6 cases including an array which length is around 7000.\\n\\nThis question should be reviewed by admins ASAP. I even copied the test that the system is using when I click on submit to create a case here, when I run the code it says \"Invalid Test\" lol!!!"
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "One of the test case length is 54500 which good to test the time limit."
                    },
                    {
                        "username": "malegkin",
                        "content": "BE CAREFUL!!! LESS OR EQUAL!!\\nabs(i - j) <= k "
                    },
                    {
                        "username": "AndyDope",
                        "content": "Hey guys if the test case has nums=[1, 1, 3] and k=0\\nWhat is expected? True or False"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "i - j <= k\\n\\nif k = 0 i don\\'t think you should execute any code, not sure but logically with the constraint it means that i = j in order to get a result i - j = 0 which leads to comparing a value with itself inside the array!"
                    },
                    {
                        "username": "samuelraj349",
                        "content": "Input: nums = [1,0,1,1], k = 1\\nOutput: true \\nhow it is true?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "nums[2] == nums[3] and abs(2-3)<=1, so output is True."
                    },
                    {
                        "username": "adiya",
                        "content": "[99,99] k=2 why is it true?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "nums[0] == nums[1] and abs(0-1)<=2, so output is True."
                    },
                    {
                        "username": "Devilcoder2311",
                        "content": "[1,2,3,4,5,6,7,8,9,9]\\nk=3\\nexpected=true\\noutput=false"
                    },
                    {
                        "username": "sparklingness",
                        "content": "nums[8]==nums[9] and abs(8-9)<=3, so expected output is True."
                    }
                ]
            },
            {
                "id": 1671334,
                "content": [
                    {
                        "username": "noskillzjusthackz",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i]) && Math.abs(map.get(nums[i]) - i) <= k) {\\n                return true;\\n            }\\n            map.put(nums[i], i);\\n\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "calm27",
                        "content": "don\\'t post solutions here. it is `Discussion` section. "
                    },
                    {
                        "username": "cindyzh2011",
                        "content": "python 3\\n"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "why none is checking nums[i] == nums[j] explicitly in any of these solutions ??\\n\\nSomeone pls explain.."
                    },
                    {
                        "username": "calm27",
                        "content": "Perhaps, to check each `i` with each `j` in window `k`, you need to write some kind of brute-force solution. There are planty of data structure that may help us to understand if there are duplicates or not, without actually direct checking them.  "
                    },
                    {
                        "username": "ashwiniranjansingh",
                        "content": "int len=nums.length;\n      for(int i=0;i<nums.length-k+1;i++){\n         \n          for(int j=(k>(len-1)?0:i);j<nums.length;j++){\n             \n              if((nums[i]==nums[j])&&(Math.abs(j-i)<=k)&&(i!=j))\n              \n              return true;\n              \n          }\n      }  \n      return false;\n\nwhat is the problem"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The problem is you need something faster than nested loops buddy. Think about using Maps (HashSet or HashMap) etc..."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The question itself is a bit tricky but understandable and can be considered easy BUT when I submit the code it says \"Time Limit Exceeded\" which does not make sense, tried it on my Eclipse IDE and it works perfectly, less than 0.1s to execute more than 6 cases including an array which length is around 7000.\\n\\nThis question should be reviewed by admins ASAP. I even copied the test that the system is using when I click on submit to create a case here, when I run the code it says \"Invalid Test\" lol!!!"
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "One of the test case length is 54500 which good to test the time limit."
                    },
                    {
                        "username": "malegkin",
                        "content": "BE CAREFUL!!! LESS OR EQUAL!!\\nabs(i - j) <= k "
                    },
                    {
                        "username": "AndyDope",
                        "content": "Hey guys if the test case has nums=[1, 1, 3] and k=0\\nWhat is expected? True or False"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "i - j <= k\\n\\nif k = 0 i don\\'t think you should execute any code, not sure but logically with the constraint it means that i = j in order to get a result i - j = 0 which leads to comparing a value with itself inside the array!"
                    },
                    {
                        "username": "samuelraj349",
                        "content": "Input: nums = [1,0,1,1], k = 1\\nOutput: true \\nhow it is true?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "nums[2] == nums[3] and abs(2-3)<=1, so output is True."
                    },
                    {
                        "username": "adiya",
                        "content": "[99,99] k=2 why is it true?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "nums[0] == nums[1] and abs(0-1)<=2, so output is True."
                    },
                    {
                        "username": "Devilcoder2311",
                        "content": "[1,2,3,4,5,6,7,8,9,9]\\nk=3\\nexpected=true\\noutput=false"
                    },
                    {
                        "username": "sparklingness",
                        "content": "nums[8]==nums[9] and abs(8-9)<=3, so expected output is True."
                    }
                ]
            },
            {
                "id": 1653643,
                "content": [
                    {
                        "username": "noskillzjusthackz",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i]) && Math.abs(map.get(nums[i]) - i) <= k) {\\n                return true;\\n            }\\n            map.put(nums[i], i);\\n\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "calm27",
                        "content": "don\\'t post solutions here. it is `Discussion` section. "
                    },
                    {
                        "username": "cindyzh2011",
                        "content": "python 3\\n"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "why none is checking nums[i] == nums[j] explicitly in any of these solutions ??\\n\\nSomeone pls explain.."
                    },
                    {
                        "username": "calm27",
                        "content": "Perhaps, to check each `i` with each `j` in window `k`, you need to write some kind of brute-force solution. There are planty of data structure that may help us to understand if there are duplicates or not, without actually direct checking them.  "
                    },
                    {
                        "username": "ashwiniranjansingh",
                        "content": "int len=nums.length;\n      for(int i=0;i<nums.length-k+1;i++){\n         \n          for(int j=(k>(len-1)?0:i);j<nums.length;j++){\n             \n              if((nums[i]==nums[j])&&(Math.abs(j-i)<=k)&&(i!=j))\n              \n              return true;\n              \n          }\n      }  \n      return false;\n\nwhat is the problem"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The problem is you need something faster than nested loops buddy. Think about using Maps (HashSet or HashMap) etc..."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The question itself is a bit tricky but understandable and can be considered easy BUT when I submit the code it says \"Time Limit Exceeded\" which does not make sense, tried it on my Eclipse IDE and it works perfectly, less than 0.1s to execute more than 6 cases including an array which length is around 7000.\\n\\nThis question should be reviewed by admins ASAP. I even copied the test that the system is using when I click on submit to create a case here, when I run the code it says \"Invalid Test\" lol!!!"
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "One of the test case length is 54500 which good to test the time limit."
                    },
                    {
                        "username": "malegkin",
                        "content": "BE CAREFUL!!! LESS OR EQUAL!!\\nabs(i - j) <= k "
                    },
                    {
                        "username": "AndyDope",
                        "content": "Hey guys if the test case has nums=[1, 1, 3] and k=0\\nWhat is expected? True or False"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "i - j <= k\\n\\nif k = 0 i don\\'t think you should execute any code, not sure but logically with the constraint it means that i = j in order to get a result i - j = 0 which leads to comparing a value with itself inside the array!"
                    },
                    {
                        "username": "samuelraj349",
                        "content": "Input: nums = [1,0,1,1], k = 1\\nOutput: true \\nhow it is true?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "nums[2] == nums[3] and abs(2-3)<=1, so output is True."
                    },
                    {
                        "username": "adiya",
                        "content": "[99,99] k=2 why is it true?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "nums[0] == nums[1] and abs(0-1)<=2, so output is True."
                    },
                    {
                        "username": "Devilcoder2311",
                        "content": "[1,2,3,4,5,6,7,8,9,9]\\nk=3\\nexpected=true\\noutput=false"
                    },
                    {
                        "username": "sparklingness",
                        "content": "nums[8]==nums[9] and abs(8-9)<=3, so expected output is True."
                    }
                ]
            },
            {
                "id": 1653539,
                "content": [
                    {
                        "username": "noskillzjusthackz",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i]) && Math.abs(map.get(nums[i]) - i) <= k) {\\n                return true;\\n            }\\n            map.put(nums[i], i);\\n\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "calm27",
                        "content": "don\\'t post solutions here. it is `Discussion` section. "
                    },
                    {
                        "username": "cindyzh2011",
                        "content": "python 3\\n"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "why none is checking nums[i] == nums[j] explicitly in any of these solutions ??\\n\\nSomeone pls explain.."
                    },
                    {
                        "username": "calm27",
                        "content": "Perhaps, to check each `i` with each `j` in window `k`, you need to write some kind of brute-force solution. There are planty of data structure that may help us to understand if there are duplicates or not, without actually direct checking them.  "
                    },
                    {
                        "username": "ashwiniranjansingh",
                        "content": "int len=nums.length;\n      for(int i=0;i<nums.length-k+1;i++){\n         \n          for(int j=(k>(len-1)?0:i);j<nums.length;j++){\n             \n              if((nums[i]==nums[j])&&(Math.abs(j-i)<=k)&&(i!=j))\n              \n              return true;\n              \n          }\n      }  \n      return false;\n\nwhat is the problem"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The problem is you need something faster than nested loops buddy. Think about using Maps (HashSet or HashMap) etc..."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The question itself is a bit tricky but understandable and can be considered easy BUT when I submit the code it says \"Time Limit Exceeded\" which does not make sense, tried it on my Eclipse IDE and it works perfectly, less than 0.1s to execute more than 6 cases including an array which length is around 7000.\\n\\nThis question should be reviewed by admins ASAP. I even copied the test that the system is using when I click on submit to create a case here, when I run the code it says \"Invalid Test\" lol!!!"
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "One of the test case length is 54500 which good to test the time limit."
                    },
                    {
                        "username": "malegkin",
                        "content": "BE CAREFUL!!! LESS OR EQUAL!!\\nabs(i - j) <= k "
                    },
                    {
                        "username": "AndyDope",
                        "content": "Hey guys if the test case has nums=[1, 1, 3] and k=0\\nWhat is expected? True or False"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "i - j <= k\\n\\nif k = 0 i don\\'t think you should execute any code, not sure but logically with the constraint it means that i = j in order to get a result i - j = 0 which leads to comparing a value with itself inside the array!"
                    },
                    {
                        "username": "samuelraj349",
                        "content": "Input: nums = [1,0,1,1], k = 1\\nOutput: true \\nhow it is true?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "nums[2] == nums[3] and abs(2-3)<=1, so output is True."
                    },
                    {
                        "username": "adiya",
                        "content": "[99,99] k=2 why is it true?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "nums[0] == nums[1] and abs(0-1)<=2, so output is True."
                    },
                    {
                        "username": "Devilcoder2311",
                        "content": "[1,2,3,4,5,6,7,8,9,9]\\nk=3\\nexpected=true\\noutput=false"
                    },
                    {
                        "username": "sparklingness",
                        "content": "nums[8]==nums[9] and abs(8-9)<=3, so expected output is True."
                    }
                ]
            },
            {
                "id": 1653382,
                "content": [
                    {
                        "username": "noskillzjusthackz",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i]) && Math.abs(map.get(nums[i]) - i) <= k) {\\n                return true;\\n            }\\n            map.put(nums[i], i);\\n\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "calm27",
                        "content": "don\\'t post solutions here. it is `Discussion` section. "
                    },
                    {
                        "username": "cindyzh2011",
                        "content": "python 3\\n"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "why none is checking nums[i] == nums[j] explicitly in any of these solutions ??\\n\\nSomeone pls explain.."
                    },
                    {
                        "username": "calm27",
                        "content": "Perhaps, to check each `i` with each `j` in window `k`, you need to write some kind of brute-force solution. There are planty of data structure that may help us to understand if there are duplicates or not, without actually direct checking them.  "
                    },
                    {
                        "username": "ashwiniranjansingh",
                        "content": "int len=nums.length;\n      for(int i=0;i<nums.length-k+1;i++){\n         \n          for(int j=(k>(len-1)?0:i);j<nums.length;j++){\n             \n              if((nums[i]==nums[j])&&(Math.abs(j-i)<=k)&&(i!=j))\n              \n              return true;\n              \n          }\n      }  \n      return false;\n\nwhat is the problem"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The problem is you need something faster than nested loops buddy. Think about using Maps (HashSet or HashMap) etc..."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The question itself is a bit tricky but understandable and can be considered easy BUT when I submit the code it says \"Time Limit Exceeded\" which does not make sense, tried it on my Eclipse IDE and it works perfectly, less than 0.1s to execute more than 6 cases including an array which length is around 7000.\\n\\nThis question should be reviewed by admins ASAP. I even copied the test that the system is using when I click on submit to create a case here, when I run the code it says \"Invalid Test\" lol!!!"
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "One of the test case length is 54500 which good to test the time limit."
                    },
                    {
                        "username": "malegkin",
                        "content": "BE CAREFUL!!! LESS OR EQUAL!!\\nabs(i - j) <= k "
                    },
                    {
                        "username": "AndyDope",
                        "content": "Hey guys if the test case has nums=[1, 1, 3] and k=0\\nWhat is expected? True or False"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "i - j <= k\\n\\nif k = 0 i don\\'t think you should execute any code, not sure but logically with the constraint it means that i = j in order to get a result i - j = 0 which leads to comparing a value with itself inside the array!"
                    },
                    {
                        "username": "samuelraj349",
                        "content": "Input: nums = [1,0,1,1], k = 1\\nOutput: true \\nhow it is true?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "nums[2] == nums[3] and abs(2-3)<=1, so output is True."
                    },
                    {
                        "username": "adiya",
                        "content": "[99,99] k=2 why is it true?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "nums[0] == nums[1] and abs(0-1)<=2, so output is True."
                    },
                    {
                        "username": "Devilcoder2311",
                        "content": "[1,2,3,4,5,6,7,8,9,9]\\nk=3\\nexpected=true\\noutput=false"
                    },
                    {
                        "username": "sparklingness",
                        "content": "nums[8]==nums[9] and abs(8-9)<=3, so expected output is True."
                    }
                ]
            },
            {
                "id": 1653244,
                "content": [
                    {
                        "username": "noskillzjusthackz",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i]) && Math.abs(map.get(nums[i]) - i) <= k) {\\n                return true;\\n            }\\n            map.put(nums[i], i);\\n\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "calm27",
                        "content": "don\\'t post solutions here. it is `Discussion` section. "
                    },
                    {
                        "username": "cindyzh2011",
                        "content": "python 3\\n"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "why none is checking nums[i] == nums[j] explicitly in any of these solutions ??\\n\\nSomeone pls explain.."
                    },
                    {
                        "username": "calm27",
                        "content": "Perhaps, to check each `i` with each `j` in window `k`, you need to write some kind of brute-force solution. There are planty of data structure that may help us to understand if there are duplicates or not, without actually direct checking them.  "
                    },
                    {
                        "username": "ashwiniranjansingh",
                        "content": "int len=nums.length;\n      for(int i=0;i<nums.length-k+1;i++){\n         \n          for(int j=(k>(len-1)?0:i);j<nums.length;j++){\n             \n              if((nums[i]==nums[j])&&(Math.abs(j-i)<=k)&&(i!=j))\n              \n              return true;\n              \n          }\n      }  \n      return false;\n\nwhat is the problem"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The problem is you need something faster than nested loops buddy. Think about using Maps (HashSet or HashMap) etc..."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The question itself is a bit tricky but understandable and can be considered easy BUT when I submit the code it says \"Time Limit Exceeded\" which does not make sense, tried it on my Eclipse IDE and it works perfectly, less than 0.1s to execute more than 6 cases including an array which length is around 7000.\\n\\nThis question should be reviewed by admins ASAP. I even copied the test that the system is using when I click on submit to create a case here, when I run the code it says \"Invalid Test\" lol!!!"
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "One of the test case length is 54500 which good to test the time limit."
                    },
                    {
                        "username": "malegkin",
                        "content": "BE CAREFUL!!! LESS OR EQUAL!!\\nabs(i - j) <= k "
                    },
                    {
                        "username": "AndyDope",
                        "content": "Hey guys if the test case has nums=[1, 1, 3] and k=0\\nWhat is expected? True or False"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "i - j <= k\\n\\nif k = 0 i don\\'t think you should execute any code, not sure but logically with the constraint it means that i = j in order to get a result i - j = 0 which leads to comparing a value with itself inside the array!"
                    },
                    {
                        "username": "samuelraj349",
                        "content": "Input: nums = [1,0,1,1], k = 1\\nOutput: true \\nhow it is true?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "nums[2] == nums[3] and abs(2-3)<=1, so output is True."
                    },
                    {
                        "username": "adiya",
                        "content": "[99,99] k=2 why is it true?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "nums[0] == nums[1] and abs(0-1)<=2, so output is True."
                    },
                    {
                        "username": "Devilcoder2311",
                        "content": "[1,2,3,4,5,6,7,8,9,9]\\nk=3\\nexpected=true\\noutput=false"
                    },
                    {
                        "username": "sparklingness",
                        "content": "nums[8]==nums[9] and abs(8-9)<=3, so expected output is True."
                    }
                ]
            },
            {
                "id": 1653029,
                "content": [
                    {
                        "username": "noskillzjusthackz",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i]) && Math.abs(map.get(nums[i]) - i) <= k) {\\n                return true;\\n            }\\n            map.put(nums[i], i);\\n\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "calm27",
                        "content": "don\\'t post solutions here. it is `Discussion` section. "
                    },
                    {
                        "username": "cindyzh2011",
                        "content": "python 3\\n"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "why none is checking nums[i] == nums[j] explicitly in any of these solutions ??\\n\\nSomeone pls explain.."
                    },
                    {
                        "username": "calm27",
                        "content": "Perhaps, to check each `i` with each `j` in window `k`, you need to write some kind of brute-force solution. There are planty of data structure that may help us to understand if there are duplicates or not, without actually direct checking them.  "
                    },
                    {
                        "username": "ashwiniranjansingh",
                        "content": "int len=nums.length;\n      for(int i=0;i<nums.length-k+1;i++){\n         \n          for(int j=(k>(len-1)?0:i);j<nums.length;j++){\n             \n              if((nums[i]==nums[j])&&(Math.abs(j-i)<=k)&&(i!=j))\n              \n              return true;\n              \n          }\n      }  \n      return false;\n\nwhat is the problem"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The problem is you need something faster than nested loops buddy. Think about using Maps (HashSet or HashMap) etc..."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The question itself is a bit tricky but understandable and can be considered easy BUT when I submit the code it says \"Time Limit Exceeded\" which does not make sense, tried it on my Eclipse IDE and it works perfectly, less than 0.1s to execute more than 6 cases including an array which length is around 7000.\\n\\nThis question should be reviewed by admins ASAP. I even copied the test that the system is using when I click on submit to create a case here, when I run the code it says \"Invalid Test\" lol!!!"
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "One of the test case length is 54500 which good to test the time limit."
                    },
                    {
                        "username": "malegkin",
                        "content": "BE CAREFUL!!! LESS OR EQUAL!!\\nabs(i - j) <= k "
                    },
                    {
                        "username": "AndyDope",
                        "content": "Hey guys if the test case has nums=[1, 1, 3] and k=0\\nWhat is expected? True or False"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "i - j <= k\\n\\nif k = 0 i don\\'t think you should execute any code, not sure but logically with the constraint it means that i = j in order to get a result i - j = 0 which leads to comparing a value with itself inside the array!"
                    },
                    {
                        "username": "samuelraj349",
                        "content": "Input: nums = [1,0,1,1], k = 1\\nOutput: true \\nhow it is true?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "nums[2] == nums[3] and abs(2-3)<=1, so output is True."
                    },
                    {
                        "username": "adiya",
                        "content": "[99,99] k=2 why is it true?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "nums[0] == nums[1] and abs(0-1)<=2, so output is True."
                    },
                    {
                        "username": "Devilcoder2311",
                        "content": "[1,2,3,4,5,6,7,8,9,9]\\nk=3\\nexpected=true\\noutput=false"
                    },
                    {
                        "username": "sparklingness",
                        "content": "nums[8]==nums[9] and abs(8-9)<=3, so expected output is True."
                    }
                ]
            },
            {
                "id": 1653028,
                "content": [
                    {
                        "username": "noskillzjusthackz",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i]) && Math.abs(map.get(nums[i]) - i) <= k) {\\n                return true;\\n            }\\n            map.put(nums[i], i);\\n\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "calm27",
                        "content": "don\\'t post solutions here. it is `Discussion` section. "
                    },
                    {
                        "username": "cindyzh2011",
                        "content": "python 3\\n"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "why none is checking nums[i] == nums[j] explicitly in any of these solutions ??\\n\\nSomeone pls explain.."
                    },
                    {
                        "username": "calm27",
                        "content": "Perhaps, to check each `i` with each `j` in window `k`, you need to write some kind of brute-force solution. There are planty of data structure that may help us to understand if there are duplicates or not, without actually direct checking them.  "
                    },
                    {
                        "username": "ashwiniranjansingh",
                        "content": "int len=nums.length;\n      for(int i=0;i<nums.length-k+1;i++){\n         \n          for(int j=(k>(len-1)?0:i);j<nums.length;j++){\n             \n              if((nums[i]==nums[j])&&(Math.abs(j-i)<=k)&&(i!=j))\n              \n              return true;\n              \n          }\n      }  \n      return false;\n\nwhat is the problem"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The problem is you need something faster than nested loops buddy. Think about using Maps (HashSet or HashMap) etc..."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The question itself is a bit tricky but understandable and can be considered easy BUT when I submit the code it says \"Time Limit Exceeded\" which does not make sense, tried it on my Eclipse IDE and it works perfectly, less than 0.1s to execute more than 6 cases including an array which length is around 7000.\\n\\nThis question should be reviewed by admins ASAP. I even copied the test that the system is using when I click on submit to create a case here, when I run the code it says \"Invalid Test\" lol!!!"
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "One of the test case length is 54500 which good to test the time limit."
                    },
                    {
                        "username": "malegkin",
                        "content": "BE CAREFUL!!! LESS OR EQUAL!!\\nabs(i - j) <= k "
                    },
                    {
                        "username": "AndyDope",
                        "content": "Hey guys if the test case has nums=[1, 1, 3] and k=0\\nWhat is expected? True or False"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "i - j <= k\\n\\nif k = 0 i don\\'t think you should execute any code, not sure but logically with the constraint it means that i = j in order to get a result i - j = 0 which leads to comparing a value with itself inside the array!"
                    },
                    {
                        "username": "samuelraj349",
                        "content": "Input: nums = [1,0,1,1], k = 1\\nOutput: true \\nhow it is true?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "nums[2] == nums[3] and abs(2-3)<=1, so output is True."
                    },
                    {
                        "username": "adiya",
                        "content": "[99,99] k=2 why is it true?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "nums[0] == nums[1] and abs(0-1)<=2, so output is True."
                    },
                    {
                        "username": "Devilcoder2311",
                        "content": "[1,2,3,4,5,6,7,8,9,9]\\nk=3\\nexpected=true\\noutput=false"
                    },
                    {
                        "username": "sparklingness",
                        "content": "nums[8]==nums[9] and abs(8-9)<=3, so expected output is True."
                    }
                ]
            },
            {
                "id": 1634553,
                "content": [
                    {
                        "username": "noskillzjusthackz",
                        "content": "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i]) && Math.abs(map.get(nums[i]) - i) <= k) {\\n                return true;\\n            }\\n            map.put(nums[i], i);\\n\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "calm27",
                        "content": "don\\'t post solutions here. it is `Discussion` section. "
                    },
                    {
                        "username": "cindyzh2011",
                        "content": "python 3\\n"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "why none is checking nums[i] == nums[j] explicitly in any of these solutions ??\\n\\nSomeone pls explain.."
                    },
                    {
                        "username": "calm27",
                        "content": "Perhaps, to check each `i` with each `j` in window `k`, you need to write some kind of brute-force solution. There are planty of data structure that may help us to understand if there are duplicates or not, without actually direct checking them.  "
                    },
                    {
                        "username": "ashwiniranjansingh",
                        "content": "int len=nums.length;\n      for(int i=0;i<nums.length-k+1;i++){\n         \n          for(int j=(k>(len-1)?0:i);j<nums.length;j++){\n             \n              if((nums[i]==nums[j])&&(Math.abs(j-i)<=k)&&(i!=j))\n              \n              return true;\n              \n          }\n      }  \n      return false;\n\nwhat is the problem"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The problem is you need something faster than nested loops buddy. Think about using Maps (HashSet or HashMap) etc..."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The question itself is a bit tricky but understandable and can be considered easy BUT when I submit the code it says \"Time Limit Exceeded\" which does not make sense, tried it on my Eclipse IDE and it works perfectly, less than 0.1s to execute more than 6 cases including an array which length is around 7000.\\n\\nThis question should be reviewed by admins ASAP. I even copied the test that the system is using when I click on submit to create a case here, when I run the code it says \"Invalid Test\" lol!!!"
                    },
                    {
                        "username": "chouhanabhishek365",
                        "content": "One of the test case length is 54500 which good to test the time limit."
                    },
                    {
                        "username": "malegkin",
                        "content": "BE CAREFUL!!! LESS OR EQUAL!!\\nabs(i - j) <= k "
                    },
                    {
                        "username": "AndyDope",
                        "content": "Hey guys if the test case has nums=[1, 1, 3] and k=0\\nWhat is expected? True or False"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "i - j <= k\\n\\nif k = 0 i don\\'t think you should execute any code, not sure but logically with the constraint it means that i = j in order to get a result i - j = 0 which leads to comparing a value with itself inside the array!"
                    },
                    {
                        "username": "samuelraj349",
                        "content": "Input: nums = [1,0,1,1], k = 1\\nOutput: true \\nhow it is true?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "nums[2] == nums[3] and abs(2-3)<=1, so output is True."
                    },
                    {
                        "username": "adiya",
                        "content": "[99,99] k=2 why is it true?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "nums[0] == nums[1] and abs(0-1)<=2, so output is True."
                    },
                    {
                        "username": "Devilcoder2311",
                        "content": "[1,2,3,4,5,6,7,8,9,9]\\nk=3\\nexpected=true\\noutput=false"
                    },
                    {
                        "username": "sparklingness",
                        "content": "nums[8]==nums[9] and abs(8-9)<=3, so expected output is True."
                    }
                ]
            }
        ]
    },
    {
        "title": "Bulb Switcher",
        "question_content": "<p>There are <code>n</code> bulbs that are initially off. You first turn on all the bulbs, then&nbsp;you turn off every second bulb.</p>\n\n<p>On the third round, you toggle every third bulb (turning on if it&#39;s off or turning off if it&#39;s on). For the <code>i<sup>th</sup></code> round, you toggle every <code>i</code> bulb. For the <code>n<sup>th</sup></code> round, you only toggle the last bulb.</p>\n\n<p>Return <em>the number of bulbs that are on after <code>n</code> rounds</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/05/bulb.jpg\" style=\"width: 421px; height: 321px;\" />\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> At first, the three bulbs are [off, off, off].\nAfter the first round, the three bulbs are [on, on, on].\nAfter the second round, the three bulbs are [on, off, on].\nAfter the third round, the three bulbs are [on, off, off]. \nSo you should return 1 because there is only one bulb is on.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 0\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 77104,
                "title": "math-solution",
                "content": "```\\nint bulbSwitch(int n) {\\n    return sqrt(n);\\n}\\n```\\n\\nA bulb ends up on iff it is switched an odd number of times.\\n\\nCall them bulb 1 to bulb n. Bulb i is switched in round d if and only if d divides i. So bulb i ends up on if and only if it has an odd number of divisors.\\n\\nDivisors come in pairs, like i=12 has divisors 1 and 12, 2 and 6, and 3 and 4. Except when i is a square, like 36 has divisors 1 and 36, 2 and 18, 3 and 12, 4 and 9, and double divisor 6. So bulb i ends up on if and only if i is a square.\\n\\n**So just count the square numbers.**\\n\\nLet R = int(sqrt(n)). That\\'s the root of the largest square in the range [1,n]. And 1 is the smallest root. So you have the roots from 1 to R, that\\'s R roots. Which correspond to the R squares. So int(sqrt(n)) is the answer. (C++ does the conversion to int automatically, because of the specified return type).\\n\\nUpdate years later: Python now has `math.isqrt` and LeetCode apparently auto-imports *everything* for us, so this now gets accepted as Python solution:\\n```\\nclass Solution:\\n    bulbSwitch = isqrt\\n```",
                "solutionTags": [],
                "code": "```\\nint bulbSwitch(int n) {\\n    return sqrt(n);\\n}\\n```\n```\\nclass Solution:\\n    bulbSwitch = isqrt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77112,
                "title": "share-my-o-1-solution-with-explanation",
                "content": "    class Solution {\\n    public:\\n        int bulbSwitch(int n) {\\n            return sqrt(n);\\n        }\\n    };\\n As we know that there are n bulbs, let's name them as 1, 2, 3, 4, ..., n.  \\n\\n 1. You first turn on all the bulbs.\\n 2. Then, you turn off every second bulb.(2, 4, 6, ...)\\n 3. On the third round, you toggle every third bulb.(3, 6, 9, ...) \\n 4. For the ith round, you toggle every i bulb.(i, 2i, 3i, ...)\\n 5. For the nth round, you only toggle the last bulb.(n)\\n\\n\\n----------\\n\\n\\nIf n > 6, you can find that bulb 6 is toggled in round 2 and 3. \\n\\nLater, it will also be toggled in round 6, and round 6 will be the last round when bulb 6 is toggled.\\n\\nHere, **2,3 and 6 are all *factors* of 6 (except 1).**\\n\\n----------\\n**Prove:**\\n----------\\n\\nWe can come to the conclusion that **the bulb *i* is toggled *k* times.**\\n\\nHere, ***k*** is **the number of *i*'s factors (except 1)**.\\n\\n***k* + 1** will be **the total number of *i*'s factors**\\n\\n\\n----------\\n\\n\\nFor example:\\n\\n - **Factors of 6: 1, 2, 3, 6 (3 factors except 1, so it will be toggled 3 times)**\\n - **Factors of 7: 1, 7 (1 factors except 1, so it will be toggled once)**\\n....\\n\\nNow, the key problem here is to judge **whether *k* is *even* or *odd*.**\\n\\n----------\\n\\nSince **all bulbs are on at the beginning**, we can get:\\n\\n - **If *k* is *odd*, the bulb will be *off* in the end.(after odd times of toggling).**\\n - **If *k* is *even*, the bulb i will be *on* in the end (after even times of toggling).**\\n\\nAs we all know, **a natural number can divided by 1 and itself**, and **all factors appear *in pairs***.\\n\\n**When we know that *p* is *i*'s factor, we are sure *q* = *i/p* is also *i*'s factor.**\\n\\n**If *i* has no factor *p* that makes *p* = *i/p*, *k*+ 1 is even.**\\n\\n**If *i* has a factor *p* that makes *p* = *i/p* (*i* = *p*^2, *i* is a perfect square of *p*), *k*+ 1 is odd.**\\n\\n\\n----------\\n\\n\\nSo we get that **in the end**:\\n\\n - If ***i*** is a **perfect square** , *k*+ 1 is odd, ***k* is even (bulb *i* is on)**.\\n - If ***i*** is **NOT** a **perfect square** , *k*+ 1 is even, ***k* is odd (bulb *i* is off)**.\\n\\n----------\\n\\nWe want to find **how many *bulbs* are on** after *n* rounds (**In the end**).\\n\\nThat means we need to find out **how many *perfect square numbers* are NO MORE than *n***.\\n\\nThe **number of *perfect square numbers* which are no more than *n***, is the ***square root* of the *maximum perfect square number* which is NO MORE than *n***\\n\\n----------\\n**Result:**\\n----------\\n\\nThe ***square root* of the *maximum perfect square number* which is NO MORE than *n*** is the \\n***integer part* of *sqrt(n)*.**\\n\\n(**If *i* = 1, it will NEVER be toggled, *k* is 0 (even) here which meets the requirement.**)",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\n    public:\\n        int bulbSwitch(int n) {\\n            return sqrt(n);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 77132,
                "title": "the-simplest-and-most-efficient-solution-well-explained",
                "content": "### Solution\\nBefore we take a jump to the solution, let's first try to clear out what exactly the problem is talking about: \\n - every i-th distance you switch the bulb to the opposite state (from on to off, or from off to on); actually suppose the bulbs are labelled from 1 to n then the every second bulb will mean that 2, 4, 6, 8, ... all even numbers less than n; while every third bulb will be 3, 6, 9, 12, ... all multiples of 3 that is less than n and so on; \\n - since the bulb will only have two different states - on or off, the result will be quite clear now; odd switching operations will result in bulb-on state (since original state is bulb-off) while even switching operations will give us bulb-off state;\\n\\nNow the purpose here is clear searching for the **odd-operation numbers**: \\n - as for primes, they only have 1 and itself as their factors, even-operation numbers;\\n - as for non-primes, normally they will have different pairs of factors like 12 whose factors are (1, 12), (3, 4), (2, 6) - 6 different factors, also even-operation numbers;\\n - but among non-primes, there are some special numbers, perfect square numbers like 9 whose factors are (1, 9) and (3, 3) - odd-operation numbers, which means there will be only three different numbers that will affect the current bulb and result in bulb-on state!\\n\\nSo that's all we need to know to hack this problem now. But how to get the amount of squares that are less than n, quite simple. Sqrt(n) is the answer, since all square numbers that is less than n will be 1, 4, 9 ... n and their corresponding square roots will be 1, 2, 3,... sqrt(n).\\n\\n - Space cost O(1)\\n - Time cost O(1)\\n\\n```\\n//AC - 0ms;\\nint bulbSwitch(int n) {\\n\\treturn sqrt(n);\\n}\\n```\\nAlways welcome new ideas and `practical` tricks, just leave them in the comments!",
                "solutionTags": [],
                "code": "```\\n//AC - 0ms;\\nint bulbSwitch(int n) {\\n\\treturn sqrt(n);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3459106,
                "title": "image-explanation-easiest-to-understand-no-clickbait-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Bulb Switcher` by `Aryan Mittal`\\n![lc.png](https://assets.leetcode.com/users/images/a3e889bd-7b40-412e-8e55-5335d872acb8_1682559814.8735898.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/1fdf1dd6-5f40-40e1-967f-ca3388dc9224_1682559087.0548987.png)\\n![image.png](https://assets.leetcode.com/users/images/e122b3d2-5f2e-4f7d-997c-16f6650e2393_1682559096.9522943.png)\\n![image.png](https://assets.leetcode.com/users/images/0a8adb86-2e51-4952-af48-dfd1148ceba6_1682559107.5787735.png)\\n![image.png](https://assets.leetcode.com/users/images/c64c8eb2-1377-45d3-a64b-7d136286f6d6_1682559119.9725766.png)\\n![image.png](https://assets.leetcode.com/users/images/a98f0d15-e251-4071-bd46-723cc8e30ba9_1682559130.6620624.png)\\n![image.png](https://assets.leetcode.com/users/images/917462af-c595-447e-b5e3-e224f742839f_1682559139.1918097.png)\\n![image.png](https://assets.leetcode.com/users/images/bf90fc30-3208-4f94-badc-db586b8b435c_1682559150.8375518.png)\\n![image.png](https://assets.leetcode.com/users/images/4a22e1b1-f62e-47c8-ba62-342b59af8458_1682559165.5627007.png)\\n![image.png](https://assets.leetcode.com/users/images/048337b4-6219-4218-842e-ad690aa7f585_1682559176.4367657.png)\\n![image.png](https://assets.leetcode.com/users/images/2d651803-a540-43f1-8567-a08ff410abd1_1682559183.7578912.png)\\n![image.png](https://assets.leetcode.com/users/images/1616acd0-1d4a-430a-b742-be6682e92f16_1682559191.2816284.png)\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return sqrt(n);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);\\n    }\\n}\\n```\\n```Python []\\nimport math\\n\\nclass Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return int(math.sqrt(n))\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Math"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return sqrt(n);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);\\n    }\\n}\\n```\n```Python []\\nimport math\\n\\nclass Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return int(math.sqrt(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77133,
                "title": "my-0-ms-c-solution-with-explanation",
                "content": "    int bulbSwitch(int n) {\\n        int counts = 0;\\n        \\n        for (int i=1; i*i<=n; ++i) {\\n            ++ counts;    \\n        }\\n        \\n        return counts;\\n    }\\n\\nExplanation:  \\nA light will be toggled only during the round of its factors, e.g.  number 6 light will be toggled at 1,2,3,6 and light 12 will be toggled at 1,2,3,4,6,12.   The final state of a light is on and off only depends on if the number of its factor is odd or even.    If odd, the light is on and if even the light is off.   The number of one number's factor is odd if and only if it is a perfect square!   \\nSo we will only need to loop to find all the perfect squares that are smaller than n!",
                "solutionTags": [],
                "code": "    int bulbSwitch(int n) {\\n        int counts = 0;\\n        \\n        for (int i=1; i*i<=n; ++i) {\\n            ++ counts;    \\n        }\\n        \\n        return counts;\\n    }\\n\\nExplanation:  \\nA light will be toggled only during the round of its factors, e.g.  number 6 light will be toggled at 1,2,3,6 and light 12 will be toggled at 1,2,3,4,6,12.   The final state of a light is on and off only depends on if the number of its factor is odd or even.    If odd, the light is on and if even the light is off.   The number of one number's factor is odd if and only if it is a perfect square!   \\nSo we will only need to loop to find all the perfect squares that are smaller than n!",
                "codeTag": "Unknown"
            },
            {
                "id": 383285,
                "title": "python-99-one-line-solution-its-math",
                "content": "```\\ndef bulbSwitch(self, n: int) -> int:\\n        return int(n**(1/2))\\n```\\n\\nThere is a pattern for it\\nfor 1th bulb : 1\\n2nd : 1 0\\n3rd : 1 0 0\\n4th : 1 0 0 1\\n5th : 1 0 0 1 0\\n6th : 1 0 0 1 0 0\\n7th : 1 0 0 1 0 0 0\\n8th : 1 0 0 1 0 0 0 0\\n9th : 1 0 0 1 0 0 0 0 1\\n\\nMeaning the **I-th bulb that is on** only on when its on **I\\\\*\\\\*2 turn**, for example if you want 2 bulb on then you will have to go to 4th round, 3 bulb on -> 9th round. \\nso for (n-th round) you can get at most floor(square_root(n)) bulb.\\n\\nPlease star it if you like my solution and explanation :), any advice or correction would be appreciated.\\n\\nThanks !",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\ndef bulbSwitch(self, n: int) -> int:\\n        return int(n**(1/2))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 77144,
                "title": "one-line-java-with-explanation",
                "content": "factor of 6: 1,2,3,6\\nfactor of 7: 1,7 \\nfactor of 9: 1,3,9\\n\\nso all number have even number of factors except square number(e.g: factor of 9:1,3,9). \\nsquare number must turn on because of odd number of factors(9: turn on at 1st, off at 3rd, on at 9th)\\nother number must turn off(6: turn on at 1st, off at 2nd, on at 3rd, off at 6th)\\nso we only need to compute the number of square number less equal than n\\n\\n    public class Solution {\\n        public int bulbSwitch(int n) {\\n            return (int)Math.sqrt(n);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int bulbSwitch(int n) {\\n            return (int)Math.sqrt(n);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 77145,
                "title": "crystal-clear-explanation-one-line-c-code",
                "content": "Ok, very verbose explanation, but clear enough for everyone to understand.\\n\\nthe initial state all bulbs are off.\\n\\nif at last the bulb was toggled odd number of times, it is on.\\nif toggled even number of times, it is off.\\n\\nsimple enough, and that number is determined by how many factors a number has.\\nnote that every number has 1 and itself as a factor. and if it has multiple times of a factor\\nit only counted once.\\n\\n1 --------- 1\\n\\n2 --------- 1, 2\\n\\n3 --------- 1, 3\\n\\n4 --------- 1, 2, 4\\n\\n5 --------- 1, 5\\n\\n6 --------- 1, 2, 3, 6\\n\\n7 --------- 1, 7\\n\\n8 --------- 1, 2, 4, 8\\n\\n9 --------- 1, 3, 9\\n\\nsee that only square numbers like 1, 4 and 9 has odd number of factors.\\nbulbs at those numbers will left on after all the rounds of toggle.\\n\\nso basically, we calculate how many square numbers are there within a given number.\\nand we can get it simply by calculate the square root of that number. of course the decimal part is eliminated.\\n\\n\\n    class Solution {\\n    public:\\n        int bulbSwitch(int n) {\\n            return sqrt(n);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int bulbSwitch(int n) {\\n            return sqrt(n);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3459109,
                "title": "java-easy-two-methods-using-binary-search",
                "content": "**Method 1**\\n```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);\\n    }\\n}\\n```\\n**Method 2 (Binary Search)**\\n```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        long low=0;\\n        long high=n;\\n        while(low<=high){\\n            long mid=low+(high-low)/2;\\n            if((mid*mid)==n)\\n                return (int)mid;\\n            else if((mid*mid)<n)\\n                low=mid+1;\\n            else\\n                high=mid-1;\\n        }\\n        return (int)low-1;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/889d4a14-99a7-43bb-943f-550ef779d088_1682559183.139507.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        long low=0;\\n        long high=n;\\n        while(low<=high){\\n            long mid=low+(high-low)/2;\\n            if((mid*mid)==n)\\n                return (int)mid;\\n            else if((mid*mid)<n)\\n                low=mid+1;\\n            else\\n                high=mid-1;\\n        }\\n        return (int)low-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459630,
                "title": "c-easy-math",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        long long i=1;\\n        int ct=0;\\n        while((i*i)<=n){\\n            i++;\\n            ct++;\\n        }\\n        return ct;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/9548ac35-16a8-4f1c-94a5-f8447ef7f0b2_1682574456.026129.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        long long i=1;\\n        int ct=0;\\n        while((i*i)<=n){\\n            i++;\\n            ct++;\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 759991,
                "title": "my-explanation-on-why-the-solution-is-sqrt-n",
                "content": "Lets think when a bulb is going to be on or off at end.\\n\\nSo lets talk about the kth bulb now this bulb will be on at the end if and only if it is toggled odd number of times,\\n\\nWhy odd number of times?  ans -   for kth bulb initially it is OFF\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tafter 1st toggle its         ON    \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tafter 2nd toggle its        OFF  \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tafter 3rd toggle its        ON    \\n\\t\\t\\t\\nso from this we can see if you toggle a bulb odd number of time it is ON and if toggled even number of times it is OFF.\\n\\nSo lets take the K = 4 so this bulb will be toggled at 1st(ON), 2nd(OFF) and 4th(ON) operations. So the 1st, 2nd and 4th are actually the\\nfactors of 4. So our problem reduced to find whether the kth bulb has odd number of factors or even no of factors.\\n\\nIf it has odd number of factors the bulb will be on and if even number of factors the bulb will be off.\\nAccording to maths number that are perfect square has odd no of factors and number that are not perfect square have even number of factors.\\n\\nExample : 36(perfect square) - the factors are 1,2,3,4,6,9,12,18,36 we see that it has 9 factors which is odd.\\n                 12(not a perfect square) - the factors are 1,2,3,4,6,12 we see that it has 6 factors which is even.\\n\\t\\t\\t\\t \\nSo we are given N bulbs now the problem reduced to find the number of perfect squares between 1 to N. As these number will have odd factors and will be ON at the end. \\n\\nSo according to maths the number of perfect squares between 1 to N is given by SQRT (N).\\n\\neg for n = 6  \\n       sqrt ( 6 ) = 2 so there are 2 perfect squares between 1 to 6  -  (1,4);\\n\\t   So at end bulb 1 and 4 will be on.\\n\\t   \\n\\t   0 0 0 0 0 0    - initially\\n\\t   1 1 1 1 1 1    - 1st toggle\\n\\t   1 0 1 0 1 0   - 2nd toggle\\n\\t   1 0 0 0 1 1   - 3rd toggle \\n\\t   1 0 0 1 1 1   - 4th toggle\\n\\t   1 0 0 1 0 1   - 5th toggle\\n\\t   1 0 0 1 0 0   - 6th toggle\\n\\t   \\n\\t   \\n\\t   If you find this helpful please upvote.\\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n",
                "solutionTags": [],
                "code": "Lets think when a bulb is going to be on or off at end.\\n\\nSo lets talk about the kth bulb now this bulb will be on at the end if and only if it is toggled odd number of times,\\n\\nWhy odd number of times?  ans -   for kth bulb initially it is OFF\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tafter 1st toggle its         ON    \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tafter 2nd toggle its        OFF  \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tafter 3rd toggle its        ON    \\n\\t\\t\\t\\nso from this we can see if you toggle a bulb odd number of time it is ON and if toggled even number of times it is OFF.\\n\\nSo lets take the K = 4 so this bulb will be toggled at 1st(ON), 2nd(OFF) and 4th(ON) operations. So the 1st, 2nd and 4th are actually the\\nfactors of 4. So our problem reduced to find whether the kth bulb has odd number of factors or even no of factors.\\n\\nIf it has odd number of factors the bulb will be on and if even number of factors the bulb will be off.\\nAccording to maths number that are perfect square has odd no of factors and number that are not perfect square have even number of factors.\\n\\nExample : 36(perfect square) - the factors are 1,2,3,4,6,9,12,18,36 we see that it has 9 factors which is odd.\\n                 12(not a perfect square) - the factors are 1,2,3,4,6,12 we see that it has 6 factors which is even.\\n\\t\\t\\t\\t \\nSo we are given N bulbs now the problem reduced to find the number of perfect squares between 1 to N. As these number will have odd factors and will be ON at the end. \\n\\nSo according to maths the number of perfect squares between 1 to N is given by SQRT (N).\\n\\neg for n = 6  \\n       sqrt ( 6 ) = 2 so there are 2 perfect squares between 1 to 6  -  (1,4);\\n\\t   So at end bulb 1 and 4 will be on.\\n\\t   \\n\\t   0 0 0 0 0 0    - initially\\n\\t   1 1 1 1 1 1    - 1st toggle\\n\\t   1 0 1 0 1 0   - 2nd toggle\\n\\t   1 0 0 0 1 1   - 3rd toggle \\n\\t   1 0 0 1 1 1   - 4th toggle\\n\\t   1 0 0 1 0 1   - 5th toggle\\n\\t   1 0 0 1 0 0   - 6th toggle\\n\\t   \\n\\t   \\n\\t   If you find this helpful please upvote.\\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1221872,
                "title": "one-line-c-solution-with-great-explanation",
                "content": "Just focus on a bulb and see how many times its state gets toggled. If a bulb gets toggled even number of times its state is the same as initial state (which is **OFF**), and if the bulb is toggled odd number of times its state is **ON**.\\n\\nNotice that each bulb gets toggled only in those rounds that are its divisors.\\n\\nBulb 1 -> Gets toggled 1 time. (in round 1) -> Final State **ON**\\nBulb 2 -> Gets toggled 2 times. (in round 1 and 2) -> Final State **OFF**\\n...\\nBulb 6 -> Gets toggled 4 times (in round 1, 2, 3 and 6) -> Final State **OFF**\\nBulb 9 -> Gets toggled 3 times (in round 1, 3 and 9) -> Final State **ON**\\n...\\nBulb 25 -> Gets toggled 3 times (in round 1, 5 and 25) -> Final State **ON**\\n\\nOnce you start writing the state of each bulb after n rounds you will notice that only the bulbs that are perfect square numbered are in ON state, rest are in OFF (or initial) state\\n.\\nThis is because the divisors of every integer that is NOT a perfect square comes as a pair.\\nFor example, in case of 6 its divisors are (1,6) and (2,3). In case of 12 the divisors are (1,12), (2,6), (3,4).\\nEach member of the pair cancels out the toggle made by the other member.\\n\\nBut in case of perfect-square number one of its divisor does not come as a pair. That divisor is the square root of that perfect square number. Thats why a perfect-square number has odd number of divisors. That is why there is no round that can cancel out the toggle made by the \"square-root\" round. Thats why all the perfect square numbers are in ON state.\\n\\nSo, the answer is: the number of perfect square numbers less than or equal to ***n***\\n\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n)\\n    {\\n        return sqrt(n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n)\\n    {\\n        return sqrt(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77120,
                "title": "clear-thought-process-explained",
                "content": "I try explain my though as following:\\n\\nHow many \"on\" at the end of nth toggle?\\n\\n--> \"on\" or \"off\" at each position in an array of length n?\\n\\n--> toggle even number times will result in \"on\", toggle odd number times will result in \"off\"\\n\\n--> for position k, the number of toggles is the number of distinct divisors that k has\\n\\n--> divisors always come in pair, which means even number of divisors, for example, 12 has (1,12),(2,6),(3,4).\\n\\n--> however, Square Number has odd number of divisors, e.g. 25 has 1,25,5\\n\\n--> thus, the number of \"on\", is the number of perfect square number <= n\\n\\n\\n\\nPython:\\n\\n    def bulbSwitch(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        return int(math.sqrt(n))",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "I try explain my though as following:\\n\\nHow many \"on\" at the end of nth toggle?\\n\\n--> \"on\" or \"off\" at each position in an array of length n?\\n\\n--> toggle even number times will result in \"on\", toggle odd number times will result in \"off\"\\n\\n--> for position k, the number of toggles is the number of distinct divisors that k has\\n\\n--> divisors always come in pair, which means even number of divisors, for example, 12 has (1,12),(2,6),(3,4).\\n\\n--> however, Square Number has odd number of divisors, e.g. 25 has 1,25,5\\n\\n--> thus, the number of \"on\", is the number of perfect square number <= n\\n\\n\\n\\nPython:\\n\\n    def bulbSwitch(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        return int(math.sqrt(n))",
                "codeTag": "Python3"
            },
            {
                "id": 77147,
                "title": "one-line-math-solution-with-some-explanation",
                "content": "    // For prime numbers, they must be off because we can reach them only twice (The first round and their own round).\\n    /* For other numbers, if we can reach them odd times, then they are on; otherwise, they are off. So only \\n     those numbers who have square root will be reached odd times and there are sqrt(n) of them because\\n     for every x > sqrt(n), x*x > n and thus should not be considered as the answer. */\\n    \\n     return (int)sqrt(n);",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "    // For prime numbers, they must be off because we can reach them only twice (The first round and their own round).\\n    /* For other numbers, if we can reach them odd times, then they are on; otherwise, they are off. So only \\n     those numbers who have square root will be reached odd times and there are sqrt(n) of them because\\n     for every x > sqrt(n), x*x > n and thus should not be considered as the answer. */\\n    \\n     return (int)sqrt(n);",
                "codeTag": "Unknown"
            },
            {
                "id": 535399,
                "title": "python-js-java-c-sol-by-perfect-square-w-visualization",
                "content": "sol by math.\\n\\n---\\n\\n**Hint**:\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1583906058.png)\\n\\nInitial state is \"OFF\" for all bulbs\\n\\nWe have n bulbs, number them from bulb_#1 to buld_#n.\\n\\nBulb_#k will be \"ON\" where k has odd times of *switch toggle*, if and only if, k has odd factors.\\n\\nFor all positive integers, only **perfect square number**s have **odd factors**.\\n\\nBulb_#1 : 1 (OFF->**ON**). \\ntotal 1 factor\\n\\n---\\n\\nBulb_#4 : 1 (OFF->ON), 2 (ON->OFF), 4 (OFF->**ON**). \\ntotal 3 factors\\n\\n---\\n\\nBulb_#9 : 1 (OFF->ON), 3 (ON->OFF), 9 (OFF->**ON**). \\ntotal 3 factors\\n\\n---\\n\\nBulb_#16 : 1 (OFF->ON), 2 (ON->OFF), 4 (OFF->ON). , 8 (ON->OFF), 16 (OFF->**ON**). \\ntotal 5 factors\\n\\n---\\n\\nBulb_#25 : 1 (OFF->ON), 5 (ON->OFF), 25 (OFF->**ON**)\\ntotal 3 factors\\n\\n... and so on\\n\\n---\\n**Implementation**:\\n\\n**Python**\\n\\n```\\nclass Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        \\n        # Only those bulds with perferct square number index will keep \"ON\" at last.\\n        \\n        return int(n**0.5)\\n```\\n\\n---\\n\\n**Javascript**:\\n\\n```\\nvar bulbSwitch = function(n) {\\n    return Math.floor(n**0.5);\\n};\\n```\\n\\n---\\n\\n**Java**:\\n\\n```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);\\n    }\\n}\\n```\\n\\n---\\n\\n**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return int( sqrt(n) );\\n    }\\n};\\n```\\n\\n---\\n\\nAppendix:\\n\\nDemo for n = 10\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1583862004.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        \\n        # Only those bulds with perferct square number index will keep \"ON\" at last.\\n        \\n        return int(n**0.5)\\n```\n```\\nvar bulbSwitch = function(n) {\\n    return Math.floor(n**0.5);\\n};\\n```\n```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return int( sqrt(n) );\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459158,
                "title": "image-explanation-100-faster-solution-mathematical-solution",
                "content": "# Image Explanation : \\n![image.png](https://assets.leetcode.com/users/images/0921224a-c49a-469f-aee5-9f8dc8cf437f_1682561033.9239.png)\\n\\n# Intuition\\nThe perfect square numbers have **UNIQUE** odd number of divisors.\\n\\n# Approach\\n![WhatsApp Image 2023-04-27 at 7.25.42 AM.jpeg](https://assets.leetcode.com/users/images/c1c4e8c2-9691-431a-adc2-7d8b5c451072_1682560857.4105785.jpeg)\\n![WhatsApp Image 2023-04-27 at 7.41.10 AM.jpeg](https://assets.leetcode.com/users/images/6d13c207-b90f-4ef1-ade3-85d6a965ec5f_1682561495.9763756.jpeg)\\n\\n\\n\\n# Complexity\\n- Time complexity: O(log n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return sqrt(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return sqrt(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 260515,
                "title": "math-binary-search",
                "content": "Stefan has posted an extremely fancy math solution [here](https://leetcode.com/problems/bulb-switcher/discuss/77104/Math-solution..). The following is a less fancier one.\\n\\nIf you try to play with many examples, you will find that the answer for `n = 1, 2, 3, ...` is `1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, ...`: answer `k` appears for `2 * k + 1` times. So the solution is to find the smallest `k` such that `3 + 5 + 7 + ... + 2 * k + 1` (the sum is `k * k + 2 * k`) is not smaller than `n`. This can be done using binary search.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        long l = 1, r = n;\\n        while (l < r) {\\n            long k = (l + r) / 2;\\n            if (k * k + 2 * k < n) {\\n                l = k + 1;\\n            } else {\\n                r = k;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        long l = 1, r = n;\\n        while (l < r) {\\n            long k = (l + r) / 2;\\n            if (k * k + 2 * k < n) {\\n                l = k + 1;\\n            } else {\\n                r = k;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459068,
                "title": "easy-java-solution-with-proper-explanation-beats-100-in-tc",
                "content": "# PLEASE UPVOTE!!!!\\n\\n![Screenshot 2023-04-27 at 06.31.03.png](https://assets.leetcode.com/users/images/aee6628c-8232-4912-bbe4-272135d5d9bc_1682557320.3316755.png)\\n\\n\\n# Intuition & Aproach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe solution is based on the observation that a bulb will be toggled an even number of times (including zero) if it has an even number of divisors, and an odd number of times if it has an odd number of divisors. A bulb will have an odd number of divisors if and only if it is a perfect square, because each divisor less than the square root of the number corresponds to a divisor greater than the square root of the number. Therefore, the number of bulbs that are on after n rounds is equal to the number of perfect squares less than or equal to n, which is equal to the floor of the square root of n.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(logN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int) Math.sqrt(n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int) Math.sqrt(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1161362,
                "title": "java-code-with-explanation",
                "content": "Each bulb is initially switched OFF. \\nAfter the first round, \"every first bulb\" (i.e. each bulb) is toggled and thus switched ON.\\nAfter the second round, every second bulb is toggled.\\n.\\n.\\n.\\nAfter the ith round, every ith bulb is toggled.\\n\\nSo, for example, the 20th bulb is toggled in the following rounds : 1,2,4,5,10,20.\\nThe 25th bulb is toggled every 1st,5th and in the 25th round. \\n\\nNotice that the number of times each bulb is toggled is equal to the number of its factors.\\nAlso notice that if we toggle a bulb even number of times, it goes back to its original OFF state.\\n\\nSince every number,except perfect squares, has an even number of factors, the number of bulbs in the ON state after n toggles will be equal to the number of perfect squares <= n.\\n```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        //find all perfect squares less than or equal to n\\n        int count =0;\\n        for(long i=1;i*i<=n;i++){\\n            count++;\\n        }\\n        return count;\\n    }\\n\\n}\\n\\n```\\nor simply,\\n```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n    \\n        return (int)Math.floor(Math.sqrt(n));\\n    }\\n\\n}\\n```\\n\\n********",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        //find all perfect squares less than or equal to n\\n        int count =0;\\n        for(long i=1;i*i<=n;i++){\\n            count++;\\n        }\\n        return count;\\n    }\\n\\n}\\n\\n```\n```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n    \\n        return (int)Math.floor(Math.sqrt(n));\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 445042,
                "title": "java-one-line-code-with-explanation",
                "content": "# Explanation taken from CTCI\\nWe can tackle this problem by thinking through what it means for a door to be toggled. This will help us\\ndeduce which doors at the very end will be left opened.\\n\\n**Question: For which rounds is a door toggled (open or closed)?**\\nA door n is toggled once for each factor of n, including itself and 1. That is, door 15 is toggled on rounds 1,\\n3, 5, and 15.\\n\\n**Question: When would a door be left open?**\\nA door is left open if the number of factors (which we will call x) is odd. You can think about this by pairing\\nfactors off as an open and a close. If there\\'s one remaining, the door will be open.\\n\\n**Question: When would x be odd?**\\nThe value x is odd if n is a perfect square. Here\\'s why: pair n\\'s factors by their complements. For example,\\nif n is 36, the factors are (1, 36), (2, 18), (3, 12), (4, 9), (6, 6). Note that (6, 6) only contributes one factor, thus\\ngiving n an odd number of factors.\\n\\n**Question: How many perfect squares are there?**\\nIf n was 100, there are 10 perfect squares in it. You could count them (1, 4, 9, 16, 25, 36, 49, 64, 81, 100), or you could simply realize that you can take the numbers 1 through 10 and square them:\\n1 * 1, 2 * 2, 3 * 3, ... , 10 * 10\\n\\nTherefore, there are **sqrt(n)** lockers open at the end of this process.\\n```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77129,
                "title": "c-solution-with-0ms",
                "content": "    We are toggling the nth bulb that much number of times as much there are factors of it. Thus number i with even number of factors will be off and bulb at number j with odd number of factors will be on.\\n    And only square numbers have odd number of factors. E.g 1(only 1), 4(1,2,4) ,  9(1,3,9), 16(1,2,4,8,16)...and so on...thus we have to find number of perfect squares within n which can be simply reduced to square root of n.\\n    \\n        int bulbSwitch(int n) {\\n            int i;\\n            for(i=1; i*i<=n; i++);\\n            return i-1;\\n        }",
                "solutionTags": [],
                "code": "    We are toggling the nth bulb that much number of times as much there are factors of it. Thus number i with even number of factors will be off and bulb at number j with odd number of factors will be on.\\n    And only square numbers have odd number of factors. E.g 1(only 1), 4(1,2,4) ,  9(1,3,9), 16(1,2,4,8,16)...and so on...thus we have to find number of perfect squares within n which can be simply reduced to square root of n.\\n    \\n        int bulbSwitch(int n) {\\n            int i;\\n            for(i=1; i*i<=n; i++);\\n            return i-1;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 77102,
                "title": "python-four-solutions-without-sqrt",
                "content": "Sqrt solution is very easy to get but not CS to me. I believe there are people like me really want to find out a CS solution which can be accepted by OJ. Here is what I tried. Please let me know if you have some other thoughts. Thank you.\\n\\n1. making use of numpy array: this is not acceptable because numpy array is not implemented in leetcode. You can run it locally if interested.\\n```\\na = [0]*(n+1)\\na = numpy.array(a)\\nfor i in xrange(1,n+1):\\n    a[::i] = 1-a[::i] \\nreturn sum(a[1:])\\n```\\n2. Similar to the first one but without numpy, O(n^2) time complexity and time limit exceeded at 999999, however, numpy solution is twice as faster as this one when n == 7000000. I am not sure if there is a chance that numpy solution can be accepted or not. What I do not understand is why that the same idea but implemented by other programming language can be accepted by OJ. Should`t Python be much faster than programming language such as Java ? \\n```\\na = [0]*(n+1)\\nfor i in xrange(1,n+1):\\n    for j in xrange(0,n+1,i):\\n        a[j] = 1 -a[j]\\nsum(a[1:])\\n```\\n3. Bit manipulation. TLE. /sign\\n```\\na = \"0\"*(n)\\nfor i in xrange(0,n):    \\n    b = ((\"0\"*i+\"1\")*(2*n/(i+1)))[:n]\\n    a = str(bin(int(a,2)^int(b,2)))[2:]\\nreturn a[:].count(\"1\")\\n```\\n4. This is a python version of the solution I got from https://discuss.leetcode.com/topic/38032/c-version-beats-90-in-less-than-30-lines-of-code/2 \\nI do not quite understand the explanation behind it but I found it was a variant of sqr(), though no multiply operation included. \\n```\\nres, p = 0, 0\\nif n == 0:\\n    return 0\\nelif n <4:\\n    return 1\\nelif n == 4:\\n    return 2\\nfor i in xrange(3,n+1,2):\\n    res += 1\\n    p += i\\n    if (n <= p):\\n        break\\nreturn res   \\n```\\nSeemingly method 4 does not look like sqrt(), it make use of the property of square numbers.\\nThe difference between two square numbers` different is 2: \\neg. \\n```\\noriginal number     square number    difference\\n1                      1                          \\n2                      4             3   \\uff084-1\\uff09\\n3                      9             5   \\uff089-4\\uff09\\n4                     16             7   \\uff0816-7\\uff09\\n5                     25             9    \\uff0825-16\\uff09\\n```\\nThat`s why we say it is a variance of sqrt().",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\na = [0]*(n+1)\\na = numpy.array(a)\\nfor i in xrange(1,n+1):\\n    a[::i] = 1-a[::i] \\nreturn sum(a[1:])\\n```\n```\\na = [0]*(n+1)\\nfor i in xrange(1,n+1):\\n    for j in xrange(0,n+1,i):\\n        a[j] = 1 -a[j]\\nsum(a[1:])\\n```\n```\\na = \"0\"*(n)\\nfor i in xrange(0,n):    \\n    b = ((\"0\"*i+\"1\")*(2*n/(i+1)))[:n]\\n    a = str(bin(int(a,2)^int(b,2)))[2:]\\nreturn a[:].count(\"1\")\\n```\n```\\nres, p = 0, 0\\nif n == 0:\\n    return 0\\nelif n <4:\\n    return 1\\nelif n == 4:\\n    return 2\\nfor i in xrange(3,n+1,2):\\n    res += 1\\n    p += i\\n    if (n <= p):\\n        break\\nreturn res   \\n```\n```\\noriginal number     square number    difference\\n1                      1                          \\n2                      4             3   \\uff084-1\\uff09\\n3                      9             5   \\uff089-4\\uff09\\n4                     16             7   \\uff0816-7\\uff09\\n5                     25             9    \\uff0825-16\\uff09\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 77142,
                "title": "i-s-a-math-problem-not-a-programming-problem",
                "content": "     public int bulbSwitch(int n) {\\n            \\n            return (int) Math.sqrt(n);\\n        }\\n\\nOnly problem is to prove this is correct. Don't think this is a good programming / algorithm problem though. Just by observing sequences will probably found the trick",
                "solutionTags": [],
                "code": "     public int bulbSwitch(int n) {\\n            \\n            return (int) Math.sqrt(n);\\n        }\\n\\nOnly problem is to prove this is correct. Don't think this is a good programming / algorithm problem though. Just by observing sequences will probably found the trick",
                "codeTag": "Unknown"
            },
            {
                "id": 3459085,
                "title": "python-3-1-line-w-explanation-t-m-99-94",
                "content": "Here\\'s the intuition:\\n\\n1. A light switch is a toggle with two states,`off`and`on`, and in this problem the initial state is`off`, so reason tells us that the bulbs that will be`on`at the end are those with an odd number of divisors.\\n2. Consider lightbulb`k`, where`0 <= k <= n-1`. For every divisor`d`of`k`, `k//d` is also a divisor, and reason also tells us that`d*(k//d) = k`. Also,`k`can have an odd number of distinct divisors if and only if`k = d*d`for exactly one divisor`d`, which is true if and only if `k`is a perfect square.\\n3. From 2) above, the answer to the problem is the integer part of the square root of`n`.\\n```\\nclass Solution:     \\n    def bulbSwitch(self, n: int) -> int:\\n        \\n        return isqrt(n) \\n```\\n[https://leetcode.com/submissions/detail/674479447/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(log*n*) and space complexity is *O*(1).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:     \\n    def bulbSwitch(self, n: int) -> int:\\n        \\n        return isqrt(n) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459055,
                "title": "easy-solution-of-java-c-100-faster-code-one-liner-beginner-friendly",
                "content": "\\n\\n# Code\\n  PLEASE UPVOTE IF YOU LIKE.\\n```\\n  class Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);\\n    }\\n}\\n```\\nC++\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return sqrt(n);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  class Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return sqrt(n);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77146,
                "title": "one-line-python-solution-of-o-1",
                "content": "    class Solution(object):\\n        def bulbSwitch(self, n):\\n            return int(n**(0.5))",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def bulbSwitch(self, n):\\n            return int(n**(0.5))",
                "codeTag": "Java"
            },
            {
                "id": 1579209,
                "title": "1-liner-soln-c-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        \\n        return sqrt(n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        \\n        return sqrt(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77103,
                "title": "sharing-how-i-came-up-with-the-sqrt-n-solution-factorization",
                "content": "...\\nimport java.lang.Math;\\npublic class Solution {\\n    public int bulbSwitch(int n) {\\n        if(n<=0)\\n          return 0;\\n        else return (int)Math.sqrt(n);\\n    }\\n}\\n...\\n\\nThe code is simple, so what I post to share is how I came up with this solution\\n1. At first, I try some cases to discover the pattern behind solution. And I find out that:\\n   Considering two consecutive numbers N-1 and N, the only difference for the two cases is decided by the on/off state of the last bulb--      the N-th bulb.\\n   So what leaves to us now is the state of the N-th bulb, and it's not hard to find out that the state of N-th bulb is decided by how many integer factors it has. Specifically if N has an odd number of  integer factors , the N-th bulb will be on, and otherwise off.  \\n2. Then I find only when a number is a square number ,will it has an odd number of integer factors. Because all factors always appear pair-wise  expect the square root of the square number. \\n    For instance, with 9, it has 3 integer factors (1,3,9) which resulted from \\n   9=1X9 (1,9),   9=3X3 (3)\\n   So it is turned on on the 1st round , turned off on the 3nd, and turned on on the 9th. So finally it is on\\n   Another instance, with 10, integer factors are (1,2,5,10) So finally off. The same case with 11,12,....up to 15.\\n  It changes when it reaches 16, the same with 9, so one more bulb is on.\\n3. Sort out the above mentioned, we can figure out, considering in sequence from 1,2... to n  the answer is to increment 1 every time you encounter a square number. So final answer is Sqrt(n).",
                "solutionTags": [],
                "code": "class Solution {\\n    public int bulbSwitch(int n) {\\n        if(n<=0)\\n          return 0;\\n        else return (int)Math.sqrt(n);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3459187,
                "title": "best-easiest-1-liner-solution-out-there-in-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int) Math.sqrt(n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int) Math.sqrt(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459054,
                "title": "prefix-sum-inclusive-scan",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe bulb will be off or on it really depends on their no of divisor. Suppose, a bulb has a number, n = 6 having diviors {1,2,3,6} then it\\'ll be on->off->on->off. And if n = 9, having divisor {1,3,9} then it\\'ll be on->off->on. So, we can conclude that if no. of diviors of n is odd then it\\'ll be on in the end else off. \\nBut, we can\\'t do brute force here cuz the constraint n=1e9. So, we can observe something like this if no of bulb is n then for \\nn = 0 -> 0\\nn = 1 -> 1\\nn = 2 -> 1\\nn = 3 -> 1\\nn = 4 -> 2\\nn = 5 -> 2\\nn = 6 -> 2\\nn = 7 -> 2\\nn = 8 -> 2\\n... \\nsimilary from n = [9,15] -> 3\\nso, we can see that \\n0 occur 0 times\\n1 occur 3 times\\n2 occur 5 times\\n3 occur 7 times\\n...\\nso, it\\'ll form an of sequence 0,3,5,7,9,11,13,....\\nand now if we ignore 0 then it form an AP having common difference 2. So, we can just populate this AP for n=1e5 in vector. And do the prefix sum of this array. Then, the lower bound will be our answer because it\\'ll store till what bulb what will be the our answer.\\n\\n* Inclusive scan fuction is similar to partial sum. we can also use partial sum or we can simply calculate itself in the first single iteration just do like v[i] = v[i-1] + i\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        vector<long long> v{0};\\n        for(int i=3; i<=100000; i+=2) v.push_back(i);\\n        inclusive_scan(begin(v),end(v),begin(v),plus(),0ll);\\n        return lower_bound(begin(v),end(v),n)-begin(v);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Brainteaser",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        vector<long long> v{0};\\n        for(int i=3; i<=100000; i+=2) v.push_back(i);\\n        inclusive_scan(begin(v),end(v),begin(v),plus(),0ll);\\n        return lower_bound(begin(v),end(v),n)-begin(v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1633360,
                "title": "java-o-1-pure-math-explained",
                "content": "A lightbulb stays on if we flip it `even` times. At `i th` rounds, we flip a lightbulk that contains factor `i` , so now the question becomes how to determine the total number of number `<= n` that contains even number of factors excluding 1, or in other words, odd number of factors including 1. \\n\\nAny positive whole number can be expressed as `num = a^x * b^y * ... ` where `a, b, ...` are primes, and its number of factors can be determined as ` K = (x + 1) * (y + 1) *...`, we want `K` to be an odd number, so it means `x, y, ...`, they all have to be even. In other words, `num` has to be a perfect square.\\n\\n```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467416,
                "title": "python-explained",
                "content": "For number *n*, all the numbers *i,* which are less than n, would have reached there final state. For eg, consider n = 3, and i =2, for the third round of toggling, where we will toggle lights which are multiples of 3, there is no effect on light 2, since it\\'s final state has been achieved. \\n\\n```\\nFirst Turn      1 1 1\\nSecond Turn     1 0 1\\nThird Turn      1 0 0\\n```\\nSimilary for any number which is not a perfect square, will have the final state as Off. Consider, 2, the final state of bulb 2 after 2 rounds is off. Similary the final state of bulb 3, is off after round 3. And for numbers greater than 3, there will be no effect on the state of bulbs with numbers less than that.\\n\\nLike in round 7, bulb 5 would have no change.\\n\\nThe case when the no is a perfect square, the final state will be on. Consider, 4, \\n```\\nFirst  1 1 1\\nSecond  1 0 1 0\\nThird  1 0 0 0\\nFourth  1 0 0 1\\n```\\n\\nBulb 4, will have a change of state at 1, 2, 4. Similarly Bulb 9 will have a change of state at 1,3, 9.\\n\\nLet us analyse the no. of bulbs that will be on when n = 4, 1 will be on, 2 and all the factors of two would have toggled, 3 and all its factors would have toggled. 4 will only toggle its bulb in the 4th round. Hence, only 2 bulbs remain. \\n\\nwhen n = 9, only 1, 4, 9 will remain on. which is basically like finding all the perfect squares present in the range 1, N. Which is equivalent to finding, the square root of the no, since the range is uniform and increasing. \\n\\nNo of sqaures in the range 1, ..9 : 1, 4, 9\\n9 is the square of 3. \\nFor no. [n], which is a square of no. [m]. The no. of perfect squares in the range 1..n will be m, since squares of no. less than m, will be less than n. \\n\\n\\n```\\ndef bulbSwitch(self, n: int) -> int:\\n        return int(n**(0.5))\\n```\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nFirst Turn      1 1 1\\nSecond Turn     1 0 1\\nThird Turn      1 0 0\\n```\n```\\nFirst  1 1 1\\nSecond  1 0 1 0\\nThird  1 0 0 0\\nFourth  1 0 0 1\\n```\n```\\ndef bulbSwitch(self, n: int) -> int:\\n        return int(n**(0.5))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1425900,
                "title": "explained-in-detail",
                "content": "# **Idea**\\n1. All the numbers will be OFF at start **(Turn 1)** , and next time they will be ON **(Turn 2)** , again turn OFF in **(Turn 3)**  and so on..\\n\\n2. Observation, bulb is ON when it is having **odd turn**. \\n\\n3. So, in order to find if nth bulb is on we need to find how many times that bulb is switched, if that number is ODD, then buld is ON, else OFF.\\n\\n4. We simply can calculate factors to know how many times bulb is switched. Eg. 4th bulb... this will be switched ON by 1st turn, OFF by 2nd turn, ON by 4th turn.\\n\\n5. Simple Maths, all factors of a number exist in pairs, Eg. 7 = 7 x 1, 15 = 3 x 5 x 15 x 1, exception.. Eg. 4 = 1 x 2 x 4,    9 = 1 x 3 x 9, here it just have 3 factors, HOW? 1 x 3 x 9 (3 x 3),,, 9 is hiding the factors in itself.\\n\\n6. So, the problem brokes down to finding perfect squares between 1 to N.\\n\\n7. A simple formula to find perfect square is - **floor(sqrt(n))** \\n\\n# Code - \\n\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return (int)sqrt(n);\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/6195e5f2-b9bb-4090-999e-84c00c30f247_1629908063.9719772.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return (int)sqrt(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1220041,
                "title": "python3-simple-one-liner-solution",
                "content": "```\\nclass Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return int(n**0.5)\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return int(n**0.5)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461654,
                "title": "bulb-switcher-c-solution-in-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute Force Approach - The most basic solution/approach that comes in mind is that run an outer loop n times and in the inner loop increment the variable (j) according to the value of i (variable of outer loop). In this way, you will iterate directly to the ith position and toggle the values.\\nThis approach had a time complexity of O(n^2).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf you analyze the problem for various test cases, you could observe that the final output is the largest number whose perfect square is less than or equal to the input parameter.\\n\\nFor Example:- \\n\\n         For n=10, Output is 3.\\n            3^2 => 9 <= 10\\n         For n=103, Output is 10.\\n            10^2 => 100 < 103\\n         On the other hand, n=94, Output is 9.\\n            9^2 => 81 < 94, whereas 10^2 => 100 > 94.\\n         For n=100, Output = 10.\\n            10^2 => 100 <= 100\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity of Brute Force Approach = O(n^2)\\nTime Complexity of My Approach = O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        int ans = 0;\\n        \\n        for (int i=1; i<=sqrt(n); i++)\\n        {\\n            \\n            int temp = i*i;\\n            \\n            if (temp <= n){\\n                ans = i;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        int ans = 0;\\n        \\n        for (int i=1; i<=sqrt(n); i++)\\n        {\\n            \\n            int temp = i*i;\\n            \\n            if (temp <= n){\\n                ans = i;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458996,
                "title": "daily-leetcoding-challenge-april-day-27",
                "content": "This problem is the Daily LeetCoding Challenge for April, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/bulb-switcher/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/bulb-switcher/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 770502,
                "title": "solving-it-by-brute-force-then-use-observation",
                "content": "First, let it try brute forcing this question like this:\\n```\\ndef run(n):\\n\\tl=[False]*n\\n\\tfor step in range(1,n+1):\\n\\t\\tfor i in range(-1,n+1,step):\\n\\t\\t\\tl[i]=not l[i]\\n\\tcnt=0\\n\\tfor i in range(0,n+1):\\n\\t\\tif l[i]==true:\\n\\t\\t\\tcnt=cnt+1\\n\\treturn cnt\\n\\tfor i in range(1,101):\\n\\t\\tprint(run(i))\\n```\\n\\nIt will print the result in [0,100], like this:\\n\\n```\\n1\\n1\\n1\\n2\\n2\\n2\\n2\\n2\\n3\\n3\\n3\\n3\\n3\\n3\\n3\\n4\\n4\\n4\\n4\\n4\\n4\\n4\\n4\\n4\\n5\\n5\\n5\\n5\\n5\\n5\\n5\\n5\\n5\\n5\\n5\\n6\\n6\\n6\\n6\\n6\\n6\\n6\\n6\\n6\\n6\\n6\\n6\\n6\\n...(omitted)\\n```\\n\\nThen you could found that their are `1`x3, then `2`x5, then `3`x7 and so on. So we can have a naive solution here:\\n\\n```\\nclass Solution {\\n   public:\\n\\tint bulbSwitch(int n) {\\n\\t\\tif (n == 0)\\n\\t\\t\\treturn 0;\\n\\t\\tint sum = 0, i;\\n\\t\\tfor (i = 1; sum < n; i++) {\\n\\t\\t\\tsum += (2 * i + 1);\\n\\t\\t}\\n\\t\\treturn i - 1;\\n\\t}\\n};\\n```\\n\\nBut how would you turn it into `sqrt(n)` solution? This requires more observation.\\nYou notice the first appearence of `1` is at 1, `2` is at 1+3=4, `3` is at 1+3+5=9, and `4` is at 1+3+5+7=16. These numbers looks like perfect squares right? Actually, you can prove that `sum 2*i-1 from i=1 to n` is `n^2` using some math.\\n\\nSo, we can have out final solution:\\n\\n```\\nclass Solution {\\n   public:\\n\\tint bulbSwitch(int n) { return sqrt(n); }\\n};\\n```\\n\\nAppendix: You can also search that sequence at OEIS like [this](https://oeis.org/search?q=1%2C1%2C1%2C2%2C2%2C2%2C2%2C2%2C3%2C3%2C3%2C3%2C3%2C3%2C3&language=english&go=Search), then it will tell it is integer part of sqrt(n).",
                "solutionTags": [],
                "code": "```\\ndef run(n):\\n\\tl=[False]*n\\n\\tfor step in range(1,n+1):\\n\\t\\tfor i in range(-1,n+1,step):\\n\\t\\t\\tl[i]=not l[i]\\n\\tcnt=0\\n\\tfor i in range(0,n+1):\\n\\t\\tif l[i]==true:\\n\\t\\t\\tcnt=cnt+1\\n\\treturn cnt\\n\\tfor i in range(1,101):\\n\\t\\tprint(run(i))\\n```\n```\\n1\\n1\\n1\\n2\\n2\\n2\\n2\\n2\\n3\\n3\\n3\\n3\\n3\\n3\\n3\\n4\\n4\\n4\\n4\\n4\\n4\\n4\\n4\\n4\\n5\\n5\\n5\\n5\\n5\\n5\\n5\\n5\\n5\\n5\\n5\\n6\\n6\\n6\\n6\\n6\\n6\\n6\\n6\\n6\\n6\\n6\\n6\\n6\\n...(omitted)\\n```\n```\\nclass Solution {\\n   public:\\n\\tint bulbSwitch(int n) {\\n\\t\\tif (n == 0)\\n\\t\\t\\treturn 0;\\n\\t\\tint sum = 0, i;\\n\\t\\tfor (i = 1; sum < n; i++) {\\n\\t\\t\\tsum += (2 * i + 1);\\n\\t\\t}\\n\\t\\treturn i - 1;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\n   public:\\n\\tint bulbSwitch(int n) { return sqrt(n); }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461796,
                "title": "simple-c-code-runtime-that-beats-100-and-memory-that-beats-94-time-and-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the code is based on the observation that a bulb will be toggled once for each factor it has. For example, the 6th bulb will be toggled on rounds 1, 2, 3, and 6, since it has factors 1, 2, 3, and 6. Bulbs that are toggled an even number of times will be off, while bulbs that are toggled an odd number of times will be on.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach behind this code is\\n\\nFor the first round\\n----------------------------------------\\n all bulbs are turned on.\\n\\nFor the second round\\n---\\n every second bulb is toggled, which means that bulbs with even indices are toggled once and then toggled again, so they end up off. Bulbs with odd indices are toggled only once, so they end up on.\\n\\nFor the third round\\n------\\n every third bulb is toggled. This means that bulbs with indices that are multiples of 3 will be toggled three times: once on round 1, once on round 3, and once on round 6. So any bulb with an index that has an odd number of factors will end up on, while bulbs with an even number of factors will end up off.\\n\\nFor the ith round\\n------------------- \\nevery ith bulb will be toggled. This means that bulbs with indices that are multiples of i will be toggled i times. So any bulb with an index that has an odd number of factors will end up on, while bulbs with an even number of factors will end up off.\\n\\nThe final result\\n------------------\\n is the number of bulbs that end up on after n rounds, which is equal to the number of perfect squares less than or equal to n, because a number has an odd number of factors if and only if it is a perfect square. The code calculates this by iterating through all numbers less than or equal to n and counting the number of perfect squares.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(sqrt(n))\\n-------------\\n the loop runs for sqrt(n) iterations, the time complexity of the code is O(sqrt(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n------------------\\nthe space complexity is O(1), because the code only uses a single integer variable to keep track of the count of perfect squares.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n         int count = 0;\\n    for (int i = 1; i * i <= n; i++) {\\n        count++;\\n    }\\n    return count; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Brainteaser",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n         int count = 0;\\n    for (int i = 1; i * i <= n; i++) {\\n        count++;\\n    }\\n    return count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460539,
                "title": "very-simple-explanation-c-logn",
                "content": "# Intuition\\nThis is a little bit tricky one.\\nAvoid question\\'s explanation you just have to do one thing: \\nOn each iteration you have to change that bulb\\'s phase and the multiples of that bulb also (means if it is on->off or off->on).\\n\\nExample: (Initially all bulbs are off)\\n\\nFor Iteration 1: turn on bulb number 1 and multiples of it also turned on.\\n\\nFor Iteration 2: turn off bulb number 2 and multiples of 2 also (if on->off or if off->on)\\n\\nFor Iteration 3: turn off bulb number 3(if it\\'s on) and multiples of 3 also (if on->off or if off->on)\\n.\\n.\\n.\\n.so on\\n\\nIf you observe the pattern for some values of `n` you will find the answer is integer part of `sqrt(n)`\\n\\nExample:\\nn=1: 1\\nn=2: 1\\nn=3: 1\\nn=4: 2\\nn=5: 2\\nn=6: 2\\nn=7: 2\\nn=8: 2\\nn=9: 3\\nn=10: 3\\n\\n`Note`: Above explanation is not for n=0, if n=0 it will return 0;\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return sqrt(n);\\n    }\\n};\\n```\\n\\n![please upvote.png](https://assets.leetcode.com/users/images/d4485104-ce50-4534-bb14-f2b3d996ac06_1682596778.9272993.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return sqrt(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459172,
                "title": "cpp-easiest-solution-o-sqrt-n-3ms",
                "content": "# Intuition\\nI observed that if the index of a bulb is a perfect square, it will be toggled an even number of times, specifically the number of factors it has (including 1 and itself), which is always odd for perfect squares. Therefore, you only need to count the number of perfect squares less than or equal to n to determine the number of bulbs that will be on at the end.\\n\\n\\nLets take some eg. \\n1)n=4\\n  i=1 -> 1 1 1 1\\n  i=2 -> 1 0 1 0\\n  i=3 -> 1 0 0 0\\n  i=4 -> 1 0 0 1\\n\\nso 2 ones are there so ans would be 2,\\nyou can see the for the i (i=perf. square) its value was 1st toggled by 2, but then finally it is also toggled by 4 itself.\\n\\n2)n=4\\n  i=1 -> 1 1 1 1 1\\n  i=2 -> 1 0 1 0 1\\n  i=3 -> 1 0 0 0 1\\n  i=4 -> 1 0 0 1 1\\n  i=5 -> 1 0 0 1 0\\n\\nhere in bw 1 to 5 there are 2 perfect sq. 1 and 4 and you can see here 4 is toggled even by index=2 and 4, i.e even times so it remained 1, i.e if the index is perfect square then it will remain 1,\\nso my ans is 2\\n\\n\\n\\nSo you can observe it by taking few cases , that the no. of lights on will be equal to no of perfect square in bw 1 to n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(sqrt(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n    int i=0, cnt=0;\\n    while(i*i<=n)\\n    {\\n        cnt++;\\n        i++;\\n    }\\n    return cnt-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n    int i=0, cnt=0;\\n    while(i*i<=n)\\n    {\\n        cnt++;\\n        i++;\\n    }\\n    return cnt-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459047,
                "title": "0-line-solution-for-fun",
                "content": "Technically still 2 lines there but heh\\n\\n# Code\\n```\\nclass Solution:\\n    bulbSwitch = isqrt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    bulbSwitch = isqrt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458999,
                "title": "c-one-liner-easy-understanding",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        int sum=0,ans=0,cnt=0;\\n        for(int i=1; i<=n; i+=2)\\n        {\\n            sum = sum + i;\\n            if(n<sum)\\n            {\\n                break;\\n            }\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        int sum=0,ans=0,cnt=0;\\n        for(int i=1; i<=n; i+=2)\\n        {\\n            sum = sum + i;\\n            if(n<sum)\\n            {\\n                break;\\n            }\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337659,
                "title": "1-linner-solution-acceptable-for-all-languages-ek-line-ka-jugad",
                "content": "# Intuition\\nMOST JUGADU SOLUTION BY TRIPPY THE CODDER : )\\n\\n# Approach\\nJUST SMIE UNDERSTAND AND IMPLEMENT\\n\\n# Complexity\\nNOTHING COMPLEX\\n\\n# HUMBLE REQUEST\\nPLEASE UPVOTE IF I HELPED YOU\\nTHANK YOU.\\nKEEP IT UP.\\n\\n# Code\\n```\\n//JAVA\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);//PLEASE UPVOTE\\n        }\\n}\\n```\\n# Code\\n```\\n//C++\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n         if(n<=1) return n;\\n        return (int)sqrt(n);\\n    }\\n};\\n```\\n# Code\\n```\\n//PYTHON\\nclass Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return int(n**(1/2))\\n```\\n\\n\\n\\n# Code\\n```\\n//JAVASCRIPT\\nvar bulbSwitch = function(n) {\\n    return parseInt(Math.sqrt(n));\\n};\\n```\\n\\n# PLEASE UPVOTE",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\n//JAVA\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);//PLEASE UPVOTE\\n        }\\n}\\n```\n```\\n//C++\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n         if(n<=1) return n;\\n        return (int)sqrt(n);\\n    }\\n};\\n```\n```\\n//PYTHON\\nclass Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return int(n**(1/2))\\n```\n```\\n//JAVASCRIPT\\nvar bulbSwitch = function(n) {\\n    return parseInt(Math.sqrt(n));\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242096,
                "title": "319-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize a variable count to 0 and a variable i to 1.\\n2. While i*i is less than or equal to n, increment count by 1 and increment i by 1.\\n3. Return the final value of count.\\n\\nThe idea behind this solution is that a bulb will be toggled for each factor it has (excluding 1 and itself). For example, bulb 6 will be toggled by rounds 1, 2, 3, and 6. So if a bulb has an odd number of factors, it will end up on, and if it has an even number of factors, it will end up off. The only bulbs that will end up on are those that have an odd number of factors, which are the perfect squares. So the solution simply counts the number of perfect squares less than or equal to n.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        count = 0\\n        i = 1\\n        while i*i <= n:\\n            count += 1\\n            i += 1\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        count = 0\\n        i = 1\\n        while i*i <= n:\\n            count += 1\\n            i += 1\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 633504,
                "title": "java-brute-force-tle",
                "content": "```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        \\n        // brute force\\n        int total = 0;\\n        for (int i = 1; i < n + 1; i++) {\\n            \\n            boolean on = false;\\n            for (int j = 1; j < n + 1; j++) {\\n                if (i % j == 0)\\n                    on = !on;\\n            }\\n            \\n            total += on ? 1 : 0;\\n        }\\n        \\n        return total;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int bulbSwitch(int n) {\\n        \\n        // brute force\\n        int total = 0;\\n        for (int i = 1; i < n + 1; i++) {\\n            \\n            boolean on = false;\\n            for (int j = 1; j < n + 1; j++) {\\n                if (i % j == 0)\\n                    on = !on;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 516171,
                "title": "simple-explanation",
                "content": "Let\\'s understand the problem first. All the blubs are off at starting. After the first round, all the blub are in on state(1,2,3,4,5,... on blubs).\\nAfter the second round, every second blub will change their state which means blub at position 2,4,6,8,.. change their state. after the third round, every third bulb 3,6,9,12,...(multiple of 3) change their state.\\nNow we can see if we perform odd numbers of operation of a blub then it will be in On state because starting state is off. Blub one(1) is always on because only one operation can be performed on this.\\nNow here we have to find the number of operations on each blub if it\\'s odd then it will be on. We can count the number of operations by using the factors of a number. If the count of a number\\'s factor is odd then blub will be in On state.\\nlet\\'s take an example:\\nn=9 let\\'s count the factors of the number-\\n1 - 1\\n2 - 1,2\\n3 - 1,3\\n4 - 1,2,4\\n5 - 1,5\\n6 - 1,2,3,6\\n7 - 1,7\\n8 - 1,2,4,8\\n9 - 1,3,9\\n\\nWe can see here only number 1,4,9 has the odd number of factors so these blub will be in on state. We know prime number has only two factors(1 and number) so they always in off state and factors always comes in pair for example 8(1 and 8, 2 and 4) except number that has perfect square root for example 9(3*3, 1 and 9) so in this case, 3 comes only once.\\nSo basically we need to calculate how many square numbers are there within a given number. These blub are always on- 1,4,9,16,25,...and so on.\\n\\nJava Program: \\n```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);\\n    }\\n}\\n```\\n[Solution link](https://www.thecodingshala.com/2020/02/leetcode-bulb-switcher-solution-coding-shala.html)",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 376978,
                "title": "javascript-one-line-solution",
                "content": "```\\nvar bulbSwitch = function(n) {\\n    return parseInt(Math.sqrt(n));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar bulbSwitch = function(n) {\\n    return parseInt(Math.sqrt(n));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 77151,
                "title": "it-s-equivalent-to-count-the-square-numbers-no-larger-than-n",
                "content": "    \\n/* For individual bulb, its final state depends on how many times it got toggled, and it equals the number of its distinct factors. If the number is even, the bulb is off, otherwise it's on. We know all numbers factors are even number unless it's a square number. So the problem is equivalent to count the square numbers no larger than n\\n*/\\n\\n    public class Solution {\\n        public int BulbSwitch(int n) {\\n            return (int)Math.Sqrt(n);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int BulbSwitch(int n) {\\n            return (int)Math.Sqrt(n);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 77155,
                "title": "java-o-1-solution-for-real-no-bs-no-sqrt",
                "content": "    public int bulbSwitch(int n) {\\n        return (int) Math.pow(2, 0.5 * (Math.log(n)/Math.log(2)));\\n    }\\n\\nThere is a Math trick to get a rounded to the floor square root of a number (this is exactly what we need since integers get rounded down).\\n\\n1. We can express sqrt(n) as n^0.5, \\n2. then add a log trick: 2^log(base 2)(n^0.5),\\n3. then simplify a little: 2^(0.5*log(base 2)(n)).\\n4. Since java's Math library doesn't have log(base 2), we can get it by log(base e)(n) / log(base e)(2).\\n\\nI looked at Java's Math source code and its log method defaults to the log method of StrictMath. I have a link here for the StrictMath source:\\n\\n[http://developer.classpath.org/doc/java/lang/StrictMath-source.html][1]\\n\\nThe log method is O(1) (I didn't see any loops or recursive calls), although extremely ugly, there is a lot going on in it, and I don't understand most of it :) Another slow-down comes from the pow method, it's also O(1) and even uglier than log :D\\n\\nI also ran a quick speed test for both sqrt and log versions of the bulbSwitch, here are the results ( I ran a few times, the results are relatively consistent) :\\n\\n    bulbSwitchSqrt(5) ------------------------- 35437 ns\\n    bulbSwitchLog(5) -------------------------- 8495 ns\\n    bulbSwitchSqrt(25789104) ------------------ 421 ns\\n    bulbSwitchLog(25789104) ------------------- 822 ns\\n\\nFor very small numbers log method is an order of the magnitude faster than sqrt, for very large numbers they are about the same. From what I read in the source code comments, small values require more precision, so there is more computation going on in both log and sqrt, otherwise sqrt is surprisingly fast.\\n\\nI am not making any claims here, just sharing what I've found out :) Let me know if I made a mistake somewhere or missed anything.\\n\\nCheers.\\n\\n\\n\\n\\n  [1]: http://developer.classpath.org/doc/java/lang/StrictMath-source.html",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int bulbSwitch(int n) {\\n        return (int) Math.pow(2, 0.5 * (Math.log(n)/Math.log(2)));\\n    }\\n\\nThere is a Math trick to get a rounded to the floor square root of a number (this is exactly what we need since integers get rounded down).\\n\\n1. We can express sqrt(n) as n^0.5, \\n2. then add a log trick: 2^log(base 2)(n^0.5),\\n3. then simplify a little: 2^(0.5*log(base 2)(n)).\\n4. Since java's Math library doesn't have log(base 2), we can get it by log(base e)(n) / log(base e)(2).\\n\\nI looked at Java's Math source code and its log method defaults to the log method of StrictMath. I have a link here for the StrictMath source:\\n\\n[http://developer.classpath.org/doc/java/lang/StrictMath-source.html][1]\\n\\nThe log method is O(1) (I didn't see any loops or recursive calls), although extremely ugly, there is a lot going on in it, and I don't understand most of it :) Another slow-down comes from the pow method, it's also O(1) and even uglier than log :D\\n\\nI also ran a quick speed test for both sqrt and log versions of the bulbSwitch, here are the results ( I ran a few times, the results are relatively consistent) :\\n\\n    bulbSwitchSqrt(5) ------------------------- 35437 ns\\n    bulbSwitchLog(5) -------------------------- 8495 ns\\n    bulbSwitchSqrt(25789104) ------------------ 421 ns\\n    bulbSwitchLog(25789104) ------------------- 822 ns\\n\\nFor very small numbers log method is an order of the magnitude faster than sqrt, for very large numbers they are about the same. From what I read in the source code comments, small values require more precision, so there is more computation going on in both log and sqrt, otherwise sqrt is surprisingly fast.\\n\\nI am not making any claims here, just sharing what I've found out :) Let me know if I made a mistake somewhere or missed anything.\\n\\nCheers.\\n\\n\\n\\n\\n  [1]: http://developer.classpath.org/doc/java/lang/StrictMath-source.html",
                "codeTag": "Java"
            },
            {
                "id": 3459600,
                "title": "easiest-1line-c-solution-complete-explanation-t-c-o-logn-s-c-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter seeing the constraints of the question it becomes quite clear that an approach of O(n) will not be sufficient for it and we need to come up with an approach of O(logn).\\nWe dey run the code and get the following results-\\n\\nFor n=1 we get answer=1\\nFor n=2 we get answer=1\\nFor n=3 we get answer=1\\nFor n=4 we get answer=2\\nFor n=9 we get answer=3\\nFor n=16 we get answer=4\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAfter doing run for a lot of cases a common thing is being observed as the anwer is always sqaure root of n.\\nSo we need to find out square root of the given number n.\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) // no extra space is used\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return sqrt(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return sqrt(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3133275,
                "title": "100-fastest-and-easiest-c-solution-beginner-friendly-easy-to-understand",
                "content": "# Intuition\\nTry to catch the pattern\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFor 1st bulb, 1 bulb will be on, for the next 3 bulbs, 2 bulbs will be on, for the next 5 bulbs, 3 bulbs will be on and the pattern goes so on\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        int sum=0,ans=0,c=0;\\n        for(int i=1; i<=n; i+=2)\\n        {\\n            \\n            sum = sum + i;\\n            if(n<sum)\\n            {\\n                break;\\n            }\\n            c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        int sum=0,ans=0,c=0;\\n        for(int i=1; i<=n; i+=2)\\n        {\\n            \\n            sum = sum + i;\\n            if(n<sum)\\n            {\\n                break;\\n            }\\n            c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1541982,
                "title": "golang-math-solution-with-explanation-and-images",
                "content": "Note: If you don\\'t understand this problem, think of it as something similar to *Seive of Eratosthenes*.\\n\\nAt first I didn\\'t understand how to go about this problem, so I drew it out. I made a graph that might be easier to understand than my drawing:\\n\\n![](https://i.imgur.com/MZP1ibF.png)\\n\\n* In this graph the numbers represent what round we are on (Y-axis = what round we are on).\\n* And the bulbs represent each bulb (X-axis = what bulb we are on).\\n* The yellow dots represent the bulb being on.\\n* While the empty boxes in the graph represent the bulb being off.\\n\\nIf we do this for many different `n` we can see a pattern:\\n\\n![](https://i.imgur.com/GcFJxKr.png)\\n\\n\\n* In each of the example I only show the end result to save space.\\n* The numbers are to show the round, and bulb number.\\n* The yellow dots represent the bulbs that are on\\n* I went through a much more excessive messy list of examples, but have shortened it for this this solution.\\n\\n**The Explanation:**\\n\\nIf you notice, the only bulbs that end up on are the squares because squares are the only numbers that have an odd number of non-repeating divisors. \\n\\n* The divisors of `36` are `1, 6, 6, 36`, and the non-repeating divisors are `1, 6, 36`.\\n* The divisors of `9` are `1, 3, 3, 9`, and the non-repeating divisors are `1, 3, 9`.\\n* The divisors of `12` (Not a square) are `1, 3, 4, 12`.\\n* The divisors of `26` (Not a square) are `1, 2, 13, 26`.\\n* The divisors of `13` (Not a square) are `1, 13`.\\n\\nAs you can see, the primes have an odd number of non-repeating divisors, while non-primes have an even number of non-repeating divisors. \\n\\nSince squares have an odd number of non-repeating divisors, they will toggle an odd number of times and end up lit up.\\n\\n* `1` toggles at `1` and is always lit up.\\n* `4` is first toggled at `1`, then `2`, and then `4`.\\n* `9` is first toggled at `1`, then `3`, and then `9` again.\\n* `16` is first toggled at `1`, then `2`, `4`, `8`, and `16`.\\n\\n***\\n\\nIf you don\\'t understand how we are toggling `1`, it is based on the problem statement:\\n\\n> There are n bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb.\\n\\nWhen they say, \"You first turn on all the bulbs,\" they mean to toggle on all the bulbs from the first round.\\n\\n``` go\\nfunc bulbSwitch(n int) int {\\n    return int(math.Sqrt(float64(n)))\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nfunc bulbSwitch(n int) int {\\n    return int(math.Sqrt(float64(n)))\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1156154,
                "title": "c-explanation-of-code-easy",
                "content": "The logic behind code is - A bulb is toggled in ith iteration if i divides bulb. For example the bulb number 45 is toggled in 1st, 3rd, 5th, 9th ,15th and 45th iteration. After every even number of toggles bulb will retain its original state i.e OFF. Every number have their factors in pairs thus they will remain in OFF state. Only for perfect squares there would be odd number of toggles as their two factors are same which makes total of odd number of factors. Ex - For 16 - 1, 2, 4, 8 and 16. So answer is count of perfect squares till N.\\n\\n\\t\\t\\t\\tint bulbSwitch(int n) \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\t\\tfor(long long i = 1; i <= n; i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(i * i <= n)\\n\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn count;\\n\\n\\t\\t\\t\\t\\t//2 method\\n\\t\\t\\t\\t\\t//return floor(sqrt(n));\\n                }\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "The logic behind code is - A bulb is toggled in ith iteration if i divides bulb. For example the bulb number 45 is toggled in 1st, 3rd, 5th, 9th ,15th and 45th iteration. After every even number of toggles bulb will retain its original state i.e OFF. Every number have their factors in pairs thus they will remain in OFF state. Only for perfect squares there would be odd number of toggles as their two factors are same which makes total of odd number of factors. Ex - For 16 - 1, 2, 4, 8 and 16. So answer is count of perfect squares till N.\\n\\n\\t\\t\\t\\tint bulbSwitch(int n) \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\t\\tfor(long long i = 1; i <= n; i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(i * i <= n)\\n\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn count;\\n\\n\\t\\t\\t\\t\\t//2 method\\n\\t\\t\\t\\t\\t//return floor(sqrt(n));\\n                }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 929525,
                "title": "maths-solution-python-in-o-1",
                "content": "The solution to that problem is quite simple when you think about it logically. A bulb will be turned off when it is switched an odd number of times: OFF, ON, OFF for instance. \\n\\nThis means that we need to find numbers which have an odd number of divisors. If a number like 10 has an even number of them: 1,2,5 and 10; a number like 9 will have an odd number of them: 1,3 and 9. By testing a few numbers, we realise that all numbers with integer square roots will have an odd number of divisors. Hence, the solution is as follows:\\n\\n```\\nclass Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return int(sqrt(n))\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return int(sqrt(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825836,
                "title": "java-one-liner-explaination-simple-observation-of-math-0ms-solution",
                "content": "Consider each number right from 1,2,3.....N\\nEvery swich is on. If switch is to change its state, then that particular number should have odd number of factors. Think about only that switch. Lets say number 5. 5 will be hit by 1 and 5 , it has even factors, so there will no change in state. Guess which numbers have odd number of factors ? Yes, perfect squares have odd no of factors. They will be hit by odd times, leaving their position changed. \\nSo at last perfect squares will be the numbers which are on now.\\n```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 797704,
                "title": "c-one-liner-o-1-super-simple-solution-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return floor(sqrt(n));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return floor(sqrt(n));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 762582,
                "title": "mathematical-explanation-fast",
                "content": "Firstly, the solution is a one-liner:\\n\\n```\\ndef bulbSwitch(self, n: int) -> int:\\n        return int(math.sqrt(n))\\n```\\n\\nBut here is why this works:\\n\\nA lightbulb is switched everytime a number divides it. Thus a lightbulb is switched on exactly if its number of divisors (that is the count of numbers that divide it) is odd. \\n\\nEach number can be decomposed in its prime factors like so:\\n\\n![image](https://assets.leetcode.com/users/images/234b3900-4c7f-4c2c-b1f7-209ff88a142f_1596057242.8032293.png)\\n\\nThen the number of divisors is exactly:\\n\\n![image](https://assets.leetcode.com/users/images/aeac41e2-ebe3-4c59-858b-d2800989c201_1596057306.8243656.png)\\n\\nThis is because for each prime factor we can use it up to \\\\nu times or not use it at all (thus the +1). \\n\\nTherefore, the only way that a number can have an odd number of divisors is if all of its prime factor powers are even (which means they are divisible by two) and thus it can only happen if n is a square number. Thus, only square number lightbulbs are turned on and all others are turned off. \\n",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\ndef bulbSwitch(self, n: int) -> int:\\n        return int(math.sqrt(n))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 678054,
                "title": "brute-force-then-observed-a-pattern",
                "content": "It\\'s been 40 years since I\\'ve been in a math class and even after the explanation of factors and and square roots I have no clue how one would derive that solely from the problem description. The only thing that occurred to me was to do it by brute force, which worked, but timed out on submission because of the very large number. I ended up iterating on my brute force method to print out the results from 1 to 50 and was able to observe a very predictable pattern of number of offs between ons increasing by 2 each time, which allowed my to come up with this:\\n```\\nclass Solution {   \\n    public int bulbSwitch(int n) {\\n        int count = 0;\\n        int increment = 3;\\n        for (int i = 0; i < n; i += increment, increment += 2) {\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {   \\n    public int bulbSwitch(int n) {\\n        int count = 0;\\n        int increment = 3;\\n        for (int i = 0; i < n; i += increment, increment += 2) {\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 609241,
                "title": "sqrt-n-solution-with-explanation",
                "content": "\\'\\'\\'class Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        //bulb k to be on, it has to be toggled an odd number of times. \\n        //bulb k will toggle when the the k is exact multiple of the toggle.\\n        //so the toggle is a factor of k.\\n        //so bulb k is on when it has an odd number of factors.\\n        /* only perfect square number has an odd number of factors.\\n\\t\\t\\tThis is because: factors are in the form of pairs: Example: 6: (1x6), (2x3). so total number of factors is 4.\\n\\t\\t\\tbut for square number its root is paired with itself so total factors are odd. Example 4: (1x4), (2,2) factors are 1,2,4 */\\n        //total number of perfect square <= n is floor of sqrt(n);\\n        return sqrt(n);\\n    }\\n};\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        //bulb k to be on, it has to be toggled an odd number of times. \\n        //bulb k will toggle when the the k is exact multiple of the toggle.\\n        //so the toggle is a factor of k.\\n        //so bulb k is on when it has an odd number of factors.\\n        /* only perfect square number has an odd number of factors.\\n\\t\\t\\tThis is because: factors are in the form of pairs: Example: 6: (1x6), (2x3). so total number of factors is 4.\\n\\t\\t\\tbut for square number its root is paired with itself so total factors are odd. Example 4: (1x4), (2,2) factors are 1,2,4 */\\n        //total number of perfect square <= n is floor of sqrt(n);\\n        return sqrt(n);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 344323,
                "title": "java-1-liner-beats-100",
                "content": "```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 264840,
                "title": "3-line-c-solution-faster-100",
                "content": "For problems like this, I like to write out an example on paper for a small number of elements (10). In this case, noticed that 1, 4, 9 were on at the end. Thought about it and figured out that primes had to be off and any other numbers had an even number of unique factors, so just need to count the primes (inclusive).\\n\\nKept a long and implicit downcast to int in return value\\n\\n```\\n    int bulbSwitch(int n) {\\n        long i=1;\\n        while (i * i <= n) i++;\\n        return i-1;\\n    }\\n```\\t",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\n    int bulbSwitch(int n) {\\n        long i=1;\\n        while (i * i <= n) i++;\\n        return i-1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 77168,
                "title": "simple-java-solution-square-root",
                "content": "Only bulbs with index equaling a perfect square number will be on in the end. (because it has an odd number of divisors). So a simple solution follows:\\n\\n\\n    public static int bulbSwitch(int n) {\\n            return (int)Math.sqrt((double)n);\\n    }",
                "solutionTags": [],
                "code": "Only bulbs with index equaling a perfect square number will be on in the end. (because it has an odd number of divisors). So a simple solution follows:\\n\\n\\n    public static int bulbSwitch(int n) {\\n            return (int)Math.sqrt((double)n);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3698008,
                "title": "1-line-easy-cpp-beats-100-solution-with-full-explanation-of-approach-with-examples-basic-math",
                "content": "\\n\\n# Approach\\n- Number of times each bulb is toggled= its divisors.\\n- If the divisors in numbers are even(for eg 8 divisors are 1 2 4 8 ) then the bulb is OFF.\\n       - for 1 bulb is ON\\n       - for 2 bulb is OFF\\n       - for 4 bulb is ON\\n       - for 8 bulb is OFF\\n- This implies that the number which has odd number of divisors are the once that are ON (for eg 9 have divisors as 1 3 9 ) \\n         - for 1 bulb is ON\\n        - for 3 bulb is OFF\\n        - for 9 bulb is ON\\n- Hence we need to find the numbers in range from 1 to n which have odd number of divisors.\\n- Therefore lets take n as 25.\\n    - From 1 to 25 we can notice that the numbers which have odd number of divisors are perfect squares in the range (1 to 25)\\n1 2 3 4 5 are the bulbs that are ON for this case.(Since numbers from 6 and above crosses the range as 36>25).\\n- So we can directly say that the answer lies between 1 and sqrt(n).\\nNumber of integers in range 1,sqrt(n) is sqrt(n)-1 + 1=sqrt(n).\\n\\n- Therefore if we directly returns sqrt(n) we will get the required number of bulbs that are ON.\\n \\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return sqrt(n);\\n    }\\n};\\n```\\n# Please upvote for better reach!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return sqrt(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462414,
                "title": "very-easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        if(n<=1){\\n            return n;\\n        }\\n        return sqrt(n);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        if(n<=1){\\n            return n;\\n        }\\n        return sqrt(n);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461071,
                "title": "tle-one-liner-0ms-beats-100-c-solution-with-easy-explaination",
                "content": "# First approach - TLE\\nIn this approach I tried the brute force method. Created an array of size n+1, set all the bits to 1, as all the bulbs will be on in the first round. Set the 0th index as 0, as we are not going to use it. Then start a for loop from i=2 which goes upto i<=n, inside that loop, the another for loop starts from j-i, goes to j<=n and j increments in a fashion j+=i and inside this loop simply multiply jth bulb by -1, i.e. toggle its state and at last simply count the number of 1s in the vector and return the count.\\nBut, we know that n<=10^9 which is huge number and will obviously throw TLE.\\n```\\nclass solution{\\npublic:\\n\\tint bulbSwitch(int n){\\n\\t\\tvector<int> bulbs(n+1, 1);\\n\\t\\t bulbs[0]=0;\\n\\t\\t for(int i=2; i<=n; i++){\\n\\t\\t\\t for(int j=i; j<=n; j+=i)\\n\\t\\t\\t\\t bulbs[j]*=-1;\\n\\t\\t }\\n\\t\\t sort(bulbs.begin(), bulbs.end(), greater<int>());\\n\\t\\t int ans =0;\\n\\t\\t for(int i=0; i<=n; i++){\\n\\t\\t\\t if(bulbs[i]!=1)\\n\\t\\t\\t\\t return ans;\\n\\t\\t\\t ans++;\\n\\t\\t }\\n\\t\\t return ans;\\n\\t }\\n };\\n```\\n# Second approach - One_liner\\nSo if we run hit and trial method starting from 0, we find a pattern which comes out to be:\\nFrom n = 1-3 the ans is 1 ->  (1* (1+2))\\nfrom n = 4-8 the ans is 2  -> (2* (2+2))\\nfrom n = 9-15 the ans is 3 -> (3* (3+2)) and so on..\\nSo the ans will be the minimum number which satisfys the condition  i*(i+2)>=n.\\nAgain interesting thought is, that number will never be more than the perfect square root of that number.\\nFor example, for n=25-35, the ans will be 5, square root of 25.\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return (int)sqrt(n);\\n    }\\n};\\n```\\nIf you liked my explaination please upvote my solution and subscribe for more such solutions.\\nOk Byee!\\n",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass solution{\\npublic:\\n\\tint bulbSwitch(int n){\\n\\t\\tvector<int> bulbs(n+1, 1);\\n\\t\\t bulbs[0]=0;\\n\\t\\t for(int i=2; i<=n; i++){\\n\\t\\t\\t for(int j=i; j<=n; j+=i)\\n\\t\\t\\t\\t bulbs[j]*=-1;\\n\\t\\t }\\n\\t\\t sort(bulbs.begin(), bulbs.end(), greater<int>());\\n\\t\\t int ans =0;\\n\\t\\t for(int i=0; i<=n; i++){\\n\\t\\t\\t if(bulbs[i]!=1)\\n\\t\\t\\t\\t return ans;\\n\\t\\t\\t ans++;\\n\\t\\t }\\n\\t\\t return ans;\\n\\t }\\n };\\n```\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return (int)sqrt(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459500,
                "title": "java-1-liner-super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe main thing to realize is that a bulb that is flipped on and off even number of times will end up as off in the end, and simlilarly a bulb that is flipped on and off odd number of times will be on in the end. Only bulbs at perfect square locations will be flipped odd number of times. Hence we only need to count the number of bulbs that are perfect squares and <= n.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int bulbSwitch(int n) {\\n    return (int) Math.sqrt(n);\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\n  public int bulbSwitch(int n) {\\n    return (int) Math.sqrt(n);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459455,
                "title": "return-sqrt-n-c-one-line",
                "content": "````\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return sqrt(n);\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return sqrt(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459350,
                "title": "sabse-easy-approch-logical-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n - The first bulb is turned on in the beginning, so we start with a count of 1.\\n- In the second round, every second bulb is turned off, so the count becomes n/2 (rounded down).\\n- In the third round, every third bulb is toggled. If a bulb has been toggled an odd number of times, it will be on at the end of the round; otherwise, it will be off. The number of times a bulb is toggled is equal to the number of its divisors. For example, the 6th bulb is toggled by rounds 1, 2, 3, and 6. So we need to count the number of bulbs with an odd number of divisors.\\n- A number has an odd number of divisors if and only if it is a perfect square. Therefore, we can count the number of perfect squares less than or equal to n, and that will give us the answer.\\n\\n# Complexity\\n- Time complexity:\\nO(sqrt(N))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint bulbSwitch(int n) {\\n    int count = 0;\\n    for (int i = 1; i*i <= n; i++) {\\n        count++;\\n    }\\n    return count;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint bulbSwitch(int n) {\\n    int count = 0;\\n    for (int i = 1; i*i <= n; i++) {\\n        count++;\\n    }\\n    return count;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459108,
                "title": "ruby-math",
                "content": "# Code\\n\\n```ruby\\ndef bulb_switch(n) = Integer.sqrt(n)\\n```\\n\\n# Explanation\\n\\nEach bulb is toggled whenever the number is one of the divisors of the bulb\\'s number.\\n\\nFor a bulb to be on, it has to be toggled an odd number of times.\\n\\nIt\\'s easy to see that numbers $$m$$ generally have an even number of divisors $$d_i$$ because they come in pairs: $$\\\\{d_i, m / d_i\\\\}$$; however, among such divisor pairs in square numbers we have exactly one that consists of the root of the square repeated: $$\\\\{\\\\sqrt{m}; \\\\sqrt{m}\\\\}$$.\\n\\nThe bulbs assigned to square numbers are exactly those that will stay on. The number of square numbers between $$[1, n]$$ is precisely the integer square root of $$n$$, hence the solution.\\n\\n# Complexity\\n\\n$$\\\\mathcal{O}(1)$$",
                "solutionTags": [
                    "Ruby",
                    "Math"
                ],
                "code": "```ruby\\ndef bulb_switch(n) = Integer.sqrt(n)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3459031,
                "title": "rust-full-mathematical-proof",
                "content": "# Intuition\\n\\nYou need to count the number of times a bulb at each position will change states. It will change the states based on the amount of divisors it has.\\n\\nNext important observation is that you do not care about the actual number of the divisiors but whether the number of divisors is odd or even\\n\\nIf the number of divisors is odd (1, 3, 5, ...) it will be turned off at the end, otherwise will be on. If the number $X$ has a divisor $a$, then it also has $a$ divisor $X/a$. So in most cases it is odd and it is even only if they are equal. So $a = X / a$ which means that $X = a^2$, so numbers like $1, 4, 9, 16, ... a^2$\\n\\nSo you need to find how many squared numbers do you have $<= n$\\n\\n# Complexity\\n- Time complexity: $O(1)$ (of log if you consider any size of integers, like $10^{1000}$)\\n- Space complexity: $O(1)$\\n\\n# Code\\n```\\nimpl Solution {\\n  pub fn bulb_switch(n: i32) -> i32 {\\n    return f64::sqrt(n as f64) as i32;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n  pub fn bulb_switch(n: i32) -> i32 {\\n    return f64::sqrt(n as f64) as i32;\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2451872,
                "title": "c-2-line-code-explained-in-detail-faster-than-100",
                "content": "![image](https://assets.leetcode.com/users/images/4221f8f1-e936-42de-b0b0-c07345627392_1660974170.652242.png)\\n\\n![image](https://assets.leetcode.com/users/images/42aa95dd-9019-49cb-ac94-a263ab6d4a55_1660974838.9806044.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/11fe0897-5fa2-44bd-9121-9a36099ba64e_1660974847.8563175.jpeg)\\n\\n\\n\\n**T->O(sqrt(n)) && S->O(1)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint bulbSwitch(int n) {\\n\\t\\t\\tint count=0,i=1;\\n\\t\\t\\twhile(i*i<=n){\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint bulbSwitch(int n) {\\n\\t\\t\\tint count=0,i=1;\\n\\t\\t\\twhile(i*i<=n){\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2401364,
                "title": "java-explained-o-1-runtime",
                "content": "class Solution {\\n    /**\\n\\nKey Insight: All the light bulbs are initially off. The ith light bulb will be on if and only if we interact with it an odd amount of times. If we interact with the lightbulb an even amount of times it will be off. \\n\\nBrute force: Create a boolean array of size n and then iterate from 1-n. Lets say the current iteration is k. Starting from the beginning of the array flip the switch on every kth lightbulb (true -> false or false -> true). At the end iterate through the boolean array and sum up all the elements that are true. Runtime complexity is O(N^2)\\n\\nOptimal Algorithm: Using the key insight we want to determine which bulbs we interact with an odd amount of times. Lets consider the ith light bulb. We interact with the ith light bulb once for each factor it has.\\n\\n1) E.x Lets say i = 8. We interact with it in the beginning (factor = 1), we interact with it when we interact with every second bulb (factor = 2), we interact with every 4th bulb (factor = 4), we interact with every 8th bulb(factor = 8). Here the list of factors is = [1,2,4,8] -> even amount of factors so we know the 8th bulb will be turned off. \\n\\nNow lets say we want to determine the factors for k. We can write k as k = p * q. Without loss of generality we can say that p is always smaller than q. Now we can see that all the factors of k come in pairs. When k = 8 the pairs were [p,q] = [1, 8] and [2, 4]. \\n\\nThis begs the question -> If the factors of k always come in pairs can the number of pairs every be odd? YES, they can. Consider a number that is a perfect square. \\n\\n2) E.x. K = 9. We know that [p, q] = [1, 9], [3, 3] define the pairs of all factors that result in a product of k. However, notice that in the second pair even though there are 2 numbers there is only 1 DISTINCT number. Therefore the # of factors of k = 9 here would be [1,3,9] -> which is an odd length -> resulting in an on switch for the light bulb\\n\\nThis results in the following conclusion: If the ith number is a perfect square then the ith bulb will be turned on else the bulb will be off. \\n\\nTo find the number of bulbs turned on less than n -> determine the number of perfect squares less than n. \\n\\nOptimal Algorithm runtime: O(1)\\n    **/\\n\\t\\n```\\n    public int bulbSwitch(int n) {\\n        int sqrt = (int) Math.sqrt(n);\\n        \\n        return sqrt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int bulbSwitch(int n) {\\n        int sqrt = (int) Math.sqrt(n);\\n        \\n        return sqrt;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2276346,
                "title": "100-fast-simple-3-line-code",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int bulbSwitch(int n) {\\n        int ans=0,i=1;\\n        while(n>=i*i)\\n            ++ans,++i;\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int bulbSwitch(int n) {\\n        int ans=0,i=1;\\n        while(n>=i*i)\\n            ++ans,++i;\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2163264,
                "title": "easy-to-understand-maths-problem-better-than-85",
                "content": "Easiest way that I did is, I ran this for some random numbers and got to know that number is increasing at every square.\\nExample:\\n1 to 3 answer is 1\\n4 to 8 answer is 2\\n9 to 15 answer is 3\\n16 to 24 answer is 4\\nand so on. This gave me a sequence I just took the square root of the given number and did the flooring so that the number changes only at perfect squares.\\n```\\nclass Solution(object):\\n    def bulbSwitch(self, n):\\n        return int(math.floor(sqrt(n)))\\n```",
                "solutionTags": [
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution(object):\\n    def bulbSwitch(self, n):\\n        return int(math.floor(sqrt(n)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1945932,
                "title": "kotlin-beats-100-00-speed-memory-april-2022",
                "content": "\\n\\tclass Solution {\\n\\n    fun bulbSwitch(n: Int): Int {\\n        return getSqrt(n)\\n    }\\n\\n    private fun getSqrt(n: Int): Int {\\n        var l = 1L\\n        var r : Long = n.toLong()\\n        while (l <= r) {\\n            var mid = l + (r - l)/2\\n            if (mid * mid == n.toLong()) {\\n                return mid.toInt()\\n            } else if (mid * mid < n.toLong()) {\\n                l = mid + 1\\n            } else {\\n                r = mid - 1\\n            }\\n        }\\n        return r.toInt()\\n    }\\n\\t}",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "class Solution {\\n\\n    fun bulbSwitch(n: Int): Int {\\n        return getSqrt(n)\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1826737,
                "title": "simple-logic-explained-in-20-seconds",
                "content": "bulb n will be toggled when round # is one of its factors.\\n\\ni.e. \\nbulb `3` will be toggled on round #`1, 3`\\nbulb `4` will be toggled on round #`1,2,4`\\n\\nConclusion:\\nif a bulb# has even number of factors, it will be off;\\nif a bulb# has odd number of factors, it will be on;\\n\\n**ONLY SQUARE OF INTEGERS HAVE ODD NUMBER OF FACTORS**\\nEverything else has reciprocating factors - i.e. 6=3x2 and 6=2x3, therefore factors of 6 - [1, 2, 3, 6]  -- This means their factors count will be even.\\nOnly when a integer is a perfect square of another integer, it has odd number of factors  - i.e.  9=3x3, therefore factors of 9 - [1, 3, 9]\\n\\n**Therefore** The question is asking you to find the number of integer squares between 1 and n;\\n\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return sqrt(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return sqrt(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586391,
                "title": "java-solution-with-explanation",
                "content": "\\n * Points to remember \\n 1) The number of bulbs that have odd number of factors remain ON.\\n 2) Tnly perfect squares have odd number of factors.\\n\\n * Only perfect squares have an odd number of factors.This is because a*b=n. \\n * For any number \\'a\\' there is a corresponding number \\'b\\' which is also a factor \\n * hence factors will make pairs always.But when it is perfect square \\n * then a*a=n where a is sqrt(n).\\n * Due to of presence of this single factor whose pair in itself\\n * will make total number of factors odd <1,a,a>. Hence only perfect square will \\n * have odd number of factors.\\n        //First go all bulbs are ON i.e. 1,2,3,4,5,..n\\n\\t\\t//Second go OFF bulbs              2 , 4 , ..n\\n\\t\\t//third go OFF bulbs                 3     ..n\\n\\t\\t//4th.                                 4   ..n      \\n\\t\\t//5th                                     5..n\\n        Here we see for N(say 5), after the 5th(nth) round , the bulb 4 was tackeled ODD number of times, so it has returned to its original state that is \\'ON\\' for others action was performed even number of times, so their state remains changed \\'OFF\\'\\n        Taking square root gives result directly.\\n \\n //Complexitiy : Time O(root(N)) ; Space O(1)\\n```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        //trying to find out how many bulbs are perfect square and that count would give us \\'ON\\' bulns\\n        int count=0;\\n        for(int num=1; num*num<=n;num++){\\n            count++;\\n        }\\n        return count;\\n    }``\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        //trying to find out how many bulbs are perfect square and that count would give us \\'ON\\' bulns\\n        int count=0;\\n        for(int num=1; num*num<=n;num++){\\n            count++;\\n        }\\n        return count;\\n    }``\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1311719,
                "title": "319-bulb-switcher-0ms-100-faster-c",
                "content": "```class Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        int count=0;\\n1.         here we need to look at the pattern that how will one bulb remain ON and OFF\\n2.    if we take a closer look we will notice that :- if for any number we have even number of factors,then it will be OFF at end,otherwise ON\\n3.          so,we need count of perfect squares\\n        \\n        \\n*         but why??\\n        non-perfect square       vs    perfect-square\\n*         eg.   24(8 factors)                36(9 factors)\\n               1 X 24                       1  X 36\\n               2 X 12                       2  X 18\\n               3 X 8                        3  X 12\\n               4 X 6                        4  X 9 \\n               24 X 1                       6  X 6\\n               12 X 2                       9  X 4\\n               8 X 3                        12 X 3 \\n               6 X 4                        18 X 2\\n                                            36 X 1\\n                   \\n4.          so u can try it urself and find it out that it really works!!\\n*         so, simply count perfect squares in the given range,and return its count\\n        for(int i=1;i*i<=n;i++)\\n            count++;\\n        return count;\\n\\t\\t****last step:- kindly smile and upvote\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        int count=0;\\n1.         here we need to look at the pattern that how will one bulb remain ON and OFF\\n2.    if we take a closer look we will notice that :- if for any number we have even number of factors,then it will be OFF at end,otherwise ON\\n3.          so,we need count of perfect squares\\n        \\n        \\n*         but why??\\n        non-perfect square       vs    perfect-square\\n*         eg.   24(8 factors)                36(9 factors)\\n               1 X 24                       1  X 36\\n               2 X 12                       2  X 18\\n               3 X 8                        3  X 12\\n               4 X 6                        4  X 9 \\n               24 X 1                       6  X 6\\n               12 X 2                       9  X 4\\n               8 X 3                        12 X 3 \\n               6 X 4                        18 X 2\\n                                            36 X 1\\n                   \\n4.          so u can try it urself and find it out that it really works!!\\n*         so, simply count perfect squares in the given range,and return its count\\n        for(int i=1;i*i<=n;i++)\\n            count++;\\n        return count;\\n\\t\\t****last step:- kindly smile and upvote\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1298219,
                "title": "java-one-line-solution-with-explanation",
                "content": "In this bulb switcher all the bulbs are on in first round.\\nNow on second round it is toggle on or off.\\nWe can find it that after n round , How many bulbs were on Just by using its factors.\\n**If an Integer factors are even its is Off .\\nIf an Integer Factors are odd it is on**\\nUsing same logic we can find that all perfect square have pdd factors,while all other no has even factor.\\nHence we can say that in n round we will have tota**l (int)Math.sqrt(n)** bulbs on.\\n\\nIf found useful Please** Upvote.**\\nThanks.\\n```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188062,
                "title": "c-perfect-square-property",
                "content": "**Logic** \\nnth bulb is toggled in ith iteration if i divides n. Thus nth bulb is toggled x times where x is the number of divisors of n. After every even number of toggles, a bulb will retain its original state i.e off. We need odd number of divisors so that a bulb remains in on state. A number has odd number of divisors only when it is a perfect square e.g. 1, 4, 9. So we need to calculate sqrt(n) which gives us the number of numbers which have odd number of divisors and are less than or equal to n.\\n\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return sqrt(n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return sqrt(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 667544,
                "title": "one-line-python-with-explanation",
                "content": "For any bulb i in the bulb set from 1 to n, we need to know which number d that i % d == 0, such these number d(s) will toggle the bulb i. Actually, we dont even need to know what d is, we need to know such these d(s) are even or odd.\\n\\nFor example, Bulb #20 has 1, 2, 4, 5, 10 and 20. These numbers that makes 20 % d == 0. and the total count of these numbers are 6, which is even. Another example is Bulb #49, it has 1, 7 and 49, and the total count is 3, which is odd. When you try more numbers you\\'ll notice that only those numbers with integer square root have odd total count, and the numbers with odd total count has light on eventually. so the result for this problem is the rounding down of sqrt(n), which is a math problem.\\n\\nclass Solution(object):\\n\\n    def bulbSwitch(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        return int(floor(sqrt(n)))",
                "solutionTags": [],
                "code": "For any bulb i in the bulb set from 1 to n, we need to know which number d that i % d == 0, such these number d(s) will toggle the bulb i. Actually, we dont even need to know what d is, we need to know such these d(s) are even or odd.\\n\\nFor example, Bulb #20 has 1, 2, 4, 5, 10 and 20. These numbers that makes 20 % d == 0. and the total count of these numbers are 6, which is even. Another example is Bulb #49, it has 1, 7 and 49, and the total count is 3, which is odd. When you try more numbers you\\'ll notice that only those numbers with integer square root have odd total count, and the numbers with odd total count has light on eventually. so the result for this problem is the rounding down of sqrt(n), which is a math problem.\\n\\nclass Solution(object):\\n\\n    def bulbSwitch(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        return int(floor(sqrt(n)))",
                "codeTag": "Java"
            },
            {
                "id": 402164,
                "title": "full-description-and-justification",
                "content": "I didn\\'t see a full description of this solution that didn\\'t leave me with follow-up questions so I decided to write one that I hope is satisfing to a broader audience.\\n\\n -Each bulb is toggled for each number lower than it that divides it evenly\\n -That is a bulb will be on iff it has an even number of unique divisors\\n -This happens only when a number is a perfect square since all divisors can be grouped in pairs (d, n/d)\\n -The pair has two unique values except for the case of d = n/d i.e d*d = n or n is a perfect square\\n        \\n        //so we count the perect squares <= n\\n        if (n < 1) return 0;\\n        \\n        int cnt = 2;\\n        while (cnt*cnt <= n) cnt++;\\n        \\n        return cnt-1;\\n        \\n        //equivalently floor(sqrt(n)) will give the number of perfect squares less <= n\\n        //since for all numbers <= this value we have num*num <= n",
                "solutionTags": [],
                "code": "I didn\\'t see a full description of this solution that didn\\'t leave me with follow-up questions so I decided to write one that I hope is satisfing to a broader audience.\\n\\n -Each bulb is toggled for each number lower than it that divides it evenly\\n -That is a bulb will be on iff it has an even number of unique divisors\\n -This happens only when a number is a perfect square since all divisors can be grouped in pairs (d, n/d)\\n -The pair has two unique values except for the case of d = n/d i.e d*d = n or n is a perfect square\\n        \\n        //so we count the perect squares <= n\\n        if (n < 1) return 0;\\n        \\n        int cnt = 2;\\n        while (cnt*cnt <= n) cnt++;\\n        \\n        return cnt-1;\\n        \\n        //equivalently floor(sqrt(n)) will give the number of perfect squares less <= n\\n        //since for all numbers <= this value we have num*num <= n",
                "codeTag": "Unknown"
            },
            {
                "id": 370443,
                "title": "lc319-bulb-switcher-it-s-not-exactly-a-switching-problem-see-the-attached-image",
                "content": "The answer is the number of perfect square less than or equal to n\\n\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        if(!n)\\n            return 0;\\n        \\n        int i=1;\\n        for(; i <= n/2+1; i++){\\n            if(i > n/i)\\n                break;\\n        }\\n        \\n        return i-1;\\n    }\\n};\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/pratyush9/image_1567142536.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        if(!n)\\n            return 0;\\n        \\n        int i=1;\\n        for(; i <= n/2+1; i++){\\n            if(i > n/i)\\n                break;\\n        }\\n        \\n        return i-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 297771,
                "title": "python-solution-beats-95-no-sqrt",
                "content": "So when I actually ran a simulation for small values of n, I saw the following pattern at the end:\\nOn<2 Offs>On<4 Offs>On<6 Offs>On<8 Offs>...\\nSo basically every successive On comes after 2 more Offs than the number of Offs before the current On.\\nPutting this into code:\\n```\\nclass Solution(object):\\n    def bulbSwitch(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        i = 0\\n        jump = 2\\n        res = 0\\n        while i < n:\\n            res += 1\\n            i += jump + 1\\n            jump += 2\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def bulbSwitch(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        i = 0\\n        jump = 2\\n        res = 0\\n        while i < n:\\n            res += 1\\n            i += jump + 1\\n            jump += 2\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77106,
                "title": "look-at-my-code-take-a-break-laugh",
                "content": "Get TLE\\n\\n\\n\\n    public int bulbSwitch(int n) {\\n        int onCnt = 0;\\n        for(int i = 1 ; i <= n; i++) {\\n            int toggle = 0;\\n            for(int k = 1; k <= i; k++) {\\n                if(i % k == 0)\\n                    toggle ++;\\n            }\\n\\n            if (toggle % 2 == 1)\\n                onCnt ++;\\n        }\\n        return onCnt;\\n    }",
                "solutionTags": [],
                "code": "Get TLE\\n\\n\\n\\n    public int bulbSwitch(int n) {\\n        int onCnt = 0;\\n        for(int i = 1 ; i <= n; i++) {\\n            int toggle = 0;\\n            for(int k = 1; k <= i; k++) {\\n                if(i % k == 0)\\n                    toggle ++;\\n            }\\n\\n            if (toggle % 2 == 1)\\n                onCnt ++;\\n        }\\n        return onCnt;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 77109,
                "title": "just-share-o-n-time-o-1-space-solution",
                "content": "See all is O(1) solution, just spent a little time to figure out how to get value in one pass. Happy to share it.\\n```\\npublic class Solution {\\n    public int bulbSwitch(int n) {\\n        if (n == 0) return 0;\\n        int i = 1;\\n        int prev = 0, cur = 0, multi = 1;\\n        while (i <= n) {\\n            while (i < multi * multi && i <= n) {\\n                cur = prev;\\n                i++;\\n            }\\n            if (i++ <= n) cur = prev + 1;\\n            prev = cur;\\n            multi++;\\n        }\\n        return cur;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int bulbSwitch(int n) {\\n        if (n == 0) return 0;\\n        int i = 1;\\n        int prev = 0, cur = 0, multi = 1;\\n        while (i <= n) {\\n            while (i < multi * multi && i <= n) {\\n                cur = prev;\\n                i++;\\n            }\\n            if (i++ <= n) cur = prev + 1;\\n            prev = cur;\\n            multi++;\\n        }\\n        return cur;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 77116,
                "title": "java-simple-n-1-2-solution",
                "content": "4 = 2^2: on\\n\\n8 = 2^3: off\\n\\n36 = 2^2 * 3^2: on\\n\\na number is on, if its factors have even power, in other words, if it is a square\\n\\n    public class Solution {\\n        public int bulbSwitch(int n) {\\n            int on = 0;\\n            for (int i = 1; i * i <= n; i++)    {\\n                on++;\\n            }\\n                \\n            return on;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int bulbSwitch(int n) {\\n            int on = 0;\\n            for (int i = 1; i * i <= n; i++)    {\\n                on++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 77128,
                "title": "java-accepted-solution",
                "content": "    public class Solution {\\n        public int bulbSwitch(int n) {\\n            if (n <= 0) return 0;\\n            return (int)Math.sqrt(n);\\n        }\\n    }",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\n        public int bulbSwitch(int n) {\\n            if (n <= 0) return 0;\\n            return (int)Math.sqrt(n);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 77166,
                "title": "1-line-c-code-with-explanation",
                "content": "Only lights labeled as perfect squares will be on because perfect squares have odd numbers of divisors.\\n\\n1st bulb  (1: 1):           1 **on**                 -------             1=1^2\\n\\n2nd bulb (2: 1,2):        1 on, 2 off\\n\\n3rd bulb  (3: 1,3):        1 on, 3 off\\n\\n4th bulb  (4: 1,2,4):     1 on, 2 off, 4 **on**     ------      4=2^2\\n\\n5th bulb  (5: 1,5):        1 on, 5 off\\n\\n6th bulb  (6: 1,2,3,6):  1 on, 2 off, 3 on, 6 off\\n\\n7th bulb  (7: 1,7):        1 on, 7 off\\n\\n8th bulb  (8: 1,2,4,8):  1 on, 2 off, 4 on, 8 off\\n\\n9th bulb  (9: 1,3,9):     1 on, 3 off, 9 **on**    ---------       9=3^2\\n\\nand so on...\\n\\n    int bulbSwitch(int n) {\\n        return sqrt(n);\\n    }",
                "solutionTags": [],
                "code": "Only lights labeled as perfect squares will be on because perfect squares have odd numbers of divisors.\\n\\n1st bulb  (1: 1):           1 **on**                 -------             1=1^2\\n\\n2nd bulb (2: 1,2):        1 on, 2 off\\n\\n3rd bulb  (3: 1,3):        1 on, 3 off\\n\\n4th bulb  (4: 1,2,4):     1 on, 2 off, 4 **on**     ------      4=2^2\\n\\n5th bulb  (5: 1,5):        1 on, 5 off\\n\\n6th bulb  (6: 1,2,3,6):  1 on, 2 off, 3 on, 6 off\\n\\n7th bulb  (7: 1,7):        1 on, 7 off\\n\\n8th bulb  (8: 1,2,4,8):  1 on, 2 off, 4 on, 8 off\\n\\n9th bulb  (9: 1,3,9):     1 on, 3 off, 9 **on**    ---------       9=3^2\\n\\nand so on...\\n\\n    int bulbSwitch(int n) {\\n        return sqrt(n);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3558788,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return sqrt(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return sqrt(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478290,
                "title": "smart-clean-code-2-liner-c-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n    int cnt = 0;\\n    for (int i = 1 ; i*i <= n ; i++, cnt++);\\n    return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n    int cnt = 0;\\n    for (int i = 1 ; i*i <= n ; i++, cnt++);\\n    return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461732,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return sqrt(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return sqrt(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461670,
                "title": "js-solutions-without-using-sqrt",
                "content": "# Intuition\\n\\n**Intuition/Math:**\\n\\nWe notice that there is a repetition pattern between the 1 (on) and 0s (off) of the lights, which looks like:\\n`1, 2*0s, 1, 4*0s, 1, 6*0s, 1, 8*0s,...`\\nor\\n`[1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,...]`\\nSo we could either build this array upto n, and then count the 1s;\\nOr follow the pattern and `remove` each `array item` as we\\'ve used it/set it into the correct on/off state from our `array length`, n.\\nI marked the on/off with a 1/0 (not true/false)\\n\\n\\n# Code\\n```\\n// Calculating the number of ones using substractions\\n// Based on the observation that the sequence of numbers follows this rule:\\n// 1, 2*0s, 1, 4*0s, 1, 6*0s, 1, 8*0s\\n// i.e.:\\n// for 16: [1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1] total 5 ones\\nvar bulbSwitch = function(n) {\\n  let ans = 0;\\n\\n  let factor = 1;\\n  while(n > 0) {\\n    // remove 1x 1, and add it to the answer\\n    n--;\\n    ans++;\\n\\n    // The one is followed by 2 * factor zeroes:\\n    n = n - (factor * 2);\\n    factor++;\\n  }\\n\\n  return ans;\\n}\\n\\n/*\\n    one   [1]\\n    two   [1,0]    \\n    three [1,0,0]  \\n    four  [1,0,0,1]         2\\n    five  [1,0,0,1,0]\\n    six   [1,0,0,1,0,0]\\n    seven [1,0,0,1,0,0,0]\\n    eight [1,0,0,1,0,0,0,0]   \\n    nine  [1,0,0,1,0,0,0,0,1] 3\\n    ten   [1,0,0,1,0,0,0,0,1,0]\\n    //...\\n    15.   [1,0,0,1,0,0,0,0,1,0,0,0,0,0,0]\\n    16.   [1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1] 4\\n\\n    [1,4,9,16,25]\\n    1, 2*0s, 1, 4*0s, 1, 6*0s, 1, 8*0s\\n    25 should have 5\\n*/\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\n// Calculating the number of ones using substractions\\n// Based on the observation that the sequence of numbers follows this rule:\\n// 1, 2*0s, 1, 4*0s, 1, 6*0s, 1, 8*0s\\n// i.e.:\\n// for 16: [1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1] total 5 ones\\nvar bulbSwitch = function(n) {\\n  let ans = 0;\\n\\n  let factor = 1;\\n  while(n > 0) {\\n    // remove 1x 1, and add it to the answer\\n    n--;\\n    ans++;\\n\\n    // The one is followed by 2 * factor zeroes:\\n    n = n - (factor * 2);\\n    factor++;\\n  }\\n\\n  return ans;\\n}\\n\\n/*\\n    one   [1]\\n    two   [1,0]    \\n    three [1,0,0]  \\n    four  [1,0,0,1]         2\\n    five  [1,0,0,1,0]\\n    six   [1,0,0,1,0,0]\\n    seven [1,0,0,1,0,0,0]\\n    eight [1,0,0,1,0,0,0,0]   \\n    nine  [1,0,0,1,0,0,0,0,1] 3\\n    ten   [1,0,0,1,0,0,0,0,1,0]\\n    //...\\n    15.   [1,0,0,1,0,0,0,0,1,0,0,0,0,0,0]\\n    16.   [1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1] 4\\n\\n    [1,4,9,16,25]\\n    1, 2*0s, 1, 4*0s, 1, 6*0s, 1, 8*0s\\n    25 should have 5\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3461428,
                "title": "beating-100-single-line-java-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/80847c54-8418-4c8c-a47b-d0e3b7472510_1682616436.166732.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n       int a=(int)Math.pow(n,0.5);\\n       return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n       int a=(int)Math.pow(n,0.5);\\n       return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461414,
                "title": "3-easy-solution-in-c-o-n-2-o-n-o-1-beats-100-test-cases-but-o-n-2-give-time",
                "content": "the solution is easy but will give Time Limit Exceeded\\n# Code c++ O(n^2)\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        int arr[n+1];\\n        for(int i = 0;i<=n;i++)arr[i]=1;\\n        for(int i = 2 ; i <=n ;i++)\\n        {\\n            for(int j = i ; j <=n ;j+=i)arr[j]=abs(arr[j]-1);\\n        }\\n        int cont=0;\\n        for(int i = 1;i<=n;i++)cont+=arr[i];\\n        return cont;\\n    }\\n};\\n```\\n\\nwhen num = 1,2,3 ---> the solution is 1\\nand  num = 4,5,6,7,8 ---> the solution is 2\\nand the num from 9 to 15 ---> the solution is 3\\nthen the solution increase one when the cont = 3,3+5,3+5+7,3+5+7+9 and so on...\\n\\nnum <=3 ...cont =1\\nnum <=3+5 ...cont =2\\nnum <=3+5+7 ...cont =3\\nnum <=3+5+7+9 ...cont =4\\nnum <=3+5+7+9+11 ...cont =5 and so on\\n\\n# Code c++ O(n)\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        if(n==0)return 0;\\n        else\\n        {\\n            int cont=1,cont2=3;\\n            for(int i = cont2 ; i < n ;i+=cont2){cont++;cont2+=2;}\\n            return cont;\\n        }\\n    }\\n};\\n```\\n\\nthis is easy solution, the solution = sqrt num\\nnum=1 bulbs=1\\nnum=2 bulbs=1\\nnum=3 bulbs=1\\nnum=4 bulbs=2\\nnum=5 bulbs=2\\nnum=6 bulbs=2\\nnum=7 bulbs=2\\nnum=8 bulbs=2\\nnum=9 bulbs=3\\nnum=10 bulbs=3\\nand so on\\n\\n# Code c++ O(1)\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return sqrt(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        int arr[n+1];\\n        for(int i = 0;i<=n;i++)arr[i]=1;\\n        for(int i = 2 ; i <=n ;i++)\\n        {\\n            for(int j = i ; j <=n ;j+=i)arr[j]=abs(arr[j]-1);\\n        }\\n        int cont=0;\\n        for(int i = 1;i<=n;i++)cont+=arr[i];\\n        return cont;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        if(n==0)return 0;\\n        else\\n        {\\n            int cont=1,cont2=3;\\n            for(int i = cont2 ; i < n ;i+=cont2){cont++;cont2+=2;}\\n            return cont;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return sqrt(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461284,
                "title": "easy-c-sqrt-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        if(n==0||n==1){return n;}\\n\\n        return sqrt(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        if(n==0||n==1){return n;}\\n\\n        return sqrt(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460755,
                "title": "beats-100-most-optimal-solution-with-explanation-short-and-clean-code",
                "content": "\\n\\n# Approach\\nThe problem can be solved by observing that a bulb i will only be toggled on rounds where i is a factor of the current round number. So for any given round, the number of factors of a bulb number i is equal to the number of times the bulb will be toggled.\\n\\nFor example, consider bulb number 6:\\n\\nOn round 1, it is turned on\\nOn round 2, it is turned off\\nOn round 3, it is turned off (because 3 is a factor of 6)\\nOn round 6, it is turned on (because 6 is a factor of 6)\\nSince the bulb will only be on if it is toggled an odd number of times, we can count the number of factors of each bulb number up to n, and this will give us the answer.\\n\\nThe loop runs from 1 to sqrt(n) because any factor greater than sqrt(n) will have a corresponding factor less than sqrt(n). The count variable keeps track of the number of bulbs that will be on at the end of n rounds.\\n\\n# Complexity\\n- Time complexity:\\nO(sqrt(n))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        int count = 0;\\n        for (int i = 1; i*i <= n; i++) {\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Math",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        int count = 0;\\n        for (int i = 1; i*i <= n; i++) {\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459959,
                "title": "python-math-explained",
                "content": "1. For the `m`th bulb, how many times will it be toggled?\\nSuppose the prime factorization of `m` is `p_1^m_1 * p_2^m_2 * ... * p_k^m_k`, then the total number of factors of `m` would be `(m_1+1)*(m_2+1)*...*(m_k+1)`.\\n2. If there are at least one odd number in `{m_1, ..., m_k}`, the number of factors would be even. A bulb toggled even times remains being off.\\n3. Only those bulbs with indices being square numbers would be on after `n` rounds.\\n```\\nclass Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return int(math.sqrt(n))",
                "solutionTags": [
                    "Python3"
                ],
                "code": "1. For the `m`th bulb, how many times will it be toggled?\\nSuppose the prime factorization of `m` is `p_1^m_1 * p_2^m_2 * ... * p_k^m_k`, then the total number of factors of `m` would be `(m_1+1)*(m_2+1)*...*(m_k+1)`.\\n2. If there are at least one odd number in `{m_1, ..., m_k}`, the number of factors would be even. A bulb toggled even times remains being off.\\n3. Only those bulbs with indices being square numbers would be on after `n` rounds.\\n```\\nclass Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return int(math.sqrt(n))",
                "codeTag": "Java"
            },
            {
                "id": 3459596,
                "title": "simple-and-easy-solution-1-line-code-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int bulbSwitch(int n) {        \\n        return (int)Math.floor(Math.sqrt(n));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int bulbSwitch(int n) {        \\n        return (int)Math.floor(Math.sqrt(n));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459425,
                "title": "just-square-root-of-n",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return sqrt(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return sqrt(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459401,
                "title": "python-shortest-1-liner-functional-programming",
                "content": "# Approach\\nTL;DR, Similar to [Editorial solution](https://leetcode.com/problems/bulb-switcher/editorial/).\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```python\\nclass Solution: bulbSwitch = isqrt\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Brainteaser"
                ],
                "code": "```python\\nclass Solution: bulbSwitch = isqrt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459363,
                "title": "c-python-java-c-javascript-one-liner-maths",
                "content": "# Code [ C++ ]\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return (int)sqrt(n);\\n    }\\n};\\n```\\n\\n# Code [ Python ]\\n```\\nclass Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return int(sqrt(n))\\n```\\n\\n# Code [ Java ]\\n```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);\\n    }\\n}\\n```\\n\\n# Code [ C ]\\n```\\nint bulbSwitch(int n){\\n    return sqrt(n);\\n}\\n```\\n\\n# Code [ JavaScript ]\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar bulbSwitch = function(n) {\\n    var res=1;\\n    while(res*res<=n){\\n        res++;\\n    }\\n    while(res*res>n){\\n        res--;\\n    }\\n    return res;\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return (int)sqrt(n);\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return int(sqrt(n))\\n```\n```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);\\n    }\\n}\\n```\n```\\nint bulbSwitch(int n){\\n    return sqrt(n);\\n}\\n```\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar bulbSwitch = function(n) {\\n    var res=1;\\n    while(res*res<=n){\\n        res++;\\n    }\\n    while(res*res>n){\\n        res--;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459099,
                "title": "java-1-liner-100-faster-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(sqrt(N))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/1a73b35a-4c42-44d3-8ae6-488dca68aaf0_1682558816.0916822.png)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int bulbSwitch(int n) {\\n        // Find the number of bulbs that are on after n rounds\\n        // The bulbs whose numbers have an odd number of factors will be on after n rounds,\\n        // and if a number has an odd number of factors, it must be a perfect square.\\n        \\n        // Therefore, we can simply find the square root of n and return it as an integer.\\n        // The reason why we take the floor value of the square root is that we need to return\\n        // the count of perfect squares up to n, which is an integer value.\\n        \\n        // Find the square root of n and cast it to an integer\\n        int count = (int) Math.sqrt(n);\\n        \\n        // Return the count of perfect squares\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\npublic class Solution {\\n    public int bulbSwitch(int n) {\\n        // Find the number of bulbs that are on after n rounds\\n        // The bulbs whose numbers have an odd number of factors will be on after n rounds,\\n        // and if a number has an odd number of factors, it must be a perfect square.\\n        \\n        // Therefore, we can simply find the square root of n and return it as an integer.\\n        // The reason why we take the floor value of the square root is that we need to return\\n        // the count of perfect squares up to n, which is an integer value.\\n        \\n        // Find the square root of n and cast it to an integer\\n        int count = (int) Math.sqrt(n);\\n        \\n        // Return the count of perfect squares\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459071,
                "title": "c-easy-single-line-mathy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int BulbSwitch(int n)\\n    {\\n        return (int)Math.Sqrt(n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int BulbSwitch(int n)\\n    {\\n        return (int)Math.Sqrt(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459001,
                "title": "rust-iterators",
                "content": "Count all of the perfect squares within the Range\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn bulb_switch(num: i32) -> i32 {\\n        (1..).map(|n| n * n).take_while(|&n| n <= num).count() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn bulb_switch(num: i32) -> i32 {\\n        (1..).map(|n| n * n).take_while(|&n| n <= num).count() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3163649,
                "title": "easy-to-understand-c-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe answer is number of perfect square from 1 to n inclusive.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor any number switch toggle number of times equal to number of factor it has.\\nOnly perfect square number has odd number of factor, So only that bulb will be on.\\n    For 12 = 1*12,2*6,3*4\\n        number of factor is 6(1,2,3,4,6,12)\\n        it will be off\\n\\n    For 16 = 1*16,2*8,4*4\\n        number of factor is 5(1,2,4,8,16)\\n        it will be on\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(sqrt(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        if(n==0)\\n        {\\n            return 0;\\n        }\\n        int num=1;\\n        while(num*num<=n)\\n        {\\n            num++;\\n        }\\n        return num-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        if(n==0)\\n        {\\n            return 0;\\n        }\\n        int num=1;\\n        while(num*num<=n)\\n        {\\n            num++;\\n        }\\n        return num-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078069,
                "title": "100-beats-with-0ms-in-1-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return pow(n,0.5);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return pow(n,0.5);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835762,
                "title": "one-word-math-solution-very-easy-to-understand-50-ms",
                "content": "```\\nclass Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return int(n**(1/2))",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return int(n**(1/2))",
                "codeTag": "Java"
            },
            {
                "id": 2822840,
                "title": "0-ms-solution-100-faster-only-2-line-code-cpp-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        if(n<=1) return n;\\n        return (int)sqrt(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        if(n<=1) return n;\\n        return (int)sqrt(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755036,
                "title": "python3-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport math\\nclass Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return int(math.sqrt(n))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return int(math.sqrt(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327715,
                "title": "python-solution-explained",
                "content": "The toggle times of each bulb is the number of its factors.\\nbulb 12: 1&12, 2&6, 3&4 (Off at last)\\nbulb 16: 1&16, 2&8, 4&4 (On at last)\\nWe can find that the perfect sqaured number will be on at last. So the problem turns into finding the perfect square number smaller than n.\\n\\n```\\nclass Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return int(sqrt(n))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return int(sqrt(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2248539,
                "title": "maths-explained-the-derivation-in-detail-with-observations",
                "content": "// The solution is 1 liner but requires some Maths understanding so here it is (Put together from various posts)\\n\\n// To start with consider we got a set of bulbs who are ALL OFF\\n// Step 1: TOGGLE every bulb\\n// Step 2: TOGGLE every second bulb\\n// Step 3: TOGGLE every third bulb\\n// Adding step 1 makes it much more clearer for me that STEP NUMBER corresponds to the TOGGLE of the buld at that NUMBER positions\\n\\n// Few Observations: Thanks to @rexthk for Observation 1 & 2 and thanks to @printf_ll_ for Observation 4\\n\\n// Observation #1:\\n// A bulb is ON if it is toggled ODD times: (ON), (ON -> OFF -> ON), (ON -> OFF -> ON -> OFF -> ON) ...\\n// A bulb is OFF if it is toggled EVEN times: (ON -> OFF), (ON -> OFF -> ON -> OFF ) ...\\n\\n// Observation #2:\\n// Once we reach and toggle the i-th bulb, it will never be touched anymore.\\n\\n// for exmaple, let n = 5 ( changes in each round denoted as bold ), initial state is all OFF:\\n// 1-th round : ON, ON, ON, ON, ON\\n// 2-nd round:  ON, OFF, ON, OFF, ON\\n// 3-rd round : ON, OFF, OFF, OFF, ON\\n// 4-th round : ON, OFF, OFF, ON, ON\\n// 5-th round : ON, OFF, OFF, ON, OFF\\n\\n// Observation #3:\\n// The FACTORS of a number ALWAYS comes in a pair\\n// What does that mean ?\\n// Factors of 6 are [1,6] and [2,3] (try any number)\\n// [6 times 1] is 6\\n// [2 times 3] is 6 \\n\\n// Observation #4:\\n// ALL the numbers have EVEN number of factors EXCEPT the numbers which are the perfect SQUARE of some number\\n// WHY ?\\n// Apart from 1, every NON-SQUARE number has ATLEAST two factors, one factor is 1 and other factor is the number itself. And from the Observation 3 we know that if there are more factors of a number other than 1 and the number itself, then they must be in pair. \\n// Also, every SQUARE NUMBER will have atleast 1 and the number itself as a factor but the other PAIR of factor will be the SAME number of which the the number is SQUARE of. For example, Factors of 9 are [1,9] and [3,3] so basically 3 unique factors [1,3,9]\\n\\n// So basically if we can find out somehow that how many times a buld at position X has been toggled, we can find out the total numbers of bulbs that are ON after N steps\\n// So, given a bulb at position X, how do I know it will be toggled EVEN/ODD times ?\\n// Answer: We can find the number of factors of X.\\n// But we do not need to do this. Observation 4 clearly deduce that the ONLY those bulbs will be in ON state which lies on the position which is a PERFECT SQUARE\\n\\n\\n```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n); // This will return me a number which will show HOW MANY bulbs are present at a position which is a perfect square. For ex: n = 42 sp Math.sqrt(42) will be 6 and the positions are (1, 4, 9, 16, 25, 36)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n); // This will return me a number which will show HOW MANY bulbs are present at a position which is a perfect square. For ex: n = 42 sp Math.sqrt(42) will be 6 and the positions are (1, 4, 9, 16, 25, 36)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2102358,
                "title": "square-root-method-explanation",
                "content": "If the `i`th bulb has `n` factors, then the same bulb with get toggled `n` number of times.\\n\\nNow, if the bulb gets toggled:\\n\\n1. An odd number of times - The bulb will be on in the end\\n2. An even number of times - The bulb will be off in the end\\n\\nSo all the bulbs from `1` to `n` will be either on or off depending on if their number of factors is odd or even. Now it gets a bit mathematical.\\n\\nOnly perfect square numbers have an odd number of factors, rest of the numbers have an even number of factors, check [this discussion](https://math.stackexchange.com/questions/525935/why-perfect-square-has-odd-number-of-factors) if you want the reason.\\n\\nSo all the perfect squares from `1` to `n` will be on in the end - the rest will be off. To get the number of perfect squares from `1` to `n` for a number `n`, simply take the square root of that number and truncate it to the floor integer.\\n\\nHence the answer is just the `square root of n`.\\n\\n\\n    def bulbSwitch(self, n):\\n        return int(n**0.5)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "If the `i`th bulb has `n` factors, then the same bulb with get toggled `n` number of times.\\n\\nNow, if the bulb gets toggled:\\n\\n1. An odd number of times - The bulb will be on in the end\\n2. An even number of times - The bulb will be off in the end\\n\\nSo all the bulbs from `1` to `n` will be either on or off depending on if their number of factors is odd or even. Now it gets a bit mathematical.\\n\\nOnly perfect square numbers have an odd number of factors, rest of the numbers have an even number of factors, check [this discussion](https://math.stackexchange.com/questions/525935/why-perfect-square-has-odd-number-of-factors) if you want the reason.\\n\\nSo all the perfect squares from `1` to `n` will be on in the end - the rest will be off. To get the number of perfect squares from `1` to `n` for a number `n`, simply take the square root of that number and truncate it to the floor integer.\\n\\nHence the answer is just the `square root of n`.\\n\\n\\n    def bulbSwitch(self, n):\\n        return int(n**0.5)",
                "codeTag": "Python3"
            },
            {
                "id": 1791262,
                "title": "java-o-1-0ms-using-maths",
                "content": "```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        int a=0;\\n        int x=0;\\n        while(true)\\n        {\\n            if(n<=a)\\n                return x;\\n            x++;\\n            a+=2*x+1;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        int a=0;\\n        int x=0;\\n        while(true)\\n        {\\n            if(n<=a)\\n                return x;\\n            x++;\\n            a+=2*x+1;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1348522,
                "title": "this-is-maths-easy-solution",
                "content": "```\\na=n**0.5\\n\\treturn int(a)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\na=n**0.5\\n\\treturn int(a)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1204580,
                "title": "100-faster-super-easy-concept",
                "content": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        int count=0;\\n        for(int i=1; i*i<=n; i++){\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\nPrimes will get on and then off by 1 and number itself\\nNumbers which are squares will have odd factors hence, they will remain on at last\\nNon squares will have even factors so they will get off at last.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        int count=0;\\n        for(int i=1; i*i<=n; i++){\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126928,
                "title": "simple-solution",
                "content": "class Solution {\\n    public int bulbSwitch(int n) {\\n        int c=0;\\n        for(int i = 1; i * i <= n; i++){\\n          c++;\\n          }\\n    return c;}\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int bulbSwitch(int n) {\\n        int c=0;\\n        for(int i = 1; i * i <= n; i++){\\n          c++;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 1095216,
                "title": "o-1-solution-and-proof",
                "content": "It\\'s enough to calculate up until round 16, to see the pattern:\\n1 0 0 1 0 0 0 0 1 0 0 0 0 0 0 1\\nBulb is \"On\" at all the positions that are perfect squares and only at them.\\n\\nHow to prove it? Here is my try.\\n\\n//---------------------------------------------------------------------------------------------------------\\nObviously: bulb **X** is \"On\" if and only if **X** has odd number of divisors (including 1 and **X** itself).\\n\\nLet **N(X)** be the number of divisors of **X**.\\n\\nAny **X** > 1 can be decomposed as **P^a * R**, where **P** is a prime, and **R** is not divisible by **P**.\\n\\nObserve that:\\n**N(P^1 * R) = 2 * N(R)\\nN(P^2 * R) = 3 * N(R)\\n...\\nN(P^a * R) = (a+1) * N(R)**\\n\\nSo **N(X)** is odd <=> **N(R)** is odd and **a** is even.\\n\\nThis implies: in order for **N(X)** to be odd, it is necessary that all powers of primes in the decomposition be even. Expanding  power of i-th prime as  **2 * ai**, we can expand **X** as:\\n**X = (P1^a1 * P2^a2 * ... * Pn^an) * (P1^a1 * P2^a2 * ... * Pn^an)**\\n\\nSo **N(X)** is odd => **X** is perfect square\\nAnd obviously: **X** is perfect square => **N(X)** is odd\\n\\nSo bulb is \"On\" at all the positions that are perfect squares and only at them.\\n//---------------------------------------------------------------------------------------------------------\\n```\\nclass Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return int(math.sqrt(n))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return int(math.sqrt(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 788489,
                "title": "python3-brain-teaser",
                "content": "This is a more of a brain teaser question than a programming question. Given a number, its factors appear in pair. For example, `6 = 1 x 6 = 2 x 3`. So the 6th light got turned on in 1st round, off in 2nd round, on in 3rd round and off in 6th round. The exceptions are perfect squares for which there are even factors. For example, `4 = 1 x 4 = 2 x 2`. Its sequence from the beginning is `off-on-off-off-on`. \\n\\nAs a result, the question asks to count number of perfect squares up to `n` (inclusive). \\n\\n```\\nclass Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return int(sqrt(n))\\n```\\n\\nPer @WilmerKrisp, utilizing `isqrt` function new in Python 3.8\\n```\\nclass Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return isqrt(n)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return int(sqrt(n))\\n```\n```\\nclass Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return isqrt(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 758527,
                "title": "1-line-solution-in-java-100-faster",
                "content": "The idea behind this-\\nAll the bulbs will become off excpet the perfect square numbers because these numbers will access only two time -\\n1. it will access by its square root that will switch off the bulb and\\n2.  it will access by itself so that this bulb will become on.\\n\\nEx - if n = 7,\\nat the first, all the bulbs are on.\\n2nd time-[on,off,on,off,on,off,on]\\n3rd time - [on,off,off,off,on,on,on]\\n4th time -[on,off,off,on,on,on,on]\\n5th time -[on,off,off,on,off,on,on]\\n6th time- [on,off,off,on,off,off,on]\\n7th time -[on,off,off,on,off,off,off]\\nso only 2 bulbs are on that is 1 & 4.\\n\\n\\n```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.floor((int)Math.sqrt(n));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.floor((int)Math.sqrt(n));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696177,
                "title": "c-straightforward-1-line-after-observing-patterns-math-logic-beats-100",
                "content": "This is really simple if we observe the pattern with few example test runs :\\nGiven n : 3 expected : 1\\nGiven n : 9 expected : 3\\nGiven n : 100 expected : 10\\nGiven n : 25 expected : 5\\nGiven n : 10 expected : 3\\nSo, it boils down to the integer part of the sqrt(n) and hence the below code.\\n```\\nint bulbSwitch(int n){\\n    return sqrt(n);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint bulbSwitch(int n){\\n    return sqrt(n);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 678744,
                "title": "one-line-code-with-explained-cpp-solution",
                "content": "We will make a array of n and every time we will increase its value:\\n**Let n=10;**\\nWe have to count number of operation on ecah index:\\ni.e: if we have performed 4 times the it will be off\\n1->0->1->0\\nSo, if number of times operation is odd then it will be on otherwise it will be off.\\nFor every index+1 we have to find number of factors if it is odd then bulb will be on otherwise it will be off.\\n**Let\\'s say index 5 i.e 6, factors will be : 1,2,3,6 ->4 factors**\\nIt means operation on 5th index will be 4 times.\\nSo it will be off.\\nSo , we have to find numbers which numbers of factors are odd .\\nAnd those numbers are perfect square.\\nPerfect square have odd numbers of factors.\\nSo ans will be  numbers of perfect square between 1 to n.\\nfor n=10:  1,4,9 = 3 ans. \\n\\n\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n    return sqrt(n);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n    return sqrt(n);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 630540,
                "title": "c-explanation",
                "content": "If we consider `n` bulbs that are all initially switched off, in order to have any `i`th bulb turned on at the end of `n` rounds, it must have been toggled an odd number of times [`OFF -> ON | OFF -> ON -> OFF -> ON |` and so on...]. The `i`th bulb is toggled `k` times, where `k` is the number of unique factors of `i`. Thus, 4 is toggled 3 times (one each for the 1st, 2nd, and 4th rounds) and 7 is toggled 2 times (for 1st and 7th). So, we could find the number of numbers with an odd number of unique factors in `O(n * sqrt (n))` time. However, this turns out to be too slow.\\n\\nWe can use a property of perfect squares to speed things up. A perfect square will have an odd number of unique factors. This is because generally, for a given `n`, if a divisor `d` is known, the other divisor is `n / d`. Thus, we can count them in twos. However, for a perfect square, the square root will repeat, and thus not be unique, so we only count it once (if `n` is a perfect square, `sqrt(n) == n / sqrt(n`)). Thus, we can count the number of perfect squares upto and including `n`, which will give us the number of numbers with an odd number of unique factors, which in turn tells us the number of bulbs that will be turned on at the end of `n` rounds. This turns out to be the floor of `sqrt(n) `(that is, we only consider the integral part of `sqrt(n)`.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // O (n sqrt (n)), counting divisors, TLE\\n    // int countDivisors(int x) {\\n    //     int res = 0;\\n    //     if (x == 1)\\n    //         return 1;\\n    //     for (int i = 1; i * i <= x; i++) {\\n    //         if (x % i == 0 && x / i != i)\\n    //             res += 2;\\n    //         else if (x % i == 0)\\n    //             res += 1;\\n    //     }\\n    //     return res;\\n    // }\\n    \\n    int bulbSwitch(int n) {\\n        // int result = 0;\\n        // for (int i = 1; i <= n; i++) {\\n        //     if (countDivisors(i) % 2)\\n        //         result++;\\n        // }\\n        return (int)(sqrt(n));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // O (n sqrt (n)), counting divisors, TLE\\n    // int countDivisors(int x) {\\n    //     int res = 0;\\n    //     if (x == 1)\\n    //         return 1;\\n    //     for (int i = 1; i * i <= x; i++) {\\n    //         if (x % i == 0 && x / i != i)\\n    //             res += 2;\\n    //         else if (x % i == 0)\\n    //             res += 1;\\n    //     }\\n    //     return res;\\n    // }\\n    \\n    int bulbSwitch(int n) {\\n        // int result = 0;\\n        // for (int i = 1; i <= n; i++) {\\n        //     if (countDivisors(i) % 2)\\n        //         result++;\\n        // }\\n        return (int)(sqrt(n));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 444249,
                "title": "c-solution-with-explanation",
                "content": "Bulb is turned on only if it was toggled odd number of times. \\nEvery i-th Bulb toogled in round **1** and round **i**. (2 to toggles count)\\nif **i = j*k** and **j != k** we make + 2 to toggles count.\\nSo toggles count can be odd only if **i** is a perfect square.\\n\\n```\\n   public class Solution\\n        {\\n            public int BulbSwitch(int n)\\n            {\\n                checked\\n                {\\n                    if (n <= 1)\\n                    {\\n                        return n;\\n                    }\\n\\n                    int res = 1;\\n\\n                    for (long i = 2; i * i <= n; i++)\\n                    {\\n                        res++;\\n                    }\\n\\n                    return res;\\n                }\\n            }\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n   public class Solution\\n        {\\n            public int BulbSwitch(int n)\\n            {\\n                checked\\n                {\\n                    if (n <= 1)\\n                    {\\n                        return n;\\n                    }\\n\\n                    int res = 1;\\n\\n                    for (long i = 2; i * i <= n; i++)\\n                    {\\n                        res++;\\n                    }\\n\\n                    return res;\\n                }\\n            }\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 435122,
                "title": "c-100-faster-time-and-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return floor(sqrt(n));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return floor(sqrt(n));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 334310,
                "title": "c-100-plus-explanation",
                "content": "Intuition: \\n\\nwe can think by simulating the process. For example, the 10th bulb will be switched off at the round of every 2 bulbs (OFF), and toggled by the round of every 5 bulbs (ON), then toggled by the round of every 10 bulbs (OFF). So finally it is off. \\n\\nSo to have it ON at the end, it must be toggled EVEN times, including itself. This means the number must have ODD number of factors, and that is, the square number.\\n\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        int count = 0;\\n        for (int i = 1; i*i <= n; i++) {\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        int count = 0;\\n        for (int i = 1; i*i <= n; i++) {\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279101,
                "title": "o-1-time-java-solution-no-math-sqrt-no-math-log-no-long-variables",
                "content": "(I\\'ve updated the comment in the code with a more precise derivation of the math...)\\n\\nThis solution does compute the square root, but it does not use an exhaustive search or Math.sqrt() or even Math.pow()/Math.log().  And it doesn\\'t need a long variable to test the squares of numbers because it computes the square root directly from n using only integer math.\\n\\nLong ago I learned a technique for computing integer sqrts in O(nbits) time.  It\\'s basically a successive approximation technique that starts with a hypothesis that ```i=(1<<15)``` is less than or equal to the sqrt and compares ```i*i``` to the number.  On each comparison, it decides whether to include that bit in the result or discard it and then hypothesize the next bit down.  While you are rejecting the bits, the computations from one step to the next are relatively straightforward with ```i``` reducing by a factor of 2 each time and the square is reducing by a factor of 4.  Once you find a bit you can include in the square root, though, then computing the next value of ```i``` is only slightly more complicated, but computing the next value of ```i-squared``` is a bit more involved.  If you break the math down, then there are really only 3 values you need to keep and a series of shifts and add/subtract operations to move to the next approximation.\\n\\nThis algorithm takes 15 steps to compute the square root of any integer up to 2^31-1 (technically up to ((1<<16)-1)^2 if Java had unsigned math). You could search for the proper initial condition for the ```bsq``` variable based on n to save some steps, but the steps are very quick.\\n\\nHopefully the comments express the incremental math from one step to the next. Though I\\'ve used this before I try to re-derive it when I need to use it rather than cut and pasting from my previous efforts to keep it fresh in my mind.  So I invite you to dig into the math and see how it works for yourself... ;) (I did not come up with this originally, it was shown to me decades ago, so apoligies if this comes from a common source of algorithms...)\\n\\n```\\n    // On each loop we consider a hypothetical guess (i) and its square:\\n    //   isq = i * i\\n    // We compare that value to n and decide if we should increase or decrease\\n    // the i value and thus the isq value.\\n    //\\n    // The pattern we follow in how to guess values for i and come up with new\\n    // guesses is we attempt to construct the i value one bit at a time.\\n    // Every number n<2^31 has a square root with a most significant bit no\\n    // more than 2^15.\\n    // So, we start with a guess for i=2^15 and decide if isq = i*i = 2^30 is\\n    // greater or less than n.  If it is greater, then that bit must not be\\n    // set in its square root.\\n    //\\n    // So, we have 3 values we are talking about here:\\n    //   bit = bit being considered for including in sqrt - 2^15 => 2^0\\n    //   i   = number being considered as sqrt - some accumulation of the bits\\n    //   isq = i * i - the square product of the accumulation of bits\\n    // (Values for the next step will be indicated as i\\', bit\\', and isq\\')\\n    //\\n    // At each stage we consider:\\n    // compute a potential isq = (i+bit) * (i+bit) and compare to n\\n    // depending on how it compares i either stays the same, or becomes (i+bit)\\n    // similarly isq either stays its prior value, or becomes the isq guess\\n    // then we move to the next bit and repeat:\\n    //   is (isq guess > n) ?\\n    //     isq\\' = isq, or isq guess\\n    //     i\\'   = i,   or i+bit\\n    //   bit\\' = bit/2\\n    //\\n    // Now, i, bit, and isq aren\\'t necessarily the best variables to track.\\n    // The primary work needed at each stage is to compute the hypothetical\\n    // value of isq\\' where we\\'ve added the bit and then decide if it was\\n    // \"too much\" and we need to back up or if we really wanted to do that.\\n    //   isq = (i + bit) * (i + bit)\\n    //       = i*i + 2*i*bit + bit*bit\\n    //       = isq + 2*i*bit + bit*bit\\n    // If it was too far, then the next hypothetical value is:\\n    //   isq\\' = (i + bit\\') * (i + bit\\')\\n    //        = i*i + 2*i*bit\\' + bit\\'*bit\\'\\n    // (now sub bit\\'=bit/2)\\n    //        = isq + i*bit     + bit*bit/4\\n    //        = isq - i*bit - bit*bit + bit*bit/4      [eq#1]\\n    // If we want to keep the bit, then the next hypothetical value is:\\n    //   isq\\' = (i\\' + bit\\') * (i\\' + bit\\')\\n    //        = i\\'*i\\' + 2*i\\'*bit\\' + bit\\'*bit\\'\\n    // (sub bit\\'=bit/2)\\n    // (sub i\\'=i+bit)\\n    //        = (i+bit)*(i+bit)  + (i+bit)*bit  + bit*bit/4\\n    //        = isq + (i+bit)*bit + bit*bit/4\\n    //        = isq + i*bit + bit*bit + bit*bit/4      [eq#2]\\n    //\\n    // Comparing eq#1 and eq#2 we see they are mostly the same, but:\\n    //   [eq#1] isq\\' = isq - i*bit - bit*bit + bit*bit/4\\n    //   [eq#2] isq\\' = isq + i*bit + bit*bit + bit*bit/4\\n    //\\n    // So, depending on how isq compares to n, we either add or\\n    // subtract the (i*bit+bit*bit) term and then always add the\\n    // (bit*bit/4) term.\\n    //\\n    // It appears that if we kept the following values, then we would\\n    // have the necessary tools to update our hypothetical value for isq:\\n    //   isq (as above)\\n    //   ibit = i*bit + bit*bit\\n    //   bsq  = bit*bit\\n    //\\n    // How do we update these values from step to step?  We\\'ve already shown\\n    // how to update isq.  Now for the others:\\n    //   bsq\\'  = bit\\'*bit\\'\\n    //         = bit/2 * bit/2\\n    //         = bsq/4\\n    //   ibit\\' = i\\'*bit\\' + bit\\'*bit\\'\\n    //   i\\' = i, or i+bit - so we have 2 equations for i\\' and ibit\\'\\n    // If we don\\'t keep the bit in our sqrt (isq > n), then:\\n    //   ibit\\' = i*bit\\'             + bit\\'*bit\\'\\n    //         = i*bit/2            + bit*bit/4\\n    //         = (ibit - bit*bit)/2 + bsq\\'\\n    //         = (ibit - bsq)/2     + bsq\\'      [eq#3]\\n    // If we do keep the bit, then:\\n    //   ibit\\' = i\\'*bit\\'             + bit\\'*bit\\'\\n    //         = (i+bit)*bit/2       + bit*bit/4\\n    //         = (i*bit + bit*bit)/2 + bsq\\'\\n    //         = ibit/2              + bsq\\'     [eq#4]\\n    //\\n    // So, we mostly compute (ibit/2 + bsq\\') in both cases, but if we\\n    // don\\'t keep the bit, we subtract bsq from ibit first.\\n    //   [eq#3] ibit\\' = (ibit - bsq)/2 + bsq\\'\\n    //   [eq#4] ibit\\' = (ibit      )/2 + bsq\\'\\n    // Revisiting [eq#1] and [eq#2] we get:\\n    //   [eq#1] isq\\'  = isq - i*bit - bit*bit + bit*bit/4\\n    //   [eq#2] isq\\'  = isq + i*bit + bit*bit + bit*bit/4\\n    // Or:\\n    //   [eq#1] isq\\' = isq - ibit + bsq\\'\\n    //   [eq#2] isq\\' = isq + ibit + bsq\\'\\n    //\\n    // Conditionally, for (isq > n) we need to compute (eq1,3):\\n    //      isq -= ibit\\n    //      ibit -= bsq\\n    // and for (isq <= n), we need (eq2,4):\\n    //      isq += bit\\n    // then regardless (in both cases), we need (rest of eq1,2,3,4):\\n    //      bsq >>= 2;\\n    //      isq += bsq;\\n    //      ibit = ibit>>1 + bsq;\\n    //\\n    // In the end, though, we need i, not isq, or ibit or bsq.  It turns\\n    // out, though, that the ibit value on the last iteration will be\\n    // nearly the value we want. Consider when bit=2^0 (and bsq also == 2^0).\\n    // In that case we have:\\n    //   ibit0 = i * 2^0 + 2^0*2^0\\n    //         = i*1 + 1*1\\n    //         = i + 1\\n    // At this point that \"+1\" is hypothetical and we are about to do the\\n    // test to see if we leave it in, or subtract it out.  Once we do that\\n    // test and do the conditional subtraction we then divide by 2 for the\\n    // next step, which will leave us with:\\n    //   ibit_final = i*2^-1 + 2^-1*2^-1\\n    //              = i/2 + 1/4\\n    //   bsq_final  = 1/4\\n    // Adding the 1/4 is not an issue because that is \"0\" in integer math,\\n    // but we\\'d like to avoid the divide by 2. This is easy to arrange, we\\n    // simply have the value for ibit at the top of the loop be:\\n    //   ibit_top = 2*i*bit\\n    // then we do the standard [eq#4] calculations at the top of the loop:\\n    //   ibit_body = ibit_top/2 + bsq\\n    //             = 2*i*bit/2 + bit*bit\\n    //             = i*bit + bit*bit\\n    //             = \"ibit\"\\n    // In the conditional we may or may not subtract bsq, which leaves us with:\\n    //   ibit_bot = (ibit - bsq) or (ibit)\\n    // which is our answer on the last pass.  Similarly, for isq, we\\n    // leave the addition of bsq to the top of the loop rather than put it\\n    // at the bottom, which helps with initial conditions below.\\n    //\\n    // Initial conditions should be:\\n    //   bit  = 1 << 15\\n    //   bsq  = 1 << 30\\n    //   i    = 0\\n    //   ibit = i*bit + bit*bit\\n    //        = 0 + bsq\\n    //   isq = (i+bit)*(i+bit)\\n    //       = (0+bit)*(0+bit)\\n    //       = bsq\\n    // From above, we will be dividing ibit by 2 and adding bsq to both ibit and\\n    // isq at the top of the loop, so we can initialize them to 0 outside of the\\n    // loop and they will be all set to receive their initial values for the body\\n    // when they are adjusted prior to the big test.\\n    //\\n\\tpublic int bulbSwitch(int n) {\\n        int bsq = 1 << 30;\\n        int ibit = 0;\\n        int isq = 0;\\n        while (bsq > 0) {\\n            isq = isq + bsq;\\n            ibit = (ibit >> 1) + bsq;\\n            if (isq > n) {\\n                isq -= ibit;\\n                ibit -= bsq;\\n            } else {\\n                isq += ibit;\\n            }\\n            bsq >>= 2;\\n        }\\n        return ibit;\\n    }\\n```",
                "solutionTags": [],
                "code": "```i=(1<<15)```\n```i*i```\n```i```\n```i```\n```i-squared```\n```bsq```\n```\\n    // On each loop we consider a hypothetical guess (i) and its square:\\n    //   isq = i * i\\n    // We compare that value to n and decide if we should increase or decrease\\n    // the i value and thus the isq value.\\n    //\\n    // The pattern we follow in how to guess values for i and come up with new\\n    // guesses is we attempt to construct the i value one bit at a time.\\n    // Every number n<2^31 has a square root with a most significant bit no\\n    // more than 2^15.\\n    // So, we start with a guess for i=2^15 and decide if isq = i*i = 2^30 is\\n    // greater or less than n.  If it is greater, then that bit must not be\\n    // set in its square root.\\n    //\\n    // So, we have 3 values we are talking about here:\\n    //   bit = bit being considered for including in sqrt - 2^15 => 2^0\\n    //   i   = number being considered as sqrt - some accumulation of the bits\\n    //   isq = i * i - the square product of the accumulation of bits\\n    // (Values for the next step will be indicated as i\\', bit\\', and isq\\')\\n    //\\n    // At each stage we consider:\\n    // compute a potential isq = (i+bit) * (i+bit) and compare to n\\n    // depending on how it compares i either stays the same, or becomes (i+bit)\\n    // similarly isq either stays its prior value, or becomes the isq guess\\n    // then we move to the next bit and repeat:\\n    //   is (isq guess > n) ?\\n    //     isq\\' = isq, or isq guess\\n    //     i\\'   = i,   or i+bit\\n    //   bit\\' = bit/2\\n    //\\n    // Now, i, bit, and isq aren\\'t necessarily the best variables to track.\\n    // The primary work needed at each stage is to compute the hypothetical\\n    // value of isq\\' where we\\'ve added the bit and then decide if it was\\n    // \"too much\" and we need to back up or if we really wanted to do that.\\n    //   isq = (i + bit) * (i + bit)\\n    //       = i*i + 2*i*bit + bit*bit\\n    //       = isq + 2*i*bit + bit*bit\\n    // If it was too far, then the next hypothetical value is:\\n    //   isq\\' = (i + bit\\') * (i + bit\\')\\n    //        = i*i + 2*i*bit\\' + bit\\'*bit\\'\\n    // (now sub bit\\'=bit/2)\\n    //        = isq + i*bit     + bit*bit/4\\n    //        = isq - i*bit - bit*bit + bit*bit/4      [eq#1]\\n    // If we want to keep the bit, then the next hypothetical value is:\\n    //   isq\\' = (i\\' + bit\\') * (i\\' + bit\\')\\n    //        = i\\'*i\\' + 2*i\\'*bit\\' + bit\\'*bit\\'\\n    // (sub bit\\'=bit/2)\\n    // (sub i\\'=i+bit)\\n    //        = (i+bit)*(i+bit)  + (i+bit)*bit  + bit*bit/4\\n    //        = isq + (i+bit)*bit + bit*bit/4\\n    //        = isq + i*bit + bit*bit + bit*bit/4      [eq#2]\\n    //\\n    // Comparing eq#1 and eq#2 we see they are mostly the same, but:\\n    //   [eq#1] isq\\' = isq - i*bit - bit*bit + bit*bit/4\\n    //   [eq#2] isq\\' = isq + i*bit + bit*bit + bit*bit/4\\n    //\\n    // So, depending on how isq compares to n, we either add or\\n    // subtract the (i*bit+bit*bit) term and then always add the\\n    // (bit*bit/4) term.\\n    //\\n    // It appears that if we kept the following values, then we would\\n    // have the necessary tools to update our hypothetical value for isq:\\n    //   isq (as above)\\n    //   ibit = i*bit + bit*bit\\n    //   bsq  = bit*bit\\n    //\\n    // How do we update these values from step to step?  We\\'ve already shown\\n    // how to update isq.  Now for the others:\\n    //   bsq\\'  = bit\\'*bit\\'\\n    //         = bit/2 * bit/2\\n    //         = bsq/4\\n    //   ibit\\' = i\\'*bit\\' + bit\\'*bit\\'\\n    //   i\\' = i, or i+bit - so we have 2 equations for i\\' and ibit\\'\\n    // If we don\\'t keep the bit in our sqrt (isq > n), then:\\n    //   ibit\\' = i*bit\\'             + bit\\'*bit\\'\\n    //         = i*bit/2            + bit*bit/4\\n    //         = (ibit - bit*bit)/2 + bsq\\'\\n    //         = (ibit - bsq)/2     + bsq\\'      [eq#3]\\n    // If we do keep the bit, then:\\n    //   ibit\\' = i\\'*bit\\'             + bit\\'*bit\\'\\n    //         = (i+bit)*bit/2       + bit*bit/4\\n    //         = (i*bit + bit*bit)/2 + bsq\\'\\n    //         = ibit/2              + bsq\\'     [eq#4]\\n    //\\n    // So, we mostly compute (ibit/2 + bsq\\') in both cases, but if we\\n    // don\\'t keep the bit, we subtract bsq from ibit first.\\n    //   [eq#3] ibit\\' = (ibit - bsq)/2 + bsq\\'\\n    //   [eq#4] ibit\\' = (ibit      )/2 + bsq\\'\\n    // Revisiting [eq#1] and [eq#2] we get:\\n    //   [eq#1] isq\\'  = isq - i*bit - bit*bit + bit*bit/4\\n    //   [eq#2] isq\\'  = isq + i*bit + bit*bit + bit*bit/4\\n    // Or:\\n    //   [eq#1] isq\\' = isq - ibit + bsq\\'\\n    //   [eq#2] isq\\' = isq + ibit + bsq\\'\\n    //\\n    // Conditionally, for (isq > n) we need to compute (eq1,3):\\n    //      isq -= ibit\\n    //      ibit -= bsq\\n    // and for (isq <= n), we need (eq2,4):\\n    //      isq += bit\\n    // then regardless (in both cases), we need (rest of eq1,2,3,4):\\n    //      bsq >>= 2;\\n    //      isq += bsq;\\n    //      ibit = ibit>>1 + bsq;\\n    //\\n    // In the end, though, we need i, not isq, or ibit or bsq.  It turns\\n    // out, though, that the ibit value on the last iteration will be\\n    // nearly the value we want. Consider when bit=2^0 (and bsq also == 2^0).\\n    // In that case we have:\\n    //   ibit0 = i * 2^0 + 2^0*2^0\\n    //         = i*1 + 1*1\\n    //         = i + 1\\n    // At this point that \"+1\" is hypothetical and we are about to do the\\n    // test to see if we leave it in, or subtract it out.  Once we do that\\n    // test and do the conditional subtraction we then divide by 2 for the\\n    // next step, which will leave us with:\\n    //   ibit_final = i*2^-1 + 2^-1*2^-1\\n    //              = i/2 + 1/4\\n    //   bsq_final  = 1/4\\n    // Adding the 1/4 is not an issue because that is \"0\" in integer math,\\n    // but we\\'d like to avoid the divide by 2. This is easy to arrange, we\\n    // simply have the value for ibit at the top of the loop be:\\n    //   ibit_top = 2*i*bit\\n    // then we do the standard [eq#4] calculations at the top of the loop:\\n    //   ibit_body = ibit_top/2 + bsq\\n    //             = 2*i*bit/2 + bit*bit\\n    //             = i*bit + bit*bit\\n    //             = \"ibit\"\\n    // In the conditional we may or may not subtract bsq, which leaves us with:\\n    //   ibit_bot = (ibit - bsq) or (ibit)\\n    // which is our answer on the last pass.  Similarly, for isq, we\\n    // leave the addition of bsq to the top of the loop rather than put it\\n    // at the bottom, which helps with initial conditions below.\\n    //\\n    // Initial conditions should be:\\n    //   bit  = 1 << 15\\n    //   bsq  = 1 << 30\\n    //   i    = 0\\n    //   ibit = i*bit + bit*bit\\n    //        = 0 + bsq\\n    //   isq = (i+bit)*(i+bit)\\n    //       = (0+bit)*(0+bit)\\n    //       = bsq\\n    // From above, we will be dividing ibit by 2 and adding bsq to both ibit and\\n    // isq at the top of the loop, so we can initialize them to 0 outside of the\\n    // loop and they will be all set to receive their initial values for the body\\n    // when they are adjusted prior to the big test.\\n    //\\n\\tpublic int bulbSwitch(int n) {\\n        int bsq = 1 << 30;\\n        int ibit = 0;\\n        int isq = 0;\\n        while (bsq > 0) {\\n            isq = isq + bsq;\\n            ibit = (ibit >> 1) + bsq;\\n            if (isq > n) {\\n                isq -= ibit;\\n                ibit -= bsq;\\n            } else {\\n                isq += ibit;\\n            }\\n            bsq >>= 2;\\n        }\\n        return ibit;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 186579,
                "title": "mathematical-explanation",
                "content": "The number `x` can be represented as\\n\\n```\\nx = p1^k1 * p2^k2 * p3^k3 ... pn^kn\\n```\\nwhere `pi` is the prime base.\\n\\nThe number of factors equals to \\n```\\n# of factors = (k1+1)*(k2+1)*(k3+1)...(kn+1)\\n```\\n\\nThe light `x` is on if and only if `x` has odd factors. Therefore `k1, k2, ...kn` must be even.\\n\\nObviously, `x` is a square number and the root is \\n\\n```\\nsqrt(x) = p1^(k1/2) * p2^(k2/2)...pn^(kn/2)\\n```\\n\\nSolution:\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return (int)sqrt(n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nx = p1^k1 * p2^k2 * p3^k3 ... pn^kn\\n```\n```\\n# of factors = (k1+1)*(k2+1)*(k3+1)...(kn+1)\\n```\n```\\nsqrt(x) = p1^(k1/2) * p2^(k2/2)...pn^(kn/2)\\n```\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return (int)sqrt(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 176688,
                "title": "one-line-soution-and-how-to-reach-there-intuation",
                "content": "# **intuation**\\nWhen I first looked at the question, my first thought was dynamic programming as you can see the nth position does not affect results upto (n-1) position\\nso \\n`dp[n] = dp[n-1] + 1` if n is on\\n`dp[n] = dp[n-1]` if n is off\\nAll that left was to calculate wheater nth bulb was off on,so I wrote the code\\n```\\nint count(int n) {\\n\\tint nof = 0;\\n\\tfor (int i=1;i<sqrt(n);i++) {\\n\\t\\tif(n%i==0) nof+=2;\\n\\t}\\n\\tif (sqrt(n)*sqrt(n) == n) nof++;\\n\\treturn nof;\\n}\\n```\\nIf nof was odd, than it\\'s off otherwise on.\\nThan it hit me, nof can only be odd if it is a perfect square, than the problem simply become counting the number of perfect square till n\\n\\n# Solution\\n```\\nreturn sqrt(n);\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nint count(int n) {\\n\\tint nof = 0;\\n\\tfor (int i=1;i<sqrt(n);i++) {\\n\\t\\tif(n%i==0) nof+=2;\\n\\t}\\n\\tif (sqrt(n)*sqrt(n) == n) nof++;\\n\\treturn nof;\\n}\\n```\n```\\nreturn sqrt(n);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 77119,
                "title": "one-line-solution-in-c",
                "content": "since only perfect squares have odd number of factors!!\\n\\n\\n\\n    class Solution {\\n    public:\\n        int bulbSwitch(int n)\\n                {\\n                     int k=sqrt(n);\\n                  return k;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int bulbSwitch(int n)\\n                {\\n                     int k=sqrt(n);\\n                  return k;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 77163,
                "title": "java-one-line-solution",
                "content": "     public int bulbSwitch(int n) {\\n            return (int)Math.sqrt(n);\\n        }",
                "solutionTags": [],
                "code": "     public int bulbSwitch(int n) {\\n            return (int)Math.sqrt(n);\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3947493,
                "title": "very-simple-c-code-for-beginner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n       return sqrt(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n       return sqrt(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609541,
                "title": "complete-thought-process-beats-100-beginner-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first thought that came to me when i saw the question and constraints is that this is a math question, $$i.e.$$, simulating this \\'situation\\' just wont cut it for the time constraints.\\nBut then how do we approach the question, at first I had no idea.\\nSo i did the simulation myself for the first 10 numbers $$i.e.$$ 1-10.\\nThis is a very important lesson, some example test cases can help you get an idea of what the pattern of the answers for a given input is.\\n\\nHere\\'s the results for the first 10 numbers.\\n\\n![image.png](https://assets.leetcode.com/users/images/bf3230cf-85e6-45c0-8fb7-93b6376da644_1686145617.1277115.png)\\n\\nWe can see that the answer is incremented when we hit a perfect square, furthermore, the answer is the square root of the last perfect square (floor of the square root of any number).\\n\\nAdmittedly, this is just a hunch, but is wort trying to implement, also there are other patterns you \"get\" from this sequence of numbers, but this is the most plausable.\\n\\nHence I wrote code for it and **BAM!!** it worked.\\nNow what is important is that you think **WHY** it worked. Since we already know the answer, this process will be much easier.\\n\\nI would implore you to think for yourself why this solution works, I have given the reason at the end of this solution.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nBruhh, we just return the square root of the given integer\\uD83D\\uDE02.\\n\\n# Complexity\\n- Time complexity: O(1).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        if(n <= 1) return n;\\n        return sqrt(n);\\n    }\\n};\\n```\\n\\n# Why this logic works\\n\\nDude seriously?? think for yourself, **YOU CAN DO THIS**\\uD83D\\uDE03\\uD83D\\uDE03",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        if(n <= 1) return n;\\n        return sqrt(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582550,
                "title": "one-line-code-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513605,
                "title": "one-liner-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n\\n       int ans=sqrt(n);\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n\\n       int ans=sqrt(n);\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489030,
                "title": "1-line-solution-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return sqrt(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return sqrt(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462939,
                "title": "one-liner-solution-with-example",
                "content": "# Intuition\\n0-0\\n\\n1-1\\n\\n2-1 0\\n\\n3-1 0 0\\n\\n4-1 0 0 1\\n\\n5-1 0 0 1 0\\n\\n6-1 0 0 1 0 0\\n\\n7-1 0 0 1 0 0 0\\n\\n\\n8-1 0 0 1 0 0 0 0\\n\\n9-1 0 0 1 0 0 0 0 1\\n\\n10-1 0 0 1 0 0 0 0 1 0\\n\\n\\n11-1 0 0 1 0 0 0 0 1 0 0\\n\\n12-1 0 0 1 0 0 0 0 1 0 0 0\\n\\n13-1 0 0 1 0 0 0 0 1 0 0 0 0\\n\\n14-1 0 0 1 0 0 0 0 1 0 0 0 0 0\\n\\n15-1 0 0 1 0 0 0 0 1 0 0 0 0 0 0\\n\\n16-1 0 0 1 0 0 0 0 1 0 0 0 0 0 0 1\\n\\n\\n# Approach\\n\\nthe occurence of one is the square position of the number deduced from the pattern\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int bulbSwitch(int n) {\\n        \\n        return sqrt(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int bulbSwitch(int n) {\\n        \\n        return sqrt(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462022,
                "title": "explanation-of-factoring-through-fundamental-theorem-of-arithmetic",
                "content": "# Approach\\nonly those bulbs are toggled whose indexes have an odd number of factors.\\nAccording to the main theorem of arithmetic, every number can be factored into prime factors in unique way (my favorite theorem).\\nExamples:\\n18 -> (3,3,2)\\n9 -> (3,3)\\n5 -> (5)\\n\\nSo, how many different factors do we have (not only prime)?\\n\\nTo enumerate all factors, we can combine prime factors, and the total number of factors is equal to the number of combinations of prime factors (supersets in combinatorics).\\n\\nFor example, for 12:\\n1 (we don\\'t choose any of the prime factors),\\n3, 2, 2*3, 2*2, 2*2*3.\\n\\nThere are 3 options for choosing 2 (0 2s or 1 2s, 2 2s) and two options for choosing 3 (0 3s, 1 3s).\\n\\nSuppose we have a number N and its prime factors: A^a, B^b, C^c, where \"a\" is the number of As, \"b\" is the number of Bs, and \"c\" is the number of Cs. We can choose 0 As, 1 As, 2 As, and so on, up to \"a\" As. The same is true for Bs and Cs.\\n\\nThe total number of different factors for number N is equal to the number of possible counts for A times possible counts for B and so on. So it is equal to (a+1)(b+1)(c+1). It is easy to see that this number can be even only if one of \"a\", \"b\", or \"c\" is odd. So, the odd number of factors can be only if all of prime factors have even degree, such numbers are perfect square.\\n\\nThe last question is: how many perfect squares are there until some number N? Just draw a multiplication table in this format, and it will be clear.\\n1   2 3 4\\n1-1\\n2---4\\n3-----6\\n4-------8\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(1)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return int(n**0.5)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return int(n**0.5)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461877,
                "title": "1-line-java-solution-100-faster-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461874,
                "title": "easy-c-solution-beat-100",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/efdbca8a-a4a5-4686-bd4e-35e46b76356a_1682628831.2636185.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return sqrt(n);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        return sqrt(n);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461736,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        long long i=1;\\n        int ct=0;\\n        while((i*i)<=n){\\n            i++;\\n            ct++;\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        long long i=1;\\n        int ct=0;\\n        while((i*i)<=n){\\n            i++;\\n            ct++;\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461580,
                "title": "explanation-with-image-in-javascript",
                "content": "![image.png](https://assets.leetcode.com/users/images/f15c5d3a-846c-4f19-a5b5-de409cc59d38_1682619244.8537414.png)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI didn\\'t want to look at the solutions and wrote all states for 10 bulbs. I was going to solve this problem with bunch of if & elses. Surprisingly, I realized that in the end bulbs which are in the index of square numbers are always remain turned on. To find the answer, we only need to find the square root of n.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar bulbSwitch = function(n) {\\n    return Math.floor(Math.sqrt(n));\\n};\\n```\\n\\n# If You Like, Please, Upvote!",
                "solutionTags": [
                    "JavaScript",
                    "Math",
                    "Brainteaser"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar bulbSwitch = function(n) {\\n    return Math.floor(Math.sqrt(n));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3461564,
                "title": "fundamental-theorem-of-arithmetic-approach",
                "content": "# Approach\\nLet us consider an arbitrary number $$m$$. It can be expressed as a product of prime factors, using the fundamental theorem of arithmetic: $$m = p_1^{i_1} \\\\cdot p_2^{i_2} \\\\cdot \\\\ldots \\\\cdot p_j^{i_j}$$, where $$p_j$$ are prime numbers.\\n\\nTo count the number of toggles for $$m$$, we need to count its divisors. The total number of divisors of $$m$$ is the product of the powers of each prime factor plus one, i.e. $$\\\\prod_{k=1}^{j} (i_k + 1)\\n$$. However, we don\\'t want to count \"1\" as a divisor, because on the first step we turn on all bulbs. Therefore, we should subtract 1 from the total number of divisors to get the total number of toggles, which is $$\\\\prod_{k=1}^{j} (i_k + 1) - 1$$.\\n\\nIf any of the powers $$i_k$$ is odd, the product would be even, because the product contains an odd power plus one, which is a multiple of two. Thus, the total number of toggles would be odd. Therefore, the number of toggles is even only if all powers are even, which implies that the number is a perfect square.\\n\\nHence, for all bulbs with a non-perfect square number, there will be an odd number of toggles, which means they will be turned off. Bulbs with a perfect square number will stay turned on.\\n\\nTo find the answer, we just need to know how many perfect square numbers there are in n, which is easy to determine.\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n\\n# Code\\n```\\npublic class Solution {\\n    public int BulbSwitch(int n) {\\n        return (int)Math.Sqrt(n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Math"
                ],
                "code": "```\\npublic class Solution {\\n    public int BulbSwitch(int n) {\\n        return (int)Math.Sqrt(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461469,
                "title": "bulb-switcher",
                "content": "# Intuition\\nAnalyze the pattern by number of testcases.\\n\\n# Approach\\nif(n=0) then 0 b/c square root of 0 is 0\\nif(n=1,2,3) then 1 b/c b/c square root of 1,2,3 is 0\\nif(n=4,5,6,7,8,9) then 2 b/c square root of 4 to 9 is 0\\nif(n=10,11,12,13,14,15) then 3\\nif(n=16 to 24) then 4\\n\\n# Complexity\\n- Time complexity: O(sqrt(n))\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        \\n        ans=int(math.sqrt(n))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        \\n        ans=int(math.sqrt(n))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461445,
                "title": "easy-one-line-code-100-faster-submission",
                "content": "**there is a simple concept of perfect squares , once you got the pattern , you crack it**\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n         return sqrt(n);\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/82ed45d4-9b9c-49e0-951d-1691261ee443_1682616819.7843864.jpeg)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n         return sqrt(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461386,
                "title": "simple-code-in-c-language-beginner-s-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint bulbSwitch(int n){\\nint i = 1;\\n        int g = 0;\\n                int count = 0 ;\\n                        while(g < n)\\n                                {\\n                                            i = i + 2 ;\\n                                                        g = g + i;\\n                                                                    count = count + 1;\\n                                                                            }\\n                                                                                    return count;\\n}\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\nint bulbSwitch(int n){\\nint i = 1;\\n        int g = 0;\\n                int count = 0 ;\\n                        while(g < n)\\n                                {\\n                                            i = i + 2 ;\\n                                                        g = g + i;\\n                                                                    count = count + 1;\\n                                                                            }\\n                                                                                    return count;\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3461380,
                "title": "easy-math-solution-php",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $n\\n     * @return Integer\\n     */\\n    function bulbSwitch($n) {\\n        $i = 1;\\n        $ct = 0;\\n\\n        while ($i * $i <= $n) {\\n            $i++;\\n            $ct++;\\n        }\\n\\n        return $ct;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $n\\n     * @return Integer\\n     */\\n    function bulbSwitch($n) {\\n        $i = 1;\\n        $ct = 0;\\n\\n        while ($i * $i <= $n) {\\n            $i++;\\n            $ct++;\\n        }\\n\\n        return $ct;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461346,
                "title": "easy-c-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n       return (int)sqrt(n);\\n   }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n       return (int)sqrt(n);\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461332,
                "title": "java-sqrt",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461200,
                "title": "bulb-switcher-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(sqrt(n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        int i, count=0;\\n        if(n==0)\\n            return 0;\\n        for(i=1 ; i<=sqrt(n) ; i++)\\n        {\\n            if(i*i<=n)\\n            {\\n                count++;\\n            }\\n            else\\n                return count;\\n        }\\n        return count;\\n    }\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/2b954b3a-3c0a-4571-8e1b-eb457a037a2e_1682612318.2669694.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bulbSwitch(int n) {\\n        int i, count=0;\\n        if(n==0)\\n            return 0;\\n        for(i=1 ; i<=sqrt(n) ; i++)\\n        {\\n            if(i*i<=n)\\n            {\\n                count++;\\n            }\\n            else\\n                return count;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564812,
                "content": [
                    {
                        "username": "rexthk",
                        "content": "Below are my step by step thought process. Hope it helps\\n\\nObservation #1:\\nA bulb is ON if it is toggled **odd** times: (ON), (ON -> OFF -> ON), (ON -> OFF -> ON -> OFF -> ON) ...\\nA bulb is OFF if it is toggled **even** times: (ON -> OFF), (ON -> OFF -> ON -> OFF ) ...\\n\\nObservation #2:\\nOnce we reach and toggle the ***i-th*** bulb, it will never be touched anymore.\\n\\nfor exmaple, let n = 5 ( changes in each round denoted as bold ), initial state is all OFF:\\n1-th round :   **ON,  ON,  ON,  ON, ON**\\n2-nd round:   ON, **OFF**,  ON, **OFF**, ON\\n3-rd round :   ON, OFF, **OFF**, OFF, ON\\n4-th round :   ON, OFF, OFF, **ON**, ON\\n5-th round :   ON, OFF, OFF, ON, **OFF**\\n\\nYou can see that, after each round, all bulbs before that round will not be touched anymore.\\n\\nSo, given a bulb at position X, how do I know it will be toggled EVEN/ODD times ?\\nAnswer: We can find the number of divisors of X. \\n\\nfor example, if the position of a bulb is 3, its divisor is [1,3], that mean we will toggle the 3-rd bulb at 1-st round and 3-rd round:\\nCombine the observation above, \\nat ***3-rd*** round, the third bulb will have been toggeld even times ( [1,3] ), so it is OFF. And it will not be changed later on round.\\nat ***5-th*** round, the fifth bulb will have been toggled even times ( [1,5] ), so it is OFF. And it will not be changed later on round.\\n\\nSuppose we have a func to get all divisors of i : **getDivisors(int)**, a simple algorithm can be deduced:\\n`for i = 1..n, if getDivisors(i) % 2 == 1, count++;`\\nWe loop through all positions, if it has odd number of divisors, it is ON and hence count + 1.\\n\\nUnfortunately, it will timeout. How to optimize ?\\n\\nObservation #3:\\nDivisors always come in pair. For example:\\n1: [1,1]  ---  2: [1,2] --- 3: [1,3] --- 4: [1,4] [2,2] --- 5:[1,5] --- 6:[1,6][2,3] --- 7:[1,7] \\n8: [1,8][2,4] --- 9:[1,9][3,3]\\n\\nIn above examples, we know that: \\nOnly when ***i*** has **perfect square root**, its number of divisors is ODD, because it contains duplicated divisor. In above example,\\n4: [1,2,4] --- 9: [1,3,9]\\nYou can pick any number to examine yourself.\\n\\nHere comes a better algorithm:\\n`for i = 1...n,  if i^2 <= n, count++ ; if i^2 > n, break;`\\nWe loop through all position, if **i^2** is <= n, that means there exists a valid bulb which has perfect square root ***i***, and we need to count that **i^2**, so count + 1. If the **i^2** exceed n, we can terminate it because we have found all ***i*** with perfect square root within n already.\\n\\nMany of you might have seen the answer, so why the answer can be simply written as Math.sqrt(n) ?\\nconsider n = 9, the process of aforementioned algorithm will be: \\ncheck (1 * 1 ) <= 9, count++\\ncheck (2 * 2 ) <= 9, count++;\\ncheck (3 * 3) <= 9, count++;\\ncheck (4 * 4) > 9, break;\\n\\nWe can say, if square root of 9 is 3, that mean **1^2** and **2^2** must exists for n = 9. Hence, the Math.sqrt(i) reflect this fact.\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "I got to observation 2 on my own. The condition for an odd number of divisors was eluding me, thanks for the help"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "mind glowing explanation\\n"
                    },
                    {
                        "username": "saidfgn",
                        "content": "Great explanation, thanks!"
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "**Its more like a puzzle rather than a coding problem**"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "[@yusufm09](/yusufm09) brain tester problem means does they ask this in interviews"
                    },
                    {
                        "username": "yusufm09",
                        "content": "[@jerryy147](/jerryy147) I never knew that there was a brainteaser problem list. Thanks."
                    },
                    {
                        "username": "jerryy147",
                        "content": "that\\'s why it\\'s in the \"brainteaser\" problem list"
                    },
                    {
                        "username": "strongwillow",
                        "content": "It only stated the first, second, third, and last round. Should be updated as follows:\\n\\nThere are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). **For the ith round, you toggle every i bulb.** For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds."
                    },
                    {
                        "username": "sx1w",
                        "content": "Like many of you are wondering why a simple sqaure root solution to the problem, I wanted to find out why that is correct. Here is my little research into it. \\n\\nThe light bulb at postion k must be toggled in odd number to stay on, e.g. \\'On, Off, On\\' including the initial toggle. What triggers k-th bulb be toggled? Number k must be an **exact** multiple of each toggling. For example, when k=4, the bulb will be triggered by the 1st (On), 2nd (Off) and 4th (On) operation. What is the exact number of multiple of a nature number k? **All of its factors** ! \\n\\nSo the k-th bulb \\'ON\\' is corresponding to the number of factors of k being odd. You can certainly develop a program to count. However, the [*number math*](http://mathcentral.uregina.ca/QQ/database/QQ.09.06/jacqueline1.html) tells us only perfect square numbers have odd number of factors, which is what needed for the bulb to stay on. \\n\\nGreat! Now to solve the problem is to find out how many perfect square number between 1 and n. The [*math*](https://www.quora.com/How-many-perfect-squares-are-there-between-1-to-1000) kicks in again, and that number is the square root of n (more preceisly the floor of sqaure root of n). \\n\\nWhat a great problem!"
                    },
                    {
                        "username": "bharathb",
                        "content": "A lot of other posts provide code / suggest a simulation to see the pattern. I will attempt to describe the intuition behind the solution. \\n\\n* First let s identify all the bulbs that can touch/affect/toggle bulb X. Bulb X can only be toggled by other bulbs which are less than or equal to X. For example, 26 will never toggle bulb 23.\\n* Secondly, for a bulb X what are the bulbs that can toggle X? 23 can never toggle 25. We notice that a bulb X can only be toggled by divisors of X - including 1 and X itself. \\n* Now let s consider prime numbers. Prime numbers by definition have exactly two divisors. Any number with 2 divisors will never be ON at the end - because 1 will set it to ON and the second divisor (the prime number itself) will toggle it off.\\n* With prime numbers gone, lets consider a composite number with an even number of divisors.  Say 24. The divisors of 24 are (1,2,3,4,6,8,12,24). Listing the divisors as pairs - (1, 24) (2,12), (3,8), (4,6) - pairs are crucial because one divisor will set 24 to ON and the other divisor will set it to OFF. So, the net result is that those bulbs will NOT be ON at the end of the simulation - because they are initially OFF. They are toggled an even number of times.\\n* Now, we need to find numbers <=N which have an odd number of divisors. This might not be intuitive immediately and this simulating the problem on paper helps. If we consider a perfect square like 36 and write the divisors in pairs - (1,36), (2,18), (3, 12), (4, 9), (6,6). Now, we can see that while all other divisors cancel each other out - (they toggle the bulb twice) - 6 has no counterpart to toggle the bulb off. So, when there are 36 bulbs, 6 will always be ON at the end. The same holds true for perfect squares less than N - which are 1,4,9,16,25.\\n* Based on the above inferences, we can see that we need to find the numbers less than N that are perfect squares.  We can calculate this (int) Math.sqrt(N) or have a simple for-loop to count (i*i) <=N \\n\\nHope this helps."
                    },
                    {
                        "username": "rajeshkumar1130",
                        "content": "I was asked this question in an interview with microsoft on 22-01-2021"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It just proves that an ordinary position at MS is a dead-end job."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@sandagolcea](/sandagolcea)  Nice solution bro! The code is also quite neat. Good job!"
                    },
                    {
                        "username": "algoacer",
                        "content": "[@code_coffeee](/code_coffeee) Acutally it is so true, some one gets to implement a plain algorithm and someone has to think out of the box in 40 minutes. Not fair. But we should keep applying at multiple companies."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@code_coffeee](/code_coffeee) do you mean a TLE? I've actually solved it differently, using rather simple mathematics, but not sqrt (which i know was quite obvs, but I thought of doing smth else :D ) here https://leetcode.com/problems/bulb-switcher/solutions/3461670/js-solutions-without-using-sqrt/ "
                    },
                    {
                        "username": "l3aonti",
                        "content": "[@dvijay96](/dvijay96) it throws memory limit exception "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@code_coffeee](/code_coffeee) Brute force n^2 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "they what happened bro how did you explain "
                    },
                    {
                        "username": "code_coffeee",
                        "content": "This makes me sad.\\n\\nI feel like if they ask anyone this, they must not want to hire this person. If anyone codes it in any way without using square root, it is  a rejection."
                    },
                    {
                        "username": "bingzhoudaren",
                        "content": "First, we need to figure out how do we know if the ith light is on or off at the end. \\nit dpends on how many numbers could output i after you get product of them.\\nfor example 6, \\nwe will toggle the 6th light in the first round becasue 1 times6=6\\nwe will toggle the 6th light in the second round because 2 times 3=6;\\nwe will toggle the 6th light in third round beacuse 3 times 2 =6;\\nand we will toggle the 6th light in 6th round beacuse 6 times 1=6;\\n\\nso since wil have 1,2,3,6,totally four numbers, we will toggle the 6th light 4 times.\\nand since 4 is even ,so the 6th light will be off at the end.\\n\\nand for example, 9 could have division 1,3,9,  there are three of them. which is odd, so the 9th light is on at the end.\\n\\n\\nthen the problem is to figure out which number have odd divisions, which have even.\\n\\nthen, we should realize that,  for no-square number, the divisions can be paired.\\n\\nfor example, for 6, 1,and 6 is a pair, 2 and 3 is a pair.\\nhowever, for square number, for example 9, 3 will pair by itself, or we could say, 3 does not have a partener to build a pair.\\n\\nso, only lights at square numbers position will be on at the end.\\n\\nso, if we have 10 lights, at the end, only 1,4,9 light will be on.\\n\\n\\nand how to count them? by sqrt(10), we could get 3, which is the number of square numbers smaller than 10\\n\\n\\n\\n"
                    },
                    {
                        "username": "warrenbrodsky",
                        "content": "To begin, let\\'s forget keeping track of *every*  bulb and only think about *one*. Clearly, this bulb can either be on or off.  While obvious, this is still significant. If we know how many times we toggled the bulb, we can figure out which state it is in: If we have a bulb that begins on and we toggle it once, it will be off. Twice, on again. Thrice, off, four times on, five off, six on, etc. OK, so the answer is parity -- even flips it\\'s on, odd it\\'s off. \\n\\nGreat, but we don\\'t flip every bulb on every iteration, so how do we know how many times we flipped it? Ok, well on the first pass, we flip every other bulb, that is, every bulb whose index is a multiple of 2 (assuming indexing starts from 1 ;) ). On the next, we toggle every multiple of 3. On the next, multiples of 4, etc. When we\\'re done, we\\'ll have flipped every bulb once for each number that it is a multiple of, which is to say, once for each *divisor*. (Importantly, we include itself, but not 1.) For example, bulb 6 is flipped off for 2, on for 3, and off one final time for 6. Another important fact is that divisors come in pairs -- it and the thing it has to be multiplied with to get the number. The ***only*** time this isn\\'t true is if the thing it is multiplied by is itself. In other words, it\\'s a perfect square. Therefore perfect squares will *always* have an *odd* number of divisors and all others have *even* numbers of divisors. Since we\\'re not including one as a divisor, the parity flips and therefore, when all is said and done, only bulbs with perfect square indices will remain on.\\n\\nBulk of the work done -- now we just need to know how many perfect squares there are from 1 to n (which I will call squaresLTE(n)) and that will be our answer. This is fairly simple: beginning with n=1 and squaresLTE(1) = 1, we can see squaresLTE(2) is still 1,  squaresLTE(3) is still 1, and we finally get another square when n=4 and squaresLTE(4)=2 -- 1, and 4. We don\\'t add another square to the list until n=the next square. This gives us the final answer:\\n\\n`bulbs(n) = squaresLTE(n) = floor(sqrt(n))`\\n\\nThis works because if we\\'re between two squares a=s^2 and b=(s+1)^2, sqrt(n) will be some number between s and s+1, so floor(sqrt(n)) will bring us down to the sqrt of the last square we added to the list"
                    },
                    {
                        "username": "dilipK",
                        "content": "* If a particular number n is divisible by k , it means it will also  be divisible by n/k. So it will bring it to original state i.e.off. So toggling at kth iteration will turn ON but toggling at (n/k)th iteration will bring it to OFF. So no change.\\n* But for a prefect square sqrt(n) will only toggle it once , so it will be overall ON."
                    },
                    {
                        "username": "suhane",
                        "content": "# Logic : 1st round Bulb is ON, then each switch will OFF then ON. so for any number ->\\n# 1st round : ON\\n# 2nd round : OFF\\n# 3rd round : ON \\n# 4th round : OFF  and so on ....\\n# \\n# **If we can calculate how many times each bulb is switched we can tell it was ON/OFF at the last.**\\n# \\n# from above we can see if we switch bulb EVEN times we get it OFF at last, if switch ODD times we get it ON at the last.**\\n\\n*Now take few examples to understand better-*\\nN=1 -> bulb switched 1 time (for N=1)  \\t\\t\\t-> OFF at last\\n\\nN=2 -> bulb switched 2 times (for N=1, 2) \\t\\t-> OFF at last\\n\\nN=3 -> bulb switched 2 times (for N=1, 3) \\t\\t-> OFF at last\\n\\nN=4 -> bulb switched 3 times (for N=1, 2, 4) \\t-> **ON** at last\\n\\nN=5 -> bulb switched 2 times (for N=1, 5) \\t\\t-> OFF at last\\n\\nN=6 -> bulb switched 4 times (for N=1, 2, 3, 6) -> OFF at last\\n\\nN=7 -> bulb switched 2 times (for N=1, 7)\\t\\t-> OFF at last\\t\\n\\nN=8 -> bulb switched 8* times (for N=1, 2, 4, 8)\\t-> OFF at last\\t\\n(how we got 8 switches -\\nadd all switches of\\nN=1 (1 times at N=1),\\nN=2 (2 times at N=1,2), \\nN=4 (3 times at N=1,2,4) ,\\nN=8 (2 time at N=1,8))\\n\\nN=9 -> bulb switched 3 times (for N=1, 3, 9)\\t-> **ON** at last\\t\\n\\nAs you can see from above we got a conclusion only bulbs which are perfect square will be left ON at the last. (4, 9, 16, 25....) rest all bulbs will be OFF at the last.\\n\\nso we just need to fine how may perfact squares are present for any given N.\\nif N=20 -> 2, 4, 9, 16 (total 4)\\nif N=30 -> 2, 4, 9, 16, 25 (total 5)\\n\\nso we can convert calculating how many perfact sqs to -> simple solution\\n\\n# Ans: round(sqrt(N));\\n\\nBut this 1 line solution we can\\'t find until we know the whole logic that takes long time.\\n\\nHappy Learning !!\\n\\n"
                    }
                ]
            },
            {
                "id": 1566048,
                "content": [
                    {
                        "username": "rexthk",
                        "content": "Below are my step by step thought process. Hope it helps\\n\\nObservation #1:\\nA bulb is ON if it is toggled **odd** times: (ON), (ON -> OFF -> ON), (ON -> OFF -> ON -> OFF -> ON) ...\\nA bulb is OFF if it is toggled **even** times: (ON -> OFF), (ON -> OFF -> ON -> OFF ) ...\\n\\nObservation #2:\\nOnce we reach and toggle the ***i-th*** bulb, it will never be touched anymore.\\n\\nfor exmaple, let n = 5 ( changes in each round denoted as bold ), initial state is all OFF:\\n1-th round :   **ON,  ON,  ON,  ON, ON**\\n2-nd round:   ON, **OFF**,  ON, **OFF**, ON\\n3-rd round :   ON, OFF, **OFF**, OFF, ON\\n4-th round :   ON, OFF, OFF, **ON**, ON\\n5-th round :   ON, OFF, OFF, ON, **OFF**\\n\\nYou can see that, after each round, all bulbs before that round will not be touched anymore.\\n\\nSo, given a bulb at position X, how do I know it will be toggled EVEN/ODD times ?\\nAnswer: We can find the number of divisors of X. \\n\\nfor example, if the position of a bulb is 3, its divisor is [1,3], that mean we will toggle the 3-rd bulb at 1-st round and 3-rd round:\\nCombine the observation above, \\nat ***3-rd*** round, the third bulb will have been toggeld even times ( [1,3] ), so it is OFF. And it will not be changed later on round.\\nat ***5-th*** round, the fifth bulb will have been toggled even times ( [1,5] ), so it is OFF. And it will not be changed later on round.\\n\\nSuppose we have a func to get all divisors of i : **getDivisors(int)**, a simple algorithm can be deduced:\\n`for i = 1..n, if getDivisors(i) % 2 == 1, count++;`\\nWe loop through all positions, if it has odd number of divisors, it is ON and hence count + 1.\\n\\nUnfortunately, it will timeout. How to optimize ?\\n\\nObservation #3:\\nDivisors always come in pair. For example:\\n1: [1,1]  ---  2: [1,2] --- 3: [1,3] --- 4: [1,4] [2,2] --- 5:[1,5] --- 6:[1,6][2,3] --- 7:[1,7] \\n8: [1,8][2,4] --- 9:[1,9][3,3]\\n\\nIn above examples, we know that: \\nOnly when ***i*** has **perfect square root**, its number of divisors is ODD, because it contains duplicated divisor. In above example,\\n4: [1,2,4] --- 9: [1,3,9]\\nYou can pick any number to examine yourself.\\n\\nHere comes a better algorithm:\\n`for i = 1...n,  if i^2 <= n, count++ ; if i^2 > n, break;`\\nWe loop through all position, if **i^2** is <= n, that means there exists a valid bulb which has perfect square root ***i***, and we need to count that **i^2**, so count + 1. If the **i^2** exceed n, we can terminate it because we have found all ***i*** with perfect square root within n already.\\n\\nMany of you might have seen the answer, so why the answer can be simply written as Math.sqrt(n) ?\\nconsider n = 9, the process of aforementioned algorithm will be: \\ncheck (1 * 1 ) <= 9, count++\\ncheck (2 * 2 ) <= 9, count++;\\ncheck (3 * 3) <= 9, count++;\\ncheck (4 * 4) > 9, break;\\n\\nWe can say, if square root of 9 is 3, that mean **1^2** and **2^2** must exists for n = 9. Hence, the Math.sqrt(i) reflect this fact.\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "I got to observation 2 on my own. The condition for an odd number of divisors was eluding me, thanks for the help"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "mind glowing explanation\\n"
                    },
                    {
                        "username": "saidfgn",
                        "content": "Great explanation, thanks!"
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "**Its more like a puzzle rather than a coding problem**"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "[@yusufm09](/yusufm09) brain tester problem means does they ask this in interviews"
                    },
                    {
                        "username": "yusufm09",
                        "content": "[@jerryy147](/jerryy147) I never knew that there was a brainteaser problem list. Thanks."
                    },
                    {
                        "username": "jerryy147",
                        "content": "that\\'s why it\\'s in the \"brainteaser\" problem list"
                    },
                    {
                        "username": "strongwillow",
                        "content": "It only stated the first, second, third, and last round. Should be updated as follows:\\n\\nThere are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). **For the ith round, you toggle every i bulb.** For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds."
                    },
                    {
                        "username": "sx1w",
                        "content": "Like many of you are wondering why a simple sqaure root solution to the problem, I wanted to find out why that is correct. Here is my little research into it. \\n\\nThe light bulb at postion k must be toggled in odd number to stay on, e.g. \\'On, Off, On\\' including the initial toggle. What triggers k-th bulb be toggled? Number k must be an **exact** multiple of each toggling. For example, when k=4, the bulb will be triggered by the 1st (On), 2nd (Off) and 4th (On) operation. What is the exact number of multiple of a nature number k? **All of its factors** ! \\n\\nSo the k-th bulb \\'ON\\' is corresponding to the number of factors of k being odd. You can certainly develop a program to count. However, the [*number math*](http://mathcentral.uregina.ca/QQ/database/QQ.09.06/jacqueline1.html) tells us only perfect square numbers have odd number of factors, which is what needed for the bulb to stay on. \\n\\nGreat! Now to solve the problem is to find out how many perfect square number between 1 and n. The [*math*](https://www.quora.com/How-many-perfect-squares-are-there-between-1-to-1000) kicks in again, and that number is the square root of n (more preceisly the floor of sqaure root of n). \\n\\nWhat a great problem!"
                    },
                    {
                        "username": "bharathb",
                        "content": "A lot of other posts provide code / suggest a simulation to see the pattern. I will attempt to describe the intuition behind the solution. \\n\\n* First let s identify all the bulbs that can touch/affect/toggle bulb X. Bulb X can only be toggled by other bulbs which are less than or equal to X. For example, 26 will never toggle bulb 23.\\n* Secondly, for a bulb X what are the bulbs that can toggle X? 23 can never toggle 25. We notice that a bulb X can only be toggled by divisors of X - including 1 and X itself. \\n* Now let s consider prime numbers. Prime numbers by definition have exactly two divisors. Any number with 2 divisors will never be ON at the end - because 1 will set it to ON and the second divisor (the prime number itself) will toggle it off.\\n* With prime numbers gone, lets consider a composite number with an even number of divisors.  Say 24. The divisors of 24 are (1,2,3,4,6,8,12,24). Listing the divisors as pairs - (1, 24) (2,12), (3,8), (4,6) - pairs are crucial because one divisor will set 24 to ON and the other divisor will set it to OFF. So, the net result is that those bulbs will NOT be ON at the end of the simulation - because they are initially OFF. They are toggled an even number of times.\\n* Now, we need to find numbers <=N which have an odd number of divisors. This might not be intuitive immediately and this simulating the problem on paper helps. If we consider a perfect square like 36 and write the divisors in pairs - (1,36), (2,18), (3, 12), (4, 9), (6,6). Now, we can see that while all other divisors cancel each other out - (they toggle the bulb twice) - 6 has no counterpart to toggle the bulb off. So, when there are 36 bulbs, 6 will always be ON at the end. The same holds true for perfect squares less than N - which are 1,4,9,16,25.\\n* Based on the above inferences, we can see that we need to find the numbers less than N that are perfect squares.  We can calculate this (int) Math.sqrt(N) or have a simple for-loop to count (i*i) <=N \\n\\nHope this helps."
                    },
                    {
                        "username": "rajeshkumar1130",
                        "content": "I was asked this question in an interview with microsoft on 22-01-2021"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It just proves that an ordinary position at MS is a dead-end job."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@sandagolcea](/sandagolcea)  Nice solution bro! The code is also quite neat. Good job!"
                    },
                    {
                        "username": "algoacer",
                        "content": "[@code_coffeee](/code_coffeee) Acutally it is so true, some one gets to implement a plain algorithm and someone has to think out of the box in 40 minutes. Not fair. But we should keep applying at multiple companies."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@code_coffeee](/code_coffeee) do you mean a TLE? I've actually solved it differently, using rather simple mathematics, but not sqrt (which i know was quite obvs, but I thought of doing smth else :D ) here https://leetcode.com/problems/bulb-switcher/solutions/3461670/js-solutions-without-using-sqrt/ "
                    },
                    {
                        "username": "l3aonti",
                        "content": "[@dvijay96](/dvijay96) it throws memory limit exception "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@code_coffeee](/code_coffeee) Brute force n^2 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "they what happened bro how did you explain "
                    },
                    {
                        "username": "code_coffeee",
                        "content": "This makes me sad.\\n\\nI feel like if they ask anyone this, they must not want to hire this person. If anyone codes it in any way without using square root, it is  a rejection."
                    },
                    {
                        "username": "bingzhoudaren",
                        "content": "First, we need to figure out how do we know if the ith light is on or off at the end. \\nit dpends on how many numbers could output i after you get product of them.\\nfor example 6, \\nwe will toggle the 6th light in the first round becasue 1 times6=6\\nwe will toggle the 6th light in the second round because 2 times 3=6;\\nwe will toggle the 6th light in third round beacuse 3 times 2 =6;\\nand we will toggle the 6th light in 6th round beacuse 6 times 1=6;\\n\\nso since wil have 1,2,3,6,totally four numbers, we will toggle the 6th light 4 times.\\nand since 4 is even ,so the 6th light will be off at the end.\\n\\nand for example, 9 could have division 1,3,9,  there are three of them. which is odd, so the 9th light is on at the end.\\n\\n\\nthen the problem is to figure out which number have odd divisions, which have even.\\n\\nthen, we should realize that,  for no-square number, the divisions can be paired.\\n\\nfor example, for 6, 1,and 6 is a pair, 2 and 3 is a pair.\\nhowever, for square number, for example 9, 3 will pair by itself, or we could say, 3 does not have a partener to build a pair.\\n\\nso, only lights at square numbers position will be on at the end.\\n\\nso, if we have 10 lights, at the end, only 1,4,9 light will be on.\\n\\n\\nand how to count them? by sqrt(10), we could get 3, which is the number of square numbers smaller than 10\\n\\n\\n\\n"
                    },
                    {
                        "username": "warrenbrodsky",
                        "content": "To begin, let\\'s forget keeping track of *every*  bulb and only think about *one*. Clearly, this bulb can either be on or off.  While obvious, this is still significant. If we know how many times we toggled the bulb, we can figure out which state it is in: If we have a bulb that begins on and we toggle it once, it will be off. Twice, on again. Thrice, off, four times on, five off, six on, etc. OK, so the answer is parity -- even flips it\\'s on, odd it\\'s off. \\n\\nGreat, but we don\\'t flip every bulb on every iteration, so how do we know how many times we flipped it? Ok, well on the first pass, we flip every other bulb, that is, every bulb whose index is a multiple of 2 (assuming indexing starts from 1 ;) ). On the next, we toggle every multiple of 3. On the next, multiples of 4, etc. When we\\'re done, we\\'ll have flipped every bulb once for each number that it is a multiple of, which is to say, once for each *divisor*. (Importantly, we include itself, but not 1.) For example, bulb 6 is flipped off for 2, on for 3, and off one final time for 6. Another important fact is that divisors come in pairs -- it and the thing it has to be multiplied with to get the number. The ***only*** time this isn\\'t true is if the thing it is multiplied by is itself. In other words, it\\'s a perfect square. Therefore perfect squares will *always* have an *odd* number of divisors and all others have *even* numbers of divisors. Since we\\'re not including one as a divisor, the parity flips and therefore, when all is said and done, only bulbs with perfect square indices will remain on.\\n\\nBulk of the work done -- now we just need to know how many perfect squares there are from 1 to n (which I will call squaresLTE(n)) and that will be our answer. This is fairly simple: beginning with n=1 and squaresLTE(1) = 1, we can see squaresLTE(2) is still 1,  squaresLTE(3) is still 1, and we finally get another square when n=4 and squaresLTE(4)=2 -- 1, and 4. We don\\'t add another square to the list until n=the next square. This gives us the final answer:\\n\\n`bulbs(n) = squaresLTE(n) = floor(sqrt(n))`\\n\\nThis works because if we\\'re between two squares a=s^2 and b=(s+1)^2, sqrt(n) will be some number between s and s+1, so floor(sqrt(n)) will bring us down to the sqrt of the last square we added to the list"
                    },
                    {
                        "username": "dilipK",
                        "content": "* If a particular number n is divisible by k , it means it will also  be divisible by n/k. So it will bring it to original state i.e.off. So toggling at kth iteration will turn ON but toggling at (n/k)th iteration will bring it to OFF. So no change.\\n* But for a prefect square sqrt(n) will only toggle it once , so it will be overall ON."
                    },
                    {
                        "username": "suhane",
                        "content": "# Logic : 1st round Bulb is ON, then each switch will OFF then ON. so for any number ->\\n# 1st round : ON\\n# 2nd round : OFF\\n# 3rd round : ON \\n# 4th round : OFF  and so on ....\\n# \\n# **If we can calculate how many times each bulb is switched we can tell it was ON/OFF at the last.**\\n# \\n# from above we can see if we switch bulb EVEN times we get it OFF at last, if switch ODD times we get it ON at the last.**\\n\\n*Now take few examples to understand better-*\\nN=1 -> bulb switched 1 time (for N=1)  \\t\\t\\t-> OFF at last\\n\\nN=2 -> bulb switched 2 times (for N=1, 2) \\t\\t-> OFF at last\\n\\nN=3 -> bulb switched 2 times (for N=1, 3) \\t\\t-> OFF at last\\n\\nN=4 -> bulb switched 3 times (for N=1, 2, 4) \\t-> **ON** at last\\n\\nN=5 -> bulb switched 2 times (for N=1, 5) \\t\\t-> OFF at last\\n\\nN=6 -> bulb switched 4 times (for N=1, 2, 3, 6) -> OFF at last\\n\\nN=7 -> bulb switched 2 times (for N=1, 7)\\t\\t-> OFF at last\\t\\n\\nN=8 -> bulb switched 8* times (for N=1, 2, 4, 8)\\t-> OFF at last\\t\\n(how we got 8 switches -\\nadd all switches of\\nN=1 (1 times at N=1),\\nN=2 (2 times at N=1,2), \\nN=4 (3 times at N=1,2,4) ,\\nN=8 (2 time at N=1,8))\\n\\nN=9 -> bulb switched 3 times (for N=1, 3, 9)\\t-> **ON** at last\\t\\n\\nAs you can see from above we got a conclusion only bulbs which are perfect square will be left ON at the last. (4, 9, 16, 25....) rest all bulbs will be OFF at the last.\\n\\nso we just need to fine how may perfact squares are present for any given N.\\nif N=20 -> 2, 4, 9, 16 (total 4)\\nif N=30 -> 2, 4, 9, 16, 25 (total 5)\\n\\nso we can convert calculating how many perfact sqs to -> simple solution\\n\\n# Ans: round(sqrt(N));\\n\\nBut this 1 line solution we can\\'t find until we know the whole logic that takes long time.\\n\\nHappy Learning !!\\n\\n"
                    }
                ]
            },
            {
                "id": 1565021,
                "content": [
                    {
                        "username": "rexthk",
                        "content": "Below are my step by step thought process. Hope it helps\\n\\nObservation #1:\\nA bulb is ON if it is toggled **odd** times: (ON), (ON -> OFF -> ON), (ON -> OFF -> ON -> OFF -> ON) ...\\nA bulb is OFF if it is toggled **even** times: (ON -> OFF), (ON -> OFF -> ON -> OFF ) ...\\n\\nObservation #2:\\nOnce we reach and toggle the ***i-th*** bulb, it will never be touched anymore.\\n\\nfor exmaple, let n = 5 ( changes in each round denoted as bold ), initial state is all OFF:\\n1-th round :   **ON,  ON,  ON,  ON, ON**\\n2-nd round:   ON, **OFF**,  ON, **OFF**, ON\\n3-rd round :   ON, OFF, **OFF**, OFF, ON\\n4-th round :   ON, OFF, OFF, **ON**, ON\\n5-th round :   ON, OFF, OFF, ON, **OFF**\\n\\nYou can see that, after each round, all bulbs before that round will not be touched anymore.\\n\\nSo, given a bulb at position X, how do I know it will be toggled EVEN/ODD times ?\\nAnswer: We can find the number of divisors of X. \\n\\nfor example, if the position of a bulb is 3, its divisor is [1,3], that mean we will toggle the 3-rd bulb at 1-st round and 3-rd round:\\nCombine the observation above, \\nat ***3-rd*** round, the third bulb will have been toggeld even times ( [1,3] ), so it is OFF. And it will not be changed later on round.\\nat ***5-th*** round, the fifth bulb will have been toggled even times ( [1,5] ), so it is OFF. And it will not be changed later on round.\\n\\nSuppose we have a func to get all divisors of i : **getDivisors(int)**, a simple algorithm can be deduced:\\n`for i = 1..n, if getDivisors(i) % 2 == 1, count++;`\\nWe loop through all positions, if it has odd number of divisors, it is ON and hence count + 1.\\n\\nUnfortunately, it will timeout. How to optimize ?\\n\\nObservation #3:\\nDivisors always come in pair. For example:\\n1: [1,1]  ---  2: [1,2] --- 3: [1,3] --- 4: [1,4] [2,2] --- 5:[1,5] --- 6:[1,6][2,3] --- 7:[1,7] \\n8: [1,8][2,4] --- 9:[1,9][3,3]\\n\\nIn above examples, we know that: \\nOnly when ***i*** has **perfect square root**, its number of divisors is ODD, because it contains duplicated divisor. In above example,\\n4: [1,2,4] --- 9: [1,3,9]\\nYou can pick any number to examine yourself.\\n\\nHere comes a better algorithm:\\n`for i = 1...n,  if i^2 <= n, count++ ; if i^2 > n, break;`\\nWe loop through all position, if **i^2** is <= n, that means there exists a valid bulb which has perfect square root ***i***, and we need to count that **i^2**, so count + 1. If the **i^2** exceed n, we can terminate it because we have found all ***i*** with perfect square root within n already.\\n\\nMany of you might have seen the answer, so why the answer can be simply written as Math.sqrt(n) ?\\nconsider n = 9, the process of aforementioned algorithm will be: \\ncheck (1 * 1 ) <= 9, count++\\ncheck (2 * 2 ) <= 9, count++;\\ncheck (3 * 3) <= 9, count++;\\ncheck (4 * 4) > 9, break;\\n\\nWe can say, if square root of 9 is 3, that mean **1^2** and **2^2** must exists for n = 9. Hence, the Math.sqrt(i) reflect this fact.\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "I got to observation 2 on my own. The condition for an odd number of divisors was eluding me, thanks for the help"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "mind glowing explanation\\n"
                    },
                    {
                        "username": "saidfgn",
                        "content": "Great explanation, thanks!"
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "**Its more like a puzzle rather than a coding problem**"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "[@yusufm09](/yusufm09) brain tester problem means does they ask this in interviews"
                    },
                    {
                        "username": "yusufm09",
                        "content": "[@jerryy147](/jerryy147) I never knew that there was a brainteaser problem list. Thanks."
                    },
                    {
                        "username": "jerryy147",
                        "content": "that\\'s why it\\'s in the \"brainteaser\" problem list"
                    },
                    {
                        "username": "strongwillow",
                        "content": "It only stated the first, second, third, and last round. Should be updated as follows:\\n\\nThere are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). **For the ith round, you toggle every i bulb.** For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds."
                    },
                    {
                        "username": "sx1w",
                        "content": "Like many of you are wondering why a simple sqaure root solution to the problem, I wanted to find out why that is correct. Here is my little research into it. \\n\\nThe light bulb at postion k must be toggled in odd number to stay on, e.g. \\'On, Off, On\\' including the initial toggle. What triggers k-th bulb be toggled? Number k must be an **exact** multiple of each toggling. For example, when k=4, the bulb will be triggered by the 1st (On), 2nd (Off) and 4th (On) operation. What is the exact number of multiple of a nature number k? **All of its factors** ! \\n\\nSo the k-th bulb \\'ON\\' is corresponding to the number of factors of k being odd. You can certainly develop a program to count. However, the [*number math*](http://mathcentral.uregina.ca/QQ/database/QQ.09.06/jacqueline1.html) tells us only perfect square numbers have odd number of factors, which is what needed for the bulb to stay on. \\n\\nGreat! Now to solve the problem is to find out how many perfect square number between 1 and n. The [*math*](https://www.quora.com/How-many-perfect-squares-are-there-between-1-to-1000) kicks in again, and that number is the square root of n (more preceisly the floor of sqaure root of n). \\n\\nWhat a great problem!"
                    },
                    {
                        "username": "bharathb",
                        "content": "A lot of other posts provide code / suggest a simulation to see the pattern. I will attempt to describe the intuition behind the solution. \\n\\n* First let s identify all the bulbs that can touch/affect/toggle bulb X. Bulb X can only be toggled by other bulbs which are less than or equal to X. For example, 26 will never toggle bulb 23.\\n* Secondly, for a bulb X what are the bulbs that can toggle X? 23 can never toggle 25. We notice that a bulb X can only be toggled by divisors of X - including 1 and X itself. \\n* Now let s consider prime numbers. Prime numbers by definition have exactly two divisors. Any number with 2 divisors will never be ON at the end - because 1 will set it to ON and the second divisor (the prime number itself) will toggle it off.\\n* With prime numbers gone, lets consider a composite number with an even number of divisors.  Say 24. The divisors of 24 are (1,2,3,4,6,8,12,24). Listing the divisors as pairs - (1, 24) (2,12), (3,8), (4,6) - pairs are crucial because one divisor will set 24 to ON and the other divisor will set it to OFF. So, the net result is that those bulbs will NOT be ON at the end of the simulation - because they are initially OFF. They are toggled an even number of times.\\n* Now, we need to find numbers <=N which have an odd number of divisors. This might not be intuitive immediately and this simulating the problem on paper helps. If we consider a perfect square like 36 and write the divisors in pairs - (1,36), (2,18), (3, 12), (4, 9), (6,6). Now, we can see that while all other divisors cancel each other out - (they toggle the bulb twice) - 6 has no counterpart to toggle the bulb off. So, when there are 36 bulbs, 6 will always be ON at the end. The same holds true for perfect squares less than N - which are 1,4,9,16,25.\\n* Based on the above inferences, we can see that we need to find the numbers less than N that are perfect squares.  We can calculate this (int) Math.sqrt(N) or have a simple for-loop to count (i*i) <=N \\n\\nHope this helps."
                    },
                    {
                        "username": "rajeshkumar1130",
                        "content": "I was asked this question in an interview with microsoft on 22-01-2021"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It just proves that an ordinary position at MS is a dead-end job."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@sandagolcea](/sandagolcea)  Nice solution bro! The code is also quite neat. Good job!"
                    },
                    {
                        "username": "algoacer",
                        "content": "[@code_coffeee](/code_coffeee) Acutally it is so true, some one gets to implement a plain algorithm and someone has to think out of the box in 40 minutes. Not fair. But we should keep applying at multiple companies."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@code_coffeee](/code_coffeee) do you mean a TLE? I've actually solved it differently, using rather simple mathematics, but not sqrt (which i know was quite obvs, but I thought of doing smth else :D ) here https://leetcode.com/problems/bulb-switcher/solutions/3461670/js-solutions-without-using-sqrt/ "
                    },
                    {
                        "username": "l3aonti",
                        "content": "[@dvijay96](/dvijay96) it throws memory limit exception "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@code_coffeee](/code_coffeee) Brute force n^2 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "they what happened bro how did you explain "
                    },
                    {
                        "username": "code_coffeee",
                        "content": "This makes me sad.\\n\\nI feel like if they ask anyone this, they must not want to hire this person. If anyone codes it in any way without using square root, it is  a rejection."
                    },
                    {
                        "username": "bingzhoudaren",
                        "content": "First, we need to figure out how do we know if the ith light is on or off at the end. \\nit dpends on how many numbers could output i after you get product of them.\\nfor example 6, \\nwe will toggle the 6th light in the first round becasue 1 times6=6\\nwe will toggle the 6th light in the second round because 2 times 3=6;\\nwe will toggle the 6th light in third round beacuse 3 times 2 =6;\\nand we will toggle the 6th light in 6th round beacuse 6 times 1=6;\\n\\nso since wil have 1,2,3,6,totally four numbers, we will toggle the 6th light 4 times.\\nand since 4 is even ,so the 6th light will be off at the end.\\n\\nand for example, 9 could have division 1,3,9,  there are three of them. which is odd, so the 9th light is on at the end.\\n\\n\\nthen the problem is to figure out which number have odd divisions, which have even.\\n\\nthen, we should realize that,  for no-square number, the divisions can be paired.\\n\\nfor example, for 6, 1,and 6 is a pair, 2 and 3 is a pair.\\nhowever, for square number, for example 9, 3 will pair by itself, or we could say, 3 does not have a partener to build a pair.\\n\\nso, only lights at square numbers position will be on at the end.\\n\\nso, if we have 10 lights, at the end, only 1,4,9 light will be on.\\n\\n\\nand how to count them? by sqrt(10), we could get 3, which is the number of square numbers smaller than 10\\n\\n\\n\\n"
                    },
                    {
                        "username": "warrenbrodsky",
                        "content": "To begin, let\\'s forget keeping track of *every*  bulb and only think about *one*. Clearly, this bulb can either be on or off.  While obvious, this is still significant. If we know how many times we toggled the bulb, we can figure out which state it is in: If we have a bulb that begins on and we toggle it once, it will be off. Twice, on again. Thrice, off, four times on, five off, six on, etc. OK, so the answer is parity -- even flips it\\'s on, odd it\\'s off. \\n\\nGreat, but we don\\'t flip every bulb on every iteration, so how do we know how many times we flipped it? Ok, well on the first pass, we flip every other bulb, that is, every bulb whose index is a multiple of 2 (assuming indexing starts from 1 ;) ). On the next, we toggle every multiple of 3. On the next, multiples of 4, etc. When we\\'re done, we\\'ll have flipped every bulb once for each number that it is a multiple of, which is to say, once for each *divisor*. (Importantly, we include itself, but not 1.) For example, bulb 6 is flipped off for 2, on for 3, and off one final time for 6. Another important fact is that divisors come in pairs -- it and the thing it has to be multiplied with to get the number. The ***only*** time this isn\\'t true is if the thing it is multiplied by is itself. In other words, it\\'s a perfect square. Therefore perfect squares will *always* have an *odd* number of divisors and all others have *even* numbers of divisors. Since we\\'re not including one as a divisor, the parity flips and therefore, when all is said and done, only bulbs with perfect square indices will remain on.\\n\\nBulk of the work done -- now we just need to know how many perfect squares there are from 1 to n (which I will call squaresLTE(n)) and that will be our answer. This is fairly simple: beginning with n=1 and squaresLTE(1) = 1, we can see squaresLTE(2) is still 1,  squaresLTE(3) is still 1, and we finally get another square when n=4 and squaresLTE(4)=2 -- 1, and 4. We don\\'t add another square to the list until n=the next square. This gives us the final answer:\\n\\n`bulbs(n) = squaresLTE(n) = floor(sqrt(n))`\\n\\nThis works because if we\\'re between two squares a=s^2 and b=(s+1)^2, sqrt(n) will be some number between s and s+1, so floor(sqrt(n)) will bring us down to the sqrt of the last square we added to the list"
                    },
                    {
                        "username": "dilipK",
                        "content": "* If a particular number n is divisible by k , it means it will also  be divisible by n/k. So it will bring it to original state i.e.off. So toggling at kth iteration will turn ON but toggling at (n/k)th iteration will bring it to OFF. So no change.\\n* But for a prefect square sqrt(n) will only toggle it once , so it will be overall ON."
                    },
                    {
                        "username": "suhane",
                        "content": "# Logic : 1st round Bulb is ON, then each switch will OFF then ON. so for any number ->\\n# 1st round : ON\\n# 2nd round : OFF\\n# 3rd round : ON \\n# 4th round : OFF  and so on ....\\n# \\n# **If we can calculate how many times each bulb is switched we can tell it was ON/OFF at the last.**\\n# \\n# from above we can see if we switch bulb EVEN times we get it OFF at last, if switch ODD times we get it ON at the last.**\\n\\n*Now take few examples to understand better-*\\nN=1 -> bulb switched 1 time (for N=1)  \\t\\t\\t-> OFF at last\\n\\nN=2 -> bulb switched 2 times (for N=1, 2) \\t\\t-> OFF at last\\n\\nN=3 -> bulb switched 2 times (for N=1, 3) \\t\\t-> OFF at last\\n\\nN=4 -> bulb switched 3 times (for N=1, 2, 4) \\t-> **ON** at last\\n\\nN=5 -> bulb switched 2 times (for N=1, 5) \\t\\t-> OFF at last\\n\\nN=6 -> bulb switched 4 times (for N=1, 2, 3, 6) -> OFF at last\\n\\nN=7 -> bulb switched 2 times (for N=1, 7)\\t\\t-> OFF at last\\t\\n\\nN=8 -> bulb switched 8* times (for N=1, 2, 4, 8)\\t-> OFF at last\\t\\n(how we got 8 switches -\\nadd all switches of\\nN=1 (1 times at N=1),\\nN=2 (2 times at N=1,2), \\nN=4 (3 times at N=1,2,4) ,\\nN=8 (2 time at N=1,8))\\n\\nN=9 -> bulb switched 3 times (for N=1, 3, 9)\\t-> **ON** at last\\t\\n\\nAs you can see from above we got a conclusion only bulbs which are perfect square will be left ON at the last. (4, 9, 16, 25....) rest all bulbs will be OFF at the last.\\n\\nso we just need to fine how may perfact squares are present for any given N.\\nif N=20 -> 2, 4, 9, 16 (total 4)\\nif N=30 -> 2, 4, 9, 16, 25 (total 5)\\n\\nso we can convert calculating how many perfact sqs to -> simple solution\\n\\n# Ans: round(sqrt(N));\\n\\nBut this 1 line solution we can\\'t find until we know the whole logic that takes long time.\\n\\nHappy Learning !!\\n\\n"
                    }
                ]
            },
            {
                "id": 1565556,
                "content": [
                    {
                        "username": "rexthk",
                        "content": "Below are my step by step thought process. Hope it helps\\n\\nObservation #1:\\nA bulb is ON if it is toggled **odd** times: (ON), (ON -> OFF -> ON), (ON -> OFF -> ON -> OFF -> ON) ...\\nA bulb is OFF if it is toggled **even** times: (ON -> OFF), (ON -> OFF -> ON -> OFF ) ...\\n\\nObservation #2:\\nOnce we reach and toggle the ***i-th*** bulb, it will never be touched anymore.\\n\\nfor exmaple, let n = 5 ( changes in each round denoted as bold ), initial state is all OFF:\\n1-th round :   **ON,  ON,  ON,  ON, ON**\\n2-nd round:   ON, **OFF**,  ON, **OFF**, ON\\n3-rd round :   ON, OFF, **OFF**, OFF, ON\\n4-th round :   ON, OFF, OFF, **ON**, ON\\n5-th round :   ON, OFF, OFF, ON, **OFF**\\n\\nYou can see that, after each round, all bulbs before that round will not be touched anymore.\\n\\nSo, given a bulb at position X, how do I know it will be toggled EVEN/ODD times ?\\nAnswer: We can find the number of divisors of X. \\n\\nfor example, if the position of a bulb is 3, its divisor is [1,3], that mean we will toggle the 3-rd bulb at 1-st round and 3-rd round:\\nCombine the observation above, \\nat ***3-rd*** round, the third bulb will have been toggeld even times ( [1,3] ), so it is OFF. And it will not be changed later on round.\\nat ***5-th*** round, the fifth bulb will have been toggled even times ( [1,5] ), so it is OFF. And it will not be changed later on round.\\n\\nSuppose we have a func to get all divisors of i : **getDivisors(int)**, a simple algorithm can be deduced:\\n`for i = 1..n, if getDivisors(i) % 2 == 1, count++;`\\nWe loop through all positions, if it has odd number of divisors, it is ON and hence count + 1.\\n\\nUnfortunately, it will timeout. How to optimize ?\\n\\nObservation #3:\\nDivisors always come in pair. For example:\\n1: [1,1]  ---  2: [1,2] --- 3: [1,3] --- 4: [1,4] [2,2] --- 5:[1,5] --- 6:[1,6][2,3] --- 7:[1,7] \\n8: [1,8][2,4] --- 9:[1,9][3,3]\\n\\nIn above examples, we know that: \\nOnly when ***i*** has **perfect square root**, its number of divisors is ODD, because it contains duplicated divisor. In above example,\\n4: [1,2,4] --- 9: [1,3,9]\\nYou can pick any number to examine yourself.\\n\\nHere comes a better algorithm:\\n`for i = 1...n,  if i^2 <= n, count++ ; if i^2 > n, break;`\\nWe loop through all position, if **i^2** is <= n, that means there exists a valid bulb which has perfect square root ***i***, and we need to count that **i^2**, so count + 1. If the **i^2** exceed n, we can terminate it because we have found all ***i*** with perfect square root within n already.\\n\\nMany of you might have seen the answer, so why the answer can be simply written as Math.sqrt(n) ?\\nconsider n = 9, the process of aforementioned algorithm will be: \\ncheck (1 * 1 ) <= 9, count++\\ncheck (2 * 2 ) <= 9, count++;\\ncheck (3 * 3) <= 9, count++;\\ncheck (4 * 4) > 9, break;\\n\\nWe can say, if square root of 9 is 3, that mean **1^2** and **2^2** must exists for n = 9. Hence, the Math.sqrt(i) reflect this fact.\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "I got to observation 2 on my own. The condition for an odd number of divisors was eluding me, thanks for the help"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "mind glowing explanation\\n"
                    },
                    {
                        "username": "saidfgn",
                        "content": "Great explanation, thanks!"
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "**Its more like a puzzle rather than a coding problem**"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "[@yusufm09](/yusufm09) brain tester problem means does they ask this in interviews"
                    },
                    {
                        "username": "yusufm09",
                        "content": "[@jerryy147](/jerryy147) I never knew that there was a brainteaser problem list. Thanks."
                    },
                    {
                        "username": "jerryy147",
                        "content": "that\\'s why it\\'s in the \"brainteaser\" problem list"
                    },
                    {
                        "username": "strongwillow",
                        "content": "It only stated the first, second, third, and last round. Should be updated as follows:\\n\\nThere are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). **For the ith round, you toggle every i bulb.** For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds."
                    },
                    {
                        "username": "sx1w",
                        "content": "Like many of you are wondering why a simple sqaure root solution to the problem, I wanted to find out why that is correct. Here is my little research into it. \\n\\nThe light bulb at postion k must be toggled in odd number to stay on, e.g. \\'On, Off, On\\' including the initial toggle. What triggers k-th bulb be toggled? Number k must be an **exact** multiple of each toggling. For example, when k=4, the bulb will be triggered by the 1st (On), 2nd (Off) and 4th (On) operation. What is the exact number of multiple of a nature number k? **All of its factors** ! \\n\\nSo the k-th bulb \\'ON\\' is corresponding to the number of factors of k being odd. You can certainly develop a program to count. However, the [*number math*](http://mathcentral.uregina.ca/QQ/database/QQ.09.06/jacqueline1.html) tells us only perfect square numbers have odd number of factors, which is what needed for the bulb to stay on. \\n\\nGreat! Now to solve the problem is to find out how many perfect square number between 1 and n. The [*math*](https://www.quora.com/How-many-perfect-squares-are-there-between-1-to-1000) kicks in again, and that number is the square root of n (more preceisly the floor of sqaure root of n). \\n\\nWhat a great problem!"
                    },
                    {
                        "username": "bharathb",
                        "content": "A lot of other posts provide code / suggest a simulation to see the pattern. I will attempt to describe the intuition behind the solution. \\n\\n* First let s identify all the bulbs that can touch/affect/toggle bulb X. Bulb X can only be toggled by other bulbs which are less than or equal to X. For example, 26 will never toggle bulb 23.\\n* Secondly, for a bulb X what are the bulbs that can toggle X? 23 can never toggle 25. We notice that a bulb X can only be toggled by divisors of X - including 1 and X itself. \\n* Now let s consider prime numbers. Prime numbers by definition have exactly two divisors. Any number with 2 divisors will never be ON at the end - because 1 will set it to ON and the second divisor (the prime number itself) will toggle it off.\\n* With prime numbers gone, lets consider a composite number with an even number of divisors.  Say 24. The divisors of 24 are (1,2,3,4,6,8,12,24). Listing the divisors as pairs - (1, 24) (2,12), (3,8), (4,6) - pairs are crucial because one divisor will set 24 to ON and the other divisor will set it to OFF. So, the net result is that those bulbs will NOT be ON at the end of the simulation - because they are initially OFF. They are toggled an even number of times.\\n* Now, we need to find numbers <=N which have an odd number of divisors. This might not be intuitive immediately and this simulating the problem on paper helps. If we consider a perfect square like 36 and write the divisors in pairs - (1,36), (2,18), (3, 12), (4, 9), (6,6). Now, we can see that while all other divisors cancel each other out - (they toggle the bulb twice) - 6 has no counterpart to toggle the bulb off. So, when there are 36 bulbs, 6 will always be ON at the end. The same holds true for perfect squares less than N - which are 1,4,9,16,25.\\n* Based on the above inferences, we can see that we need to find the numbers less than N that are perfect squares.  We can calculate this (int) Math.sqrt(N) or have a simple for-loop to count (i*i) <=N \\n\\nHope this helps."
                    },
                    {
                        "username": "rajeshkumar1130",
                        "content": "I was asked this question in an interview with microsoft on 22-01-2021"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It just proves that an ordinary position at MS is a dead-end job."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@sandagolcea](/sandagolcea)  Nice solution bro! The code is also quite neat. Good job!"
                    },
                    {
                        "username": "algoacer",
                        "content": "[@code_coffeee](/code_coffeee) Acutally it is so true, some one gets to implement a plain algorithm and someone has to think out of the box in 40 minutes. Not fair. But we should keep applying at multiple companies."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@code_coffeee](/code_coffeee) do you mean a TLE? I've actually solved it differently, using rather simple mathematics, but not sqrt (which i know was quite obvs, but I thought of doing smth else :D ) here https://leetcode.com/problems/bulb-switcher/solutions/3461670/js-solutions-without-using-sqrt/ "
                    },
                    {
                        "username": "l3aonti",
                        "content": "[@dvijay96](/dvijay96) it throws memory limit exception "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@code_coffeee](/code_coffeee) Brute force n^2 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "they what happened bro how did you explain "
                    },
                    {
                        "username": "code_coffeee",
                        "content": "This makes me sad.\\n\\nI feel like if they ask anyone this, they must not want to hire this person. If anyone codes it in any way without using square root, it is  a rejection."
                    },
                    {
                        "username": "bingzhoudaren",
                        "content": "First, we need to figure out how do we know if the ith light is on or off at the end. \\nit dpends on how many numbers could output i after you get product of them.\\nfor example 6, \\nwe will toggle the 6th light in the first round becasue 1 times6=6\\nwe will toggle the 6th light in the second round because 2 times 3=6;\\nwe will toggle the 6th light in third round beacuse 3 times 2 =6;\\nand we will toggle the 6th light in 6th round beacuse 6 times 1=6;\\n\\nso since wil have 1,2,3,6,totally four numbers, we will toggle the 6th light 4 times.\\nand since 4 is even ,so the 6th light will be off at the end.\\n\\nand for example, 9 could have division 1,3,9,  there are three of them. which is odd, so the 9th light is on at the end.\\n\\n\\nthen the problem is to figure out which number have odd divisions, which have even.\\n\\nthen, we should realize that,  for no-square number, the divisions can be paired.\\n\\nfor example, for 6, 1,and 6 is a pair, 2 and 3 is a pair.\\nhowever, for square number, for example 9, 3 will pair by itself, or we could say, 3 does not have a partener to build a pair.\\n\\nso, only lights at square numbers position will be on at the end.\\n\\nso, if we have 10 lights, at the end, only 1,4,9 light will be on.\\n\\n\\nand how to count them? by sqrt(10), we could get 3, which is the number of square numbers smaller than 10\\n\\n\\n\\n"
                    },
                    {
                        "username": "warrenbrodsky",
                        "content": "To begin, let\\'s forget keeping track of *every*  bulb and only think about *one*. Clearly, this bulb can either be on or off.  While obvious, this is still significant. If we know how many times we toggled the bulb, we can figure out which state it is in: If we have a bulb that begins on and we toggle it once, it will be off. Twice, on again. Thrice, off, four times on, five off, six on, etc. OK, so the answer is parity -- even flips it\\'s on, odd it\\'s off. \\n\\nGreat, but we don\\'t flip every bulb on every iteration, so how do we know how many times we flipped it? Ok, well on the first pass, we flip every other bulb, that is, every bulb whose index is a multiple of 2 (assuming indexing starts from 1 ;) ). On the next, we toggle every multiple of 3. On the next, multiples of 4, etc. When we\\'re done, we\\'ll have flipped every bulb once for each number that it is a multiple of, which is to say, once for each *divisor*. (Importantly, we include itself, but not 1.) For example, bulb 6 is flipped off for 2, on for 3, and off one final time for 6. Another important fact is that divisors come in pairs -- it and the thing it has to be multiplied with to get the number. The ***only*** time this isn\\'t true is if the thing it is multiplied by is itself. In other words, it\\'s a perfect square. Therefore perfect squares will *always* have an *odd* number of divisors and all others have *even* numbers of divisors. Since we\\'re not including one as a divisor, the parity flips and therefore, when all is said and done, only bulbs with perfect square indices will remain on.\\n\\nBulk of the work done -- now we just need to know how many perfect squares there are from 1 to n (which I will call squaresLTE(n)) and that will be our answer. This is fairly simple: beginning with n=1 and squaresLTE(1) = 1, we can see squaresLTE(2) is still 1,  squaresLTE(3) is still 1, and we finally get another square when n=4 and squaresLTE(4)=2 -- 1, and 4. We don\\'t add another square to the list until n=the next square. This gives us the final answer:\\n\\n`bulbs(n) = squaresLTE(n) = floor(sqrt(n))`\\n\\nThis works because if we\\'re between two squares a=s^2 and b=(s+1)^2, sqrt(n) will be some number between s and s+1, so floor(sqrt(n)) will bring us down to the sqrt of the last square we added to the list"
                    },
                    {
                        "username": "dilipK",
                        "content": "* If a particular number n is divisible by k , it means it will also  be divisible by n/k. So it will bring it to original state i.e.off. So toggling at kth iteration will turn ON but toggling at (n/k)th iteration will bring it to OFF. So no change.\\n* But for a prefect square sqrt(n) will only toggle it once , so it will be overall ON."
                    },
                    {
                        "username": "suhane",
                        "content": "# Logic : 1st round Bulb is ON, then each switch will OFF then ON. so for any number ->\\n# 1st round : ON\\n# 2nd round : OFF\\n# 3rd round : ON \\n# 4th round : OFF  and so on ....\\n# \\n# **If we can calculate how many times each bulb is switched we can tell it was ON/OFF at the last.**\\n# \\n# from above we can see if we switch bulb EVEN times we get it OFF at last, if switch ODD times we get it ON at the last.**\\n\\n*Now take few examples to understand better-*\\nN=1 -> bulb switched 1 time (for N=1)  \\t\\t\\t-> OFF at last\\n\\nN=2 -> bulb switched 2 times (for N=1, 2) \\t\\t-> OFF at last\\n\\nN=3 -> bulb switched 2 times (for N=1, 3) \\t\\t-> OFF at last\\n\\nN=4 -> bulb switched 3 times (for N=1, 2, 4) \\t-> **ON** at last\\n\\nN=5 -> bulb switched 2 times (for N=1, 5) \\t\\t-> OFF at last\\n\\nN=6 -> bulb switched 4 times (for N=1, 2, 3, 6) -> OFF at last\\n\\nN=7 -> bulb switched 2 times (for N=1, 7)\\t\\t-> OFF at last\\t\\n\\nN=8 -> bulb switched 8* times (for N=1, 2, 4, 8)\\t-> OFF at last\\t\\n(how we got 8 switches -\\nadd all switches of\\nN=1 (1 times at N=1),\\nN=2 (2 times at N=1,2), \\nN=4 (3 times at N=1,2,4) ,\\nN=8 (2 time at N=1,8))\\n\\nN=9 -> bulb switched 3 times (for N=1, 3, 9)\\t-> **ON** at last\\t\\n\\nAs you can see from above we got a conclusion only bulbs which are perfect square will be left ON at the last. (4, 9, 16, 25....) rest all bulbs will be OFF at the last.\\n\\nso we just need to fine how may perfact squares are present for any given N.\\nif N=20 -> 2, 4, 9, 16 (total 4)\\nif N=30 -> 2, 4, 9, 16, 25 (total 5)\\n\\nso we can convert calculating how many perfact sqs to -> simple solution\\n\\n# Ans: round(sqrt(N));\\n\\nBut this 1 line solution we can\\'t find until we know the whole logic that takes long time.\\n\\nHappy Learning !!\\n\\n"
                    }
                ]
            },
            {
                "id": 1565569,
                "content": [
                    {
                        "username": "rexthk",
                        "content": "Below are my step by step thought process. Hope it helps\\n\\nObservation #1:\\nA bulb is ON if it is toggled **odd** times: (ON), (ON -> OFF -> ON), (ON -> OFF -> ON -> OFF -> ON) ...\\nA bulb is OFF if it is toggled **even** times: (ON -> OFF), (ON -> OFF -> ON -> OFF ) ...\\n\\nObservation #2:\\nOnce we reach and toggle the ***i-th*** bulb, it will never be touched anymore.\\n\\nfor exmaple, let n = 5 ( changes in each round denoted as bold ), initial state is all OFF:\\n1-th round :   **ON,  ON,  ON,  ON, ON**\\n2-nd round:   ON, **OFF**,  ON, **OFF**, ON\\n3-rd round :   ON, OFF, **OFF**, OFF, ON\\n4-th round :   ON, OFF, OFF, **ON**, ON\\n5-th round :   ON, OFF, OFF, ON, **OFF**\\n\\nYou can see that, after each round, all bulbs before that round will not be touched anymore.\\n\\nSo, given a bulb at position X, how do I know it will be toggled EVEN/ODD times ?\\nAnswer: We can find the number of divisors of X. \\n\\nfor example, if the position of a bulb is 3, its divisor is [1,3], that mean we will toggle the 3-rd bulb at 1-st round and 3-rd round:\\nCombine the observation above, \\nat ***3-rd*** round, the third bulb will have been toggeld even times ( [1,3] ), so it is OFF. And it will not be changed later on round.\\nat ***5-th*** round, the fifth bulb will have been toggled even times ( [1,5] ), so it is OFF. And it will not be changed later on round.\\n\\nSuppose we have a func to get all divisors of i : **getDivisors(int)**, a simple algorithm can be deduced:\\n`for i = 1..n, if getDivisors(i) % 2 == 1, count++;`\\nWe loop through all positions, if it has odd number of divisors, it is ON and hence count + 1.\\n\\nUnfortunately, it will timeout. How to optimize ?\\n\\nObservation #3:\\nDivisors always come in pair. For example:\\n1: [1,1]  ---  2: [1,2] --- 3: [1,3] --- 4: [1,4] [2,2] --- 5:[1,5] --- 6:[1,6][2,3] --- 7:[1,7] \\n8: [1,8][2,4] --- 9:[1,9][3,3]\\n\\nIn above examples, we know that: \\nOnly when ***i*** has **perfect square root**, its number of divisors is ODD, because it contains duplicated divisor. In above example,\\n4: [1,2,4] --- 9: [1,3,9]\\nYou can pick any number to examine yourself.\\n\\nHere comes a better algorithm:\\n`for i = 1...n,  if i^2 <= n, count++ ; if i^2 > n, break;`\\nWe loop through all position, if **i^2** is <= n, that means there exists a valid bulb which has perfect square root ***i***, and we need to count that **i^2**, so count + 1. If the **i^2** exceed n, we can terminate it because we have found all ***i*** with perfect square root within n already.\\n\\nMany of you might have seen the answer, so why the answer can be simply written as Math.sqrt(n) ?\\nconsider n = 9, the process of aforementioned algorithm will be: \\ncheck (1 * 1 ) <= 9, count++\\ncheck (2 * 2 ) <= 9, count++;\\ncheck (3 * 3) <= 9, count++;\\ncheck (4 * 4) > 9, break;\\n\\nWe can say, if square root of 9 is 3, that mean **1^2** and **2^2** must exists for n = 9. Hence, the Math.sqrt(i) reflect this fact.\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "I got to observation 2 on my own. The condition for an odd number of divisors was eluding me, thanks for the help"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "mind glowing explanation\\n"
                    },
                    {
                        "username": "saidfgn",
                        "content": "Great explanation, thanks!"
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "**Its more like a puzzle rather than a coding problem**"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "[@yusufm09](/yusufm09) brain tester problem means does they ask this in interviews"
                    },
                    {
                        "username": "yusufm09",
                        "content": "[@jerryy147](/jerryy147) I never knew that there was a brainteaser problem list. Thanks."
                    },
                    {
                        "username": "jerryy147",
                        "content": "that\\'s why it\\'s in the \"brainteaser\" problem list"
                    },
                    {
                        "username": "strongwillow",
                        "content": "It only stated the first, second, third, and last round. Should be updated as follows:\\n\\nThere are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). **For the ith round, you toggle every i bulb.** For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds."
                    },
                    {
                        "username": "sx1w",
                        "content": "Like many of you are wondering why a simple sqaure root solution to the problem, I wanted to find out why that is correct. Here is my little research into it. \\n\\nThe light bulb at postion k must be toggled in odd number to stay on, e.g. \\'On, Off, On\\' including the initial toggle. What triggers k-th bulb be toggled? Number k must be an **exact** multiple of each toggling. For example, when k=4, the bulb will be triggered by the 1st (On), 2nd (Off) and 4th (On) operation. What is the exact number of multiple of a nature number k? **All of its factors** ! \\n\\nSo the k-th bulb \\'ON\\' is corresponding to the number of factors of k being odd. You can certainly develop a program to count. However, the [*number math*](http://mathcentral.uregina.ca/QQ/database/QQ.09.06/jacqueline1.html) tells us only perfect square numbers have odd number of factors, which is what needed for the bulb to stay on. \\n\\nGreat! Now to solve the problem is to find out how many perfect square number between 1 and n. The [*math*](https://www.quora.com/How-many-perfect-squares-are-there-between-1-to-1000) kicks in again, and that number is the square root of n (more preceisly the floor of sqaure root of n). \\n\\nWhat a great problem!"
                    },
                    {
                        "username": "bharathb",
                        "content": "A lot of other posts provide code / suggest a simulation to see the pattern. I will attempt to describe the intuition behind the solution. \\n\\n* First let s identify all the bulbs that can touch/affect/toggle bulb X. Bulb X can only be toggled by other bulbs which are less than or equal to X. For example, 26 will never toggle bulb 23.\\n* Secondly, for a bulb X what are the bulbs that can toggle X? 23 can never toggle 25. We notice that a bulb X can only be toggled by divisors of X - including 1 and X itself. \\n* Now let s consider prime numbers. Prime numbers by definition have exactly two divisors. Any number with 2 divisors will never be ON at the end - because 1 will set it to ON and the second divisor (the prime number itself) will toggle it off.\\n* With prime numbers gone, lets consider a composite number with an even number of divisors.  Say 24. The divisors of 24 are (1,2,3,4,6,8,12,24). Listing the divisors as pairs - (1, 24) (2,12), (3,8), (4,6) - pairs are crucial because one divisor will set 24 to ON and the other divisor will set it to OFF. So, the net result is that those bulbs will NOT be ON at the end of the simulation - because they are initially OFF. They are toggled an even number of times.\\n* Now, we need to find numbers <=N which have an odd number of divisors. This might not be intuitive immediately and this simulating the problem on paper helps. If we consider a perfect square like 36 and write the divisors in pairs - (1,36), (2,18), (3, 12), (4, 9), (6,6). Now, we can see that while all other divisors cancel each other out - (they toggle the bulb twice) - 6 has no counterpart to toggle the bulb off. So, when there are 36 bulbs, 6 will always be ON at the end. The same holds true for perfect squares less than N - which are 1,4,9,16,25.\\n* Based on the above inferences, we can see that we need to find the numbers less than N that are perfect squares.  We can calculate this (int) Math.sqrt(N) or have a simple for-loop to count (i*i) <=N \\n\\nHope this helps."
                    },
                    {
                        "username": "rajeshkumar1130",
                        "content": "I was asked this question in an interview with microsoft on 22-01-2021"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It just proves that an ordinary position at MS is a dead-end job."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@sandagolcea](/sandagolcea)  Nice solution bro! The code is also quite neat. Good job!"
                    },
                    {
                        "username": "algoacer",
                        "content": "[@code_coffeee](/code_coffeee) Acutally it is so true, some one gets to implement a plain algorithm and someone has to think out of the box in 40 minutes. Not fair. But we should keep applying at multiple companies."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@code_coffeee](/code_coffeee) do you mean a TLE? I've actually solved it differently, using rather simple mathematics, but not sqrt (which i know was quite obvs, but I thought of doing smth else :D ) here https://leetcode.com/problems/bulb-switcher/solutions/3461670/js-solutions-without-using-sqrt/ "
                    },
                    {
                        "username": "l3aonti",
                        "content": "[@dvijay96](/dvijay96) it throws memory limit exception "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@code_coffeee](/code_coffeee) Brute force n^2 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "they what happened bro how did you explain "
                    },
                    {
                        "username": "code_coffeee",
                        "content": "This makes me sad.\\n\\nI feel like if they ask anyone this, they must not want to hire this person. If anyone codes it in any way without using square root, it is  a rejection."
                    },
                    {
                        "username": "bingzhoudaren",
                        "content": "First, we need to figure out how do we know if the ith light is on or off at the end. \\nit dpends on how many numbers could output i after you get product of them.\\nfor example 6, \\nwe will toggle the 6th light in the first round becasue 1 times6=6\\nwe will toggle the 6th light in the second round because 2 times 3=6;\\nwe will toggle the 6th light in third round beacuse 3 times 2 =6;\\nand we will toggle the 6th light in 6th round beacuse 6 times 1=6;\\n\\nso since wil have 1,2,3,6,totally four numbers, we will toggle the 6th light 4 times.\\nand since 4 is even ,so the 6th light will be off at the end.\\n\\nand for example, 9 could have division 1,3,9,  there are three of them. which is odd, so the 9th light is on at the end.\\n\\n\\nthen the problem is to figure out which number have odd divisions, which have even.\\n\\nthen, we should realize that,  for no-square number, the divisions can be paired.\\n\\nfor example, for 6, 1,and 6 is a pair, 2 and 3 is a pair.\\nhowever, for square number, for example 9, 3 will pair by itself, or we could say, 3 does not have a partener to build a pair.\\n\\nso, only lights at square numbers position will be on at the end.\\n\\nso, if we have 10 lights, at the end, only 1,4,9 light will be on.\\n\\n\\nand how to count them? by sqrt(10), we could get 3, which is the number of square numbers smaller than 10\\n\\n\\n\\n"
                    },
                    {
                        "username": "warrenbrodsky",
                        "content": "To begin, let\\'s forget keeping track of *every*  bulb and only think about *one*. Clearly, this bulb can either be on or off.  While obvious, this is still significant. If we know how many times we toggled the bulb, we can figure out which state it is in: If we have a bulb that begins on and we toggle it once, it will be off. Twice, on again. Thrice, off, four times on, five off, six on, etc. OK, so the answer is parity -- even flips it\\'s on, odd it\\'s off. \\n\\nGreat, but we don\\'t flip every bulb on every iteration, so how do we know how many times we flipped it? Ok, well on the first pass, we flip every other bulb, that is, every bulb whose index is a multiple of 2 (assuming indexing starts from 1 ;) ). On the next, we toggle every multiple of 3. On the next, multiples of 4, etc. When we\\'re done, we\\'ll have flipped every bulb once for each number that it is a multiple of, which is to say, once for each *divisor*. (Importantly, we include itself, but not 1.) For example, bulb 6 is flipped off for 2, on for 3, and off one final time for 6. Another important fact is that divisors come in pairs -- it and the thing it has to be multiplied with to get the number. The ***only*** time this isn\\'t true is if the thing it is multiplied by is itself. In other words, it\\'s a perfect square. Therefore perfect squares will *always* have an *odd* number of divisors and all others have *even* numbers of divisors. Since we\\'re not including one as a divisor, the parity flips and therefore, when all is said and done, only bulbs with perfect square indices will remain on.\\n\\nBulk of the work done -- now we just need to know how many perfect squares there are from 1 to n (which I will call squaresLTE(n)) and that will be our answer. This is fairly simple: beginning with n=1 and squaresLTE(1) = 1, we can see squaresLTE(2) is still 1,  squaresLTE(3) is still 1, and we finally get another square when n=4 and squaresLTE(4)=2 -- 1, and 4. We don\\'t add another square to the list until n=the next square. This gives us the final answer:\\n\\n`bulbs(n) = squaresLTE(n) = floor(sqrt(n))`\\n\\nThis works because if we\\'re between two squares a=s^2 and b=(s+1)^2, sqrt(n) will be some number between s and s+1, so floor(sqrt(n)) will bring us down to the sqrt of the last square we added to the list"
                    },
                    {
                        "username": "dilipK",
                        "content": "* If a particular number n is divisible by k , it means it will also  be divisible by n/k. So it will bring it to original state i.e.off. So toggling at kth iteration will turn ON but toggling at (n/k)th iteration will bring it to OFF. So no change.\\n* But for a prefect square sqrt(n) will only toggle it once , so it will be overall ON."
                    },
                    {
                        "username": "suhane",
                        "content": "# Logic : 1st round Bulb is ON, then each switch will OFF then ON. so for any number ->\\n# 1st round : ON\\n# 2nd round : OFF\\n# 3rd round : ON \\n# 4th round : OFF  and so on ....\\n# \\n# **If we can calculate how many times each bulb is switched we can tell it was ON/OFF at the last.**\\n# \\n# from above we can see if we switch bulb EVEN times we get it OFF at last, if switch ODD times we get it ON at the last.**\\n\\n*Now take few examples to understand better-*\\nN=1 -> bulb switched 1 time (for N=1)  \\t\\t\\t-> OFF at last\\n\\nN=2 -> bulb switched 2 times (for N=1, 2) \\t\\t-> OFF at last\\n\\nN=3 -> bulb switched 2 times (for N=1, 3) \\t\\t-> OFF at last\\n\\nN=4 -> bulb switched 3 times (for N=1, 2, 4) \\t-> **ON** at last\\n\\nN=5 -> bulb switched 2 times (for N=1, 5) \\t\\t-> OFF at last\\n\\nN=6 -> bulb switched 4 times (for N=1, 2, 3, 6) -> OFF at last\\n\\nN=7 -> bulb switched 2 times (for N=1, 7)\\t\\t-> OFF at last\\t\\n\\nN=8 -> bulb switched 8* times (for N=1, 2, 4, 8)\\t-> OFF at last\\t\\n(how we got 8 switches -\\nadd all switches of\\nN=1 (1 times at N=1),\\nN=2 (2 times at N=1,2), \\nN=4 (3 times at N=1,2,4) ,\\nN=8 (2 time at N=1,8))\\n\\nN=9 -> bulb switched 3 times (for N=1, 3, 9)\\t-> **ON** at last\\t\\n\\nAs you can see from above we got a conclusion only bulbs which are perfect square will be left ON at the last. (4, 9, 16, 25....) rest all bulbs will be OFF at the last.\\n\\nso we just need to fine how may perfact squares are present for any given N.\\nif N=20 -> 2, 4, 9, 16 (total 4)\\nif N=30 -> 2, 4, 9, 16, 25 (total 5)\\n\\nso we can convert calculating how many perfact sqs to -> simple solution\\n\\n# Ans: round(sqrt(N));\\n\\nBut this 1 line solution we can\\'t find until we know the whole logic that takes long time.\\n\\nHappy Learning !!\\n\\n"
                    }
                ]
            },
            {
                "id": 1566028,
                "content": [
                    {
                        "username": "rexthk",
                        "content": "Below are my step by step thought process. Hope it helps\\n\\nObservation #1:\\nA bulb is ON if it is toggled **odd** times: (ON), (ON -> OFF -> ON), (ON -> OFF -> ON -> OFF -> ON) ...\\nA bulb is OFF if it is toggled **even** times: (ON -> OFF), (ON -> OFF -> ON -> OFF ) ...\\n\\nObservation #2:\\nOnce we reach and toggle the ***i-th*** bulb, it will never be touched anymore.\\n\\nfor exmaple, let n = 5 ( changes in each round denoted as bold ), initial state is all OFF:\\n1-th round :   **ON,  ON,  ON,  ON, ON**\\n2-nd round:   ON, **OFF**,  ON, **OFF**, ON\\n3-rd round :   ON, OFF, **OFF**, OFF, ON\\n4-th round :   ON, OFF, OFF, **ON**, ON\\n5-th round :   ON, OFF, OFF, ON, **OFF**\\n\\nYou can see that, after each round, all bulbs before that round will not be touched anymore.\\n\\nSo, given a bulb at position X, how do I know it will be toggled EVEN/ODD times ?\\nAnswer: We can find the number of divisors of X. \\n\\nfor example, if the position of a bulb is 3, its divisor is [1,3], that mean we will toggle the 3-rd bulb at 1-st round and 3-rd round:\\nCombine the observation above, \\nat ***3-rd*** round, the third bulb will have been toggeld even times ( [1,3] ), so it is OFF. And it will not be changed later on round.\\nat ***5-th*** round, the fifth bulb will have been toggled even times ( [1,5] ), so it is OFF. And it will not be changed later on round.\\n\\nSuppose we have a func to get all divisors of i : **getDivisors(int)**, a simple algorithm can be deduced:\\n`for i = 1..n, if getDivisors(i) % 2 == 1, count++;`\\nWe loop through all positions, if it has odd number of divisors, it is ON and hence count + 1.\\n\\nUnfortunately, it will timeout. How to optimize ?\\n\\nObservation #3:\\nDivisors always come in pair. For example:\\n1: [1,1]  ---  2: [1,2] --- 3: [1,3] --- 4: [1,4] [2,2] --- 5:[1,5] --- 6:[1,6][2,3] --- 7:[1,7] \\n8: [1,8][2,4] --- 9:[1,9][3,3]\\n\\nIn above examples, we know that: \\nOnly when ***i*** has **perfect square root**, its number of divisors is ODD, because it contains duplicated divisor. In above example,\\n4: [1,2,4] --- 9: [1,3,9]\\nYou can pick any number to examine yourself.\\n\\nHere comes a better algorithm:\\n`for i = 1...n,  if i^2 <= n, count++ ; if i^2 > n, break;`\\nWe loop through all position, if **i^2** is <= n, that means there exists a valid bulb which has perfect square root ***i***, and we need to count that **i^2**, so count + 1. If the **i^2** exceed n, we can terminate it because we have found all ***i*** with perfect square root within n already.\\n\\nMany of you might have seen the answer, so why the answer can be simply written as Math.sqrt(n) ?\\nconsider n = 9, the process of aforementioned algorithm will be: \\ncheck (1 * 1 ) <= 9, count++\\ncheck (2 * 2 ) <= 9, count++;\\ncheck (3 * 3) <= 9, count++;\\ncheck (4 * 4) > 9, break;\\n\\nWe can say, if square root of 9 is 3, that mean **1^2** and **2^2** must exists for n = 9. Hence, the Math.sqrt(i) reflect this fact.\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "I got to observation 2 on my own. The condition for an odd number of divisors was eluding me, thanks for the help"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "mind glowing explanation\\n"
                    },
                    {
                        "username": "saidfgn",
                        "content": "Great explanation, thanks!"
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "**Its more like a puzzle rather than a coding problem**"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "[@yusufm09](/yusufm09) brain tester problem means does they ask this in interviews"
                    },
                    {
                        "username": "yusufm09",
                        "content": "[@jerryy147](/jerryy147) I never knew that there was a brainteaser problem list. Thanks."
                    },
                    {
                        "username": "jerryy147",
                        "content": "that\\'s why it\\'s in the \"brainteaser\" problem list"
                    },
                    {
                        "username": "strongwillow",
                        "content": "It only stated the first, second, third, and last round. Should be updated as follows:\\n\\nThere are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). **For the ith round, you toggle every i bulb.** For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds."
                    },
                    {
                        "username": "sx1w",
                        "content": "Like many of you are wondering why a simple sqaure root solution to the problem, I wanted to find out why that is correct. Here is my little research into it. \\n\\nThe light bulb at postion k must be toggled in odd number to stay on, e.g. \\'On, Off, On\\' including the initial toggle. What triggers k-th bulb be toggled? Number k must be an **exact** multiple of each toggling. For example, when k=4, the bulb will be triggered by the 1st (On), 2nd (Off) and 4th (On) operation. What is the exact number of multiple of a nature number k? **All of its factors** ! \\n\\nSo the k-th bulb \\'ON\\' is corresponding to the number of factors of k being odd. You can certainly develop a program to count. However, the [*number math*](http://mathcentral.uregina.ca/QQ/database/QQ.09.06/jacqueline1.html) tells us only perfect square numbers have odd number of factors, which is what needed for the bulb to stay on. \\n\\nGreat! Now to solve the problem is to find out how many perfect square number between 1 and n. The [*math*](https://www.quora.com/How-many-perfect-squares-are-there-between-1-to-1000) kicks in again, and that number is the square root of n (more preceisly the floor of sqaure root of n). \\n\\nWhat a great problem!"
                    },
                    {
                        "username": "bharathb",
                        "content": "A lot of other posts provide code / suggest a simulation to see the pattern. I will attempt to describe the intuition behind the solution. \\n\\n* First let s identify all the bulbs that can touch/affect/toggle bulb X. Bulb X can only be toggled by other bulbs which are less than or equal to X. For example, 26 will never toggle bulb 23.\\n* Secondly, for a bulb X what are the bulbs that can toggle X? 23 can never toggle 25. We notice that a bulb X can only be toggled by divisors of X - including 1 and X itself. \\n* Now let s consider prime numbers. Prime numbers by definition have exactly two divisors. Any number with 2 divisors will never be ON at the end - because 1 will set it to ON and the second divisor (the prime number itself) will toggle it off.\\n* With prime numbers gone, lets consider a composite number with an even number of divisors.  Say 24. The divisors of 24 are (1,2,3,4,6,8,12,24). Listing the divisors as pairs - (1, 24) (2,12), (3,8), (4,6) - pairs are crucial because one divisor will set 24 to ON and the other divisor will set it to OFF. So, the net result is that those bulbs will NOT be ON at the end of the simulation - because they are initially OFF. They are toggled an even number of times.\\n* Now, we need to find numbers <=N which have an odd number of divisors. This might not be intuitive immediately and this simulating the problem on paper helps. If we consider a perfect square like 36 and write the divisors in pairs - (1,36), (2,18), (3, 12), (4, 9), (6,6). Now, we can see that while all other divisors cancel each other out - (they toggle the bulb twice) - 6 has no counterpart to toggle the bulb off. So, when there are 36 bulbs, 6 will always be ON at the end. The same holds true for perfect squares less than N - which are 1,4,9,16,25.\\n* Based on the above inferences, we can see that we need to find the numbers less than N that are perfect squares.  We can calculate this (int) Math.sqrt(N) or have a simple for-loop to count (i*i) <=N \\n\\nHope this helps."
                    },
                    {
                        "username": "rajeshkumar1130",
                        "content": "I was asked this question in an interview with microsoft on 22-01-2021"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It just proves that an ordinary position at MS is a dead-end job."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@sandagolcea](/sandagolcea)  Nice solution bro! The code is also quite neat. Good job!"
                    },
                    {
                        "username": "algoacer",
                        "content": "[@code_coffeee](/code_coffeee) Acutally it is so true, some one gets to implement a plain algorithm and someone has to think out of the box in 40 minutes. Not fair. But we should keep applying at multiple companies."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@code_coffeee](/code_coffeee) do you mean a TLE? I've actually solved it differently, using rather simple mathematics, but not sqrt (which i know was quite obvs, but I thought of doing smth else :D ) here https://leetcode.com/problems/bulb-switcher/solutions/3461670/js-solutions-without-using-sqrt/ "
                    },
                    {
                        "username": "l3aonti",
                        "content": "[@dvijay96](/dvijay96) it throws memory limit exception "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@code_coffeee](/code_coffeee) Brute force n^2 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "they what happened bro how did you explain "
                    },
                    {
                        "username": "code_coffeee",
                        "content": "This makes me sad.\\n\\nI feel like if they ask anyone this, they must not want to hire this person. If anyone codes it in any way without using square root, it is  a rejection."
                    },
                    {
                        "username": "bingzhoudaren",
                        "content": "First, we need to figure out how do we know if the ith light is on or off at the end. \\nit dpends on how many numbers could output i after you get product of them.\\nfor example 6, \\nwe will toggle the 6th light in the first round becasue 1 times6=6\\nwe will toggle the 6th light in the second round because 2 times 3=6;\\nwe will toggle the 6th light in third round beacuse 3 times 2 =6;\\nand we will toggle the 6th light in 6th round beacuse 6 times 1=6;\\n\\nso since wil have 1,2,3,6,totally four numbers, we will toggle the 6th light 4 times.\\nand since 4 is even ,so the 6th light will be off at the end.\\n\\nand for example, 9 could have division 1,3,9,  there are three of them. which is odd, so the 9th light is on at the end.\\n\\n\\nthen the problem is to figure out which number have odd divisions, which have even.\\n\\nthen, we should realize that,  for no-square number, the divisions can be paired.\\n\\nfor example, for 6, 1,and 6 is a pair, 2 and 3 is a pair.\\nhowever, for square number, for example 9, 3 will pair by itself, or we could say, 3 does not have a partener to build a pair.\\n\\nso, only lights at square numbers position will be on at the end.\\n\\nso, if we have 10 lights, at the end, only 1,4,9 light will be on.\\n\\n\\nand how to count them? by sqrt(10), we could get 3, which is the number of square numbers smaller than 10\\n\\n\\n\\n"
                    },
                    {
                        "username": "warrenbrodsky",
                        "content": "To begin, let\\'s forget keeping track of *every*  bulb and only think about *one*. Clearly, this bulb can either be on or off.  While obvious, this is still significant. If we know how many times we toggled the bulb, we can figure out which state it is in: If we have a bulb that begins on and we toggle it once, it will be off. Twice, on again. Thrice, off, four times on, five off, six on, etc. OK, so the answer is parity -- even flips it\\'s on, odd it\\'s off. \\n\\nGreat, but we don\\'t flip every bulb on every iteration, so how do we know how many times we flipped it? Ok, well on the first pass, we flip every other bulb, that is, every bulb whose index is a multiple of 2 (assuming indexing starts from 1 ;) ). On the next, we toggle every multiple of 3. On the next, multiples of 4, etc. When we\\'re done, we\\'ll have flipped every bulb once for each number that it is a multiple of, which is to say, once for each *divisor*. (Importantly, we include itself, but not 1.) For example, bulb 6 is flipped off for 2, on for 3, and off one final time for 6. Another important fact is that divisors come in pairs -- it and the thing it has to be multiplied with to get the number. The ***only*** time this isn\\'t true is if the thing it is multiplied by is itself. In other words, it\\'s a perfect square. Therefore perfect squares will *always* have an *odd* number of divisors and all others have *even* numbers of divisors. Since we\\'re not including one as a divisor, the parity flips and therefore, when all is said and done, only bulbs with perfect square indices will remain on.\\n\\nBulk of the work done -- now we just need to know how many perfect squares there are from 1 to n (which I will call squaresLTE(n)) and that will be our answer. This is fairly simple: beginning with n=1 and squaresLTE(1) = 1, we can see squaresLTE(2) is still 1,  squaresLTE(3) is still 1, and we finally get another square when n=4 and squaresLTE(4)=2 -- 1, and 4. We don\\'t add another square to the list until n=the next square. This gives us the final answer:\\n\\n`bulbs(n) = squaresLTE(n) = floor(sqrt(n))`\\n\\nThis works because if we\\'re between two squares a=s^2 and b=(s+1)^2, sqrt(n) will be some number between s and s+1, so floor(sqrt(n)) will bring us down to the sqrt of the last square we added to the list"
                    },
                    {
                        "username": "dilipK",
                        "content": "* If a particular number n is divisible by k , it means it will also  be divisible by n/k. So it will bring it to original state i.e.off. So toggling at kth iteration will turn ON but toggling at (n/k)th iteration will bring it to OFF. So no change.\\n* But for a prefect square sqrt(n) will only toggle it once , so it will be overall ON."
                    },
                    {
                        "username": "suhane",
                        "content": "# Logic : 1st round Bulb is ON, then each switch will OFF then ON. so for any number ->\\n# 1st round : ON\\n# 2nd round : OFF\\n# 3rd round : ON \\n# 4th round : OFF  and so on ....\\n# \\n# **If we can calculate how many times each bulb is switched we can tell it was ON/OFF at the last.**\\n# \\n# from above we can see if we switch bulb EVEN times we get it OFF at last, if switch ODD times we get it ON at the last.**\\n\\n*Now take few examples to understand better-*\\nN=1 -> bulb switched 1 time (for N=1)  \\t\\t\\t-> OFF at last\\n\\nN=2 -> bulb switched 2 times (for N=1, 2) \\t\\t-> OFF at last\\n\\nN=3 -> bulb switched 2 times (for N=1, 3) \\t\\t-> OFF at last\\n\\nN=4 -> bulb switched 3 times (for N=1, 2, 4) \\t-> **ON** at last\\n\\nN=5 -> bulb switched 2 times (for N=1, 5) \\t\\t-> OFF at last\\n\\nN=6 -> bulb switched 4 times (for N=1, 2, 3, 6) -> OFF at last\\n\\nN=7 -> bulb switched 2 times (for N=1, 7)\\t\\t-> OFF at last\\t\\n\\nN=8 -> bulb switched 8* times (for N=1, 2, 4, 8)\\t-> OFF at last\\t\\n(how we got 8 switches -\\nadd all switches of\\nN=1 (1 times at N=1),\\nN=2 (2 times at N=1,2), \\nN=4 (3 times at N=1,2,4) ,\\nN=8 (2 time at N=1,8))\\n\\nN=9 -> bulb switched 3 times (for N=1, 3, 9)\\t-> **ON** at last\\t\\n\\nAs you can see from above we got a conclusion only bulbs which are perfect square will be left ON at the last. (4, 9, 16, 25....) rest all bulbs will be OFF at the last.\\n\\nso we just need to fine how may perfact squares are present for any given N.\\nif N=20 -> 2, 4, 9, 16 (total 4)\\nif N=30 -> 2, 4, 9, 16, 25 (total 5)\\n\\nso we can convert calculating how many perfact sqs to -> simple solution\\n\\n# Ans: round(sqrt(N));\\n\\nBut this 1 line solution we can\\'t find until we know the whole logic that takes long time.\\n\\nHappy Learning !!\\n\\n"
                    }
                ]
            },
            {
                "id": 1566143,
                "content": [
                    {
                        "username": "rexthk",
                        "content": "Below are my step by step thought process. Hope it helps\\n\\nObservation #1:\\nA bulb is ON if it is toggled **odd** times: (ON), (ON -> OFF -> ON), (ON -> OFF -> ON -> OFF -> ON) ...\\nA bulb is OFF if it is toggled **even** times: (ON -> OFF), (ON -> OFF -> ON -> OFF ) ...\\n\\nObservation #2:\\nOnce we reach and toggle the ***i-th*** bulb, it will never be touched anymore.\\n\\nfor exmaple, let n = 5 ( changes in each round denoted as bold ), initial state is all OFF:\\n1-th round :   **ON,  ON,  ON,  ON, ON**\\n2-nd round:   ON, **OFF**,  ON, **OFF**, ON\\n3-rd round :   ON, OFF, **OFF**, OFF, ON\\n4-th round :   ON, OFF, OFF, **ON**, ON\\n5-th round :   ON, OFF, OFF, ON, **OFF**\\n\\nYou can see that, after each round, all bulbs before that round will not be touched anymore.\\n\\nSo, given a bulb at position X, how do I know it will be toggled EVEN/ODD times ?\\nAnswer: We can find the number of divisors of X. \\n\\nfor example, if the position of a bulb is 3, its divisor is [1,3], that mean we will toggle the 3-rd bulb at 1-st round and 3-rd round:\\nCombine the observation above, \\nat ***3-rd*** round, the third bulb will have been toggeld even times ( [1,3] ), so it is OFF. And it will not be changed later on round.\\nat ***5-th*** round, the fifth bulb will have been toggled even times ( [1,5] ), so it is OFF. And it will not be changed later on round.\\n\\nSuppose we have a func to get all divisors of i : **getDivisors(int)**, a simple algorithm can be deduced:\\n`for i = 1..n, if getDivisors(i) % 2 == 1, count++;`\\nWe loop through all positions, if it has odd number of divisors, it is ON and hence count + 1.\\n\\nUnfortunately, it will timeout. How to optimize ?\\n\\nObservation #3:\\nDivisors always come in pair. For example:\\n1: [1,1]  ---  2: [1,2] --- 3: [1,3] --- 4: [1,4] [2,2] --- 5:[1,5] --- 6:[1,6][2,3] --- 7:[1,7] \\n8: [1,8][2,4] --- 9:[1,9][3,3]\\n\\nIn above examples, we know that: \\nOnly when ***i*** has **perfect square root**, its number of divisors is ODD, because it contains duplicated divisor. In above example,\\n4: [1,2,4] --- 9: [1,3,9]\\nYou can pick any number to examine yourself.\\n\\nHere comes a better algorithm:\\n`for i = 1...n,  if i^2 <= n, count++ ; if i^2 > n, break;`\\nWe loop through all position, if **i^2** is <= n, that means there exists a valid bulb which has perfect square root ***i***, and we need to count that **i^2**, so count + 1. If the **i^2** exceed n, we can terminate it because we have found all ***i*** with perfect square root within n already.\\n\\nMany of you might have seen the answer, so why the answer can be simply written as Math.sqrt(n) ?\\nconsider n = 9, the process of aforementioned algorithm will be: \\ncheck (1 * 1 ) <= 9, count++\\ncheck (2 * 2 ) <= 9, count++;\\ncheck (3 * 3) <= 9, count++;\\ncheck (4 * 4) > 9, break;\\n\\nWe can say, if square root of 9 is 3, that mean **1^2** and **2^2** must exists for n = 9. Hence, the Math.sqrt(i) reflect this fact.\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "I got to observation 2 on my own. The condition for an odd number of divisors was eluding me, thanks for the help"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "mind glowing explanation\\n"
                    },
                    {
                        "username": "saidfgn",
                        "content": "Great explanation, thanks!"
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "**Its more like a puzzle rather than a coding problem**"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "[@yusufm09](/yusufm09) brain tester problem means does they ask this in interviews"
                    },
                    {
                        "username": "yusufm09",
                        "content": "[@jerryy147](/jerryy147) I never knew that there was a brainteaser problem list. Thanks."
                    },
                    {
                        "username": "jerryy147",
                        "content": "that\\'s why it\\'s in the \"brainteaser\" problem list"
                    },
                    {
                        "username": "strongwillow",
                        "content": "It only stated the first, second, third, and last round. Should be updated as follows:\\n\\nThere are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). **For the ith round, you toggle every i bulb.** For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds."
                    },
                    {
                        "username": "sx1w",
                        "content": "Like many of you are wondering why a simple sqaure root solution to the problem, I wanted to find out why that is correct. Here is my little research into it. \\n\\nThe light bulb at postion k must be toggled in odd number to stay on, e.g. \\'On, Off, On\\' including the initial toggle. What triggers k-th bulb be toggled? Number k must be an **exact** multiple of each toggling. For example, when k=4, the bulb will be triggered by the 1st (On), 2nd (Off) and 4th (On) operation. What is the exact number of multiple of a nature number k? **All of its factors** ! \\n\\nSo the k-th bulb \\'ON\\' is corresponding to the number of factors of k being odd. You can certainly develop a program to count. However, the [*number math*](http://mathcentral.uregina.ca/QQ/database/QQ.09.06/jacqueline1.html) tells us only perfect square numbers have odd number of factors, which is what needed for the bulb to stay on. \\n\\nGreat! Now to solve the problem is to find out how many perfect square number between 1 and n. The [*math*](https://www.quora.com/How-many-perfect-squares-are-there-between-1-to-1000) kicks in again, and that number is the square root of n (more preceisly the floor of sqaure root of n). \\n\\nWhat a great problem!"
                    },
                    {
                        "username": "bharathb",
                        "content": "A lot of other posts provide code / suggest a simulation to see the pattern. I will attempt to describe the intuition behind the solution. \\n\\n* First let s identify all the bulbs that can touch/affect/toggle bulb X. Bulb X can only be toggled by other bulbs which are less than or equal to X. For example, 26 will never toggle bulb 23.\\n* Secondly, for a bulb X what are the bulbs that can toggle X? 23 can never toggle 25. We notice that a bulb X can only be toggled by divisors of X - including 1 and X itself. \\n* Now let s consider prime numbers. Prime numbers by definition have exactly two divisors. Any number with 2 divisors will never be ON at the end - because 1 will set it to ON and the second divisor (the prime number itself) will toggle it off.\\n* With prime numbers gone, lets consider a composite number with an even number of divisors.  Say 24. The divisors of 24 are (1,2,3,4,6,8,12,24). Listing the divisors as pairs - (1, 24) (2,12), (3,8), (4,6) - pairs are crucial because one divisor will set 24 to ON and the other divisor will set it to OFF. So, the net result is that those bulbs will NOT be ON at the end of the simulation - because they are initially OFF. They are toggled an even number of times.\\n* Now, we need to find numbers <=N which have an odd number of divisors. This might not be intuitive immediately and this simulating the problem on paper helps. If we consider a perfect square like 36 and write the divisors in pairs - (1,36), (2,18), (3, 12), (4, 9), (6,6). Now, we can see that while all other divisors cancel each other out - (they toggle the bulb twice) - 6 has no counterpart to toggle the bulb off. So, when there are 36 bulbs, 6 will always be ON at the end. The same holds true for perfect squares less than N - which are 1,4,9,16,25.\\n* Based on the above inferences, we can see that we need to find the numbers less than N that are perfect squares.  We can calculate this (int) Math.sqrt(N) or have a simple for-loop to count (i*i) <=N \\n\\nHope this helps."
                    },
                    {
                        "username": "rajeshkumar1130",
                        "content": "I was asked this question in an interview with microsoft on 22-01-2021"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It just proves that an ordinary position at MS is a dead-end job."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@sandagolcea](/sandagolcea)  Nice solution bro! The code is also quite neat. Good job!"
                    },
                    {
                        "username": "algoacer",
                        "content": "[@code_coffeee](/code_coffeee) Acutally it is so true, some one gets to implement a plain algorithm and someone has to think out of the box in 40 minutes. Not fair. But we should keep applying at multiple companies."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@code_coffeee](/code_coffeee) do you mean a TLE? I've actually solved it differently, using rather simple mathematics, but not sqrt (which i know was quite obvs, but I thought of doing smth else :D ) here https://leetcode.com/problems/bulb-switcher/solutions/3461670/js-solutions-without-using-sqrt/ "
                    },
                    {
                        "username": "l3aonti",
                        "content": "[@dvijay96](/dvijay96) it throws memory limit exception "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@code_coffeee](/code_coffeee) Brute force n^2 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "they what happened bro how did you explain "
                    },
                    {
                        "username": "code_coffeee",
                        "content": "This makes me sad.\\n\\nI feel like if they ask anyone this, they must not want to hire this person. If anyone codes it in any way without using square root, it is  a rejection."
                    },
                    {
                        "username": "bingzhoudaren",
                        "content": "First, we need to figure out how do we know if the ith light is on or off at the end. \\nit dpends on how many numbers could output i after you get product of them.\\nfor example 6, \\nwe will toggle the 6th light in the first round becasue 1 times6=6\\nwe will toggle the 6th light in the second round because 2 times 3=6;\\nwe will toggle the 6th light in third round beacuse 3 times 2 =6;\\nand we will toggle the 6th light in 6th round beacuse 6 times 1=6;\\n\\nso since wil have 1,2,3,6,totally four numbers, we will toggle the 6th light 4 times.\\nand since 4 is even ,so the 6th light will be off at the end.\\n\\nand for example, 9 could have division 1,3,9,  there are three of them. which is odd, so the 9th light is on at the end.\\n\\n\\nthen the problem is to figure out which number have odd divisions, which have even.\\n\\nthen, we should realize that,  for no-square number, the divisions can be paired.\\n\\nfor example, for 6, 1,and 6 is a pair, 2 and 3 is a pair.\\nhowever, for square number, for example 9, 3 will pair by itself, or we could say, 3 does not have a partener to build a pair.\\n\\nso, only lights at square numbers position will be on at the end.\\n\\nso, if we have 10 lights, at the end, only 1,4,9 light will be on.\\n\\n\\nand how to count them? by sqrt(10), we could get 3, which is the number of square numbers smaller than 10\\n\\n\\n\\n"
                    },
                    {
                        "username": "warrenbrodsky",
                        "content": "To begin, let\\'s forget keeping track of *every*  bulb and only think about *one*. Clearly, this bulb can either be on or off.  While obvious, this is still significant. If we know how many times we toggled the bulb, we can figure out which state it is in: If we have a bulb that begins on and we toggle it once, it will be off. Twice, on again. Thrice, off, four times on, five off, six on, etc. OK, so the answer is parity -- even flips it\\'s on, odd it\\'s off. \\n\\nGreat, but we don\\'t flip every bulb on every iteration, so how do we know how many times we flipped it? Ok, well on the first pass, we flip every other bulb, that is, every bulb whose index is a multiple of 2 (assuming indexing starts from 1 ;) ). On the next, we toggle every multiple of 3. On the next, multiples of 4, etc. When we\\'re done, we\\'ll have flipped every bulb once for each number that it is a multiple of, which is to say, once for each *divisor*. (Importantly, we include itself, but not 1.) For example, bulb 6 is flipped off for 2, on for 3, and off one final time for 6. Another important fact is that divisors come in pairs -- it and the thing it has to be multiplied with to get the number. The ***only*** time this isn\\'t true is if the thing it is multiplied by is itself. In other words, it\\'s a perfect square. Therefore perfect squares will *always* have an *odd* number of divisors and all others have *even* numbers of divisors. Since we\\'re not including one as a divisor, the parity flips and therefore, when all is said and done, only bulbs with perfect square indices will remain on.\\n\\nBulk of the work done -- now we just need to know how many perfect squares there are from 1 to n (which I will call squaresLTE(n)) and that will be our answer. This is fairly simple: beginning with n=1 and squaresLTE(1) = 1, we can see squaresLTE(2) is still 1,  squaresLTE(3) is still 1, and we finally get another square when n=4 and squaresLTE(4)=2 -- 1, and 4. We don\\'t add another square to the list until n=the next square. This gives us the final answer:\\n\\n`bulbs(n) = squaresLTE(n) = floor(sqrt(n))`\\n\\nThis works because if we\\'re between two squares a=s^2 and b=(s+1)^2, sqrt(n) will be some number between s and s+1, so floor(sqrt(n)) will bring us down to the sqrt of the last square we added to the list"
                    },
                    {
                        "username": "dilipK",
                        "content": "* If a particular number n is divisible by k , it means it will also  be divisible by n/k. So it will bring it to original state i.e.off. So toggling at kth iteration will turn ON but toggling at (n/k)th iteration will bring it to OFF. So no change.\\n* But for a prefect square sqrt(n) will only toggle it once , so it will be overall ON."
                    },
                    {
                        "username": "suhane",
                        "content": "# Logic : 1st round Bulb is ON, then each switch will OFF then ON. so for any number ->\\n# 1st round : ON\\n# 2nd round : OFF\\n# 3rd round : ON \\n# 4th round : OFF  and so on ....\\n# \\n# **If we can calculate how many times each bulb is switched we can tell it was ON/OFF at the last.**\\n# \\n# from above we can see if we switch bulb EVEN times we get it OFF at last, if switch ODD times we get it ON at the last.**\\n\\n*Now take few examples to understand better-*\\nN=1 -> bulb switched 1 time (for N=1)  \\t\\t\\t-> OFF at last\\n\\nN=2 -> bulb switched 2 times (for N=1, 2) \\t\\t-> OFF at last\\n\\nN=3 -> bulb switched 2 times (for N=1, 3) \\t\\t-> OFF at last\\n\\nN=4 -> bulb switched 3 times (for N=1, 2, 4) \\t-> **ON** at last\\n\\nN=5 -> bulb switched 2 times (for N=1, 5) \\t\\t-> OFF at last\\n\\nN=6 -> bulb switched 4 times (for N=1, 2, 3, 6) -> OFF at last\\n\\nN=7 -> bulb switched 2 times (for N=1, 7)\\t\\t-> OFF at last\\t\\n\\nN=8 -> bulb switched 8* times (for N=1, 2, 4, 8)\\t-> OFF at last\\t\\n(how we got 8 switches -\\nadd all switches of\\nN=1 (1 times at N=1),\\nN=2 (2 times at N=1,2), \\nN=4 (3 times at N=1,2,4) ,\\nN=8 (2 time at N=1,8))\\n\\nN=9 -> bulb switched 3 times (for N=1, 3, 9)\\t-> **ON** at last\\t\\n\\nAs you can see from above we got a conclusion only bulbs which are perfect square will be left ON at the last. (4, 9, 16, 25....) rest all bulbs will be OFF at the last.\\n\\nso we just need to fine how may perfact squares are present for any given N.\\nif N=20 -> 2, 4, 9, 16 (total 4)\\nif N=30 -> 2, 4, 9, 16, 25 (total 5)\\n\\nso we can convert calculating how many perfact sqs to -> simple solution\\n\\n# Ans: round(sqrt(N));\\n\\nBut this 1 line solution we can\\'t find until we know the whole logic that takes long time.\\n\\nHappy Learning !!\\n\\n"
                    }
                ]
            },
            {
                "id": 1566635,
                "content": [
                    {
                        "username": "rexthk",
                        "content": "Below are my step by step thought process. Hope it helps\\n\\nObservation #1:\\nA bulb is ON if it is toggled **odd** times: (ON), (ON -> OFF -> ON), (ON -> OFF -> ON -> OFF -> ON) ...\\nA bulb is OFF if it is toggled **even** times: (ON -> OFF), (ON -> OFF -> ON -> OFF ) ...\\n\\nObservation #2:\\nOnce we reach and toggle the ***i-th*** bulb, it will never be touched anymore.\\n\\nfor exmaple, let n = 5 ( changes in each round denoted as bold ), initial state is all OFF:\\n1-th round :   **ON,  ON,  ON,  ON, ON**\\n2-nd round:   ON, **OFF**,  ON, **OFF**, ON\\n3-rd round :   ON, OFF, **OFF**, OFF, ON\\n4-th round :   ON, OFF, OFF, **ON**, ON\\n5-th round :   ON, OFF, OFF, ON, **OFF**\\n\\nYou can see that, after each round, all bulbs before that round will not be touched anymore.\\n\\nSo, given a bulb at position X, how do I know it will be toggled EVEN/ODD times ?\\nAnswer: We can find the number of divisors of X. \\n\\nfor example, if the position of a bulb is 3, its divisor is [1,3], that mean we will toggle the 3-rd bulb at 1-st round and 3-rd round:\\nCombine the observation above, \\nat ***3-rd*** round, the third bulb will have been toggeld even times ( [1,3] ), so it is OFF. And it will not be changed later on round.\\nat ***5-th*** round, the fifth bulb will have been toggled even times ( [1,5] ), so it is OFF. And it will not be changed later on round.\\n\\nSuppose we have a func to get all divisors of i : **getDivisors(int)**, a simple algorithm can be deduced:\\n`for i = 1..n, if getDivisors(i) % 2 == 1, count++;`\\nWe loop through all positions, if it has odd number of divisors, it is ON and hence count + 1.\\n\\nUnfortunately, it will timeout. How to optimize ?\\n\\nObservation #3:\\nDivisors always come in pair. For example:\\n1: [1,1]  ---  2: [1,2] --- 3: [1,3] --- 4: [1,4] [2,2] --- 5:[1,5] --- 6:[1,6][2,3] --- 7:[1,7] \\n8: [1,8][2,4] --- 9:[1,9][3,3]\\n\\nIn above examples, we know that: \\nOnly when ***i*** has **perfect square root**, its number of divisors is ODD, because it contains duplicated divisor. In above example,\\n4: [1,2,4] --- 9: [1,3,9]\\nYou can pick any number to examine yourself.\\n\\nHere comes a better algorithm:\\n`for i = 1...n,  if i^2 <= n, count++ ; if i^2 > n, break;`\\nWe loop through all position, if **i^2** is <= n, that means there exists a valid bulb which has perfect square root ***i***, and we need to count that **i^2**, so count + 1. If the **i^2** exceed n, we can terminate it because we have found all ***i*** with perfect square root within n already.\\n\\nMany of you might have seen the answer, so why the answer can be simply written as Math.sqrt(n) ?\\nconsider n = 9, the process of aforementioned algorithm will be: \\ncheck (1 * 1 ) <= 9, count++\\ncheck (2 * 2 ) <= 9, count++;\\ncheck (3 * 3) <= 9, count++;\\ncheck (4 * 4) > 9, break;\\n\\nWe can say, if square root of 9 is 3, that mean **1^2** and **2^2** must exists for n = 9. Hence, the Math.sqrt(i) reflect this fact.\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "I got to observation 2 on my own. The condition for an odd number of divisors was eluding me, thanks for the help"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "mind glowing explanation\\n"
                    },
                    {
                        "username": "saidfgn",
                        "content": "Great explanation, thanks!"
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "**Its more like a puzzle rather than a coding problem**"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "[@yusufm09](/yusufm09) brain tester problem means does they ask this in interviews"
                    },
                    {
                        "username": "yusufm09",
                        "content": "[@jerryy147](/jerryy147) I never knew that there was a brainteaser problem list. Thanks."
                    },
                    {
                        "username": "jerryy147",
                        "content": "that\\'s why it\\'s in the \"brainteaser\" problem list"
                    },
                    {
                        "username": "strongwillow",
                        "content": "It only stated the first, second, third, and last round. Should be updated as follows:\\n\\nThere are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). **For the ith round, you toggle every i bulb.** For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds."
                    },
                    {
                        "username": "sx1w",
                        "content": "Like many of you are wondering why a simple sqaure root solution to the problem, I wanted to find out why that is correct. Here is my little research into it. \\n\\nThe light bulb at postion k must be toggled in odd number to stay on, e.g. \\'On, Off, On\\' including the initial toggle. What triggers k-th bulb be toggled? Number k must be an **exact** multiple of each toggling. For example, when k=4, the bulb will be triggered by the 1st (On), 2nd (Off) and 4th (On) operation. What is the exact number of multiple of a nature number k? **All of its factors** ! \\n\\nSo the k-th bulb \\'ON\\' is corresponding to the number of factors of k being odd. You can certainly develop a program to count. However, the [*number math*](http://mathcentral.uregina.ca/QQ/database/QQ.09.06/jacqueline1.html) tells us only perfect square numbers have odd number of factors, which is what needed for the bulb to stay on. \\n\\nGreat! Now to solve the problem is to find out how many perfect square number between 1 and n. The [*math*](https://www.quora.com/How-many-perfect-squares-are-there-between-1-to-1000) kicks in again, and that number is the square root of n (more preceisly the floor of sqaure root of n). \\n\\nWhat a great problem!"
                    },
                    {
                        "username": "bharathb",
                        "content": "A lot of other posts provide code / suggest a simulation to see the pattern. I will attempt to describe the intuition behind the solution. \\n\\n* First let s identify all the bulbs that can touch/affect/toggle bulb X. Bulb X can only be toggled by other bulbs which are less than or equal to X. For example, 26 will never toggle bulb 23.\\n* Secondly, for a bulb X what are the bulbs that can toggle X? 23 can never toggle 25. We notice that a bulb X can only be toggled by divisors of X - including 1 and X itself. \\n* Now let s consider prime numbers. Prime numbers by definition have exactly two divisors. Any number with 2 divisors will never be ON at the end - because 1 will set it to ON and the second divisor (the prime number itself) will toggle it off.\\n* With prime numbers gone, lets consider a composite number with an even number of divisors.  Say 24. The divisors of 24 are (1,2,3,4,6,8,12,24). Listing the divisors as pairs - (1, 24) (2,12), (3,8), (4,6) - pairs are crucial because one divisor will set 24 to ON and the other divisor will set it to OFF. So, the net result is that those bulbs will NOT be ON at the end of the simulation - because they are initially OFF. They are toggled an even number of times.\\n* Now, we need to find numbers <=N which have an odd number of divisors. This might not be intuitive immediately and this simulating the problem on paper helps. If we consider a perfect square like 36 and write the divisors in pairs - (1,36), (2,18), (3, 12), (4, 9), (6,6). Now, we can see that while all other divisors cancel each other out - (they toggle the bulb twice) - 6 has no counterpart to toggle the bulb off. So, when there are 36 bulbs, 6 will always be ON at the end. The same holds true for perfect squares less than N - which are 1,4,9,16,25.\\n* Based on the above inferences, we can see that we need to find the numbers less than N that are perfect squares.  We can calculate this (int) Math.sqrt(N) or have a simple for-loop to count (i*i) <=N \\n\\nHope this helps."
                    },
                    {
                        "username": "rajeshkumar1130",
                        "content": "I was asked this question in an interview with microsoft on 22-01-2021"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It just proves that an ordinary position at MS is a dead-end job."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@sandagolcea](/sandagolcea)  Nice solution bro! The code is also quite neat. Good job!"
                    },
                    {
                        "username": "algoacer",
                        "content": "[@code_coffeee](/code_coffeee) Acutally it is so true, some one gets to implement a plain algorithm and someone has to think out of the box in 40 minutes. Not fair. But we should keep applying at multiple companies."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@code_coffeee](/code_coffeee) do you mean a TLE? I've actually solved it differently, using rather simple mathematics, but not sqrt (which i know was quite obvs, but I thought of doing smth else :D ) here https://leetcode.com/problems/bulb-switcher/solutions/3461670/js-solutions-without-using-sqrt/ "
                    },
                    {
                        "username": "l3aonti",
                        "content": "[@dvijay96](/dvijay96) it throws memory limit exception "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@code_coffeee](/code_coffeee) Brute force n^2 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "they what happened bro how did you explain "
                    },
                    {
                        "username": "code_coffeee",
                        "content": "This makes me sad.\\n\\nI feel like if they ask anyone this, they must not want to hire this person. If anyone codes it in any way without using square root, it is  a rejection."
                    },
                    {
                        "username": "bingzhoudaren",
                        "content": "First, we need to figure out how do we know if the ith light is on or off at the end. \\nit dpends on how many numbers could output i after you get product of them.\\nfor example 6, \\nwe will toggle the 6th light in the first round becasue 1 times6=6\\nwe will toggle the 6th light in the second round because 2 times 3=6;\\nwe will toggle the 6th light in third round beacuse 3 times 2 =6;\\nand we will toggle the 6th light in 6th round beacuse 6 times 1=6;\\n\\nso since wil have 1,2,3,6,totally four numbers, we will toggle the 6th light 4 times.\\nand since 4 is even ,so the 6th light will be off at the end.\\n\\nand for example, 9 could have division 1,3,9,  there are three of them. which is odd, so the 9th light is on at the end.\\n\\n\\nthen the problem is to figure out which number have odd divisions, which have even.\\n\\nthen, we should realize that,  for no-square number, the divisions can be paired.\\n\\nfor example, for 6, 1,and 6 is a pair, 2 and 3 is a pair.\\nhowever, for square number, for example 9, 3 will pair by itself, or we could say, 3 does not have a partener to build a pair.\\n\\nso, only lights at square numbers position will be on at the end.\\n\\nso, if we have 10 lights, at the end, only 1,4,9 light will be on.\\n\\n\\nand how to count them? by sqrt(10), we could get 3, which is the number of square numbers smaller than 10\\n\\n\\n\\n"
                    },
                    {
                        "username": "warrenbrodsky",
                        "content": "To begin, let\\'s forget keeping track of *every*  bulb and only think about *one*. Clearly, this bulb can either be on or off.  While obvious, this is still significant. If we know how many times we toggled the bulb, we can figure out which state it is in: If we have a bulb that begins on and we toggle it once, it will be off. Twice, on again. Thrice, off, four times on, five off, six on, etc. OK, so the answer is parity -- even flips it\\'s on, odd it\\'s off. \\n\\nGreat, but we don\\'t flip every bulb on every iteration, so how do we know how many times we flipped it? Ok, well on the first pass, we flip every other bulb, that is, every bulb whose index is a multiple of 2 (assuming indexing starts from 1 ;) ). On the next, we toggle every multiple of 3. On the next, multiples of 4, etc. When we\\'re done, we\\'ll have flipped every bulb once for each number that it is a multiple of, which is to say, once for each *divisor*. (Importantly, we include itself, but not 1.) For example, bulb 6 is flipped off for 2, on for 3, and off one final time for 6. Another important fact is that divisors come in pairs -- it and the thing it has to be multiplied with to get the number. The ***only*** time this isn\\'t true is if the thing it is multiplied by is itself. In other words, it\\'s a perfect square. Therefore perfect squares will *always* have an *odd* number of divisors and all others have *even* numbers of divisors. Since we\\'re not including one as a divisor, the parity flips and therefore, when all is said and done, only bulbs with perfect square indices will remain on.\\n\\nBulk of the work done -- now we just need to know how many perfect squares there are from 1 to n (which I will call squaresLTE(n)) and that will be our answer. This is fairly simple: beginning with n=1 and squaresLTE(1) = 1, we can see squaresLTE(2) is still 1,  squaresLTE(3) is still 1, and we finally get another square when n=4 and squaresLTE(4)=2 -- 1, and 4. We don\\'t add another square to the list until n=the next square. This gives us the final answer:\\n\\n`bulbs(n) = squaresLTE(n) = floor(sqrt(n))`\\n\\nThis works because if we\\'re between two squares a=s^2 and b=(s+1)^2, sqrt(n) will be some number between s and s+1, so floor(sqrt(n)) will bring us down to the sqrt of the last square we added to the list"
                    },
                    {
                        "username": "dilipK",
                        "content": "* If a particular number n is divisible by k , it means it will also  be divisible by n/k. So it will bring it to original state i.e.off. So toggling at kth iteration will turn ON but toggling at (n/k)th iteration will bring it to OFF. So no change.\\n* But for a prefect square sqrt(n) will only toggle it once , so it will be overall ON."
                    },
                    {
                        "username": "suhane",
                        "content": "# Logic : 1st round Bulb is ON, then each switch will OFF then ON. so for any number ->\\n# 1st round : ON\\n# 2nd round : OFF\\n# 3rd round : ON \\n# 4th round : OFF  and so on ....\\n# \\n# **If we can calculate how many times each bulb is switched we can tell it was ON/OFF at the last.**\\n# \\n# from above we can see if we switch bulb EVEN times we get it OFF at last, if switch ODD times we get it ON at the last.**\\n\\n*Now take few examples to understand better-*\\nN=1 -> bulb switched 1 time (for N=1)  \\t\\t\\t-> OFF at last\\n\\nN=2 -> bulb switched 2 times (for N=1, 2) \\t\\t-> OFF at last\\n\\nN=3 -> bulb switched 2 times (for N=1, 3) \\t\\t-> OFF at last\\n\\nN=4 -> bulb switched 3 times (for N=1, 2, 4) \\t-> **ON** at last\\n\\nN=5 -> bulb switched 2 times (for N=1, 5) \\t\\t-> OFF at last\\n\\nN=6 -> bulb switched 4 times (for N=1, 2, 3, 6) -> OFF at last\\n\\nN=7 -> bulb switched 2 times (for N=1, 7)\\t\\t-> OFF at last\\t\\n\\nN=8 -> bulb switched 8* times (for N=1, 2, 4, 8)\\t-> OFF at last\\t\\n(how we got 8 switches -\\nadd all switches of\\nN=1 (1 times at N=1),\\nN=2 (2 times at N=1,2), \\nN=4 (3 times at N=1,2,4) ,\\nN=8 (2 time at N=1,8))\\n\\nN=9 -> bulb switched 3 times (for N=1, 3, 9)\\t-> **ON** at last\\t\\n\\nAs you can see from above we got a conclusion only bulbs which are perfect square will be left ON at the last. (4, 9, 16, 25....) rest all bulbs will be OFF at the last.\\n\\nso we just need to fine how may perfact squares are present for any given N.\\nif N=20 -> 2, 4, 9, 16 (total 4)\\nif N=30 -> 2, 4, 9, 16, 25 (total 5)\\n\\nso we can convert calculating how many perfact sqs to -> simple solution\\n\\n# Ans: round(sqrt(N));\\n\\nBut this 1 line solution we can\\'t find until we know the whole logic that takes long time.\\n\\nHappy Learning !!\\n\\n"
                    }
                ]
            },
            {
                "id": 1566361,
                "content": [
                    {
                        "username": "rexthk",
                        "content": "Below are my step by step thought process. Hope it helps\\n\\nObservation #1:\\nA bulb is ON if it is toggled **odd** times: (ON), (ON -> OFF -> ON), (ON -> OFF -> ON -> OFF -> ON) ...\\nA bulb is OFF if it is toggled **even** times: (ON -> OFF), (ON -> OFF -> ON -> OFF ) ...\\n\\nObservation #2:\\nOnce we reach and toggle the ***i-th*** bulb, it will never be touched anymore.\\n\\nfor exmaple, let n = 5 ( changes in each round denoted as bold ), initial state is all OFF:\\n1-th round :   **ON,  ON,  ON,  ON, ON**\\n2-nd round:   ON, **OFF**,  ON, **OFF**, ON\\n3-rd round :   ON, OFF, **OFF**, OFF, ON\\n4-th round :   ON, OFF, OFF, **ON**, ON\\n5-th round :   ON, OFF, OFF, ON, **OFF**\\n\\nYou can see that, after each round, all bulbs before that round will not be touched anymore.\\n\\nSo, given a bulb at position X, how do I know it will be toggled EVEN/ODD times ?\\nAnswer: We can find the number of divisors of X. \\n\\nfor example, if the position of a bulb is 3, its divisor is [1,3], that mean we will toggle the 3-rd bulb at 1-st round and 3-rd round:\\nCombine the observation above, \\nat ***3-rd*** round, the third bulb will have been toggeld even times ( [1,3] ), so it is OFF. And it will not be changed later on round.\\nat ***5-th*** round, the fifth bulb will have been toggled even times ( [1,5] ), so it is OFF. And it will not be changed later on round.\\n\\nSuppose we have a func to get all divisors of i : **getDivisors(int)**, a simple algorithm can be deduced:\\n`for i = 1..n, if getDivisors(i) % 2 == 1, count++;`\\nWe loop through all positions, if it has odd number of divisors, it is ON and hence count + 1.\\n\\nUnfortunately, it will timeout. How to optimize ?\\n\\nObservation #3:\\nDivisors always come in pair. For example:\\n1: [1,1]  ---  2: [1,2] --- 3: [1,3] --- 4: [1,4] [2,2] --- 5:[1,5] --- 6:[1,6][2,3] --- 7:[1,7] \\n8: [1,8][2,4] --- 9:[1,9][3,3]\\n\\nIn above examples, we know that: \\nOnly when ***i*** has **perfect square root**, its number of divisors is ODD, because it contains duplicated divisor. In above example,\\n4: [1,2,4] --- 9: [1,3,9]\\nYou can pick any number to examine yourself.\\n\\nHere comes a better algorithm:\\n`for i = 1...n,  if i^2 <= n, count++ ; if i^2 > n, break;`\\nWe loop through all position, if **i^2** is <= n, that means there exists a valid bulb which has perfect square root ***i***, and we need to count that **i^2**, so count + 1. If the **i^2** exceed n, we can terminate it because we have found all ***i*** with perfect square root within n already.\\n\\nMany of you might have seen the answer, so why the answer can be simply written as Math.sqrt(n) ?\\nconsider n = 9, the process of aforementioned algorithm will be: \\ncheck (1 * 1 ) <= 9, count++\\ncheck (2 * 2 ) <= 9, count++;\\ncheck (3 * 3) <= 9, count++;\\ncheck (4 * 4) > 9, break;\\n\\nWe can say, if square root of 9 is 3, that mean **1^2** and **2^2** must exists for n = 9. Hence, the Math.sqrt(i) reflect this fact.\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "I got to observation 2 on my own. The condition for an odd number of divisors was eluding me, thanks for the help"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "mind glowing explanation\\n"
                    },
                    {
                        "username": "saidfgn",
                        "content": "Great explanation, thanks!"
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "**Its more like a puzzle rather than a coding problem**"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "[@yusufm09](/yusufm09) brain tester problem means does they ask this in interviews"
                    },
                    {
                        "username": "yusufm09",
                        "content": "[@jerryy147](/jerryy147) I never knew that there was a brainteaser problem list. Thanks."
                    },
                    {
                        "username": "jerryy147",
                        "content": "that\\'s why it\\'s in the \"brainteaser\" problem list"
                    },
                    {
                        "username": "strongwillow",
                        "content": "It only stated the first, second, third, and last round. Should be updated as follows:\\n\\nThere are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). **For the ith round, you toggle every i bulb.** For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds."
                    },
                    {
                        "username": "sx1w",
                        "content": "Like many of you are wondering why a simple sqaure root solution to the problem, I wanted to find out why that is correct. Here is my little research into it. \\n\\nThe light bulb at postion k must be toggled in odd number to stay on, e.g. \\'On, Off, On\\' including the initial toggle. What triggers k-th bulb be toggled? Number k must be an **exact** multiple of each toggling. For example, when k=4, the bulb will be triggered by the 1st (On), 2nd (Off) and 4th (On) operation. What is the exact number of multiple of a nature number k? **All of its factors** ! \\n\\nSo the k-th bulb \\'ON\\' is corresponding to the number of factors of k being odd. You can certainly develop a program to count. However, the [*number math*](http://mathcentral.uregina.ca/QQ/database/QQ.09.06/jacqueline1.html) tells us only perfect square numbers have odd number of factors, which is what needed for the bulb to stay on. \\n\\nGreat! Now to solve the problem is to find out how many perfect square number between 1 and n. The [*math*](https://www.quora.com/How-many-perfect-squares-are-there-between-1-to-1000) kicks in again, and that number is the square root of n (more preceisly the floor of sqaure root of n). \\n\\nWhat a great problem!"
                    },
                    {
                        "username": "bharathb",
                        "content": "A lot of other posts provide code / suggest a simulation to see the pattern. I will attempt to describe the intuition behind the solution. \\n\\n* First let s identify all the bulbs that can touch/affect/toggle bulb X. Bulb X can only be toggled by other bulbs which are less than or equal to X. For example, 26 will never toggle bulb 23.\\n* Secondly, for a bulb X what are the bulbs that can toggle X? 23 can never toggle 25. We notice that a bulb X can only be toggled by divisors of X - including 1 and X itself. \\n* Now let s consider prime numbers. Prime numbers by definition have exactly two divisors. Any number with 2 divisors will never be ON at the end - because 1 will set it to ON and the second divisor (the prime number itself) will toggle it off.\\n* With prime numbers gone, lets consider a composite number with an even number of divisors.  Say 24. The divisors of 24 are (1,2,3,4,6,8,12,24). Listing the divisors as pairs - (1, 24) (2,12), (3,8), (4,6) - pairs are crucial because one divisor will set 24 to ON and the other divisor will set it to OFF. So, the net result is that those bulbs will NOT be ON at the end of the simulation - because they are initially OFF. They are toggled an even number of times.\\n* Now, we need to find numbers <=N which have an odd number of divisors. This might not be intuitive immediately and this simulating the problem on paper helps. If we consider a perfect square like 36 and write the divisors in pairs - (1,36), (2,18), (3, 12), (4, 9), (6,6). Now, we can see that while all other divisors cancel each other out - (they toggle the bulb twice) - 6 has no counterpart to toggle the bulb off. So, when there are 36 bulbs, 6 will always be ON at the end. The same holds true for perfect squares less than N - which are 1,4,9,16,25.\\n* Based on the above inferences, we can see that we need to find the numbers less than N that are perfect squares.  We can calculate this (int) Math.sqrt(N) or have a simple for-loop to count (i*i) <=N \\n\\nHope this helps."
                    },
                    {
                        "username": "rajeshkumar1130",
                        "content": "I was asked this question in an interview with microsoft on 22-01-2021"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It just proves that an ordinary position at MS is a dead-end job."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@sandagolcea](/sandagolcea)  Nice solution bro! The code is also quite neat. Good job!"
                    },
                    {
                        "username": "algoacer",
                        "content": "[@code_coffeee](/code_coffeee) Acutally it is so true, some one gets to implement a plain algorithm and someone has to think out of the box in 40 minutes. Not fair. But we should keep applying at multiple companies."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@code_coffeee](/code_coffeee) do you mean a TLE? I've actually solved it differently, using rather simple mathematics, but not sqrt (which i know was quite obvs, but I thought of doing smth else :D ) here https://leetcode.com/problems/bulb-switcher/solutions/3461670/js-solutions-without-using-sqrt/ "
                    },
                    {
                        "username": "l3aonti",
                        "content": "[@dvijay96](/dvijay96) it throws memory limit exception "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@code_coffeee](/code_coffeee) Brute force n^2 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "they what happened bro how did you explain "
                    },
                    {
                        "username": "code_coffeee",
                        "content": "This makes me sad.\\n\\nI feel like if they ask anyone this, they must not want to hire this person. If anyone codes it in any way without using square root, it is  a rejection."
                    },
                    {
                        "username": "bingzhoudaren",
                        "content": "First, we need to figure out how do we know if the ith light is on or off at the end. \\nit dpends on how many numbers could output i after you get product of them.\\nfor example 6, \\nwe will toggle the 6th light in the first round becasue 1 times6=6\\nwe will toggle the 6th light in the second round because 2 times 3=6;\\nwe will toggle the 6th light in third round beacuse 3 times 2 =6;\\nand we will toggle the 6th light in 6th round beacuse 6 times 1=6;\\n\\nso since wil have 1,2,3,6,totally four numbers, we will toggle the 6th light 4 times.\\nand since 4 is even ,so the 6th light will be off at the end.\\n\\nand for example, 9 could have division 1,3,9,  there are three of them. which is odd, so the 9th light is on at the end.\\n\\n\\nthen the problem is to figure out which number have odd divisions, which have even.\\n\\nthen, we should realize that,  for no-square number, the divisions can be paired.\\n\\nfor example, for 6, 1,and 6 is a pair, 2 and 3 is a pair.\\nhowever, for square number, for example 9, 3 will pair by itself, or we could say, 3 does not have a partener to build a pair.\\n\\nso, only lights at square numbers position will be on at the end.\\n\\nso, if we have 10 lights, at the end, only 1,4,9 light will be on.\\n\\n\\nand how to count them? by sqrt(10), we could get 3, which is the number of square numbers smaller than 10\\n\\n\\n\\n"
                    },
                    {
                        "username": "warrenbrodsky",
                        "content": "To begin, let\\'s forget keeping track of *every*  bulb and only think about *one*. Clearly, this bulb can either be on or off.  While obvious, this is still significant. If we know how many times we toggled the bulb, we can figure out which state it is in: If we have a bulb that begins on and we toggle it once, it will be off. Twice, on again. Thrice, off, four times on, five off, six on, etc. OK, so the answer is parity -- even flips it\\'s on, odd it\\'s off. \\n\\nGreat, but we don\\'t flip every bulb on every iteration, so how do we know how many times we flipped it? Ok, well on the first pass, we flip every other bulb, that is, every bulb whose index is a multiple of 2 (assuming indexing starts from 1 ;) ). On the next, we toggle every multiple of 3. On the next, multiples of 4, etc. When we\\'re done, we\\'ll have flipped every bulb once for each number that it is a multiple of, which is to say, once for each *divisor*. (Importantly, we include itself, but not 1.) For example, bulb 6 is flipped off for 2, on for 3, and off one final time for 6. Another important fact is that divisors come in pairs -- it and the thing it has to be multiplied with to get the number. The ***only*** time this isn\\'t true is if the thing it is multiplied by is itself. In other words, it\\'s a perfect square. Therefore perfect squares will *always* have an *odd* number of divisors and all others have *even* numbers of divisors. Since we\\'re not including one as a divisor, the parity flips and therefore, when all is said and done, only bulbs with perfect square indices will remain on.\\n\\nBulk of the work done -- now we just need to know how many perfect squares there are from 1 to n (which I will call squaresLTE(n)) and that will be our answer. This is fairly simple: beginning with n=1 and squaresLTE(1) = 1, we can see squaresLTE(2) is still 1,  squaresLTE(3) is still 1, and we finally get another square when n=4 and squaresLTE(4)=2 -- 1, and 4. We don\\'t add another square to the list until n=the next square. This gives us the final answer:\\n\\n`bulbs(n) = squaresLTE(n) = floor(sqrt(n))`\\n\\nThis works because if we\\'re between two squares a=s^2 and b=(s+1)^2, sqrt(n) will be some number between s and s+1, so floor(sqrt(n)) will bring us down to the sqrt of the last square we added to the list"
                    },
                    {
                        "username": "dilipK",
                        "content": "* If a particular number n is divisible by k , it means it will also  be divisible by n/k. So it will bring it to original state i.e.off. So toggling at kth iteration will turn ON but toggling at (n/k)th iteration will bring it to OFF. So no change.\\n* But for a prefect square sqrt(n) will only toggle it once , so it will be overall ON."
                    },
                    {
                        "username": "suhane",
                        "content": "# Logic : 1st round Bulb is ON, then each switch will OFF then ON. so for any number ->\\n# 1st round : ON\\n# 2nd round : OFF\\n# 3rd round : ON \\n# 4th round : OFF  and so on ....\\n# \\n# **If we can calculate how many times each bulb is switched we can tell it was ON/OFF at the last.**\\n# \\n# from above we can see if we switch bulb EVEN times we get it OFF at last, if switch ODD times we get it ON at the last.**\\n\\n*Now take few examples to understand better-*\\nN=1 -> bulb switched 1 time (for N=1)  \\t\\t\\t-> OFF at last\\n\\nN=2 -> bulb switched 2 times (for N=1, 2) \\t\\t-> OFF at last\\n\\nN=3 -> bulb switched 2 times (for N=1, 3) \\t\\t-> OFF at last\\n\\nN=4 -> bulb switched 3 times (for N=1, 2, 4) \\t-> **ON** at last\\n\\nN=5 -> bulb switched 2 times (for N=1, 5) \\t\\t-> OFF at last\\n\\nN=6 -> bulb switched 4 times (for N=1, 2, 3, 6) -> OFF at last\\n\\nN=7 -> bulb switched 2 times (for N=1, 7)\\t\\t-> OFF at last\\t\\n\\nN=8 -> bulb switched 8* times (for N=1, 2, 4, 8)\\t-> OFF at last\\t\\n(how we got 8 switches -\\nadd all switches of\\nN=1 (1 times at N=1),\\nN=2 (2 times at N=1,2), \\nN=4 (3 times at N=1,2,4) ,\\nN=8 (2 time at N=1,8))\\n\\nN=9 -> bulb switched 3 times (for N=1, 3, 9)\\t-> **ON** at last\\t\\n\\nAs you can see from above we got a conclusion only bulbs which are perfect square will be left ON at the last. (4, 9, 16, 25....) rest all bulbs will be OFF at the last.\\n\\nso we just need to fine how may perfact squares are present for any given N.\\nif N=20 -> 2, 4, 9, 16 (total 4)\\nif N=30 -> 2, 4, 9, 16, 25 (total 5)\\n\\nso we can convert calculating how many perfact sqs to -> simple solution\\n\\n# Ans: round(sqrt(N));\\n\\nBut this 1 line solution we can\\'t find until we know the whole logic that takes long time.\\n\\nHappy Learning !!\\n\\n"
                    }
                ]
            },
            {
                "id": 1567066,
                "content": [
                    {
                        "username": "rexthk",
                        "content": "Below are my step by step thought process. Hope it helps\\n\\nObservation #1:\\nA bulb is ON if it is toggled **odd** times: (ON), (ON -> OFF -> ON), (ON -> OFF -> ON -> OFF -> ON) ...\\nA bulb is OFF if it is toggled **even** times: (ON -> OFF), (ON -> OFF -> ON -> OFF ) ...\\n\\nObservation #2:\\nOnce we reach and toggle the ***i-th*** bulb, it will never be touched anymore.\\n\\nfor exmaple, let n = 5 ( changes in each round denoted as bold ), initial state is all OFF:\\n1-th round :   **ON,  ON,  ON,  ON, ON**\\n2-nd round:   ON, **OFF**,  ON, **OFF**, ON\\n3-rd round :   ON, OFF, **OFF**, OFF, ON\\n4-th round :   ON, OFF, OFF, **ON**, ON\\n5-th round :   ON, OFF, OFF, ON, **OFF**\\n\\nYou can see that, after each round, all bulbs before that round will not be touched anymore.\\n\\nSo, given a bulb at position X, how do I know it will be toggled EVEN/ODD times ?\\nAnswer: We can find the number of divisors of X. \\n\\nfor example, if the position of a bulb is 3, its divisor is [1,3], that mean we will toggle the 3-rd bulb at 1-st round and 3-rd round:\\nCombine the observation above, \\nat ***3-rd*** round, the third bulb will have been toggeld even times ( [1,3] ), so it is OFF. And it will not be changed later on round.\\nat ***5-th*** round, the fifth bulb will have been toggled even times ( [1,5] ), so it is OFF. And it will not be changed later on round.\\n\\nSuppose we have a func to get all divisors of i : **getDivisors(int)**, a simple algorithm can be deduced:\\n`for i = 1..n, if getDivisors(i) % 2 == 1, count++;`\\nWe loop through all positions, if it has odd number of divisors, it is ON and hence count + 1.\\n\\nUnfortunately, it will timeout. How to optimize ?\\n\\nObservation #3:\\nDivisors always come in pair. For example:\\n1: [1,1]  ---  2: [1,2] --- 3: [1,3] --- 4: [1,4] [2,2] --- 5:[1,5] --- 6:[1,6][2,3] --- 7:[1,7] \\n8: [1,8][2,4] --- 9:[1,9][3,3]\\n\\nIn above examples, we know that: \\nOnly when ***i*** has **perfect square root**, its number of divisors is ODD, because it contains duplicated divisor. In above example,\\n4: [1,2,4] --- 9: [1,3,9]\\nYou can pick any number to examine yourself.\\n\\nHere comes a better algorithm:\\n`for i = 1...n,  if i^2 <= n, count++ ; if i^2 > n, break;`\\nWe loop through all position, if **i^2** is <= n, that means there exists a valid bulb which has perfect square root ***i***, and we need to count that **i^2**, so count + 1. If the **i^2** exceed n, we can terminate it because we have found all ***i*** with perfect square root within n already.\\n\\nMany of you might have seen the answer, so why the answer can be simply written as Math.sqrt(n) ?\\nconsider n = 9, the process of aforementioned algorithm will be: \\ncheck (1 * 1 ) <= 9, count++\\ncheck (2 * 2 ) <= 9, count++;\\ncheck (3 * 3) <= 9, count++;\\ncheck (4 * 4) > 9, break;\\n\\nWe can say, if square root of 9 is 3, that mean **1^2** and **2^2** must exists for n = 9. Hence, the Math.sqrt(i) reflect this fact.\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "I got to observation 2 on my own. The condition for an odd number of divisors was eluding me, thanks for the help"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "mind glowing explanation\\n"
                    },
                    {
                        "username": "saidfgn",
                        "content": "Great explanation, thanks!"
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "**Its more like a puzzle rather than a coding problem**"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "[@yusufm09](/yusufm09) brain tester problem means does they ask this in interviews"
                    },
                    {
                        "username": "yusufm09",
                        "content": "[@jerryy147](/jerryy147) I never knew that there was a brainteaser problem list. Thanks."
                    },
                    {
                        "username": "jerryy147",
                        "content": "that\\'s why it\\'s in the \"brainteaser\" problem list"
                    },
                    {
                        "username": "strongwillow",
                        "content": "It only stated the first, second, third, and last round. Should be updated as follows:\\n\\nThere are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). **For the ith round, you toggle every i bulb.** For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds."
                    },
                    {
                        "username": "sx1w",
                        "content": "Like many of you are wondering why a simple sqaure root solution to the problem, I wanted to find out why that is correct. Here is my little research into it. \\n\\nThe light bulb at postion k must be toggled in odd number to stay on, e.g. \\'On, Off, On\\' including the initial toggle. What triggers k-th bulb be toggled? Number k must be an **exact** multiple of each toggling. For example, when k=4, the bulb will be triggered by the 1st (On), 2nd (Off) and 4th (On) operation. What is the exact number of multiple of a nature number k? **All of its factors** ! \\n\\nSo the k-th bulb \\'ON\\' is corresponding to the number of factors of k being odd. You can certainly develop a program to count. However, the [*number math*](http://mathcentral.uregina.ca/QQ/database/QQ.09.06/jacqueline1.html) tells us only perfect square numbers have odd number of factors, which is what needed for the bulb to stay on. \\n\\nGreat! Now to solve the problem is to find out how many perfect square number between 1 and n. The [*math*](https://www.quora.com/How-many-perfect-squares-are-there-between-1-to-1000) kicks in again, and that number is the square root of n (more preceisly the floor of sqaure root of n). \\n\\nWhat a great problem!"
                    },
                    {
                        "username": "bharathb",
                        "content": "A lot of other posts provide code / suggest a simulation to see the pattern. I will attempt to describe the intuition behind the solution. \\n\\n* First let s identify all the bulbs that can touch/affect/toggle bulb X. Bulb X can only be toggled by other bulbs which are less than or equal to X. For example, 26 will never toggle bulb 23.\\n* Secondly, for a bulb X what are the bulbs that can toggle X? 23 can never toggle 25. We notice that a bulb X can only be toggled by divisors of X - including 1 and X itself. \\n* Now let s consider prime numbers. Prime numbers by definition have exactly two divisors. Any number with 2 divisors will never be ON at the end - because 1 will set it to ON and the second divisor (the prime number itself) will toggle it off.\\n* With prime numbers gone, lets consider a composite number with an even number of divisors.  Say 24. The divisors of 24 are (1,2,3,4,6,8,12,24). Listing the divisors as pairs - (1, 24) (2,12), (3,8), (4,6) - pairs are crucial because one divisor will set 24 to ON and the other divisor will set it to OFF. So, the net result is that those bulbs will NOT be ON at the end of the simulation - because they are initially OFF. They are toggled an even number of times.\\n* Now, we need to find numbers <=N which have an odd number of divisors. This might not be intuitive immediately and this simulating the problem on paper helps. If we consider a perfect square like 36 and write the divisors in pairs - (1,36), (2,18), (3, 12), (4, 9), (6,6). Now, we can see that while all other divisors cancel each other out - (they toggle the bulb twice) - 6 has no counterpart to toggle the bulb off. So, when there are 36 bulbs, 6 will always be ON at the end. The same holds true for perfect squares less than N - which are 1,4,9,16,25.\\n* Based on the above inferences, we can see that we need to find the numbers less than N that are perfect squares.  We can calculate this (int) Math.sqrt(N) or have a simple for-loop to count (i*i) <=N \\n\\nHope this helps."
                    },
                    {
                        "username": "rajeshkumar1130",
                        "content": "I was asked this question in an interview with microsoft on 22-01-2021"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It just proves that an ordinary position at MS is a dead-end job."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@sandagolcea](/sandagolcea)  Nice solution bro! The code is also quite neat. Good job!"
                    },
                    {
                        "username": "algoacer",
                        "content": "[@code_coffeee](/code_coffeee) Acutally it is so true, some one gets to implement a plain algorithm and someone has to think out of the box in 40 minutes. Not fair. But we should keep applying at multiple companies."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@code_coffeee](/code_coffeee) do you mean a TLE? I've actually solved it differently, using rather simple mathematics, but not sqrt (which i know was quite obvs, but I thought of doing smth else :D ) here https://leetcode.com/problems/bulb-switcher/solutions/3461670/js-solutions-without-using-sqrt/ "
                    },
                    {
                        "username": "l3aonti",
                        "content": "[@dvijay96](/dvijay96) it throws memory limit exception "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@code_coffeee](/code_coffeee) Brute force n^2 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "they what happened bro how did you explain "
                    },
                    {
                        "username": "code_coffeee",
                        "content": "This makes me sad.\\n\\nI feel like if they ask anyone this, they must not want to hire this person. If anyone codes it in any way without using square root, it is  a rejection."
                    },
                    {
                        "username": "bingzhoudaren",
                        "content": "First, we need to figure out how do we know if the ith light is on or off at the end. \\nit dpends on how many numbers could output i after you get product of them.\\nfor example 6, \\nwe will toggle the 6th light in the first round becasue 1 times6=6\\nwe will toggle the 6th light in the second round because 2 times 3=6;\\nwe will toggle the 6th light in third round beacuse 3 times 2 =6;\\nand we will toggle the 6th light in 6th round beacuse 6 times 1=6;\\n\\nso since wil have 1,2,3,6,totally four numbers, we will toggle the 6th light 4 times.\\nand since 4 is even ,so the 6th light will be off at the end.\\n\\nand for example, 9 could have division 1,3,9,  there are three of them. which is odd, so the 9th light is on at the end.\\n\\n\\nthen the problem is to figure out which number have odd divisions, which have even.\\n\\nthen, we should realize that,  for no-square number, the divisions can be paired.\\n\\nfor example, for 6, 1,and 6 is a pair, 2 and 3 is a pair.\\nhowever, for square number, for example 9, 3 will pair by itself, or we could say, 3 does not have a partener to build a pair.\\n\\nso, only lights at square numbers position will be on at the end.\\n\\nso, if we have 10 lights, at the end, only 1,4,9 light will be on.\\n\\n\\nand how to count them? by sqrt(10), we could get 3, which is the number of square numbers smaller than 10\\n\\n\\n\\n"
                    },
                    {
                        "username": "warrenbrodsky",
                        "content": "To begin, let\\'s forget keeping track of *every*  bulb and only think about *one*. Clearly, this bulb can either be on or off.  While obvious, this is still significant. If we know how many times we toggled the bulb, we can figure out which state it is in: If we have a bulb that begins on and we toggle it once, it will be off. Twice, on again. Thrice, off, four times on, five off, six on, etc. OK, so the answer is parity -- even flips it\\'s on, odd it\\'s off. \\n\\nGreat, but we don\\'t flip every bulb on every iteration, so how do we know how many times we flipped it? Ok, well on the first pass, we flip every other bulb, that is, every bulb whose index is a multiple of 2 (assuming indexing starts from 1 ;) ). On the next, we toggle every multiple of 3. On the next, multiples of 4, etc. When we\\'re done, we\\'ll have flipped every bulb once for each number that it is a multiple of, which is to say, once for each *divisor*. (Importantly, we include itself, but not 1.) For example, bulb 6 is flipped off for 2, on for 3, and off one final time for 6. Another important fact is that divisors come in pairs -- it and the thing it has to be multiplied with to get the number. The ***only*** time this isn\\'t true is if the thing it is multiplied by is itself. In other words, it\\'s a perfect square. Therefore perfect squares will *always* have an *odd* number of divisors and all others have *even* numbers of divisors. Since we\\'re not including one as a divisor, the parity flips and therefore, when all is said and done, only bulbs with perfect square indices will remain on.\\n\\nBulk of the work done -- now we just need to know how many perfect squares there are from 1 to n (which I will call squaresLTE(n)) and that will be our answer. This is fairly simple: beginning with n=1 and squaresLTE(1) = 1, we can see squaresLTE(2) is still 1,  squaresLTE(3) is still 1, and we finally get another square when n=4 and squaresLTE(4)=2 -- 1, and 4. We don\\'t add another square to the list until n=the next square. This gives us the final answer:\\n\\n`bulbs(n) = squaresLTE(n) = floor(sqrt(n))`\\n\\nThis works because if we\\'re between two squares a=s^2 and b=(s+1)^2, sqrt(n) will be some number between s and s+1, so floor(sqrt(n)) will bring us down to the sqrt of the last square we added to the list"
                    },
                    {
                        "username": "dilipK",
                        "content": "* If a particular number n is divisible by k , it means it will also  be divisible by n/k. So it will bring it to original state i.e.off. So toggling at kth iteration will turn ON but toggling at (n/k)th iteration will bring it to OFF. So no change.\\n* But for a prefect square sqrt(n) will only toggle it once , so it will be overall ON."
                    },
                    {
                        "username": "suhane",
                        "content": "# Logic : 1st round Bulb is ON, then each switch will OFF then ON. so for any number ->\\n# 1st round : ON\\n# 2nd round : OFF\\n# 3rd round : ON \\n# 4th round : OFF  and so on ....\\n# \\n# **If we can calculate how many times each bulb is switched we can tell it was ON/OFF at the last.**\\n# \\n# from above we can see if we switch bulb EVEN times we get it OFF at last, if switch ODD times we get it ON at the last.**\\n\\n*Now take few examples to understand better-*\\nN=1 -> bulb switched 1 time (for N=1)  \\t\\t\\t-> OFF at last\\n\\nN=2 -> bulb switched 2 times (for N=1, 2) \\t\\t-> OFF at last\\n\\nN=3 -> bulb switched 2 times (for N=1, 3) \\t\\t-> OFF at last\\n\\nN=4 -> bulb switched 3 times (for N=1, 2, 4) \\t-> **ON** at last\\n\\nN=5 -> bulb switched 2 times (for N=1, 5) \\t\\t-> OFF at last\\n\\nN=6 -> bulb switched 4 times (for N=1, 2, 3, 6) -> OFF at last\\n\\nN=7 -> bulb switched 2 times (for N=1, 7)\\t\\t-> OFF at last\\t\\n\\nN=8 -> bulb switched 8* times (for N=1, 2, 4, 8)\\t-> OFF at last\\t\\n(how we got 8 switches -\\nadd all switches of\\nN=1 (1 times at N=1),\\nN=2 (2 times at N=1,2), \\nN=4 (3 times at N=1,2,4) ,\\nN=8 (2 time at N=1,8))\\n\\nN=9 -> bulb switched 3 times (for N=1, 3, 9)\\t-> **ON** at last\\t\\n\\nAs you can see from above we got a conclusion only bulbs which are perfect square will be left ON at the last. (4, 9, 16, 25....) rest all bulbs will be OFF at the last.\\n\\nso we just need to fine how may perfact squares are present for any given N.\\nif N=20 -> 2, 4, 9, 16 (total 4)\\nif N=30 -> 2, 4, 9, 16, 25 (total 5)\\n\\nso we can convert calculating how many perfact sqs to -> simple solution\\n\\n# Ans: round(sqrt(N));\\n\\nBut this 1 line solution we can\\'t find until we know the whole logic that takes long time.\\n\\nHappy Learning !!\\n\\n"
                    }
                ]
            },
            {
                "id": 1564812,
                "content": [
                    {
                        "username": "rexthk",
                        "content": "Below are my step by step thought process. Hope it helps\\n\\nObservation #1:\\nA bulb is ON if it is toggled **odd** times: (ON), (ON -> OFF -> ON), (ON -> OFF -> ON -> OFF -> ON) ...\\nA bulb is OFF if it is toggled **even** times: (ON -> OFF), (ON -> OFF -> ON -> OFF ) ...\\n\\nObservation #2:\\nOnce we reach and toggle the ***i-th*** bulb, it will never be touched anymore.\\n\\nfor exmaple, let n = 5 ( changes in each round denoted as bold ), initial state is all OFF:\\n1-th round :   **ON,  ON,  ON,  ON, ON**\\n2-nd round:   ON, **OFF**,  ON, **OFF**, ON\\n3-rd round :   ON, OFF, **OFF**, OFF, ON\\n4-th round :   ON, OFF, OFF, **ON**, ON\\n5-th round :   ON, OFF, OFF, ON, **OFF**\\n\\nYou can see that, after each round, all bulbs before that round will not be touched anymore.\\n\\nSo, given a bulb at position X, how do I know it will be toggled EVEN/ODD times ?\\nAnswer: We can find the number of divisors of X. \\n\\nfor example, if the position of a bulb is 3, its divisor is [1,3], that mean we will toggle the 3-rd bulb at 1-st round and 3-rd round:\\nCombine the observation above, \\nat ***3-rd*** round, the third bulb will have been toggeld even times ( [1,3] ), so it is OFF. And it will not be changed later on round.\\nat ***5-th*** round, the fifth bulb will have been toggled even times ( [1,5] ), so it is OFF. And it will not be changed later on round.\\n\\nSuppose we have a func to get all divisors of i : **getDivisors(int)**, a simple algorithm can be deduced:\\n`for i = 1..n, if getDivisors(i) % 2 == 1, count++;`\\nWe loop through all positions, if it has odd number of divisors, it is ON and hence count + 1.\\n\\nUnfortunately, it will timeout. How to optimize ?\\n\\nObservation #3:\\nDivisors always come in pair. For example:\\n1: [1,1]  ---  2: [1,2] --- 3: [1,3] --- 4: [1,4] [2,2] --- 5:[1,5] --- 6:[1,6][2,3] --- 7:[1,7] \\n8: [1,8][2,4] --- 9:[1,9][3,3]\\n\\nIn above examples, we know that: \\nOnly when ***i*** has **perfect square root**, its number of divisors is ODD, because it contains duplicated divisor. In above example,\\n4: [1,2,4] --- 9: [1,3,9]\\nYou can pick any number to examine yourself.\\n\\nHere comes a better algorithm:\\n`for i = 1...n,  if i^2 <= n, count++ ; if i^2 > n, break;`\\nWe loop through all position, if **i^2** is <= n, that means there exists a valid bulb which has perfect square root ***i***, and we need to count that **i^2**, so count + 1. If the **i^2** exceed n, we can terminate it because we have found all ***i*** with perfect square root within n already.\\n\\nMany of you might have seen the answer, so why the answer can be simply written as Math.sqrt(n) ?\\nconsider n = 9, the process of aforementioned algorithm will be: \\ncheck (1 * 1 ) <= 9, count++\\ncheck (2 * 2 ) <= 9, count++;\\ncheck (3 * 3) <= 9, count++;\\ncheck (4 * 4) > 9, break;\\n\\nWe can say, if square root of 9 is 3, that mean **1^2** and **2^2** must exists for n = 9. Hence, the Math.sqrt(i) reflect this fact.\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "I got to observation 2 on my own. The condition for an odd number of divisors was eluding me, thanks for the help"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "mind glowing explanation\\n"
                    },
                    {
                        "username": "saidfgn",
                        "content": "Great explanation, thanks!"
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "**Its more like a puzzle rather than a coding problem**"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "[@yusufm09](/yusufm09) brain tester problem means does they ask this in interviews"
                    },
                    {
                        "username": "yusufm09",
                        "content": "[@jerryy147](/jerryy147) I never knew that there was a brainteaser problem list. Thanks."
                    },
                    {
                        "username": "jerryy147",
                        "content": "that\\'s why it\\'s in the \"brainteaser\" problem list"
                    },
                    {
                        "username": "strongwillow",
                        "content": "It only stated the first, second, third, and last round. Should be updated as follows:\\n\\nThere are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). **For the ith round, you toggle every i bulb.** For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds."
                    },
                    {
                        "username": "sx1w",
                        "content": "Like many of you are wondering why a simple sqaure root solution to the problem, I wanted to find out why that is correct. Here is my little research into it. \\n\\nThe light bulb at postion k must be toggled in odd number to stay on, e.g. \\'On, Off, On\\' including the initial toggle. What triggers k-th bulb be toggled? Number k must be an **exact** multiple of each toggling. For example, when k=4, the bulb will be triggered by the 1st (On), 2nd (Off) and 4th (On) operation. What is the exact number of multiple of a nature number k? **All of its factors** ! \\n\\nSo the k-th bulb \\'ON\\' is corresponding to the number of factors of k being odd. You can certainly develop a program to count. However, the [*number math*](http://mathcentral.uregina.ca/QQ/database/QQ.09.06/jacqueline1.html) tells us only perfect square numbers have odd number of factors, which is what needed for the bulb to stay on. \\n\\nGreat! Now to solve the problem is to find out how many perfect square number between 1 and n. The [*math*](https://www.quora.com/How-many-perfect-squares-are-there-between-1-to-1000) kicks in again, and that number is the square root of n (more preceisly the floor of sqaure root of n). \\n\\nWhat a great problem!"
                    },
                    {
                        "username": "bharathb",
                        "content": "A lot of other posts provide code / suggest a simulation to see the pattern. I will attempt to describe the intuition behind the solution. \\n\\n* First let s identify all the bulbs that can touch/affect/toggle bulb X. Bulb X can only be toggled by other bulbs which are less than or equal to X. For example, 26 will never toggle bulb 23.\\n* Secondly, for a bulb X what are the bulbs that can toggle X? 23 can never toggle 25. We notice that a bulb X can only be toggled by divisors of X - including 1 and X itself. \\n* Now let s consider prime numbers. Prime numbers by definition have exactly two divisors. Any number with 2 divisors will never be ON at the end - because 1 will set it to ON and the second divisor (the prime number itself) will toggle it off.\\n* With prime numbers gone, lets consider a composite number with an even number of divisors.  Say 24. The divisors of 24 are (1,2,3,4,6,8,12,24). Listing the divisors as pairs - (1, 24) (2,12), (3,8), (4,6) - pairs are crucial because one divisor will set 24 to ON and the other divisor will set it to OFF. So, the net result is that those bulbs will NOT be ON at the end of the simulation - because they are initially OFF. They are toggled an even number of times.\\n* Now, we need to find numbers <=N which have an odd number of divisors. This might not be intuitive immediately and this simulating the problem on paper helps. If we consider a perfect square like 36 and write the divisors in pairs - (1,36), (2,18), (3, 12), (4, 9), (6,6). Now, we can see that while all other divisors cancel each other out - (they toggle the bulb twice) - 6 has no counterpart to toggle the bulb off. So, when there are 36 bulbs, 6 will always be ON at the end. The same holds true for perfect squares less than N - which are 1,4,9,16,25.\\n* Based on the above inferences, we can see that we need to find the numbers less than N that are perfect squares.  We can calculate this (int) Math.sqrt(N) or have a simple for-loop to count (i*i) <=N \\n\\nHope this helps."
                    },
                    {
                        "username": "rajeshkumar1130",
                        "content": "I was asked this question in an interview with microsoft on 22-01-2021"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It just proves that an ordinary position at MS is a dead-end job."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@sandagolcea](/sandagolcea)  Nice solution bro! The code is also quite neat. Good job!"
                    },
                    {
                        "username": "algoacer",
                        "content": "[@code_coffeee](/code_coffeee) Acutally it is so true, some one gets to implement a plain algorithm and someone has to think out of the box in 40 minutes. Not fair. But we should keep applying at multiple companies."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@code_coffeee](/code_coffeee) do you mean a TLE? I've actually solved it differently, using rather simple mathematics, but not sqrt (which i know was quite obvs, but I thought of doing smth else :D ) here https://leetcode.com/problems/bulb-switcher/solutions/3461670/js-solutions-without-using-sqrt/ "
                    },
                    {
                        "username": "l3aonti",
                        "content": "[@dvijay96](/dvijay96) it throws memory limit exception "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@code_coffeee](/code_coffeee) Brute force n^2 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "they what happened bro how did you explain "
                    },
                    {
                        "username": "code_coffeee",
                        "content": "This makes me sad.\\n\\nI feel like if they ask anyone this, they must not want to hire this person. If anyone codes it in any way without using square root, it is  a rejection."
                    },
                    {
                        "username": "bingzhoudaren",
                        "content": "First, we need to figure out how do we know if the ith light is on or off at the end. \\nit dpends on how many numbers could output i after you get product of them.\\nfor example 6, \\nwe will toggle the 6th light in the first round becasue 1 times6=6\\nwe will toggle the 6th light in the second round because 2 times 3=6;\\nwe will toggle the 6th light in third round beacuse 3 times 2 =6;\\nand we will toggle the 6th light in 6th round beacuse 6 times 1=6;\\n\\nso since wil have 1,2,3,6,totally four numbers, we will toggle the 6th light 4 times.\\nand since 4 is even ,so the 6th light will be off at the end.\\n\\nand for example, 9 could have division 1,3,9,  there are three of them. which is odd, so the 9th light is on at the end.\\n\\n\\nthen the problem is to figure out which number have odd divisions, which have even.\\n\\nthen, we should realize that,  for no-square number, the divisions can be paired.\\n\\nfor example, for 6, 1,and 6 is a pair, 2 and 3 is a pair.\\nhowever, for square number, for example 9, 3 will pair by itself, or we could say, 3 does not have a partener to build a pair.\\n\\nso, only lights at square numbers position will be on at the end.\\n\\nso, if we have 10 lights, at the end, only 1,4,9 light will be on.\\n\\n\\nand how to count them? by sqrt(10), we could get 3, which is the number of square numbers smaller than 10\\n\\n\\n\\n"
                    },
                    {
                        "username": "warrenbrodsky",
                        "content": "To begin, let\\'s forget keeping track of *every*  bulb and only think about *one*. Clearly, this bulb can either be on or off.  While obvious, this is still significant. If we know how many times we toggled the bulb, we can figure out which state it is in: If we have a bulb that begins on and we toggle it once, it will be off. Twice, on again. Thrice, off, four times on, five off, six on, etc. OK, so the answer is parity -- even flips it\\'s on, odd it\\'s off. \\n\\nGreat, but we don\\'t flip every bulb on every iteration, so how do we know how many times we flipped it? Ok, well on the first pass, we flip every other bulb, that is, every bulb whose index is a multiple of 2 (assuming indexing starts from 1 ;) ). On the next, we toggle every multiple of 3. On the next, multiples of 4, etc. When we\\'re done, we\\'ll have flipped every bulb once for each number that it is a multiple of, which is to say, once for each *divisor*. (Importantly, we include itself, but not 1.) For example, bulb 6 is flipped off for 2, on for 3, and off one final time for 6. Another important fact is that divisors come in pairs -- it and the thing it has to be multiplied with to get the number. The ***only*** time this isn\\'t true is if the thing it is multiplied by is itself. In other words, it\\'s a perfect square. Therefore perfect squares will *always* have an *odd* number of divisors and all others have *even* numbers of divisors. Since we\\'re not including one as a divisor, the parity flips and therefore, when all is said and done, only bulbs with perfect square indices will remain on.\\n\\nBulk of the work done -- now we just need to know how many perfect squares there are from 1 to n (which I will call squaresLTE(n)) and that will be our answer. This is fairly simple: beginning with n=1 and squaresLTE(1) = 1, we can see squaresLTE(2) is still 1,  squaresLTE(3) is still 1, and we finally get another square when n=4 and squaresLTE(4)=2 -- 1, and 4. We don\\'t add another square to the list until n=the next square. This gives us the final answer:\\n\\n`bulbs(n) = squaresLTE(n) = floor(sqrt(n))`\\n\\nThis works because if we\\'re between two squares a=s^2 and b=(s+1)^2, sqrt(n) will be some number between s and s+1, so floor(sqrt(n)) will bring us down to the sqrt of the last square we added to the list"
                    },
                    {
                        "username": "dilipK",
                        "content": "* If a particular number n is divisible by k , it means it will also  be divisible by n/k. So it will bring it to original state i.e.off. So toggling at kth iteration will turn ON but toggling at (n/k)th iteration will bring it to OFF. So no change.\\n* But for a prefect square sqrt(n) will only toggle it once , so it will be overall ON."
                    },
                    {
                        "username": "suhane",
                        "content": "# Logic : 1st round Bulb is ON, then each switch will OFF then ON. so for any number ->\\n# 1st round : ON\\n# 2nd round : OFF\\n# 3rd round : ON \\n# 4th round : OFF  and so on ....\\n# \\n# **If we can calculate how many times each bulb is switched we can tell it was ON/OFF at the last.**\\n# \\n# from above we can see if we switch bulb EVEN times we get it OFF at last, if switch ODD times we get it ON at the last.**\\n\\n*Now take few examples to understand better-*\\nN=1 -> bulb switched 1 time (for N=1)  \\t\\t\\t-> OFF at last\\n\\nN=2 -> bulb switched 2 times (for N=1, 2) \\t\\t-> OFF at last\\n\\nN=3 -> bulb switched 2 times (for N=1, 3) \\t\\t-> OFF at last\\n\\nN=4 -> bulb switched 3 times (for N=1, 2, 4) \\t-> **ON** at last\\n\\nN=5 -> bulb switched 2 times (for N=1, 5) \\t\\t-> OFF at last\\n\\nN=6 -> bulb switched 4 times (for N=1, 2, 3, 6) -> OFF at last\\n\\nN=7 -> bulb switched 2 times (for N=1, 7)\\t\\t-> OFF at last\\t\\n\\nN=8 -> bulb switched 8* times (for N=1, 2, 4, 8)\\t-> OFF at last\\t\\n(how we got 8 switches -\\nadd all switches of\\nN=1 (1 times at N=1),\\nN=2 (2 times at N=1,2), \\nN=4 (3 times at N=1,2,4) ,\\nN=8 (2 time at N=1,8))\\n\\nN=9 -> bulb switched 3 times (for N=1, 3, 9)\\t-> **ON** at last\\t\\n\\nAs you can see from above we got a conclusion only bulbs which are perfect square will be left ON at the last. (4, 9, 16, 25....) rest all bulbs will be OFF at the last.\\n\\nso we just need to fine how may perfact squares are present for any given N.\\nif N=20 -> 2, 4, 9, 16 (total 4)\\nif N=30 -> 2, 4, 9, 16, 25 (total 5)\\n\\nso we can convert calculating how many perfact sqs to -> simple solution\\n\\n# Ans: round(sqrt(N));\\n\\nBut this 1 line solution we can\\'t find until we know the whole logic that takes long time.\\n\\nHappy Learning !!\\n\\n"
                    }
                ]
            },
            {
                "id": 1566048,
                "content": [
                    {
                        "username": "rexthk",
                        "content": "Below are my step by step thought process. Hope it helps\\n\\nObservation #1:\\nA bulb is ON if it is toggled **odd** times: (ON), (ON -> OFF -> ON), (ON -> OFF -> ON -> OFF -> ON) ...\\nA bulb is OFF if it is toggled **even** times: (ON -> OFF), (ON -> OFF -> ON -> OFF ) ...\\n\\nObservation #2:\\nOnce we reach and toggle the ***i-th*** bulb, it will never be touched anymore.\\n\\nfor exmaple, let n = 5 ( changes in each round denoted as bold ), initial state is all OFF:\\n1-th round :   **ON,  ON,  ON,  ON, ON**\\n2-nd round:   ON, **OFF**,  ON, **OFF**, ON\\n3-rd round :   ON, OFF, **OFF**, OFF, ON\\n4-th round :   ON, OFF, OFF, **ON**, ON\\n5-th round :   ON, OFF, OFF, ON, **OFF**\\n\\nYou can see that, after each round, all bulbs before that round will not be touched anymore.\\n\\nSo, given a bulb at position X, how do I know it will be toggled EVEN/ODD times ?\\nAnswer: We can find the number of divisors of X. \\n\\nfor example, if the position of a bulb is 3, its divisor is [1,3], that mean we will toggle the 3-rd bulb at 1-st round and 3-rd round:\\nCombine the observation above, \\nat ***3-rd*** round, the third bulb will have been toggeld even times ( [1,3] ), so it is OFF. And it will not be changed later on round.\\nat ***5-th*** round, the fifth bulb will have been toggled even times ( [1,5] ), so it is OFF. And it will not be changed later on round.\\n\\nSuppose we have a func to get all divisors of i : **getDivisors(int)**, a simple algorithm can be deduced:\\n`for i = 1..n, if getDivisors(i) % 2 == 1, count++;`\\nWe loop through all positions, if it has odd number of divisors, it is ON and hence count + 1.\\n\\nUnfortunately, it will timeout. How to optimize ?\\n\\nObservation #3:\\nDivisors always come in pair. For example:\\n1: [1,1]  ---  2: [1,2] --- 3: [1,3] --- 4: [1,4] [2,2] --- 5:[1,5] --- 6:[1,6][2,3] --- 7:[1,7] \\n8: [1,8][2,4] --- 9:[1,9][3,3]\\n\\nIn above examples, we know that: \\nOnly when ***i*** has **perfect square root**, its number of divisors is ODD, because it contains duplicated divisor. In above example,\\n4: [1,2,4] --- 9: [1,3,9]\\nYou can pick any number to examine yourself.\\n\\nHere comes a better algorithm:\\n`for i = 1...n,  if i^2 <= n, count++ ; if i^2 > n, break;`\\nWe loop through all position, if **i^2** is <= n, that means there exists a valid bulb which has perfect square root ***i***, and we need to count that **i^2**, so count + 1. If the **i^2** exceed n, we can terminate it because we have found all ***i*** with perfect square root within n already.\\n\\nMany of you might have seen the answer, so why the answer can be simply written as Math.sqrt(n) ?\\nconsider n = 9, the process of aforementioned algorithm will be: \\ncheck (1 * 1 ) <= 9, count++\\ncheck (2 * 2 ) <= 9, count++;\\ncheck (3 * 3) <= 9, count++;\\ncheck (4 * 4) > 9, break;\\n\\nWe can say, if square root of 9 is 3, that mean **1^2** and **2^2** must exists for n = 9. Hence, the Math.sqrt(i) reflect this fact.\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "I got to observation 2 on my own. The condition for an odd number of divisors was eluding me, thanks for the help"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "mind glowing explanation\\n"
                    },
                    {
                        "username": "saidfgn",
                        "content": "Great explanation, thanks!"
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "**Its more like a puzzle rather than a coding problem**"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "[@yusufm09](/yusufm09) brain tester problem means does they ask this in interviews"
                    },
                    {
                        "username": "yusufm09",
                        "content": "[@jerryy147](/jerryy147) I never knew that there was a brainteaser problem list. Thanks."
                    },
                    {
                        "username": "jerryy147",
                        "content": "that\\'s why it\\'s in the \"brainteaser\" problem list"
                    },
                    {
                        "username": "strongwillow",
                        "content": "It only stated the first, second, third, and last round. Should be updated as follows:\\n\\nThere are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). **For the ith round, you toggle every i bulb.** For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds."
                    },
                    {
                        "username": "sx1w",
                        "content": "Like many of you are wondering why a simple sqaure root solution to the problem, I wanted to find out why that is correct. Here is my little research into it. \\n\\nThe light bulb at postion k must be toggled in odd number to stay on, e.g. \\'On, Off, On\\' including the initial toggle. What triggers k-th bulb be toggled? Number k must be an **exact** multiple of each toggling. For example, when k=4, the bulb will be triggered by the 1st (On), 2nd (Off) and 4th (On) operation. What is the exact number of multiple of a nature number k? **All of its factors** ! \\n\\nSo the k-th bulb \\'ON\\' is corresponding to the number of factors of k being odd. You can certainly develop a program to count. However, the [*number math*](http://mathcentral.uregina.ca/QQ/database/QQ.09.06/jacqueline1.html) tells us only perfect square numbers have odd number of factors, which is what needed for the bulb to stay on. \\n\\nGreat! Now to solve the problem is to find out how many perfect square number between 1 and n. The [*math*](https://www.quora.com/How-many-perfect-squares-are-there-between-1-to-1000) kicks in again, and that number is the square root of n (more preceisly the floor of sqaure root of n). \\n\\nWhat a great problem!"
                    },
                    {
                        "username": "bharathb",
                        "content": "A lot of other posts provide code / suggest a simulation to see the pattern. I will attempt to describe the intuition behind the solution. \\n\\n* First let s identify all the bulbs that can touch/affect/toggle bulb X. Bulb X can only be toggled by other bulbs which are less than or equal to X. For example, 26 will never toggle bulb 23.\\n* Secondly, for a bulb X what are the bulbs that can toggle X? 23 can never toggle 25. We notice that a bulb X can only be toggled by divisors of X - including 1 and X itself. \\n* Now let s consider prime numbers. Prime numbers by definition have exactly two divisors. Any number with 2 divisors will never be ON at the end - because 1 will set it to ON and the second divisor (the prime number itself) will toggle it off.\\n* With prime numbers gone, lets consider a composite number with an even number of divisors.  Say 24. The divisors of 24 are (1,2,3,4,6,8,12,24). Listing the divisors as pairs - (1, 24) (2,12), (3,8), (4,6) - pairs are crucial because one divisor will set 24 to ON and the other divisor will set it to OFF. So, the net result is that those bulbs will NOT be ON at the end of the simulation - because they are initially OFF. They are toggled an even number of times.\\n* Now, we need to find numbers <=N which have an odd number of divisors. This might not be intuitive immediately and this simulating the problem on paper helps. If we consider a perfect square like 36 and write the divisors in pairs - (1,36), (2,18), (3, 12), (4, 9), (6,6). Now, we can see that while all other divisors cancel each other out - (they toggle the bulb twice) - 6 has no counterpart to toggle the bulb off. So, when there are 36 bulbs, 6 will always be ON at the end. The same holds true for perfect squares less than N - which are 1,4,9,16,25.\\n* Based on the above inferences, we can see that we need to find the numbers less than N that are perfect squares.  We can calculate this (int) Math.sqrt(N) or have a simple for-loop to count (i*i) <=N \\n\\nHope this helps."
                    },
                    {
                        "username": "rajeshkumar1130",
                        "content": "I was asked this question in an interview with microsoft on 22-01-2021"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It just proves that an ordinary position at MS is a dead-end job."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@sandagolcea](/sandagolcea)  Nice solution bro! The code is also quite neat. Good job!"
                    },
                    {
                        "username": "algoacer",
                        "content": "[@code_coffeee](/code_coffeee) Acutally it is so true, some one gets to implement a plain algorithm and someone has to think out of the box in 40 minutes. Not fair. But we should keep applying at multiple companies."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@code_coffeee](/code_coffeee) do you mean a TLE? I've actually solved it differently, using rather simple mathematics, but not sqrt (which i know was quite obvs, but I thought of doing smth else :D ) here https://leetcode.com/problems/bulb-switcher/solutions/3461670/js-solutions-without-using-sqrt/ "
                    },
                    {
                        "username": "l3aonti",
                        "content": "[@dvijay96](/dvijay96) it throws memory limit exception "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@code_coffeee](/code_coffeee) Brute force n^2 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "they what happened bro how did you explain "
                    },
                    {
                        "username": "code_coffeee",
                        "content": "This makes me sad.\\n\\nI feel like if they ask anyone this, they must not want to hire this person. If anyone codes it in any way without using square root, it is  a rejection."
                    },
                    {
                        "username": "bingzhoudaren",
                        "content": "First, we need to figure out how do we know if the ith light is on or off at the end. \\nit dpends on how many numbers could output i after you get product of them.\\nfor example 6, \\nwe will toggle the 6th light in the first round becasue 1 times6=6\\nwe will toggle the 6th light in the second round because 2 times 3=6;\\nwe will toggle the 6th light in third round beacuse 3 times 2 =6;\\nand we will toggle the 6th light in 6th round beacuse 6 times 1=6;\\n\\nso since wil have 1,2,3,6,totally four numbers, we will toggle the 6th light 4 times.\\nand since 4 is even ,so the 6th light will be off at the end.\\n\\nand for example, 9 could have division 1,3,9,  there are three of them. which is odd, so the 9th light is on at the end.\\n\\n\\nthen the problem is to figure out which number have odd divisions, which have even.\\n\\nthen, we should realize that,  for no-square number, the divisions can be paired.\\n\\nfor example, for 6, 1,and 6 is a pair, 2 and 3 is a pair.\\nhowever, for square number, for example 9, 3 will pair by itself, or we could say, 3 does not have a partener to build a pair.\\n\\nso, only lights at square numbers position will be on at the end.\\n\\nso, if we have 10 lights, at the end, only 1,4,9 light will be on.\\n\\n\\nand how to count them? by sqrt(10), we could get 3, which is the number of square numbers smaller than 10\\n\\n\\n\\n"
                    },
                    {
                        "username": "warrenbrodsky",
                        "content": "To begin, let\\'s forget keeping track of *every*  bulb and only think about *one*. Clearly, this bulb can either be on or off.  While obvious, this is still significant. If we know how many times we toggled the bulb, we can figure out which state it is in: If we have a bulb that begins on and we toggle it once, it will be off. Twice, on again. Thrice, off, four times on, five off, six on, etc. OK, so the answer is parity -- even flips it\\'s on, odd it\\'s off. \\n\\nGreat, but we don\\'t flip every bulb on every iteration, so how do we know how many times we flipped it? Ok, well on the first pass, we flip every other bulb, that is, every bulb whose index is a multiple of 2 (assuming indexing starts from 1 ;) ). On the next, we toggle every multiple of 3. On the next, multiples of 4, etc. When we\\'re done, we\\'ll have flipped every bulb once for each number that it is a multiple of, which is to say, once for each *divisor*. (Importantly, we include itself, but not 1.) For example, bulb 6 is flipped off for 2, on for 3, and off one final time for 6. Another important fact is that divisors come in pairs -- it and the thing it has to be multiplied with to get the number. The ***only*** time this isn\\'t true is if the thing it is multiplied by is itself. In other words, it\\'s a perfect square. Therefore perfect squares will *always* have an *odd* number of divisors and all others have *even* numbers of divisors. Since we\\'re not including one as a divisor, the parity flips and therefore, when all is said and done, only bulbs with perfect square indices will remain on.\\n\\nBulk of the work done -- now we just need to know how many perfect squares there are from 1 to n (which I will call squaresLTE(n)) and that will be our answer. This is fairly simple: beginning with n=1 and squaresLTE(1) = 1, we can see squaresLTE(2) is still 1,  squaresLTE(3) is still 1, and we finally get another square when n=4 and squaresLTE(4)=2 -- 1, and 4. We don\\'t add another square to the list until n=the next square. This gives us the final answer:\\n\\n`bulbs(n) = squaresLTE(n) = floor(sqrt(n))`\\n\\nThis works because if we\\'re between two squares a=s^2 and b=(s+1)^2, sqrt(n) will be some number between s and s+1, so floor(sqrt(n)) will bring us down to the sqrt of the last square we added to the list"
                    },
                    {
                        "username": "dilipK",
                        "content": "* If a particular number n is divisible by k , it means it will also  be divisible by n/k. So it will bring it to original state i.e.off. So toggling at kth iteration will turn ON but toggling at (n/k)th iteration will bring it to OFF. So no change.\\n* But for a prefect square sqrt(n) will only toggle it once , so it will be overall ON."
                    },
                    {
                        "username": "suhane",
                        "content": "# Logic : 1st round Bulb is ON, then each switch will OFF then ON. so for any number ->\\n# 1st round : ON\\n# 2nd round : OFF\\n# 3rd round : ON \\n# 4th round : OFF  and so on ....\\n# \\n# **If we can calculate how many times each bulb is switched we can tell it was ON/OFF at the last.**\\n# \\n# from above we can see if we switch bulb EVEN times we get it OFF at last, if switch ODD times we get it ON at the last.**\\n\\n*Now take few examples to understand better-*\\nN=1 -> bulb switched 1 time (for N=1)  \\t\\t\\t-> OFF at last\\n\\nN=2 -> bulb switched 2 times (for N=1, 2) \\t\\t-> OFF at last\\n\\nN=3 -> bulb switched 2 times (for N=1, 3) \\t\\t-> OFF at last\\n\\nN=4 -> bulb switched 3 times (for N=1, 2, 4) \\t-> **ON** at last\\n\\nN=5 -> bulb switched 2 times (for N=1, 5) \\t\\t-> OFF at last\\n\\nN=6 -> bulb switched 4 times (for N=1, 2, 3, 6) -> OFF at last\\n\\nN=7 -> bulb switched 2 times (for N=1, 7)\\t\\t-> OFF at last\\t\\n\\nN=8 -> bulb switched 8* times (for N=1, 2, 4, 8)\\t-> OFF at last\\t\\n(how we got 8 switches -\\nadd all switches of\\nN=1 (1 times at N=1),\\nN=2 (2 times at N=1,2), \\nN=4 (3 times at N=1,2,4) ,\\nN=8 (2 time at N=1,8))\\n\\nN=9 -> bulb switched 3 times (for N=1, 3, 9)\\t-> **ON** at last\\t\\n\\nAs you can see from above we got a conclusion only bulbs which are perfect square will be left ON at the last. (4, 9, 16, 25....) rest all bulbs will be OFF at the last.\\n\\nso we just need to fine how may perfact squares are present for any given N.\\nif N=20 -> 2, 4, 9, 16 (total 4)\\nif N=30 -> 2, 4, 9, 16, 25 (total 5)\\n\\nso we can convert calculating how many perfact sqs to -> simple solution\\n\\n# Ans: round(sqrt(N));\\n\\nBut this 1 line solution we can\\'t find until we know the whole logic that takes long time.\\n\\nHappy Learning !!\\n\\n"
                    }
                ]
            },
            {
                "id": 1565021,
                "content": [
                    {
                        "username": "rexthk",
                        "content": "Below are my step by step thought process. Hope it helps\\n\\nObservation #1:\\nA bulb is ON if it is toggled **odd** times: (ON), (ON -> OFF -> ON), (ON -> OFF -> ON -> OFF -> ON) ...\\nA bulb is OFF if it is toggled **even** times: (ON -> OFF), (ON -> OFF -> ON -> OFF ) ...\\n\\nObservation #2:\\nOnce we reach and toggle the ***i-th*** bulb, it will never be touched anymore.\\n\\nfor exmaple, let n = 5 ( changes in each round denoted as bold ), initial state is all OFF:\\n1-th round :   **ON,  ON,  ON,  ON, ON**\\n2-nd round:   ON, **OFF**,  ON, **OFF**, ON\\n3-rd round :   ON, OFF, **OFF**, OFF, ON\\n4-th round :   ON, OFF, OFF, **ON**, ON\\n5-th round :   ON, OFF, OFF, ON, **OFF**\\n\\nYou can see that, after each round, all bulbs before that round will not be touched anymore.\\n\\nSo, given a bulb at position X, how do I know it will be toggled EVEN/ODD times ?\\nAnswer: We can find the number of divisors of X. \\n\\nfor example, if the position of a bulb is 3, its divisor is [1,3], that mean we will toggle the 3-rd bulb at 1-st round and 3-rd round:\\nCombine the observation above, \\nat ***3-rd*** round, the third bulb will have been toggeld even times ( [1,3] ), so it is OFF. And it will not be changed later on round.\\nat ***5-th*** round, the fifth bulb will have been toggled even times ( [1,5] ), so it is OFF. And it will not be changed later on round.\\n\\nSuppose we have a func to get all divisors of i : **getDivisors(int)**, a simple algorithm can be deduced:\\n`for i = 1..n, if getDivisors(i) % 2 == 1, count++;`\\nWe loop through all positions, if it has odd number of divisors, it is ON and hence count + 1.\\n\\nUnfortunately, it will timeout. How to optimize ?\\n\\nObservation #3:\\nDivisors always come in pair. For example:\\n1: [1,1]  ---  2: [1,2] --- 3: [1,3] --- 4: [1,4] [2,2] --- 5:[1,5] --- 6:[1,6][2,3] --- 7:[1,7] \\n8: [1,8][2,4] --- 9:[1,9][3,3]\\n\\nIn above examples, we know that: \\nOnly when ***i*** has **perfect square root**, its number of divisors is ODD, because it contains duplicated divisor. In above example,\\n4: [1,2,4] --- 9: [1,3,9]\\nYou can pick any number to examine yourself.\\n\\nHere comes a better algorithm:\\n`for i = 1...n,  if i^2 <= n, count++ ; if i^2 > n, break;`\\nWe loop through all position, if **i^2** is <= n, that means there exists a valid bulb which has perfect square root ***i***, and we need to count that **i^2**, so count + 1. If the **i^2** exceed n, we can terminate it because we have found all ***i*** with perfect square root within n already.\\n\\nMany of you might have seen the answer, so why the answer can be simply written as Math.sqrt(n) ?\\nconsider n = 9, the process of aforementioned algorithm will be: \\ncheck (1 * 1 ) <= 9, count++\\ncheck (2 * 2 ) <= 9, count++;\\ncheck (3 * 3) <= 9, count++;\\ncheck (4 * 4) > 9, break;\\n\\nWe can say, if square root of 9 is 3, that mean **1^2** and **2^2** must exists for n = 9. Hence, the Math.sqrt(i) reflect this fact.\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "I got to observation 2 on my own. The condition for an odd number of divisors was eluding me, thanks for the help"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "mind glowing explanation\\n"
                    },
                    {
                        "username": "saidfgn",
                        "content": "Great explanation, thanks!"
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "**Its more like a puzzle rather than a coding problem**"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "[@yusufm09](/yusufm09) brain tester problem means does they ask this in interviews"
                    },
                    {
                        "username": "yusufm09",
                        "content": "[@jerryy147](/jerryy147) I never knew that there was a brainteaser problem list. Thanks."
                    },
                    {
                        "username": "jerryy147",
                        "content": "that\\'s why it\\'s in the \"brainteaser\" problem list"
                    },
                    {
                        "username": "strongwillow",
                        "content": "It only stated the first, second, third, and last round. Should be updated as follows:\\n\\nThere are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). **For the ith round, you toggle every i bulb.** For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds."
                    },
                    {
                        "username": "sx1w",
                        "content": "Like many of you are wondering why a simple sqaure root solution to the problem, I wanted to find out why that is correct. Here is my little research into it. \\n\\nThe light bulb at postion k must be toggled in odd number to stay on, e.g. \\'On, Off, On\\' including the initial toggle. What triggers k-th bulb be toggled? Number k must be an **exact** multiple of each toggling. For example, when k=4, the bulb will be triggered by the 1st (On), 2nd (Off) and 4th (On) operation. What is the exact number of multiple of a nature number k? **All of its factors** ! \\n\\nSo the k-th bulb \\'ON\\' is corresponding to the number of factors of k being odd. You can certainly develop a program to count. However, the [*number math*](http://mathcentral.uregina.ca/QQ/database/QQ.09.06/jacqueline1.html) tells us only perfect square numbers have odd number of factors, which is what needed for the bulb to stay on. \\n\\nGreat! Now to solve the problem is to find out how many perfect square number between 1 and n. The [*math*](https://www.quora.com/How-many-perfect-squares-are-there-between-1-to-1000) kicks in again, and that number is the square root of n (more preceisly the floor of sqaure root of n). \\n\\nWhat a great problem!"
                    },
                    {
                        "username": "bharathb",
                        "content": "A lot of other posts provide code / suggest a simulation to see the pattern. I will attempt to describe the intuition behind the solution. \\n\\n* First let s identify all the bulbs that can touch/affect/toggle bulb X. Bulb X can only be toggled by other bulbs which are less than or equal to X. For example, 26 will never toggle bulb 23.\\n* Secondly, for a bulb X what are the bulbs that can toggle X? 23 can never toggle 25. We notice that a bulb X can only be toggled by divisors of X - including 1 and X itself. \\n* Now let s consider prime numbers. Prime numbers by definition have exactly two divisors. Any number with 2 divisors will never be ON at the end - because 1 will set it to ON and the second divisor (the prime number itself) will toggle it off.\\n* With prime numbers gone, lets consider a composite number with an even number of divisors.  Say 24. The divisors of 24 are (1,2,3,4,6,8,12,24). Listing the divisors as pairs - (1, 24) (2,12), (3,8), (4,6) - pairs are crucial because one divisor will set 24 to ON and the other divisor will set it to OFF. So, the net result is that those bulbs will NOT be ON at the end of the simulation - because they are initially OFF. They are toggled an even number of times.\\n* Now, we need to find numbers <=N which have an odd number of divisors. This might not be intuitive immediately and this simulating the problem on paper helps. If we consider a perfect square like 36 and write the divisors in pairs - (1,36), (2,18), (3, 12), (4, 9), (6,6). Now, we can see that while all other divisors cancel each other out - (they toggle the bulb twice) - 6 has no counterpart to toggle the bulb off. So, when there are 36 bulbs, 6 will always be ON at the end. The same holds true for perfect squares less than N - which are 1,4,9,16,25.\\n* Based on the above inferences, we can see that we need to find the numbers less than N that are perfect squares.  We can calculate this (int) Math.sqrt(N) or have a simple for-loop to count (i*i) <=N \\n\\nHope this helps."
                    },
                    {
                        "username": "rajeshkumar1130",
                        "content": "I was asked this question in an interview with microsoft on 22-01-2021"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It just proves that an ordinary position at MS is a dead-end job."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@sandagolcea](/sandagolcea)  Nice solution bro! The code is also quite neat. Good job!"
                    },
                    {
                        "username": "algoacer",
                        "content": "[@code_coffeee](/code_coffeee) Acutally it is so true, some one gets to implement a plain algorithm and someone has to think out of the box in 40 minutes. Not fair. But we should keep applying at multiple companies."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@code_coffeee](/code_coffeee) do you mean a TLE? I've actually solved it differently, using rather simple mathematics, but not sqrt (which i know was quite obvs, but I thought of doing smth else :D ) here https://leetcode.com/problems/bulb-switcher/solutions/3461670/js-solutions-without-using-sqrt/ "
                    },
                    {
                        "username": "l3aonti",
                        "content": "[@dvijay96](/dvijay96) it throws memory limit exception "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@code_coffeee](/code_coffeee) Brute force n^2 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "they what happened bro how did you explain "
                    },
                    {
                        "username": "code_coffeee",
                        "content": "This makes me sad.\\n\\nI feel like if they ask anyone this, they must not want to hire this person. If anyone codes it in any way without using square root, it is  a rejection."
                    },
                    {
                        "username": "bingzhoudaren",
                        "content": "First, we need to figure out how do we know if the ith light is on or off at the end. \\nit dpends on how many numbers could output i after you get product of them.\\nfor example 6, \\nwe will toggle the 6th light in the first round becasue 1 times6=6\\nwe will toggle the 6th light in the second round because 2 times 3=6;\\nwe will toggle the 6th light in third round beacuse 3 times 2 =6;\\nand we will toggle the 6th light in 6th round beacuse 6 times 1=6;\\n\\nso since wil have 1,2,3,6,totally four numbers, we will toggle the 6th light 4 times.\\nand since 4 is even ,so the 6th light will be off at the end.\\n\\nand for example, 9 could have division 1,3,9,  there are three of them. which is odd, so the 9th light is on at the end.\\n\\n\\nthen the problem is to figure out which number have odd divisions, which have even.\\n\\nthen, we should realize that,  for no-square number, the divisions can be paired.\\n\\nfor example, for 6, 1,and 6 is a pair, 2 and 3 is a pair.\\nhowever, for square number, for example 9, 3 will pair by itself, or we could say, 3 does not have a partener to build a pair.\\n\\nso, only lights at square numbers position will be on at the end.\\n\\nso, if we have 10 lights, at the end, only 1,4,9 light will be on.\\n\\n\\nand how to count them? by sqrt(10), we could get 3, which is the number of square numbers smaller than 10\\n\\n\\n\\n"
                    },
                    {
                        "username": "warrenbrodsky",
                        "content": "To begin, let\\'s forget keeping track of *every*  bulb and only think about *one*. Clearly, this bulb can either be on or off.  While obvious, this is still significant. If we know how many times we toggled the bulb, we can figure out which state it is in: If we have a bulb that begins on and we toggle it once, it will be off. Twice, on again. Thrice, off, four times on, five off, six on, etc. OK, so the answer is parity -- even flips it\\'s on, odd it\\'s off. \\n\\nGreat, but we don\\'t flip every bulb on every iteration, so how do we know how many times we flipped it? Ok, well on the first pass, we flip every other bulb, that is, every bulb whose index is a multiple of 2 (assuming indexing starts from 1 ;) ). On the next, we toggle every multiple of 3. On the next, multiples of 4, etc. When we\\'re done, we\\'ll have flipped every bulb once for each number that it is a multiple of, which is to say, once for each *divisor*. (Importantly, we include itself, but not 1.) For example, bulb 6 is flipped off for 2, on for 3, and off one final time for 6. Another important fact is that divisors come in pairs -- it and the thing it has to be multiplied with to get the number. The ***only*** time this isn\\'t true is if the thing it is multiplied by is itself. In other words, it\\'s a perfect square. Therefore perfect squares will *always* have an *odd* number of divisors and all others have *even* numbers of divisors. Since we\\'re not including one as a divisor, the parity flips and therefore, when all is said and done, only bulbs with perfect square indices will remain on.\\n\\nBulk of the work done -- now we just need to know how many perfect squares there are from 1 to n (which I will call squaresLTE(n)) and that will be our answer. This is fairly simple: beginning with n=1 and squaresLTE(1) = 1, we can see squaresLTE(2) is still 1,  squaresLTE(3) is still 1, and we finally get another square when n=4 and squaresLTE(4)=2 -- 1, and 4. We don\\'t add another square to the list until n=the next square. This gives us the final answer:\\n\\n`bulbs(n) = squaresLTE(n) = floor(sqrt(n))`\\n\\nThis works because if we\\'re between two squares a=s^2 and b=(s+1)^2, sqrt(n) will be some number between s and s+1, so floor(sqrt(n)) will bring us down to the sqrt of the last square we added to the list"
                    },
                    {
                        "username": "dilipK",
                        "content": "* If a particular number n is divisible by k , it means it will also  be divisible by n/k. So it will bring it to original state i.e.off. So toggling at kth iteration will turn ON but toggling at (n/k)th iteration will bring it to OFF. So no change.\\n* But for a prefect square sqrt(n) will only toggle it once , so it will be overall ON."
                    },
                    {
                        "username": "suhane",
                        "content": "# Logic : 1st round Bulb is ON, then each switch will OFF then ON. so for any number ->\\n# 1st round : ON\\n# 2nd round : OFF\\n# 3rd round : ON \\n# 4th round : OFF  and so on ....\\n# \\n# **If we can calculate how many times each bulb is switched we can tell it was ON/OFF at the last.**\\n# \\n# from above we can see if we switch bulb EVEN times we get it OFF at last, if switch ODD times we get it ON at the last.**\\n\\n*Now take few examples to understand better-*\\nN=1 -> bulb switched 1 time (for N=1)  \\t\\t\\t-> OFF at last\\n\\nN=2 -> bulb switched 2 times (for N=1, 2) \\t\\t-> OFF at last\\n\\nN=3 -> bulb switched 2 times (for N=1, 3) \\t\\t-> OFF at last\\n\\nN=4 -> bulb switched 3 times (for N=1, 2, 4) \\t-> **ON** at last\\n\\nN=5 -> bulb switched 2 times (for N=1, 5) \\t\\t-> OFF at last\\n\\nN=6 -> bulb switched 4 times (for N=1, 2, 3, 6) -> OFF at last\\n\\nN=7 -> bulb switched 2 times (for N=1, 7)\\t\\t-> OFF at last\\t\\n\\nN=8 -> bulb switched 8* times (for N=1, 2, 4, 8)\\t-> OFF at last\\t\\n(how we got 8 switches -\\nadd all switches of\\nN=1 (1 times at N=1),\\nN=2 (2 times at N=1,2), \\nN=4 (3 times at N=1,2,4) ,\\nN=8 (2 time at N=1,8))\\n\\nN=9 -> bulb switched 3 times (for N=1, 3, 9)\\t-> **ON** at last\\t\\n\\nAs you can see from above we got a conclusion only bulbs which are perfect square will be left ON at the last. (4, 9, 16, 25....) rest all bulbs will be OFF at the last.\\n\\nso we just need to fine how may perfact squares are present for any given N.\\nif N=20 -> 2, 4, 9, 16 (total 4)\\nif N=30 -> 2, 4, 9, 16, 25 (total 5)\\n\\nso we can convert calculating how many perfact sqs to -> simple solution\\n\\n# Ans: round(sqrt(N));\\n\\nBut this 1 line solution we can\\'t find until we know the whole logic that takes long time.\\n\\nHappy Learning !!\\n\\n"
                    }
                ]
            },
            {
                "id": 1565556,
                "content": [
                    {
                        "username": "rexthk",
                        "content": "Below are my step by step thought process. Hope it helps\\n\\nObservation #1:\\nA bulb is ON if it is toggled **odd** times: (ON), (ON -> OFF -> ON), (ON -> OFF -> ON -> OFF -> ON) ...\\nA bulb is OFF if it is toggled **even** times: (ON -> OFF), (ON -> OFF -> ON -> OFF ) ...\\n\\nObservation #2:\\nOnce we reach and toggle the ***i-th*** bulb, it will never be touched anymore.\\n\\nfor exmaple, let n = 5 ( changes in each round denoted as bold ), initial state is all OFF:\\n1-th round :   **ON,  ON,  ON,  ON, ON**\\n2-nd round:   ON, **OFF**,  ON, **OFF**, ON\\n3-rd round :   ON, OFF, **OFF**, OFF, ON\\n4-th round :   ON, OFF, OFF, **ON**, ON\\n5-th round :   ON, OFF, OFF, ON, **OFF**\\n\\nYou can see that, after each round, all bulbs before that round will not be touched anymore.\\n\\nSo, given a bulb at position X, how do I know it will be toggled EVEN/ODD times ?\\nAnswer: We can find the number of divisors of X. \\n\\nfor example, if the position of a bulb is 3, its divisor is [1,3], that mean we will toggle the 3-rd bulb at 1-st round and 3-rd round:\\nCombine the observation above, \\nat ***3-rd*** round, the third bulb will have been toggeld even times ( [1,3] ), so it is OFF. And it will not be changed later on round.\\nat ***5-th*** round, the fifth bulb will have been toggled even times ( [1,5] ), so it is OFF. And it will not be changed later on round.\\n\\nSuppose we have a func to get all divisors of i : **getDivisors(int)**, a simple algorithm can be deduced:\\n`for i = 1..n, if getDivisors(i) % 2 == 1, count++;`\\nWe loop through all positions, if it has odd number of divisors, it is ON and hence count + 1.\\n\\nUnfortunately, it will timeout. How to optimize ?\\n\\nObservation #3:\\nDivisors always come in pair. For example:\\n1: [1,1]  ---  2: [1,2] --- 3: [1,3] --- 4: [1,4] [2,2] --- 5:[1,5] --- 6:[1,6][2,3] --- 7:[1,7] \\n8: [1,8][2,4] --- 9:[1,9][3,3]\\n\\nIn above examples, we know that: \\nOnly when ***i*** has **perfect square root**, its number of divisors is ODD, because it contains duplicated divisor. In above example,\\n4: [1,2,4] --- 9: [1,3,9]\\nYou can pick any number to examine yourself.\\n\\nHere comes a better algorithm:\\n`for i = 1...n,  if i^2 <= n, count++ ; if i^2 > n, break;`\\nWe loop through all position, if **i^2** is <= n, that means there exists a valid bulb which has perfect square root ***i***, and we need to count that **i^2**, so count + 1. If the **i^2** exceed n, we can terminate it because we have found all ***i*** with perfect square root within n already.\\n\\nMany of you might have seen the answer, so why the answer can be simply written as Math.sqrt(n) ?\\nconsider n = 9, the process of aforementioned algorithm will be: \\ncheck (1 * 1 ) <= 9, count++\\ncheck (2 * 2 ) <= 9, count++;\\ncheck (3 * 3) <= 9, count++;\\ncheck (4 * 4) > 9, break;\\n\\nWe can say, if square root of 9 is 3, that mean **1^2** and **2^2** must exists for n = 9. Hence, the Math.sqrt(i) reflect this fact.\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "I got to observation 2 on my own. The condition for an odd number of divisors was eluding me, thanks for the help"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "mind glowing explanation\\n"
                    },
                    {
                        "username": "saidfgn",
                        "content": "Great explanation, thanks!"
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "**Its more like a puzzle rather than a coding problem**"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "[@yusufm09](/yusufm09) brain tester problem means does they ask this in interviews"
                    },
                    {
                        "username": "yusufm09",
                        "content": "[@jerryy147](/jerryy147) I never knew that there was a brainteaser problem list. Thanks."
                    },
                    {
                        "username": "jerryy147",
                        "content": "that\\'s why it\\'s in the \"brainteaser\" problem list"
                    },
                    {
                        "username": "strongwillow",
                        "content": "It only stated the first, second, third, and last round. Should be updated as follows:\\n\\nThere are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). **For the ith round, you toggle every i bulb.** For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds."
                    },
                    {
                        "username": "sx1w",
                        "content": "Like many of you are wondering why a simple sqaure root solution to the problem, I wanted to find out why that is correct. Here is my little research into it. \\n\\nThe light bulb at postion k must be toggled in odd number to stay on, e.g. \\'On, Off, On\\' including the initial toggle. What triggers k-th bulb be toggled? Number k must be an **exact** multiple of each toggling. For example, when k=4, the bulb will be triggered by the 1st (On), 2nd (Off) and 4th (On) operation. What is the exact number of multiple of a nature number k? **All of its factors** ! \\n\\nSo the k-th bulb \\'ON\\' is corresponding to the number of factors of k being odd. You can certainly develop a program to count. However, the [*number math*](http://mathcentral.uregina.ca/QQ/database/QQ.09.06/jacqueline1.html) tells us only perfect square numbers have odd number of factors, which is what needed for the bulb to stay on. \\n\\nGreat! Now to solve the problem is to find out how many perfect square number between 1 and n. The [*math*](https://www.quora.com/How-many-perfect-squares-are-there-between-1-to-1000) kicks in again, and that number is the square root of n (more preceisly the floor of sqaure root of n). \\n\\nWhat a great problem!"
                    },
                    {
                        "username": "bharathb",
                        "content": "A lot of other posts provide code / suggest a simulation to see the pattern. I will attempt to describe the intuition behind the solution. \\n\\n* First let s identify all the bulbs that can touch/affect/toggle bulb X. Bulb X can only be toggled by other bulbs which are less than or equal to X. For example, 26 will never toggle bulb 23.\\n* Secondly, for a bulb X what are the bulbs that can toggle X? 23 can never toggle 25. We notice that a bulb X can only be toggled by divisors of X - including 1 and X itself. \\n* Now let s consider prime numbers. Prime numbers by definition have exactly two divisors. Any number with 2 divisors will never be ON at the end - because 1 will set it to ON and the second divisor (the prime number itself) will toggle it off.\\n* With prime numbers gone, lets consider a composite number with an even number of divisors.  Say 24. The divisors of 24 are (1,2,3,4,6,8,12,24). Listing the divisors as pairs - (1, 24) (2,12), (3,8), (4,6) - pairs are crucial because one divisor will set 24 to ON and the other divisor will set it to OFF. So, the net result is that those bulbs will NOT be ON at the end of the simulation - because they are initially OFF. They are toggled an even number of times.\\n* Now, we need to find numbers <=N which have an odd number of divisors. This might not be intuitive immediately and this simulating the problem on paper helps. If we consider a perfect square like 36 and write the divisors in pairs - (1,36), (2,18), (3, 12), (4, 9), (6,6). Now, we can see that while all other divisors cancel each other out - (they toggle the bulb twice) - 6 has no counterpart to toggle the bulb off. So, when there are 36 bulbs, 6 will always be ON at the end. The same holds true for perfect squares less than N - which are 1,4,9,16,25.\\n* Based on the above inferences, we can see that we need to find the numbers less than N that are perfect squares.  We can calculate this (int) Math.sqrt(N) or have a simple for-loop to count (i*i) <=N \\n\\nHope this helps."
                    },
                    {
                        "username": "rajeshkumar1130",
                        "content": "I was asked this question in an interview with microsoft on 22-01-2021"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It just proves that an ordinary position at MS is a dead-end job."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@sandagolcea](/sandagolcea)  Nice solution bro! The code is also quite neat. Good job!"
                    },
                    {
                        "username": "algoacer",
                        "content": "[@code_coffeee](/code_coffeee) Acutally it is so true, some one gets to implement a plain algorithm and someone has to think out of the box in 40 minutes. Not fair. But we should keep applying at multiple companies."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@code_coffeee](/code_coffeee) do you mean a TLE? I've actually solved it differently, using rather simple mathematics, but not sqrt (which i know was quite obvs, but I thought of doing smth else :D ) here https://leetcode.com/problems/bulb-switcher/solutions/3461670/js-solutions-without-using-sqrt/ "
                    },
                    {
                        "username": "l3aonti",
                        "content": "[@dvijay96](/dvijay96) it throws memory limit exception "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@code_coffeee](/code_coffeee) Brute force n^2 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "they what happened bro how did you explain "
                    },
                    {
                        "username": "code_coffeee",
                        "content": "This makes me sad.\\n\\nI feel like if they ask anyone this, they must not want to hire this person. If anyone codes it in any way without using square root, it is  a rejection."
                    },
                    {
                        "username": "bingzhoudaren",
                        "content": "First, we need to figure out how do we know if the ith light is on or off at the end. \\nit dpends on how many numbers could output i after you get product of them.\\nfor example 6, \\nwe will toggle the 6th light in the first round becasue 1 times6=6\\nwe will toggle the 6th light in the second round because 2 times 3=6;\\nwe will toggle the 6th light in third round beacuse 3 times 2 =6;\\nand we will toggle the 6th light in 6th round beacuse 6 times 1=6;\\n\\nso since wil have 1,2,3,6,totally four numbers, we will toggle the 6th light 4 times.\\nand since 4 is even ,so the 6th light will be off at the end.\\n\\nand for example, 9 could have division 1,3,9,  there are three of them. which is odd, so the 9th light is on at the end.\\n\\n\\nthen the problem is to figure out which number have odd divisions, which have even.\\n\\nthen, we should realize that,  for no-square number, the divisions can be paired.\\n\\nfor example, for 6, 1,and 6 is a pair, 2 and 3 is a pair.\\nhowever, for square number, for example 9, 3 will pair by itself, or we could say, 3 does not have a partener to build a pair.\\n\\nso, only lights at square numbers position will be on at the end.\\n\\nso, if we have 10 lights, at the end, only 1,4,9 light will be on.\\n\\n\\nand how to count them? by sqrt(10), we could get 3, which is the number of square numbers smaller than 10\\n\\n\\n\\n"
                    },
                    {
                        "username": "warrenbrodsky",
                        "content": "To begin, let\\'s forget keeping track of *every*  bulb and only think about *one*. Clearly, this bulb can either be on or off.  While obvious, this is still significant. If we know how many times we toggled the bulb, we can figure out which state it is in: If we have a bulb that begins on and we toggle it once, it will be off. Twice, on again. Thrice, off, four times on, five off, six on, etc. OK, so the answer is parity -- even flips it\\'s on, odd it\\'s off. \\n\\nGreat, but we don\\'t flip every bulb on every iteration, so how do we know how many times we flipped it? Ok, well on the first pass, we flip every other bulb, that is, every bulb whose index is a multiple of 2 (assuming indexing starts from 1 ;) ). On the next, we toggle every multiple of 3. On the next, multiples of 4, etc. When we\\'re done, we\\'ll have flipped every bulb once for each number that it is a multiple of, which is to say, once for each *divisor*. (Importantly, we include itself, but not 1.) For example, bulb 6 is flipped off for 2, on for 3, and off one final time for 6. Another important fact is that divisors come in pairs -- it and the thing it has to be multiplied with to get the number. The ***only*** time this isn\\'t true is if the thing it is multiplied by is itself. In other words, it\\'s a perfect square. Therefore perfect squares will *always* have an *odd* number of divisors and all others have *even* numbers of divisors. Since we\\'re not including one as a divisor, the parity flips and therefore, when all is said and done, only bulbs with perfect square indices will remain on.\\n\\nBulk of the work done -- now we just need to know how many perfect squares there are from 1 to n (which I will call squaresLTE(n)) and that will be our answer. This is fairly simple: beginning with n=1 and squaresLTE(1) = 1, we can see squaresLTE(2) is still 1,  squaresLTE(3) is still 1, and we finally get another square when n=4 and squaresLTE(4)=2 -- 1, and 4. We don\\'t add another square to the list until n=the next square. This gives us the final answer:\\n\\n`bulbs(n) = squaresLTE(n) = floor(sqrt(n))`\\n\\nThis works because if we\\'re between two squares a=s^2 and b=(s+1)^2, sqrt(n) will be some number between s and s+1, so floor(sqrt(n)) will bring us down to the sqrt of the last square we added to the list"
                    },
                    {
                        "username": "dilipK",
                        "content": "* If a particular number n is divisible by k , it means it will also  be divisible by n/k. So it will bring it to original state i.e.off. So toggling at kth iteration will turn ON but toggling at (n/k)th iteration will bring it to OFF. So no change.\\n* But for a prefect square sqrt(n) will only toggle it once , so it will be overall ON."
                    },
                    {
                        "username": "suhane",
                        "content": "# Logic : 1st round Bulb is ON, then each switch will OFF then ON. so for any number ->\\n# 1st round : ON\\n# 2nd round : OFF\\n# 3rd round : ON \\n# 4th round : OFF  and so on ....\\n# \\n# **If we can calculate how many times each bulb is switched we can tell it was ON/OFF at the last.**\\n# \\n# from above we can see if we switch bulb EVEN times we get it OFF at last, if switch ODD times we get it ON at the last.**\\n\\n*Now take few examples to understand better-*\\nN=1 -> bulb switched 1 time (for N=1)  \\t\\t\\t-> OFF at last\\n\\nN=2 -> bulb switched 2 times (for N=1, 2) \\t\\t-> OFF at last\\n\\nN=3 -> bulb switched 2 times (for N=1, 3) \\t\\t-> OFF at last\\n\\nN=4 -> bulb switched 3 times (for N=1, 2, 4) \\t-> **ON** at last\\n\\nN=5 -> bulb switched 2 times (for N=1, 5) \\t\\t-> OFF at last\\n\\nN=6 -> bulb switched 4 times (for N=1, 2, 3, 6) -> OFF at last\\n\\nN=7 -> bulb switched 2 times (for N=1, 7)\\t\\t-> OFF at last\\t\\n\\nN=8 -> bulb switched 8* times (for N=1, 2, 4, 8)\\t-> OFF at last\\t\\n(how we got 8 switches -\\nadd all switches of\\nN=1 (1 times at N=1),\\nN=2 (2 times at N=1,2), \\nN=4 (3 times at N=1,2,4) ,\\nN=8 (2 time at N=1,8))\\n\\nN=9 -> bulb switched 3 times (for N=1, 3, 9)\\t-> **ON** at last\\t\\n\\nAs you can see from above we got a conclusion only bulbs which are perfect square will be left ON at the last. (4, 9, 16, 25....) rest all bulbs will be OFF at the last.\\n\\nso we just need to fine how may perfact squares are present for any given N.\\nif N=20 -> 2, 4, 9, 16 (total 4)\\nif N=30 -> 2, 4, 9, 16, 25 (total 5)\\n\\nso we can convert calculating how many perfact sqs to -> simple solution\\n\\n# Ans: round(sqrt(N));\\n\\nBut this 1 line solution we can\\'t find until we know the whole logic that takes long time.\\n\\nHappy Learning !!\\n\\n"
                    }
                ]
            },
            {
                "id": 1565569,
                "content": [
                    {
                        "username": "rexthk",
                        "content": "Below are my step by step thought process. Hope it helps\\n\\nObservation #1:\\nA bulb is ON if it is toggled **odd** times: (ON), (ON -> OFF -> ON), (ON -> OFF -> ON -> OFF -> ON) ...\\nA bulb is OFF if it is toggled **even** times: (ON -> OFF), (ON -> OFF -> ON -> OFF ) ...\\n\\nObservation #2:\\nOnce we reach and toggle the ***i-th*** bulb, it will never be touched anymore.\\n\\nfor exmaple, let n = 5 ( changes in each round denoted as bold ), initial state is all OFF:\\n1-th round :   **ON,  ON,  ON,  ON, ON**\\n2-nd round:   ON, **OFF**,  ON, **OFF**, ON\\n3-rd round :   ON, OFF, **OFF**, OFF, ON\\n4-th round :   ON, OFF, OFF, **ON**, ON\\n5-th round :   ON, OFF, OFF, ON, **OFF**\\n\\nYou can see that, after each round, all bulbs before that round will not be touched anymore.\\n\\nSo, given a bulb at position X, how do I know it will be toggled EVEN/ODD times ?\\nAnswer: We can find the number of divisors of X. \\n\\nfor example, if the position of a bulb is 3, its divisor is [1,3], that mean we will toggle the 3-rd bulb at 1-st round and 3-rd round:\\nCombine the observation above, \\nat ***3-rd*** round, the third bulb will have been toggeld even times ( [1,3] ), so it is OFF. And it will not be changed later on round.\\nat ***5-th*** round, the fifth bulb will have been toggled even times ( [1,5] ), so it is OFF. And it will not be changed later on round.\\n\\nSuppose we have a func to get all divisors of i : **getDivisors(int)**, a simple algorithm can be deduced:\\n`for i = 1..n, if getDivisors(i) % 2 == 1, count++;`\\nWe loop through all positions, if it has odd number of divisors, it is ON and hence count + 1.\\n\\nUnfortunately, it will timeout. How to optimize ?\\n\\nObservation #3:\\nDivisors always come in pair. For example:\\n1: [1,1]  ---  2: [1,2] --- 3: [1,3] --- 4: [1,4] [2,2] --- 5:[1,5] --- 6:[1,6][2,3] --- 7:[1,7] \\n8: [1,8][2,4] --- 9:[1,9][3,3]\\n\\nIn above examples, we know that: \\nOnly when ***i*** has **perfect square root**, its number of divisors is ODD, because it contains duplicated divisor. In above example,\\n4: [1,2,4] --- 9: [1,3,9]\\nYou can pick any number to examine yourself.\\n\\nHere comes a better algorithm:\\n`for i = 1...n,  if i^2 <= n, count++ ; if i^2 > n, break;`\\nWe loop through all position, if **i^2** is <= n, that means there exists a valid bulb which has perfect square root ***i***, and we need to count that **i^2**, so count + 1. If the **i^2** exceed n, we can terminate it because we have found all ***i*** with perfect square root within n already.\\n\\nMany of you might have seen the answer, so why the answer can be simply written as Math.sqrt(n) ?\\nconsider n = 9, the process of aforementioned algorithm will be: \\ncheck (1 * 1 ) <= 9, count++\\ncheck (2 * 2 ) <= 9, count++;\\ncheck (3 * 3) <= 9, count++;\\ncheck (4 * 4) > 9, break;\\n\\nWe can say, if square root of 9 is 3, that mean **1^2** and **2^2** must exists for n = 9. Hence, the Math.sqrt(i) reflect this fact.\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "I got to observation 2 on my own. The condition for an odd number of divisors was eluding me, thanks for the help"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "mind glowing explanation\\n"
                    },
                    {
                        "username": "saidfgn",
                        "content": "Great explanation, thanks!"
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "**Its more like a puzzle rather than a coding problem**"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "[@yusufm09](/yusufm09) brain tester problem means does they ask this in interviews"
                    },
                    {
                        "username": "yusufm09",
                        "content": "[@jerryy147](/jerryy147) I never knew that there was a brainteaser problem list. Thanks."
                    },
                    {
                        "username": "jerryy147",
                        "content": "that\\'s why it\\'s in the \"brainteaser\" problem list"
                    },
                    {
                        "username": "strongwillow",
                        "content": "It only stated the first, second, third, and last round. Should be updated as follows:\\n\\nThere are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). **For the ith round, you toggle every i bulb.** For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds."
                    },
                    {
                        "username": "sx1w",
                        "content": "Like many of you are wondering why a simple sqaure root solution to the problem, I wanted to find out why that is correct. Here is my little research into it. \\n\\nThe light bulb at postion k must be toggled in odd number to stay on, e.g. \\'On, Off, On\\' including the initial toggle. What triggers k-th bulb be toggled? Number k must be an **exact** multiple of each toggling. For example, when k=4, the bulb will be triggered by the 1st (On), 2nd (Off) and 4th (On) operation. What is the exact number of multiple of a nature number k? **All of its factors** ! \\n\\nSo the k-th bulb \\'ON\\' is corresponding to the number of factors of k being odd. You can certainly develop a program to count. However, the [*number math*](http://mathcentral.uregina.ca/QQ/database/QQ.09.06/jacqueline1.html) tells us only perfect square numbers have odd number of factors, which is what needed for the bulb to stay on. \\n\\nGreat! Now to solve the problem is to find out how many perfect square number between 1 and n. The [*math*](https://www.quora.com/How-many-perfect-squares-are-there-between-1-to-1000) kicks in again, and that number is the square root of n (more preceisly the floor of sqaure root of n). \\n\\nWhat a great problem!"
                    },
                    {
                        "username": "bharathb",
                        "content": "A lot of other posts provide code / suggest a simulation to see the pattern. I will attempt to describe the intuition behind the solution. \\n\\n* First let s identify all the bulbs that can touch/affect/toggle bulb X. Bulb X can only be toggled by other bulbs which are less than or equal to X. For example, 26 will never toggle bulb 23.\\n* Secondly, for a bulb X what are the bulbs that can toggle X? 23 can never toggle 25. We notice that a bulb X can only be toggled by divisors of X - including 1 and X itself. \\n* Now let s consider prime numbers. Prime numbers by definition have exactly two divisors. Any number with 2 divisors will never be ON at the end - because 1 will set it to ON and the second divisor (the prime number itself) will toggle it off.\\n* With prime numbers gone, lets consider a composite number with an even number of divisors.  Say 24. The divisors of 24 are (1,2,3,4,6,8,12,24). Listing the divisors as pairs - (1, 24) (2,12), (3,8), (4,6) - pairs are crucial because one divisor will set 24 to ON and the other divisor will set it to OFF. So, the net result is that those bulbs will NOT be ON at the end of the simulation - because they are initially OFF. They are toggled an even number of times.\\n* Now, we need to find numbers <=N which have an odd number of divisors. This might not be intuitive immediately and this simulating the problem on paper helps. If we consider a perfect square like 36 and write the divisors in pairs - (1,36), (2,18), (3, 12), (4, 9), (6,6). Now, we can see that while all other divisors cancel each other out - (they toggle the bulb twice) - 6 has no counterpart to toggle the bulb off. So, when there are 36 bulbs, 6 will always be ON at the end. The same holds true for perfect squares less than N - which are 1,4,9,16,25.\\n* Based on the above inferences, we can see that we need to find the numbers less than N that are perfect squares.  We can calculate this (int) Math.sqrt(N) or have a simple for-loop to count (i*i) <=N \\n\\nHope this helps."
                    },
                    {
                        "username": "rajeshkumar1130",
                        "content": "I was asked this question in an interview with microsoft on 22-01-2021"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It just proves that an ordinary position at MS is a dead-end job."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@sandagolcea](/sandagolcea)  Nice solution bro! The code is also quite neat. Good job!"
                    },
                    {
                        "username": "algoacer",
                        "content": "[@code_coffeee](/code_coffeee) Acutally it is so true, some one gets to implement a plain algorithm and someone has to think out of the box in 40 minutes. Not fair. But we should keep applying at multiple companies."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@code_coffeee](/code_coffeee) do you mean a TLE? I've actually solved it differently, using rather simple mathematics, but not sqrt (which i know was quite obvs, but I thought of doing smth else :D ) here https://leetcode.com/problems/bulb-switcher/solutions/3461670/js-solutions-without-using-sqrt/ "
                    },
                    {
                        "username": "l3aonti",
                        "content": "[@dvijay96](/dvijay96) it throws memory limit exception "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@code_coffeee](/code_coffeee) Brute force n^2 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "they what happened bro how did you explain "
                    },
                    {
                        "username": "code_coffeee",
                        "content": "This makes me sad.\\n\\nI feel like if they ask anyone this, they must not want to hire this person. If anyone codes it in any way without using square root, it is  a rejection."
                    },
                    {
                        "username": "bingzhoudaren",
                        "content": "First, we need to figure out how do we know if the ith light is on or off at the end. \\nit dpends on how many numbers could output i after you get product of them.\\nfor example 6, \\nwe will toggle the 6th light in the first round becasue 1 times6=6\\nwe will toggle the 6th light in the second round because 2 times 3=6;\\nwe will toggle the 6th light in third round beacuse 3 times 2 =6;\\nand we will toggle the 6th light in 6th round beacuse 6 times 1=6;\\n\\nso since wil have 1,2,3,6,totally four numbers, we will toggle the 6th light 4 times.\\nand since 4 is even ,so the 6th light will be off at the end.\\n\\nand for example, 9 could have division 1,3,9,  there are three of them. which is odd, so the 9th light is on at the end.\\n\\n\\nthen the problem is to figure out which number have odd divisions, which have even.\\n\\nthen, we should realize that,  for no-square number, the divisions can be paired.\\n\\nfor example, for 6, 1,and 6 is a pair, 2 and 3 is a pair.\\nhowever, for square number, for example 9, 3 will pair by itself, or we could say, 3 does not have a partener to build a pair.\\n\\nso, only lights at square numbers position will be on at the end.\\n\\nso, if we have 10 lights, at the end, only 1,4,9 light will be on.\\n\\n\\nand how to count them? by sqrt(10), we could get 3, which is the number of square numbers smaller than 10\\n\\n\\n\\n"
                    },
                    {
                        "username": "warrenbrodsky",
                        "content": "To begin, let\\'s forget keeping track of *every*  bulb and only think about *one*. Clearly, this bulb can either be on or off.  While obvious, this is still significant. If we know how many times we toggled the bulb, we can figure out which state it is in: If we have a bulb that begins on and we toggle it once, it will be off. Twice, on again. Thrice, off, four times on, five off, six on, etc. OK, so the answer is parity -- even flips it\\'s on, odd it\\'s off. \\n\\nGreat, but we don\\'t flip every bulb on every iteration, so how do we know how many times we flipped it? Ok, well on the first pass, we flip every other bulb, that is, every bulb whose index is a multiple of 2 (assuming indexing starts from 1 ;) ). On the next, we toggle every multiple of 3. On the next, multiples of 4, etc. When we\\'re done, we\\'ll have flipped every bulb once for each number that it is a multiple of, which is to say, once for each *divisor*. (Importantly, we include itself, but not 1.) For example, bulb 6 is flipped off for 2, on for 3, and off one final time for 6. Another important fact is that divisors come in pairs -- it and the thing it has to be multiplied with to get the number. The ***only*** time this isn\\'t true is if the thing it is multiplied by is itself. In other words, it\\'s a perfect square. Therefore perfect squares will *always* have an *odd* number of divisors and all others have *even* numbers of divisors. Since we\\'re not including one as a divisor, the parity flips and therefore, when all is said and done, only bulbs with perfect square indices will remain on.\\n\\nBulk of the work done -- now we just need to know how many perfect squares there are from 1 to n (which I will call squaresLTE(n)) and that will be our answer. This is fairly simple: beginning with n=1 and squaresLTE(1) = 1, we can see squaresLTE(2) is still 1,  squaresLTE(3) is still 1, and we finally get another square when n=4 and squaresLTE(4)=2 -- 1, and 4. We don\\'t add another square to the list until n=the next square. This gives us the final answer:\\n\\n`bulbs(n) = squaresLTE(n) = floor(sqrt(n))`\\n\\nThis works because if we\\'re between two squares a=s^2 and b=(s+1)^2, sqrt(n) will be some number between s and s+1, so floor(sqrt(n)) will bring us down to the sqrt of the last square we added to the list"
                    },
                    {
                        "username": "dilipK",
                        "content": "* If a particular number n is divisible by k , it means it will also  be divisible by n/k. So it will bring it to original state i.e.off. So toggling at kth iteration will turn ON but toggling at (n/k)th iteration will bring it to OFF. So no change.\\n* But for a prefect square sqrt(n) will only toggle it once , so it will be overall ON."
                    },
                    {
                        "username": "suhane",
                        "content": "# Logic : 1st round Bulb is ON, then each switch will OFF then ON. so for any number ->\\n# 1st round : ON\\n# 2nd round : OFF\\n# 3rd round : ON \\n# 4th round : OFF  and so on ....\\n# \\n# **If we can calculate how many times each bulb is switched we can tell it was ON/OFF at the last.**\\n# \\n# from above we can see if we switch bulb EVEN times we get it OFF at last, if switch ODD times we get it ON at the last.**\\n\\n*Now take few examples to understand better-*\\nN=1 -> bulb switched 1 time (for N=1)  \\t\\t\\t-> OFF at last\\n\\nN=2 -> bulb switched 2 times (for N=1, 2) \\t\\t-> OFF at last\\n\\nN=3 -> bulb switched 2 times (for N=1, 3) \\t\\t-> OFF at last\\n\\nN=4 -> bulb switched 3 times (for N=1, 2, 4) \\t-> **ON** at last\\n\\nN=5 -> bulb switched 2 times (for N=1, 5) \\t\\t-> OFF at last\\n\\nN=6 -> bulb switched 4 times (for N=1, 2, 3, 6) -> OFF at last\\n\\nN=7 -> bulb switched 2 times (for N=1, 7)\\t\\t-> OFF at last\\t\\n\\nN=8 -> bulb switched 8* times (for N=1, 2, 4, 8)\\t-> OFF at last\\t\\n(how we got 8 switches -\\nadd all switches of\\nN=1 (1 times at N=1),\\nN=2 (2 times at N=1,2), \\nN=4 (3 times at N=1,2,4) ,\\nN=8 (2 time at N=1,8))\\n\\nN=9 -> bulb switched 3 times (for N=1, 3, 9)\\t-> **ON** at last\\t\\n\\nAs you can see from above we got a conclusion only bulbs which are perfect square will be left ON at the last. (4, 9, 16, 25....) rest all bulbs will be OFF at the last.\\n\\nso we just need to fine how may perfact squares are present for any given N.\\nif N=20 -> 2, 4, 9, 16 (total 4)\\nif N=30 -> 2, 4, 9, 16, 25 (total 5)\\n\\nso we can convert calculating how many perfact sqs to -> simple solution\\n\\n# Ans: round(sqrt(N));\\n\\nBut this 1 line solution we can\\'t find until we know the whole logic that takes long time.\\n\\nHappy Learning !!\\n\\n"
                    }
                ]
            },
            {
                "id": 1566028,
                "content": [
                    {
                        "username": "rexthk",
                        "content": "Below are my step by step thought process. Hope it helps\\n\\nObservation #1:\\nA bulb is ON if it is toggled **odd** times: (ON), (ON -> OFF -> ON), (ON -> OFF -> ON -> OFF -> ON) ...\\nA bulb is OFF if it is toggled **even** times: (ON -> OFF), (ON -> OFF -> ON -> OFF ) ...\\n\\nObservation #2:\\nOnce we reach and toggle the ***i-th*** bulb, it will never be touched anymore.\\n\\nfor exmaple, let n = 5 ( changes in each round denoted as bold ), initial state is all OFF:\\n1-th round :   **ON,  ON,  ON,  ON, ON**\\n2-nd round:   ON, **OFF**,  ON, **OFF**, ON\\n3-rd round :   ON, OFF, **OFF**, OFF, ON\\n4-th round :   ON, OFF, OFF, **ON**, ON\\n5-th round :   ON, OFF, OFF, ON, **OFF**\\n\\nYou can see that, after each round, all bulbs before that round will not be touched anymore.\\n\\nSo, given a bulb at position X, how do I know it will be toggled EVEN/ODD times ?\\nAnswer: We can find the number of divisors of X. \\n\\nfor example, if the position of a bulb is 3, its divisor is [1,3], that mean we will toggle the 3-rd bulb at 1-st round and 3-rd round:\\nCombine the observation above, \\nat ***3-rd*** round, the third bulb will have been toggeld even times ( [1,3] ), so it is OFF. And it will not be changed later on round.\\nat ***5-th*** round, the fifth bulb will have been toggled even times ( [1,5] ), so it is OFF. And it will not be changed later on round.\\n\\nSuppose we have a func to get all divisors of i : **getDivisors(int)**, a simple algorithm can be deduced:\\n`for i = 1..n, if getDivisors(i) % 2 == 1, count++;`\\nWe loop through all positions, if it has odd number of divisors, it is ON and hence count + 1.\\n\\nUnfortunately, it will timeout. How to optimize ?\\n\\nObservation #3:\\nDivisors always come in pair. For example:\\n1: [1,1]  ---  2: [1,2] --- 3: [1,3] --- 4: [1,4] [2,2] --- 5:[1,5] --- 6:[1,6][2,3] --- 7:[1,7] \\n8: [1,8][2,4] --- 9:[1,9][3,3]\\n\\nIn above examples, we know that: \\nOnly when ***i*** has **perfect square root**, its number of divisors is ODD, because it contains duplicated divisor. In above example,\\n4: [1,2,4] --- 9: [1,3,9]\\nYou can pick any number to examine yourself.\\n\\nHere comes a better algorithm:\\n`for i = 1...n,  if i^2 <= n, count++ ; if i^2 > n, break;`\\nWe loop through all position, if **i^2** is <= n, that means there exists a valid bulb which has perfect square root ***i***, and we need to count that **i^2**, so count + 1. If the **i^2** exceed n, we can terminate it because we have found all ***i*** with perfect square root within n already.\\n\\nMany of you might have seen the answer, so why the answer can be simply written as Math.sqrt(n) ?\\nconsider n = 9, the process of aforementioned algorithm will be: \\ncheck (1 * 1 ) <= 9, count++\\ncheck (2 * 2 ) <= 9, count++;\\ncheck (3 * 3) <= 9, count++;\\ncheck (4 * 4) > 9, break;\\n\\nWe can say, if square root of 9 is 3, that mean **1^2** and **2^2** must exists for n = 9. Hence, the Math.sqrt(i) reflect this fact.\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "I got to observation 2 on my own. The condition for an odd number of divisors was eluding me, thanks for the help"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "mind glowing explanation\\n"
                    },
                    {
                        "username": "saidfgn",
                        "content": "Great explanation, thanks!"
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "**Its more like a puzzle rather than a coding problem**"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "[@yusufm09](/yusufm09) brain tester problem means does they ask this in interviews"
                    },
                    {
                        "username": "yusufm09",
                        "content": "[@jerryy147](/jerryy147) I never knew that there was a brainteaser problem list. Thanks."
                    },
                    {
                        "username": "jerryy147",
                        "content": "that\\'s why it\\'s in the \"brainteaser\" problem list"
                    },
                    {
                        "username": "strongwillow",
                        "content": "It only stated the first, second, third, and last round. Should be updated as follows:\\n\\nThere are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). **For the ith round, you toggle every i bulb.** For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds."
                    },
                    {
                        "username": "sx1w",
                        "content": "Like many of you are wondering why a simple sqaure root solution to the problem, I wanted to find out why that is correct. Here is my little research into it. \\n\\nThe light bulb at postion k must be toggled in odd number to stay on, e.g. \\'On, Off, On\\' including the initial toggle. What triggers k-th bulb be toggled? Number k must be an **exact** multiple of each toggling. For example, when k=4, the bulb will be triggered by the 1st (On), 2nd (Off) and 4th (On) operation. What is the exact number of multiple of a nature number k? **All of its factors** ! \\n\\nSo the k-th bulb \\'ON\\' is corresponding to the number of factors of k being odd. You can certainly develop a program to count. However, the [*number math*](http://mathcentral.uregina.ca/QQ/database/QQ.09.06/jacqueline1.html) tells us only perfect square numbers have odd number of factors, which is what needed for the bulb to stay on. \\n\\nGreat! Now to solve the problem is to find out how many perfect square number between 1 and n. The [*math*](https://www.quora.com/How-many-perfect-squares-are-there-between-1-to-1000) kicks in again, and that number is the square root of n (more preceisly the floor of sqaure root of n). \\n\\nWhat a great problem!"
                    },
                    {
                        "username": "bharathb",
                        "content": "A lot of other posts provide code / suggest a simulation to see the pattern. I will attempt to describe the intuition behind the solution. \\n\\n* First let s identify all the bulbs that can touch/affect/toggle bulb X. Bulb X can only be toggled by other bulbs which are less than or equal to X. For example, 26 will never toggle bulb 23.\\n* Secondly, for a bulb X what are the bulbs that can toggle X? 23 can never toggle 25. We notice that a bulb X can only be toggled by divisors of X - including 1 and X itself. \\n* Now let s consider prime numbers. Prime numbers by definition have exactly two divisors. Any number with 2 divisors will never be ON at the end - because 1 will set it to ON and the second divisor (the prime number itself) will toggle it off.\\n* With prime numbers gone, lets consider a composite number with an even number of divisors.  Say 24. The divisors of 24 are (1,2,3,4,6,8,12,24). Listing the divisors as pairs - (1, 24) (2,12), (3,8), (4,6) - pairs are crucial because one divisor will set 24 to ON and the other divisor will set it to OFF. So, the net result is that those bulbs will NOT be ON at the end of the simulation - because they are initially OFF. They are toggled an even number of times.\\n* Now, we need to find numbers <=N which have an odd number of divisors. This might not be intuitive immediately and this simulating the problem on paper helps. If we consider a perfect square like 36 and write the divisors in pairs - (1,36), (2,18), (3, 12), (4, 9), (6,6). Now, we can see that while all other divisors cancel each other out - (they toggle the bulb twice) - 6 has no counterpart to toggle the bulb off. So, when there are 36 bulbs, 6 will always be ON at the end. The same holds true for perfect squares less than N - which are 1,4,9,16,25.\\n* Based on the above inferences, we can see that we need to find the numbers less than N that are perfect squares.  We can calculate this (int) Math.sqrt(N) or have a simple for-loop to count (i*i) <=N \\n\\nHope this helps."
                    },
                    {
                        "username": "rajeshkumar1130",
                        "content": "I was asked this question in an interview with microsoft on 22-01-2021"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It just proves that an ordinary position at MS is a dead-end job."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@sandagolcea](/sandagolcea)  Nice solution bro! The code is also quite neat. Good job!"
                    },
                    {
                        "username": "algoacer",
                        "content": "[@code_coffeee](/code_coffeee) Acutally it is so true, some one gets to implement a plain algorithm and someone has to think out of the box in 40 minutes. Not fair. But we should keep applying at multiple companies."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@code_coffeee](/code_coffeee) do you mean a TLE? I've actually solved it differently, using rather simple mathematics, but not sqrt (which i know was quite obvs, but I thought of doing smth else :D ) here https://leetcode.com/problems/bulb-switcher/solutions/3461670/js-solutions-without-using-sqrt/ "
                    },
                    {
                        "username": "l3aonti",
                        "content": "[@dvijay96](/dvijay96) it throws memory limit exception "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@code_coffeee](/code_coffeee) Brute force n^2 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "they what happened bro how did you explain "
                    },
                    {
                        "username": "code_coffeee",
                        "content": "This makes me sad.\\n\\nI feel like if they ask anyone this, they must not want to hire this person. If anyone codes it in any way without using square root, it is  a rejection."
                    },
                    {
                        "username": "bingzhoudaren",
                        "content": "First, we need to figure out how do we know if the ith light is on or off at the end. \\nit dpends on how many numbers could output i after you get product of them.\\nfor example 6, \\nwe will toggle the 6th light in the first round becasue 1 times6=6\\nwe will toggle the 6th light in the second round because 2 times 3=6;\\nwe will toggle the 6th light in third round beacuse 3 times 2 =6;\\nand we will toggle the 6th light in 6th round beacuse 6 times 1=6;\\n\\nso since wil have 1,2,3,6,totally four numbers, we will toggle the 6th light 4 times.\\nand since 4 is even ,so the 6th light will be off at the end.\\n\\nand for example, 9 could have division 1,3,9,  there are three of them. which is odd, so the 9th light is on at the end.\\n\\n\\nthen the problem is to figure out which number have odd divisions, which have even.\\n\\nthen, we should realize that,  for no-square number, the divisions can be paired.\\n\\nfor example, for 6, 1,and 6 is a pair, 2 and 3 is a pair.\\nhowever, for square number, for example 9, 3 will pair by itself, or we could say, 3 does not have a partener to build a pair.\\n\\nso, only lights at square numbers position will be on at the end.\\n\\nso, if we have 10 lights, at the end, only 1,4,9 light will be on.\\n\\n\\nand how to count them? by sqrt(10), we could get 3, which is the number of square numbers smaller than 10\\n\\n\\n\\n"
                    },
                    {
                        "username": "warrenbrodsky",
                        "content": "To begin, let\\'s forget keeping track of *every*  bulb and only think about *one*. Clearly, this bulb can either be on or off.  While obvious, this is still significant. If we know how many times we toggled the bulb, we can figure out which state it is in: If we have a bulb that begins on and we toggle it once, it will be off. Twice, on again. Thrice, off, four times on, five off, six on, etc. OK, so the answer is parity -- even flips it\\'s on, odd it\\'s off. \\n\\nGreat, but we don\\'t flip every bulb on every iteration, so how do we know how many times we flipped it? Ok, well on the first pass, we flip every other bulb, that is, every bulb whose index is a multiple of 2 (assuming indexing starts from 1 ;) ). On the next, we toggle every multiple of 3. On the next, multiples of 4, etc. When we\\'re done, we\\'ll have flipped every bulb once for each number that it is a multiple of, which is to say, once for each *divisor*. (Importantly, we include itself, but not 1.) For example, bulb 6 is flipped off for 2, on for 3, and off one final time for 6. Another important fact is that divisors come in pairs -- it and the thing it has to be multiplied with to get the number. The ***only*** time this isn\\'t true is if the thing it is multiplied by is itself. In other words, it\\'s a perfect square. Therefore perfect squares will *always* have an *odd* number of divisors and all others have *even* numbers of divisors. Since we\\'re not including one as a divisor, the parity flips and therefore, when all is said and done, only bulbs with perfect square indices will remain on.\\n\\nBulk of the work done -- now we just need to know how many perfect squares there are from 1 to n (which I will call squaresLTE(n)) and that will be our answer. This is fairly simple: beginning with n=1 and squaresLTE(1) = 1, we can see squaresLTE(2) is still 1,  squaresLTE(3) is still 1, and we finally get another square when n=4 and squaresLTE(4)=2 -- 1, and 4. We don\\'t add another square to the list until n=the next square. This gives us the final answer:\\n\\n`bulbs(n) = squaresLTE(n) = floor(sqrt(n))`\\n\\nThis works because if we\\'re between two squares a=s^2 and b=(s+1)^2, sqrt(n) will be some number between s and s+1, so floor(sqrt(n)) will bring us down to the sqrt of the last square we added to the list"
                    },
                    {
                        "username": "dilipK",
                        "content": "* If a particular number n is divisible by k , it means it will also  be divisible by n/k. So it will bring it to original state i.e.off. So toggling at kth iteration will turn ON but toggling at (n/k)th iteration will bring it to OFF. So no change.\\n* But for a prefect square sqrt(n) will only toggle it once , so it will be overall ON."
                    },
                    {
                        "username": "suhane",
                        "content": "# Logic : 1st round Bulb is ON, then each switch will OFF then ON. so for any number ->\\n# 1st round : ON\\n# 2nd round : OFF\\n# 3rd round : ON \\n# 4th round : OFF  and so on ....\\n# \\n# **If we can calculate how many times each bulb is switched we can tell it was ON/OFF at the last.**\\n# \\n# from above we can see if we switch bulb EVEN times we get it OFF at last, if switch ODD times we get it ON at the last.**\\n\\n*Now take few examples to understand better-*\\nN=1 -> bulb switched 1 time (for N=1)  \\t\\t\\t-> OFF at last\\n\\nN=2 -> bulb switched 2 times (for N=1, 2) \\t\\t-> OFF at last\\n\\nN=3 -> bulb switched 2 times (for N=1, 3) \\t\\t-> OFF at last\\n\\nN=4 -> bulb switched 3 times (for N=1, 2, 4) \\t-> **ON** at last\\n\\nN=5 -> bulb switched 2 times (for N=1, 5) \\t\\t-> OFF at last\\n\\nN=6 -> bulb switched 4 times (for N=1, 2, 3, 6) -> OFF at last\\n\\nN=7 -> bulb switched 2 times (for N=1, 7)\\t\\t-> OFF at last\\t\\n\\nN=8 -> bulb switched 8* times (for N=1, 2, 4, 8)\\t-> OFF at last\\t\\n(how we got 8 switches -\\nadd all switches of\\nN=1 (1 times at N=1),\\nN=2 (2 times at N=1,2), \\nN=4 (3 times at N=1,2,4) ,\\nN=8 (2 time at N=1,8))\\n\\nN=9 -> bulb switched 3 times (for N=1, 3, 9)\\t-> **ON** at last\\t\\n\\nAs you can see from above we got a conclusion only bulbs which are perfect square will be left ON at the last. (4, 9, 16, 25....) rest all bulbs will be OFF at the last.\\n\\nso we just need to fine how may perfact squares are present for any given N.\\nif N=20 -> 2, 4, 9, 16 (total 4)\\nif N=30 -> 2, 4, 9, 16, 25 (total 5)\\n\\nso we can convert calculating how many perfact sqs to -> simple solution\\n\\n# Ans: round(sqrt(N));\\n\\nBut this 1 line solution we can\\'t find until we know the whole logic that takes long time.\\n\\nHappy Learning !!\\n\\n"
                    }
                ]
            },
            {
                "id": 1566143,
                "content": [
                    {
                        "username": "rexthk",
                        "content": "Below are my step by step thought process. Hope it helps\\n\\nObservation #1:\\nA bulb is ON if it is toggled **odd** times: (ON), (ON -> OFF -> ON), (ON -> OFF -> ON -> OFF -> ON) ...\\nA bulb is OFF if it is toggled **even** times: (ON -> OFF), (ON -> OFF -> ON -> OFF ) ...\\n\\nObservation #2:\\nOnce we reach and toggle the ***i-th*** bulb, it will never be touched anymore.\\n\\nfor exmaple, let n = 5 ( changes in each round denoted as bold ), initial state is all OFF:\\n1-th round :   **ON,  ON,  ON,  ON, ON**\\n2-nd round:   ON, **OFF**,  ON, **OFF**, ON\\n3-rd round :   ON, OFF, **OFF**, OFF, ON\\n4-th round :   ON, OFF, OFF, **ON**, ON\\n5-th round :   ON, OFF, OFF, ON, **OFF**\\n\\nYou can see that, after each round, all bulbs before that round will not be touched anymore.\\n\\nSo, given a bulb at position X, how do I know it will be toggled EVEN/ODD times ?\\nAnswer: We can find the number of divisors of X. \\n\\nfor example, if the position of a bulb is 3, its divisor is [1,3], that mean we will toggle the 3-rd bulb at 1-st round and 3-rd round:\\nCombine the observation above, \\nat ***3-rd*** round, the third bulb will have been toggeld even times ( [1,3] ), so it is OFF. And it will not be changed later on round.\\nat ***5-th*** round, the fifth bulb will have been toggled even times ( [1,5] ), so it is OFF. And it will not be changed later on round.\\n\\nSuppose we have a func to get all divisors of i : **getDivisors(int)**, a simple algorithm can be deduced:\\n`for i = 1..n, if getDivisors(i) % 2 == 1, count++;`\\nWe loop through all positions, if it has odd number of divisors, it is ON and hence count + 1.\\n\\nUnfortunately, it will timeout. How to optimize ?\\n\\nObservation #3:\\nDivisors always come in pair. For example:\\n1: [1,1]  ---  2: [1,2] --- 3: [1,3] --- 4: [1,4] [2,2] --- 5:[1,5] --- 6:[1,6][2,3] --- 7:[1,7] \\n8: [1,8][2,4] --- 9:[1,9][3,3]\\n\\nIn above examples, we know that: \\nOnly when ***i*** has **perfect square root**, its number of divisors is ODD, because it contains duplicated divisor. In above example,\\n4: [1,2,4] --- 9: [1,3,9]\\nYou can pick any number to examine yourself.\\n\\nHere comes a better algorithm:\\n`for i = 1...n,  if i^2 <= n, count++ ; if i^2 > n, break;`\\nWe loop through all position, if **i^2** is <= n, that means there exists a valid bulb which has perfect square root ***i***, and we need to count that **i^2**, so count + 1. If the **i^2** exceed n, we can terminate it because we have found all ***i*** with perfect square root within n already.\\n\\nMany of you might have seen the answer, so why the answer can be simply written as Math.sqrt(n) ?\\nconsider n = 9, the process of aforementioned algorithm will be: \\ncheck (1 * 1 ) <= 9, count++\\ncheck (2 * 2 ) <= 9, count++;\\ncheck (3 * 3) <= 9, count++;\\ncheck (4 * 4) > 9, break;\\n\\nWe can say, if square root of 9 is 3, that mean **1^2** and **2^2** must exists for n = 9. Hence, the Math.sqrt(i) reflect this fact.\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "I got to observation 2 on my own. The condition for an odd number of divisors was eluding me, thanks for the help"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "mind glowing explanation\\n"
                    },
                    {
                        "username": "saidfgn",
                        "content": "Great explanation, thanks!"
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "**Its more like a puzzle rather than a coding problem**"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "[@yusufm09](/yusufm09) brain tester problem means does they ask this in interviews"
                    },
                    {
                        "username": "yusufm09",
                        "content": "[@jerryy147](/jerryy147) I never knew that there was a brainteaser problem list. Thanks."
                    },
                    {
                        "username": "jerryy147",
                        "content": "that\\'s why it\\'s in the \"brainteaser\" problem list"
                    },
                    {
                        "username": "strongwillow",
                        "content": "It only stated the first, second, third, and last round. Should be updated as follows:\\n\\nThere are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). **For the ith round, you toggle every i bulb.** For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds."
                    },
                    {
                        "username": "sx1w",
                        "content": "Like many of you are wondering why a simple sqaure root solution to the problem, I wanted to find out why that is correct. Here is my little research into it. \\n\\nThe light bulb at postion k must be toggled in odd number to stay on, e.g. \\'On, Off, On\\' including the initial toggle. What triggers k-th bulb be toggled? Number k must be an **exact** multiple of each toggling. For example, when k=4, the bulb will be triggered by the 1st (On), 2nd (Off) and 4th (On) operation. What is the exact number of multiple of a nature number k? **All of its factors** ! \\n\\nSo the k-th bulb \\'ON\\' is corresponding to the number of factors of k being odd. You can certainly develop a program to count. However, the [*number math*](http://mathcentral.uregina.ca/QQ/database/QQ.09.06/jacqueline1.html) tells us only perfect square numbers have odd number of factors, which is what needed for the bulb to stay on. \\n\\nGreat! Now to solve the problem is to find out how many perfect square number between 1 and n. The [*math*](https://www.quora.com/How-many-perfect-squares-are-there-between-1-to-1000) kicks in again, and that number is the square root of n (more preceisly the floor of sqaure root of n). \\n\\nWhat a great problem!"
                    },
                    {
                        "username": "bharathb",
                        "content": "A lot of other posts provide code / suggest a simulation to see the pattern. I will attempt to describe the intuition behind the solution. \\n\\n* First let s identify all the bulbs that can touch/affect/toggle bulb X. Bulb X can only be toggled by other bulbs which are less than or equal to X. For example, 26 will never toggle bulb 23.\\n* Secondly, for a bulb X what are the bulbs that can toggle X? 23 can never toggle 25. We notice that a bulb X can only be toggled by divisors of X - including 1 and X itself. \\n* Now let s consider prime numbers. Prime numbers by definition have exactly two divisors. Any number with 2 divisors will never be ON at the end - because 1 will set it to ON and the second divisor (the prime number itself) will toggle it off.\\n* With prime numbers gone, lets consider a composite number with an even number of divisors.  Say 24. The divisors of 24 are (1,2,3,4,6,8,12,24). Listing the divisors as pairs - (1, 24) (2,12), (3,8), (4,6) - pairs are crucial because one divisor will set 24 to ON and the other divisor will set it to OFF. So, the net result is that those bulbs will NOT be ON at the end of the simulation - because they are initially OFF. They are toggled an even number of times.\\n* Now, we need to find numbers <=N which have an odd number of divisors. This might not be intuitive immediately and this simulating the problem on paper helps. If we consider a perfect square like 36 and write the divisors in pairs - (1,36), (2,18), (3, 12), (4, 9), (6,6). Now, we can see that while all other divisors cancel each other out - (they toggle the bulb twice) - 6 has no counterpart to toggle the bulb off. So, when there are 36 bulbs, 6 will always be ON at the end. The same holds true for perfect squares less than N - which are 1,4,9,16,25.\\n* Based on the above inferences, we can see that we need to find the numbers less than N that are perfect squares.  We can calculate this (int) Math.sqrt(N) or have a simple for-loop to count (i*i) <=N \\n\\nHope this helps."
                    },
                    {
                        "username": "rajeshkumar1130",
                        "content": "I was asked this question in an interview with microsoft on 22-01-2021"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It just proves that an ordinary position at MS is a dead-end job."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@sandagolcea](/sandagolcea)  Nice solution bro! The code is also quite neat. Good job!"
                    },
                    {
                        "username": "algoacer",
                        "content": "[@code_coffeee](/code_coffeee) Acutally it is so true, some one gets to implement a plain algorithm and someone has to think out of the box in 40 minutes. Not fair. But we should keep applying at multiple companies."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@code_coffeee](/code_coffeee) do you mean a TLE? I've actually solved it differently, using rather simple mathematics, but not sqrt (which i know was quite obvs, but I thought of doing smth else :D ) here https://leetcode.com/problems/bulb-switcher/solutions/3461670/js-solutions-without-using-sqrt/ "
                    },
                    {
                        "username": "l3aonti",
                        "content": "[@dvijay96](/dvijay96) it throws memory limit exception "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@code_coffeee](/code_coffeee) Brute force n^2 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "they what happened bro how did you explain "
                    },
                    {
                        "username": "code_coffeee",
                        "content": "This makes me sad.\\n\\nI feel like if they ask anyone this, they must not want to hire this person. If anyone codes it in any way without using square root, it is  a rejection."
                    },
                    {
                        "username": "bingzhoudaren",
                        "content": "First, we need to figure out how do we know if the ith light is on or off at the end. \\nit dpends on how many numbers could output i after you get product of them.\\nfor example 6, \\nwe will toggle the 6th light in the first round becasue 1 times6=6\\nwe will toggle the 6th light in the second round because 2 times 3=6;\\nwe will toggle the 6th light in third round beacuse 3 times 2 =6;\\nand we will toggle the 6th light in 6th round beacuse 6 times 1=6;\\n\\nso since wil have 1,2,3,6,totally four numbers, we will toggle the 6th light 4 times.\\nand since 4 is even ,so the 6th light will be off at the end.\\n\\nand for example, 9 could have division 1,3,9,  there are three of them. which is odd, so the 9th light is on at the end.\\n\\n\\nthen the problem is to figure out which number have odd divisions, which have even.\\n\\nthen, we should realize that,  for no-square number, the divisions can be paired.\\n\\nfor example, for 6, 1,and 6 is a pair, 2 and 3 is a pair.\\nhowever, for square number, for example 9, 3 will pair by itself, or we could say, 3 does not have a partener to build a pair.\\n\\nso, only lights at square numbers position will be on at the end.\\n\\nso, if we have 10 lights, at the end, only 1,4,9 light will be on.\\n\\n\\nand how to count them? by sqrt(10), we could get 3, which is the number of square numbers smaller than 10\\n\\n\\n\\n"
                    },
                    {
                        "username": "warrenbrodsky",
                        "content": "To begin, let\\'s forget keeping track of *every*  bulb and only think about *one*. Clearly, this bulb can either be on or off.  While obvious, this is still significant. If we know how many times we toggled the bulb, we can figure out which state it is in: If we have a bulb that begins on and we toggle it once, it will be off. Twice, on again. Thrice, off, four times on, five off, six on, etc. OK, so the answer is parity -- even flips it\\'s on, odd it\\'s off. \\n\\nGreat, but we don\\'t flip every bulb on every iteration, so how do we know how many times we flipped it? Ok, well on the first pass, we flip every other bulb, that is, every bulb whose index is a multiple of 2 (assuming indexing starts from 1 ;) ). On the next, we toggle every multiple of 3. On the next, multiples of 4, etc. When we\\'re done, we\\'ll have flipped every bulb once for each number that it is a multiple of, which is to say, once for each *divisor*. (Importantly, we include itself, but not 1.) For example, bulb 6 is flipped off for 2, on for 3, and off one final time for 6. Another important fact is that divisors come in pairs -- it and the thing it has to be multiplied with to get the number. The ***only*** time this isn\\'t true is if the thing it is multiplied by is itself. In other words, it\\'s a perfect square. Therefore perfect squares will *always* have an *odd* number of divisors and all others have *even* numbers of divisors. Since we\\'re not including one as a divisor, the parity flips and therefore, when all is said and done, only bulbs with perfect square indices will remain on.\\n\\nBulk of the work done -- now we just need to know how many perfect squares there are from 1 to n (which I will call squaresLTE(n)) and that will be our answer. This is fairly simple: beginning with n=1 and squaresLTE(1) = 1, we can see squaresLTE(2) is still 1,  squaresLTE(3) is still 1, and we finally get another square when n=4 and squaresLTE(4)=2 -- 1, and 4. We don\\'t add another square to the list until n=the next square. This gives us the final answer:\\n\\n`bulbs(n) = squaresLTE(n) = floor(sqrt(n))`\\n\\nThis works because if we\\'re between two squares a=s^2 and b=(s+1)^2, sqrt(n) will be some number between s and s+1, so floor(sqrt(n)) will bring us down to the sqrt of the last square we added to the list"
                    },
                    {
                        "username": "dilipK",
                        "content": "* If a particular number n is divisible by k , it means it will also  be divisible by n/k. So it will bring it to original state i.e.off. So toggling at kth iteration will turn ON but toggling at (n/k)th iteration will bring it to OFF. So no change.\\n* But for a prefect square sqrt(n) will only toggle it once , so it will be overall ON."
                    },
                    {
                        "username": "suhane",
                        "content": "# Logic : 1st round Bulb is ON, then each switch will OFF then ON. so for any number ->\\n# 1st round : ON\\n# 2nd round : OFF\\n# 3rd round : ON \\n# 4th round : OFF  and so on ....\\n# \\n# **If we can calculate how many times each bulb is switched we can tell it was ON/OFF at the last.**\\n# \\n# from above we can see if we switch bulb EVEN times we get it OFF at last, if switch ODD times we get it ON at the last.**\\n\\n*Now take few examples to understand better-*\\nN=1 -> bulb switched 1 time (for N=1)  \\t\\t\\t-> OFF at last\\n\\nN=2 -> bulb switched 2 times (for N=1, 2) \\t\\t-> OFF at last\\n\\nN=3 -> bulb switched 2 times (for N=1, 3) \\t\\t-> OFF at last\\n\\nN=4 -> bulb switched 3 times (for N=1, 2, 4) \\t-> **ON** at last\\n\\nN=5 -> bulb switched 2 times (for N=1, 5) \\t\\t-> OFF at last\\n\\nN=6 -> bulb switched 4 times (for N=1, 2, 3, 6) -> OFF at last\\n\\nN=7 -> bulb switched 2 times (for N=1, 7)\\t\\t-> OFF at last\\t\\n\\nN=8 -> bulb switched 8* times (for N=1, 2, 4, 8)\\t-> OFF at last\\t\\n(how we got 8 switches -\\nadd all switches of\\nN=1 (1 times at N=1),\\nN=2 (2 times at N=1,2), \\nN=4 (3 times at N=1,2,4) ,\\nN=8 (2 time at N=1,8))\\n\\nN=9 -> bulb switched 3 times (for N=1, 3, 9)\\t-> **ON** at last\\t\\n\\nAs you can see from above we got a conclusion only bulbs which are perfect square will be left ON at the last. (4, 9, 16, 25....) rest all bulbs will be OFF at the last.\\n\\nso we just need to fine how may perfact squares are present for any given N.\\nif N=20 -> 2, 4, 9, 16 (total 4)\\nif N=30 -> 2, 4, 9, 16, 25 (total 5)\\n\\nso we can convert calculating how many perfact sqs to -> simple solution\\n\\n# Ans: round(sqrt(N));\\n\\nBut this 1 line solution we can\\'t find until we know the whole logic that takes long time.\\n\\nHappy Learning !!\\n\\n"
                    }
                ]
            },
            {
                "id": 1566635,
                "content": [
                    {
                        "username": "rexthk",
                        "content": "Below are my step by step thought process. Hope it helps\\n\\nObservation #1:\\nA bulb is ON if it is toggled **odd** times: (ON), (ON -> OFF -> ON), (ON -> OFF -> ON -> OFF -> ON) ...\\nA bulb is OFF if it is toggled **even** times: (ON -> OFF), (ON -> OFF -> ON -> OFF ) ...\\n\\nObservation #2:\\nOnce we reach and toggle the ***i-th*** bulb, it will never be touched anymore.\\n\\nfor exmaple, let n = 5 ( changes in each round denoted as bold ), initial state is all OFF:\\n1-th round :   **ON,  ON,  ON,  ON, ON**\\n2-nd round:   ON, **OFF**,  ON, **OFF**, ON\\n3-rd round :   ON, OFF, **OFF**, OFF, ON\\n4-th round :   ON, OFF, OFF, **ON**, ON\\n5-th round :   ON, OFF, OFF, ON, **OFF**\\n\\nYou can see that, after each round, all bulbs before that round will not be touched anymore.\\n\\nSo, given a bulb at position X, how do I know it will be toggled EVEN/ODD times ?\\nAnswer: We can find the number of divisors of X. \\n\\nfor example, if the position of a bulb is 3, its divisor is [1,3], that mean we will toggle the 3-rd bulb at 1-st round and 3-rd round:\\nCombine the observation above, \\nat ***3-rd*** round, the third bulb will have been toggeld even times ( [1,3] ), so it is OFF. And it will not be changed later on round.\\nat ***5-th*** round, the fifth bulb will have been toggled even times ( [1,5] ), so it is OFF. And it will not be changed later on round.\\n\\nSuppose we have a func to get all divisors of i : **getDivisors(int)**, a simple algorithm can be deduced:\\n`for i = 1..n, if getDivisors(i) % 2 == 1, count++;`\\nWe loop through all positions, if it has odd number of divisors, it is ON and hence count + 1.\\n\\nUnfortunately, it will timeout. How to optimize ?\\n\\nObservation #3:\\nDivisors always come in pair. For example:\\n1: [1,1]  ---  2: [1,2] --- 3: [1,3] --- 4: [1,4] [2,2] --- 5:[1,5] --- 6:[1,6][2,3] --- 7:[1,7] \\n8: [1,8][2,4] --- 9:[1,9][3,3]\\n\\nIn above examples, we know that: \\nOnly when ***i*** has **perfect square root**, its number of divisors is ODD, because it contains duplicated divisor. In above example,\\n4: [1,2,4] --- 9: [1,3,9]\\nYou can pick any number to examine yourself.\\n\\nHere comes a better algorithm:\\n`for i = 1...n,  if i^2 <= n, count++ ; if i^2 > n, break;`\\nWe loop through all position, if **i^2** is <= n, that means there exists a valid bulb which has perfect square root ***i***, and we need to count that **i^2**, so count + 1. If the **i^2** exceed n, we can terminate it because we have found all ***i*** with perfect square root within n already.\\n\\nMany of you might have seen the answer, so why the answer can be simply written as Math.sqrt(n) ?\\nconsider n = 9, the process of aforementioned algorithm will be: \\ncheck (1 * 1 ) <= 9, count++\\ncheck (2 * 2 ) <= 9, count++;\\ncheck (3 * 3) <= 9, count++;\\ncheck (4 * 4) > 9, break;\\n\\nWe can say, if square root of 9 is 3, that mean **1^2** and **2^2** must exists for n = 9. Hence, the Math.sqrt(i) reflect this fact.\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "I got to observation 2 on my own. The condition for an odd number of divisors was eluding me, thanks for the help"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "mind glowing explanation\\n"
                    },
                    {
                        "username": "saidfgn",
                        "content": "Great explanation, thanks!"
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "**Its more like a puzzle rather than a coding problem**"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "[@yusufm09](/yusufm09) brain tester problem means does they ask this in interviews"
                    },
                    {
                        "username": "yusufm09",
                        "content": "[@jerryy147](/jerryy147) I never knew that there was a brainteaser problem list. Thanks."
                    },
                    {
                        "username": "jerryy147",
                        "content": "that\\'s why it\\'s in the \"brainteaser\" problem list"
                    },
                    {
                        "username": "strongwillow",
                        "content": "It only stated the first, second, third, and last round. Should be updated as follows:\\n\\nThere are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). **For the ith round, you toggle every i bulb.** For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds."
                    },
                    {
                        "username": "sx1w",
                        "content": "Like many of you are wondering why a simple sqaure root solution to the problem, I wanted to find out why that is correct. Here is my little research into it. \\n\\nThe light bulb at postion k must be toggled in odd number to stay on, e.g. \\'On, Off, On\\' including the initial toggle. What triggers k-th bulb be toggled? Number k must be an **exact** multiple of each toggling. For example, when k=4, the bulb will be triggered by the 1st (On), 2nd (Off) and 4th (On) operation. What is the exact number of multiple of a nature number k? **All of its factors** ! \\n\\nSo the k-th bulb \\'ON\\' is corresponding to the number of factors of k being odd. You can certainly develop a program to count. However, the [*number math*](http://mathcentral.uregina.ca/QQ/database/QQ.09.06/jacqueline1.html) tells us only perfect square numbers have odd number of factors, which is what needed for the bulb to stay on. \\n\\nGreat! Now to solve the problem is to find out how many perfect square number between 1 and n. The [*math*](https://www.quora.com/How-many-perfect-squares-are-there-between-1-to-1000) kicks in again, and that number is the square root of n (more preceisly the floor of sqaure root of n). \\n\\nWhat a great problem!"
                    },
                    {
                        "username": "bharathb",
                        "content": "A lot of other posts provide code / suggest a simulation to see the pattern. I will attempt to describe the intuition behind the solution. \\n\\n* First let s identify all the bulbs that can touch/affect/toggle bulb X. Bulb X can only be toggled by other bulbs which are less than or equal to X. For example, 26 will never toggle bulb 23.\\n* Secondly, for a bulb X what are the bulbs that can toggle X? 23 can never toggle 25. We notice that a bulb X can only be toggled by divisors of X - including 1 and X itself. \\n* Now let s consider prime numbers. Prime numbers by definition have exactly two divisors. Any number with 2 divisors will never be ON at the end - because 1 will set it to ON and the second divisor (the prime number itself) will toggle it off.\\n* With prime numbers gone, lets consider a composite number with an even number of divisors.  Say 24. The divisors of 24 are (1,2,3,4,6,8,12,24). Listing the divisors as pairs - (1, 24) (2,12), (3,8), (4,6) - pairs are crucial because one divisor will set 24 to ON and the other divisor will set it to OFF. So, the net result is that those bulbs will NOT be ON at the end of the simulation - because they are initially OFF. They are toggled an even number of times.\\n* Now, we need to find numbers <=N which have an odd number of divisors. This might not be intuitive immediately and this simulating the problem on paper helps. If we consider a perfect square like 36 and write the divisors in pairs - (1,36), (2,18), (3, 12), (4, 9), (6,6). Now, we can see that while all other divisors cancel each other out - (they toggle the bulb twice) - 6 has no counterpart to toggle the bulb off. So, when there are 36 bulbs, 6 will always be ON at the end. The same holds true for perfect squares less than N - which are 1,4,9,16,25.\\n* Based on the above inferences, we can see that we need to find the numbers less than N that are perfect squares.  We can calculate this (int) Math.sqrt(N) or have a simple for-loop to count (i*i) <=N \\n\\nHope this helps."
                    },
                    {
                        "username": "rajeshkumar1130",
                        "content": "I was asked this question in an interview with microsoft on 22-01-2021"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It just proves that an ordinary position at MS is a dead-end job."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@sandagolcea](/sandagolcea)  Nice solution bro! The code is also quite neat. Good job!"
                    },
                    {
                        "username": "algoacer",
                        "content": "[@code_coffeee](/code_coffeee) Acutally it is so true, some one gets to implement a plain algorithm and someone has to think out of the box in 40 minutes. Not fair. But we should keep applying at multiple companies."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@code_coffeee](/code_coffeee) do you mean a TLE? I've actually solved it differently, using rather simple mathematics, but not sqrt (which i know was quite obvs, but I thought of doing smth else :D ) here https://leetcode.com/problems/bulb-switcher/solutions/3461670/js-solutions-without-using-sqrt/ "
                    },
                    {
                        "username": "l3aonti",
                        "content": "[@dvijay96](/dvijay96) it throws memory limit exception "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@code_coffeee](/code_coffeee) Brute force n^2 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "they what happened bro how did you explain "
                    },
                    {
                        "username": "code_coffeee",
                        "content": "This makes me sad.\\n\\nI feel like if they ask anyone this, they must not want to hire this person. If anyone codes it in any way without using square root, it is  a rejection."
                    },
                    {
                        "username": "bingzhoudaren",
                        "content": "First, we need to figure out how do we know if the ith light is on or off at the end. \\nit dpends on how many numbers could output i after you get product of them.\\nfor example 6, \\nwe will toggle the 6th light in the first round becasue 1 times6=6\\nwe will toggle the 6th light in the second round because 2 times 3=6;\\nwe will toggle the 6th light in third round beacuse 3 times 2 =6;\\nand we will toggle the 6th light in 6th round beacuse 6 times 1=6;\\n\\nso since wil have 1,2,3,6,totally four numbers, we will toggle the 6th light 4 times.\\nand since 4 is even ,so the 6th light will be off at the end.\\n\\nand for example, 9 could have division 1,3,9,  there are three of them. which is odd, so the 9th light is on at the end.\\n\\n\\nthen the problem is to figure out which number have odd divisions, which have even.\\n\\nthen, we should realize that,  for no-square number, the divisions can be paired.\\n\\nfor example, for 6, 1,and 6 is a pair, 2 and 3 is a pair.\\nhowever, for square number, for example 9, 3 will pair by itself, or we could say, 3 does not have a partener to build a pair.\\n\\nso, only lights at square numbers position will be on at the end.\\n\\nso, if we have 10 lights, at the end, only 1,4,9 light will be on.\\n\\n\\nand how to count them? by sqrt(10), we could get 3, which is the number of square numbers smaller than 10\\n\\n\\n\\n"
                    },
                    {
                        "username": "warrenbrodsky",
                        "content": "To begin, let\\'s forget keeping track of *every*  bulb and only think about *one*. Clearly, this bulb can either be on or off.  While obvious, this is still significant. If we know how many times we toggled the bulb, we can figure out which state it is in: If we have a bulb that begins on and we toggle it once, it will be off. Twice, on again. Thrice, off, four times on, five off, six on, etc. OK, so the answer is parity -- even flips it\\'s on, odd it\\'s off. \\n\\nGreat, but we don\\'t flip every bulb on every iteration, so how do we know how many times we flipped it? Ok, well on the first pass, we flip every other bulb, that is, every bulb whose index is a multiple of 2 (assuming indexing starts from 1 ;) ). On the next, we toggle every multiple of 3. On the next, multiples of 4, etc. When we\\'re done, we\\'ll have flipped every bulb once for each number that it is a multiple of, which is to say, once for each *divisor*. (Importantly, we include itself, but not 1.) For example, bulb 6 is flipped off for 2, on for 3, and off one final time for 6. Another important fact is that divisors come in pairs -- it and the thing it has to be multiplied with to get the number. The ***only*** time this isn\\'t true is if the thing it is multiplied by is itself. In other words, it\\'s a perfect square. Therefore perfect squares will *always* have an *odd* number of divisors and all others have *even* numbers of divisors. Since we\\'re not including one as a divisor, the parity flips and therefore, when all is said and done, only bulbs with perfect square indices will remain on.\\n\\nBulk of the work done -- now we just need to know how many perfect squares there are from 1 to n (which I will call squaresLTE(n)) and that will be our answer. This is fairly simple: beginning with n=1 and squaresLTE(1) = 1, we can see squaresLTE(2) is still 1,  squaresLTE(3) is still 1, and we finally get another square when n=4 and squaresLTE(4)=2 -- 1, and 4. We don\\'t add another square to the list until n=the next square. This gives us the final answer:\\n\\n`bulbs(n) = squaresLTE(n) = floor(sqrt(n))`\\n\\nThis works because if we\\'re between two squares a=s^2 and b=(s+1)^2, sqrt(n) will be some number between s and s+1, so floor(sqrt(n)) will bring us down to the sqrt of the last square we added to the list"
                    },
                    {
                        "username": "dilipK",
                        "content": "* If a particular number n is divisible by k , it means it will also  be divisible by n/k. So it will bring it to original state i.e.off. So toggling at kth iteration will turn ON but toggling at (n/k)th iteration will bring it to OFF. So no change.\\n* But for a prefect square sqrt(n) will only toggle it once , so it will be overall ON."
                    },
                    {
                        "username": "suhane",
                        "content": "# Logic : 1st round Bulb is ON, then each switch will OFF then ON. so for any number ->\\n# 1st round : ON\\n# 2nd round : OFF\\n# 3rd round : ON \\n# 4th round : OFF  and so on ....\\n# \\n# **If we can calculate how many times each bulb is switched we can tell it was ON/OFF at the last.**\\n# \\n# from above we can see if we switch bulb EVEN times we get it OFF at last, if switch ODD times we get it ON at the last.**\\n\\n*Now take few examples to understand better-*\\nN=1 -> bulb switched 1 time (for N=1)  \\t\\t\\t-> OFF at last\\n\\nN=2 -> bulb switched 2 times (for N=1, 2) \\t\\t-> OFF at last\\n\\nN=3 -> bulb switched 2 times (for N=1, 3) \\t\\t-> OFF at last\\n\\nN=4 -> bulb switched 3 times (for N=1, 2, 4) \\t-> **ON** at last\\n\\nN=5 -> bulb switched 2 times (for N=1, 5) \\t\\t-> OFF at last\\n\\nN=6 -> bulb switched 4 times (for N=1, 2, 3, 6) -> OFF at last\\n\\nN=7 -> bulb switched 2 times (for N=1, 7)\\t\\t-> OFF at last\\t\\n\\nN=8 -> bulb switched 8* times (for N=1, 2, 4, 8)\\t-> OFF at last\\t\\n(how we got 8 switches -\\nadd all switches of\\nN=1 (1 times at N=1),\\nN=2 (2 times at N=1,2), \\nN=4 (3 times at N=1,2,4) ,\\nN=8 (2 time at N=1,8))\\n\\nN=9 -> bulb switched 3 times (for N=1, 3, 9)\\t-> **ON** at last\\t\\n\\nAs you can see from above we got a conclusion only bulbs which are perfect square will be left ON at the last. (4, 9, 16, 25....) rest all bulbs will be OFF at the last.\\n\\nso we just need to fine how may perfact squares are present for any given N.\\nif N=20 -> 2, 4, 9, 16 (total 4)\\nif N=30 -> 2, 4, 9, 16, 25 (total 5)\\n\\nso we can convert calculating how many perfact sqs to -> simple solution\\n\\n# Ans: round(sqrt(N));\\n\\nBut this 1 line solution we can\\'t find until we know the whole logic that takes long time.\\n\\nHappy Learning !!\\n\\n"
                    }
                ]
            },
            {
                "id": 1566361,
                "content": [
                    {
                        "username": "rexthk",
                        "content": "Below are my step by step thought process. Hope it helps\\n\\nObservation #1:\\nA bulb is ON if it is toggled **odd** times: (ON), (ON -> OFF -> ON), (ON -> OFF -> ON -> OFF -> ON) ...\\nA bulb is OFF if it is toggled **even** times: (ON -> OFF), (ON -> OFF -> ON -> OFF ) ...\\n\\nObservation #2:\\nOnce we reach and toggle the ***i-th*** bulb, it will never be touched anymore.\\n\\nfor exmaple, let n = 5 ( changes in each round denoted as bold ), initial state is all OFF:\\n1-th round :   **ON,  ON,  ON,  ON, ON**\\n2-nd round:   ON, **OFF**,  ON, **OFF**, ON\\n3-rd round :   ON, OFF, **OFF**, OFF, ON\\n4-th round :   ON, OFF, OFF, **ON**, ON\\n5-th round :   ON, OFF, OFF, ON, **OFF**\\n\\nYou can see that, after each round, all bulbs before that round will not be touched anymore.\\n\\nSo, given a bulb at position X, how do I know it will be toggled EVEN/ODD times ?\\nAnswer: We can find the number of divisors of X. \\n\\nfor example, if the position of a bulb is 3, its divisor is [1,3], that mean we will toggle the 3-rd bulb at 1-st round and 3-rd round:\\nCombine the observation above, \\nat ***3-rd*** round, the third bulb will have been toggeld even times ( [1,3] ), so it is OFF. And it will not be changed later on round.\\nat ***5-th*** round, the fifth bulb will have been toggled even times ( [1,5] ), so it is OFF. And it will not be changed later on round.\\n\\nSuppose we have a func to get all divisors of i : **getDivisors(int)**, a simple algorithm can be deduced:\\n`for i = 1..n, if getDivisors(i) % 2 == 1, count++;`\\nWe loop through all positions, if it has odd number of divisors, it is ON and hence count + 1.\\n\\nUnfortunately, it will timeout. How to optimize ?\\n\\nObservation #3:\\nDivisors always come in pair. For example:\\n1: [1,1]  ---  2: [1,2] --- 3: [1,3] --- 4: [1,4] [2,2] --- 5:[1,5] --- 6:[1,6][2,3] --- 7:[1,7] \\n8: [1,8][2,4] --- 9:[1,9][3,3]\\n\\nIn above examples, we know that: \\nOnly when ***i*** has **perfect square root**, its number of divisors is ODD, because it contains duplicated divisor. In above example,\\n4: [1,2,4] --- 9: [1,3,9]\\nYou can pick any number to examine yourself.\\n\\nHere comes a better algorithm:\\n`for i = 1...n,  if i^2 <= n, count++ ; if i^2 > n, break;`\\nWe loop through all position, if **i^2** is <= n, that means there exists a valid bulb which has perfect square root ***i***, and we need to count that **i^2**, so count + 1. If the **i^2** exceed n, we can terminate it because we have found all ***i*** with perfect square root within n already.\\n\\nMany of you might have seen the answer, so why the answer can be simply written as Math.sqrt(n) ?\\nconsider n = 9, the process of aforementioned algorithm will be: \\ncheck (1 * 1 ) <= 9, count++\\ncheck (2 * 2 ) <= 9, count++;\\ncheck (3 * 3) <= 9, count++;\\ncheck (4 * 4) > 9, break;\\n\\nWe can say, if square root of 9 is 3, that mean **1^2** and **2^2** must exists for n = 9. Hence, the Math.sqrt(i) reflect this fact.\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "I got to observation 2 on my own. The condition for an odd number of divisors was eluding me, thanks for the help"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "mind glowing explanation\\n"
                    },
                    {
                        "username": "saidfgn",
                        "content": "Great explanation, thanks!"
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "**Its more like a puzzle rather than a coding problem**"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "[@yusufm09](/yusufm09) brain tester problem means does they ask this in interviews"
                    },
                    {
                        "username": "yusufm09",
                        "content": "[@jerryy147](/jerryy147) I never knew that there was a brainteaser problem list. Thanks."
                    },
                    {
                        "username": "jerryy147",
                        "content": "that\\'s why it\\'s in the \"brainteaser\" problem list"
                    },
                    {
                        "username": "strongwillow",
                        "content": "It only stated the first, second, third, and last round. Should be updated as follows:\\n\\nThere are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). **For the ith round, you toggle every i bulb.** For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds."
                    },
                    {
                        "username": "sx1w",
                        "content": "Like many of you are wondering why a simple sqaure root solution to the problem, I wanted to find out why that is correct. Here is my little research into it. \\n\\nThe light bulb at postion k must be toggled in odd number to stay on, e.g. \\'On, Off, On\\' including the initial toggle. What triggers k-th bulb be toggled? Number k must be an **exact** multiple of each toggling. For example, when k=4, the bulb will be triggered by the 1st (On), 2nd (Off) and 4th (On) operation. What is the exact number of multiple of a nature number k? **All of its factors** ! \\n\\nSo the k-th bulb \\'ON\\' is corresponding to the number of factors of k being odd. You can certainly develop a program to count. However, the [*number math*](http://mathcentral.uregina.ca/QQ/database/QQ.09.06/jacqueline1.html) tells us only perfect square numbers have odd number of factors, which is what needed for the bulb to stay on. \\n\\nGreat! Now to solve the problem is to find out how many perfect square number between 1 and n. The [*math*](https://www.quora.com/How-many-perfect-squares-are-there-between-1-to-1000) kicks in again, and that number is the square root of n (more preceisly the floor of sqaure root of n). \\n\\nWhat a great problem!"
                    },
                    {
                        "username": "bharathb",
                        "content": "A lot of other posts provide code / suggest a simulation to see the pattern. I will attempt to describe the intuition behind the solution. \\n\\n* First let s identify all the bulbs that can touch/affect/toggle bulb X. Bulb X can only be toggled by other bulbs which are less than or equal to X. For example, 26 will never toggle bulb 23.\\n* Secondly, for a bulb X what are the bulbs that can toggle X? 23 can never toggle 25. We notice that a bulb X can only be toggled by divisors of X - including 1 and X itself. \\n* Now let s consider prime numbers. Prime numbers by definition have exactly two divisors. Any number with 2 divisors will never be ON at the end - because 1 will set it to ON and the second divisor (the prime number itself) will toggle it off.\\n* With prime numbers gone, lets consider a composite number with an even number of divisors.  Say 24. The divisors of 24 are (1,2,3,4,6,8,12,24). Listing the divisors as pairs - (1, 24) (2,12), (3,8), (4,6) - pairs are crucial because one divisor will set 24 to ON and the other divisor will set it to OFF. So, the net result is that those bulbs will NOT be ON at the end of the simulation - because they are initially OFF. They are toggled an even number of times.\\n* Now, we need to find numbers <=N which have an odd number of divisors. This might not be intuitive immediately and this simulating the problem on paper helps. If we consider a perfect square like 36 and write the divisors in pairs - (1,36), (2,18), (3, 12), (4, 9), (6,6). Now, we can see that while all other divisors cancel each other out - (they toggle the bulb twice) - 6 has no counterpart to toggle the bulb off. So, when there are 36 bulbs, 6 will always be ON at the end. The same holds true for perfect squares less than N - which are 1,4,9,16,25.\\n* Based on the above inferences, we can see that we need to find the numbers less than N that are perfect squares.  We can calculate this (int) Math.sqrt(N) or have a simple for-loop to count (i*i) <=N \\n\\nHope this helps."
                    },
                    {
                        "username": "rajeshkumar1130",
                        "content": "I was asked this question in an interview with microsoft on 22-01-2021"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It just proves that an ordinary position at MS is a dead-end job."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@sandagolcea](/sandagolcea)  Nice solution bro! The code is also quite neat. Good job!"
                    },
                    {
                        "username": "algoacer",
                        "content": "[@code_coffeee](/code_coffeee) Acutally it is so true, some one gets to implement a plain algorithm and someone has to think out of the box in 40 minutes. Not fair. But we should keep applying at multiple companies."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@code_coffeee](/code_coffeee) do you mean a TLE? I've actually solved it differently, using rather simple mathematics, but not sqrt (which i know was quite obvs, but I thought of doing smth else :D ) here https://leetcode.com/problems/bulb-switcher/solutions/3461670/js-solutions-without-using-sqrt/ "
                    },
                    {
                        "username": "l3aonti",
                        "content": "[@dvijay96](/dvijay96) it throws memory limit exception "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@code_coffeee](/code_coffeee) Brute force n^2 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "they what happened bro how did you explain "
                    },
                    {
                        "username": "code_coffeee",
                        "content": "This makes me sad.\\n\\nI feel like if they ask anyone this, they must not want to hire this person. If anyone codes it in any way without using square root, it is  a rejection."
                    },
                    {
                        "username": "bingzhoudaren",
                        "content": "First, we need to figure out how do we know if the ith light is on or off at the end. \\nit dpends on how many numbers could output i after you get product of them.\\nfor example 6, \\nwe will toggle the 6th light in the first round becasue 1 times6=6\\nwe will toggle the 6th light in the second round because 2 times 3=6;\\nwe will toggle the 6th light in third round beacuse 3 times 2 =6;\\nand we will toggle the 6th light in 6th round beacuse 6 times 1=6;\\n\\nso since wil have 1,2,3,6,totally four numbers, we will toggle the 6th light 4 times.\\nand since 4 is even ,so the 6th light will be off at the end.\\n\\nand for example, 9 could have division 1,3,9,  there are three of them. which is odd, so the 9th light is on at the end.\\n\\n\\nthen the problem is to figure out which number have odd divisions, which have even.\\n\\nthen, we should realize that,  for no-square number, the divisions can be paired.\\n\\nfor example, for 6, 1,and 6 is a pair, 2 and 3 is a pair.\\nhowever, for square number, for example 9, 3 will pair by itself, or we could say, 3 does not have a partener to build a pair.\\n\\nso, only lights at square numbers position will be on at the end.\\n\\nso, if we have 10 lights, at the end, only 1,4,9 light will be on.\\n\\n\\nand how to count them? by sqrt(10), we could get 3, which is the number of square numbers smaller than 10\\n\\n\\n\\n"
                    },
                    {
                        "username": "warrenbrodsky",
                        "content": "To begin, let\\'s forget keeping track of *every*  bulb and only think about *one*. Clearly, this bulb can either be on or off.  While obvious, this is still significant. If we know how many times we toggled the bulb, we can figure out which state it is in: If we have a bulb that begins on and we toggle it once, it will be off. Twice, on again. Thrice, off, four times on, five off, six on, etc. OK, so the answer is parity -- even flips it\\'s on, odd it\\'s off. \\n\\nGreat, but we don\\'t flip every bulb on every iteration, so how do we know how many times we flipped it? Ok, well on the first pass, we flip every other bulb, that is, every bulb whose index is a multiple of 2 (assuming indexing starts from 1 ;) ). On the next, we toggle every multiple of 3. On the next, multiples of 4, etc. When we\\'re done, we\\'ll have flipped every bulb once for each number that it is a multiple of, which is to say, once for each *divisor*. (Importantly, we include itself, but not 1.) For example, bulb 6 is flipped off for 2, on for 3, and off one final time for 6. Another important fact is that divisors come in pairs -- it and the thing it has to be multiplied with to get the number. The ***only*** time this isn\\'t true is if the thing it is multiplied by is itself. In other words, it\\'s a perfect square. Therefore perfect squares will *always* have an *odd* number of divisors and all others have *even* numbers of divisors. Since we\\'re not including one as a divisor, the parity flips and therefore, when all is said and done, only bulbs with perfect square indices will remain on.\\n\\nBulk of the work done -- now we just need to know how many perfect squares there are from 1 to n (which I will call squaresLTE(n)) and that will be our answer. This is fairly simple: beginning with n=1 and squaresLTE(1) = 1, we can see squaresLTE(2) is still 1,  squaresLTE(3) is still 1, and we finally get another square when n=4 and squaresLTE(4)=2 -- 1, and 4. We don\\'t add another square to the list until n=the next square. This gives us the final answer:\\n\\n`bulbs(n) = squaresLTE(n) = floor(sqrt(n))`\\n\\nThis works because if we\\'re between two squares a=s^2 and b=(s+1)^2, sqrt(n) will be some number between s and s+1, so floor(sqrt(n)) will bring us down to the sqrt of the last square we added to the list"
                    },
                    {
                        "username": "dilipK",
                        "content": "* If a particular number n is divisible by k , it means it will also  be divisible by n/k. So it will bring it to original state i.e.off. So toggling at kth iteration will turn ON but toggling at (n/k)th iteration will bring it to OFF. So no change.\\n* But for a prefect square sqrt(n) will only toggle it once , so it will be overall ON."
                    },
                    {
                        "username": "suhane",
                        "content": "# Logic : 1st round Bulb is ON, then each switch will OFF then ON. so for any number ->\\n# 1st round : ON\\n# 2nd round : OFF\\n# 3rd round : ON \\n# 4th round : OFF  and so on ....\\n# \\n# **If we can calculate how many times each bulb is switched we can tell it was ON/OFF at the last.**\\n# \\n# from above we can see if we switch bulb EVEN times we get it OFF at last, if switch ODD times we get it ON at the last.**\\n\\n*Now take few examples to understand better-*\\nN=1 -> bulb switched 1 time (for N=1)  \\t\\t\\t-> OFF at last\\n\\nN=2 -> bulb switched 2 times (for N=1, 2) \\t\\t-> OFF at last\\n\\nN=3 -> bulb switched 2 times (for N=1, 3) \\t\\t-> OFF at last\\n\\nN=4 -> bulb switched 3 times (for N=1, 2, 4) \\t-> **ON** at last\\n\\nN=5 -> bulb switched 2 times (for N=1, 5) \\t\\t-> OFF at last\\n\\nN=6 -> bulb switched 4 times (for N=1, 2, 3, 6) -> OFF at last\\n\\nN=7 -> bulb switched 2 times (for N=1, 7)\\t\\t-> OFF at last\\t\\n\\nN=8 -> bulb switched 8* times (for N=1, 2, 4, 8)\\t-> OFF at last\\t\\n(how we got 8 switches -\\nadd all switches of\\nN=1 (1 times at N=1),\\nN=2 (2 times at N=1,2), \\nN=4 (3 times at N=1,2,4) ,\\nN=8 (2 time at N=1,8))\\n\\nN=9 -> bulb switched 3 times (for N=1, 3, 9)\\t-> **ON** at last\\t\\n\\nAs you can see from above we got a conclusion only bulbs which are perfect square will be left ON at the last. (4, 9, 16, 25....) rest all bulbs will be OFF at the last.\\n\\nso we just need to fine how may perfact squares are present for any given N.\\nif N=20 -> 2, 4, 9, 16 (total 4)\\nif N=30 -> 2, 4, 9, 16, 25 (total 5)\\n\\nso we can convert calculating how many perfact sqs to -> simple solution\\n\\n# Ans: round(sqrt(N));\\n\\nBut this 1 line solution we can\\'t find until we know the whole logic that takes long time.\\n\\nHappy Learning !!\\n\\n"
                    }
                ]
            },
            {
                "id": 1567066,
                "content": [
                    {
                        "username": "rexthk",
                        "content": "Below are my step by step thought process. Hope it helps\\n\\nObservation #1:\\nA bulb is ON if it is toggled **odd** times: (ON), (ON -> OFF -> ON), (ON -> OFF -> ON -> OFF -> ON) ...\\nA bulb is OFF if it is toggled **even** times: (ON -> OFF), (ON -> OFF -> ON -> OFF ) ...\\n\\nObservation #2:\\nOnce we reach and toggle the ***i-th*** bulb, it will never be touched anymore.\\n\\nfor exmaple, let n = 5 ( changes in each round denoted as bold ), initial state is all OFF:\\n1-th round :   **ON,  ON,  ON,  ON, ON**\\n2-nd round:   ON, **OFF**,  ON, **OFF**, ON\\n3-rd round :   ON, OFF, **OFF**, OFF, ON\\n4-th round :   ON, OFF, OFF, **ON**, ON\\n5-th round :   ON, OFF, OFF, ON, **OFF**\\n\\nYou can see that, after each round, all bulbs before that round will not be touched anymore.\\n\\nSo, given a bulb at position X, how do I know it will be toggled EVEN/ODD times ?\\nAnswer: We can find the number of divisors of X. \\n\\nfor example, if the position of a bulb is 3, its divisor is [1,3], that mean we will toggle the 3-rd bulb at 1-st round and 3-rd round:\\nCombine the observation above, \\nat ***3-rd*** round, the third bulb will have been toggeld even times ( [1,3] ), so it is OFF. And it will not be changed later on round.\\nat ***5-th*** round, the fifth bulb will have been toggled even times ( [1,5] ), so it is OFF. And it will not be changed later on round.\\n\\nSuppose we have a func to get all divisors of i : **getDivisors(int)**, a simple algorithm can be deduced:\\n`for i = 1..n, if getDivisors(i) % 2 == 1, count++;`\\nWe loop through all positions, if it has odd number of divisors, it is ON and hence count + 1.\\n\\nUnfortunately, it will timeout. How to optimize ?\\n\\nObservation #3:\\nDivisors always come in pair. For example:\\n1: [1,1]  ---  2: [1,2] --- 3: [1,3] --- 4: [1,4] [2,2] --- 5:[1,5] --- 6:[1,6][2,3] --- 7:[1,7] \\n8: [1,8][2,4] --- 9:[1,9][3,3]\\n\\nIn above examples, we know that: \\nOnly when ***i*** has **perfect square root**, its number of divisors is ODD, because it contains duplicated divisor. In above example,\\n4: [1,2,4] --- 9: [1,3,9]\\nYou can pick any number to examine yourself.\\n\\nHere comes a better algorithm:\\n`for i = 1...n,  if i^2 <= n, count++ ; if i^2 > n, break;`\\nWe loop through all position, if **i^2** is <= n, that means there exists a valid bulb which has perfect square root ***i***, and we need to count that **i^2**, so count + 1. If the **i^2** exceed n, we can terminate it because we have found all ***i*** with perfect square root within n already.\\n\\nMany of you might have seen the answer, so why the answer can be simply written as Math.sqrt(n) ?\\nconsider n = 9, the process of aforementioned algorithm will be: \\ncheck (1 * 1 ) <= 9, count++\\ncheck (2 * 2 ) <= 9, count++;\\ncheck (3 * 3) <= 9, count++;\\ncheck (4 * 4) > 9, break;\\n\\nWe can say, if square root of 9 is 3, that mean **1^2** and **2^2** must exists for n = 9. Hence, the Math.sqrt(i) reflect this fact.\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "I got to observation 2 on my own. The condition for an odd number of divisors was eluding me, thanks for the help"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "mind glowing explanation\\n"
                    },
                    {
                        "username": "saidfgn",
                        "content": "Great explanation, thanks!"
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "**Its more like a puzzle rather than a coding problem**"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "[@yusufm09](/yusufm09) brain tester problem means does they ask this in interviews"
                    },
                    {
                        "username": "yusufm09",
                        "content": "[@jerryy147](/jerryy147) I never knew that there was a brainteaser problem list. Thanks."
                    },
                    {
                        "username": "jerryy147",
                        "content": "that\\'s why it\\'s in the \"brainteaser\" problem list"
                    },
                    {
                        "username": "strongwillow",
                        "content": "It only stated the first, second, third, and last round. Should be updated as follows:\\n\\nThere are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). **For the ith round, you toggle every i bulb.** For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds."
                    },
                    {
                        "username": "sx1w",
                        "content": "Like many of you are wondering why a simple sqaure root solution to the problem, I wanted to find out why that is correct. Here is my little research into it. \\n\\nThe light bulb at postion k must be toggled in odd number to stay on, e.g. \\'On, Off, On\\' including the initial toggle. What triggers k-th bulb be toggled? Number k must be an **exact** multiple of each toggling. For example, when k=4, the bulb will be triggered by the 1st (On), 2nd (Off) and 4th (On) operation. What is the exact number of multiple of a nature number k? **All of its factors** ! \\n\\nSo the k-th bulb \\'ON\\' is corresponding to the number of factors of k being odd. You can certainly develop a program to count. However, the [*number math*](http://mathcentral.uregina.ca/QQ/database/QQ.09.06/jacqueline1.html) tells us only perfect square numbers have odd number of factors, which is what needed for the bulb to stay on. \\n\\nGreat! Now to solve the problem is to find out how many perfect square number between 1 and n. The [*math*](https://www.quora.com/How-many-perfect-squares-are-there-between-1-to-1000) kicks in again, and that number is the square root of n (more preceisly the floor of sqaure root of n). \\n\\nWhat a great problem!"
                    },
                    {
                        "username": "bharathb",
                        "content": "A lot of other posts provide code / suggest a simulation to see the pattern. I will attempt to describe the intuition behind the solution. \\n\\n* First let s identify all the bulbs that can touch/affect/toggle bulb X. Bulb X can only be toggled by other bulbs which are less than or equal to X. For example, 26 will never toggle bulb 23.\\n* Secondly, for a bulb X what are the bulbs that can toggle X? 23 can never toggle 25. We notice that a bulb X can only be toggled by divisors of X - including 1 and X itself. \\n* Now let s consider prime numbers. Prime numbers by definition have exactly two divisors. Any number with 2 divisors will never be ON at the end - because 1 will set it to ON and the second divisor (the prime number itself) will toggle it off.\\n* With prime numbers gone, lets consider a composite number with an even number of divisors.  Say 24. The divisors of 24 are (1,2,3,4,6,8,12,24). Listing the divisors as pairs - (1, 24) (2,12), (3,8), (4,6) - pairs are crucial because one divisor will set 24 to ON and the other divisor will set it to OFF. So, the net result is that those bulbs will NOT be ON at the end of the simulation - because they are initially OFF. They are toggled an even number of times.\\n* Now, we need to find numbers <=N which have an odd number of divisors. This might not be intuitive immediately and this simulating the problem on paper helps. If we consider a perfect square like 36 and write the divisors in pairs - (1,36), (2,18), (3, 12), (4, 9), (6,6). Now, we can see that while all other divisors cancel each other out - (they toggle the bulb twice) - 6 has no counterpart to toggle the bulb off. So, when there are 36 bulbs, 6 will always be ON at the end. The same holds true for perfect squares less than N - which are 1,4,9,16,25.\\n* Based on the above inferences, we can see that we need to find the numbers less than N that are perfect squares.  We can calculate this (int) Math.sqrt(N) or have a simple for-loop to count (i*i) <=N \\n\\nHope this helps."
                    },
                    {
                        "username": "rajeshkumar1130",
                        "content": "I was asked this question in an interview with microsoft on 22-01-2021"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It just proves that an ordinary position at MS is a dead-end job."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@sandagolcea](/sandagolcea)  Nice solution bro! The code is also quite neat. Good job!"
                    },
                    {
                        "username": "algoacer",
                        "content": "[@code_coffeee](/code_coffeee) Acutally it is so true, some one gets to implement a plain algorithm and someone has to think out of the box in 40 minutes. Not fair. But we should keep applying at multiple companies."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@code_coffeee](/code_coffeee) do you mean a TLE? I've actually solved it differently, using rather simple mathematics, but not sqrt (which i know was quite obvs, but I thought of doing smth else :D ) here https://leetcode.com/problems/bulb-switcher/solutions/3461670/js-solutions-without-using-sqrt/ "
                    },
                    {
                        "username": "l3aonti",
                        "content": "[@dvijay96](/dvijay96) it throws memory limit exception "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@code_coffeee](/code_coffeee) Brute force n^2 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "they what happened bro how did you explain "
                    },
                    {
                        "username": "code_coffeee",
                        "content": "This makes me sad.\\n\\nI feel like if they ask anyone this, they must not want to hire this person. If anyone codes it in any way without using square root, it is  a rejection."
                    },
                    {
                        "username": "bingzhoudaren",
                        "content": "First, we need to figure out how do we know if the ith light is on or off at the end. \\nit dpends on how many numbers could output i after you get product of them.\\nfor example 6, \\nwe will toggle the 6th light in the first round becasue 1 times6=6\\nwe will toggle the 6th light in the second round because 2 times 3=6;\\nwe will toggle the 6th light in third round beacuse 3 times 2 =6;\\nand we will toggle the 6th light in 6th round beacuse 6 times 1=6;\\n\\nso since wil have 1,2,3,6,totally four numbers, we will toggle the 6th light 4 times.\\nand since 4 is even ,so the 6th light will be off at the end.\\n\\nand for example, 9 could have division 1,3,9,  there are three of them. which is odd, so the 9th light is on at the end.\\n\\n\\nthen the problem is to figure out which number have odd divisions, which have even.\\n\\nthen, we should realize that,  for no-square number, the divisions can be paired.\\n\\nfor example, for 6, 1,and 6 is a pair, 2 and 3 is a pair.\\nhowever, for square number, for example 9, 3 will pair by itself, or we could say, 3 does not have a partener to build a pair.\\n\\nso, only lights at square numbers position will be on at the end.\\n\\nso, if we have 10 lights, at the end, only 1,4,9 light will be on.\\n\\n\\nand how to count them? by sqrt(10), we could get 3, which is the number of square numbers smaller than 10\\n\\n\\n\\n"
                    },
                    {
                        "username": "warrenbrodsky",
                        "content": "To begin, let\\'s forget keeping track of *every*  bulb and only think about *one*. Clearly, this bulb can either be on or off.  While obvious, this is still significant. If we know how many times we toggled the bulb, we can figure out which state it is in: If we have a bulb that begins on and we toggle it once, it will be off. Twice, on again. Thrice, off, four times on, five off, six on, etc. OK, so the answer is parity -- even flips it\\'s on, odd it\\'s off. \\n\\nGreat, but we don\\'t flip every bulb on every iteration, so how do we know how many times we flipped it? Ok, well on the first pass, we flip every other bulb, that is, every bulb whose index is a multiple of 2 (assuming indexing starts from 1 ;) ). On the next, we toggle every multiple of 3. On the next, multiples of 4, etc. When we\\'re done, we\\'ll have flipped every bulb once for each number that it is a multiple of, which is to say, once for each *divisor*. (Importantly, we include itself, but not 1.) For example, bulb 6 is flipped off for 2, on for 3, and off one final time for 6. Another important fact is that divisors come in pairs -- it and the thing it has to be multiplied with to get the number. The ***only*** time this isn\\'t true is if the thing it is multiplied by is itself. In other words, it\\'s a perfect square. Therefore perfect squares will *always* have an *odd* number of divisors and all others have *even* numbers of divisors. Since we\\'re not including one as a divisor, the parity flips and therefore, when all is said and done, only bulbs with perfect square indices will remain on.\\n\\nBulk of the work done -- now we just need to know how many perfect squares there are from 1 to n (which I will call squaresLTE(n)) and that will be our answer. This is fairly simple: beginning with n=1 and squaresLTE(1) = 1, we can see squaresLTE(2) is still 1,  squaresLTE(3) is still 1, and we finally get another square when n=4 and squaresLTE(4)=2 -- 1, and 4. We don\\'t add another square to the list until n=the next square. This gives us the final answer:\\n\\n`bulbs(n) = squaresLTE(n) = floor(sqrt(n))`\\n\\nThis works because if we\\'re between two squares a=s^2 and b=(s+1)^2, sqrt(n) will be some number between s and s+1, so floor(sqrt(n)) will bring us down to the sqrt of the last square we added to the list"
                    },
                    {
                        "username": "dilipK",
                        "content": "* If a particular number n is divisible by k , it means it will also  be divisible by n/k. So it will bring it to original state i.e.off. So toggling at kth iteration will turn ON but toggling at (n/k)th iteration will bring it to OFF. So no change.\\n* But for a prefect square sqrt(n) will only toggle it once , so it will be overall ON."
                    },
                    {
                        "username": "suhane",
                        "content": "# Logic : 1st round Bulb is ON, then each switch will OFF then ON. so for any number ->\\n# 1st round : ON\\n# 2nd round : OFF\\n# 3rd round : ON \\n# 4th round : OFF  and so on ....\\n# \\n# **If we can calculate how many times each bulb is switched we can tell it was ON/OFF at the last.**\\n# \\n# from above we can see if we switch bulb EVEN times we get it OFF at last, if switch ODD times we get it ON at the last.**\\n\\n*Now take few examples to understand better-*\\nN=1 -> bulb switched 1 time (for N=1)  \\t\\t\\t-> OFF at last\\n\\nN=2 -> bulb switched 2 times (for N=1, 2) \\t\\t-> OFF at last\\n\\nN=3 -> bulb switched 2 times (for N=1, 3) \\t\\t-> OFF at last\\n\\nN=4 -> bulb switched 3 times (for N=1, 2, 4) \\t-> **ON** at last\\n\\nN=5 -> bulb switched 2 times (for N=1, 5) \\t\\t-> OFF at last\\n\\nN=6 -> bulb switched 4 times (for N=1, 2, 3, 6) -> OFF at last\\n\\nN=7 -> bulb switched 2 times (for N=1, 7)\\t\\t-> OFF at last\\t\\n\\nN=8 -> bulb switched 8* times (for N=1, 2, 4, 8)\\t-> OFF at last\\t\\n(how we got 8 switches -\\nadd all switches of\\nN=1 (1 times at N=1),\\nN=2 (2 times at N=1,2), \\nN=4 (3 times at N=1,2,4) ,\\nN=8 (2 time at N=1,8))\\n\\nN=9 -> bulb switched 3 times (for N=1, 3, 9)\\t-> **ON** at last\\t\\n\\nAs you can see from above we got a conclusion only bulbs which are perfect square will be left ON at the last. (4, 9, 16, 25....) rest all bulbs will be OFF at the last.\\n\\nso we just need to fine how may perfact squares are present for any given N.\\nif N=20 -> 2, 4, 9, 16 (total 4)\\nif N=30 -> 2, 4, 9, 16, 25 (total 5)\\n\\nso we can convert calculating how many perfact sqs to -> simple solution\\n\\n# Ans: round(sqrt(N));\\n\\nBut this 1 line solution we can\\'t find until we know the whole logic that takes long time.\\n\\nHappy Learning !!\\n\\n"
                    }
                ]
            },
            {
                "id": 1567954,
                "content": [
                    {
                        "username": "mlblount45",
                        "content": "This problem is heavily math based. The `Math` tag should be added to this problem. \\n\\n**General technique for solving problems like this.**\\n\\nWithout being a genius the only way to solve problems like this is to use whats known as the *Examplify Technique* In the Examplify technique you write out specific examples of the problem and see if you can derive a general rule (or pattern) from there. In this case write out by hand what will happen when n = 1 then n = 2 then n = 3 then n = 4, and so on until you are able to figure out the pattern. This approach isn't the fastest but its a decent approach when you are unable to think of a solution off of the top of your head. \\n\\nmany others have provided the answer to this problem but the answer to this one problem isn't the important part being able to come up with solutions is what matters."
                    },
                    {
                        "username": "cswartzell",
                        "content": "What terrible writing. Firstly, you dont \"start by turning all the bulbs on, then every one off\". for i in 1...n you toggle every ith bulb. They all start as off.\\n\\nYes, this has the effect of turning every one on, but lets not mix up \"turning on\" and \"toggling\".  "
                    },
                    {
                        "username": "deepVashisth",
                        "content": "Turn Off All Bulbs, Save Electricity, Save Environment"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This is NOT a coding question - the coding answer would get TLE.\\n\\nThis is a math puzzle. And for those that want the answer:\\n<details>\\n  <summary>Spoiler</summary>\\n  Literally just return the sqrt floored:\\n\\n  ```java\\n  return (int) Math.sqrt(n);\\n  ```\\n  \\n</details>\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today, I learned a method how to find the square root of n. The crucial part is the following fact:\nLet x be a natural number. Then x has an odd number of factors iff x is a perfect square. How many perfect squares are within [1,n]? just (int(sqrt(n))"
                    },
                    {
                        "username": "user5640Rb",
                        "content": "it took about sometime to figure it out but here are somefindings for those who are still struggling:\\n1. the first bulb will only be flipped once so always ON\\n2. every bulb indexed *i* where *i* is a primitive, it will only be flipped twice (the first round and the *i*th round) so always OFF\\n3. every bulb indexed *i* where *i* is a non primitive number, it will only be flipped in pairs (1 and *i*) .... (*a* and *b*) where *a* * *b = i*, so it will always be OFF, unless, there is a specific condition where *a = b* which means an integer square root.\\n4. so for conclusion every index from 1 to *n* that has an integer square root will be ON\\n\\nhope that help..."
                    },
                    {
                        "username": "shenyurun",
                        "content": "First we can find that:\\n\\t1) if *i*th bit is on, then *i* must have odd factors;\\n\\t2) if *i*th bit is off, then *i* must have even factors;\\n\\nSecond, if *i* is not a square number, all the factors of *i* can be grouped into pairs. If *i* is a square number, then all factors of *i* **except sqrt(i)** can be grouped into pairs. So only square numbers have odd numbers of factors. Thus we only need to find how many square numbers there are in [1,n]."
                    },
                    {
                        "username": "erjoalgo",
                        "content": "The number of times bulb `i` is toggled is the number of divisors of `i`. Let us count the divisors of `i`.\\n\\nLet p<sub>1</sub><sup>e<sub>1</sub></sup> * p<sub>2</sub><sup>e<sub>2</sub></sup> ... * p<sub>n</sub><sup>e<sub>n</sub></sup> be the prime factorization of `i`. Since the prime factorization of any divisor `d` of `i` will be contained in that of `i`, we can count the number of unique prime factorizations that are contained in `i`. For each prime `p`, there are `e+1` choices for the number of times `p` appears in `d` (i.e. `0, 1... e`). Thus, there are (e<sub>1</sub>+1) (e<sub>2</sub>+1) ... (e<sub>n</sub> +1) unique prime factorizations which are a subset of `i`'s factorization, each corresponding to a unique divisor.\\n\\nFor example, 24=(2<sup>3</sup>)(3<sup>1</sup>). Each divisor can have `0,1,2,3` factors of 2, and `0, 1` factors of 3. The exponents are 3, 1, so there are (3+1)(1+1) = 8 divisors: [1,2,3,4,6,8,12,24]\\n\\nEach bulb will be toggled once for each of its divisors, and will remain on if toggled an odd number of times. So we need to count those numbers with an odd number of divisors. \\n\\nUsing our formula above, a number has an odd number of divisors iff all of the factors in (e<sub>1</sub>+1)(e<sub>2</sub>+1)...(e<sub>n</sub>+1) are odd. This means that all of the exponents e<sub>1,</sub> e<sub>2</sub> ... e<sub>n</sub> must be even in order for bulb `i` to remain on.\\n\\nThus we are looking for numbers which can be expressed as:\\n\\np<sub>1</sub><sup></sup>(2e<sub>1</sub>) * p<sub>2</sub><sup></sup>(2e<sub>2</sub>) ... p<sub>n</sub><sup></sup>(2e<sub>n</sub>)\\n\\nFactoring out the 2 from the exponents, we get:\\n\\n(p<sub>1</sub><sup>e</sup><sub>1</sub> * ... p<sub>n</sub><sup>e</sup><sub>n</sub>)<sup>2</sup>\\n\\nThus, bulb `i` will remain on iff it can be expressed as a (perfect) square.\\n\\nWe thus need to count the number of perfect squares <= n. This count is given by `floor(sqrt(n))`"
                    },
                    {
                        "username": "hikean",
                        "content": "     int bulbSwitch(int n) {   return sqrt(n+0.5);  }"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "So while I see a lot of sqrt solutions (quite obvious, I know, but still), I did solve the problem with the simple observation that there\\'s a \"rythm\" to the ones, there\\'s a sequence / pattern.\\n\\nIn case anyone is curious of a different solution, this is mine in JS, it does not TLE:\\nhttps://leetcode.com/problems/bulb-switcher/solutions/3461670/js-solutions-without-using-sqrt/ "
                    }
                ]
            },
            {
                "id": 1875139,
                "content": [
                    {
                        "username": "mlblount45",
                        "content": "This problem is heavily math based. The `Math` tag should be added to this problem. \\n\\n**General technique for solving problems like this.**\\n\\nWithout being a genius the only way to solve problems like this is to use whats known as the *Examplify Technique* In the Examplify technique you write out specific examples of the problem and see if you can derive a general rule (or pattern) from there. In this case write out by hand what will happen when n = 1 then n = 2 then n = 3 then n = 4, and so on until you are able to figure out the pattern. This approach isn't the fastest but its a decent approach when you are unable to think of a solution off of the top of your head. \\n\\nmany others have provided the answer to this problem but the answer to this one problem isn't the important part being able to come up with solutions is what matters."
                    },
                    {
                        "username": "cswartzell",
                        "content": "What terrible writing. Firstly, you dont \"start by turning all the bulbs on, then every one off\". for i in 1...n you toggle every ith bulb. They all start as off.\\n\\nYes, this has the effect of turning every one on, but lets not mix up \"turning on\" and \"toggling\".  "
                    },
                    {
                        "username": "deepVashisth",
                        "content": "Turn Off All Bulbs, Save Electricity, Save Environment"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This is NOT a coding question - the coding answer would get TLE.\\n\\nThis is a math puzzle. And for those that want the answer:\\n<details>\\n  <summary>Spoiler</summary>\\n  Literally just return the sqrt floored:\\n\\n  ```java\\n  return (int) Math.sqrt(n);\\n  ```\\n  \\n</details>\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today, I learned a method how to find the square root of n. The crucial part is the following fact:\nLet x be a natural number. Then x has an odd number of factors iff x is a perfect square. How many perfect squares are within [1,n]? just (int(sqrt(n))"
                    },
                    {
                        "username": "user5640Rb",
                        "content": "it took about sometime to figure it out but here are somefindings for those who are still struggling:\\n1. the first bulb will only be flipped once so always ON\\n2. every bulb indexed *i* where *i* is a primitive, it will only be flipped twice (the first round and the *i*th round) so always OFF\\n3. every bulb indexed *i* where *i* is a non primitive number, it will only be flipped in pairs (1 and *i*) .... (*a* and *b*) where *a* * *b = i*, so it will always be OFF, unless, there is a specific condition where *a = b* which means an integer square root.\\n4. so for conclusion every index from 1 to *n* that has an integer square root will be ON\\n\\nhope that help..."
                    },
                    {
                        "username": "shenyurun",
                        "content": "First we can find that:\\n\\t1) if *i*th bit is on, then *i* must have odd factors;\\n\\t2) if *i*th bit is off, then *i* must have even factors;\\n\\nSecond, if *i* is not a square number, all the factors of *i* can be grouped into pairs. If *i* is a square number, then all factors of *i* **except sqrt(i)** can be grouped into pairs. So only square numbers have odd numbers of factors. Thus we only need to find how many square numbers there are in [1,n]."
                    },
                    {
                        "username": "erjoalgo",
                        "content": "The number of times bulb `i` is toggled is the number of divisors of `i`. Let us count the divisors of `i`.\\n\\nLet p<sub>1</sub><sup>e<sub>1</sub></sup> * p<sub>2</sub><sup>e<sub>2</sub></sup> ... * p<sub>n</sub><sup>e<sub>n</sub></sup> be the prime factorization of `i`. Since the prime factorization of any divisor `d` of `i` will be contained in that of `i`, we can count the number of unique prime factorizations that are contained in `i`. For each prime `p`, there are `e+1` choices for the number of times `p` appears in `d` (i.e. `0, 1... e`). Thus, there are (e<sub>1</sub>+1) (e<sub>2</sub>+1) ... (e<sub>n</sub> +1) unique prime factorizations which are a subset of `i`'s factorization, each corresponding to a unique divisor.\\n\\nFor example, 24=(2<sup>3</sup>)(3<sup>1</sup>). Each divisor can have `0,1,2,3` factors of 2, and `0, 1` factors of 3. The exponents are 3, 1, so there are (3+1)(1+1) = 8 divisors: [1,2,3,4,6,8,12,24]\\n\\nEach bulb will be toggled once for each of its divisors, and will remain on if toggled an odd number of times. So we need to count those numbers with an odd number of divisors. \\n\\nUsing our formula above, a number has an odd number of divisors iff all of the factors in (e<sub>1</sub>+1)(e<sub>2</sub>+1)...(e<sub>n</sub>+1) are odd. This means that all of the exponents e<sub>1,</sub> e<sub>2</sub> ... e<sub>n</sub> must be even in order for bulb `i` to remain on.\\n\\nThus we are looking for numbers which can be expressed as:\\n\\np<sub>1</sub><sup></sup>(2e<sub>1</sub>) * p<sub>2</sub><sup></sup>(2e<sub>2</sub>) ... p<sub>n</sub><sup></sup>(2e<sub>n</sub>)\\n\\nFactoring out the 2 from the exponents, we get:\\n\\n(p<sub>1</sub><sup>e</sup><sub>1</sub> * ... p<sub>n</sub><sup>e</sup><sub>n</sub>)<sup>2</sup>\\n\\nThus, bulb `i` will remain on iff it can be expressed as a (perfect) square.\\n\\nWe thus need to count the number of perfect squares <= n. This count is given by `floor(sqrt(n))`"
                    },
                    {
                        "username": "hikean",
                        "content": "     int bulbSwitch(int n) {   return sqrt(n+0.5);  }"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "So while I see a lot of sqrt solutions (quite obvious, I know, but still), I did solve the problem with the simple observation that there\\'s a \"rythm\" to the ones, there\\'s a sequence / pattern.\\n\\nIn case anyone is curious of a different solution, this is mine in JS, it does not TLE:\\nhttps://leetcode.com/problems/bulb-switcher/solutions/3461670/js-solutions-without-using-sqrt/ "
                    }
                ]
            },
            {
                "id": 1875073,
                "content": [
                    {
                        "username": "mlblount45",
                        "content": "This problem is heavily math based. The `Math` tag should be added to this problem. \\n\\n**General technique for solving problems like this.**\\n\\nWithout being a genius the only way to solve problems like this is to use whats known as the *Examplify Technique* In the Examplify technique you write out specific examples of the problem and see if you can derive a general rule (or pattern) from there. In this case write out by hand what will happen when n = 1 then n = 2 then n = 3 then n = 4, and so on until you are able to figure out the pattern. This approach isn't the fastest but its a decent approach when you are unable to think of a solution off of the top of your head. \\n\\nmany others have provided the answer to this problem but the answer to this one problem isn't the important part being able to come up with solutions is what matters."
                    },
                    {
                        "username": "cswartzell",
                        "content": "What terrible writing. Firstly, you dont \"start by turning all the bulbs on, then every one off\". for i in 1...n you toggle every ith bulb. They all start as off.\\n\\nYes, this has the effect of turning every one on, but lets not mix up \"turning on\" and \"toggling\".  "
                    },
                    {
                        "username": "deepVashisth",
                        "content": "Turn Off All Bulbs, Save Electricity, Save Environment"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This is NOT a coding question - the coding answer would get TLE.\\n\\nThis is a math puzzle. And for those that want the answer:\\n<details>\\n  <summary>Spoiler</summary>\\n  Literally just return the sqrt floored:\\n\\n  ```java\\n  return (int) Math.sqrt(n);\\n  ```\\n  \\n</details>\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today, I learned a method how to find the square root of n. The crucial part is the following fact:\nLet x be a natural number. Then x has an odd number of factors iff x is a perfect square. How many perfect squares are within [1,n]? just (int(sqrt(n))"
                    },
                    {
                        "username": "user5640Rb",
                        "content": "it took about sometime to figure it out but here are somefindings for those who are still struggling:\\n1. the first bulb will only be flipped once so always ON\\n2. every bulb indexed *i* where *i* is a primitive, it will only be flipped twice (the first round and the *i*th round) so always OFF\\n3. every bulb indexed *i* where *i* is a non primitive number, it will only be flipped in pairs (1 and *i*) .... (*a* and *b*) where *a* * *b = i*, so it will always be OFF, unless, there is a specific condition where *a = b* which means an integer square root.\\n4. so for conclusion every index from 1 to *n* that has an integer square root will be ON\\n\\nhope that help..."
                    },
                    {
                        "username": "shenyurun",
                        "content": "First we can find that:\\n\\t1) if *i*th bit is on, then *i* must have odd factors;\\n\\t2) if *i*th bit is off, then *i* must have even factors;\\n\\nSecond, if *i* is not a square number, all the factors of *i* can be grouped into pairs. If *i* is a square number, then all factors of *i* **except sqrt(i)** can be grouped into pairs. So only square numbers have odd numbers of factors. Thus we only need to find how many square numbers there are in [1,n]."
                    },
                    {
                        "username": "erjoalgo",
                        "content": "The number of times bulb `i` is toggled is the number of divisors of `i`. Let us count the divisors of `i`.\\n\\nLet p<sub>1</sub><sup>e<sub>1</sub></sup> * p<sub>2</sub><sup>e<sub>2</sub></sup> ... * p<sub>n</sub><sup>e<sub>n</sub></sup> be the prime factorization of `i`. Since the prime factorization of any divisor `d` of `i` will be contained in that of `i`, we can count the number of unique prime factorizations that are contained in `i`. For each prime `p`, there are `e+1` choices for the number of times `p` appears in `d` (i.e. `0, 1... e`). Thus, there are (e<sub>1</sub>+1) (e<sub>2</sub>+1) ... (e<sub>n</sub> +1) unique prime factorizations which are a subset of `i`'s factorization, each corresponding to a unique divisor.\\n\\nFor example, 24=(2<sup>3</sup>)(3<sup>1</sup>). Each divisor can have `0,1,2,3` factors of 2, and `0, 1` factors of 3. The exponents are 3, 1, so there are (3+1)(1+1) = 8 divisors: [1,2,3,4,6,8,12,24]\\n\\nEach bulb will be toggled once for each of its divisors, and will remain on if toggled an odd number of times. So we need to count those numbers with an odd number of divisors. \\n\\nUsing our formula above, a number has an odd number of divisors iff all of the factors in (e<sub>1</sub>+1)(e<sub>2</sub>+1)...(e<sub>n</sub>+1) are odd. This means that all of the exponents e<sub>1,</sub> e<sub>2</sub> ... e<sub>n</sub> must be even in order for bulb `i` to remain on.\\n\\nThus we are looking for numbers which can be expressed as:\\n\\np<sub>1</sub><sup></sup>(2e<sub>1</sub>) * p<sub>2</sub><sup></sup>(2e<sub>2</sub>) ... p<sub>n</sub><sup></sup>(2e<sub>n</sub>)\\n\\nFactoring out the 2 from the exponents, we get:\\n\\n(p<sub>1</sub><sup>e</sup><sub>1</sub> * ... p<sub>n</sub><sup>e</sup><sub>n</sub>)<sup>2</sup>\\n\\nThus, bulb `i` will remain on iff it can be expressed as a (perfect) square.\\n\\nWe thus need to count the number of perfect squares <= n. This count is given by `floor(sqrt(n))`"
                    },
                    {
                        "username": "hikean",
                        "content": "     int bulbSwitch(int n) {   return sqrt(n+0.5);  }"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "So while I see a lot of sqrt solutions (quite obvious, I know, but still), I did solve the problem with the simple observation that there\\'s a \"rythm\" to the ones, there\\'s a sequence / pattern.\\n\\nIn case anyone is curious of a different solution, this is mine in JS, it does not TLE:\\nhttps://leetcode.com/problems/bulb-switcher/solutions/3461670/js-solutions-without-using-sqrt/ "
                    }
                ]
            },
            {
                "id": 1874866,
                "content": [
                    {
                        "username": "mlblount45",
                        "content": "This problem is heavily math based. The `Math` tag should be added to this problem. \\n\\n**General technique for solving problems like this.**\\n\\nWithout being a genius the only way to solve problems like this is to use whats known as the *Examplify Technique* In the Examplify technique you write out specific examples of the problem and see if you can derive a general rule (or pattern) from there. In this case write out by hand what will happen when n = 1 then n = 2 then n = 3 then n = 4, and so on until you are able to figure out the pattern. This approach isn't the fastest but its a decent approach when you are unable to think of a solution off of the top of your head. \\n\\nmany others have provided the answer to this problem but the answer to this one problem isn't the important part being able to come up with solutions is what matters."
                    },
                    {
                        "username": "cswartzell",
                        "content": "What terrible writing. Firstly, you dont \"start by turning all the bulbs on, then every one off\". for i in 1...n you toggle every ith bulb. They all start as off.\\n\\nYes, this has the effect of turning every one on, but lets not mix up \"turning on\" and \"toggling\".  "
                    },
                    {
                        "username": "deepVashisth",
                        "content": "Turn Off All Bulbs, Save Electricity, Save Environment"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This is NOT a coding question - the coding answer would get TLE.\\n\\nThis is a math puzzle. And for those that want the answer:\\n<details>\\n  <summary>Spoiler</summary>\\n  Literally just return the sqrt floored:\\n\\n  ```java\\n  return (int) Math.sqrt(n);\\n  ```\\n  \\n</details>\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today, I learned a method how to find the square root of n. The crucial part is the following fact:\nLet x be a natural number. Then x has an odd number of factors iff x is a perfect square. How many perfect squares are within [1,n]? just (int(sqrt(n))"
                    },
                    {
                        "username": "user5640Rb",
                        "content": "it took about sometime to figure it out but here are somefindings for those who are still struggling:\\n1. the first bulb will only be flipped once so always ON\\n2. every bulb indexed *i* where *i* is a primitive, it will only be flipped twice (the first round and the *i*th round) so always OFF\\n3. every bulb indexed *i* where *i* is a non primitive number, it will only be flipped in pairs (1 and *i*) .... (*a* and *b*) where *a* * *b = i*, so it will always be OFF, unless, there is a specific condition where *a = b* which means an integer square root.\\n4. so for conclusion every index from 1 to *n* that has an integer square root will be ON\\n\\nhope that help..."
                    },
                    {
                        "username": "shenyurun",
                        "content": "First we can find that:\\n\\t1) if *i*th bit is on, then *i* must have odd factors;\\n\\t2) if *i*th bit is off, then *i* must have even factors;\\n\\nSecond, if *i* is not a square number, all the factors of *i* can be grouped into pairs. If *i* is a square number, then all factors of *i* **except sqrt(i)** can be grouped into pairs. So only square numbers have odd numbers of factors. Thus we only need to find how many square numbers there are in [1,n]."
                    },
                    {
                        "username": "erjoalgo",
                        "content": "The number of times bulb `i` is toggled is the number of divisors of `i`. Let us count the divisors of `i`.\\n\\nLet p<sub>1</sub><sup>e<sub>1</sub></sup> * p<sub>2</sub><sup>e<sub>2</sub></sup> ... * p<sub>n</sub><sup>e<sub>n</sub></sup> be the prime factorization of `i`. Since the prime factorization of any divisor `d` of `i` will be contained in that of `i`, we can count the number of unique prime factorizations that are contained in `i`. For each prime `p`, there are `e+1` choices for the number of times `p` appears in `d` (i.e. `0, 1... e`). Thus, there are (e<sub>1</sub>+1) (e<sub>2</sub>+1) ... (e<sub>n</sub> +1) unique prime factorizations which are a subset of `i`'s factorization, each corresponding to a unique divisor.\\n\\nFor example, 24=(2<sup>3</sup>)(3<sup>1</sup>). Each divisor can have `0,1,2,3` factors of 2, and `0, 1` factors of 3. The exponents are 3, 1, so there are (3+1)(1+1) = 8 divisors: [1,2,3,4,6,8,12,24]\\n\\nEach bulb will be toggled once for each of its divisors, and will remain on if toggled an odd number of times. So we need to count those numbers with an odd number of divisors. \\n\\nUsing our formula above, a number has an odd number of divisors iff all of the factors in (e<sub>1</sub>+1)(e<sub>2</sub>+1)...(e<sub>n</sub>+1) are odd. This means that all of the exponents e<sub>1,</sub> e<sub>2</sub> ... e<sub>n</sub> must be even in order for bulb `i` to remain on.\\n\\nThus we are looking for numbers which can be expressed as:\\n\\np<sub>1</sub><sup></sup>(2e<sub>1</sub>) * p<sub>2</sub><sup></sup>(2e<sub>2</sub>) ... p<sub>n</sub><sup></sup>(2e<sub>n</sub>)\\n\\nFactoring out the 2 from the exponents, we get:\\n\\n(p<sub>1</sub><sup>e</sup><sub>1</sub> * ... p<sub>n</sub><sup>e</sup><sub>n</sub>)<sup>2</sup>\\n\\nThus, bulb `i` will remain on iff it can be expressed as a (perfect) square.\\n\\nWe thus need to count the number of perfect squares <= n. This count is given by `floor(sqrt(n))`"
                    },
                    {
                        "username": "hikean",
                        "content": "     int bulbSwitch(int n) {   return sqrt(n+0.5);  }"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "So while I see a lot of sqrt solutions (quite obvious, I know, but still), I did solve the problem with the simple observation that there\\'s a \"rythm\" to the ones, there\\'s a sequence / pattern.\\n\\nIn case anyone is curious of a different solution, this is mine in JS, it does not TLE:\\nhttps://leetcode.com/problems/bulb-switcher/solutions/3461670/js-solutions-without-using-sqrt/ "
                    }
                ]
            },
            {
                "id": 1874840,
                "content": [
                    {
                        "username": "mlblount45",
                        "content": "This problem is heavily math based. The `Math` tag should be added to this problem. \\n\\n**General technique for solving problems like this.**\\n\\nWithout being a genius the only way to solve problems like this is to use whats known as the *Examplify Technique* In the Examplify technique you write out specific examples of the problem and see if you can derive a general rule (or pattern) from there. In this case write out by hand what will happen when n = 1 then n = 2 then n = 3 then n = 4, and so on until you are able to figure out the pattern. This approach isn't the fastest but its a decent approach when you are unable to think of a solution off of the top of your head. \\n\\nmany others have provided the answer to this problem but the answer to this one problem isn't the important part being able to come up with solutions is what matters."
                    },
                    {
                        "username": "cswartzell",
                        "content": "What terrible writing. Firstly, you dont \"start by turning all the bulbs on, then every one off\". for i in 1...n you toggle every ith bulb. They all start as off.\\n\\nYes, this has the effect of turning every one on, but lets not mix up \"turning on\" and \"toggling\".  "
                    },
                    {
                        "username": "deepVashisth",
                        "content": "Turn Off All Bulbs, Save Electricity, Save Environment"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This is NOT a coding question - the coding answer would get TLE.\\n\\nThis is a math puzzle. And for those that want the answer:\\n<details>\\n  <summary>Spoiler</summary>\\n  Literally just return the sqrt floored:\\n\\n  ```java\\n  return (int) Math.sqrt(n);\\n  ```\\n  \\n</details>\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today, I learned a method how to find the square root of n. The crucial part is the following fact:\nLet x be a natural number. Then x has an odd number of factors iff x is a perfect square. How many perfect squares are within [1,n]? just (int(sqrt(n))"
                    },
                    {
                        "username": "user5640Rb",
                        "content": "it took about sometime to figure it out but here are somefindings for those who are still struggling:\\n1. the first bulb will only be flipped once so always ON\\n2. every bulb indexed *i* where *i* is a primitive, it will only be flipped twice (the first round and the *i*th round) so always OFF\\n3. every bulb indexed *i* where *i* is a non primitive number, it will only be flipped in pairs (1 and *i*) .... (*a* and *b*) where *a* * *b = i*, so it will always be OFF, unless, there is a specific condition where *a = b* which means an integer square root.\\n4. so for conclusion every index from 1 to *n* that has an integer square root will be ON\\n\\nhope that help..."
                    },
                    {
                        "username": "shenyurun",
                        "content": "First we can find that:\\n\\t1) if *i*th bit is on, then *i* must have odd factors;\\n\\t2) if *i*th bit is off, then *i* must have even factors;\\n\\nSecond, if *i* is not a square number, all the factors of *i* can be grouped into pairs. If *i* is a square number, then all factors of *i* **except sqrt(i)** can be grouped into pairs. So only square numbers have odd numbers of factors. Thus we only need to find how many square numbers there are in [1,n]."
                    },
                    {
                        "username": "erjoalgo",
                        "content": "The number of times bulb `i` is toggled is the number of divisors of `i`. Let us count the divisors of `i`.\\n\\nLet p<sub>1</sub><sup>e<sub>1</sub></sup> * p<sub>2</sub><sup>e<sub>2</sub></sup> ... * p<sub>n</sub><sup>e<sub>n</sub></sup> be the prime factorization of `i`. Since the prime factorization of any divisor `d` of `i` will be contained in that of `i`, we can count the number of unique prime factorizations that are contained in `i`. For each prime `p`, there are `e+1` choices for the number of times `p` appears in `d` (i.e. `0, 1... e`). Thus, there are (e<sub>1</sub>+1) (e<sub>2</sub>+1) ... (e<sub>n</sub> +1) unique prime factorizations which are a subset of `i`'s factorization, each corresponding to a unique divisor.\\n\\nFor example, 24=(2<sup>3</sup>)(3<sup>1</sup>). Each divisor can have `0,1,2,3` factors of 2, and `0, 1` factors of 3. The exponents are 3, 1, so there are (3+1)(1+1) = 8 divisors: [1,2,3,4,6,8,12,24]\\n\\nEach bulb will be toggled once for each of its divisors, and will remain on if toggled an odd number of times. So we need to count those numbers with an odd number of divisors. \\n\\nUsing our formula above, a number has an odd number of divisors iff all of the factors in (e<sub>1</sub>+1)(e<sub>2</sub>+1)...(e<sub>n</sub>+1) are odd. This means that all of the exponents e<sub>1,</sub> e<sub>2</sub> ... e<sub>n</sub> must be even in order for bulb `i` to remain on.\\n\\nThus we are looking for numbers which can be expressed as:\\n\\np<sub>1</sub><sup></sup>(2e<sub>1</sub>) * p<sub>2</sub><sup></sup>(2e<sub>2</sub>) ... p<sub>n</sub><sup></sup>(2e<sub>n</sub>)\\n\\nFactoring out the 2 from the exponents, we get:\\n\\n(p<sub>1</sub><sup>e</sup><sub>1</sub> * ... p<sub>n</sub><sup>e</sup><sub>n</sub>)<sup>2</sup>\\n\\nThus, bulb `i` will remain on iff it can be expressed as a (perfect) square.\\n\\nWe thus need to count the number of perfect squares <= n. This count is given by `floor(sqrt(n))`"
                    },
                    {
                        "username": "hikean",
                        "content": "     int bulbSwitch(int n) {   return sqrt(n+0.5);  }"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "So while I see a lot of sqrt solutions (quite obvious, I know, but still), I did solve the problem with the simple observation that there\\'s a \"rythm\" to the ones, there\\'s a sequence / pattern.\\n\\nIn case anyone is curious of a different solution, this is mine in JS, it does not TLE:\\nhttps://leetcode.com/problems/bulb-switcher/solutions/3461670/js-solutions-without-using-sqrt/ "
                    }
                ]
            },
            {
                "id": 1570254,
                "content": [
                    {
                        "username": "mlblount45",
                        "content": "This problem is heavily math based. The `Math` tag should be added to this problem. \\n\\n**General technique for solving problems like this.**\\n\\nWithout being a genius the only way to solve problems like this is to use whats known as the *Examplify Technique* In the Examplify technique you write out specific examples of the problem and see if you can derive a general rule (or pattern) from there. In this case write out by hand what will happen when n = 1 then n = 2 then n = 3 then n = 4, and so on until you are able to figure out the pattern. This approach isn't the fastest but its a decent approach when you are unable to think of a solution off of the top of your head. \\n\\nmany others have provided the answer to this problem but the answer to this one problem isn't the important part being able to come up with solutions is what matters."
                    },
                    {
                        "username": "cswartzell",
                        "content": "What terrible writing. Firstly, you dont \"start by turning all the bulbs on, then every one off\". for i in 1...n you toggle every ith bulb. They all start as off.\\n\\nYes, this has the effect of turning every one on, but lets not mix up \"turning on\" and \"toggling\".  "
                    },
                    {
                        "username": "deepVashisth",
                        "content": "Turn Off All Bulbs, Save Electricity, Save Environment"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This is NOT a coding question - the coding answer would get TLE.\\n\\nThis is a math puzzle. And for those that want the answer:\\n<details>\\n  <summary>Spoiler</summary>\\n  Literally just return the sqrt floored:\\n\\n  ```java\\n  return (int) Math.sqrt(n);\\n  ```\\n  \\n</details>\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today, I learned a method how to find the square root of n. The crucial part is the following fact:\nLet x be a natural number. Then x has an odd number of factors iff x is a perfect square. How many perfect squares are within [1,n]? just (int(sqrt(n))"
                    },
                    {
                        "username": "user5640Rb",
                        "content": "it took about sometime to figure it out but here are somefindings for those who are still struggling:\\n1. the first bulb will only be flipped once so always ON\\n2. every bulb indexed *i* where *i* is a primitive, it will only be flipped twice (the first round and the *i*th round) so always OFF\\n3. every bulb indexed *i* where *i* is a non primitive number, it will only be flipped in pairs (1 and *i*) .... (*a* and *b*) where *a* * *b = i*, so it will always be OFF, unless, there is a specific condition where *a = b* which means an integer square root.\\n4. so for conclusion every index from 1 to *n* that has an integer square root will be ON\\n\\nhope that help..."
                    },
                    {
                        "username": "shenyurun",
                        "content": "First we can find that:\\n\\t1) if *i*th bit is on, then *i* must have odd factors;\\n\\t2) if *i*th bit is off, then *i* must have even factors;\\n\\nSecond, if *i* is not a square number, all the factors of *i* can be grouped into pairs. If *i* is a square number, then all factors of *i* **except sqrt(i)** can be grouped into pairs. So only square numbers have odd numbers of factors. Thus we only need to find how many square numbers there are in [1,n]."
                    },
                    {
                        "username": "erjoalgo",
                        "content": "The number of times bulb `i` is toggled is the number of divisors of `i`. Let us count the divisors of `i`.\\n\\nLet p<sub>1</sub><sup>e<sub>1</sub></sup> * p<sub>2</sub><sup>e<sub>2</sub></sup> ... * p<sub>n</sub><sup>e<sub>n</sub></sup> be the prime factorization of `i`. Since the prime factorization of any divisor `d` of `i` will be contained in that of `i`, we can count the number of unique prime factorizations that are contained in `i`. For each prime `p`, there are `e+1` choices for the number of times `p` appears in `d` (i.e. `0, 1... e`). Thus, there are (e<sub>1</sub>+1) (e<sub>2</sub>+1) ... (e<sub>n</sub> +1) unique prime factorizations which are a subset of `i`'s factorization, each corresponding to a unique divisor.\\n\\nFor example, 24=(2<sup>3</sup>)(3<sup>1</sup>). Each divisor can have `0,1,2,3` factors of 2, and `0, 1` factors of 3. The exponents are 3, 1, so there are (3+1)(1+1) = 8 divisors: [1,2,3,4,6,8,12,24]\\n\\nEach bulb will be toggled once for each of its divisors, and will remain on if toggled an odd number of times. So we need to count those numbers with an odd number of divisors. \\n\\nUsing our formula above, a number has an odd number of divisors iff all of the factors in (e<sub>1</sub>+1)(e<sub>2</sub>+1)...(e<sub>n</sub>+1) are odd. This means that all of the exponents e<sub>1,</sub> e<sub>2</sub> ... e<sub>n</sub> must be even in order for bulb `i` to remain on.\\n\\nThus we are looking for numbers which can be expressed as:\\n\\np<sub>1</sub><sup></sup>(2e<sub>1</sub>) * p<sub>2</sub><sup></sup>(2e<sub>2</sub>) ... p<sub>n</sub><sup></sup>(2e<sub>n</sub>)\\n\\nFactoring out the 2 from the exponents, we get:\\n\\n(p<sub>1</sub><sup>e</sup><sub>1</sub> * ... p<sub>n</sub><sup>e</sup><sub>n</sub>)<sup>2</sup>\\n\\nThus, bulb `i` will remain on iff it can be expressed as a (perfect) square.\\n\\nWe thus need to count the number of perfect squares <= n. This count is given by `floor(sqrt(n))`"
                    },
                    {
                        "username": "hikean",
                        "content": "     int bulbSwitch(int n) {   return sqrt(n+0.5);  }"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "So while I see a lot of sqrt solutions (quite obvious, I know, but still), I did solve the problem with the simple observation that there\\'s a \"rythm\" to the ones, there\\'s a sequence / pattern.\\n\\nIn case anyone is curious of a different solution, this is mine in JS, it does not TLE:\\nhttps://leetcode.com/problems/bulb-switcher/solutions/3461670/js-solutions-without-using-sqrt/ "
                    }
                ]
            },
            {
                "id": 1569535,
                "content": [
                    {
                        "username": "mlblount45",
                        "content": "This problem is heavily math based. The `Math` tag should be added to this problem. \\n\\n**General technique for solving problems like this.**\\n\\nWithout being a genius the only way to solve problems like this is to use whats known as the *Examplify Technique* In the Examplify technique you write out specific examples of the problem and see if you can derive a general rule (or pattern) from there. In this case write out by hand what will happen when n = 1 then n = 2 then n = 3 then n = 4, and so on until you are able to figure out the pattern. This approach isn't the fastest but its a decent approach when you are unable to think of a solution off of the top of your head. \\n\\nmany others have provided the answer to this problem but the answer to this one problem isn't the important part being able to come up with solutions is what matters."
                    },
                    {
                        "username": "cswartzell",
                        "content": "What terrible writing. Firstly, you dont \"start by turning all the bulbs on, then every one off\". for i in 1...n you toggle every ith bulb. They all start as off.\\n\\nYes, this has the effect of turning every one on, but lets not mix up \"turning on\" and \"toggling\".  "
                    },
                    {
                        "username": "deepVashisth",
                        "content": "Turn Off All Bulbs, Save Electricity, Save Environment"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This is NOT a coding question - the coding answer would get TLE.\\n\\nThis is a math puzzle. And for those that want the answer:\\n<details>\\n  <summary>Spoiler</summary>\\n  Literally just return the sqrt floored:\\n\\n  ```java\\n  return (int) Math.sqrt(n);\\n  ```\\n  \\n</details>\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today, I learned a method how to find the square root of n. The crucial part is the following fact:\nLet x be a natural number. Then x has an odd number of factors iff x is a perfect square. How many perfect squares are within [1,n]? just (int(sqrt(n))"
                    },
                    {
                        "username": "user5640Rb",
                        "content": "it took about sometime to figure it out but here are somefindings for those who are still struggling:\\n1. the first bulb will only be flipped once so always ON\\n2. every bulb indexed *i* where *i* is a primitive, it will only be flipped twice (the first round and the *i*th round) so always OFF\\n3. every bulb indexed *i* where *i* is a non primitive number, it will only be flipped in pairs (1 and *i*) .... (*a* and *b*) where *a* * *b = i*, so it will always be OFF, unless, there is a specific condition where *a = b* which means an integer square root.\\n4. so for conclusion every index from 1 to *n* that has an integer square root will be ON\\n\\nhope that help..."
                    },
                    {
                        "username": "shenyurun",
                        "content": "First we can find that:\\n\\t1) if *i*th bit is on, then *i* must have odd factors;\\n\\t2) if *i*th bit is off, then *i* must have even factors;\\n\\nSecond, if *i* is not a square number, all the factors of *i* can be grouped into pairs. If *i* is a square number, then all factors of *i* **except sqrt(i)** can be grouped into pairs. So only square numbers have odd numbers of factors. Thus we only need to find how many square numbers there are in [1,n]."
                    },
                    {
                        "username": "erjoalgo",
                        "content": "The number of times bulb `i` is toggled is the number of divisors of `i`. Let us count the divisors of `i`.\\n\\nLet p<sub>1</sub><sup>e<sub>1</sub></sup> * p<sub>2</sub><sup>e<sub>2</sub></sup> ... * p<sub>n</sub><sup>e<sub>n</sub></sup> be the prime factorization of `i`. Since the prime factorization of any divisor `d` of `i` will be contained in that of `i`, we can count the number of unique prime factorizations that are contained in `i`. For each prime `p`, there are `e+1` choices for the number of times `p` appears in `d` (i.e. `0, 1... e`). Thus, there are (e<sub>1</sub>+1) (e<sub>2</sub>+1) ... (e<sub>n</sub> +1) unique prime factorizations which are a subset of `i`'s factorization, each corresponding to a unique divisor.\\n\\nFor example, 24=(2<sup>3</sup>)(3<sup>1</sup>). Each divisor can have `0,1,2,3` factors of 2, and `0, 1` factors of 3. The exponents are 3, 1, so there are (3+1)(1+1) = 8 divisors: [1,2,3,4,6,8,12,24]\\n\\nEach bulb will be toggled once for each of its divisors, and will remain on if toggled an odd number of times. So we need to count those numbers with an odd number of divisors. \\n\\nUsing our formula above, a number has an odd number of divisors iff all of the factors in (e<sub>1</sub>+1)(e<sub>2</sub>+1)...(e<sub>n</sub>+1) are odd. This means that all of the exponents e<sub>1,</sub> e<sub>2</sub> ... e<sub>n</sub> must be even in order for bulb `i` to remain on.\\n\\nThus we are looking for numbers which can be expressed as:\\n\\np<sub>1</sub><sup></sup>(2e<sub>1</sub>) * p<sub>2</sub><sup></sup>(2e<sub>2</sub>) ... p<sub>n</sub><sup></sup>(2e<sub>n</sub>)\\n\\nFactoring out the 2 from the exponents, we get:\\n\\n(p<sub>1</sub><sup>e</sup><sub>1</sub> * ... p<sub>n</sub><sup>e</sup><sub>n</sub>)<sup>2</sup>\\n\\nThus, bulb `i` will remain on iff it can be expressed as a (perfect) square.\\n\\nWe thus need to count the number of perfect squares <= n. This count is given by `floor(sqrt(n))`"
                    },
                    {
                        "username": "hikean",
                        "content": "     int bulbSwitch(int n) {   return sqrt(n+0.5);  }"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "So while I see a lot of sqrt solutions (quite obvious, I know, but still), I did solve the problem with the simple observation that there\\'s a \"rythm\" to the ones, there\\'s a sequence / pattern.\\n\\nIn case anyone is curious of a different solution, this is mine in JS, it does not TLE:\\nhttps://leetcode.com/problems/bulb-switcher/solutions/3461670/js-solutions-without-using-sqrt/ "
                    }
                ]
            },
            {
                "id": 1569072,
                "content": [
                    {
                        "username": "mlblount45",
                        "content": "This problem is heavily math based. The `Math` tag should be added to this problem. \\n\\n**General technique for solving problems like this.**\\n\\nWithout being a genius the only way to solve problems like this is to use whats known as the *Examplify Technique* In the Examplify technique you write out specific examples of the problem and see if you can derive a general rule (or pattern) from there. In this case write out by hand what will happen when n = 1 then n = 2 then n = 3 then n = 4, and so on until you are able to figure out the pattern. This approach isn't the fastest but its a decent approach when you are unable to think of a solution off of the top of your head. \\n\\nmany others have provided the answer to this problem but the answer to this one problem isn't the important part being able to come up with solutions is what matters."
                    },
                    {
                        "username": "cswartzell",
                        "content": "What terrible writing. Firstly, you dont \"start by turning all the bulbs on, then every one off\". for i in 1...n you toggle every ith bulb. They all start as off.\\n\\nYes, this has the effect of turning every one on, but lets not mix up \"turning on\" and \"toggling\".  "
                    },
                    {
                        "username": "deepVashisth",
                        "content": "Turn Off All Bulbs, Save Electricity, Save Environment"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This is NOT a coding question - the coding answer would get TLE.\\n\\nThis is a math puzzle. And for those that want the answer:\\n<details>\\n  <summary>Spoiler</summary>\\n  Literally just return the sqrt floored:\\n\\n  ```java\\n  return (int) Math.sqrt(n);\\n  ```\\n  \\n</details>\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today, I learned a method how to find the square root of n. The crucial part is the following fact:\nLet x be a natural number. Then x has an odd number of factors iff x is a perfect square. How many perfect squares are within [1,n]? just (int(sqrt(n))"
                    },
                    {
                        "username": "user5640Rb",
                        "content": "it took about sometime to figure it out but here are somefindings for those who are still struggling:\\n1. the first bulb will only be flipped once so always ON\\n2. every bulb indexed *i* where *i* is a primitive, it will only be flipped twice (the first round and the *i*th round) so always OFF\\n3. every bulb indexed *i* where *i* is a non primitive number, it will only be flipped in pairs (1 and *i*) .... (*a* and *b*) where *a* * *b = i*, so it will always be OFF, unless, there is a specific condition where *a = b* which means an integer square root.\\n4. so for conclusion every index from 1 to *n* that has an integer square root will be ON\\n\\nhope that help..."
                    },
                    {
                        "username": "shenyurun",
                        "content": "First we can find that:\\n\\t1) if *i*th bit is on, then *i* must have odd factors;\\n\\t2) if *i*th bit is off, then *i* must have even factors;\\n\\nSecond, if *i* is not a square number, all the factors of *i* can be grouped into pairs. If *i* is a square number, then all factors of *i* **except sqrt(i)** can be grouped into pairs. So only square numbers have odd numbers of factors. Thus we only need to find how many square numbers there are in [1,n]."
                    },
                    {
                        "username": "erjoalgo",
                        "content": "The number of times bulb `i` is toggled is the number of divisors of `i`. Let us count the divisors of `i`.\\n\\nLet p<sub>1</sub><sup>e<sub>1</sub></sup> * p<sub>2</sub><sup>e<sub>2</sub></sup> ... * p<sub>n</sub><sup>e<sub>n</sub></sup> be the prime factorization of `i`. Since the prime factorization of any divisor `d` of `i` will be contained in that of `i`, we can count the number of unique prime factorizations that are contained in `i`. For each prime `p`, there are `e+1` choices for the number of times `p` appears in `d` (i.e. `0, 1... e`). Thus, there are (e<sub>1</sub>+1) (e<sub>2</sub>+1) ... (e<sub>n</sub> +1) unique prime factorizations which are a subset of `i`'s factorization, each corresponding to a unique divisor.\\n\\nFor example, 24=(2<sup>3</sup>)(3<sup>1</sup>). Each divisor can have `0,1,2,3` factors of 2, and `0, 1` factors of 3. The exponents are 3, 1, so there are (3+1)(1+1) = 8 divisors: [1,2,3,4,6,8,12,24]\\n\\nEach bulb will be toggled once for each of its divisors, and will remain on if toggled an odd number of times. So we need to count those numbers with an odd number of divisors. \\n\\nUsing our formula above, a number has an odd number of divisors iff all of the factors in (e<sub>1</sub>+1)(e<sub>2</sub>+1)...(e<sub>n</sub>+1) are odd. This means that all of the exponents e<sub>1,</sub> e<sub>2</sub> ... e<sub>n</sub> must be even in order for bulb `i` to remain on.\\n\\nThus we are looking for numbers which can be expressed as:\\n\\np<sub>1</sub><sup></sup>(2e<sub>1</sub>) * p<sub>2</sub><sup></sup>(2e<sub>2</sub>) ... p<sub>n</sub><sup></sup>(2e<sub>n</sub>)\\n\\nFactoring out the 2 from the exponents, we get:\\n\\n(p<sub>1</sub><sup>e</sup><sub>1</sub> * ... p<sub>n</sub><sup>e</sup><sub>n</sub>)<sup>2</sup>\\n\\nThus, bulb `i` will remain on iff it can be expressed as a (perfect) square.\\n\\nWe thus need to count the number of perfect squares <= n. This count is given by `floor(sqrt(n))`"
                    },
                    {
                        "username": "hikean",
                        "content": "     int bulbSwitch(int n) {   return sqrt(n+0.5);  }"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "So while I see a lot of sqrt solutions (quite obvious, I know, but still), I did solve the problem with the simple observation that there\\'s a \"rythm\" to the ones, there\\'s a sequence / pattern.\\n\\nIn case anyone is curious of a different solution, this is mine in JS, it does not TLE:\\nhttps://leetcode.com/problems/bulb-switcher/solutions/3461670/js-solutions-without-using-sqrt/ "
                    }
                ]
            },
            {
                "id": 1567247,
                "content": [
                    {
                        "username": "mlblount45",
                        "content": "This problem is heavily math based. The `Math` tag should be added to this problem. \\n\\n**General technique for solving problems like this.**\\n\\nWithout being a genius the only way to solve problems like this is to use whats known as the *Examplify Technique* In the Examplify technique you write out specific examples of the problem and see if you can derive a general rule (or pattern) from there. In this case write out by hand what will happen when n = 1 then n = 2 then n = 3 then n = 4, and so on until you are able to figure out the pattern. This approach isn't the fastest but its a decent approach when you are unable to think of a solution off of the top of your head. \\n\\nmany others have provided the answer to this problem but the answer to this one problem isn't the important part being able to come up with solutions is what matters."
                    },
                    {
                        "username": "cswartzell",
                        "content": "What terrible writing. Firstly, you dont \"start by turning all the bulbs on, then every one off\". for i in 1...n you toggle every ith bulb. They all start as off.\\n\\nYes, this has the effect of turning every one on, but lets not mix up \"turning on\" and \"toggling\".  "
                    },
                    {
                        "username": "deepVashisth",
                        "content": "Turn Off All Bulbs, Save Electricity, Save Environment"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This is NOT a coding question - the coding answer would get TLE.\\n\\nThis is a math puzzle. And for those that want the answer:\\n<details>\\n  <summary>Spoiler</summary>\\n  Literally just return the sqrt floored:\\n\\n  ```java\\n  return (int) Math.sqrt(n);\\n  ```\\n  \\n</details>\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today, I learned a method how to find the square root of n. The crucial part is the following fact:\nLet x be a natural number. Then x has an odd number of factors iff x is a perfect square. How many perfect squares are within [1,n]? just (int(sqrt(n))"
                    },
                    {
                        "username": "user5640Rb",
                        "content": "it took about sometime to figure it out but here are somefindings for those who are still struggling:\\n1. the first bulb will only be flipped once so always ON\\n2. every bulb indexed *i* where *i* is a primitive, it will only be flipped twice (the first round and the *i*th round) so always OFF\\n3. every bulb indexed *i* where *i* is a non primitive number, it will only be flipped in pairs (1 and *i*) .... (*a* and *b*) where *a* * *b = i*, so it will always be OFF, unless, there is a specific condition where *a = b* which means an integer square root.\\n4. so for conclusion every index from 1 to *n* that has an integer square root will be ON\\n\\nhope that help..."
                    },
                    {
                        "username": "shenyurun",
                        "content": "First we can find that:\\n\\t1) if *i*th bit is on, then *i* must have odd factors;\\n\\t2) if *i*th bit is off, then *i* must have even factors;\\n\\nSecond, if *i* is not a square number, all the factors of *i* can be grouped into pairs. If *i* is a square number, then all factors of *i* **except sqrt(i)** can be grouped into pairs. So only square numbers have odd numbers of factors. Thus we only need to find how many square numbers there are in [1,n]."
                    },
                    {
                        "username": "erjoalgo",
                        "content": "The number of times bulb `i` is toggled is the number of divisors of `i`. Let us count the divisors of `i`.\\n\\nLet p<sub>1</sub><sup>e<sub>1</sub></sup> * p<sub>2</sub><sup>e<sub>2</sub></sup> ... * p<sub>n</sub><sup>e<sub>n</sub></sup> be the prime factorization of `i`. Since the prime factorization of any divisor `d` of `i` will be contained in that of `i`, we can count the number of unique prime factorizations that are contained in `i`. For each prime `p`, there are `e+1` choices for the number of times `p` appears in `d` (i.e. `0, 1... e`). Thus, there are (e<sub>1</sub>+1) (e<sub>2</sub>+1) ... (e<sub>n</sub> +1) unique prime factorizations which are a subset of `i`'s factorization, each corresponding to a unique divisor.\\n\\nFor example, 24=(2<sup>3</sup>)(3<sup>1</sup>). Each divisor can have `0,1,2,3` factors of 2, and `0, 1` factors of 3. The exponents are 3, 1, so there are (3+1)(1+1) = 8 divisors: [1,2,3,4,6,8,12,24]\\n\\nEach bulb will be toggled once for each of its divisors, and will remain on if toggled an odd number of times. So we need to count those numbers with an odd number of divisors. \\n\\nUsing our formula above, a number has an odd number of divisors iff all of the factors in (e<sub>1</sub>+1)(e<sub>2</sub>+1)...(e<sub>n</sub>+1) are odd. This means that all of the exponents e<sub>1,</sub> e<sub>2</sub> ... e<sub>n</sub> must be even in order for bulb `i` to remain on.\\n\\nThus we are looking for numbers which can be expressed as:\\n\\np<sub>1</sub><sup></sup>(2e<sub>1</sub>) * p<sub>2</sub><sup></sup>(2e<sub>2</sub>) ... p<sub>n</sub><sup></sup>(2e<sub>n</sub>)\\n\\nFactoring out the 2 from the exponents, we get:\\n\\n(p<sub>1</sub><sup>e</sup><sub>1</sub> * ... p<sub>n</sub><sup>e</sup><sub>n</sub>)<sup>2</sup>\\n\\nThus, bulb `i` will remain on iff it can be expressed as a (perfect) square.\\n\\nWe thus need to count the number of perfect squares <= n. This count is given by `floor(sqrt(n))`"
                    },
                    {
                        "username": "hikean",
                        "content": "     int bulbSwitch(int n) {   return sqrt(n+0.5);  }"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "So while I see a lot of sqrt solutions (quite obvious, I know, but still), I did solve the problem with the simple observation that there\\'s a \"rythm\" to the ones, there\\'s a sequence / pattern.\\n\\nIn case anyone is curious of a different solution, this is mine in JS, it does not TLE:\\nhttps://leetcode.com/problems/bulb-switcher/solutions/3461670/js-solutions-without-using-sqrt/ "
                    }
                ]
            },
            {
                "id": 1875562,
                "content": [
                    {
                        "username": "mlblount45",
                        "content": "This problem is heavily math based. The `Math` tag should be added to this problem. \\n\\n**General technique for solving problems like this.**\\n\\nWithout being a genius the only way to solve problems like this is to use whats known as the *Examplify Technique* In the Examplify technique you write out specific examples of the problem and see if you can derive a general rule (or pattern) from there. In this case write out by hand what will happen when n = 1 then n = 2 then n = 3 then n = 4, and so on until you are able to figure out the pattern. This approach isn't the fastest but its a decent approach when you are unable to think of a solution off of the top of your head. \\n\\nmany others have provided the answer to this problem but the answer to this one problem isn't the important part being able to come up with solutions is what matters."
                    },
                    {
                        "username": "cswartzell",
                        "content": "What terrible writing. Firstly, you dont \"start by turning all the bulbs on, then every one off\". for i in 1...n you toggle every ith bulb. They all start as off.\\n\\nYes, this has the effect of turning every one on, but lets not mix up \"turning on\" and \"toggling\".  "
                    },
                    {
                        "username": "deepVashisth",
                        "content": "Turn Off All Bulbs, Save Electricity, Save Environment"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This is NOT a coding question - the coding answer would get TLE.\\n\\nThis is a math puzzle. And for those that want the answer:\\n<details>\\n  <summary>Spoiler</summary>\\n  Literally just return the sqrt floored:\\n\\n  ```java\\n  return (int) Math.sqrt(n);\\n  ```\\n  \\n</details>\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today, I learned a method how to find the square root of n. The crucial part is the following fact:\nLet x be a natural number. Then x has an odd number of factors iff x is a perfect square. How many perfect squares are within [1,n]? just (int(sqrt(n))"
                    },
                    {
                        "username": "user5640Rb",
                        "content": "it took about sometime to figure it out but here are somefindings for those who are still struggling:\\n1. the first bulb will only be flipped once so always ON\\n2. every bulb indexed *i* where *i* is a primitive, it will only be flipped twice (the first round and the *i*th round) so always OFF\\n3. every bulb indexed *i* where *i* is a non primitive number, it will only be flipped in pairs (1 and *i*) .... (*a* and *b*) where *a* * *b = i*, so it will always be OFF, unless, there is a specific condition where *a = b* which means an integer square root.\\n4. so for conclusion every index from 1 to *n* that has an integer square root will be ON\\n\\nhope that help..."
                    },
                    {
                        "username": "shenyurun",
                        "content": "First we can find that:\\n\\t1) if *i*th bit is on, then *i* must have odd factors;\\n\\t2) if *i*th bit is off, then *i* must have even factors;\\n\\nSecond, if *i* is not a square number, all the factors of *i* can be grouped into pairs. If *i* is a square number, then all factors of *i* **except sqrt(i)** can be grouped into pairs. So only square numbers have odd numbers of factors. Thus we only need to find how many square numbers there are in [1,n]."
                    },
                    {
                        "username": "erjoalgo",
                        "content": "The number of times bulb `i` is toggled is the number of divisors of `i`. Let us count the divisors of `i`.\\n\\nLet p<sub>1</sub><sup>e<sub>1</sub></sup> * p<sub>2</sub><sup>e<sub>2</sub></sup> ... * p<sub>n</sub><sup>e<sub>n</sub></sup> be the prime factorization of `i`. Since the prime factorization of any divisor `d` of `i` will be contained in that of `i`, we can count the number of unique prime factorizations that are contained in `i`. For each prime `p`, there are `e+1` choices for the number of times `p` appears in `d` (i.e. `0, 1... e`). Thus, there are (e<sub>1</sub>+1) (e<sub>2</sub>+1) ... (e<sub>n</sub> +1) unique prime factorizations which are a subset of `i`'s factorization, each corresponding to a unique divisor.\\n\\nFor example, 24=(2<sup>3</sup>)(3<sup>1</sup>). Each divisor can have `0,1,2,3` factors of 2, and `0, 1` factors of 3. The exponents are 3, 1, so there are (3+1)(1+1) = 8 divisors: [1,2,3,4,6,8,12,24]\\n\\nEach bulb will be toggled once for each of its divisors, and will remain on if toggled an odd number of times. So we need to count those numbers with an odd number of divisors. \\n\\nUsing our formula above, a number has an odd number of divisors iff all of the factors in (e<sub>1</sub>+1)(e<sub>2</sub>+1)...(e<sub>n</sub>+1) are odd. This means that all of the exponents e<sub>1,</sub> e<sub>2</sub> ... e<sub>n</sub> must be even in order for bulb `i` to remain on.\\n\\nThus we are looking for numbers which can be expressed as:\\n\\np<sub>1</sub><sup></sup>(2e<sub>1</sub>) * p<sub>2</sub><sup></sup>(2e<sub>2</sub>) ... p<sub>n</sub><sup></sup>(2e<sub>n</sub>)\\n\\nFactoring out the 2 from the exponents, we get:\\n\\n(p<sub>1</sub><sup>e</sup><sub>1</sub> * ... p<sub>n</sub><sup>e</sup><sub>n</sub>)<sup>2</sup>\\n\\nThus, bulb `i` will remain on iff it can be expressed as a (perfect) square.\\n\\nWe thus need to count the number of perfect squares <= n. This count is given by `floor(sqrt(n))`"
                    },
                    {
                        "username": "hikean",
                        "content": "     int bulbSwitch(int n) {   return sqrt(n+0.5);  }"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "So while I see a lot of sqrt solutions (quite obvious, I know, but still), I did solve the problem with the simple observation that there\\'s a \"rythm\" to the ones, there\\'s a sequence / pattern.\\n\\nIn case anyone is curious of a different solution, this is mine in JS, it does not TLE:\\nhttps://leetcode.com/problems/bulb-switcher/solutions/3461670/js-solutions-without-using-sqrt/ "
                    }
                ]
            },
            {
                "id": 1875151,
                "content": [
                    {
                        "username": "sugarteddy",
                        "content": "no wonder this got so many dislikes"
                    },
                    {
                        "username": "ikorpse",
                        "content": "I think such questions shouldn\\'t be asked on a coding interview, it has nothing to do with algorithmic coding"
                    },
                    {
                        "username": "ajesk",
                        "content": "This is my least favorite type of problem by far and it is even worse in today\\'s remote-centric world. \\n\\nThe way I would approach this problem in an in person setting, would be to write down every combination on an actual whiteboard until I realized the sqrt pattern.\\nDoing such a thing remotely is much more cumbersome and tougher to visualize."
                    },
                    {
                        "username": "kjers96",
                        "content": "Bro what even is this problem lol"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "more simplified explanation to the problem statement:\\nAt each step, you toggle every posiiton that is multiple of that step.\\nfor eg. at 2nd step, we toggle every multiple of 2( i.e. 2, 4, 6,8,... so on).\\nhope this helps :-)"
                    },
                    {
                        "username": "lowhochi",
                        "content": "Suppose there are n lightbulbs, Let L_k be the k-th lightbulb (k<=n). After n rounds, the light bulb L_k will be ON if k has odd number of factors (including 1 and k itself) and it will be OFF if k has even number of factors.\\n\\ne.g. L_16 will be ON after n rounds (n>=16) since 16 has five factors 1, 2, 4, 8, 16\\ne.g. L_24 will be OFF after n rounds (n>=24) since 24 has eight factors: 1, 2, 3, 4, 6, 8, 12, 24.\\n\\na number k has odd number of factors if and only if k is a perfect square.\\n\\nSuppos (p1, p2, ..., pr) are distinct prime factors of k.\\n\\nIf (r=1), we have k = p1^m => k has (m+1) factors 1, p1, p1^2, ..., p1^m\\nm+1 is odd when m is even => k = (p1^(m/2))^2 is a perfect square.\\n\\nIn general, k = p1^m1 * p2^m2 * ... * pr^mr has a total of (m1+1)(m2+1)...(mr+1) factors\\n(m1+1)(m2+1)...(mr+1) is odd if and only if all m1, m2, ..., mr are even numbers.\\nSo \\n>\\tk = [p1^(m1/2) * ... * pr^(mr/2)]^2 is a perfect square"
                    },
                    {
                        "username": "sschappy",
                        "content": "For every integer N, there happens : N=a * b ,while 1 <= a,b <=N \\n\\nnow assume the bulb number is 1,2,3,\\u2026\\u2026,N,\\u2026\\u2026\\nin (a) round, the bulb N changed its status;\\nin (b) round, the bulb N changed its status;\\n\\nWe know\\uFF1A\\nif a **!=** b, the bulb N changed twice, so it **remain** its status;\\nif a **==** b, the bulb N changed once, so it **changed** its status;\\n\\nAbove conclusion always happens, \\n\\nFor bulb N, the (N+1),(N+2),\\u2026\\u2026 round doesn\\'t affect; \\nFor any number a,\\nif N%a!=0, this (a) round doesn\\'t affect\\nif N%a==0, there must has number b=N/a,\\n(1) if a != b \\uFF0Cthe bulb remain its status\\n(2) if a == b \\uFF0Cthe bulb change its status\\n\\nIf N is big enough, only the bulb 1,4,9,16,25, \\u2026\\u2026  change its status\\nWe should count how many numbers could write as (a * a)\\uFF0Cso the answer is **sqrt(N)**"
                    },
                    {
                        "username": "qsli",
                        "content": "I can understand the solution is to find the count of numbers below n which can be sqrt, but why sqrt(n) is right?"
                    },
                    {
                        "username": "mtx",
                        "content": "When all the loop is done, only numbers a^2 which satisfy a<=n&&a^2<=n will be 1, other digits are all flipped to zero, for if a digit wants to remain 1, it must flip twice.\\nfor example, n=5\\nloop k:\\n2^2<=5,so only digit 4 flips twice, digit 2 and digit 3 and digit 5 only flips once. The last digit also satisfies this.\\nSo sqrt(n) means what is the max digit(assume it is a) that satisfies a^2<=n? This 'a' is just what we want."
                    },
                    {
                        "username": "Chomolungma",
                        "content": "For any light, say, light k, it only gets switched when the interval is a factor of k.  Now, notice that factors come in pairs, that is, if a*b==k, you will switch light k at both intervals a and b.  As long as a !=b, the light k will be off in the end.  The only chance that light k remains on is when a==b, that is, k==a^2, , in this case it only gets switched once for this pair of factors.  So, k needs to be a square number!\\n\\nThen the question is really asking how many square numbers are smaller or equal to N, which is trivial to programmers."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "Hey, your name represents Mount Everest in Tibetan, right?!"
                    },
                    {
                        "username": "evahuynh95",
                        "content": "From my understanding, the bulbs change as follow:\\n1st round: [on,on,on,on,on]\\n2nd round: [on,off,on,off,on]\\n3rd round: [on,off,off,off,on]\\nnth/5th round: [on,off,off,off,off]\\n\\nMy understanding my be wrong, for it is not clear what should happen between round 4 to round n-1. I simply assumed nothing should happen between those rounds."
                    }
                ]
            },
            {
                "id": 1875108,
                "content": [
                    {
                        "username": "sugarteddy",
                        "content": "no wonder this got so many dislikes"
                    },
                    {
                        "username": "ikorpse",
                        "content": "I think such questions shouldn\\'t be asked on a coding interview, it has nothing to do with algorithmic coding"
                    },
                    {
                        "username": "ajesk",
                        "content": "This is my least favorite type of problem by far and it is even worse in today\\'s remote-centric world. \\n\\nThe way I would approach this problem in an in person setting, would be to write down every combination on an actual whiteboard until I realized the sqrt pattern.\\nDoing such a thing remotely is much more cumbersome and tougher to visualize."
                    },
                    {
                        "username": "kjers96",
                        "content": "Bro what even is this problem lol"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "more simplified explanation to the problem statement:\\nAt each step, you toggle every posiiton that is multiple of that step.\\nfor eg. at 2nd step, we toggle every multiple of 2( i.e. 2, 4, 6,8,... so on).\\nhope this helps :-)"
                    },
                    {
                        "username": "lowhochi",
                        "content": "Suppose there are n lightbulbs, Let L_k be the k-th lightbulb (k<=n). After n rounds, the light bulb L_k will be ON if k has odd number of factors (including 1 and k itself) and it will be OFF if k has even number of factors.\\n\\ne.g. L_16 will be ON after n rounds (n>=16) since 16 has five factors 1, 2, 4, 8, 16\\ne.g. L_24 will be OFF after n rounds (n>=24) since 24 has eight factors: 1, 2, 3, 4, 6, 8, 12, 24.\\n\\na number k has odd number of factors if and only if k is a perfect square.\\n\\nSuppos (p1, p2, ..., pr) are distinct prime factors of k.\\n\\nIf (r=1), we have k = p1^m => k has (m+1) factors 1, p1, p1^2, ..., p1^m\\nm+1 is odd when m is even => k = (p1^(m/2))^2 is a perfect square.\\n\\nIn general, k = p1^m1 * p2^m2 * ... * pr^mr has a total of (m1+1)(m2+1)...(mr+1) factors\\n(m1+1)(m2+1)...(mr+1) is odd if and only if all m1, m2, ..., mr are even numbers.\\nSo \\n>\\tk = [p1^(m1/2) * ... * pr^(mr/2)]^2 is a perfect square"
                    },
                    {
                        "username": "sschappy",
                        "content": "For every integer N, there happens : N=a * b ,while 1 <= a,b <=N \\n\\nnow assume the bulb number is 1,2,3,\\u2026\\u2026,N,\\u2026\\u2026\\nin (a) round, the bulb N changed its status;\\nin (b) round, the bulb N changed its status;\\n\\nWe know\\uFF1A\\nif a **!=** b, the bulb N changed twice, so it **remain** its status;\\nif a **==** b, the bulb N changed once, so it **changed** its status;\\n\\nAbove conclusion always happens, \\n\\nFor bulb N, the (N+1),(N+2),\\u2026\\u2026 round doesn\\'t affect; \\nFor any number a,\\nif N%a!=0, this (a) round doesn\\'t affect\\nif N%a==0, there must has number b=N/a,\\n(1) if a != b \\uFF0Cthe bulb remain its status\\n(2) if a == b \\uFF0Cthe bulb change its status\\n\\nIf N is big enough, only the bulb 1,4,9,16,25, \\u2026\\u2026  change its status\\nWe should count how many numbers could write as (a * a)\\uFF0Cso the answer is **sqrt(N)**"
                    },
                    {
                        "username": "qsli",
                        "content": "I can understand the solution is to find the count of numbers below n which can be sqrt, but why sqrt(n) is right?"
                    },
                    {
                        "username": "mtx",
                        "content": "When all the loop is done, only numbers a^2 which satisfy a<=n&&a^2<=n will be 1, other digits are all flipped to zero, for if a digit wants to remain 1, it must flip twice.\\nfor example, n=5\\nloop k:\\n2^2<=5,so only digit 4 flips twice, digit 2 and digit 3 and digit 5 only flips once. The last digit also satisfies this.\\nSo sqrt(n) means what is the max digit(assume it is a) that satisfies a^2<=n? This 'a' is just what we want."
                    },
                    {
                        "username": "Chomolungma",
                        "content": "For any light, say, light k, it only gets switched when the interval is a factor of k.  Now, notice that factors come in pairs, that is, if a*b==k, you will switch light k at both intervals a and b.  As long as a !=b, the light k will be off in the end.  The only chance that light k remains on is when a==b, that is, k==a^2, , in this case it only gets switched once for this pair of factors.  So, k needs to be a square number!\\n\\nThen the question is really asking how many square numbers are smaller or equal to N, which is trivial to programmers."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "Hey, your name represents Mount Everest in Tibetan, right?!"
                    },
                    {
                        "username": "evahuynh95",
                        "content": "From my understanding, the bulbs change as follow:\\n1st round: [on,on,on,on,on]\\n2nd round: [on,off,on,off,on]\\n3rd round: [on,off,off,off,on]\\nnth/5th round: [on,off,off,off,off]\\n\\nMy understanding my be wrong, for it is not clear what should happen between round 4 to round n-1. I simply assumed nothing should happen between those rounds."
                    }
                ]
            },
            {
                "id": 1875091,
                "content": [
                    {
                        "username": "sugarteddy",
                        "content": "no wonder this got so many dislikes"
                    },
                    {
                        "username": "ikorpse",
                        "content": "I think such questions shouldn\\'t be asked on a coding interview, it has nothing to do with algorithmic coding"
                    },
                    {
                        "username": "ajesk",
                        "content": "This is my least favorite type of problem by far and it is even worse in today\\'s remote-centric world. \\n\\nThe way I would approach this problem in an in person setting, would be to write down every combination on an actual whiteboard until I realized the sqrt pattern.\\nDoing such a thing remotely is much more cumbersome and tougher to visualize."
                    },
                    {
                        "username": "kjers96",
                        "content": "Bro what even is this problem lol"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "more simplified explanation to the problem statement:\\nAt each step, you toggle every posiiton that is multiple of that step.\\nfor eg. at 2nd step, we toggle every multiple of 2( i.e. 2, 4, 6,8,... so on).\\nhope this helps :-)"
                    },
                    {
                        "username": "lowhochi",
                        "content": "Suppose there are n lightbulbs, Let L_k be the k-th lightbulb (k<=n). After n rounds, the light bulb L_k will be ON if k has odd number of factors (including 1 and k itself) and it will be OFF if k has even number of factors.\\n\\ne.g. L_16 will be ON after n rounds (n>=16) since 16 has five factors 1, 2, 4, 8, 16\\ne.g. L_24 will be OFF after n rounds (n>=24) since 24 has eight factors: 1, 2, 3, 4, 6, 8, 12, 24.\\n\\na number k has odd number of factors if and only if k is a perfect square.\\n\\nSuppos (p1, p2, ..., pr) are distinct prime factors of k.\\n\\nIf (r=1), we have k = p1^m => k has (m+1) factors 1, p1, p1^2, ..., p1^m\\nm+1 is odd when m is even => k = (p1^(m/2))^2 is a perfect square.\\n\\nIn general, k = p1^m1 * p2^m2 * ... * pr^mr has a total of (m1+1)(m2+1)...(mr+1) factors\\n(m1+1)(m2+1)...(mr+1) is odd if and only if all m1, m2, ..., mr are even numbers.\\nSo \\n>\\tk = [p1^(m1/2) * ... * pr^(mr/2)]^2 is a perfect square"
                    },
                    {
                        "username": "sschappy",
                        "content": "For every integer N, there happens : N=a * b ,while 1 <= a,b <=N \\n\\nnow assume the bulb number is 1,2,3,\\u2026\\u2026,N,\\u2026\\u2026\\nin (a) round, the bulb N changed its status;\\nin (b) round, the bulb N changed its status;\\n\\nWe know\\uFF1A\\nif a **!=** b, the bulb N changed twice, so it **remain** its status;\\nif a **==** b, the bulb N changed once, so it **changed** its status;\\n\\nAbove conclusion always happens, \\n\\nFor bulb N, the (N+1),(N+2),\\u2026\\u2026 round doesn\\'t affect; \\nFor any number a,\\nif N%a!=0, this (a) round doesn\\'t affect\\nif N%a==0, there must has number b=N/a,\\n(1) if a != b \\uFF0Cthe bulb remain its status\\n(2) if a == b \\uFF0Cthe bulb change its status\\n\\nIf N is big enough, only the bulb 1,4,9,16,25, \\u2026\\u2026  change its status\\nWe should count how many numbers could write as (a * a)\\uFF0Cso the answer is **sqrt(N)**"
                    },
                    {
                        "username": "qsli",
                        "content": "I can understand the solution is to find the count of numbers below n which can be sqrt, but why sqrt(n) is right?"
                    },
                    {
                        "username": "mtx",
                        "content": "When all the loop is done, only numbers a^2 which satisfy a<=n&&a^2<=n will be 1, other digits are all flipped to zero, for if a digit wants to remain 1, it must flip twice.\\nfor example, n=5\\nloop k:\\n2^2<=5,so only digit 4 flips twice, digit 2 and digit 3 and digit 5 only flips once. The last digit also satisfies this.\\nSo sqrt(n) means what is the max digit(assume it is a) that satisfies a^2<=n? This 'a' is just what we want."
                    },
                    {
                        "username": "Chomolungma",
                        "content": "For any light, say, light k, it only gets switched when the interval is a factor of k.  Now, notice that factors come in pairs, that is, if a*b==k, you will switch light k at both intervals a and b.  As long as a !=b, the light k will be off in the end.  The only chance that light k remains on is when a==b, that is, k==a^2, , in this case it only gets switched once for this pair of factors.  So, k needs to be a square number!\\n\\nThen the question is really asking how many square numbers are smaller or equal to N, which is trivial to programmers."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "Hey, your name represents Mount Everest in Tibetan, right?!"
                    },
                    {
                        "username": "evahuynh95",
                        "content": "From my understanding, the bulbs change as follow:\\n1st round: [on,on,on,on,on]\\n2nd round: [on,off,on,off,on]\\n3rd round: [on,off,off,off,on]\\nnth/5th round: [on,off,off,off,off]\\n\\nMy understanding my be wrong, for it is not clear what should happen between round 4 to round n-1. I simply assumed nothing should happen between those rounds."
                    }
                ]
            },
            {
                "id": 1875064,
                "content": [
                    {
                        "username": "sugarteddy",
                        "content": "no wonder this got so many dislikes"
                    },
                    {
                        "username": "ikorpse",
                        "content": "I think such questions shouldn\\'t be asked on a coding interview, it has nothing to do with algorithmic coding"
                    },
                    {
                        "username": "ajesk",
                        "content": "This is my least favorite type of problem by far and it is even worse in today\\'s remote-centric world. \\n\\nThe way I would approach this problem in an in person setting, would be to write down every combination on an actual whiteboard until I realized the sqrt pattern.\\nDoing such a thing remotely is much more cumbersome and tougher to visualize."
                    },
                    {
                        "username": "kjers96",
                        "content": "Bro what even is this problem lol"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "more simplified explanation to the problem statement:\\nAt each step, you toggle every posiiton that is multiple of that step.\\nfor eg. at 2nd step, we toggle every multiple of 2( i.e. 2, 4, 6,8,... so on).\\nhope this helps :-)"
                    },
                    {
                        "username": "lowhochi",
                        "content": "Suppose there are n lightbulbs, Let L_k be the k-th lightbulb (k<=n). After n rounds, the light bulb L_k will be ON if k has odd number of factors (including 1 and k itself) and it will be OFF if k has even number of factors.\\n\\ne.g. L_16 will be ON after n rounds (n>=16) since 16 has five factors 1, 2, 4, 8, 16\\ne.g. L_24 will be OFF after n rounds (n>=24) since 24 has eight factors: 1, 2, 3, 4, 6, 8, 12, 24.\\n\\na number k has odd number of factors if and only if k is a perfect square.\\n\\nSuppos (p1, p2, ..., pr) are distinct prime factors of k.\\n\\nIf (r=1), we have k = p1^m => k has (m+1) factors 1, p1, p1^2, ..., p1^m\\nm+1 is odd when m is even => k = (p1^(m/2))^2 is a perfect square.\\n\\nIn general, k = p1^m1 * p2^m2 * ... * pr^mr has a total of (m1+1)(m2+1)...(mr+1) factors\\n(m1+1)(m2+1)...(mr+1) is odd if and only if all m1, m2, ..., mr are even numbers.\\nSo \\n>\\tk = [p1^(m1/2) * ... * pr^(mr/2)]^2 is a perfect square"
                    },
                    {
                        "username": "sschappy",
                        "content": "For every integer N, there happens : N=a * b ,while 1 <= a,b <=N \\n\\nnow assume the bulb number is 1,2,3,\\u2026\\u2026,N,\\u2026\\u2026\\nin (a) round, the bulb N changed its status;\\nin (b) round, the bulb N changed its status;\\n\\nWe know\\uFF1A\\nif a **!=** b, the bulb N changed twice, so it **remain** its status;\\nif a **==** b, the bulb N changed once, so it **changed** its status;\\n\\nAbove conclusion always happens, \\n\\nFor bulb N, the (N+1),(N+2),\\u2026\\u2026 round doesn\\'t affect; \\nFor any number a,\\nif N%a!=0, this (a) round doesn\\'t affect\\nif N%a==0, there must has number b=N/a,\\n(1) if a != b \\uFF0Cthe bulb remain its status\\n(2) if a == b \\uFF0Cthe bulb change its status\\n\\nIf N is big enough, only the bulb 1,4,9,16,25, \\u2026\\u2026  change its status\\nWe should count how many numbers could write as (a * a)\\uFF0Cso the answer is **sqrt(N)**"
                    },
                    {
                        "username": "qsli",
                        "content": "I can understand the solution is to find the count of numbers below n which can be sqrt, but why sqrt(n) is right?"
                    },
                    {
                        "username": "mtx",
                        "content": "When all the loop is done, only numbers a^2 which satisfy a<=n&&a^2<=n will be 1, other digits are all flipped to zero, for if a digit wants to remain 1, it must flip twice.\\nfor example, n=5\\nloop k:\\n2^2<=5,so only digit 4 flips twice, digit 2 and digit 3 and digit 5 only flips once. The last digit also satisfies this.\\nSo sqrt(n) means what is the max digit(assume it is a) that satisfies a^2<=n? This 'a' is just what we want."
                    },
                    {
                        "username": "Chomolungma",
                        "content": "For any light, say, light k, it only gets switched when the interval is a factor of k.  Now, notice that factors come in pairs, that is, if a*b==k, you will switch light k at both intervals a and b.  As long as a !=b, the light k will be off in the end.  The only chance that light k remains on is when a==b, that is, k==a^2, , in this case it only gets switched once for this pair of factors.  So, k needs to be a square number!\\n\\nThen the question is really asking how many square numbers are smaller or equal to N, which is trivial to programmers."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "Hey, your name represents Mount Everest in Tibetan, right?!"
                    },
                    {
                        "username": "evahuynh95",
                        "content": "From my understanding, the bulbs change as follow:\\n1st round: [on,on,on,on,on]\\n2nd round: [on,off,on,off,on]\\n3rd round: [on,off,off,off,on]\\nnth/5th round: [on,off,off,off,off]\\n\\nMy understanding my be wrong, for it is not clear what should happen between round 4 to round n-1. I simply assumed nothing should happen between those rounds."
                    }
                ]
            },
            {
                "id": 1576776,
                "content": [
                    {
                        "username": "sugarteddy",
                        "content": "no wonder this got so many dislikes"
                    },
                    {
                        "username": "ikorpse",
                        "content": "I think such questions shouldn\\'t be asked on a coding interview, it has nothing to do with algorithmic coding"
                    },
                    {
                        "username": "ajesk",
                        "content": "This is my least favorite type of problem by far and it is even worse in today\\'s remote-centric world. \\n\\nThe way I would approach this problem in an in person setting, would be to write down every combination on an actual whiteboard until I realized the sqrt pattern.\\nDoing such a thing remotely is much more cumbersome and tougher to visualize."
                    },
                    {
                        "username": "kjers96",
                        "content": "Bro what even is this problem lol"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "more simplified explanation to the problem statement:\\nAt each step, you toggle every posiiton that is multiple of that step.\\nfor eg. at 2nd step, we toggle every multiple of 2( i.e. 2, 4, 6,8,... so on).\\nhope this helps :-)"
                    },
                    {
                        "username": "lowhochi",
                        "content": "Suppose there are n lightbulbs, Let L_k be the k-th lightbulb (k<=n). After n rounds, the light bulb L_k will be ON if k has odd number of factors (including 1 and k itself) and it will be OFF if k has even number of factors.\\n\\ne.g. L_16 will be ON after n rounds (n>=16) since 16 has five factors 1, 2, 4, 8, 16\\ne.g. L_24 will be OFF after n rounds (n>=24) since 24 has eight factors: 1, 2, 3, 4, 6, 8, 12, 24.\\n\\na number k has odd number of factors if and only if k is a perfect square.\\n\\nSuppos (p1, p2, ..., pr) are distinct prime factors of k.\\n\\nIf (r=1), we have k = p1^m => k has (m+1) factors 1, p1, p1^2, ..., p1^m\\nm+1 is odd when m is even => k = (p1^(m/2))^2 is a perfect square.\\n\\nIn general, k = p1^m1 * p2^m2 * ... * pr^mr has a total of (m1+1)(m2+1)...(mr+1) factors\\n(m1+1)(m2+1)...(mr+1) is odd if and only if all m1, m2, ..., mr are even numbers.\\nSo \\n>\\tk = [p1^(m1/2) * ... * pr^(mr/2)]^2 is a perfect square"
                    },
                    {
                        "username": "sschappy",
                        "content": "For every integer N, there happens : N=a * b ,while 1 <= a,b <=N \\n\\nnow assume the bulb number is 1,2,3,\\u2026\\u2026,N,\\u2026\\u2026\\nin (a) round, the bulb N changed its status;\\nin (b) round, the bulb N changed its status;\\n\\nWe know\\uFF1A\\nif a **!=** b, the bulb N changed twice, so it **remain** its status;\\nif a **==** b, the bulb N changed once, so it **changed** its status;\\n\\nAbove conclusion always happens, \\n\\nFor bulb N, the (N+1),(N+2),\\u2026\\u2026 round doesn\\'t affect; \\nFor any number a,\\nif N%a!=0, this (a) round doesn\\'t affect\\nif N%a==0, there must has number b=N/a,\\n(1) if a != b \\uFF0Cthe bulb remain its status\\n(2) if a == b \\uFF0Cthe bulb change its status\\n\\nIf N is big enough, only the bulb 1,4,9,16,25, \\u2026\\u2026  change its status\\nWe should count how many numbers could write as (a * a)\\uFF0Cso the answer is **sqrt(N)**"
                    },
                    {
                        "username": "qsli",
                        "content": "I can understand the solution is to find the count of numbers below n which can be sqrt, but why sqrt(n) is right?"
                    },
                    {
                        "username": "mtx",
                        "content": "When all the loop is done, only numbers a^2 which satisfy a<=n&&a^2<=n will be 1, other digits are all flipped to zero, for if a digit wants to remain 1, it must flip twice.\\nfor example, n=5\\nloop k:\\n2^2<=5,so only digit 4 flips twice, digit 2 and digit 3 and digit 5 only flips once. The last digit also satisfies this.\\nSo sqrt(n) means what is the max digit(assume it is a) that satisfies a^2<=n? This 'a' is just what we want."
                    },
                    {
                        "username": "Chomolungma",
                        "content": "For any light, say, light k, it only gets switched when the interval is a factor of k.  Now, notice that factors come in pairs, that is, if a*b==k, you will switch light k at both intervals a and b.  As long as a !=b, the light k will be off in the end.  The only chance that light k remains on is when a==b, that is, k==a^2, , in this case it only gets switched once for this pair of factors.  So, k needs to be a square number!\\n\\nThen the question is really asking how many square numbers are smaller or equal to N, which is trivial to programmers."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "Hey, your name represents Mount Everest in Tibetan, right?!"
                    },
                    {
                        "username": "evahuynh95",
                        "content": "From my understanding, the bulbs change as follow:\\n1st round: [on,on,on,on,on]\\n2nd round: [on,off,on,off,on]\\n3rd round: [on,off,off,off,on]\\nnth/5th round: [on,off,off,off,off]\\n\\nMy understanding my be wrong, for it is not clear what should happen between round 4 to round n-1. I simply assumed nothing should happen between those rounds."
                    }
                ]
            },
            {
                "id": 1574309,
                "content": [
                    {
                        "username": "sugarteddy",
                        "content": "no wonder this got so many dislikes"
                    },
                    {
                        "username": "ikorpse",
                        "content": "I think such questions shouldn\\'t be asked on a coding interview, it has nothing to do with algorithmic coding"
                    },
                    {
                        "username": "ajesk",
                        "content": "This is my least favorite type of problem by far and it is even worse in today\\'s remote-centric world. \\n\\nThe way I would approach this problem in an in person setting, would be to write down every combination on an actual whiteboard until I realized the sqrt pattern.\\nDoing such a thing remotely is much more cumbersome and tougher to visualize."
                    },
                    {
                        "username": "kjers96",
                        "content": "Bro what even is this problem lol"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "more simplified explanation to the problem statement:\\nAt each step, you toggle every posiiton that is multiple of that step.\\nfor eg. at 2nd step, we toggle every multiple of 2( i.e. 2, 4, 6,8,... so on).\\nhope this helps :-)"
                    },
                    {
                        "username": "lowhochi",
                        "content": "Suppose there are n lightbulbs, Let L_k be the k-th lightbulb (k<=n). After n rounds, the light bulb L_k will be ON if k has odd number of factors (including 1 and k itself) and it will be OFF if k has even number of factors.\\n\\ne.g. L_16 will be ON after n rounds (n>=16) since 16 has five factors 1, 2, 4, 8, 16\\ne.g. L_24 will be OFF after n rounds (n>=24) since 24 has eight factors: 1, 2, 3, 4, 6, 8, 12, 24.\\n\\na number k has odd number of factors if and only if k is a perfect square.\\n\\nSuppos (p1, p2, ..., pr) are distinct prime factors of k.\\n\\nIf (r=1), we have k = p1^m => k has (m+1) factors 1, p1, p1^2, ..., p1^m\\nm+1 is odd when m is even => k = (p1^(m/2))^2 is a perfect square.\\n\\nIn general, k = p1^m1 * p2^m2 * ... * pr^mr has a total of (m1+1)(m2+1)...(mr+1) factors\\n(m1+1)(m2+1)...(mr+1) is odd if and only if all m1, m2, ..., mr are even numbers.\\nSo \\n>\\tk = [p1^(m1/2) * ... * pr^(mr/2)]^2 is a perfect square"
                    },
                    {
                        "username": "sschappy",
                        "content": "For every integer N, there happens : N=a * b ,while 1 <= a,b <=N \\n\\nnow assume the bulb number is 1,2,3,\\u2026\\u2026,N,\\u2026\\u2026\\nin (a) round, the bulb N changed its status;\\nin (b) round, the bulb N changed its status;\\n\\nWe know\\uFF1A\\nif a **!=** b, the bulb N changed twice, so it **remain** its status;\\nif a **==** b, the bulb N changed once, so it **changed** its status;\\n\\nAbove conclusion always happens, \\n\\nFor bulb N, the (N+1),(N+2),\\u2026\\u2026 round doesn\\'t affect; \\nFor any number a,\\nif N%a!=0, this (a) round doesn\\'t affect\\nif N%a==0, there must has number b=N/a,\\n(1) if a != b \\uFF0Cthe bulb remain its status\\n(2) if a == b \\uFF0Cthe bulb change its status\\n\\nIf N is big enough, only the bulb 1,4,9,16,25, \\u2026\\u2026  change its status\\nWe should count how many numbers could write as (a * a)\\uFF0Cso the answer is **sqrt(N)**"
                    },
                    {
                        "username": "qsli",
                        "content": "I can understand the solution is to find the count of numbers below n which can be sqrt, but why sqrt(n) is right?"
                    },
                    {
                        "username": "mtx",
                        "content": "When all the loop is done, only numbers a^2 which satisfy a<=n&&a^2<=n will be 1, other digits are all flipped to zero, for if a digit wants to remain 1, it must flip twice.\\nfor example, n=5\\nloop k:\\n2^2<=5,so only digit 4 flips twice, digit 2 and digit 3 and digit 5 only flips once. The last digit also satisfies this.\\nSo sqrt(n) means what is the max digit(assume it is a) that satisfies a^2<=n? This 'a' is just what we want."
                    },
                    {
                        "username": "Chomolungma",
                        "content": "For any light, say, light k, it only gets switched when the interval is a factor of k.  Now, notice that factors come in pairs, that is, if a*b==k, you will switch light k at both intervals a and b.  As long as a !=b, the light k will be off in the end.  The only chance that light k remains on is when a==b, that is, k==a^2, , in this case it only gets switched once for this pair of factors.  So, k needs to be a square number!\\n\\nThen the question is really asking how many square numbers are smaller or equal to N, which is trivial to programmers."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "Hey, your name represents Mount Everest in Tibetan, right?!"
                    },
                    {
                        "username": "evahuynh95",
                        "content": "From my understanding, the bulbs change as follow:\\n1st round: [on,on,on,on,on]\\n2nd round: [on,off,on,off,on]\\n3rd round: [on,off,off,off,on]\\nnth/5th round: [on,off,off,off,off]\\n\\nMy understanding my be wrong, for it is not clear what should happen between round 4 to round n-1. I simply assumed nothing should happen between those rounds."
                    }
                ]
            },
            {
                "id": 1571571,
                "content": [
                    {
                        "username": "sugarteddy",
                        "content": "no wonder this got so many dislikes"
                    },
                    {
                        "username": "ikorpse",
                        "content": "I think such questions shouldn\\'t be asked on a coding interview, it has nothing to do with algorithmic coding"
                    },
                    {
                        "username": "ajesk",
                        "content": "This is my least favorite type of problem by far and it is even worse in today\\'s remote-centric world. \\n\\nThe way I would approach this problem in an in person setting, would be to write down every combination on an actual whiteboard until I realized the sqrt pattern.\\nDoing such a thing remotely is much more cumbersome and tougher to visualize."
                    },
                    {
                        "username": "kjers96",
                        "content": "Bro what even is this problem lol"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "more simplified explanation to the problem statement:\\nAt each step, you toggle every posiiton that is multiple of that step.\\nfor eg. at 2nd step, we toggle every multiple of 2( i.e. 2, 4, 6,8,... so on).\\nhope this helps :-)"
                    },
                    {
                        "username": "lowhochi",
                        "content": "Suppose there are n lightbulbs, Let L_k be the k-th lightbulb (k<=n). After n rounds, the light bulb L_k will be ON if k has odd number of factors (including 1 and k itself) and it will be OFF if k has even number of factors.\\n\\ne.g. L_16 will be ON after n rounds (n>=16) since 16 has five factors 1, 2, 4, 8, 16\\ne.g. L_24 will be OFF after n rounds (n>=24) since 24 has eight factors: 1, 2, 3, 4, 6, 8, 12, 24.\\n\\na number k has odd number of factors if and only if k is a perfect square.\\n\\nSuppos (p1, p2, ..., pr) are distinct prime factors of k.\\n\\nIf (r=1), we have k = p1^m => k has (m+1) factors 1, p1, p1^2, ..., p1^m\\nm+1 is odd when m is even => k = (p1^(m/2))^2 is a perfect square.\\n\\nIn general, k = p1^m1 * p2^m2 * ... * pr^mr has a total of (m1+1)(m2+1)...(mr+1) factors\\n(m1+1)(m2+1)...(mr+1) is odd if and only if all m1, m2, ..., mr are even numbers.\\nSo \\n>\\tk = [p1^(m1/2) * ... * pr^(mr/2)]^2 is a perfect square"
                    },
                    {
                        "username": "sschappy",
                        "content": "For every integer N, there happens : N=a * b ,while 1 <= a,b <=N \\n\\nnow assume the bulb number is 1,2,3,\\u2026\\u2026,N,\\u2026\\u2026\\nin (a) round, the bulb N changed its status;\\nin (b) round, the bulb N changed its status;\\n\\nWe know\\uFF1A\\nif a **!=** b, the bulb N changed twice, so it **remain** its status;\\nif a **==** b, the bulb N changed once, so it **changed** its status;\\n\\nAbove conclusion always happens, \\n\\nFor bulb N, the (N+1),(N+2),\\u2026\\u2026 round doesn\\'t affect; \\nFor any number a,\\nif N%a!=0, this (a) round doesn\\'t affect\\nif N%a==0, there must has number b=N/a,\\n(1) if a != b \\uFF0Cthe bulb remain its status\\n(2) if a == b \\uFF0Cthe bulb change its status\\n\\nIf N is big enough, only the bulb 1,4,9,16,25, \\u2026\\u2026  change its status\\nWe should count how many numbers could write as (a * a)\\uFF0Cso the answer is **sqrt(N)**"
                    },
                    {
                        "username": "qsli",
                        "content": "I can understand the solution is to find the count of numbers below n which can be sqrt, but why sqrt(n) is right?"
                    },
                    {
                        "username": "mtx",
                        "content": "When all the loop is done, only numbers a^2 which satisfy a<=n&&a^2<=n will be 1, other digits are all flipped to zero, for if a digit wants to remain 1, it must flip twice.\\nfor example, n=5\\nloop k:\\n2^2<=5,so only digit 4 flips twice, digit 2 and digit 3 and digit 5 only flips once. The last digit also satisfies this.\\nSo sqrt(n) means what is the max digit(assume it is a) that satisfies a^2<=n? This 'a' is just what we want."
                    },
                    {
                        "username": "Chomolungma",
                        "content": "For any light, say, light k, it only gets switched when the interval is a factor of k.  Now, notice that factors come in pairs, that is, if a*b==k, you will switch light k at both intervals a and b.  As long as a !=b, the light k will be off in the end.  The only chance that light k remains on is when a==b, that is, k==a^2, , in this case it only gets switched once for this pair of factors.  So, k needs to be a square number!\\n\\nThen the question is really asking how many square numbers are smaller or equal to N, which is trivial to programmers."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "Hey, your name represents Mount Everest in Tibetan, right?!"
                    },
                    {
                        "username": "evahuynh95",
                        "content": "From my understanding, the bulbs change as follow:\\n1st round: [on,on,on,on,on]\\n2nd round: [on,off,on,off,on]\\n3rd round: [on,off,off,off,on]\\nnth/5th round: [on,off,off,off,off]\\n\\nMy understanding my be wrong, for it is not clear what should happen between round 4 to round n-1. I simply assumed nothing should happen between those rounds."
                    }
                ]
            },
            {
                "id": 1571572,
                "content": [
                    {
                        "username": "sugarteddy",
                        "content": "no wonder this got so many dislikes"
                    },
                    {
                        "username": "ikorpse",
                        "content": "I think such questions shouldn\\'t be asked on a coding interview, it has nothing to do with algorithmic coding"
                    },
                    {
                        "username": "ajesk",
                        "content": "This is my least favorite type of problem by far and it is even worse in today\\'s remote-centric world. \\n\\nThe way I would approach this problem in an in person setting, would be to write down every combination on an actual whiteboard until I realized the sqrt pattern.\\nDoing such a thing remotely is much more cumbersome and tougher to visualize."
                    },
                    {
                        "username": "kjers96",
                        "content": "Bro what even is this problem lol"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "more simplified explanation to the problem statement:\\nAt each step, you toggle every posiiton that is multiple of that step.\\nfor eg. at 2nd step, we toggle every multiple of 2( i.e. 2, 4, 6,8,... so on).\\nhope this helps :-)"
                    },
                    {
                        "username": "lowhochi",
                        "content": "Suppose there are n lightbulbs, Let L_k be the k-th lightbulb (k<=n). After n rounds, the light bulb L_k will be ON if k has odd number of factors (including 1 and k itself) and it will be OFF if k has even number of factors.\\n\\ne.g. L_16 will be ON after n rounds (n>=16) since 16 has five factors 1, 2, 4, 8, 16\\ne.g. L_24 will be OFF after n rounds (n>=24) since 24 has eight factors: 1, 2, 3, 4, 6, 8, 12, 24.\\n\\na number k has odd number of factors if and only if k is a perfect square.\\n\\nSuppos (p1, p2, ..., pr) are distinct prime factors of k.\\n\\nIf (r=1), we have k = p1^m => k has (m+1) factors 1, p1, p1^2, ..., p1^m\\nm+1 is odd when m is even => k = (p1^(m/2))^2 is a perfect square.\\n\\nIn general, k = p1^m1 * p2^m2 * ... * pr^mr has a total of (m1+1)(m2+1)...(mr+1) factors\\n(m1+1)(m2+1)...(mr+1) is odd if and only if all m1, m2, ..., mr are even numbers.\\nSo \\n>\\tk = [p1^(m1/2) * ... * pr^(mr/2)]^2 is a perfect square"
                    },
                    {
                        "username": "sschappy",
                        "content": "For every integer N, there happens : N=a * b ,while 1 <= a,b <=N \\n\\nnow assume the bulb number is 1,2,3,\\u2026\\u2026,N,\\u2026\\u2026\\nin (a) round, the bulb N changed its status;\\nin (b) round, the bulb N changed its status;\\n\\nWe know\\uFF1A\\nif a **!=** b, the bulb N changed twice, so it **remain** its status;\\nif a **==** b, the bulb N changed once, so it **changed** its status;\\n\\nAbove conclusion always happens, \\n\\nFor bulb N, the (N+1),(N+2),\\u2026\\u2026 round doesn\\'t affect; \\nFor any number a,\\nif N%a!=0, this (a) round doesn\\'t affect\\nif N%a==0, there must has number b=N/a,\\n(1) if a != b \\uFF0Cthe bulb remain its status\\n(2) if a == b \\uFF0Cthe bulb change its status\\n\\nIf N is big enough, only the bulb 1,4,9,16,25, \\u2026\\u2026  change its status\\nWe should count how many numbers could write as (a * a)\\uFF0Cso the answer is **sqrt(N)**"
                    },
                    {
                        "username": "qsli",
                        "content": "I can understand the solution is to find the count of numbers below n which can be sqrt, but why sqrt(n) is right?"
                    },
                    {
                        "username": "mtx",
                        "content": "When all the loop is done, only numbers a^2 which satisfy a<=n&&a^2<=n will be 1, other digits are all flipped to zero, for if a digit wants to remain 1, it must flip twice.\\nfor example, n=5\\nloop k:\\n2^2<=5,so only digit 4 flips twice, digit 2 and digit 3 and digit 5 only flips once. The last digit also satisfies this.\\nSo sqrt(n) means what is the max digit(assume it is a) that satisfies a^2<=n? This 'a' is just what we want."
                    },
                    {
                        "username": "Chomolungma",
                        "content": "For any light, say, light k, it only gets switched when the interval is a factor of k.  Now, notice that factors come in pairs, that is, if a*b==k, you will switch light k at both intervals a and b.  As long as a !=b, the light k will be off in the end.  The only chance that light k remains on is when a==b, that is, k==a^2, , in this case it only gets switched once for this pair of factors.  So, k needs to be a square number!\\n\\nThen the question is really asking how many square numbers are smaller or equal to N, which is trivial to programmers."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "Hey, your name represents Mount Everest in Tibetan, right?!"
                    },
                    {
                        "username": "evahuynh95",
                        "content": "From my understanding, the bulbs change as follow:\\n1st round: [on,on,on,on,on]\\n2nd round: [on,off,on,off,on]\\n3rd round: [on,off,off,off,on]\\nnth/5th round: [on,off,off,off,off]\\n\\nMy understanding my be wrong, for it is not clear what should happen between round 4 to round n-1. I simply assumed nothing should happen between those rounds."
                    }
                ]
            },
            {
                "id": 1571573,
                "content": [
                    {
                        "username": "sugarteddy",
                        "content": "no wonder this got so many dislikes"
                    },
                    {
                        "username": "ikorpse",
                        "content": "I think such questions shouldn\\'t be asked on a coding interview, it has nothing to do with algorithmic coding"
                    },
                    {
                        "username": "ajesk",
                        "content": "This is my least favorite type of problem by far and it is even worse in today\\'s remote-centric world. \\n\\nThe way I would approach this problem in an in person setting, would be to write down every combination on an actual whiteboard until I realized the sqrt pattern.\\nDoing such a thing remotely is much more cumbersome and tougher to visualize."
                    },
                    {
                        "username": "kjers96",
                        "content": "Bro what even is this problem lol"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "more simplified explanation to the problem statement:\\nAt each step, you toggle every posiiton that is multiple of that step.\\nfor eg. at 2nd step, we toggle every multiple of 2( i.e. 2, 4, 6,8,... so on).\\nhope this helps :-)"
                    },
                    {
                        "username": "lowhochi",
                        "content": "Suppose there are n lightbulbs, Let L_k be the k-th lightbulb (k<=n). After n rounds, the light bulb L_k will be ON if k has odd number of factors (including 1 and k itself) and it will be OFF if k has even number of factors.\\n\\ne.g. L_16 will be ON after n rounds (n>=16) since 16 has five factors 1, 2, 4, 8, 16\\ne.g. L_24 will be OFF after n rounds (n>=24) since 24 has eight factors: 1, 2, 3, 4, 6, 8, 12, 24.\\n\\na number k has odd number of factors if and only if k is a perfect square.\\n\\nSuppos (p1, p2, ..., pr) are distinct prime factors of k.\\n\\nIf (r=1), we have k = p1^m => k has (m+1) factors 1, p1, p1^2, ..., p1^m\\nm+1 is odd when m is even => k = (p1^(m/2))^2 is a perfect square.\\n\\nIn general, k = p1^m1 * p2^m2 * ... * pr^mr has a total of (m1+1)(m2+1)...(mr+1) factors\\n(m1+1)(m2+1)...(mr+1) is odd if and only if all m1, m2, ..., mr are even numbers.\\nSo \\n>\\tk = [p1^(m1/2) * ... * pr^(mr/2)]^2 is a perfect square"
                    },
                    {
                        "username": "sschappy",
                        "content": "For every integer N, there happens : N=a * b ,while 1 <= a,b <=N \\n\\nnow assume the bulb number is 1,2,3,\\u2026\\u2026,N,\\u2026\\u2026\\nin (a) round, the bulb N changed its status;\\nin (b) round, the bulb N changed its status;\\n\\nWe know\\uFF1A\\nif a **!=** b, the bulb N changed twice, so it **remain** its status;\\nif a **==** b, the bulb N changed once, so it **changed** its status;\\n\\nAbove conclusion always happens, \\n\\nFor bulb N, the (N+1),(N+2),\\u2026\\u2026 round doesn\\'t affect; \\nFor any number a,\\nif N%a!=0, this (a) round doesn\\'t affect\\nif N%a==0, there must has number b=N/a,\\n(1) if a != b \\uFF0Cthe bulb remain its status\\n(2) if a == b \\uFF0Cthe bulb change its status\\n\\nIf N is big enough, only the bulb 1,4,9,16,25, \\u2026\\u2026  change its status\\nWe should count how many numbers could write as (a * a)\\uFF0Cso the answer is **sqrt(N)**"
                    },
                    {
                        "username": "qsli",
                        "content": "I can understand the solution is to find the count of numbers below n which can be sqrt, but why sqrt(n) is right?"
                    },
                    {
                        "username": "mtx",
                        "content": "When all the loop is done, only numbers a^2 which satisfy a<=n&&a^2<=n will be 1, other digits are all flipped to zero, for if a digit wants to remain 1, it must flip twice.\\nfor example, n=5\\nloop k:\\n2^2<=5,so only digit 4 flips twice, digit 2 and digit 3 and digit 5 only flips once. The last digit also satisfies this.\\nSo sqrt(n) means what is the max digit(assume it is a) that satisfies a^2<=n? This 'a' is just what we want."
                    },
                    {
                        "username": "Chomolungma",
                        "content": "For any light, say, light k, it only gets switched when the interval is a factor of k.  Now, notice that factors come in pairs, that is, if a*b==k, you will switch light k at both intervals a and b.  As long as a !=b, the light k will be off in the end.  The only chance that light k remains on is when a==b, that is, k==a^2, , in this case it only gets switched once for this pair of factors.  So, k needs to be a square number!\\n\\nThen the question is really asking how many square numbers are smaller or equal to N, which is trivial to programmers."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "Hey, your name represents Mount Everest in Tibetan, right?!"
                    },
                    {
                        "username": "evahuynh95",
                        "content": "From my understanding, the bulbs change as follow:\\n1st round: [on,on,on,on,on]\\n2nd round: [on,off,on,off,on]\\n3rd round: [on,off,off,off,on]\\nnth/5th round: [on,off,off,off,off]\\n\\nMy understanding my be wrong, for it is not clear what should happen between round 4 to round n-1. I simply assumed nothing should happen between those rounds."
                    }
                ]
            },
            {
                "id": 1571574,
                "content": [
                    {
                        "username": "sugarteddy",
                        "content": "no wonder this got so many dislikes"
                    },
                    {
                        "username": "ikorpse",
                        "content": "I think such questions shouldn\\'t be asked on a coding interview, it has nothing to do with algorithmic coding"
                    },
                    {
                        "username": "ajesk",
                        "content": "This is my least favorite type of problem by far and it is even worse in today\\'s remote-centric world. \\n\\nThe way I would approach this problem in an in person setting, would be to write down every combination on an actual whiteboard until I realized the sqrt pattern.\\nDoing such a thing remotely is much more cumbersome and tougher to visualize."
                    },
                    {
                        "username": "kjers96",
                        "content": "Bro what even is this problem lol"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "more simplified explanation to the problem statement:\\nAt each step, you toggle every posiiton that is multiple of that step.\\nfor eg. at 2nd step, we toggle every multiple of 2( i.e. 2, 4, 6,8,... so on).\\nhope this helps :-)"
                    },
                    {
                        "username": "lowhochi",
                        "content": "Suppose there are n lightbulbs, Let L_k be the k-th lightbulb (k<=n). After n rounds, the light bulb L_k will be ON if k has odd number of factors (including 1 and k itself) and it will be OFF if k has even number of factors.\\n\\ne.g. L_16 will be ON after n rounds (n>=16) since 16 has five factors 1, 2, 4, 8, 16\\ne.g. L_24 will be OFF after n rounds (n>=24) since 24 has eight factors: 1, 2, 3, 4, 6, 8, 12, 24.\\n\\na number k has odd number of factors if and only if k is a perfect square.\\n\\nSuppos (p1, p2, ..., pr) are distinct prime factors of k.\\n\\nIf (r=1), we have k = p1^m => k has (m+1) factors 1, p1, p1^2, ..., p1^m\\nm+1 is odd when m is even => k = (p1^(m/2))^2 is a perfect square.\\n\\nIn general, k = p1^m1 * p2^m2 * ... * pr^mr has a total of (m1+1)(m2+1)...(mr+1) factors\\n(m1+1)(m2+1)...(mr+1) is odd if and only if all m1, m2, ..., mr are even numbers.\\nSo \\n>\\tk = [p1^(m1/2) * ... * pr^(mr/2)]^2 is a perfect square"
                    },
                    {
                        "username": "sschappy",
                        "content": "For every integer N, there happens : N=a * b ,while 1 <= a,b <=N \\n\\nnow assume the bulb number is 1,2,3,\\u2026\\u2026,N,\\u2026\\u2026\\nin (a) round, the bulb N changed its status;\\nin (b) round, the bulb N changed its status;\\n\\nWe know\\uFF1A\\nif a **!=** b, the bulb N changed twice, so it **remain** its status;\\nif a **==** b, the bulb N changed once, so it **changed** its status;\\n\\nAbove conclusion always happens, \\n\\nFor bulb N, the (N+1),(N+2),\\u2026\\u2026 round doesn\\'t affect; \\nFor any number a,\\nif N%a!=0, this (a) round doesn\\'t affect\\nif N%a==0, there must has number b=N/a,\\n(1) if a != b \\uFF0Cthe bulb remain its status\\n(2) if a == b \\uFF0Cthe bulb change its status\\n\\nIf N is big enough, only the bulb 1,4,9,16,25, \\u2026\\u2026  change its status\\nWe should count how many numbers could write as (a * a)\\uFF0Cso the answer is **sqrt(N)**"
                    },
                    {
                        "username": "qsli",
                        "content": "I can understand the solution is to find the count of numbers below n which can be sqrt, but why sqrt(n) is right?"
                    },
                    {
                        "username": "mtx",
                        "content": "When all the loop is done, only numbers a^2 which satisfy a<=n&&a^2<=n will be 1, other digits are all flipped to zero, for if a digit wants to remain 1, it must flip twice.\\nfor example, n=5\\nloop k:\\n2^2<=5,so only digit 4 flips twice, digit 2 and digit 3 and digit 5 only flips once. The last digit also satisfies this.\\nSo sqrt(n) means what is the max digit(assume it is a) that satisfies a^2<=n? This 'a' is just what we want."
                    },
                    {
                        "username": "Chomolungma",
                        "content": "For any light, say, light k, it only gets switched when the interval is a factor of k.  Now, notice that factors come in pairs, that is, if a*b==k, you will switch light k at both intervals a and b.  As long as a !=b, the light k will be off in the end.  The only chance that light k remains on is when a==b, that is, k==a^2, , in this case it only gets switched once for this pair of factors.  So, k needs to be a square number!\\n\\nThen the question is really asking how many square numbers are smaller or equal to N, which is trivial to programmers."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "Hey, your name represents Mount Everest in Tibetan, right?!"
                    },
                    {
                        "username": "evahuynh95",
                        "content": "From my understanding, the bulbs change as follow:\\n1st round: [on,on,on,on,on]\\n2nd round: [on,off,on,off,on]\\n3rd round: [on,off,off,off,on]\\nnth/5th round: [on,off,off,off,off]\\n\\nMy understanding my be wrong, for it is not clear what should happen between round 4 to round n-1. I simply assumed nothing should happen between those rounds."
                    }
                ]
            },
            {
                "id": 2040685,
                "content": [
                    {
                        "username": "cachoseg",
                        "content": "math is already imported in kotlin, so do your work"
                    },
                    {
                        "username": "chavansushil153",
                        "content": "i new too leetcode.\\ni not solve this question. \\ni am live in ycce."
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "i put all integers till 30 in testcase analysed the outputs and found the below pattern\\n\\n        // 0 -> 0\\n        // 1 to 3 -> 1\\n        // 4 to 8 -> 2\\n        // 9 to 15 -> 3\\n        // 16 to 24 -> 4\\n        // 25 to 35 -> 5\\n       // pattern - for n belonging to [ i^2 ] and [ (i+1)^2 -1 ] the ans is i\\n\\n        int i = 0;\\n        while( n >= i*i ){\\n            i++; \\n        }\\n        cout<<\"ans = \"<<i-1<<endl;"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "I found only x^2 can have odd number of factors (x is a positive integer), so the result is floor(sqrt(n))."
                    },
                    {
                        "username": "shashwat963",
                        "content": "one line c++ solution \\njust type return floor(sqrt(n));"
                    },
                    {
                        "username": "AMerrill",
                        "content": "They did this problem on Numberphile!"
                    },
                    {
                        "username": "jasngh_004",
                        "content": "Just observe few output how ?????? solution is just of 2 lines... int ans return ans; explained below:\\nso do one thing check  output for 1 to 16 in console by simply return 1; in code ik that all will be wrong pattern but you can understand the pattern and logical through that.\\nthen after observing you can see for n=0 we have o/p = 0, n=(1 to 3) o/p=1, n =(4to8) o/p = 2, n=(9to15) o/p = 3 and go ahead in short in question language when we go from ith to nth round on sqrt(n) we have toggle all bulbs thus in nth round no. of toggle button will be \\n\\n\"return sqrt(n);\" \\n\\nhope it helps happy coding :) upvote with a smile"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "wording kinda caught me at first.\\nwas thinking every second bulb turns on from ith bulb in the ith round lol"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "It can be solved with just one statement, once you figure out the pattern between the \"n\" and the answer. \\nThe solution boils down to a single line of code.\\nbulbSwitch(n){\\n   retrun k;  // easily deducible once you find the pattern\\n}"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "python is giving me 8.8ms for using this code  ```return int(sqrt(n)) ```\nwhile its 75.6 ms after using this stub \n```\nfrom math import sqrt\nreturn int(sqrt(n))\n```\nwhy is that happening can anyone explain pls"
                    }
                ]
            },
            {
                "id": 2009333,
                "content": [
                    {
                        "username": "cachoseg",
                        "content": "math is already imported in kotlin, so do your work"
                    },
                    {
                        "username": "chavansushil153",
                        "content": "i new too leetcode.\\ni not solve this question. \\ni am live in ycce."
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "i put all integers till 30 in testcase analysed the outputs and found the below pattern\\n\\n        // 0 -> 0\\n        // 1 to 3 -> 1\\n        // 4 to 8 -> 2\\n        // 9 to 15 -> 3\\n        // 16 to 24 -> 4\\n        // 25 to 35 -> 5\\n       // pattern - for n belonging to [ i^2 ] and [ (i+1)^2 -1 ] the ans is i\\n\\n        int i = 0;\\n        while( n >= i*i ){\\n            i++; \\n        }\\n        cout<<\"ans = \"<<i-1<<endl;"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "I found only x^2 can have odd number of factors (x is a positive integer), so the result is floor(sqrt(n))."
                    },
                    {
                        "username": "shashwat963",
                        "content": "one line c++ solution \\njust type return floor(sqrt(n));"
                    },
                    {
                        "username": "AMerrill",
                        "content": "They did this problem on Numberphile!"
                    },
                    {
                        "username": "jasngh_004",
                        "content": "Just observe few output how ?????? solution is just of 2 lines... int ans return ans; explained below:\\nso do one thing check  output for 1 to 16 in console by simply return 1; in code ik that all will be wrong pattern but you can understand the pattern and logical through that.\\nthen after observing you can see for n=0 we have o/p = 0, n=(1 to 3) o/p=1, n =(4to8) o/p = 2, n=(9to15) o/p = 3 and go ahead in short in question language when we go from ith to nth round on sqrt(n) we have toggle all bulbs thus in nth round no. of toggle button will be \\n\\n\"return sqrt(n);\" \\n\\nhope it helps happy coding :) upvote with a smile"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "wording kinda caught me at first.\\nwas thinking every second bulb turns on from ith bulb in the ith round lol"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "It can be solved with just one statement, once you figure out the pattern between the \"n\" and the answer. \\nThe solution boils down to a single line of code.\\nbulbSwitch(n){\\n   retrun k;  // easily deducible once you find the pattern\\n}"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "python is giving me 8.8ms for using this code  ```return int(sqrt(n)) ```\nwhile its 75.6 ms after using this stub \n```\nfrom math import sqrt\nreturn int(sqrt(n))\n```\nwhy is that happening can anyone explain pls"
                    }
                ]
            },
            {
                "id": 1958651,
                "content": [
                    {
                        "username": "cachoseg",
                        "content": "math is already imported in kotlin, so do your work"
                    },
                    {
                        "username": "chavansushil153",
                        "content": "i new too leetcode.\\ni not solve this question. \\ni am live in ycce."
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "i put all integers till 30 in testcase analysed the outputs and found the below pattern\\n\\n        // 0 -> 0\\n        // 1 to 3 -> 1\\n        // 4 to 8 -> 2\\n        // 9 to 15 -> 3\\n        // 16 to 24 -> 4\\n        // 25 to 35 -> 5\\n       // pattern - for n belonging to [ i^2 ] and [ (i+1)^2 -1 ] the ans is i\\n\\n        int i = 0;\\n        while( n >= i*i ){\\n            i++; \\n        }\\n        cout<<\"ans = \"<<i-1<<endl;"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "I found only x^2 can have odd number of factors (x is a positive integer), so the result is floor(sqrt(n))."
                    },
                    {
                        "username": "shashwat963",
                        "content": "one line c++ solution \\njust type return floor(sqrt(n));"
                    },
                    {
                        "username": "AMerrill",
                        "content": "They did this problem on Numberphile!"
                    },
                    {
                        "username": "jasngh_004",
                        "content": "Just observe few output how ?????? solution is just of 2 lines... int ans return ans; explained below:\\nso do one thing check  output for 1 to 16 in console by simply return 1; in code ik that all will be wrong pattern but you can understand the pattern and logical through that.\\nthen after observing you can see for n=0 we have o/p = 0, n=(1 to 3) o/p=1, n =(4to8) o/p = 2, n=(9to15) o/p = 3 and go ahead in short in question language when we go from ith to nth round on sqrt(n) we have toggle all bulbs thus in nth round no. of toggle button will be \\n\\n\"return sqrt(n);\" \\n\\nhope it helps happy coding :) upvote with a smile"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "wording kinda caught me at first.\\nwas thinking every second bulb turns on from ith bulb in the ith round lol"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "It can be solved with just one statement, once you figure out the pattern between the \"n\" and the answer. \\nThe solution boils down to a single line of code.\\nbulbSwitch(n){\\n   retrun k;  // easily deducible once you find the pattern\\n}"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "python is giving me 8.8ms for using this code  ```return int(sqrt(n)) ```\nwhile its 75.6 ms after using this stub \n```\nfrom math import sqrt\nreturn int(sqrt(n))\n```\nwhy is that happening can anyone explain pls"
                    }
                ]
            },
            {
                "id": 1908567,
                "content": [
                    {
                        "username": "cachoseg",
                        "content": "math is already imported in kotlin, so do your work"
                    },
                    {
                        "username": "chavansushil153",
                        "content": "i new too leetcode.\\ni not solve this question. \\ni am live in ycce."
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "i put all integers till 30 in testcase analysed the outputs and found the below pattern\\n\\n        // 0 -> 0\\n        // 1 to 3 -> 1\\n        // 4 to 8 -> 2\\n        // 9 to 15 -> 3\\n        // 16 to 24 -> 4\\n        // 25 to 35 -> 5\\n       // pattern - for n belonging to [ i^2 ] and [ (i+1)^2 -1 ] the ans is i\\n\\n        int i = 0;\\n        while( n >= i*i ){\\n            i++; \\n        }\\n        cout<<\"ans = \"<<i-1<<endl;"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "I found only x^2 can have odd number of factors (x is a positive integer), so the result is floor(sqrt(n))."
                    },
                    {
                        "username": "shashwat963",
                        "content": "one line c++ solution \\njust type return floor(sqrt(n));"
                    },
                    {
                        "username": "AMerrill",
                        "content": "They did this problem on Numberphile!"
                    },
                    {
                        "username": "jasngh_004",
                        "content": "Just observe few output how ?????? solution is just of 2 lines... int ans return ans; explained below:\\nso do one thing check  output for 1 to 16 in console by simply return 1; in code ik that all will be wrong pattern but you can understand the pattern and logical through that.\\nthen after observing you can see for n=0 we have o/p = 0, n=(1 to 3) o/p=1, n =(4to8) o/p = 2, n=(9to15) o/p = 3 and go ahead in short in question language when we go from ith to nth round on sqrt(n) we have toggle all bulbs thus in nth round no. of toggle button will be \\n\\n\"return sqrt(n);\" \\n\\nhope it helps happy coding :) upvote with a smile"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "wording kinda caught me at first.\\nwas thinking every second bulb turns on from ith bulb in the ith round lol"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "It can be solved with just one statement, once you figure out the pattern between the \"n\" and the answer. \\nThe solution boils down to a single line of code.\\nbulbSwitch(n){\\n   retrun k;  // easily deducible once you find the pattern\\n}"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "python is giving me 8.8ms for using this code  ```return int(sqrt(n)) ```\nwhile its 75.6 ms after using this stub \n```\nfrom math import sqrt\nreturn int(sqrt(n))\n```\nwhy is that happening can anyone explain pls"
                    }
                ]
            },
            {
                "id": 1876034,
                "content": [
                    {
                        "username": "cachoseg",
                        "content": "math is already imported in kotlin, so do your work"
                    },
                    {
                        "username": "chavansushil153",
                        "content": "i new too leetcode.\\ni not solve this question. \\ni am live in ycce."
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "i put all integers till 30 in testcase analysed the outputs and found the below pattern\\n\\n        // 0 -> 0\\n        // 1 to 3 -> 1\\n        // 4 to 8 -> 2\\n        // 9 to 15 -> 3\\n        // 16 to 24 -> 4\\n        // 25 to 35 -> 5\\n       // pattern - for n belonging to [ i^2 ] and [ (i+1)^2 -1 ] the ans is i\\n\\n        int i = 0;\\n        while( n >= i*i ){\\n            i++; \\n        }\\n        cout<<\"ans = \"<<i-1<<endl;"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "I found only x^2 can have odd number of factors (x is a positive integer), so the result is floor(sqrt(n))."
                    },
                    {
                        "username": "shashwat963",
                        "content": "one line c++ solution \\njust type return floor(sqrt(n));"
                    },
                    {
                        "username": "AMerrill",
                        "content": "They did this problem on Numberphile!"
                    },
                    {
                        "username": "jasngh_004",
                        "content": "Just observe few output how ?????? solution is just of 2 lines... int ans return ans; explained below:\\nso do one thing check  output for 1 to 16 in console by simply return 1; in code ik that all will be wrong pattern but you can understand the pattern and logical through that.\\nthen after observing you can see for n=0 we have o/p = 0, n=(1 to 3) o/p=1, n =(4to8) o/p = 2, n=(9to15) o/p = 3 and go ahead in short in question language when we go from ith to nth round on sqrt(n) we have toggle all bulbs thus in nth round no. of toggle button will be \\n\\n\"return sqrt(n);\" \\n\\nhope it helps happy coding :) upvote with a smile"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "wording kinda caught me at first.\\nwas thinking every second bulb turns on from ith bulb in the ith round lol"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "It can be solved with just one statement, once you figure out the pattern between the \"n\" and the answer. \\nThe solution boils down to a single line of code.\\nbulbSwitch(n){\\n   retrun k;  // easily deducible once you find the pattern\\n}"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "python is giving me 8.8ms for using this code  ```return int(sqrt(n)) ```\nwhile its 75.6 ms after using this stub \n```\nfrom math import sqrt\nreturn int(sqrt(n))\n```\nwhy is that happening can anyone explain pls"
                    }
                ]
            },
            {
                "id": 1875618,
                "content": [
                    {
                        "username": "cachoseg",
                        "content": "math is already imported in kotlin, so do your work"
                    },
                    {
                        "username": "chavansushil153",
                        "content": "i new too leetcode.\\ni not solve this question. \\ni am live in ycce."
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "i put all integers till 30 in testcase analysed the outputs and found the below pattern\\n\\n        // 0 -> 0\\n        // 1 to 3 -> 1\\n        // 4 to 8 -> 2\\n        // 9 to 15 -> 3\\n        // 16 to 24 -> 4\\n        // 25 to 35 -> 5\\n       // pattern - for n belonging to [ i^2 ] and [ (i+1)^2 -1 ] the ans is i\\n\\n        int i = 0;\\n        while( n >= i*i ){\\n            i++; \\n        }\\n        cout<<\"ans = \"<<i-1<<endl;"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "I found only x^2 can have odd number of factors (x is a positive integer), so the result is floor(sqrt(n))."
                    },
                    {
                        "username": "shashwat963",
                        "content": "one line c++ solution \\njust type return floor(sqrt(n));"
                    },
                    {
                        "username": "AMerrill",
                        "content": "They did this problem on Numberphile!"
                    },
                    {
                        "username": "jasngh_004",
                        "content": "Just observe few output how ?????? solution is just of 2 lines... int ans return ans; explained below:\\nso do one thing check  output for 1 to 16 in console by simply return 1; in code ik that all will be wrong pattern but you can understand the pattern and logical through that.\\nthen after observing you can see for n=0 we have o/p = 0, n=(1 to 3) o/p=1, n =(4to8) o/p = 2, n=(9to15) o/p = 3 and go ahead in short in question language when we go from ith to nth round on sqrt(n) we have toggle all bulbs thus in nth round no. of toggle button will be \\n\\n\"return sqrt(n);\" \\n\\nhope it helps happy coding :) upvote with a smile"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "wording kinda caught me at first.\\nwas thinking every second bulb turns on from ith bulb in the ith round lol"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "It can be solved with just one statement, once you figure out the pattern between the \"n\" and the answer. \\nThe solution boils down to a single line of code.\\nbulbSwitch(n){\\n   retrun k;  // easily deducible once you find the pattern\\n}"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "python is giving me 8.8ms for using this code  ```return int(sqrt(n)) ```\nwhile its 75.6 ms after using this stub \n```\nfrom math import sqrt\nreturn int(sqrt(n))\n```\nwhy is that happening can anyone explain pls"
                    }
                ]
            },
            {
                "id": 1875541,
                "content": [
                    {
                        "username": "cachoseg",
                        "content": "math is already imported in kotlin, so do your work"
                    },
                    {
                        "username": "chavansushil153",
                        "content": "i new too leetcode.\\ni not solve this question. \\ni am live in ycce."
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "i put all integers till 30 in testcase analysed the outputs and found the below pattern\\n\\n        // 0 -> 0\\n        // 1 to 3 -> 1\\n        // 4 to 8 -> 2\\n        // 9 to 15 -> 3\\n        // 16 to 24 -> 4\\n        // 25 to 35 -> 5\\n       // pattern - for n belonging to [ i^2 ] and [ (i+1)^2 -1 ] the ans is i\\n\\n        int i = 0;\\n        while( n >= i*i ){\\n            i++; \\n        }\\n        cout<<\"ans = \"<<i-1<<endl;"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "I found only x^2 can have odd number of factors (x is a positive integer), so the result is floor(sqrt(n))."
                    },
                    {
                        "username": "shashwat963",
                        "content": "one line c++ solution \\njust type return floor(sqrt(n));"
                    },
                    {
                        "username": "AMerrill",
                        "content": "They did this problem on Numberphile!"
                    },
                    {
                        "username": "jasngh_004",
                        "content": "Just observe few output how ?????? solution is just of 2 lines... int ans return ans; explained below:\\nso do one thing check  output for 1 to 16 in console by simply return 1; in code ik that all will be wrong pattern but you can understand the pattern and logical through that.\\nthen after observing you can see for n=0 we have o/p = 0, n=(1 to 3) o/p=1, n =(4to8) o/p = 2, n=(9to15) o/p = 3 and go ahead in short in question language when we go from ith to nth round on sqrt(n) we have toggle all bulbs thus in nth round no. of toggle button will be \\n\\n\"return sqrt(n);\" \\n\\nhope it helps happy coding :) upvote with a smile"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "wording kinda caught me at first.\\nwas thinking every second bulb turns on from ith bulb in the ith round lol"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "It can be solved with just one statement, once you figure out the pattern between the \"n\" and the answer. \\nThe solution boils down to a single line of code.\\nbulbSwitch(n){\\n   retrun k;  // easily deducible once you find the pattern\\n}"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "python is giving me 8.8ms for using this code  ```return int(sqrt(n)) ```\nwhile its 75.6 ms after using this stub \n```\nfrom math import sqrt\nreturn int(sqrt(n))\n```\nwhy is that happening can anyone explain pls"
                    }
                ]
            },
            {
                "id": 1875540,
                "content": [
                    {
                        "username": "cachoseg",
                        "content": "math is already imported in kotlin, so do your work"
                    },
                    {
                        "username": "chavansushil153",
                        "content": "i new too leetcode.\\ni not solve this question. \\ni am live in ycce."
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "i put all integers till 30 in testcase analysed the outputs and found the below pattern\\n\\n        // 0 -> 0\\n        // 1 to 3 -> 1\\n        // 4 to 8 -> 2\\n        // 9 to 15 -> 3\\n        // 16 to 24 -> 4\\n        // 25 to 35 -> 5\\n       // pattern - for n belonging to [ i^2 ] and [ (i+1)^2 -1 ] the ans is i\\n\\n        int i = 0;\\n        while( n >= i*i ){\\n            i++; \\n        }\\n        cout<<\"ans = \"<<i-1<<endl;"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "I found only x^2 can have odd number of factors (x is a positive integer), so the result is floor(sqrt(n))."
                    },
                    {
                        "username": "shashwat963",
                        "content": "one line c++ solution \\njust type return floor(sqrt(n));"
                    },
                    {
                        "username": "AMerrill",
                        "content": "They did this problem on Numberphile!"
                    },
                    {
                        "username": "jasngh_004",
                        "content": "Just observe few output how ?????? solution is just of 2 lines... int ans return ans; explained below:\\nso do one thing check  output for 1 to 16 in console by simply return 1; in code ik that all will be wrong pattern but you can understand the pattern and logical through that.\\nthen after observing you can see for n=0 we have o/p = 0, n=(1 to 3) o/p=1, n =(4to8) o/p = 2, n=(9to15) o/p = 3 and go ahead in short in question language when we go from ith to nth round on sqrt(n) we have toggle all bulbs thus in nth round no. of toggle button will be \\n\\n\"return sqrt(n);\" \\n\\nhope it helps happy coding :) upvote with a smile"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "wording kinda caught me at first.\\nwas thinking every second bulb turns on from ith bulb in the ith round lol"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "It can be solved with just one statement, once you figure out the pattern between the \"n\" and the answer. \\nThe solution boils down to a single line of code.\\nbulbSwitch(n){\\n   retrun k;  // easily deducible once you find the pattern\\n}"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "python is giving me 8.8ms for using this code  ```return int(sqrt(n)) ```\nwhile its 75.6 ms after using this stub \n```\nfrom math import sqrt\nreturn int(sqrt(n))\n```\nwhy is that happening can anyone explain pls"
                    }
                ]
            },
            {
                "id": 1875528,
                "content": [
                    {
                        "username": "cachoseg",
                        "content": "math is already imported in kotlin, so do your work"
                    },
                    {
                        "username": "chavansushil153",
                        "content": "i new too leetcode.\\ni not solve this question. \\ni am live in ycce."
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "i put all integers till 30 in testcase analysed the outputs and found the below pattern\\n\\n        // 0 -> 0\\n        // 1 to 3 -> 1\\n        // 4 to 8 -> 2\\n        // 9 to 15 -> 3\\n        // 16 to 24 -> 4\\n        // 25 to 35 -> 5\\n       // pattern - for n belonging to [ i^2 ] and [ (i+1)^2 -1 ] the ans is i\\n\\n        int i = 0;\\n        while( n >= i*i ){\\n            i++; \\n        }\\n        cout<<\"ans = \"<<i-1<<endl;"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "I found only x^2 can have odd number of factors (x is a positive integer), so the result is floor(sqrt(n))."
                    },
                    {
                        "username": "shashwat963",
                        "content": "one line c++ solution \\njust type return floor(sqrt(n));"
                    },
                    {
                        "username": "AMerrill",
                        "content": "They did this problem on Numberphile!"
                    },
                    {
                        "username": "jasngh_004",
                        "content": "Just observe few output how ?????? solution is just of 2 lines... int ans return ans; explained below:\\nso do one thing check  output for 1 to 16 in console by simply return 1; in code ik that all will be wrong pattern but you can understand the pattern and logical through that.\\nthen after observing you can see for n=0 we have o/p = 0, n=(1 to 3) o/p=1, n =(4to8) o/p = 2, n=(9to15) o/p = 3 and go ahead in short in question language when we go from ith to nth round on sqrt(n) we have toggle all bulbs thus in nth round no. of toggle button will be \\n\\n\"return sqrt(n);\" \\n\\nhope it helps happy coding :) upvote with a smile"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "wording kinda caught me at first.\\nwas thinking every second bulb turns on from ith bulb in the ith round lol"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "It can be solved with just one statement, once you figure out the pattern between the \"n\" and the answer. \\nThe solution boils down to a single line of code.\\nbulbSwitch(n){\\n   retrun k;  // easily deducible once you find the pattern\\n}"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "python is giving me 8.8ms for using this code  ```return int(sqrt(n)) ```\nwhile its 75.6 ms after using this stub \n```\nfrom math import sqrt\nreturn int(sqrt(n))\n```\nwhy is that happening can anyone explain pls"
                    }
                ]
            },
            {
                "id": 1875504,
                "content": [
                    {
                        "username": "cachoseg",
                        "content": "math is already imported in kotlin, so do your work"
                    },
                    {
                        "username": "chavansushil153",
                        "content": "i new too leetcode.\\ni not solve this question. \\ni am live in ycce."
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "i put all integers till 30 in testcase analysed the outputs and found the below pattern\\n\\n        // 0 -> 0\\n        // 1 to 3 -> 1\\n        // 4 to 8 -> 2\\n        // 9 to 15 -> 3\\n        // 16 to 24 -> 4\\n        // 25 to 35 -> 5\\n       // pattern - for n belonging to [ i^2 ] and [ (i+1)^2 -1 ] the ans is i\\n\\n        int i = 0;\\n        while( n >= i*i ){\\n            i++; \\n        }\\n        cout<<\"ans = \"<<i-1<<endl;"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "I found only x^2 can have odd number of factors (x is a positive integer), so the result is floor(sqrt(n))."
                    },
                    {
                        "username": "shashwat963",
                        "content": "one line c++ solution \\njust type return floor(sqrt(n));"
                    },
                    {
                        "username": "AMerrill",
                        "content": "They did this problem on Numberphile!"
                    },
                    {
                        "username": "jasngh_004",
                        "content": "Just observe few output how ?????? solution is just of 2 lines... int ans return ans; explained below:\\nso do one thing check  output for 1 to 16 in console by simply return 1; in code ik that all will be wrong pattern but you can understand the pattern and logical through that.\\nthen after observing you can see for n=0 we have o/p = 0, n=(1 to 3) o/p=1, n =(4to8) o/p = 2, n=(9to15) o/p = 3 and go ahead in short in question language when we go from ith to nth round on sqrt(n) we have toggle all bulbs thus in nth round no. of toggle button will be \\n\\n\"return sqrt(n);\" \\n\\nhope it helps happy coding :) upvote with a smile"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "wording kinda caught me at first.\\nwas thinking every second bulb turns on from ith bulb in the ith round lol"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "It can be solved with just one statement, once you figure out the pattern between the \"n\" and the answer. \\nThe solution boils down to a single line of code.\\nbulbSwitch(n){\\n   retrun k;  // easily deducible once you find the pattern\\n}"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "python is giving me 8.8ms for using this code  ```return int(sqrt(n)) ```\nwhile its 75.6 ms after using this stub \n```\nfrom math import sqrt\nreturn int(sqrt(n))\n```\nwhy is that happening can anyone explain pls"
                    }
                ]
            },
            {
                "id": 1875431,
                "content": [
                    {
                        "username": "kyuhyunp",
                        "content": "I was able to come up with the solution by myself and I can give a couple hints.\\nHint 1: n <= 10^9 (even O(N) will be slow for this)\\nHint 2: How many time does a bulb need to toggle to tun on?\\n\\nTry to come up with a few examples and find the pattern. Good luck!\\n"
                    },
                    {
                        "username": "jperrin36",
                        "content": "Looks like it is math week"
                    },
                    {
                        "username": "Minatokun",
                        "content": "in short question explanation :\\n\"Initially every bulb is off and for the ith round, you toggle every ith bulb.\"\\nNo need of telling 1st and 2nd etc round bcoz techniacally we are just toggling them. initially its off so toggling it  to on and in 2nd all are on so we again toggling which makes it off and so on."
                    },
                    {
                        "username": "svyas",
                        "content": "https://leetcode.com/problems/bulb-switcher/solutions/3460475/beats-100-full-explanation-with-example-dry-run-easy-solution/"
                    },
                    {
                        "username": "med_aziz_chebbi",
                        "content": "the problem statement isn\\'t clear. at the second round he will turn off every second bulb, but there is only one second bulb, the same thing for the third round he will turn off every third bulb, but there is only one third bulb, am I missing something ?\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Every second bulb = bulbs #2, #4, #6, etc.\\nEvery third bulb = bulbs #3, #6, #9, etc.\\n"
                    },
                    {
                        "username": "chinmoy_bhowmik",
                        "content": "can you please explain the output steps for 8 and 9? What would be the stages then?\\nThanks in advance\\n"
                    },
                    {
                        "username": "user5400vw",
                        "content": "it\\'s project euler week"
                    },
                    {
                        "username": "debaudh",
                        "content": "i have never seen an easier daily challenge(and still it\\'s called a \\'Medium\\'). if you know a little bit of mathematics, you can solve it in one line:)"
                    },
                    {
                        "username": "efetoua",
                        "content": "I had enough, always trying to understand the problem, sometimes I don\\'t get it at all, please clarify more or put more examples\\n"
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "if any number is having odd number of factors then only the bulb will remain on....otherwise for even factors it will be turned off...........only perfect squares have odd factors so simply count the number of perfect squares until n\nfactors of 9 (perfect square as 3x3)=1,3,9(odd number of factors)\nfactors of 16 (perfect square as 4x4)=1,2,4,8,16(odd number of factors)\nfactors of 6(not a perfect square )=1,2,3,6(even number of factors)\n"
                    }
                ]
            },
            {
                "id": 1875421,
                "content": [
                    {
                        "username": "kyuhyunp",
                        "content": "I was able to come up with the solution by myself and I can give a couple hints.\\nHint 1: n <= 10^9 (even O(N) will be slow for this)\\nHint 2: How many time does a bulb need to toggle to tun on?\\n\\nTry to come up with a few examples and find the pattern. Good luck!\\n"
                    },
                    {
                        "username": "jperrin36",
                        "content": "Looks like it is math week"
                    },
                    {
                        "username": "Minatokun",
                        "content": "in short question explanation :\\n\"Initially every bulb is off and for the ith round, you toggle every ith bulb.\"\\nNo need of telling 1st and 2nd etc round bcoz techniacally we are just toggling them. initially its off so toggling it  to on and in 2nd all are on so we again toggling which makes it off and so on."
                    },
                    {
                        "username": "svyas",
                        "content": "https://leetcode.com/problems/bulb-switcher/solutions/3460475/beats-100-full-explanation-with-example-dry-run-easy-solution/"
                    },
                    {
                        "username": "med_aziz_chebbi",
                        "content": "the problem statement isn\\'t clear. at the second round he will turn off every second bulb, but there is only one second bulb, the same thing for the third round he will turn off every third bulb, but there is only one third bulb, am I missing something ?\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Every second bulb = bulbs #2, #4, #6, etc.\\nEvery third bulb = bulbs #3, #6, #9, etc.\\n"
                    },
                    {
                        "username": "chinmoy_bhowmik",
                        "content": "can you please explain the output steps for 8 and 9? What would be the stages then?\\nThanks in advance\\n"
                    },
                    {
                        "username": "user5400vw",
                        "content": "it\\'s project euler week"
                    },
                    {
                        "username": "debaudh",
                        "content": "i have never seen an easier daily challenge(and still it\\'s called a \\'Medium\\'). if you know a little bit of mathematics, you can solve it in one line:)"
                    },
                    {
                        "username": "efetoua",
                        "content": "I had enough, always trying to understand the problem, sometimes I don\\'t get it at all, please clarify more or put more examples\\n"
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "if any number is having odd number of factors then only the bulb will remain on....otherwise for even factors it will be turned off...........only perfect squares have odd factors so simply count the number of perfect squares until n\nfactors of 9 (perfect square as 3x3)=1,3,9(odd number of factors)\nfactors of 16 (perfect square as 4x4)=1,2,4,8,16(odd number of factors)\nfactors of 6(not a perfect square )=1,2,3,6(even number of factors)\n"
                    }
                ]
            },
            {
                "id": 1875363,
                "content": [
                    {
                        "username": "kyuhyunp",
                        "content": "I was able to come up with the solution by myself and I can give a couple hints.\\nHint 1: n <= 10^9 (even O(N) will be slow for this)\\nHint 2: How many time does a bulb need to toggle to tun on?\\n\\nTry to come up with a few examples and find the pattern. Good luck!\\n"
                    },
                    {
                        "username": "jperrin36",
                        "content": "Looks like it is math week"
                    },
                    {
                        "username": "Minatokun",
                        "content": "in short question explanation :\\n\"Initially every bulb is off and for the ith round, you toggle every ith bulb.\"\\nNo need of telling 1st and 2nd etc round bcoz techniacally we are just toggling them. initially its off so toggling it  to on and in 2nd all are on so we again toggling which makes it off and so on."
                    },
                    {
                        "username": "svyas",
                        "content": "https://leetcode.com/problems/bulb-switcher/solutions/3460475/beats-100-full-explanation-with-example-dry-run-easy-solution/"
                    },
                    {
                        "username": "med_aziz_chebbi",
                        "content": "the problem statement isn\\'t clear. at the second round he will turn off every second bulb, but there is only one second bulb, the same thing for the third round he will turn off every third bulb, but there is only one third bulb, am I missing something ?\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Every second bulb = bulbs #2, #4, #6, etc.\\nEvery third bulb = bulbs #3, #6, #9, etc.\\n"
                    },
                    {
                        "username": "chinmoy_bhowmik",
                        "content": "can you please explain the output steps for 8 and 9? What would be the stages then?\\nThanks in advance\\n"
                    },
                    {
                        "username": "user5400vw",
                        "content": "it\\'s project euler week"
                    },
                    {
                        "username": "debaudh",
                        "content": "i have never seen an easier daily challenge(and still it\\'s called a \\'Medium\\'). if you know a little bit of mathematics, you can solve it in one line:)"
                    },
                    {
                        "username": "efetoua",
                        "content": "I had enough, always trying to understand the problem, sometimes I don\\'t get it at all, please clarify more or put more examples\\n"
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "if any number is having odd number of factors then only the bulb will remain on....otherwise for even factors it will be turned off...........only perfect squares have odd factors so simply count the number of perfect squares until n\nfactors of 9 (perfect square as 3x3)=1,3,9(odd number of factors)\nfactors of 16 (perfect square as 4x4)=1,2,4,8,16(odd number of factors)\nfactors of 6(not a perfect square )=1,2,3,6(even number of factors)\n"
                    }
                ]
            },
            {
                "id": 1875286,
                "content": [
                    {
                        "username": "kyuhyunp",
                        "content": "I was able to come up with the solution by myself and I can give a couple hints.\\nHint 1: n <= 10^9 (even O(N) will be slow for this)\\nHint 2: How many time does a bulb need to toggle to tun on?\\n\\nTry to come up with a few examples and find the pattern. Good luck!\\n"
                    },
                    {
                        "username": "jperrin36",
                        "content": "Looks like it is math week"
                    },
                    {
                        "username": "Minatokun",
                        "content": "in short question explanation :\\n\"Initially every bulb is off and for the ith round, you toggle every ith bulb.\"\\nNo need of telling 1st and 2nd etc round bcoz techniacally we are just toggling them. initially its off so toggling it  to on and in 2nd all are on so we again toggling which makes it off and so on."
                    },
                    {
                        "username": "svyas",
                        "content": "https://leetcode.com/problems/bulb-switcher/solutions/3460475/beats-100-full-explanation-with-example-dry-run-easy-solution/"
                    },
                    {
                        "username": "med_aziz_chebbi",
                        "content": "the problem statement isn\\'t clear. at the second round he will turn off every second bulb, but there is only one second bulb, the same thing for the third round he will turn off every third bulb, but there is only one third bulb, am I missing something ?\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Every second bulb = bulbs #2, #4, #6, etc.\\nEvery third bulb = bulbs #3, #6, #9, etc.\\n"
                    },
                    {
                        "username": "chinmoy_bhowmik",
                        "content": "can you please explain the output steps for 8 and 9? What would be the stages then?\\nThanks in advance\\n"
                    },
                    {
                        "username": "user5400vw",
                        "content": "it\\'s project euler week"
                    },
                    {
                        "username": "debaudh",
                        "content": "i have never seen an easier daily challenge(and still it\\'s called a \\'Medium\\'). if you know a little bit of mathematics, you can solve it in one line:)"
                    },
                    {
                        "username": "efetoua",
                        "content": "I had enough, always trying to understand the problem, sometimes I don\\'t get it at all, please clarify more or put more examples\\n"
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "if any number is having odd number of factors then only the bulb will remain on....otherwise for even factors it will be turned off...........only perfect squares have odd factors so simply count the number of perfect squares until n\nfactors of 9 (perfect square as 3x3)=1,3,9(odd number of factors)\nfactors of 16 (perfect square as 4x4)=1,2,4,8,16(odd number of factors)\nfactors of 6(not a perfect square )=1,2,3,6(even number of factors)\n"
                    }
                ]
            },
            {
                "id": 1875265,
                "content": [
                    {
                        "username": "kyuhyunp",
                        "content": "I was able to come up with the solution by myself and I can give a couple hints.\\nHint 1: n <= 10^9 (even O(N) will be slow for this)\\nHint 2: How many time does a bulb need to toggle to tun on?\\n\\nTry to come up with a few examples and find the pattern. Good luck!\\n"
                    },
                    {
                        "username": "jperrin36",
                        "content": "Looks like it is math week"
                    },
                    {
                        "username": "Minatokun",
                        "content": "in short question explanation :\\n\"Initially every bulb is off and for the ith round, you toggle every ith bulb.\"\\nNo need of telling 1st and 2nd etc round bcoz techniacally we are just toggling them. initially its off so toggling it  to on and in 2nd all are on so we again toggling which makes it off and so on."
                    },
                    {
                        "username": "svyas",
                        "content": "https://leetcode.com/problems/bulb-switcher/solutions/3460475/beats-100-full-explanation-with-example-dry-run-easy-solution/"
                    },
                    {
                        "username": "med_aziz_chebbi",
                        "content": "the problem statement isn\\'t clear. at the second round he will turn off every second bulb, but there is only one second bulb, the same thing for the third round he will turn off every third bulb, but there is only one third bulb, am I missing something ?\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Every second bulb = bulbs #2, #4, #6, etc.\\nEvery third bulb = bulbs #3, #6, #9, etc.\\n"
                    },
                    {
                        "username": "chinmoy_bhowmik",
                        "content": "can you please explain the output steps for 8 and 9? What would be the stages then?\\nThanks in advance\\n"
                    },
                    {
                        "username": "user5400vw",
                        "content": "it\\'s project euler week"
                    },
                    {
                        "username": "debaudh",
                        "content": "i have never seen an easier daily challenge(and still it\\'s called a \\'Medium\\'). if you know a little bit of mathematics, you can solve it in one line:)"
                    },
                    {
                        "username": "efetoua",
                        "content": "I had enough, always trying to understand the problem, sometimes I don\\'t get it at all, please clarify more or put more examples\\n"
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "if any number is having odd number of factors then only the bulb will remain on....otherwise for even factors it will be turned off...........only perfect squares have odd factors so simply count the number of perfect squares until n\nfactors of 9 (perfect square as 3x3)=1,3,9(odd number of factors)\nfactors of 16 (perfect square as 4x4)=1,2,4,8,16(odd number of factors)\nfactors of 6(not a perfect square )=1,2,3,6(even number of factors)\n"
                    }
                ]
            },
            {
                "id": 1875190,
                "content": [
                    {
                        "username": "kyuhyunp",
                        "content": "I was able to come up with the solution by myself and I can give a couple hints.\\nHint 1: n <= 10^9 (even O(N) will be slow for this)\\nHint 2: How many time does a bulb need to toggle to tun on?\\n\\nTry to come up with a few examples and find the pattern. Good luck!\\n"
                    },
                    {
                        "username": "jperrin36",
                        "content": "Looks like it is math week"
                    },
                    {
                        "username": "Minatokun",
                        "content": "in short question explanation :\\n\"Initially every bulb is off and for the ith round, you toggle every ith bulb.\"\\nNo need of telling 1st and 2nd etc round bcoz techniacally we are just toggling them. initially its off so toggling it  to on and in 2nd all are on so we again toggling which makes it off and so on."
                    },
                    {
                        "username": "svyas",
                        "content": "https://leetcode.com/problems/bulb-switcher/solutions/3460475/beats-100-full-explanation-with-example-dry-run-easy-solution/"
                    },
                    {
                        "username": "med_aziz_chebbi",
                        "content": "the problem statement isn\\'t clear. at the second round he will turn off every second bulb, but there is only one second bulb, the same thing for the third round he will turn off every third bulb, but there is only one third bulb, am I missing something ?\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Every second bulb = bulbs #2, #4, #6, etc.\\nEvery third bulb = bulbs #3, #6, #9, etc.\\n"
                    },
                    {
                        "username": "chinmoy_bhowmik",
                        "content": "can you please explain the output steps for 8 and 9? What would be the stages then?\\nThanks in advance\\n"
                    },
                    {
                        "username": "user5400vw",
                        "content": "it\\'s project euler week"
                    },
                    {
                        "username": "debaudh",
                        "content": "i have never seen an easier daily challenge(and still it\\'s called a \\'Medium\\'). if you know a little bit of mathematics, you can solve it in one line:)"
                    },
                    {
                        "username": "efetoua",
                        "content": "I had enough, always trying to understand the problem, sometimes I don\\'t get it at all, please clarify more or put more examples\\n"
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "if any number is having odd number of factors then only the bulb will remain on....otherwise for even factors it will be turned off...........only perfect squares have odd factors so simply count the number of perfect squares until n\nfactors of 9 (perfect square as 3x3)=1,3,9(odd number of factors)\nfactors of 16 (perfect square as 4x4)=1,2,4,8,16(odd number of factors)\nfactors of 6(not a perfect square )=1,2,3,6(even number of factors)\n"
                    }
                ]
            },
            {
                "id": 1875131,
                "content": [
                    {
                        "username": "kyuhyunp",
                        "content": "I was able to come up with the solution by myself and I can give a couple hints.\\nHint 1: n <= 10^9 (even O(N) will be slow for this)\\nHint 2: How many time does a bulb need to toggle to tun on?\\n\\nTry to come up with a few examples and find the pattern. Good luck!\\n"
                    },
                    {
                        "username": "jperrin36",
                        "content": "Looks like it is math week"
                    },
                    {
                        "username": "Minatokun",
                        "content": "in short question explanation :\\n\"Initially every bulb is off and for the ith round, you toggle every ith bulb.\"\\nNo need of telling 1st and 2nd etc round bcoz techniacally we are just toggling them. initially its off so toggling it  to on and in 2nd all are on so we again toggling which makes it off and so on."
                    },
                    {
                        "username": "svyas",
                        "content": "https://leetcode.com/problems/bulb-switcher/solutions/3460475/beats-100-full-explanation-with-example-dry-run-easy-solution/"
                    },
                    {
                        "username": "med_aziz_chebbi",
                        "content": "the problem statement isn\\'t clear. at the second round he will turn off every second bulb, but there is only one second bulb, the same thing for the third round he will turn off every third bulb, but there is only one third bulb, am I missing something ?\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Every second bulb = bulbs #2, #4, #6, etc.\\nEvery third bulb = bulbs #3, #6, #9, etc.\\n"
                    },
                    {
                        "username": "chinmoy_bhowmik",
                        "content": "can you please explain the output steps for 8 and 9? What would be the stages then?\\nThanks in advance\\n"
                    },
                    {
                        "username": "user5400vw",
                        "content": "it\\'s project euler week"
                    },
                    {
                        "username": "debaudh",
                        "content": "i have never seen an easier daily challenge(and still it\\'s called a \\'Medium\\'). if you know a little bit of mathematics, you can solve it in one line:)"
                    },
                    {
                        "username": "efetoua",
                        "content": "I had enough, always trying to understand the problem, sometimes I don\\'t get it at all, please clarify more or put more examples\\n"
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "if any number is having odd number of factors then only the bulb will remain on....otherwise for even factors it will be turned off...........only perfect squares have odd factors so simply count the number of perfect squares until n\nfactors of 9 (perfect square as 3x3)=1,3,9(odd number of factors)\nfactors of 16 (perfect square as 4x4)=1,2,4,8,16(odd number of factors)\nfactors of 6(not a perfect square )=1,2,3,6(even number of factors)\n"
                    }
                ]
            },
            {
                "id": 1875126,
                "content": [
                    {
                        "username": "kyuhyunp",
                        "content": "I was able to come up with the solution by myself and I can give a couple hints.\\nHint 1: n <= 10^9 (even O(N) will be slow for this)\\nHint 2: How many time does a bulb need to toggle to tun on?\\n\\nTry to come up with a few examples and find the pattern. Good luck!\\n"
                    },
                    {
                        "username": "jperrin36",
                        "content": "Looks like it is math week"
                    },
                    {
                        "username": "Minatokun",
                        "content": "in short question explanation :\\n\"Initially every bulb is off and for the ith round, you toggle every ith bulb.\"\\nNo need of telling 1st and 2nd etc round bcoz techniacally we are just toggling them. initially its off so toggling it  to on and in 2nd all are on so we again toggling which makes it off and so on."
                    },
                    {
                        "username": "svyas",
                        "content": "https://leetcode.com/problems/bulb-switcher/solutions/3460475/beats-100-full-explanation-with-example-dry-run-easy-solution/"
                    },
                    {
                        "username": "med_aziz_chebbi",
                        "content": "the problem statement isn\\'t clear. at the second round he will turn off every second bulb, but there is only one second bulb, the same thing for the third round he will turn off every third bulb, but there is only one third bulb, am I missing something ?\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Every second bulb = bulbs #2, #4, #6, etc.\\nEvery third bulb = bulbs #3, #6, #9, etc.\\n"
                    },
                    {
                        "username": "chinmoy_bhowmik",
                        "content": "can you please explain the output steps for 8 and 9? What would be the stages then?\\nThanks in advance\\n"
                    },
                    {
                        "username": "user5400vw",
                        "content": "it\\'s project euler week"
                    },
                    {
                        "username": "debaudh",
                        "content": "i have never seen an easier daily challenge(and still it\\'s called a \\'Medium\\'). if you know a little bit of mathematics, you can solve it in one line:)"
                    },
                    {
                        "username": "efetoua",
                        "content": "I had enough, always trying to understand the problem, sometimes I don\\'t get it at all, please clarify more or put more examples\\n"
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "if any number is having odd number of factors then only the bulb will remain on....otherwise for even factors it will be turned off...........only perfect squares have odd factors so simply count the number of perfect squares until n\nfactors of 9 (perfect square as 3x3)=1,3,9(odd number of factors)\nfactors of 16 (perfect square as 4x4)=1,2,4,8,16(odd number of factors)\nfactors of 6(not a perfect square )=1,2,3,6(even number of factors)\n"
                    }
                ]
            },
            {
                "id": 1875120,
                "content": [
                    {
                        "username": "kyuhyunp",
                        "content": "I was able to come up with the solution by myself and I can give a couple hints.\\nHint 1: n <= 10^9 (even O(N) will be slow for this)\\nHint 2: How many time does a bulb need to toggle to tun on?\\n\\nTry to come up with a few examples and find the pattern. Good luck!\\n"
                    },
                    {
                        "username": "jperrin36",
                        "content": "Looks like it is math week"
                    },
                    {
                        "username": "Minatokun",
                        "content": "in short question explanation :\\n\"Initially every bulb is off and for the ith round, you toggle every ith bulb.\"\\nNo need of telling 1st and 2nd etc round bcoz techniacally we are just toggling them. initially its off so toggling it  to on and in 2nd all are on so we again toggling which makes it off and so on."
                    },
                    {
                        "username": "svyas",
                        "content": "https://leetcode.com/problems/bulb-switcher/solutions/3460475/beats-100-full-explanation-with-example-dry-run-easy-solution/"
                    },
                    {
                        "username": "med_aziz_chebbi",
                        "content": "the problem statement isn\\'t clear. at the second round he will turn off every second bulb, but there is only one second bulb, the same thing for the third round he will turn off every third bulb, but there is only one third bulb, am I missing something ?\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Every second bulb = bulbs #2, #4, #6, etc.\\nEvery third bulb = bulbs #3, #6, #9, etc.\\n"
                    },
                    {
                        "username": "chinmoy_bhowmik",
                        "content": "can you please explain the output steps for 8 and 9? What would be the stages then?\\nThanks in advance\\n"
                    },
                    {
                        "username": "user5400vw",
                        "content": "it\\'s project euler week"
                    },
                    {
                        "username": "debaudh",
                        "content": "i have never seen an easier daily challenge(and still it\\'s called a \\'Medium\\'). if you know a little bit of mathematics, you can solve it in one line:)"
                    },
                    {
                        "username": "efetoua",
                        "content": "I had enough, always trying to understand the problem, sometimes I don\\'t get it at all, please clarify more or put more examples\\n"
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "if any number is having odd number of factors then only the bulb will remain on....otherwise for even factors it will be turned off...........only perfect squares have odd factors so simply count the number of perfect squares until n\nfactors of 9 (perfect square as 3x3)=1,3,9(odd number of factors)\nfactors of 16 (perfect square as 4x4)=1,2,4,8,16(odd number of factors)\nfactors of 6(not a perfect square )=1,2,3,6(even number of factors)\n"
                    }
                ]
            },
            {
                "id": 1875110,
                "content": [
                    {
                        "username": "kyuhyunp",
                        "content": "I was able to come up with the solution by myself and I can give a couple hints.\\nHint 1: n <= 10^9 (even O(N) will be slow for this)\\nHint 2: How many time does a bulb need to toggle to tun on?\\n\\nTry to come up with a few examples and find the pattern. Good luck!\\n"
                    },
                    {
                        "username": "jperrin36",
                        "content": "Looks like it is math week"
                    },
                    {
                        "username": "Minatokun",
                        "content": "in short question explanation :\\n\"Initially every bulb is off and for the ith round, you toggle every ith bulb.\"\\nNo need of telling 1st and 2nd etc round bcoz techniacally we are just toggling them. initially its off so toggling it  to on and in 2nd all are on so we again toggling which makes it off and so on."
                    },
                    {
                        "username": "svyas",
                        "content": "https://leetcode.com/problems/bulb-switcher/solutions/3460475/beats-100-full-explanation-with-example-dry-run-easy-solution/"
                    },
                    {
                        "username": "med_aziz_chebbi",
                        "content": "the problem statement isn\\'t clear. at the second round he will turn off every second bulb, but there is only one second bulb, the same thing for the third round he will turn off every third bulb, but there is only one third bulb, am I missing something ?\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Every second bulb = bulbs #2, #4, #6, etc.\\nEvery third bulb = bulbs #3, #6, #9, etc.\\n"
                    },
                    {
                        "username": "chinmoy_bhowmik",
                        "content": "can you please explain the output steps for 8 and 9? What would be the stages then?\\nThanks in advance\\n"
                    },
                    {
                        "username": "user5400vw",
                        "content": "it\\'s project euler week"
                    },
                    {
                        "username": "debaudh",
                        "content": "i have never seen an easier daily challenge(and still it\\'s called a \\'Medium\\'). if you know a little bit of mathematics, you can solve it in one line:)"
                    },
                    {
                        "username": "efetoua",
                        "content": "I had enough, always trying to understand the problem, sometimes I don\\'t get it at all, please clarify more or put more examples\\n"
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "if any number is having odd number of factors then only the bulb will remain on....otherwise for even factors it will be turned off...........only perfect squares have odd factors so simply count the number of perfect squares until n\nfactors of 9 (perfect square as 3x3)=1,3,9(odd number of factors)\nfactors of 16 (perfect square as 4x4)=1,2,4,8,16(odd number of factors)\nfactors of 6(not a perfect square )=1,2,3,6(even number of factors)\n"
                    }
                ]
            },
            {
                "id": 1875101,
                "content": [
                    {
                        "username": "gaurav89830",
                        "content": "        return (int)Math.sqrt(n);\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem makes me think I\\'m stupid."
                    },
                    {
                        "username": "priyanshu8751",
                        "content": "# Tips for this problem\\n1. Solve for n = 1 to n = 10 and observe the pattern.\\n2. Yes, what you feel is correct and go by that logic to n = 15.\\n3. Try to give one liner."
                    },
                    {
                        "username": "AbirDey",
                        "content": "Can someone please explain why for n = 2, the answer should be 1, because -\\n1. firstly round one will toggle it on right?\\n2. then In the second round, it will be toggled off but again as it is the last round for n = 2, it will be toggled on right?\\n\\nSo the answer should be 2, but it says one.\\nHelp T_T"
                    },
                    {
                        "username": "Nicholasgkc",
                        "content": "When n=2, only toggled one time not two time"
                    },
                    {
                        "username": "wookhyun",
                        "content": "In the first round, it\\'s right to turn on all the lights that have been turned off. But rather than thinking that way, I think it\\'s easier to understand the problem by thinking that in the i-th round, the light bulb corresponding to the i-multiplier is toggle."
                    },
                    {
                        "username": "piyushverma17",
                        "content": "At first, the three bulbs are [off, off, off].\nAfter the first round, the three bulbs are [on, on, on].\nAfter the second round, the three bulbs are [on, off, on].\nAfter the third round, the three bulbs are [on, off, off]. \nSo you should return 1 because there is only one bulb is on.\n \ncode-> return (int)sqrt(n);"
                    },
                    {
                        "username": "R_aghav",
                        "content": "At first i thought how to solve it against the given constraints , then observing the some test cases i see the result is somehow similar to sqrt(n) and its correct. It successfully accept the solution .How many thought the same one ."
                    },
                    {
                        "username": "shreshthpal",
                        "content": "Its a simple two step observation:\\n1. All divisor comes in pairs\\n12= 1*12 , 2*6 , 3*4  (1,2,3,4,6,12)\\n2. Only Perfect Squares have odd number of divisors\\n16 = 1*16, 2*8 ,4*4 (1,2,4,8,16)"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Just brainstormed a bit, noticed the pattern and guessed and it worked but I have no idea why it did."
                    },
                    {
                        "username": "officialkushagragupta",
                        "content": "1,1,1,1 round1\\n1,0,1,0 round2\\n1,0,0,0 round3\\n1,0,0,1 round4\\n\\n\\n1,1,1,1,1 round1\\n1,0,1,0,1 round2\\n1,0,0,0,1 round3\\n1,0,0,1,1 round4\\n1,0,0,1,0 round5\\n\\n\\n1,1,1,1,1,1 round1\\n1,0,1,0,1,0 round2\\n1,0,0,0,1,1 round3\\n1,0,0,1,1,1 round4\\n1,0,0,1,0,1 round5\\n1,0,0,1,0,0 round6\\n\\n\\n1,1,1,1,1,1,1 round1\\n1,0,1,0,1,0,1 round2\\n1,0,0,0,1,1,0  round3\\n1,0,0,1,1,1,0  round4\\n1,0,0,1,0,1,0  round5\\n1,0,0,1,0,0,0  round6\\n1,0,0,1,0,0,1  round7\\n\\nbut according to this ,for int n=7 , ans should be 3 and this pattern will follow hence we can also apply\\nans=((n-1 - 0)/3)+1.\\n\\nwhere am I going wrong?"
                    },
                    {
                        "username": "Noah492",
                        "content": "Looks like you didn\\'t carry the ending 1 from round 2 to 3. \\nSee below, answer should be 2:\\n\\n1,1,1,1,1,1,1 round1\\n1,0,1,0,1,0,1 round2\\n1,0,0,0,1,1,1 round3\\n1,0,0,1,1,1,1 round4\\n1,0,0,1,0,1,1 round5\\n1,0,0,1,0,0,1 round6\\n1,0,0,1,0,0,0 round7"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "the like dislike ratio says it all"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the like dislike ratio says that leetcoders really don\\'t appreciate having to think"
                    }
                ]
            },
            {
                "id": 1875096,
                "content": [
                    {
                        "username": "gaurav89830",
                        "content": "        return (int)Math.sqrt(n);\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem makes me think I\\'m stupid."
                    },
                    {
                        "username": "priyanshu8751",
                        "content": "# Tips for this problem\\n1. Solve for n = 1 to n = 10 and observe the pattern.\\n2. Yes, what you feel is correct and go by that logic to n = 15.\\n3. Try to give one liner."
                    },
                    {
                        "username": "AbirDey",
                        "content": "Can someone please explain why for n = 2, the answer should be 1, because -\\n1. firstly round one will toggle it on right?\\n2. then In the second round, it will be toggled off but again as it is the last round for n = 2, it will be toggled on right?\\n\\nSo the answer should be 2, but it says one.\\nHelp T_T"
                    },
                    {
                        "username": "Nicholasgkc",
                        "content": "When n=2, only toggled one time not two time"
                    },
                    {
                        "username": "wookhyun",
                        "content": "In the first round, it\\'s right to turn on all the lights that have been turned off. But rather than thinking that way, I think it\\'s easier to understand the problem by thinking that in the i-th round, the light bulb corresponding to the i-multiplier is toggle."
                    },
                    {
                        "username": "piyushverma17",
                        "content": "At first, the three bulbs are [off, off, off].\nAfter the first round, the three bulbs are [on, on, on].\nAfter the second round, the three bulbs are [on, off, on].\nAfter the third round, the three bulbs are [on, off, off]. \nSo you should return 1 because there is only one bulb is on.\n \ncode-> return (int)sqrt(n);"
                    },
                    {
                        "username": "R_aghav",
                        "content": "At first i thought how to solve it against the given constraints , then observing the some test cases i see the result is somehow similar to sqrt(n) and its correct. It successfully accept the solution .How many thought the same one ."
                    },
                    {
                        "username": "shreshthpal",
                        "content": "Its a simple two step observation:\\n1. All divisor comes in pairs\\n12= 1*12 , 2*6 , 3*4  (1,2,3,4,6,12)\\n2. Only Perfect Squares have odd number of divisors\\n16 = 1*16, 2*8 ,4*4 (1,2,4,8,16)"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Just brainstormed a bit, noticed the pattern and guessed and it worked but I have no idea why it did."
                    },
                    {
                        "username": "officialkushagragupta",
                        "content": "1,1,1,1 round1\\n1,0,1,0 round2\\n1,0,0,0 round3\\n1,0,0,1 round4\\n\\n\\n1,1,1,1,1 round1\\n1,0,1,0,1 round2\\n1,0,0,0,1 round3\\n1,0,0,1,1 round4\\n1,0,0,1,0 round5\\n\\n\\n1,1,1,1,1,1 round1\\n1,0,1,0,1,0 round2\\n1,0,0,0,1,1 round3\\n1,0,0,1,1,1 round4\\n1,0,0,1,0,1 round5\\n1,0,0,1,0,0 round6\\n\\n\\n1,1,1,1,1,1,1 round1\\n1,0,1,0,1,0,1 round2\\n1,0,0,0,1,1,0  round3\\n1,0,0,1,1,1,0  round4\\n1,0,0,1,0,1,0  round5\\n1,0,0,1,0,0,0  round6\\n1,0,0,1,0,0,1  round7\\n\\nbut according to this ,for int n=7 , ans should be 3 and this pattern will follow hence we can also apply\\nans=((n-1 - 0)/3)+1.\\n\\nwhere am I going wrong?"
                    },
                    {
                        "username": "Noah492",
                        "content": "Looks like you didn\\'t carry the ending 1 from round 2 to 3. \\nSee below, answer should be 2:\\n\\n1,1,1,1,1,1,1 round1\\n1,0,1,0,1,0,1 round2\\n1,0,0,0,1,1,1 round3\\n1,0,0,1,1,1,1 round4\\n1,0,0,1,0,1,1 round5\\n1,0,0,1,0,0,1 round6\\n1,0,0,1,0,0,0 round7"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "the like dislike ratio says it all"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the like dislike ratio says that leetcoders really don\\'t appreciate having to think"
                    }
                ]
            },
            {
                "id": 1875057,
                "content": [
                    {
                        "username": "gaurav89830",
                        "content": "        return (int)Math.sqrt(n);\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem makes me think I\\'m stupid."
                    },
                    {
                        "username": "priyanshu8751",
                        "content": "# Tips for this problem\\n1. Solve for n = 1 to n = 10 and observe the pattern.\\n2. Yes, what you feel is correct and go by that logic to n = 15.\\n3. Try to give one liner."
                    },
                    {
                        "username": "AbirDey",
                        "content": "Can someone please explain why for n = 2, the answer should be 1, because -\\n1. firstly round one will toggle it on right?\\n2. then In the second round, it will be toggled off but again as it is the last round for n = 2, it will be toggled on right?\\n\\nSo the answer should be 2, but it says one.\\nHelp T_T"
                    },
                    {
                        "username": "Nicholasgkc",
                        "content": "When n=2, only toggled one time not two time"
                    },
                    {
                        "username": "wookhyun",
                        "content": "In the first round, it\\'s right to turn on all the lights that have been turned off. But rather than thinking that way, I think it\\'s easier to understand the problem by thinking that in the i-th round, the light bulb corresponding to the i-multiplier is toggle."
                    },
                    {
                        "username": "piyushverma17",
                        "content": "At first, the three bulbs are [off, off, off].\nAfter the first round, the three bulbs are [on, on, on].\nAfter the second round, the three bulbs are [on, off, on].\nAfter the third round, the three bulbs are [on, off, off]. \nSo you should return 1 because there is only one bulb is on.\n \ncode-> return (int)sqrt(n);"
                    },
                    {
                        "username": "R_aghav",
                        "content": "At first i thought how to solve it against the given constraints , then observing the some test cases i see the result is somehow similar to sqrt(n) and its correct. It successfully accept the solution .How many thought the same one ."
                    },
                    {
                        "username": "shreshthpal",
                        "content": "Its a simple two step observation:\\n1. All divisor comes in pairs\\n12= 1*12 , 2*6 , 3*4  (1,2,3,4,6,12)\\n2. Only Perfect Squares have odd number of divisors\\n16 = 1*16, 2*8 ,4*4 (1,2,4,8,16)"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Just brainstormed a bit, noticed the pattern and guessed and it worked but I have no idea why it did."
                    },
                    {
                        "username": "officialkushagragupta",
                        "content": "1,1,1,1 round1\\n1,0,1,0 round2\\n1,0,0,0 round3\\n1,0,0,1 round4\\n\\n\\n1,1,1,1,1 round1\\n1,0,1,0,1 round2\\n1,0,0,0,1 round3\\n1,0,0,1,1 round4\\n1,0,0,1,0 round5\\n\\n\\n1,1,1,1,1,1 round1\\n1,0,1,0,1,0 round2\\n1,0,0,0,1,1 round3\\n1,0,0,1,1,1 round4\\n1,0,0,1,0,1 round5\\n1,0,0,1,0,0 round6\\n\\n\\n1,1,1,1,1,1,1 round1\\n1,0,1,0,1,0,1 round2\\n1,0,0,0,1,1,0  round3\\n1,0,0,1,1,1,0  round4\\n1,0,0,1,0,1,0  round5\\n1,0,0,1,0,0,0  round6\\n1,0,0,1,0,0,1  round7\\n\\nbut according to this ,for int n=7 , ans should be 3 and this pattern will follow hence we can also apply\\nans=((n-1 - 0)/3)+1.\\n\\nwhere am I going wrong?"
                    },
                    {
                        "username": "Noah492",
                        "content": "Looks like you didn\\'t carry the ending 1 from round 2 to 3. \\nSee below, answer should be 2:\\n\\n1,1,1,1,1,1,1 round1\\n1,0,1,0,1,0,1 round2\\n1,0,0,0,1,1,1 round3\\n1,0,0,1,1,1,1 round4\\n1,0,0,1,0,1,1 round5\\n1,0,0,1,0,0,1 round6\\n1,0,0,1,0,0,0 round7"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "the like dislike ratio says it all"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the like dislike ratio says that leetcoders really don\\'t appreciate having to think"
                    }
                ]
            },
            {
                "id": 1875034,
                "content": [
                    {
                        "username": "gaurav89830",
                        "content": "        return (int)Math.sqrt(n);\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem makes me think I\\'m stupid."
                    },
                    {
                        "username": "priyanshu8751",
                        "content": "# Tips for this problem\\n1. Solve for n = 1 to n = 10 and observe the pattern.\\n2. Yes, what you feel is correct and go by that logic to n = 15.\\n3. Try to give one liner."
                    },
                    {
                        "username": "AbirDey",
                        "content": "Can someone please explain why for n = 2, the answer should be 1, because -\\n1. firstly round one will toggle it on right?\\n2. then In the second round, it will be toggled off but again as it is the last round for n = 2, it will be toggled on right?\\n\\nSo the answer should be 2, but it says one.\\nHelp T_T"
                    },
                    {
                        "username": "Nicholasgkc",
                        "content": "When n=2, only toggled one time not two time"
                    },
                    {
                        "username": "wookhyun",
                        "content": "In the first round, it\\'s right to turn on all the lights that have been turned off. But rather than thinking that way, I think it\\'s easier to understand the problem by thinking that in the i-th round, the light bulb corresponding to the i-multiplier is toggle."
                    },
                    {
                        "username": "piyushverma17",
                        "content": "At first, the three bulbs are [off, off, off].\nAfter the first round, the three bulbs are [on, on, on].\nAfter the second round, the three bulbs are [on, off, on].\nAfter the third round, the three bulbs are [on, off, off]. \nSo you should return 1 because there is only one bulb is on.\n \ncode-> return (int)sqrt(n);"
                    },
                    {
                        "username": "R_aghav",
                        "content": "At first i thought how to solve it against the given constraints , then observing the some test cases i see the result is somehow similar to sqrt(n) and its correct. It successfully accept the solution .How many thought the same one ."
                    },
                    {
                        "username": "shreshthpal",
                        "content": "Its a simple two step observation:\\n1. All divisor comes in pairs\\n12= 1*12 , 2*6 , 3*4  (1,2,3,4,6,12)\\n2. Only Perfect Squares have odd number of divisors\\n16 = 1*16, 2*8 ,4*4 (1,2,4,8,16)"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Just brainstormed a bit, noticed the pattern and guessed and it worked but I have no idea why it did."
                    },
                    {
                        "username": "officialkushagragupta",
                        "content": "1,1,1,1 round1\\n1,0,1,0 round2\\n1,0,0,0 round3\\n1,0,0,1 round4\\n\\n\\n1,1,1,1,1 round1\\n1,0,1,0,1 round2\\n1,0,0,0,1 round3\\n1,0,0,1,1 round4\\n1,0,0,1,0 round5\\n\\n\\n1,1,1,1,1,1 round1\\n1,0,1,0,1,0 round2\\n1,0,0,0,1,1 round3\\n1,0,0,1,1,1 round4\\n1,0,0,1,0,1 round5\\n1,0,0,1,0,0 round6\\n\\n\\n1,1,1,1,1,1,1 round1\\n1,0,1,0,1,0,1 round2\\n1,0,0,0,1,1,0  round3\\n1,0,0,1,1,1,0  round4\\n1,0,0,1,0,1,0  round5\\n1,0,0,1,0,0,0  round6\\n1,0,0,1,0,0,1  round7\\n\\nbut according to this ,for int n=7 , ans should be 3 and this pattern will follow hence we can also apply\\nans=((n-1 - 0)/3)+1.\\n\\nwhere am I going wrong?"
                    },
                    {
                        "username": "Noah492",
                        "content": "Looks like you didn\\'t carry the ending 1 from round 2 to 3. \\nSee below, answer should be 2:\\n\\n1,1,1,1,1,1,1 round1\\n1,0,1,0,1,0,1 round2\\n1,0,0,0,1,1,1 round3\\n1,0,0,1,1,1,1 round4\\n1,0,0,1,0,1,1 round5\\n1,0,0,1,0,0,1 round6\\n1,0,0,1,0,0,0 round7"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "the like dislike ratio says it all"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the like dislike ratio says that leetcoders really don\\'t appreciate having to think"
                    }
                ]
            },
            {
                "id": 1875010,
                "content": [
                    {
                        "username": "gaurav89830",
                        "content": "        return (int)Math.sqrt(n);\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem makes me think I\\'m stupid."
                    },
                    {
                        "username": "priyanshu8751",
                        "content": "# Tips for this problem\\n1. Solve for n = 1 to n = 10 and observe the pattern.\\n2. Yes, what you feel is correct and go by that logic to n = 15.\\n3. Try to give one liner."
                    },
                    {
                        "username": "AbirDey",
                        "content": "Can someone please explain why for n = 2, the answer should be 1, because -\\n1. firstly round one will toggle it on right?\\n2. then In the second round, it will be toggled off but again as it is the last round for n = 2, it will be toggled on right?\\n\\nSo the answer should be 2, but it says one.\\nHelp T_T"
                    },
                    {
                        "username": "Nicholasgkc",
                        "content": "When n=2, only toggled one time not two time"
                    },
                    {
                        "username": "wookhyun",
                        "content": "In the first round, it\\'s right to turn on all the lights that have been turned off. But rather than thinking that way, I think it\\'s easier to understand the problem by thinking that in the i-th round, the light bulb corresponding to the i-multiplier is toggle."
                    },
                    {
                        "username": "piyushverma17",
                        "content": "At first, the three bulbs are [off, off, off].\nAfter the first round, the three bulbs are [on, on, on].\nAfter the second round, the three bulbs are [on, off, on].\nAfter the third round, the three bulbs are [on, off, off]. \nSo you should return 1 because there is only one bulb is on.\n \ncode-> return (int)sqrt(n);"
                    },
                    {
                        "username": "R_aghav",
                        "content": "At first i thought how to solve it against the given constraints , then observing the some test cases i see the result is somehow similar to sqrt(n) and its correct. It successfully accept the solution .How many thought the same one ."
                    },
                    {
                        "username": "shreshthpal",
                        "content": "Its a simple two step observation:\\n1. All divisor comes in pairs\\n12= 1*12 , 2*6 , 3*4  (1,2,3,4,6,12)\\n2. Only Perfect Squares have odd number of divisors\\n16 = 1*16, 2*8 ,4*4 (1,2,4,8,16)"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Just brainstormed a bit, noticed the pattern and guessed and it worked but I have no idea why it did."
                    },
                    {
                        "username": "officialkushagragupta",
                        "content": "1,1,1,1 round1\\n1,0,1,0 round2\\n1,0,0,0 round3\\n1,0,0,1 round4\\n\\n\\n1,1,1,1,1 round1\\n1,0,1,0,1 round2\\n1,0,0,0,1 round3\\n1,0,0,1,1 round4\\n1,0,0,1,0 round5\\n\\n\\n1,1,1,1,1,1 round1\\n1,0,1,0,1,0 round2\\n1,0,0,0,1,1 round3\\n1,0,0,1,1,1 round4\\n1,0,0,1,0,1 round5\\n1,0,0,1,0,0 round6\\n\\n\\n1,1,1,1,1,1,1 round1\\n1,0,1,0,1,0,1 round2\\n1,0,0,0,1,1,0  round3\\n1,0,0,1,1,1,0  round4\\n1,0,0,1,0,1,0  round5\\n1,0,0,1,0,0,0  round6\\n1,0,0,1,0,0,1  round7\\n\\nbut according to this ,for int n=7 , ans should be 3 and this pattern will follow hence we can also apply\\nans=((n-1 - 0)/3)+1.\\n\\nwhere am I going wrong?"
                    },
                    {
                        "username": "Noah492",
                        "content": "Looks like you didn\\'t carry the ending 1 from round 2 to 3. \\nSee below, answer should be 2:\\n\\n1,1,1,1,1,1,1 round1\\n1,0,1,0,1,0,1 round2\\n1,0,0,0,1,1,1 round3\\n1,0,0,1,1,1,1 round4\\n1,0,0,1,0,1,1 round5\\n1,0,0,1,0,0,1 round6\\n1,0,0,1,0,0,0 round7"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "the like dislike ratio says it all"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the like dislike ratio says that leetcoders really don\\'t appreciate having to think"
                    }
                ]
            },
            {
                "id": 1875003,
                "content": [
                    {
                        "username": "gaurav89830",
                        "content": "        return (int)Math.sqrt(n);\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem makes me think I\\'m stupid."
                    },
                    {
                        "username": "priyanshu8751",
                        "content": "# Tips for this problem\\n1. Solve for n = 1 to n = 10 and observe the pattern.\\n2. Yes, what you feel is correct and go by that logic to n = 15.\\n3. Try to give one liner."
                    },
                    {
                        "username": "AbirDey",
                        "content": "Can someone please explain why for n = 2, the answer should be 1, because -\\n1. firstly round one will toggle it on right?\\n2. then In the second round, it will be toggled off but again as it is the last round for n = 2, it will be toggled on right?\\n\\nSo the answer should be 2, but it says one.\\nHelp T_T"
                    },
                    {
                        "username": "Nicholasgkc",
                        "content": "When n=2, only toggled one time not two time"
                    },
                    {
                        "username": "wookhyun",
                        "content": "In the first round, it\\'s right to turn on all the lights that have been turned off. But rather than thinking that way, I think it\\'s easier to understand the problem by thinking that in the i-th round, the light bulb corresponding to the i-multiplier is toggle."
                    },
                    {
                        "username": "piyushverma17",
                        "content": "At first, the three bulbs are [off, off, off].\nAfter the first round, the three bulbs are [on, on, on].\nAfter the second round, the three bulbs are [on, off, on].\nAfter the third round, the three bulbs are [on, off, off]. \nSo you should return 1 because there is only one bulb is on.\n \ncode-> return (int)sqrt(n);"
                    },
                    {
                        "username": "R_aghav",
                        "content": "At first i thought how to solve it against the given constraints , then observing the some test cases i see the result is somehow similar to sqrt(n) and its correct. It successfully accept the solution .How many thought the same one ."
                    },
                    {
                        "username": "shreshthpal",
                        "content": "Its a simple two step observation:\\n1. All divisor comes in pairs\\n12= 1*12 , 2*6 , 3*4  (1,2,3,4,6,12)\\n2. Only Perfect Squares have odd number of divisors\\n16 = 1*16, 2*8 ,4*4 (1,2,4,8,16)"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Just brainstormed a bit, noticed the pattern and guessed and it worked but I have no idea why it did."
                    },
                    {
                        "username": "officialkushagragupta",
                        "content": "1,1,1,1 round1\\n1,0,1,0 round2\\n1,0,0,0 round3\\n1,0,0,1 round4\\n\\n\\n1,1,1,1,1 round1\\n1,0,1,0,1 round2\\n1,0,0,0,1 round3\\n1,0,0,1,1 round4\\n1,0,0,1,0 round5\\n\\n\\n1,1,1,1,1,1 round1\\n1,0,1,0,1,0 round2\\n1,0,0,0,1,1 round3\\n1,0,0,1,1,1 round4\\n1,0,0,1,0,1 round5\\n1,0,0,1,0,0 round6\\n\\n\\n1,1,1,1,1,1,1 round1\\n1,0,1,0,1,0,1 round2\\n1,0,0,0,1,1,0  round3\\n1,0,0,1,1,1,0  round4\\n1,0,0,1,0,1,0  round5\\n1,0,0,1,0,0,0  round6\\n1,0,0,1,0,0,1  round7\\n\\nbut according to this ,for int n=7 , ans should be 3 and this pattern will follow hence we can also apply\\nans=((n-1 - 0)/3)+1.\\n\\nwhere am I going wrong?"
                    },
                    {
                        "username": "Noah492",
                        "content": "Looks like you didn\\'t carry the ending 1 from round 2 to 3. \\nSee below, answer should be 2:\\n\\n1,1,1,1,1,1,1 round1\\n1,0,1,0,1,0,1 round2\\n1,0,0,0,1,1,1 round3\\n1,0,0,1,1,1,1 round4\\n1,0,0,1,0,1,1 round5\\n1,0,0,1,0,0,1 round6\\n1,0,0,1,0,0,0 round7"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "the like dislike ratio says it all"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the like dislike ratio says that leetcoders really don\\'t appreciate having to think"
                    }
                ]
            },
            {
                "id": 1875002,
                "content": [
                    {
                        "username": "gaurav89830",
                        "content": "        return (int)Math.sqrt(n);\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem makes me think I\\'m stupid."
                    },
                    {
                        "username": "priyanshu8751",
                        "content": "# Tips for this problem\\n1. Solve for n = 1 to n = 10 and observe the pattern.\\n2. Yes, what you feel is correct and go by that logic to n = 15.\\n3. Try to give one liner."
                    },
                    {
                        "username": "AbirDey",
                        "content": "Can someone please explain why for n = 2, the answer should be 1, because -\\n1. firstly round one will toggle it on right?\\n2. then In the second round, it will be toggled off but again as it is the last round for n = 2, it will be toggled on right?\\n\\nSo the answer should be 2, but it says one.\\nHelp T_T"
                    },
                    {
                        "username": "Nicholasgkc",
                        "content": "When n=2, only toggled one time not two time"
                    },
                    {
                        "username": "wookhyun",
                        "content": "In the first round, it\\'s right to turn on all the lights that have been turned off. But rather than thinking that way, I think it\\'s easier to understand the problem by thinking that in the i-th round, the light bulb corresponding to the i-multiplier is toggle."
                    },
                    {
                        "username": "piyushverma17",
                        "content": "At first, the three bulbs are [off, off, off].\nAfter the first round, the three bulbs are [on, on, on].\nAfter the second round, the three bulbs are [on, off, on].\nAfter the third round, the three bulbs are [on, off, off]. \nSo you should return 1 because there is only one bulb is on.\n \ncode-> return (int)sqrt(n);"
                    },
                    {
                        "username": "R_aghav",
                        "content": "At first i thought how to solve it against the given constraints , then observing the some test cases i see the result is somehow similar to sqrt(n) and its correct. It successfully accept the solution .How many thought the same one ."
                    },
                    {
                        "username": "shreshthpal",
                        "content": "Its a simple two step observation:\\n1. All divisor comes in pairs\\n12= 1*12 , 2*6 , 3*4  (1,2,3,4,6,12)\\n2. Only Perfect Squares have odd number of divisors\\n16 = 1*16, 2*8 ,4*4 (1,2,4,8,16)"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Just brainstormed a bit, noticed the pattern and guessed and it worked but I have no idea why it did."
                    },
                    {
                        "username": "officialkushagragupta",
                        "content": "1,1,1,1 round1\\n1,0,1,0 round2\\n1,0,0,0 round3\\n1,0,0,1 round4\\n\\n\\n1,1,1,1,1 round1\\n1,0,1,0,1 round2\\n1,0,0,0,1 round3\\n1,0,0,1,1 round4\\n1,0,0,1,0 round5\\n\\n\\n1,1,1,1,1,1 round1\\n1,0,1,0,1,0 round2\\n1,0,0,0,1,1 round3\\n1,0,0,1,1,1 round4\\n1,0,0,1,0,1 round5\\n1,0,0,1,0,0 round6\\n\\n\\n1,1,1,1,1,1,1 round1\\n1,0,1,0,1,0,1 round2\\n1,0,0,0,1,1,0  round3\\n1,0,0,1,1,1,0  round4\\n1,0,0,1,0,1,0  round5\\n1,0,0,1,0,0,0  round6\\n1,0,0,1,0,0,1  round7\\n\\nbut according to this ,for int n=7 , ans should be 3 and this pattern will follow hence we can also apply\\nans=((n-1 - 0)/3)+1.\\n\\nwhere am I going wrong?"
                    },
                    {
                        "username": "Noah492",
                        "content": "Looks like you didn\\'t carry the ending 1 from round 2 to 3. \\nSee below, answer should be 2:\\n\\n1,1,1,1,1,1,1 round1\\n1,0,1,0,1,0,1 round2\\n1,0,0,0,1,1,1 round3\\n1,0,0,1,1,1,1 round4\\n1,0,0,1,0,1,1 round5\\n1,0,0,1,0,0,1 round6\\n1,0,0,1,0,0,0 round7"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "the like dislike ratio says it all"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the like dislike ratio says that leetcoders really don\\'t appreciate having to think"
                    }
                ]
            },
            {
                "id": 1874996,
                "content": [
                    {
                        "username": "gaurav89830",
                        "content": "        return (int)Math.sqrt(n);\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem makes me think I\\'m stupid."
                    },
                    {
                        "username": "priyanshu8751",
                        "content": "# Tips for this problem\\n1. Solve for n = 1 to n = 10 and observe the pattern.\\n2. Yes, what you feel is correct and go by that logic to n = 15.\\n3. Try to give one liner."
                    },
                    {
                        "username": "AbirDey",
                        "content": "Can someone please explain why for n = 2, the answer should be 1, because -\\n1. firstly round one will toggle it on right?\\n2. then In the second round, it will be toggled off but again as it is the last round for n = 2, it will be toggled on right?\\n\\nSo the answer should be 2, but it says one.\\nHelp T_T"
                    },
                    {
                        "username": "Nicholasgkc",
                        "content": "When n=2, only toggled one time not two time"
                    },
                    {
                        "username": "wookhyun",
                        "content": "In the first round, it\\'s right to turn on all the lights that have been turned off. But rather than thinking that way, I think it\\'s easier to understand the problem by thinking that in the i-th round, the light bulb corresponding to the i-multiplier is toggle."
                    },
                    {
                        "username": "piyushverma17",
                        "content": "At first, the three bulbs are [off, off, off].\nAfter the first round, the three bulbs are [on, on, on].\nAfter the second round, the three bulbs are [on, off, on].\nAfter the third round, the three bulbs are [on, off, off]. \nSo you should return 1 because there is only one bulb is on.\n \ncode-> return (int)sqrt(n);"
                    },
                    {
                        "username": "R_aghav",
                        "content": "At first i thought how to solve it against the given constraints , then observing the some test cases i see the result is somehow similar to sqrt(n) and its correct. It successfully accept the solution .How many thought the same one ."
                    },
                    {
                        "username": "shreshthpal",
                        "content": "Its a simple two step observation:\\n1. All divisor comes in pairs\\n12= 1*12 , 2*6 , 3*4  (1,2,3,4,6,12)\\n2. Only Perfect Squares have odd number of divisors\\n16 = 1*16, 2*8 ,4*4 (1,2,4,8,16)"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Just brainstormed a bit, noticed the pattern and guessed and it worked but I have no idea why it did."
                    },
                    {
                        "username": "officialkushagragupta",
                        "content": "1,1,1,1 round1\\n1,0,1,0 round2\\n1,0,0,0 round3\\n1,0,0,1 round4\\n\\n\\n1,1,1,1,1 round1\\n1,0,1,0,1 round2\\n1,0,0,0,1 round3\\n1,0,0,1,1 round4\\n1,0,0,1,0 round5\\n\\n\\n1,1,1,1,1,1 round1\\n1,0,1,0,1,0 round2\\n1,0,0,0,1,1 round3\\n1,0,0,1,1,1 round4\\n1,0,0,1,0,1 round5\\n1,0,0,1,0,0 round6\\n\\n\\n1,1,1,1,1,1,1 round1\\n1,0,1,0,1,0,1 round2\\n1,0,0,0,1,1,0  round3\\n1,0,0,1,1,1,0  round4\\n1,0,0,1,0,1,0  round5\\n1,0,0,1,0,0,0  round6\\n1,0,0,1,0,0,1  round7\\n\\nbut according to this ,for int n=7 , ans should be 3 and this pattern will follow hence we can also apply\\nans=((n-1 - 0)/3)+1.\\n\\nwhere am I going wrong?"
                    },
                    {
                        "username": "Noah492",
                        "content": "Looks like you didn\\'t carry the ending 1 from round 2 to 3. \\nSee below, answer should be 2:\\n\\n1,1,1,1,1,1,1 round1\\n1,0,1,0,1,0,1 round2\\n1,0,0,0,1,1,1 round3\\n1,0,0,1,1,1,1 round4\\n1,0,0,1,0,1,1 round5\\n1,0,0,1,0,0,1 round6\\n1,0,0,1,0,0,0 round7"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "the like dislike ratio says it all"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the like dislike ratio says that leetcoders really don\\'t appreciate having to think"
                    }
                ]
            },
            {
                "id": 1874973,
                "content": [
                    {
                        "username": "gaurav89830",
                        "content": "        return (int)Math.sqrt(n);\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem makes me think I\\'m stupid."
                    },
                    {
                        "username": "priyanshu8751",
                        "content": "# Tips for this problem\\n1. Solve for n = 1 to n = 10 and observe the pattern.\\n2. Yes, what you feel is correct and go by that logic to n = 15.\\n3. Try to give one liner."
                    },
                    {
                        "username": "AbirDey",
                        "content": "Can someone please explain why for n = 2, the answer should be 1, because -\\n1. firstly round one will toggle it on right?\\n2. then In the second round, it will be toggled off but again as it is the last round for n = 2, it will be toggled on right?\\n\\nSo the answer should be 2, but it says one.\\nHelp T_T"
                    },
                    {
                        "username": "Nicholasgkc",
                        "content": "When n=2, only toggled one time not two time"
                    },
                    {
                        "username": "wookhyun",
                        "content": "In the first round, it\\'s right to turn on all the lights that have been turned off. But rather than thinking that way, I think it\\'s easier to understand the problem by thinking that in the i-th round, the light bulb corresponding to the i-multiplier is toggle."
                    },
                    {
                        "username": "piyushverma17",
                        "content": "At first, the three bulbs are [off, off, off].\nAfter the first round, the three bulbs are [on, on, on].\nAfter the second round, the three bulbs are [on, off, on].\nAfter the third round, the three bulbs are [on, off, off]. \nSo you should return 1 because there is only one bulb is on.\n \ncode-> return (int)sqrt(n);"
                    },
                    {
                        "username": "R_aghav",
                        "content": "At first i thought how to solve it against the given constraints , then observing the some test cases i see the result is somehow similar to sqrt(n) and its correct. It successfully accept the solution .How many thought the same one ."
                    },
                    {
                        "username": "shreshthpal",
                        "content": "Its a simple two step observation:\\n1. All divisor comes in pairs\\n12= 1*12 , 2*6 , 3*4  (1,2,3,4,6,12)\\n2. Only Perfect Squares have odd number of divisors\\n16 = 1*16, 2*8 ,4*4 (1,2,4,8,16)"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Just brainstormed a bit, noticed the pattern and guessed and it worked but I have no idea why it did."
                    },
                    {
                        "username": "officialkushagragupta",
                        "content": "1,1,1,1 round1\\n1,0,1,0 round2\\n1,0,0,0 round3\\n1,0,0,1 round4\\n\\n\\n1,1,1,1,1 round1\\n1,0,1,0,1 round2\\n1,0,0,0,1 round3\\n1,0,0,1,1 round4\\n1,0,0,1,0 round5\\n\\n\\n1,1,1,1,1,1 round1\\n1,0,1,0,1,0 round2\\n1,0,0,0,1,1 round3\\n1,0,0,1,1,1 round4\\n1,0,0,1,0,1 round5\\n1,0,0,1,0,0 round6\\n\\n\\n1,1,1,1,1,1,1 round1\\n1,0,1,0,1,0,1 round2\\n1,0,0,0,1,1,0  round3\\n1,0,0,1,1,1,0  round4\\n1,0,0,1,0,1,0  round5\\n1,0,0,1,0,0,0  round6\\n1,0,0,1,0,0,1  round7\\n\\nbut according to this ,for int n=7 , ans should be 3 and this pattern will follow hence we can also apply\\nans=((n-1 - 0)/3)+1.\\n\\nwhere am I going wrong?"
                    },
                    {
                        "username": "Noah492",
                        "content": "Looks like you didn\\'t carry the ending 1 from round 2 to 3. \\nSee below, answer should be 2:\\n\\n1,1,1,1,1,1,1 round1\\n1,0,1,0,1,0,1 round2\\n1,0,0,0,1,1,1 round3\\n1,0,0,1,1,1,1 round4\\n1,0,0,1,0,1,1 round5\\n1,0,0,1,0,0,1 round6\\n1,0,0,1,0,0,0 round7"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "the like dislike ratio says it all"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the like dislike ratio says that leetcoders really don\\'t appreciate having to think"
                    }
                ]
            },
            {
                "id": 1874949,
                "content": [
                    {
                        "username": "gaurav89830",
                        "content": "        return (int)Math.sqrt(n);\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem makes me think I\\'m stupid."
                    },
                    {
                        "username": "priyanshu8751",
                        "content": "# Tips for this problem\\n1. Solve for n = 1 to n = 10 and observe the pattern.\\n2. Yes, what you feel is correct and go by that logic to n = 15.\\n3. Try to give one liner."
                    },
                    {
                        "username": "AbirDey",
                        "content": "Can someone please explain why for n = 2, the answer should be 1, because -\\n1. firstly round one will toggle it on right?\\n2. then In the second round, it will be toggled off but again as it is the last round for n = 2, it will be toggled on right?\\n\\nSo the answer should be 2, but it says one.\\nHelp T_T"
                    },
                    {
                        "username": "Nicholasgkc",
                        "content": "When n=2, only toggled one time not two time"
                    },
                    {
                        "username": "wookhyun",
                        "content": "In the first round, it\\'s right to turn on all the lights that have been turned off. But rather than thinking that way, I think it\\'s easier to understand the problem by thinking that in the i-th round, the light bulb corresponding to the i-multiplier is toggle."
                    },
                    {
                        "username": "piyushverma17",
                        "content": "At first, the three bulbs are [off, off, off].\nAfter the first round, the three bulbs are [on, on, on].\nAfter the second round, the three bulbs are [on, off, on].\nAfter the third round, the three bulbs are [on, off, off]. \nSo you should return 1 because there is only one bulb is on.\n \ncode-> return (int)sqrt(n);"
                    },
                    {
                        "username": "R_aghav",
                        "content": "At first i thought how to solve it against the given constraints , then observing the some test cases i see the result is somehow similar to sqrt(n) and its correct. It successfully accept the solution .How many thought the same one ."
                    },
                    {
                        "username": "shreshthpal",
                        "content": "Its a simple two step observation:\\n1. All divisor comes in pairs\\n12= 1*12 , 2*6 , 3*4  (1,2,3,4,6,12)\\n2. Only Perfect Squares have odd number of divisors\\n16 = 1*16, 2*8 ,4*4 (1,2,4,8,16)"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Just brainstormed a bit, noticed the pattern and guessed and it worked but I have no idea why it did."
                    },
                    {
                        "username": "officialkushagragupta",
                        "content": "1,1,1,1 round1\\n1,0,1,0 round2\\n1,0,0,0 round3\\n1,0,0,1 round4\\n\\n\\n1,1,1,1,1 round1\\n1,0,1,0,1 round2\\n1,0,0,0,1 round3\\n1,0,0,1,1 round4\\n1,0,0,1,0 round5\\n\\n\\n1,1,1,1,1,1 round1\\n1,0,1,0,1,0 round2\\n1,0,0,0,1,1 round3\\n1,0,0,1,1,1 round4\\n1,0,0,1,0,1 round5\\n1,0,0,1,0,0 round6\\n\\n\\n1,1,1,1,1,1,1 round1\\n1,0,1,0,1,0,1 round2\\n1,0,0,0,1,1,0  round3\\n1,0,0,1,1,1,0  round4\\n1,0,0,1,0,1,0  round5\\n1,0,0,1,0,0,0  round6\\n1,0,0,1,0,0,1  round7\\n\\nbut according to this ,for int n=7 , ans should be 3 and this pattern will follow hence we can also apply\\nans=((n-1 - 0)/3)+1.\\n\\nwhere am I going wrong?"
                    },
                    {
                        "username": "Noah492",
                        "content": "Looks like you didn\\'t carry the ending 1 from round 2 to 3. \\nSee below, answer should be 2:\\n\\n1,1,1,1,1,1,1 round1\\n1,0,1,0,1,0,1 round2\\n1,0,0,0,1,1,1 round3\\n1,0,0,1,1,1,1 round4\\n1,0,0,1,0,1,1 round5\\n1,0,0,1,0,0,1 round6\\n1,0,0,1,0,0,0 round7"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "the like dislike ratio says it all"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the like dislike ratio says that leetcoders really don\\'t appreciate having to think"
                    }
                ]
            },
            {
                "id": 1874921,
                "content": [
                    {
                        "username": "vnk01",
                        "content": "Who thought about finding the number of prime factorizations in order to count the number of factors at i position? Feel pretty dumb after seeing the solution \\uD83D\\uDE15"
                    },
                    {
                        "username": "dinhlockt02",
                        "content": "Here is some hint:\n\n\n\nAlthough it's weird, you should print out cases if n == 3,4,5 and find out the same point of those cases. \nThen you should print case if n = 100 with index of them and you may know how to solve this problem lmao"
                    },
                    {
                        "username": "DetectiveCosteau",
                        "content": "So I guess the theme for the week is math tricks."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "sounds like my kinda week"
                    },
                    {
                        "username": "Surendra_143",
                        "content": "class Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return int(n**(0.5))"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "return sqrt(x)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "you should allow brute force for problems like that, otherwise what\\'s the point?\\none liner formula is not a coding problem"
                    },
                    {
                        "username": "dylankelly04",
                        "content": "Pretty funny seeing this here got this as an university entrance interview question"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "If it were not a daily challenge question, I wouldn\\'t attempt a question that has more downvotes than upvotes."
                    },
                    {
                        "username": "jerryy147",
                        "content": "feels like an easy rather than a medium once you understand the concept"
                    },
                    {
                        "username": "eduard92",
                        "content": "ah the brainteasers.... 100% I fail all interviews with questions like this."
                    }
                ]
            },
            {
                "id": 1874917,
                "content": [
                    {
                        "username": "vnk01",
                        "content": "Who thought about finding the number of prime factorizations in order to count the number of factors at i position? Feel pretty dumb after seeing the solution \\uD83D\\uDE15"
                    },
                    {
                        "username": "dinhlockt02",
                        "content": "Here is some hint:\n\n\n\nAlthough it's weird, you should print out cases if n == 3,4,5 and find out the same point of those cases. \nThen you should print case if n = 100 with index of them and you may know how to solve this problem lmao"
                    },
                    {
                        "username": "DetectiveCosteau",
                        "content": "So I guess the theme for the week is math tricks."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "sounds like my kinda week"
                    },
                    {
                        "username": "Surendra_143",
                        "content": "class Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return int(n**(0.5))"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "return sqrt(x)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "you should allow brute force for problems like that, otherwise what\\'s the point?\\none liner formula is not a coding problem"
                    },
                    {
                        "username": "dylankelly04",
                        "content": "Pretty funny seeing this here got this as an university entrance interview question"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "If it were not a daily challenge question, I wouldn\\'t attempt a question that has more downvotes than upvotes."
                    },
                    {
                        "username": "jerryy147",
                        "content": "feels like an easy rather than a medium once you understand the concept"
                    },
                    {
                        "username": "eduard92",
                        "content": "ah the brainteasers.... 100% I fail all interviews with questions like this."
                    }
                ]
            },
            {
                "id": 1874900,
                "content": [
                    {
                        "username": "vnk01",
                        "content": "Who thought about finding the number of prime factorizations in order to count the number of factors at i position? Feel pretty dumb after seeing the solution \\uD83D\\uDE15"
                    },
                    {
                        "username": "dinhlockt02",
                        "content": "Here is some hint:\n\n\n\nAlthough it's weird, you should print out cases if n == 3,4,5 and find out the same point of those cases. \nThen you should print case if n = 100 with index of them and you may know how to solve this problem lmao"
                    },
                    {
                        "username": "DetectiveCosteau",
                        "content": "So I guess the theme for the week is math tricks."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "sounds like my kinda week"
                    },
                    {
                        "username": "Surendra_143",
                        "content": "class Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return int(n**(0.5))"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "return sqrt(x)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "you should allow brute force for problems like that, otherwise what\\'s the point?\\none liner formula is not a coding problem"
                    },
                    {
                        "username": "dylankelly04",
                        "content": "Pretty funny seeing this here got this as an university entrance interview question"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "If it were not a daily challenge question, I wouldn\\'t attempt a question that has more downvotes than upvotes."
                    },
                    {
                        "username": "jerryy147",
                        "content": "feels like an easy rather than a medium once you understand the concept"
                    },
                    {
                        "username": "eduard92",
                        "content": "ah the brainteasers.... 100% I fail all interviews with questions like this."
                    }
                ]
            },
            {
                "id": 1874878,
                "content": [
                    {
                        "username": "vnk01",
                        "content": "Who thought about finding the number of prime factorizations in order to count the number of factors at i position? Feel pretty dumb after seeing the solution \\uD83D\\uDE15"
                    },
                    {
                        "username": "dinhlockt02",
                        "content": "Here is some hint:\n\n\n\nAlthough it's weird, you should print out cases if n == 3,4,5 and find out the same point of those cases. \nThen you should print case if n = 100 with index of them and you may know how to solve this problem lmao"
                    },
                    {
                        "username": "DetectiveCosteau",
                        "content": "So I guess the theme for the week is math tricks."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "sounds like my kinda week"
                    },
                    {
                        "username": "Surendra_143",
                        "content": "class Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return int(n**(0.5))"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "return sqrt(x)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "you should allow brute force for problems like that, otherwise what\\'s the point?\\none liner formula is not a coding problem"
                    },
                    {
                        "username": "dylankelly04",
                        "content": "Pretty funny seeing this here got this as an university entrance interview question"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "If it were not a daily challenge question, I wouldn\\'t attempt a question that has more downvotes than upvotes."
                    },
                    {
                        "username": "jerryy147",
                        "content": "feels like an easy rather than a medium once you understand the concept"
                    },
                    {
                        "username": "eduard92",
                        "content": "ah the brainteasers.... 100% I fail all interviews with questions like this."
                    }
                ]
            },
            {
                "id": 1874875,
                "content": [
                    {
                        "username": "vnk01",
                        "content": "Who thought about finding the number of prime factorizations in order to count the number of factors at i position? Feel pretty dumb after seeing the solution \\uD83D\\uDE15"
                    },
                    {
                        "username": "dinhlockt02",
                        "content": "Here is some hint:\n\n\n\nAlthough it's weird, you should print out cases if n == 3,4,5 and find out the same point of those cases. \nThen you should print case if n = 100 with index of them and you may know how to solve this problem lmao"
                    },
                    {
                        "username": "DetectiveCosteau",
                        "content": "So I guess the theme for the week is math tricks."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "sounds like my kinda week"
                    },
                    {
                        "username": "Surendra_143",
                        "content": "class Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return int(n**(0.5))"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "return sqrt(x)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "you should allow brute force for problems like that, otherwise what\\'s the point?\\none liner formula is not a coding problem"
                    },
                    {
                        "username": "dylankelly04",
                        "content": "Pretty funny seeing this here got this as an university entrance interview question"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "If it were not a daily challenge question, I wouldn\\'t attempt a question that has more downvotes than upvotes."
                    },
                    {
                        "username": "jerryy147",
                        "content": "feels like an easy rather than a medium once you understand the concept"
                    },
                    {
                        "username": "eduard92",
                        "content": "ah the brainteasers.... 100% I fail all interviews with questions like this."
                    }
                ]
            },
            {
                "id": 1874848,
                "content": [
                    {
                        "username": "vnk01",
                        "content": "Who thought about finding the number of prime factorizations in order to count the number of factors at i position? Feel pretty dumb after seeing the solution \\uD83D\\uDE15"
                    },
                    {
                        "username": "dinhlockt02",
                        "content": "Here is some hint:\n\n\n\nAlthough it's weird, you should print out cases if n == 3,4,5 and find out the same point of those cases. \nThen you should print case if n = 100 with index of them and you may know how to solve this problem lmao"
                    },
                    {
                        "username": "DetectiveCosteau",
                        "content": "So I guess the theme for the week is math tricks."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "sounds like my kinda week"
                    },
                    {
                        "username": "Surendra_143",
                        "content": "class Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return int(n**(0.5))"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "return sqrt(x)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "you should allow brute force for problems like that, otherwise what\\'s the point?\\none liner formula is not a coding problem"
                    },
                    {
                        "username": "dylankelly04",
                        "content": "Pretty funny seeing this here got this as an university entrance interview question"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "If it were not a daily challenge question, I wouldn\\'t attempt a question that has more downvotes than upvotes."
                    },
                    {
                        "username": "jerryy147",
                        "content": "feels like an easy rather than a medium once you understand the concept"
                    },
                    {
                        "username": "eduard92",
                        "content": "ah the brainteasers.... 100% I fail all interviews with questions like this."
                    }
                ]
            },
            {
                "id": 1874845,
                "content": [
                    {
                        "username": "vnk01",
                        "content": "Who thought about finding the number of prime factorizations in order to count the number of factors at i position? Feel pretty dumb after seeing the solution \\uD83D\\uDE15"
                    },
                    {
                        "username": "dinhlockt02",
                        "content": "Here is some hint:\n\n\n\nAlthough it's weird, you should print out cases if n == 3,4,5 and find out the same point of those cases. \nThen you should print case if n = 100 with index of them and you may know how to solve this problem lmao"
                    },
                    {
                        "username": "DetectiveCosteau",
                        "content": "So I guess the theme for the week is math tricks."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "sounds like my kinda week"
                    },
                    {
                        "username": "Surendra_143",
                        "content": "class Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return int(n**(0.5))"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "return sqrt(x)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "you should allow brute force for problems like that, otherwise what\\'s the point?\\none liner formula is not a coding problem"
                    },
                    {
                        "username": "dylankelly04",
                        "content": "Pretty funny seeing this here got this as an university entrance interview question"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "If it were not a daily challenge question, I wouldn\\'t attempt a question that has more downvotes than upvotes."
                    },
                    {
                        "username": "jerryy147",
                        "content": "feels like an easy rather than a medium once you understand the concept"
                    },
                    {
                        "username": "eduard92",
                        "content": "ah the brainteasers.... 100% I fail all interviews with questions like this."
                    }
                ]
            },
            {
                "id": 1874838,
                "content": [
                    {
                        "username": "vnk01",
                        "content": "Who thought about finding the number of prime factorizations in order to count the number of factors at i position? Feel pretty dumb after seeing the solution \\uD83D\\uDE15"
                    },
                    {
                        "username": "dinhlockt02",
                        "content": "Here is some hint:\n\n\n\nAlthough it's weird, you should print out cases if n == 3,4,5 and find out the same point of those cases. \nThen you should print case if n = 100 with index of them and you may know how to solve this problem lmao"
                    },
                    {
                        "username": "DetectiveCosteau",
                        "content": "So I guess the theme for the week is math tricks."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "sounds like my kinda week"
                    },
                    {
                        "username": "Surendra_143",
                        "content": "class Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return int(n**(0.5))"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "return sqrt(x)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "you should allow brute force for problems like that, otherwise what\\'s the point?\\none liner formula is not a coding problem"
                    },
                    {
                        "username": "dylankelly04",
                        "content": "Pretty funny seeing this here got this as an university entrance interview question"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "If it were not a daily challenge question, I wouldn\\'t attempt a question that has more downvotes than upvotes."
                    },
                    {
                        "username": "jerryy147",
                        "content": "feels like an easy rather than a medium once you understand the concept"
                    },
                    {
                        "username": "eduard92",
                        "content": "ah the brainteasers.... 100% I fail all interviews with questions like this."
                    }
                ]
            },
            {
                "id": 1874833,
                "content": [
                    {
                        "username": "vnk01",
                        "content": "Who thought about finding the number of prime factorizations in order to count the number of factors at i position? Feel pretty dumb after seeing the solution \\uD83D\\uDE15"
                    },
                    {
                        "username": "dinhlockt02",
                        "content": "Here is some hint:\n\n\n\nAlthough it's weird, you should print out cases if n == 3,4,5 and find out the same point of those cases. \nThen you should print case if n = 100 with index of them and you may know how to solve this problem lmao"
                    },
                    {
                        "username": "DetectiveCosteau",
                        "content": "So I guess the theme for the week is math tricks."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "sounds like my kinda week"
                    },
                    {
                        "username": "Surendra_143",
                        "content": "class Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return int(n**(0.5))"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "return sqrt(x)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "you should allow brute force for problems like that, otherwise what\\'s the point?\\none liner formula is not a coding problem"
                    },
                    {
                        "username": "dylankelly04",
                        "content": "Pretty funny seeing this here got this as an university entrance interview question"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "If it were not a daily challenge question, I wouldn\\'t attempt a question that has more downvotes than upvotes."
                    },
                    {
                        "username": "jerryy147",
                        "content": "feels like an easy rather than a medium once you understand the concept"
                    },
                    {
                        "username": "eduard92",
                        "content": "ah the brainteasers.... 100% I fail all interviews with questions like this."
                    }
                ]
            },
            {
                "id": 1874828,
                "content": [
                    {
                        "username": "vnk01",
                        "content": "Who thought about finding the number of prime factorizations in order to count the number of factors at i position? Feel pretty dumb after seeing the solution \\uD83D\\uDE15"
                    },
                    {
                        "username": "dinhlockt02",
                        "content": "Here is some hint:\n\n\n\nAlthough it's weird, you should print out cases if n == 3,4,5 and find out the same point of those cases. \nThen you should print case if n = 100 with index of them and you may know how to solve this problem lmao"
                    },
                    {
                        "username": "DetectiveCosteau",
                        "content": "So I guess the theme for the week is math tricks."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "sounds like my kinda week"
                    },
                    {
                        "username": "Surendra_143",
                        "content": "class Solution:\\n    def bulbSwitch(self, n: int) -> int:\\n        return int(n**(0.5))"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "return sqrt(x)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "you should allow brute force for problems like that, otherwise what\\'s the point?\\none liner formula is not a coding problem"
                    },
                    {
                        "username": "dylankelly04",
                        "content": "Pretty funny seeing this here got this as an university entrance interview question"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "If it were not a daily challenge question, I wouldn\\'t attempt a question that has more downvotes than upvotes."
                    },
                    {
                        "username": "jerryy147",
                        "content": "feels like an easy rather than a medium once you understand the concept"
                    },
                    {
                        "username": "eduard92",
                        "content": "ah the brainteasers.... 100% I fail all interviews with questions like this."
                    }
                ]
            }
        ]
    }
]